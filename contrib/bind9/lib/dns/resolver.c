begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2015  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/counter.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/socket.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/adb.h>
end_include

begin_include
include|#
directive|include
file|<dns/cache.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<dns/ds.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/forward.h>
end_include

begin_include
include|#
directive|include
file|<dns/keytable.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/ncache.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec3.h>
end_include

begin_include
include|#
directive|include
file|<dns/opcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/peer.h>
end_include

begin_include
include|#
directive|include
file|<dns/rbt.h>
end_include

begin_include
include|#
directive|include
file|<dns/rcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rootns.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_include
include|#
directive|include
file|<dns/validator.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WANT_QUERYTRACE
end_ifdef

begin_define
define|#
directive|define
name|RTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "res %p: %s", res, (m))
end_define

begin_define
define|#
directive|define
name|RRTRACE
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "res %p: %s", (r), (m))
end_define

begin_define
define|#
directive|define
name|FCTXTRACE
parameter_list|(
name|m
parameter_list|)
define|\
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fctx %p(%s): %s", \ 				      fctx, fctx->info, (m))
end_define

begin_define
define|#
directive|define
name|FCTXTRACE2
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
define|\
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fctx %p(%s): %s %s", \ 				      fctx, fctx->info, (m1), (m2))
end_define

begin_define
define|#
directive|define
name|FCTXTRACE3
parameter_list|(
name|m
parameter_list|,
name|res
parameter_list|)
define|\
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fctx %p(%s): [result: %s] %s", \ 				      fctx, fctx->info, \ 				      isc_result_totext(res), (m))
end_define

begin_define
define|#
directive|define
name|FCTXTRACE4
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|res
parameter_list|)
define|\
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fctx %p(%s): [result: %s] %s %s", \ 				      fctx, fctx->info, \ 				      isc_result_totext(res), (m1), (m2))
end_define

begin_define
define|#
directive|define
name|FTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fetch %p (fctx %p(%s)): %s", \ 				      fetch, fetch->private, \ 				      fetch->private->info, (m))
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "resquery %p (fctx %p(%s)): %s", \ 				      query, query->fctx, \ 				      query->fctx->info, (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RTRACE
parameter_list|(
name|m
parameter_list|)
value|do { UNUSED(m); } while (0)
end_define

begin_define
define|#
directive|define
name|RRTRACE
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|do { UNUSED(r); UNUSED(m); } while (0)
end_define

begin_define
define|#
directive|define
name|FCTXTRACE
parameter_list|(
name|m
parameter_list|)
value|do { UNUSED(m); } while (0)
end_define

begin_define
define|#
directive|define
name|FCTXTRACE2
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
value|do { UNUSED(m1); UNUSED(m2); } while (0)
end_define

begin_define
define|#
directive|define
name|FCTXTRACE3
parameter_list|(
name|m1
parameter_list|,
name|res
parameter_list|)
value|do { UNUSED(m1); UNUSED(res); } while (0)
end_define

begin_define
define|#
directive|define
name|FCTXTRACE4
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|res
parameter_list|)
define|\
value|do { UNUSED(m1); UNUSED(m2); UNUSED(res); } while (0)
end_define

begin_define
define|#
directive|define
name|FTRACE
parameter_list|(
name|m
parameter_list|)
value|do { UNUSED(m); } while (0)
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|do { UNUSED(m); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WANT_QUERYTRACE */
end_comment

begin_define
define|#
directive|define
name|US_PER_SEC
value|1000000U
end_define

begin_comment
comment|/*  * The maximum time we will wait for a single query.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SINGLE_QUERY_TIMEOUT
value|9U
end_define

begin_define
define|#
directive|define
name|MAX_SINGLE_QUERY_TIMEOUT_US
value|(MAX_SINGLE_QUERY_TIMEOUT*US_PER_SEC)
end_define

begin_comment
comment|/*  * We need to allow a individual query time to complete / timeout.  */
end_comment

begin_define
define|#
directive|define
name|MINIMUM_QUERY_TIMEOUT
value|(MAX_SINGLE_QUERY_TIMEOUT + 1U)
end_define

begin_comment
comment|/* The default time in seconds for the whole query to live. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_QUERY_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_QUERY_TIMEOUT
value|MINIMUM_QUERY_TIMEOUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The maximum time in seconds for the whole query to live. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXIMUM_QUERY_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|MAXIMUM_QUERY_TIMEOUT
value|30
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default maximum number of recursions to follow before giving up. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_RECURSION_DEPTH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_RECURSION_DEPTH
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default maximum number of iterative queries to allow before giving up. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_MAX_QUERIES
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_MAX_QUERIES
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of hash buckets for zone counters */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RES_DOMAIN_BUCKETS
end_ifndef

begin_define
define|#
directive|define
name|RES_DOMAIN_BUCKETS
value|523
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RES_NOBUCKET
value|0xffffffff
end_define

begin_comment
comment|/*%  * Maximum EDNS0 input packet size.  */
end_comment

begin_define
define|#
directive|define
name|RECV_BUFFER_SIZE
value|4096
end_define

begin_comment
comment|/* XXXRTH  Constant. */
end_comment

begin_comment
comment|/*%  * This defines the maximum number of timeouts we will permit before we  * disable EDNS0 on the query.  */
end_comment

begin_define
define|#
directive|define
name|MAX_EDNS0_TIMEOUTS
value|3
end_define

begin_typedef
typedef|typedef
name|struct
name|fetchctx
name|fetchctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|query
block|{
comment|/* Locked by task event serialization. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|dispatchmgr
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|dispatch
decl_stmt|;
name|isc_boolean_t
name|exclusivesocket
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|isc_socket_t
modifier|*
name|tcpsocket
decl_stmt|;
name|isc_time_t
name|start
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|dispentry
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct query
argument_list|)
name|link
expr_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_buffer_t
modifier|*
name|tsig
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|tsigkey
decl_stmt|;
name|isc_socketevent_t
name|sendevent
decl_stmt|;
name|int
name|ednsversion
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|unsigned
name|int
name|sends
decl_stmt|;
name|unsigned
name|int
name|connects
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|512
index|]
decl_stmt|;
block|}
name|resquery_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|QUERY_MAGIC
value|ISC_MAGIC('Q', '!', '!', '!')
end_define

begin_define
define|#
directive|define
name|VALID_QUERY
parameter_list|(
name|query
parameter_list|)
value|ISC_MAGIC_VALID(query, QUERY_MAGIC)
end_define

begin_define
define|#
directive|define
name|RESQUERY_ATTR_CANCELED
value|0x02
end_define

begin_define
define|#
directive|define
name|RESQUERY_CONNECTING
parameter_list|(
name|q
parameter_list|)
value|((q)->connects> 0)
end_define

begin_define
define|#
directive|define
name|RESQUERY_CANCELED
parameter_list|(
name|q
parameter_list|)
value|(((q)->attributes& \ 					  RESQUERY_ATTR_CANCELED) != 0)
end_define

begin_define
define|#
directive|define
name|RESQUERY_SENDING
parameter_list|(
name|q
parameter_list|)
value|((q)->sends> 0)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|fetchstate_init
init|=
literal|0
block|,
comment|/*%< Start event has not run yet. */
name|fetchstate_active
block|,
name|fetchstate_done
comment|/*%< FETCHDONE events posted. */
block|}
name|fetchstate
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|badns_unreachable
init|=
literal|0
block|,
name|badns_response
block|,
name|badns_validation
block|}
name|badnstype_t
typedef|;
end_typedef

begin_struct
struct|struct
name|fetchctx
block|{
comment|/*% Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|unsigned
name|int
name|dbucketnum
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/*% Locked by appropriate bucket lock. */
name|fetchstate
name|state
decl_stmt|;
name|isc_boolean_t
name|want_shutdown
decl_stmt|;
name|isc_boolean_t
name|cloned
decl_stmt|;
name|isc_boolean_t
name|spilled
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_event_t
name|control_event
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct fetchctx
argument_list|)
name|link
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_fetchevent_t
argument_list|)
name|events
expr_stmt|;
comment|/*% Locked by task event serialization. */
name|dns_name_t
name|domain
decl_stmt|;
name|dns_rdataset_t
name|nameservers
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|isc_time_t
name|expires
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|dns_message_t
modifier|*
name|qmessage
decl_stmt|;
name|dns_message_t
modifier|*
name|rmessage
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|resquery_t
argument_list|)
name|queries
expr_stmt|;
name|dns_adbfindlist_t
name|finds
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_adbfindlist_t
name|altfinds
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|altfind
decl_stmt|;
name|dns_adbaddrinfolist_t
name|forwaddrs
decl_stmt|;
name|dns_adbaddrinfolist_t
name|altaddrs
decl_stmt|;
name|isc_sockaddrlist_t
name|forwarders
decl_stmt|;
name|dns_fwdpolicy_t
name|fwdpolicy
decl_stmt|;
name|isc_sockaddrlist_t
name|bad
decl_stmt|;
name|isc_sockaddrlist_t
name|edns
decl_stmt|;
name|isc_sockaddrlist_t
name|edns512
decl_stmt|;
name|isc_sockaddrlist_t
name|bad_edns
decl_stmt|;
name|dns_validator_t
modifier|*
name|validator
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_validator_t
argument_list|)
name|validators
expr_stmt|;
name|dns_db_t
modifier|*
name|cache
decl_stmt|;
name|dns_adb_t
modifier|*
name|adb
decl_stmt|;
name|isc_boolean_t
name|ns_ttl_ok
decl_stmt|;
name|isc_uint32_t
name|ns_ttl
decl_stmt|;
name|isc_counter_t
modifier|*
name|qc
decl_stmt|;
comment|/*% 	 * The number of events we're waiting for. 	 */
name|unsigned
name|int
name|pending
decl_stmt|;
comment|/*% 	 * The number of times we've "restarted" the current 	 * nameserver set.  This acts as a failsafe to prevent 	 * us from pounding constantly on a particular set of 	 * servers that, for whatever reason, are not giving 	 * us useful responses, but are responding in such a 	 * way that they are not marked "bad". 	 */
name|unsigned
name|int
name|restarts
decl_stmt|;
comment|/*% 	 * The number of timeouts that have occurred since we 	 * last successfully received a response packet.  This 	 * is used for EDNS0 black hole detection. 	 */
name|unsigned
name|int
name|timeouts
decl_stmt|;
comment|/*% 	 * Look aside state for DS lookups. 	 */
name|dns_name_t
name|nsname
decl_stmt|;
name|dns_fetch_t
modifier|*
name|nsfetch
decl_stmt|;
name|dns_rdataset_t
name|nsrrset
decl_stmt|;
comment|/*% 	 * Number of queries that reference this context. 	 */
name|unsigned
name|int
name|nqueries
decl_stmt|;
comment|/*% 	 * The reason to print when logging a successful 	 * response to a query. 	 */
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
comment|/*% 	 * Random numbers to use for mixing up server addresses. 	 */
name|isc_uint32_t
name|rand_buf
decl_stmt|;
name|isc_uint32_t
name|rand_bits
decl_stmt|;
comment|/*% 	 * Fetch-local statistics for detailed logging. 	 */
name|isc_result_t
name|result
decl_stmt|;
comment|/*%< fetch result  */
name|isc_result_t
name|vresult
decl_stmt|;
comment|/*%< validation result  */
name|int
name|exitline
decl_stmt|;
name|isc_time_t
name|start
decl_stmt|;
name|isc_uint64_t
name|duration
decl_stmt|;
name|isc_boolean_t
name|logged
decl_stmt|;
name|unsigned
name|int
name|querysent
decl_stmt|;
name|unsigned
name|int
name|referrals
decl_stmt|;
name|unsigned
name|int
name|lamecount
decl_stmt|;
name|unsigned
name|int
name|quotacount
decl_stmt|;
name|unsigned
name|int
name|neterr
decl_stmt|;
name|unsigned
name|int
name|badresp
decl_stmt|;
name|unsigned
name|int
name|adberr
decl_stmt|;
name|unsigned
name|int
name|findfail
decl_stmt|;
name|unsigned
name|int
name|valfail
decl_stmt|;
name|isc_boolean_t
name|timeout
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|client
decl_stmt|;
name|unsigned
name|int
name|depth
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FCTX_MAGIC
value|ISC_MAGIC('F', '!', '!', '!')
end_define

begin_define
define|#
directive|define
name|VALID_FCTX
parameter_list|(
name|fctx
parameter_list|)
value|ISC_MAGIC_VALID(fctx, FCTX_MAGIC)
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_HAVEANSWER
value|0x0001
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_GLUING
value|0x0002
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_ADDRWAIT
value|0x0004
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_SHUTTINGDOWN
value|0x0008
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_WANTCACHE
value|0x0010
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_WANTNCACHE
value|0x0020
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_NEEDEDNS0
value|0x0040
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_TRIEDFIND
value|0x0080
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_TRIEDALT
value|0x0100
end_define

begin_define
define|#
directive|define
name|HAVE_ANSWER
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_HAVEANSWER) != \ 				 0)
end_define

begin_define
define|#
directive|define
name|GLUING
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_GLUING) != \ 				 0)
end_define

begin_define
define|#
directive|define
name|ADDRWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_ADDRWAIT) != \ 				 0)
end_define

begin_define
define|#
directive|define
name|SHUTTINGDOWN
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_SHUTTINGDOWN) \ 				 != 0)
end_define

begin_define
define|#
directive|define
name|WANTCACHE
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_WANTCACHE) != 0)
end_define

begin_define
define|#
directive|define
name|WANTNCACHE
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_WANTNCACHE) != 0)
end_define

begin_define
define|#
directive|define
name|NEEDEDNS0
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_NEEDEDNS0) != 0)
end_define

begin_define
define|#
directive|define
name|TRIEDFIND
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_TRIEDFIND) != 0)
end_define

begin_define
define|#
directive|define
name|TRIEDALT
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_TRIEDALT) != 0)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
block|}
name|dns_valarg_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_fetch
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|fetchctx_t
modifier|*
name|private
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_FETCH_MAGIC
value|ISC_MAGIC('F', 't', 'c', 'h')
end_define

begin_define
define|#
directive|define
name|DNS_FETCH_VALID
parameter_list|(
name|fetch
parameter_list|)
value|ISC_MAGIC_VALID(fetch, DNS_FETCH_MAGIC)
end_define

begin_typedef
typedef|typedef
struct|struct
name|fctxbucket
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|fetchctx_t
argument_list|)
name|fctxs
expr_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
block|}
name|fctxbucket_t
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|fctxcount
name|fctxcount_t
typedef|;
end_typedef

begin_struct
struct|struct
name|fctxcount
block|{
name|dns_fixedname_t
name|fdname
decl_stmt|;
name|dns_name_t
modifier|*
name|domain
decl_stmt|;
name|isc_uint32_t
name|count
decl_stmt|;
name|isc_uint32_t
name|allowed
decl_stmt|;
name|isc_uint32_t
name|dropped
decl_stmt|;
name|isc_stdtime_t
name|logged
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|fctxcount_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|zonebucket
block|{
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|fctxcount_t
argument_list|)
name|list
expr_stmt|;
block|}
name|zonebucket_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_FETCHLIMIT */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alternate
block|{
name|isc_boolean_t
name|isaddress
decl_stmt|;
union|union
block|{
name|isc_sockaddr_t
name|addr
decl_stmt|;
struct|struct
block|{
name|dns_name_t
name|name
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
block|}
name|_n
struct|;
block|}
name|_u
union|;
name|ISC_LINK
argument_list|(
argument|struct alternate
argument_list|)
name|link
expr_stmt|;
block|}
name|alternate_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_badcache
name|dns_badcache_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_badcache
block|{
name|dns_badcache_t
modifier|*
name|next
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|isc_time_t
name|expire
decl_stmt|;
name|unsigned
name|int
name|hashval
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_BADCACHE_SIZE
value|1021
end_define

begin_define
define|#
directive|define
name|DNS_BADCACHE_TTL
parameter_list|(
name|fctx
parameter_list|)
define|\
value|(((fctx)->res->lame_ttl> 30 ) ? (fctx)->res->lame_ttl : 30)
end_define

begin_struct
struct|struct
name|dns_resolver
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_mutex_t
name|nlock
decl_stmt|;
name|isc_mutex_t
name|primelock
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|socketmgr
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|timermgr
decl_stmt|;
name|isc_taskmgr_t
modifier|*
name|taskmgr
decl_stmt|;
name|dns_view_t
modifier|*
name|view
decl_stmt|;
name|isc_boolean_t
name|frozen
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|dispatchmgr
decl_stmt|;
name|dns_dispatchset_t
modifier|*
name|dispatches4
decl_stmt|;
name|isc_boolean_t
name|exclusivev4
decl_stmt|;
name|dns_dispatchset_t
modifier|*
name|dispatches6
decl_stmt|;
name|isc_boolean_t
name|exclusivev6
decl_stmt|;
name|unsigned
name|int
name|nbuckets
decl_stmt|;
name|fctxbucket_t
modifier|*
name|buckets
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|zonebucket_t
modifier|*
name|dbuckets
decl_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|isc_uint32_t
name|lame_ttl
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|alternate_t
argument_list|)
name|alternates
expr_stmt|;
name|isc_uint16_t
name|udpsize
decl_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|isc_rwlock_t
name|alglock
decl_stmt|;
endif|#
directive|endif
name|dns_rbt_t
modifier|*
name|algorithms
decl_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|isc_rwlock_t
name|mbslock
decl_stmt|;
endif|#
directive|endif
name|dns_rbt_t
modifier|*
name|mustbesecure
decl_stmt|;
name|unsigned
name|int
name|spillatmax
decl_stmt|;
name|unsigned
name|int
name|spillatmin
decl_stmt|;
name|isc_timer_t
modifier|*
name|spillattimer
decl_stmt|;
name|isc_boolean_t
name|zero_no_soa_ttl
decl_stmt|;
name|unsigned
name|int
name|query_timeout
decl_stmt|;
name|unsigned
name|int
name|maxdepth
decl_stmt|;
name|unsigned
name|int
name|maxqueries
decl_stmt|;
name|isc_result_t
name|quotaresp
index|[
literal|2
index|]
decl_stmt|;
comment|/* Locked by lock. */
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
name|isc_eventlist_t
name|whenshutdown
decl_stmt|;
name|unsigned
name|int
name|activebuckets
decl_stmt|;
name|isc_boolean_t
name|priming
decl_stmt|;
name|unsigned
name|int
name|spillat
decl_stmt|;
comment|/* clients-per-query */
name|unsigned
name|int
name|zspill
decl_stmt|;
comment|/* fetches-per-zone */
comment|/* Bad cache. */
name|dns_badcache_t
modifier|*
modifier|*
name|badcache
decl_stmt|;
name|unsigned
name|int
name|badcount
decl_stmt|;
name|unsigned
name|int
name|badhash
decl_stmt|;
name|unsigned
name|int
name|badsweep
decl_stmt|;
comment|/* Locked by primelock. */
name|dns_fetch_t
modifier|*
name|primefetch
decl_stmt|;
comment|/* Locked by nlock. */
name|unsigned
name|int
name|nfctx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RES_MAGIC
value|ISC_MAGIC('R', 'e', 's', '!')
end_define

begin_define
define|#
directive|define
name|VALID_RESOLVER
parameter_list|(
name|res
parameter_list|)
value|ISC_MAGIC_VALID(res, RES_MAGIC)
end_define

begin_comment
comment|/*%  * Private addrinfo flags.  These must not conflict with DNS_FETCHOPT_NOEDNS0,  * which we also use as an addrinfo flag.  */
end_comment

begin_define
define|#
directive|define
name|FCTX_ADDRINFO_MARK
value|0x0001
end_define

begin_define
define|#
directive|define
name|FCTX_ADDRINFO_FORWARDER
value|0x1000
end_define

begin_define
define|#
directive|define
name|FCTX_ADDRINFO_TRIED
value|0x2000
end_define

begin_define
define|#
directive|define
name|FCTX_ADDRINFO_EDNSOK
value|0x4000
end_define

begin_define
define|#
directive|define
name|UNMARKED
parameter_list|(
name|a
parameter_list|)
value|(((a)->flags& FCTX_ADDRINFO_MARK) \ 					 == 0)
end_define

begin_define
define|#
directive|define
name|ISFORWARDER
parameter_list|(
name|a
parameter_list|)
value|(((a)->flags& \ 					 FCTX_ADDRINFO_FORWARDER) != 0)
end_define

begin_define
define|#
directive|define
name|TRIED
parameter_list|(
name|a
parameter_list|)
value|(((a)->flags& \ 					 FCTX_ADDRINFO_TRIED) != 0)
end_define

begin_define
define|#
directive|define
name|EDNSOK
parameter_list|(
name|a
parameter_list|)
value|(((a)->flags& \ 					 FCTX_ADDRINFO_EDNSOK) != 0)
end_define

begin_define
define|#
directive|define
name|NXDOMAIN
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_NXDOMAIN) != 0)
end_define

begin_define
define|#
directive|define
name|NEGATIVE
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_NEGATIVE) != 0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|empty_bucket
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|resquery_send
parameter_list|(
name|resquery_t
modifier|*
name|query
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resquery_response
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resquery_connected
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fctx_try
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|retrying
parameter_list|,
name|isc_boolean_t
name|badcache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fctx_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|fctx_unlink
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|ncache_adderesult
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_db_t
modifier|*
name|cache
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_ttl_t
name|maxttl
parameter_list|,
name|isc_boolean_t
name|optout
parameter_list|,
name|isc_boolean_t
name|secure
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|isc_result_t
modifier|*
name|eresultp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validated
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|maybe_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|locked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_bad
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|isc_result_t
name|reason
parameter_list|,
name|badnstype_t
name|badtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|isc_result_t
name|findnoqname
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|noqname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fctx_increference
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|fctx_decreference
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%  * Increment resolver-related statistics counters.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|inc_stats
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|resstats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|res
operator|->
name|view
operator|->
name|resstats
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|valcreate
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|unsigned
name|int
name|valoptions
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|dns_validator_t
modifier|*
name|validator
init|=
name|NULL
decl_stmt|;
name|dns_valarg_t
modifier|*
name|valarg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|valarg
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|valarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valarg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|valarg
operator|->
name|fctx
operator|=
name|fctx
expr_stmt|;
name|valarg
operator|->
name|addrinfo
operator|=
name|addrinfo
expr_stmt|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
name|INSIST
argument_list|(
operator|(
name|valoptions
operator|&
name|DNS_VALIDATOR_DEFER
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_validator_create
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fctx
operator|->
name|rmessage
argument_list|,
name|valoptions
argument_list|,
name|task
argument_list|,
name|validated
argument_list|,
name|valarg
argument_list|,
operator|&
name|validator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|valoptions
operator|&
name|DNS_VALIDATOR_DEFER
operator|)
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|fctx
operator|->
name|validator
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|validator
operator|=
name|validator
expr_stmt|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|validators
argument_list|,
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|valarg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|valarg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|rrsig_fromchildzone
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|dns_namereln_t
name|namereln
decl_stmt|;
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|int
name|order
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
operator|&
name|rrsig
operator|.
name|signer
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|namereln
operator|==
name|dns_namereln_subdomain
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|fix_mustbedelegationornxdomain
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_name_t
modifier|*
name|domain
init|=
operator|&
name|fctx
operator|->
name|domain
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|keep_auth
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * A DS RRset can appear anywhere in a zone, even for a delegation-only 	 * zone.  So a response to an explicit query for this type should be 	 * excluded from delegation-only fixup. 	 * 	 * SOA, NS, and DNSKEY can only exist at a zone apex, so a postive 	 * response to a query for these types can never violate the 	 * delegation-only assumption: if the query name is below a 	 * zone cut, the response should normally be a referral, which should 	 * be accepted; if the query name is below a zone cut but the server 	 * happens to have authority for the zone of the query name, the 	 * response is a (non-referral) answer.  But this does not violate 	 * delegation-only because the query name must be in a different zone 	 * due to the "apex-only" nature of these types.  Note that if the 	 * remote server happens to have authority for a child zone of a 	 * delegation-only zone, we may still incorrectly "fix" the response 	 * with NXDOMAIN for queries for other types.  Unfortunately it's 	 * generally impossible to differentiate this case from violation of 	 * the delegation-only assumption.  Once the resolver learns the 	 * correct zone cut, possibly via a separate query for an "apex-only" 	 * type, queries for other types will be resolved correctly. 	 * 	 * A query for type ANY will be accepted if it hits an exceptional 	 * type above in the answer section as it should be from a child 	 * zone. 	 * 	 * Also accept answers with RRSIG records from the child zone. 	 * Direct queries for RRSIG records should not be answered from 	 * the parent zone. 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|!=
literal|0
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_dnskey
operator|)
condition|)
block|{
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
comment|/* 				 * RRsig from child? 				 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rrsig_fromchildzone
argument_list|(
name|fctx
argument_list|,
name|rdataset
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 				 * Direct query for apex records or DS. 				 */
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|type
operator|&&
operator|(
name|type
operator|==
name|dns_rdatatype_ds
operator|||
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|type
operator|==
name|dns_rdatatype_soa
operator|||
name|type
operator|==
name|dns_rdatatype_dnskey
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 				 * Indirect query for apex records or DS. 				 */
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|&&
operator|(
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|type
operator|==
name|dns_rdatatype_ds
operator|||
name|type
operator|==
name|dns_rdatatype_soa
operator|||
name|type
operator|==
name|dns_rdatatype_dnskey
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * A NODATA response to a DS query? 	 */
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|&&
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* Look for referral or indication of answer from child zone? */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|==
literal|0
condition|)
goto|goto
name|munge
goto|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
name|keep_auth
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_ns
operator|&&
name|type
operator|!=
name|dns_rdatatype_soa
operator|&&
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
if|if
condition|(
name|rrsig_fromchildzone
argument_list|(
name|fctx
argument_list|,
name|rdataset
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
else|else
continue|continue;
block|}
comment|/* NS or SOA records. */
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
block|{
comment|/* 				 * If a query for ANY causes a negative 				 * response, we can be sure that this is 				 * an empty node.  For other type of queries 				 * we cannot differentiate an empty node 				 * from a node that just doesn't have that 				 * type of record.  We only accept the former 				 * case. 				 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
block|{
comment|/* Referral or answer from child zone. */
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|munge
label|:
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_nxdomain
expr_stmt|;
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keep_auth
condition|)
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|=
literal|0
expr_stmt|;
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ADDITIONAL
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_starttimer
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
comment|/* 	 * Start the lifetime timer for fctx. 	 * 	 * This is also used for stopping the idle timer; in that 	 * case we must purge events already posted to ensure that 	 * no further idle events are delivered. 	 */
return|return
operator|(
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
operator|&
name|fctx
operator|->
name|expires
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_stoptimer
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * We don't return a result if resetting the timer to inactive fails 	 * since there's nothing to be done about it.  Resetting to inactive 	 * should never fail anyway, since the code as currently written 	 * cannot fail in that case. 	 */
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|timer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timer_reset(): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_startidletimer
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_interval_t
modifier|*
name|interval
parameter_list|)
block|{
comment|/* 	 * Start the idle timer for fctx.  The lifetime timer continues 	 * to be in effect. 	 */
return|return
operator|(
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
operator|&
name|fctx
operator|->
name|expires
argument_list|,
name|interval
argument_list|,
name|ISC_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stopping the idle timer is equivalent to calling fctx_starttimer(), but  * we use fctx_stopidletimer for readability in the code below.  */
end_comment

begin_define
define|#
directive|define
name|fctx_stopidletimer
value|fctx_starttimer
end_define

begin_function
specifier|static
specifier|inline
name|void
name|resquery_destroy
parameter_list|(
name|resquery_t
modifier|*
modifier|*
name|queryp
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|empty
decl_stmt|;
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|REQUIRE
argument_list|(
name|queryp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|query
operator|=
operator|*
name|queryp
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|query
operator|->
name|tcpsocket
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucket
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|fctx
operator|->
name|nqueries
operator|--
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucket
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|empty
operator|=
name|fctx_decreference
argument_list|(
name|query
operator|->
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucket
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|query
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|query
operator|->
name|mctx
argument_list|,
name|query
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|queryp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cancelquery
parameter_list|(
name|resquery_t
modifier|*
modifier|*
name|queryp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
modifier|*
name|deventp
parameter_list|,
name|isc_time_t
modifier|*
name|finish
parameter_list|,
name|isc_boolean_t
name|no_response
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|unsigned
name|int
name|rtt
decl_stmt|,
name|rttms
decl_stmt|;
name|unsigned
name|int
name|factor
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|query
operator|=
operator|*
name|queryp
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"cancelquery"
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|RESQUERY_CANCELED
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|->
name|attributes
operator||=
name|RESQUERY_ATTR_CANCELED
expr_stmt|;
comment|/* 	 * Should we update the RTT? 	 */
if|if
condition|(
name|finish
operator|!=
name|NULL
operator|||
name|no_response
condition|)
block|{
if|if
condition|(
name|finish
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have both the start and finish times for this 			 * packet, so we can compute a real RTT. 			 */
name|rtt
operator|=
operator|(
name|unsigned
name|int
operator|)
name|isc_time_microdiff
argument_list|(
name|finish
argument_list|,
operator|&
name|query
operator|->
name|start
argument_list|)
expr_stmt|;
name|factor
operator|=
name|DNS_ADB_RTTADJDEFAULT
expr_stmt|;
name|rttms
operator|=
name|rtt
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|rttms
operator|<
name|DNS_RESOLVER_QRYRTTCLASS0
condition|)
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_queryrtt0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rttms
operator|<
name|DNS_RESOLVER_QRYRTTCLASS1
condition|)
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_queryrtt1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rttms
operator|<
name|DNS_RESOLVER_QRYRTTCLASS2
condition|)
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_queryrtt2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rttms
operator|<
name|DNS_RESOLVER_QRYRTTCLASS3
condition|)
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_queryrtt3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rttms
operator|<
name|DNS_RESOLVER_QRYRTTCLASS4
condition|)
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_queryrtt4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_queryrtt5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We don't have an RTT for this query.  Maybe the 			 * packet was lost, or maybe this server is very 			 * slow.  We don't know.  Increase the RTT. 			 */
name|INSIST
argument_list|(
name|no_response
argument_list|)
expr_stmt|;
name|rtt
operator|=
name|query
operator|->
name|addrinfo
operator|->
name|srtt
operator|+
literal|200000
expr_stmt|;
if|if
condition|(
name|rtt
operator|>
name|MAX_SINGLE_QUERY_TIMEOUT_US
condition|)
name|rtt
operator|=
name|MAX_SINGLE_QUERY_TIMEOUT_US
expr_stmt|;
comment|/* 			 * Replace the current RTT with our value. 			 */
name|factor
operator|=
name|DNS_ADB_RTTADJREPLACE
expr_stmt|;
name|dns_adb_timeout
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|)
expr_stmt|;
block|}
name|dns_adb_adjustsrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|rtt
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|dns_adb_endudpfetch
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
comment|/* 	 * Age RTTs of servers not tried. 	 */
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish
operator|!=
name|NULL
condition|)
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_agesrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish
operator|!=
name|NULL
operator|&&
name|TRIEDFIND
argument_list|(
name|fctx
argument_list|)
condition|)
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
control|)
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_agesrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish
operator|!=
name|NULL
operator|&&
name|TRIEDALT
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_agesrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
control|)
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_agesrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for any outstanding socket events.  If they exist, cancel 	 * them and let the event handlers finish the cleanup.  The resolver 	 * only needs to worry about managing the connect and send events; 	 * the dispatcher manages the recv events. 	 */
if|if
condition|(
name|RESQUERY_CONNECTING
argument_list|(
name|query
argument_list|)
condition|)
block|{
comment|/* 		 * Cancel the connect. 		 */
if|if
condition|(
name|query
operator|->
name|tcpsocket
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_cancel
argument_list|(
name|query
operator|->
name|tcpsocket
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKCANCEL_CONNECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|query
operator|->
name|dispentry
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|query
operator|->
name|exclusivesocket
argument_list|)
expr_stmt|;
name|sock
operator|=
name|dns_dispatch_getentrysocket
argument_list|(
name|query
operator|->
name|dispentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
name|NULL
condition|)
name|isc_socket_cancel
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKCANCEL_CONNECT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|RESQUERY_SENDING
argument_list|(
name|query
argument_list|)
condition|)
block|{
comment|/* 		 * Cancel the pending send. 		 */
if|if
condition|(
name|query
operator|->
name|exclusivesocket
operator|&&
name|query
operator|->
name|dispentry
operator|!=
name|NULL
condition|)
name|sock
operator|=
name|dns_dispatch_getentrysocket
argument_list|(
name|query
operator|->
name|dispentry
argument_list|)
expr_stmt|;
else|else
name|sock
operator|=
name|dns_dispatch_getsocket
argument_list|(
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
name|NULL
condition|)
name|isc_socket_cancel
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKCANCEL_SEND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|->
name|dispentry
operator|!=
name|NULL
condition|)
name|dns_dispatch_removeresponse
argument_list|(
operator|&
name|query
operator|->
name|dispentry
argument_list|,
name|deventp
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|queries
argument_list|,
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tsig
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|query
operator|->
name|tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tsigkey
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|query
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|dispatch
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|RESQUERY_CONNECTING
argument_list|(
name|query
argument_list|)
operator|||
name|RESQUERY_SENDING
argument_list|(
name|query
argument_list|)
operator|)
condition|)
comment|/* 		 * It's safe to destroy the query now. 		 */
name|resquery_destroy
argument_list|(
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cancelqueries
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|no_response
parameter_list|)
block|{
name|resquery_t
modifier|*
name|query
decl_stmt|,
modifier|*
name|next_query
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"cancelqueries"
argument_list|)
expr_stmt|;
for|for
control|(
name|query
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
init|;
name|query
operator|!=
name|NULL
condition|;
name|query
operator|=
name|next_query
control|)
block|{
name|next_query
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupfinds
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|,
modifier|*
name|next_find
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|next_find
control|)
block|{
name|next_find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|finds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupaltfinds
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|,
modifier|*
name|next_find
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|next_find
control|)
block|{
name|next_find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|altfind
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupforwaddrs
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addr
decl_stmt|,
modifier|*
name|next_addr
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_addr
control|)
block|{
name|next_addr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|,
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_freeaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupaltaddrs
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addr
decl_stmt|,
modifier|*
name|next_addr
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_addr
control|)
block|{
name|next_addr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|,
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_freeaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_stopeverything
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|no_response
parameter_list|)
block|{
name|FCTXTRACE
argument_list|(
literal|"stopeverything"
argument_list|)
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_stoptimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
end_ifdef

begin_function
specifier|static
name|void
name|fcount_logspill
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|fctxcount_t
modifier|*
name|counter
parameter_list|)
block|{
name|char
name|dbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOG_INFO
argument_list|)
condition|)
return|return;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|->
name|logged
operator|>
name|now
operator|-
literal|60
condition|)
return|return;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|dbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_SPILL
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"too many simultaneous fetches for %s "
literal|"(allowed %d spilled %d)"
argument_list|,
name|dbuf
argument_list|,
name|counter
operator|->
name|allowed
argument_list|,
name|counter
operator|->
name|dropped
argument_list|)
expr_stmt|;
name|counter
operator|->
name|logged
operator|=
name|now
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fcount_incr
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|force
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|zonebucket_t
modifier|*
name|dbucket
decl_stmt|;
name|fctxcount_t
modifier|*
name|counter
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|,
name|spill
decl_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|res
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|dbucketnum
operator|==
name|RES_NOBUCKET
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|dns_name_fullhash
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|ISC_FALSE
argument_list|)
operator|%
name|RES_DOMAIN_BUCKETS
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spill
operator|=
name|fctx
operator|->
name|res
operator|->
name|zspill
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dbucket
operator|=
operator|&
name|fctx
operator|->
name|res
operator|->
name|dbuckets
index|[
name|bucketnum
index|]
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|dbucket
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dbucket
operator|->
name|list
argument_list|)
init|;
name|counter
operator|!=
name|NULL
condition|;
name|counter
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|counter
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dns_name_equal
argument_list|(
name|counter
operator|->
name|domain
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|counter
operator|==
name|NULL
condition|)
block|{
name|counter
operator|=
name|isc_mem_get
argument_list|(
name|dbucket
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|fctxcount_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|==
name|NULL
condition|)
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
else|else
block|{
name|ISC_LINK_INIT
argument_list|(
name|counter
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|counter
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|counter
operator|->
name|logged
operator|=
literal|0
expr_stmt|;
name|counter
operator|->
name|allowed
operator|=
literal|1
expr_stmt|;
name|counter
operator|->
name|dropped
operator|=
literal|0
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|counter
operator|->
name|fdname
argument_list|)
expr_stmt|;
name|counter
operator|->
name|domain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|counter
operator|->
name|fdname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|counter
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|dbucket
operator|->
name|list
argument_list|,
name|counter
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|spill
operator|!=
literal|0
operator|&&
name|counter
operator|->
name|count
operator|>=
name|spill
condition|)
block|{
name|counter
operator|->
name|dropped
operator|++
expr_stmt|;
name|fcount_logspill
argument_list|(
name|fctx
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_QUOTA
expr_stmt|;
block|}
else|else
block|{
name|counter
operator|->
name|count
operator|++
expr_stmt|;
name|counter
operator|->
name|allowed
operator|++
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|dbucket
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|fctx
operator|->
name|dbucketnum
operator|=
name|bucketnum
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fcount_decr
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|zonebucket_t
modifier|*
name|dbucket
decl_stmt|;
name|fctxcount_t
modifier|*
name|counter
decl_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|dbucketnum
operator|==
name|RES_NOBUCKET
condition|)
return|return;
name|dbucket
operator|=
operator|&
name|fctx
operator|->
name|res
operator|->
name|dbuckets
index|[
name|fctx
operator|->
name|dbucketnum
index|]
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|dbucket
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dbucket
operator|->
name|list
argument_list|)
init|;
name|counter
operator|!=
name|NULL
condition|;
name|counter
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|counter
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dns_name_equal
argument_list|(
name|counter
operator|->
name|domain
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|counter
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|counter
operator|->
name|count
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|counter
operator|->
name|count
operator|--
expr_stmt|;
name|fctx
operator|->
name|dbucketnum
operator|=
name|RES_NOBUCKET
expr_stmt|;
if|if
condition|(
name|counter
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|dbucket
operator|->
name|list
argument_list|,
name|counter
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|dbucket
operator|->
name|mctx
argument_list|,
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|counter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|dbucket
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_FETCHLIMIT */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|fctx_sendevents
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|isc_interval_t
name|i
decl_stmt|;
name|isc_boolean_t
name|logit
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|unsigned
name|int
name|old_spillat
decl_stmt|;
name|unsigned
name|int
name|new_spillat
init|=
literal|0
decl_stmt|;
comment|/* initialized to silence 					   compiler warnings */
comment|/* 	 * Caller must be holding the appropriate bucket lock. 	 */
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"sendevents"
argument_list|)
expr_stmt|;
comment|/* 	 * Keep some record of fetch result for logging later (if required). 	 */
name|fctx
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|fctx
operator|->
name|exitline
operator|=
name|line
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|duration
operator|=
name|isc_time_microdiff
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|fctx
operator|->
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|task
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|fctx
expr_stmt|;
name|event
operator|->
name|vresult
operator|=
name|fctx
operator|->
name|vresult
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
name|event
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|||
name|dns_rdataset_isassociated
argument_list|(
name|event
operator|->
name|rdataset
argument_list|)
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_sig
argument_list|)
expr_stmt|;
comment|/* 		 * Negative results must be indicated in event->result. 		 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|event
operator|->
name|rdataset
argument_list|)
operator|&&
name|NEGATIVE
argument_list|(
name|event
operator|->
name|rdataset
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|event
operator|->
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
operator|||
name|event
operator|->
name|result
operator|==
name|DNS_R_NCACHENXRRSET
argument_list|)
expr_stmt|;
block|}
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fctx
operator|->
name|attributes
operator|&
name|FCTX_ATTR_HAVEANSWER
operator|)
operator|!=
literal|0
operator|&&
name|fctx
operator|->
name|spilled
operator|&&
operator|(
name|count
operator|<
name|fctx
operator|->
name|res
operator|->
name|spillatmax
operator|||
name|fctx
operator|->
name|res
operator|->
name|spillatmax
operator|==
literal|0
operator|)
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|fctx
operator|->
name|res
operator|->
name|spillat
operator|&&
operator|!
name|fctx
operator|->
name|res
operator|->
name|exiting
condition|)
block|{
name|old_spillat
operator|=
name|fctx
operator|->
name|res
operator|->
name|spillat
expr_stmt|;
name|fctx
operator|->
name|res
operator|->
name|spillat
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|res
operator|->
name|spillat
operator|>
name|fctx
operator|->
name|res
operator|->
name|spillatmax
operator|&&
name|fctx
operator|->
name|res
operator|->
name|spillatmax
operator|!=
literal|0
condition|)
name|fctx
operator|->
name|res
operator|->
name|spillat
operator|=
name|fctx
operator|->
name|res
operator|->
name|spillatmax
expr_stmt|;
name|new_spillat
operator|=
name|fctx
operator|->
name|res
operator|->
name|spillat
expr_stmt|;
if|if
condition|(
name|new_spillat
operator|!=
name|old_spillat
condition|)
block|{
name|logit
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
literal|20
operator|*
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|spillattimer
argument_list|,
name|isc_timertype_ticker
argument_list|,
name|NULL
argument_list|,
operator|&
name|i
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|logit
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"clients-per-query increased to %u"
argument_list|,
name|new_spillat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_edns
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|fctx
operator|->
name|reason
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * We do not know if fctx->domain is the actual domain the record 	 * lives in or a parent domain so we have a '?' after it. 	 */
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_EDNS_DISABLED
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"success resolving '%s' (in '%s'?) after %s"
argument_list|,
name|fctx
operator|->
name|info
argument_list|,
name|domainbuf
argument_list|,
name|fctx
operator|->
name|reason
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|reason
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_done
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|no_response
decl_stmt|;
name|REQUIRE
argument_list|(
name|line
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/*% 		 * Log any deferred EDNS timeout messages. 		 */
name|log_edns
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|no_response
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|no_response
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|reason
operator|=
name|NULL
expr_stmt|;
name|fctx_stopeverything
argument_list|(
name|fctx
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|state
operator|=
name|fetchstate_done
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
name|fctx_sendevents
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_sendevent
parameter_list|(
name|resquery_t
modifier|*
name|query
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|isc_boolean_t
name|destroy_query
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|retry
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
if|if
condition|(
name|RESQUERY_CANCELED
argument_list|(
name|query
argument_list|)
condition|)
block|{
if|if
condition|(
name|query
operator|->
name|sends
operator|==
literal|0
operator|&&
name|query
operator|->
name|connects
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This query was canceled while the 			 * isc_socket_sendto/connect() was in progress. 			 */
if|if
condition|(
name|query
operator|->
name|tcpsocket
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|destroy_query
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|sevent
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
break|break;
case|case
name|ISC_R_HOSTUNREACH
case|:
case|case
name|ISC_R_NETUNREACH
case|:
case|case
name|ISC_R_NOPERM
case|:
case|case
name|ISC_R_ADDRNOTAVAIL
case|:
case|case
name|ISC_R_CONNREFUSED
case|:
name|FCTXTRACE3
argument_list|(
literal|"query canceled in sendevent(): "
literal|"no route to host; no response"
argument_list|,
name|sevent
operator|->
name|result
argument_list|)
expr_stmt|;
comment|/* 			 * No route to remote. 			 */
name|add_bad
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|sevent
operator|->
name|result
argument_list|,
name|badns_unreachable
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|retry
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
default|default:
name|FCTXTRACE3
argument_list|(
literal|"query canceled in sendevent() due to "
literal|"unexpected event result; responding"
argument_list|,
name|sevent
operator|->
name|result
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_CONNECT
condition|)
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
condition|)
block|{
comment|/* 		 * Behave as if the idle timer has expired.  For TCP 		 * this may not actually reflect the latest timer. 		 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|destroy_query
condition|)
name|resquery_destroy
argument_list|(
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_udpconnected
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_CONNECT
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"udpconnected"
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|RESQUERY_CONNECTING
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|->
name|connects
operator|--
expr_stmt|;
name|process_sendevent
argument_list|(
name|query
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_senddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_SENDDONE
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"senddone"
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH 	 * 	 * Currently we don't wait for the senddone event before retrying 	 * a query.  This means that if we get really behind, we may end 	 * up doing extra work! 	 */
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|RESQUERY_SENDING
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|->
name|sends
operator|--
expr_stmt|;
name|process_sendevent
argument_list|(
name|query
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_addopt
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|unsigned
name|int
name|version
parameter_list|,
name|isc_uint16_t
name|udpsize
parameter_list|,
name|dns_ednsopt_t
modifier|*
name|ednsopts
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_message_buildopt
argument_list|(
name|message
argument_list|,
operator|&
name|rdataset
argument_list|,
name|version
argument_list|,
name|udpsize
argument_list|,
name|DNS_MESSAGEEXTFLAG_DO
argument_list|,
name|ednsopts
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
return|return
operator|(
name|dns_message_setopt
argument_list|(
name|message
argument_list|,
name|rdataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_setretryinterval
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|unsigned
name|int
name|rtt
parameter_list|)
block|{
name|unsigned
name|int
name|seconds
decl_stmt|;
name|unsigned
name|int
name|us
decl_stmt|;
comment|/* 	 * We retry every .8 seconds the first two times through the address 	 * list, and then we do exponential back-off. 	 */
if|if
condition|(
name|fctx
operator|->
name|restarts
operator|<
literal|3
condition|)
name|us
operator|=
literal|800000
expr_stmt|;
else|else
name|us
operator|=
operator|(
literal|800000
operator|<<
operator|(
name|fctx
operator|->
name|restarts
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Add a fudge factor to the expected rtt based on the current 	 * estimate. 	 */
if|if
condition|(
name|rtt
operator|<
literal|50000
condition|)
name|rtt
operator|+=
literal|50000
expr_stmt|;
elseif|else
if|if
condition|(
name|rtt
operator|<
literal|100000
condition|)
name|rtt
operator|+=
literal|100000
expr_stmt|;
else|else
name|rtt
operator|+=
literal|200000
expr_stmt|;
comment|/* 	 * Always wait for at least the expected rtt. 	 */
if|if
condition|(
name|us
operator|<
name|rtt
condition|)
name|us
operator|=
name|rtt
expr_stmt|;
comment|/* 	 * But don't ever wait for more than 10 seconds. 	 */
if|if
condition|(
name|us
operator|>
name|MAX_SINGLE_QUERY_TIMEOUT_US
condition|)
name|us
operator|=
name|MAX_SINGLE_QUERY_TIMEOUT_US
expr_stmt|;
name|seconds
operator|=
name|us
operator|/
name|US_PER_SEC
expr_stmt|;
name|us
operator|-=
name|seconds
operator|*
name|US_PER_SEC
expr_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|fctx
operator|->
name|interval
argument_list|,
name|seconds
argument_list|,
name|us
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fctx_query
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|isc_sockaddr_t
name|addr
decl_stmt|;
name|isc_boolean_t
name|have_addr
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|srtt
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"query"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|task
operator|=
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
expr_stmt|;
name|srtt
operator|=
name|addrinfo
operator|->
name|srtt
expr_stmt|;
comment|/* 	 * A forwarder needs to make multiple queries. Give it at least 	 * a second to do these in. 	 */
if|if
condition|(
name|ISFORWARDER
argument_list|(
name|addrinfo
argument_list|)
operator|&&
name|srtt
operator|<
literal|1000000
condition|)
name|srtt
operator|=
literal|1000000
expr_stmt|;
name|fctx_setretryinterval
argument_list|(
name|fctx
argument_list|,
name|srtt
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_startidletimer
argument_list|(
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|dns_message_reset
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|)
expr_stmt|;
name|query
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|stop_idle_timer
goto|;
block|}
name|query
operator|->
name|mctx
operator|=
name|fctx
operator|->
name|mctx
expr_stmt|;
name|query
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|query
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|sends
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|connects
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Note that the caller MUST guarantee that 'addrinfo' will remain 	 * valid until this query is canceled. 	 */
name|query
operator|->
name|addrinfo
operator|=
name|addrinfo
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|query
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a TCP query, then we need to make a socket and 	 * a dispatch for it here.  Otherwise we use the resolver's 	 * shared dispatch. 	 */
name|query
operator|->
name|dispatchmgr
operator|=
name|res
operator|->
name|dispatchmgr
expr_stmt|;
name|query
operator|->
name|dispatch
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|exclusivesocket
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|tcpsocket
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|peers
operator|!=
name|NULL
condition|)
block|{
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|dstip
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|dstip
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_peerlist_peerbyaddr
argument_list|(
name|res
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|dstip
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_peer_getquerysource
argument_list|(
name|peer
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_addr
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|pf
decl_stmt|;
name|pf
operator|=
name|isc_sockaddr_pf
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
switch|switch
condition|(
name|pf
condition|)
block|{
case|case
name|PF_INET
case|:
name|result
operator|=
name|dns_dispatch_getlocaladdress
argument_list|(
name|res
operator|->
name|dispatches4
operator|->
name|dispatches
index|[
literal|0
index|]
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|result
operator|=
name|dns_dispatch_getlocaladdress
argument_list|(
name|res
operator|->
name|dispatches6
operator|->
name|dispatches
index|[
literal|0
index|]
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_query
goto|;
block|}
name|isc_sockaddr_setport
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_create
argument_list|(
name|res
operator|->
name|socketmgr
argument_list|,
name|pf
argument_list|,
name|isc_sockettype_tcp
argument_list|,
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_query
goto|;
ifndef|#
directive|ifndef
name|BROKEN_TCP_BIND_BEFORE_CONNECT
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|query
operator|->
name|tcpsocket
argument_list|,
operator|&
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_socket
goto|;
endif|#
directive|endif
comment|/* 		 * A dispatch will be created once the connect succeeds. 		 */
block|}
else|else
block|{
if|if
condition|(
name|have_addr
condition|)
block|{
name|unsigned
name|int
name|attrs
decl_stmt|,
name|attrmask
decl_stmt|;
name|attrs
operator|=
name|DNS_DISPATCHATTR_UDP
expr_stmt|;
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|attrs
operator||=
name|DNS_DISPATCHATTR_IPV4
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|attrs
operator||=
name|DNS_DISPATCHATTR_IPV6
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|cleanup_query
goto|;
block|}
name|attrmask
operator|=
name|DNS_DISPATCHATTR_UDP
expr_stmt|;
name|attrmask
operator||=
name|DNS_DISPATCHATTR_TCP
expr_stmt|;
name|attrmask
operator||=
name|DNS_DISPATCHATTR_IPV4
expr_stmt|;
name|attrmask
operator||=
name|DNS_DISPATCHATTR_IPV6
expr_stmt|;
name|result
operator|=
name|dns_dispatch_getudp
argument_list|(
name|res
operator|->
name|dispatchmgr
argument_list|,
name|res
operator|->
name|socketmgr
argument_list|,
name|res
operator|->
name|taskmgr
argument_list|,
operator|&
name|addr
argument_list|,
literal|4096
argument_list|,
literal|1000
argument_list|,
literal|32768
argument_list|,
literal|16411
argument_list|,
literal|16433
argument_list|,
name|attrs
argument_list|,
name|attrmask
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_query
goto|;
block|}
else|else
block|{
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
name|dns_dispatch_attach
argument_list|(
name|dns_resolver_dispatchv4
argument_list|(
name|res
argument_list|)
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|query
operator|->
name|exclusivesocket
operator|=
name|res
operator|->
name|exclusivev4
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|dns_dispatch_attach
argument_list|(
name|dns_resolver_dispatchv6
argument_list|(
name|res
argument_list|)
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|query
operator|->
name|exclusivesocket
operator|=
name|res
operator|->
name|exclusivev6
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|cleanup_query
goto|;
block|}
block|}
comment|/* 		 * We should always have a valid dispatcher here.  If we 		 * don't support a protocol family, then its dispatcher 		 * will be NULL, but we shouldn't be finding addresses for 		 * protocol types we don't support, so the dispatcher 		 * we found should never be NULL. 		 */
name|INSIST
argument_list|(
name|query
operator|->
name|dispatch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|query
operator|->
name|dispentry
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|fctx
operator|=
name|fctx
expr_stmt|;
comment|/* reference added by caller */
name|query
operator|->
name|tsig
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|tsigkey
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query
operator|->
name|magic
operator|=
name|QUERY_MAGIC
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Connect to the remote server. 		 * 		 * XXXRTH  Should we attach to the socket? 		 */
name|result
operator|=
name|isc_socket_connect
argument_list|(
name|query
operator|->
name|tcpsocket
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|task
argument_list|,
name|resquery_connected
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_socket
goto|;
name|query
operator|->
name|connects
operator|++
expr_stmt|;
name|QTRACE
argument_list|(
literal|"connecting via TCP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
if|if
condition|(
name|dns_adbentry_overquota
argument_list|(
name|addrinfo
operator|->
name|entry
argument_list|)
condition|)
goto|goto
name|cleanup_dispatch
goto|;
comment|/* Inform the ADB that we're starting a fetch */
name|dns_adb_beginudpfetch
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|result
operator|=
name|resquery_send
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_dispatch
goto|;
block|}
name|fctx
operator|->
name|querysent
operator|++
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|queries
argument_list|,
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query
operator|->
name|fctx
operator|->
name|nqueries
operator|++
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
operator|==
name|PF_INET
condition|)
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_queryv4
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_queryv6
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|resquerystats
operator|!=
name|NULL
condition|)
name|dns_rdatatypestats_increment
argument_list|(
name|res
operator|->
name|view
operator|->
name|resquerystats
argument_list|,
name|fctx
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_socket
label|:
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|cleanup_dispatch
label|:
if|if
condition|(
name|query
operator|->
name|dispatch
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|cleanup_query
label|:
if|if
condition|(
name|query
operator|->
name|connects
operator|==
literal|0
condition|)
block|{
name|query
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|query
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stop_idle_timer
label|:
name|RUNTIME_CHECK
argument_list|(
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|bad_edns
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|bad_edns
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
name|sa
argument_list|,
name|address
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_bad_edns
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
if|if
condition|(
name|bad_edns
argument_list|(
name|fctx
argument_list|,
name|address
argument_list|)
condition|)
return|return;
name|sa
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return;
operator|*
name|sa
operator|=
operator|*
name|address
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|fctx
operator|->
name|bad_edns
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|triededns
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|edns
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
name|sa
argument_list|,
name|address
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_triededns
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
if|if
condition|(
name|triededns
argument_list|(
name|fctx
argument_list|,
name|address
argument_list|)
condition|)
return|return;
name|sa
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return;
operator|*
name|sa
operator|=
operator|*
name|address
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|fctx
operator|->
name|edns
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|triededns512
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|edns512
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
name|sa
argument_list|,
name|address
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_triededns512
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
if|if
condition|(
name|triededns512
argument_list|(
name|fctx
argument_list|,
name|address
argument_list|)
condition|)
return|return;
name|sa
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return;
operator|*
name|sa
operator|=
operator|*
name|address
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|fctx
operator|->
name|edns512
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|wouldvalidate
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_boolean_t
name|secure_domain
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|enablevalidation
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|result
operator|=
name|dns_view_issecuredomain
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|secure_domain
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|resquery_send
parameter_list|(
name|resquery_t
modifier|*
name|query
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|qname
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|qrdataset
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_buffer_t
name|tcpbuffer
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|address
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_netaddr_t
name|ipaddr
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|tsigkey
init|=
name|NULL
decl_stmt|;
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|useedns
decl_stmt|;
name|dns_compress_t
name|cctx
decl_stmt|;
name|isc_boolean_t
name|cleanup_cctx
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|secure_domain
decl_stmt|;
name|isc_boolean_t
name|connecting
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_ednsopt_t
name|ednsopts
index|[
name|DNS_EDNSOPTIONS
index|]
decl_stmt|;
name|unsigned
name|ednsopt
init|=
literal|0
decl_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|QTRACE
argument_list|(
literal|"send"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|task
operator|=
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
expr_stmt|;
name|address
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Reserve space for the TCP message length. 		 */
name|isc_buffer_init
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
name|query
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|buffer
argument_list|,
name|query
operator|->
name|data
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|data
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|&
name|tcpbuffer
expr_stmt|;
block|}
else|else
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|buffer
argument_list|,
name|query
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|&
name|query
operator|->
name|buffer
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_temps
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_temps
goto|;
comment|/* 	 * Get a query id from the dispatch. 	 */
name|result
operator|=
name|dns_dispatch_addresponse2
argument_list|(
name|query
operator|->
name|dispatch
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|task
argument_list|,
name|resquery_response
argument_list|,
name|query
argument_list|,
operator|&
name|query
operator|->
name|id
argument_list|,
operator|&
name|query
operator|->
name|dispentry
argument_list|,
name|res
operator|->
name|socketmgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_temps
goto|;
name|fctx
operator|->
name|qmessage
operator|->
name|opcode
operator|=
name|dns_opcode_query
expr_stmt|;
comment|/* 	 * Set up question. 	 */
name|dns_name_init
argument_list|(
name|qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|qrdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_makequestion
argument_list|(
name|qrdataset
argument_list|,
name|res
operator|->
name|rdclass
argument_list|,
name|fctx
operator|->
name|type
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qname
operator|->
name|list
argument_list|,
name|qrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|qname
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
name|qname
operator|=
name|NULL
expr_stmt|;
name|qrdataset
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Set RD if the client has requested that we do a recursive query, 	 * or if we're sending to a forwarder. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_RECURSIVE
operator|)
operator|!=
literal|0
operator|||
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
condition|)
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_RD
expr_stmt|;
comment|/* 	 * Set CD if the client says don't validate or the question is 	 * under a secure entry point. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|enablevalidation
condition|)
block|{
name|result
operator|=
name|dns_view_issecuredomain
argument_list|(
name|res
operator|->
name|view
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|secure_domain
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
name|secure_domain
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|secure_domain
condition|)
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
block|}
comment|/* 	 * We don't have to set opcode because it defaults to query. 	 */
name|fctx
operator|->
name|qmessage
operator|->
name|id
operator|=
name|query
operator|->
name|id
expr_stmt|;
comment|/* 	 * Convert the question to wire format. 	 */
name|result
operator|=
name|dns_compress_init
argument_list|(
operator|&
name|cctx
argument_list|,
operator|-
literal|1
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|cleanup_cctx
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dns_message_renderbegin
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|cctx
argument_list|,
operator|&
name|query
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|peer
operator|=
name|NULL
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|ipaddr
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|ipaddr
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * The ADB does not know about servers with "edns no".  Check this, 	 * and then inform the ADB for future use. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|addrinfo
operator|->
name|flags
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
operator|&&
name|peer
operator|!=
name|NULL
operator|&&
name|dns_peer_getsupportedns
argument_list|(
name|peer
argument_list|,
operator|&
name|useedns
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|useedns
condition|)
block|{
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
comment|/* Sync NOEDNS0 flag in addrinfo->flags and options now. */
if|if
condition|(
operator|(
name|query
operator|->
name|addrinfo
operator|->
name|flags
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|!=
literal|0
condition|)
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
comment|/* 	 * Handle timeouts by reducing the UDP response size to 512 bytes 	 * then if that doesn't work disabling EDNS (includes DO) and CD. 	 * 	 * These timeout can be due to: 	 *	* broken nameservers that don't respond to EDNS queries. 	 *	* broken/misconfigured firewalls and NAT implementations 	 *	  that don't handle IP fragmentation. 	 *	* broken/misconfigured firewalls that don't handle responses 	 *	  greater than 512 bytes. 	 *	* broken/misconfigured firewalls that don't handle EDNS, DO 	 *	  or CD. 	 *	* packet loss / link outage. 	 */
if|if
condition|(
name|fctx
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|(
name|triededns512
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
operator|||
name|fctx
operator|->
name|timeouts
operator|>=
operator|(
name|MAX_EDNS0_TIMEOUTS
operator|*
literal|2
operator|)
operator|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|EDNSOK
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|||
operator|!
name|wouldvalidate
argument_list|(
name|fctx
argument_list|)
operator|)
condition|)
block|{
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|fctx
operator|->
name|reason
operator|=
literal|"disabling EDNS"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|triededns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
operator|||
name|fctx
operator|->
name|timeouts
operator|>=
name|MAX_EDNS0_TIMEOUTS
operator|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_EDNS512
expr_stmt|;
name|fctx
operator|->
name|reason
operator|=
literal|"reducing the advertised EDNS UDP "
literal|"packet size to 512 octets"
expr_stmt|;
block|}
name|fctx
operator|->
name|timeout
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Use EDNS0, unless the caller doesn't want it, or we know that 	 * the remote server doesn't like it. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|query
operator|->
name|addrinfo
operator|->
name|flags
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|version
init|=
literal|0
decl_stmt|;
comment|/* Default version. */
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_uint16_t
name|udpsize
init|=
name|res
operator|->
name|udpsize
decl_stmt|;
name|isc_boolean_t
name|reqnsid
init|=
name|res
operator|->
name|view
operator|->
name|requestnsid
decl_stmt|;
name|flags
operator|=
name|query
operator|->
name|addrinfo
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_FETCHOPT_EDNSVERSIONSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|version
operator|=
name|flags
operator|&
name|DNS_FETCHOPT_EDNSVERSIONMASK
expr_stmt|;
name|version
operator|>>=
name|DNS_FETCHOPT_EDNSVERSIONSHIFT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_EDNS512
operator|)
operator|!=
literal|0
condition|)
name|udpsize
operator|=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_peer_getudpsize
argument_list|(
name|peer
argument_list|,
operator|&
name|udpsize
argument_list|)
expr_stmt|;
comment|/* request NSID for current view or peer? */
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_peer_getrequestnsid
argument_list|(
name|peer
argument_list|,
operator|&
name|reqnsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqnsid
condition|)
block|{
name|INSIST
argument_list|(
name|ednsopt
operator|<
name|DNS_EDNSOPTIONS
argument_list|)
expr_stmt|;
name|ednsopts
index|[
name|ednsopt
index|]
operator|.
name|code
operator|=
name|DNS_OPT_NSID
expr_stmt|;
name|ednsopts
index|[
name|ednsopt
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|ednsopts
index|[
name|ednsopt
index|]
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
name|ednsopt
operator|++
expr_stmt|;
block|}
name|query
operator|->
name|ednsversion
operator|=
name|version
expr_stmt|;
name|result
operator|=
name|fctx_addopt
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|version
argument_list|,
name|udpsize
argument_list|,
name|ednsopts
argument_list|,
name|ednsopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqnsid
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_WANTNSID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * We couldn't add the OPT, but we'll press on. 				 * We're not using EDNS0, so set the NOEDNS0 				 * bit. 				 */
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|query
operator|->
name|ednsversion
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We know this server doesn't like EDNS0, so we 			 * won't use it.  Set the NOEDNS0 bit since we're 			 * not using EDNS0. 			 */
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|query
operator|->
name|ednsversion
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|query
operator|->
name|ednsversion
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If we need EDNS0 to do this query and aren't using it, we lose. 	 */
if|if
condition|(
name|NEEDEDNS0
argument_list|(
name|fctx
argument_list|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup_message
goto|;
block|}
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
name|add_triededns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_EDNS512
operator|)
operator|!=
literal|0
condition|)
name|add_triededns512
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Clear CD if EDNS is not in use. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|!=
literal|0
condition|)
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
comment|/* 	 * Add TSIG record tailored to the current recipient. 	 */
name|result
operator|=
name|dns_view_getpeertsig
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
operator|&
name|ipaddr
argument_list|,
operator|&
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|cleanup_message
goto|;
if|if
condition|(
name|tsigkey
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_message_settsigkey
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|tsigkey
argument_list|)
expr_stmt|;
name|dns_tsigkey_detach
argument_list|(
operator|&
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
block|}
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|result
operator|=
name|dns_message_renderend
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|cleanup_cctx
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|dns_message_gettsigkey
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dns_tsigkey_attach
argument_list|(
name|dns_message_gettsigkey
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|)
argument_list|,
operator|&
name|query
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_getquerytsig
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|query
operator|->
name|tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
block|}
comment|/* 	 * If using TCP, write the length of the message at the beginning 	 * of the buffer. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_buffer_usedregion
argument_list|(
operator|&
name|query
operator|->
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're now done with the query message. 	 */
name|dns_message_reset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|exclusivesocket
condition|)
name|sock
operator|=
name|dns_dispatch_getentrysocket
argument_list|(
name|query
operator|->
name|dispentry
argument_list|)
expr_stmt|;
else|else
name|sock
operator|=
name|dns_dispatch_getsocket
argument_list|(
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
comment|/* 	 * Send the query! 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|==
literal|0
condition|)
block|{
name|address
operator|=
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|exclusivesocket
condition|)
block|{
name|result
operator|=
name|isc_socket_connect
argument_list|(
name|sock
argument_list|,
name|address
argument_list|,
name|task
argument_list|,
name|resquery_udpconnected
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|connecting
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|connects
operator|++
expr_stmt|;
block|}
block|}
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH  Make sure we don't send to ourselves!  We should probably 	 *		prune out these addresses when we get them from the ADB. 	 */
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|query
operator|->
name|sendevent
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|sendevent
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|resquery_senddone
argument_list|,
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_sendto2
argument_list|(
name|sock
argument_list|,
operator|&
name|r
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|,
operator|&
name|query
operator|->
name|sendevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|connecting
condition|)
block|{
comment|/* 			 * This query is still connecting. 			 * Mark it as canceled so that it will just be 			 * cleaned up when the connected event is received. 			 * Keep fctx around until the event is processed. 			 */
name|query
operator|->
name|fctx
operator|->
name|nqueries
operator|++
expr_stmt|;
name|query
operator|->
name|attributes
operator||=
name|RESQUERY_ATTR_CANCELED
expr_stmt|;
block|}
goto|goto
name|cleanup_message
goto|;
block|}
name|query
operator|->
name|sends
operator|++
expr_stmt|;
name|QTRACE
argument_list|(
literal|"sent"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_message
label|:
if|if
condition|(
name|cleanup_cctx
condition|)
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|dns_message_reset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the dispatcher from listening. 	 */
name|dns_dispatch_removeresponse
argument_list|(
operator|&
name|query
operator|->
name|dispentry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cleanup_temps
label|:
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qrdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_connected
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|retry
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|attrs
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_CONNECT
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_QUERY
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"connected"
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH 	 * 	 * Currently we don't wait for the connect event before retrying 	 * a query.  This means that if we get really behind, we may end 	 * up doing extra work! 	 */
name|query
operator|->
name|connects
operator|--
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
if|if
condition|(
name|RESQUERY_CANCELED
argument_list|(
name|query
argument_list|)
condition|)
block|{
comment|/* 		 * This query was canceled while the connect() was in 		 * progress. 		 */
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|resquery_destroy
argument_list|(
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|sevent
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
comment|/* 			 * Extend the idle timer for TCP.  20 seconds 			 * should be long enough for a TCP connection to be 			 * established, a single DNS request to be sent, 			 * and the response received. 			 */
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_startidletimer
argument_list|(
name|query
operator|->
name|fctx
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"query canceled: idle timer failed; "
literal|"responding"
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * We are connected.  Create a dispatcher and 			 * send the query. 			 */
name|attrs
operator|=
literal|0
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_TCP
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_PRIVATE
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_CONNECTED
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
operator|==
name|AF_INET
condition|)
name|attrs
operator||=
name|DNS_DISPATCHATTR_IPV4
expr_stmt|;
else|else
name|attrs
operator||=
name|DNS_DISPATCHATTR_IPV6
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_MAKEQUERY
expr_stmt|;
name|result
operator|=
name|dns_dispatch_createtcp
argument_list|(
name|query
operator|->
name|dispatchmgr
argument_list|,
name|query
operator|->
name|tcpsocket
argument_list|,
name|query
operator|->
name|fctx
operator|->
name|res
operator|->
name|taskmgr
argument_list|,
literal|4096
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|attrs
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
comment|/* 			 * Regardless of whether dns_dispatch_create() 			 * succeeded or not, we don't need our reference 			 * to the socket anymore. 			 */
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|resquery_send
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"query canceled: "
literal|"resquery_send() failed; responding"
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ISC_R_NETUNREACH
case|:
case|case
name|ISC_R_HOSTUNREACH
case|:
case|case
name|ISC_R_CONNREFUSED
case|:
case|case
name|ISC_R_NOPERM
case|:
case|case
name|ISC_R_ADDRNOTAVAIL
case|:
case|case
name|ISC_R_CONNECTIONRESET
case|:
name|FCTXTRACE3
argument_list|(
literal|"query canceled in connected(): "
literal|"no route to host; no response"
argument_list|,
name|sevent
operator|->
name|result
argument_list|)
expr_stmt|;
comment|/* 			 * No route to remote. 			 */
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|retry
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
default|default:
name|FCTXTRACE3
argument_list|(
literal|"query canceled in connected() due to "
literal|"unexpected event result; responding"
argument_list|,
name|sevent
operator|->
name|result
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
condition|)
block|{
comment|/* 		 * Behave as if the idle timer has expired.  For TCP 		 * connections this may not actually reflect the latest timer. 		 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_finddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|want_try
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|want_done
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|dodestroy
init|=
name|ISC_FALSE
decl_stmt|;
name|find
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|fctx
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"finddone"
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|pending
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|pending
operator|--
expr_stmt|;
if|if
condition|(
name|ADDRWAIT
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 		 * The fetch is waiting for a name to be found. 		 */
name|INSIST
argument_list|(
operator|!
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_ADBMOREADDRESSES
condition|)
block|{
name|want_try
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|fctx
operator|->
name|findfail
operator|++
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We've got nothing else to wait for and don't 				 * know the answer.  There's nothing to do but 				 * fail the fctx. 				 */
name|want_done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
operator|&&
name|fctx
operator|->
name|pending
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|nqueries
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
block|{
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|bucket_empty
operator|=
name|fctx_unlink
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|dodestroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_try
condition|)
block|{
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want_done
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"fetch failed in finddone(); return ISC_R_FAILURE"
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|ISC_R_FAILURE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dodestroy
condition|)
block|{
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|bad_server
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|bad
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
name|sa
argument_list|,
name|address
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|mark_bad
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|curr
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|isc_boolean_t
name|all_bad
init|=
name|ISC_TRUE
decl_stmt|;
comment|/* 	 * Mark all known bad servers, so we don't try to talk to them 	 * again. 	 */
comment|/* 	 * Mark any bad nameservers. 	 */
for|for
control|(
name|curr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
control|)
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
comment|/* 	 * Mark any bad forwarders. 	 */
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Mark any bad alternates. 	 */
for|for
control|(
name|curr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
control|)
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
return|return
operator|(
name|all_bad
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_bad
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|isc_result_t
name|reason
parameter_list|,
name|badnstype_t
name|badtype
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|typebuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|code
index|[
literal|64
index|]
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
specifier|const
name|char
modifier|*
name|spc
init|=
literal|""
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|address
init|=
operator|&
name|addrinfo
operator|->
name|sockaddr
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|DNS_R_LAME
condition|)
name|fctx
operator|->
name|lamecount
operator|++
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|badtype
condition|)
block|{
case|case
name|badns_unreachable
case|:
name|fctx
operator|->
name|neterr
operator|++
expr_stmt|;
break|break;
case|case
name|badns_response
case|:
name|fctx
operator|->
name|badresp
operator|++
expr_stmt|;
break|break;
case|case
name|badns_validation
case|:
break|break;
comment|/* counted as 'valfail' */
block|}
block|}
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
name|address
argument_list|)
condition|)
block|{
comment|/* 		 * We already know this server is bad. 		 */
return|return;
block|}
name|FCTXTRACE
argument_list|(
literal|"add_bad"
argument_list|)
expr_stmt|;
name|sa
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return;
operator|*
name|sa
operator|=
operator|*
name|address
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|fctx
operator|->
name|bad
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|DNS_R_LAME
condition|)
comment|/* already logged */
return|return;
if|if
condition|(
name|reason
operator|==
name|DNS_R_UNEXPECTEDRCODE
operator|&&
name|fctx
operator|->
name|rmessage
operator|->
name|rcode
operator|==
name|dns_rcode_servfail
operator|&&
name|ISFORWARDER
argument_list|(
name|addrinfo
argument_list|)
condition|)
return|return;
if|if
condition|(
name|reason
operator|==
name|DNS_R_UNEXPECTEDRCODE
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dns_rcode_totext
argument_list|(
name|fctx
operator|->
name|rmessage
operator|->
name|rcode
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|code
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spc
operator|=
literal|" "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|DNS_R_UNEXPECTEDOPCODE
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dns_opcode_totext
argument_list|(
operator|(
name|dns_opcode_t
operator|)
name|fctx
operator|->
name|rmessage
operator|->
name|opcode
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|code
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spc
operator|=
literal|" "
expr_stmt|;
block|}
else|else
block|{
name|code
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|fctx
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_LAME_SERVERS
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"error (%s%s%s) resolving '%s/%s/%s': %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|reason
argument_list|)
argument_list|,
name|spc
argument_list|,
name|code
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sort addrinfo list by RTT.  */
end_comment

begin_function
specifier|static
name|void
name|sort_adbfind
parameter_list|(
name|dns_adbfind_t
modifier|*
name|find
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|best
decl_stmt|,
modifier|*
name|curr
decl_stmt|;
name|dns_adbaddrinfolist_t
name|sorted
decl_stmt|;
comment|/* Lame N^2 bubble sort. */
name|ISC_LIST_INIT
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|find
operator|->
name|list
argument_list|)
condition|)
block|{
name|best
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|srtt
operator|<
name|best
operator|->
name|srtt
condition|)
name|best
operator|=
name|curr
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
name|find
operator|->
name|list
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|sorted
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|find
operator|->
name|list
operator|=
name|sorted
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sort a list of finds by server RTT.  */
end_comment

begin_function
specifier|static
name|void
name|sort_finds
parameter_list|(
name|dns_adbfindlist_t
modifier|*
name|findlist
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|best
decl_stmt|,
modifier|*
name|curr
decl_stmt|;
name|dns_adbfindlist_t
name|sorted
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|,
modifier|*
name|bestaddrinfo
decl_stmt|;
comment|/* Sort each find's addrinfo list by SRTT. */
for|for
control|(
name|curr
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|findlist
argument_list|)
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
control|)
name|sort_adbfind
argument_list|(
name|curr
argument_list|)
expr_stmt|;
comment|/* Lame N^2 bubble sort. */
name|ISC_LIST_INIT
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|findlist
argument_list|)
condition|)
block|{
name|best
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|findlist
argument_list|)
expr_stmt|;
name|bestaddrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|best
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|bestaddrinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|addrinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|->
name|srtt
operator|<
name|bestaddrinfo
operator|->
name|srtt
condition|)
block|{
name|best
operator|=
name|curr
expr_stmt|;
name|bestaddrinfo
operator|=
name|addrinfo
expr_stmt|;
block|}
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|findlist
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|sorted
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
operator|*
name|findlist
operator|=
name|sorted
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|findname
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|in_port_t
name|port
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
modifier|*
name|overquota
parameter_list|,
name|isc_boolean_t
modifier|*
name|need_alternate
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|ai
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|unshared
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|ENABLE_FETCHLIMIT
name|UNUSED
argument_list|(
name|overquota
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|unshared
operator|=
name|ISC_TF
argument_list|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_UNSHARED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this name is a subdomain of the query domain, tell 	 * the ADB to start looking using zone/hint data. This keeps us 	 * from getting stuck if the nameserver is beneath the zone cut 	 * and we don't know its address (e.g. because the A record has 	 * expired). 	 */
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
name|options
operator||=
name|DNS_ADBFIND_STARTATZONE
expr_stmt|;
name|options
operator||=
name|DNS_ADBFIND_GLUEOK
expr_stmt|;
name|options
operator||=
name|DNS_ADBFIND_HINTOK
expr_stmt|;
comment|/* 	 * See what we know about this address. 	 */
name|find
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_adb_createfind2
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
argument_list|,
name|fctx_finddone
argument_list|,
name|fctx
argument_list|,
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
name|options
argument_list|,
name|now
argument_list|,
name|NULL
argument_list|,
name|res
operator|->
name|view
operator|->
name|dstport
argument_list|,
name|fctx
operator|->
name|depth
operator|+
literal|1
argument_list|,
name|fctx
operator|->
name|qc
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_ALIAS
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
comment|/* 			 * XXXRTH  Follow the CNAME/DNAME chain? 			 */
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|adberr
operator|++
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_CNAME
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"skipping nameserver '%s' because it "
literal|"is a CNAME, while resolving '%s'"
argument_list|,
name|namebuf
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|find
operator|->
name|list
argument_list|)
condition|)
block|{
comment|/* 		 * We have at least some of the addresses for the 		 * name. 		 */
name|INSIST
argument_list|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_WANTEVENT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|0
operator|||
name|port
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|ai
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ai
argument_list|,
name|publink
argument_list|)
control|)
block|{
name|ai
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|port
operator|!=
literal|0
condition|)
name|isc_sockaddr_setport
argument_list|(
operator|&
name|ai
operator|->
name|sockaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|FCTX_ADDRINFO_FORWARDER
operator|)
operator|!=
literal|0
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|finds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't know any of the addresses for this 		 * name. 		 */
if|if
condition|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_WANTEVENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We're looking for them and will get an 			 * event about it later. 			 */
name|fctx
operator|->
name|pending
operator|++
expr_stmt|;
comment|/* 			 * Bootstrap. 			 */
if|if
condition|(
name|need_alternate
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|need_alternate
operator|&&
name|unshared
operator|&&
operator|(
operator|(
name|res
operator|->
name|dispatches4
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v6
operator|!=
name|DNS_R_NXDOMAIN
operator|)
operator|||
operator|(
name|res
operator|->
name|dispatches6
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v4
operator|!=
name|DNS_R_NXDOMAIN
operator|)
operator|)
condition|)
operator|*
name|need_alternate
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
if|if
condition|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_OVERQUOTA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|overquota
operator|!=
name|NULL
condition|)
operator|*
name|overquota
operator|=
name|ISC_TRUE
expr_stmt|;
name|fctx
operator|->
name|quotacount
operator|++
expr_stmt|;
comment|/* quota exceeded */
block|}
elseif|else
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
if|if
condition|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_LAMEPRUNED
operator|)
operator|!=
literal|0
condition|)
name|fctx
operator|->
name|lamecount
operator|++
expr_stmt|;
comment|/* cached lame server */
else|else
name|fctx
operator|->
name|adberr
operator|++
expr_stmt|;
comment|/* unreachable server, etc. */
comment|/* 			 * If we know there are no addresses for 			 * the family we are using then try to add 			 * an alternative server. 			 */
if|if
condition|(
name|need_alternate
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|need_alternate
operator|&&
operator|(
operator|(
name|res
operator|->
name|dispatches4
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v6
operator|==
name|DNS_R_NXRRSET
operator|)
operator|||
operator|(
name|res
operator|->
name|dispatches6
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v4
operator|==
name|DNS_R_NXRRSET
operator|)
operator|)
condition|)
operator|*
name|need_alternate
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|isstrictsubdomain
parameter_list|(
name|dns_name_t
modifier|*
name|name1
parameter_list|,
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|;
name|dns_namereln_t
name|namereln
decl_stmt|;
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|namereln
operator|==
name|dns_namereln_subdomain
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fctx_getaddresses
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|badcache
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|unsigned
name|int
name|stdoptions
init|=
literal|0
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|ai
decl_stmt|;
name|isc_boolean_t
name|all_bad
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|isc_boolean_t
name|need_alternate
init|=
name|ISC_FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|isc_boolean_t
name|all_spilled
init|=
name|ISC_TRUE
decl_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|FCTXTRACE
argument_list|(
literal|"getaddresses"
argument_list|)
expr_stmt|;
comment|/* 	 * Don't pound on remote servers.  (Failsafe!) 	 */
name|fctx
operator|->
name|restarts
operator|++
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|restarts
operator|>
literal|10
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"too many restarts"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|depth
operator|>
name|res
operator|->
name|maxdepth
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"too much NS indirection resolving '%s'"
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
comment|/* 	 * Forwarders. 	 */
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this fctx has forwarders, use them; otherwise use any 	 * selective forwarders specified in the view; otherwise use the 	 * resolver's forwarders (if any). 	 */
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
block|{
name|dns_forwarders_t
modifier|*
name|forwarders
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
operator|&
name|fctx
operator|->
name|name
decl_stmt|;
name|dns_name_t
name|suffix
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|domain
decl_stmt|;
comment|/* 		 * DS records are found in the parent server. 		 * Strip label to get the correct forwarder (if any). 		 */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|fctx
operator|->
name|type
argument_list|)
operator|&&
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|>
literal|1
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|suffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|suffix
argument_list|)
expr_stmt|;
name|name
operator|=
operator|&
name|suffix
expr_stmt|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|domain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_fwdtable_find2
argument_list|(
name|res
operator|->
name|view
operator|->
name|fwdtable
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
operator|&
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|forwarders
operator|->
name|addrs
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|fwdpolicy
operator|=
name|forwarders
operator|->
name|fwdpolicy
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|fwdpolicy
operator|==
name|dns_fwdpolicy_only
operator|&&
name|isstrictsubdomain
argument_list|(
name|domain
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|fcount_decr
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|result
operator|=
name|fcount_incr
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
block|}
block|}
block|}
while|while
condition|(
name|sa
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|isc_sockaddr_pf
argument_list|(
name|sa
argument_list|)
operator|==
name|AF_INET
operator|&&
name|fctx
operator|->
name|res
operator|->
name|dispatches4
operator|==
name|NULL
operator|)
operator|||
operator|(
name|isc_sockaddr_pf
argument_list|(
name|sa
argument_list|)
operator|==
name|AF_INET6
operator|&&
name|fctx
operator|->
name|res
operator|->
name|dispatches6
operator|==
name|NULL
operator|)
condition|)
block|{
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ai
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_adb_findaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|sa
argument_list|,
operator|&
name|ai
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXMLG */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|cur
decl_stmt|;
name|ai
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_FORWARDER
expr_stmt|;
name|cur
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|NULL
operator|&&
name|cur
operator|->
name|srtt
operator|<
name|ai
operator|->
name|srtt
condition|)
name|cur
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|cur
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
name|ISC_LIST_INSERTBEFORE
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|,
name|cur
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the forwarding policy is "only", we don't need the addresses 	 * of the nameservers. 	 */
if|if
condition|(
name|fctx
operator|->
name|fwdpolicy
operator|==
name|dns_fwdpolicy_only
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Normal nameservers. 	 */
name|stdoptions
operator|=
name|DNS_ADBFIND_WANTEVENT
operator||
name|DNS_ADBFIND_EMPTYEVENT
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|restarts
operator|==
literal|1
condition|)
block|{
comment|/* 		 * To avoid sending out a flood of queries likely to 		 * result in NXRRSET, we suppress fetches for address 		 * families we don't have the first time through, 		 * provided that we have addresses in some family we 		 * can use. 		 * 		 * We don't want to set this option all the time, since 		 * if fctx->restarts> 1, we've clearly been having trouble 		 * with the addresses we had, so getting more could help. 		 */
name|stdoptions
operator||=
name|DNS_ADBFIND_AVOIDFETCHES
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|dispatches4
operator|!=
name|NULL
condition|)
name|stdoptions
operator||=
name|DNS_ADBFIND_INET
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatches6
operator|!=
name|NULL
condition|)
name|stdoptions
operator||=
name|DNS_ADBFIND_INET6
expr_stmt|;
if|if
condition|(
operator|(
name|stdoptions
operator|&
name|DNS_ADBFIND_ADDRESSMASK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
control|)
block|{
name|isc_boolean_t
name|overquota
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 		 * Extract the name from the NS record. 		 */
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|findname
argument_list|(
name|fctx
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
literal|0
argument_list|,
name|stdoptions
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
operator|&
name|overquota
argument_list|,
operator|&
name|need_alternate
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
if|if
condition|(
operator|!
name|overquota
condition|)
name|all_spilled
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Do we need to use 6 to 4? 	 */
if|if
condition|(
name|need_alternate
condition|)
block|{
name|int
name|family
decl_stmt|;
name|alternate_t
modifier|*
name|a
decl_stmt|;
name|family
operator|=
operator|(
name|res
operator|->
name|dispatches6
operator|!=
name|NULL
operator|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
for|for
control|(
name|a
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|alternates
argument_list|)
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|a
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|a
operator|->
name|isaddress
condition|)
block|{
name|findname
argument_list|(
name|fctx
argument_list|,
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|,
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|port
argument_list|,
name|stdoptions
argument_list|,
name|FCTX_ADDRINFO_FORWARDER
argument_list|,
name|now
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|a
operator|->
name|_u
operator|.
name|addr
argument_list|)
operator|!=
name|family
condition|)
continue|continue;
name|ai
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_adb_findaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
operator|&
name|a
operator|->
name|_u
operator|.
name|addr
argument_list|,
operator|&
name|ai
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|cur
decl_stmt|;
name|ai
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_FORWARDER
expr_stmt|;
name|cur
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|NULL
operator|&&
name|cur
operator|->
name|srtt
operator|<
name|ai
operator|->
name|srtt
condition|)
name|cur
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|cur
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
name|ISC_LIST_INSERTBEFORE
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|,
name|cur
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
comment|/* 	 * Mark all known bad servers. 	 */
name|all_bad
operator|=
name|mark_bad
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* 	 * How are we doing? 	 */
if|if
condition|(
name|all_bad
condition|)
block|{
comment|/* 		 * We've got no addresses. 		 */
if|if
condition|(
name|fctx
operator|->
name|pending
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We're fetching the addresses, but don't have any 			 * yet.   Tell the caller to wait for an answer. 			 */
name|result
operator|=
name|DNS_R_WAIT
expr_stmt|;
block|}
else|else
block|{
name|isc_time_t
name|expire
decl_stmt|;
name|isc_interval_t
name|i
decl_stmt|;
comment|/* 			 * We've lost completely.  We don't know any 			 * addresses, and the ADB has told us it can't get 			 * them. 			 */
name|FCTXTRACE
argument_list|(
literal|"no addresses"
argument_list|)
expr_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
name|DNS_BADCACHE_TTL
argument_list|(
name|fctx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|expire
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|badcache
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_dnskey
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_dlv
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|)
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_resolver_addbadcache
argument_list|(
name|res
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
operator|&
name|expire
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
comment|/* 			 * If all of the addresses found were over the 			 * fetches-per-server quota, return the configured 			 * response. 			 */
if|if
condition|(
name|all_spilled
condition|)
block|{
name|result
operator|=
name|res
operator|->
name|quotaresp
index|[
name|dns_quotatype_server
index|]
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_serverquota
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
block|}
block|}
else|else
block|{
comment|/* 		 * We've found some addresses.  We might still be looking 		 * for more addresses. 		 */
name|sort_finds
argument_list|(
operator|&
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
name|sort_finds
argument_list|(
operator|&
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|possibly_mark
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addr
parameter_list|)
block|{
name|isc_netaddr_t
name|na
decl_stmt|;
name|char
name|buf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|isc_boolean_t
name|aborted
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|bogus
decl_stmt|;
name|dns_acl_t
modifier|*
name|blackhole
decl_stmt|;
name|isc_netaddr_t
name|ipaddr
decl_stmt|;
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|sa
operator|=
operator|&
name|addr
operator|->
name|sockaddr
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|ipaddr
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|blackhole
operator|=
name|dns_dispatchmgr_getblackhole
argument_list|(
name|res
operator|->
name|dispatchmgr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|res
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|ipaddr
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|blackhole
operator|!=
name|NULL
condition|)
block|{
name|int
name|match
decl_stmt|;
if|if
condition|(
name|dns_acl_match
argument_list|(
operator|&
name|ipaddr
argument_list|,
name|NULL
argument_list|,
name|blackhole
argument_list|,
operator|&
name|res
operator|->
name|view
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
name|aborted
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|!=
name|NULL
operator|&&
name|dns_peer_getbogus
argument_list|(
name|peer
argument_list|,
operator|&
name|bogus
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|bogus
condition|)
name|aborted
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|aborted
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring blackholed / bogus server: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isc_sockaddr_ismulticast
argument_list|(
name|sa
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring multicast address: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isc_sockaddr_isexperimental
argument_list|(
name|sa
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring experimental address: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET6
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa
operator|->
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring IPv6 mapped IPV4 address: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_V4COMPAT
argument_list|(
operator|&
name|sa
operator|->
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring IPv6 compatibility IPV4 address: "
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|na
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|FCTXTRACE2
argument_list|(
name|msg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_adbaddrinfo_t
modifier|*
name|fctx_nextaddress
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|faddrinfo
decl_stmt|;
comment|/* 	 * Return the next untried address, if any. 	 */
comment|/* 	 * Find the first unmarked forwarder (if any). 	 */
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
block|{
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|fctx
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|addrinfo
operator|)
return|;
block|}
block|}
comment|/* 	 * No forwarders.  Move to the next find. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_TRIEDFIND
expr_stmt|;
name|find
operator|=
name|fctx
operator|->
name|find
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
else|else
block|{
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the first unmarked addrinfo. 	 */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|find
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|find
expr_stmt|;
do|do
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
block|{
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|addrinfo
operator|!=
name|NULL
condition|)
break|break;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|find
operator|!=
name|start
condition|)
do|;
block|}
name|fctx
operator|->
name|find
operator|=
name|find
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|!=
name|NULL
condition|)
return|return
operator|(
name|addrinfo
operator|)
return|;
comment|/* 	 * No nameservers left.  Try alternates. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_TRIEDALT
expr_stmt|;
name|find
operator|=
name|fctx
operator|->
name|altfind
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
else|else
block|{
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the first unmarked addrinfo. 	 */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|find
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|find
expr_stmt|;
do|do
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
block|{
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|addrinfo
operator|!=
name|NULL
condition|)
break|break;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|find
operator|!=
name|start
condition|)
do|;
block|}
name|faddrinfo
operator|=
name|addrinfo
expr_stmt|;
comment|/* 	 * See if we have a better alternate server by address. 	 */
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
operator|&&
operator|(
name|faddrinfo
operator|==
name|NULL
operator|||
name|addrinfo
operator|->
name|srtt
operator|<
name|faddrinfo
operator|->
name|srtt
operator|)
condition|)
block|{
if|if
condition|(
name|faddrinfo
operator|!=
name|NULL
condition|)
name|faddrinfo
operator|->
name|flags
operator|&=
operator|~
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|addrinfo
operator|==
name|NULL
condition|)
block|{
name|addrinfo
operator|=
name|faddrinfo
expr_stmt|;
name|fctx
operator|->
name|altfind
operator|=
name|find
expr_stmt|;
block|}
return|return
operator|(
name|addrinfo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_try
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|retrying
parameter_list|,
name|isc_boolean_t
name|badcache
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
init|=
name|NULL
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"try"
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ADDRWAIT
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
comment|/* We've already exceeded maximum query count */
if|if
condition|(
name|isc_counter_used
argument_list|(
name|fctx
operator|->
name|qc
argument_list|)
operator|>
name|res
operator|->
name|maxqueries
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"exceeded max queries resolving '%s'"
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
comment|/* Try to find an address that isn't over quota */
while|while
condition|(
operator|(
name|addrinfo
operator|=
name|fctx_nextaddress
argument_list|(
name|fctx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|dns_adbentry_overquota
argument_list|(
name|addrinfo
operator|->
name|entry
argument_list|)
condition|)
break|break;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
if|if
condition|(
name|addrinfo
operator|==
name|NULL
condition|)
block|{
comment|/* We have no more addresses.  Start over. */
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_getaddresses
argument_list|(
name|fctx
argument_list|,
name|badcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_WAIT
condition|)
block|{
comment|/* 			 * Sleep waiting for addresses. 			 */
name|FCTXTRACE
argument_list|(
literal|"addrwait"
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Something bad happened. 			 */
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
while|while
condition|(
operator|(
name|addrinfo
operator|=
name|fctx_nextaddress
argument_list|(
name|fctx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dns_adbentry_overquota
argument_list|(
name|addrinfo
operator|->
name|entry
argument_list|)
condition|)
break|break;
block|}
else|#
directive|else
name|addrinfo
operator|=
name|fctx_nextaddress
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
comment|/* 		 * While we may have addresses from the ADB, they 		 * might be bad ones.  In this case, return SERVFAIL. 		 */
if|if
condition|(
name|addrinfo
operator|==
name|NULL
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|2
condition|)
block|{
name|result
operator|=
name|isc_counter_increment
argument_list|(
name|fctx
operator|->
name|qc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"exceeded max queries resolving '%s'"
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|fctx_increference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_query
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|fctx
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|bucket_empty
operator|=
name|fctx_decreference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retrying
condition|)
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_retry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|fctx_unlink
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
comment|/* 	 * Caller must be holding the bucket lock. 	 */
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_init
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"unlink"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|,
name|fctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|res
operator|->
name|nfctx
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|exiting
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|,
modifier|*
name|next_sa
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_init
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"destroy"
argument_list|)
expr_stmt|;
comment|/* 	 * Free bad. 	 */
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|bad
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|next_sa
control|)
block|{
name|next_sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|bad
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|edns
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|next_sa
control|)
block|{
name|next_sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|edns
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|edns512
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|next_sa
control|)
block|{
name|next_sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|edns512
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|bad_edns
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|next_sa
control|)
block|{
name|next_sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|bad_edns
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_counter_detach
argument_list|(
operator|&
name|fctx
operator|->
name|qc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|fcount_decr
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|isc_timer_detach
argument_list|(
operator|&
name|fctx
operator|->
name|timer
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|rmessage
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|0
condition|)
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|fctx
operator|->
name|cache
argument_list|)
expr_stmt|;
name|dns_adb_detach
argument_list|(
operator|&
name|fctx
operator|->
name|adb
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|fctx
operator|->
name|mctx
argument_list|,
name|fctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch event handlers.  */
end_comment

begin_function
specifier|static
name|void
name|fctx_timeout
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_timerevent_t
modifier|*
name|tevent
init|=
operator|(
name|isc_timerevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"timeout"
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
name|dns_resstatscounter_querytimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_LIFE
condition|)
block|{
name|fctx
operator|->
name|reason
operator|=
name|NULL
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|ISC_R_TIMEDOUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_result_t
name|result
decl_stmt|;
name|fctx
operator|->
name|timeouts
operator|++
expr_stmt|;
name|fctx
operator|->
name|timeout
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * We could cancel the running queries here, or we could let 		 * them keep going.  Since we normally use separate sockets for 		 * different queries, we adopt the former approach to reduce 		 * the number of open sockets: cancel the oldest query if it 		 * expired after the query had started (this is usually the 		 * case but is not always so, depending on the task schedule 		 * timing). 		 */
name|query
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|!=
name|NULL
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|tevent
operator|->
name|due
argument_list|,
operator|&
name|query
operator|->
name|start
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"query timed out; no response"
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
comment|/* 		 * Our timer has triggered.  Reestablish the fctx lifetime 		 * timer. 		 */
name|result
operator|=
name|fctx_starttimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
comment|/* 			 * Keep trying. 			 */
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_shutdown
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|cevent
decl_stmt|;
comment|/* 	 * Start the shutdown process for fctx, if it isn't already underway. 	 */
name|FCTXTRACE
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
comment|/* 	 * The caller must be holding the appropriate bucket lock. 	 */
if|if
condition|(
name|fctx
operator|->
name|want_shutdown
condition|)
return|return;
name|fctx
operator|->
name|want_shutdown
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Unless we're still initializing (in which case the 	 * control event is still outstanding), we need to post 	 * the control event to tell the fetch we want it to 	 * exit. 	 */
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_init
condition|)
block|{
name|cevent
operator|=
operator|&
name|fctx
operator|->
name|control_event
expr_stmt|;
name|isc_task_send
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
argument_list|,
operator|&
name|cevent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_doshutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|dns_validator_t
modifier|*
name|validator
decl_stmt|;
name|isc_boolean_t
name|dodestroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"doshutdown"
argument_list|)
expr_stmt|;
comment|/* 	 * An fctx that is shutting down is no longer in ADDRWAIT mode. 	 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
comment|/* 	 * Cancel all pending validators.  Note that this must be done 	 * without the bucket lock held, since that could cause deadlock. 	 */
name|validator
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
expr_stmt|;
while|while
condition|(
name|validator
operator|!=
name|NULL
condition|)
block|{
name|dns_validator_cancel
argument_list|(
name|validator
argument_list|)
expr_stmt|;
name|validator
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fctx
operator|->
name|nsfetch
operator|!=
name|NULL
condition|)
name|dns_resolver_cancelfetch
argument_list|(
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
comment|/* 	 * Shut down anything that is still running on behalf of this 	 * fetch.  To avoid deadlock with the ADB, we must do this 	 * before we lock the bucket lock. 	 */
name|fctx_stopeverything
argument_list|(
name|fctx
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_SHUTTINGDOWN
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_active
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|want_shutdown
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_done
condition|)
block|{
name|fctx
operator|->
name|state
operator|=
name|fetchstate_done
expr_stmt|;
name|fctx_sendevents
argument_list|(
name|fctx
argument_list|,
name|ISC_R_CANCELED
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|pending
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|nqueries
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
block|{
name|bucket_empty
operator|=
name|fctx_unlink
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|dodestroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dodestroy
condition|)
block|{
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_start
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|,
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|dodestroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|want_shutdown
condition|)
block|{
comment|/* 		 * We haven't started this fctx yet, and we've been requested 		 * to shut it down. 		 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_SHUTTINGDOWN
expr_stmt|;
name|fctx
operator|->
name|state
operator|=
name|fetchstate_done
expr_stmt|;
name|fctx_sendevents
argument_list|(
name|fctx
argument_list|,
name|ISC_R_CANCELED
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* 		 * Since we haven't started, we INSIST that we have no 		 * pending ADB finds and no pending validations. 		 */
name|INSIST
argument_list|(
name|fctx
operator|->
name|pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|nqueries
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
block|{
comment|/* 			 * It's now safe to destroy this fctx. 			 */
name|bucket_empty
operator|=
name|fctx_unlink
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|dodestroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Normal fctx startup. 		 */
name|fctx
operator|->
name|state
operator|=
name|fetchstate_active
expr_stmt|;
comment|/* 		 * Reset the control event for later use in shutting down 		 * the fctx. 		 */
name|ISC_EVENT_INIT
argument_list|(
name|event
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_FETCHCONTROL
argument_list|,
name|fctx_doshutdown
argument_list|,
name|fctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|dodestroy
argument_list|)
expr_stmt|;
comment|/* 		 * All is well.  Start working on the fetch. 		 */
name|result
operator|=
name|fctx_starttimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_FALSE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dodestroy
condition|)
block|{
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch Creation, Joining, and Cancelation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_join
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|client
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_fetch_t
modifier|*
name|fetch
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|clone
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"join"
argument_list|)
expr_stmt|;
comment|/* 	 * We store the task we're going to send this event to in the 	 * sender field.  We'll make the fetch the sender when we actually 	 * send the event. 	 */
name|clone
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|clone
argument_list|)
expr_stmt|;
name|event
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
name|clone
argument_list|,
name|DNS_EVENT_FETCHDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
name|isc_task_detach
argument_list|(
operator|&
name|clone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|event
operator|->
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
name|event
operator|->
name|qtype
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
name|event
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|event
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|event
operator|->
name|rdataset
operator|=
name|rdataset
expr_stmt|;
name|event
operator|->
name|sigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|event
operator|->
name|fetch
operator|=
name|fetch
expr_stmt|;
name|event
operator|->
name|client
operator|=
name|client
expr_stmt|;
name|event
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that we can store the sigrdataset in the 	 * first event if it is needed by any of the events. 	 */
if|if
condition|(
name|event
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
name|ISC_LIST_PREPEND
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|++
expr_stmt|;
name|fctx
operator|->
name|client
operator|=
name|client
expr_stmt|;
name|fetch
operator|->
name|magic
operator|=
name|DNS_FETCH_MAGIC
expr_stmt|;
name|fetch
operator|->
name|private
operator|=
name|fctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_ns_ttl
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"log_ns_ttl: fctx %p: %s: %s (in '%s'?): %u %u"
argument_list|,
name|fctx
argument_list|,
name|where
argument_list|,
name|namebuf
argument_list|,
name|domainbuf
argument_list|,
name|fctx
operator|->
name|ns_ttl_ok
argument_list|,
name|fctx
operator|->
name|ns_ttl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fctx_create
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|unsigned
name|int
name|bucketnum
parameter_list|,
name|unsigned
name|int
name|depth
parameter_list|,
name|isc_counter_t
modifier|*
name|qc
parameter_list|,
name|fetchctx_t
modifier|*
modifier|*
name|fctxp
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|iresult
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|unsigned
name|int
name|findoptions
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
operator|+
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 	 * Caller must be holding the lock for bucket number 'bucketnum'. 	 */
name|REQUIRE
argument_list|(
name|fctxp
operator|!=
name|NULL
operator|&&
operator|*
name|fctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|mctx
expr_stmt|;
name|fctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|fctx
operator|->
name|qc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qc
operator|!=
name|NULL
condition|)
block|{
name|isc_counter_attach
argument_list|(
name|qc
argument_list|,
operator|&
name|fctx
operator|->
name|qc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|isc_counter_create
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|maxqueries
argument_list|,
operator|&
name|fctx
operator|->
name|qc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_fetch
goto|;
block|}
comment|/* 	 * Make fctx->info point to a copy of a formatted string 	 * "name/type". 	 */
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|/* checked */
name|strcat
argument_list|(
name|buf
argument_list|,
name|typebuf
argument_list|)
expr_stmt|;
comment|/* checked */
name|fctx
operator|->
name|info
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|info
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_counter
goto|;
block|}
name|FCTXTRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|name
argument_list|,
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_info
goto|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|fctx
operator|->
name|options
operator|=
name|options
expr_stmt|;
comment|/* 	 * Note!  We do not attach to the task.  We are relying on the 	 * resolver to ensure that this task doesn't go away while we are 	 * using it. 	 */
name|fctx
operator|->
name|res
operator|=
name|res
expr_stmt|;
name|fctx
operator|->
name|references
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|bucketnum
operator|=
name|bucketnum
expr_stmt|;
name|fctx
operator|->
name|dbucketnum
operator|=
name|RES_NOBUCKET
expr_stmt|;
name|fctx
operator|->
name|state
operator|=
name|fetchstate_init
expr_stmt|;
name|fctx
operator|->
name|want_shutdown
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|cloned
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|forwarders
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|fwdpolicy
operator|=
name|dns_fwdpolicy_none
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|bad
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|edns
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|edns512
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|bad_edns
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|validator
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|altfind
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|restarts
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|querysent
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|referrals
operator|=
literal|0
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|fctx
operator|->
name|start
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|timeouts
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|lamecount
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|quotacount
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|adberr
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|neterr
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|badresp
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|findfail
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|valfail
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
name|fctx
operator|->
name|vresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fctx
operator|->
name|exitline
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* sentinel */
name|fctx
operator|->
name|logged
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|spilled
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|nqueries
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|reason
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|rand_buf
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|rand_bits
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|timeout
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|addrinfo
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|client
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|ns_ttl
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|ns_ttl_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|nsfetch
operator|=
name|NULL
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|fctx
operator|->
name|nsrrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
block|{
name|dns_forwarders_t
modifier|*
name|forwarders
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|dns_name_t
modifier|*
name|fwdname
init|=
name|name
decl_stmt|;
name|dns_name_t
name|suffix
decl_stmt|;
comment|/* 		 * DS records are found in the parent server. Strip one 		 * leading label from the name (to be used in finding 		 * the forwarder). 		 */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|fctx
operator|->
name|type
argument_list|)
operator|&&
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|>
literal|1
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|suffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|suffix
argument_list|)
expr_stmt|;
name|fwdname
operator|=
operator|&
name|suffix
expr_stmt|;
block|}
comment|/* Find the forwarder for this name. */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|domain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_fwdtable_find2
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|fwdtable
argument_list|,
name|fwdname
argument_list|,
name|domain
argument_list|,
operator|&
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|fctx
operator|->
name|fwdpolicy
operator|=
name|forwarders
operator|->
name|fwdpolicy
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|fwdpolicy
operator|!=
name|dns_fwdpolicy_only
condition|)
block|{
comment|/* 			 * The caller didn't supply a query domain and 			 * nameservers, and we're not in forward-only mode, 			 * so find the best nameservers to use. 			 */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|fctx
operator|->
name|type
argument_list|)
condition|)
name|findoptions
operator||=
name|DNS_DBFIND_NOEXACT
expr_stmt|;
name|result
operator|=
name|dns_view_findzonecut
argument_list|(
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
literal|0
argument_list|,
name|findoptions
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_name
goto|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_name
goto|;
block|}
name|fctx
operator|->
name|ns_ttl
operator|=
name|fctx
operator|->
name|nameservers
operator|.
name|ttl
expr_stmt|;
name|fctx
operator|->
name|ns_ttl_ok
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're in forward-only mode.  Set the query domain. 			 */
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_name
goto|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_name
goto|;
name|dns_rdataset_clone
argument_list|(
name|nameservers
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|ns_ttl
operator|=
name|fctx
operator|->
name|nameservers
operator|.
name|ttl
expr_stmt|;
name|fctx
operator|->
name|ns_ttl_ok
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
comment|/* 	 * Are there too many simultaneous queries for this domain? 	 */
name|result
operator|=
name|fcount_incr
argument_list|(
name|fctx
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|fctx
operator|->
name|res
operator|->
name|quotaresp
index|[
name|dns_quotatype_zone
index|]
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_zonequota
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_domain
goto|;
block|}
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|log_ns_ttl
argument_list|(
name|fctx
argument_list|,
literal|"fctx_create"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dns_name_issubdomain
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|qmessage
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|,
operator|&
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
goto|goto
name|cleanup_fcount
goto|;
else|#
directive|else
goto|goto
name|cleanup_domain
goto|;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
name|fctx
operator|->
name|rmessage
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|fctx
operator|->
name|rmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_qmessage
goto|;
comment|/* 	 * Compute an expiration time for the entire fetch. 	 */
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
name|res
operator|->
name|query_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iresult
operator|=
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|fctx
operator|->
name|expires
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|iresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_time_nowplusinterval: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|iresult
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_rmessage
goto|;
block|}
comment|/* 	 * Default retry interval initialization.  We set the interval now 	 * mostly so it won't be uninitialized.  It will be set to the 	 * correct value before a query is issued. 	 */
name|isc_interval_set
argument_list|(
operator|&
name|fctx
operator|->
name|interval
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Create an inactive timer.  It will be made active when the fetch 	 * is actually started. 	 */
name|fctx
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|iresult
operator|=
name|isc_timer_create
argument_list|(
name|res
operator|->
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|task
argument_list|,
name|fctx_timeout
argument_list|,
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|iresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timer_create: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|iresult
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_rmessage
goto|;
block|}
comment|/* 	 * Attach to the view's cache and adb. 	 */
name|fctx
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|res
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|fctx
operator|->
name|cache
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|adb
operator|=
name|NULL
expr_stmt|;
name|dns_adb_attach
argument_list|(
name|res
operator|->
name|view
operator|->
name|adb
argument_list|,
operator|&
name|fctx
operator|->
name|adb
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|magic
operator|=
name|FCTX_MAGIC
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|,
name|fctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|res
operator|->
name|nfctx
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
operator|*
name|fctxp
operator|=
name|fctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_rmessage
label|:
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|rmessage
argument_list|)
expr_stmt|;
name|cleanup_qmessage
label|:
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|cleanup_fcount
label|:
name|fcount_decr
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|cleanup_domain
label|:
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|0
condition|)
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|cleanup_name
label|:
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|cleanup_info
label|:
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
name|cleanup_counter
label|:
name|isc_counter_detach
argument_list|(
operator|&
name|fctx
operator|->
name|qc
argument_list|)
expr_stmt|;
name|cleanup_fetch
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|fctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle Responses  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|is_lame
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_message_t
modifier|*
name|message
init|=
name|fctx
operator|->
name|rmessage
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
operator|&&
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_nxdomain
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_namereln_t
name|namereln
decl_stmt|;
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_ns
condition|)
continue|continue;
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|namereln
operator|==
name|dns_namereln_equal
operator|&&
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|namereln
operator|==
name|dns_namereln_subdomain
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_lame
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_LAME_SERVERS
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"lame server resolving '%s' (in '%s'?): %s"
argument_list|,
name|namebuf
argument_list|,
name|domainbuf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_formerr
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|nsbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|clbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|clmsg
init|=
literal|""
decl_stmt|;
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|fctx
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|nsbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nsbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|client
operator|!=
name|NULL
condition|)
block|{
name|clmsg
operator|=
literal|" for client "
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
name|fctx
operator|->
name|client
argument_list|,
name|clbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|clbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"DNS format error from %s resolving %s%s%s: %s"
argument_list|,
name|nsbuf
argument_list|,
name|fctx
operator|->
name|info
argument_list|,
name|clmsg
argument_list|,
name|clbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|same_question
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|fctx
operator|->
name|rmessage
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
comment|/* 	 * Caller must be holding the fctx lock. 	 */
comment|/* 	 * XXXRTH  Currently we support only one question. 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_QUESTION
index|]
operator|!=
literal|1
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"too many questions"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|rdataset
operator|->
name|type
operator|||
name|fctx
operator|->
name|res
operator|->
name|rdclass
operator|!=
name|rdataset
operator|->
name|rdclass
operator|||
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|class
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|char
name|type
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|class
argument_list|,
sizeof|sizeof
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"question section mismatch: got %s/%s/%s"
argument_list|,
name|namebuf
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clone_results
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|hevent
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|hname
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"clone_results"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up any other events to have the same data as the first 	 * event. 	 * 	 * Caller must be holding the appropriate lock. 	 */
name|fctx
operator|->
name|cloned
operator|=
name|ISC_TRUE
expr_stmt|;
name|hevent
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|hevent
operator|==
name|NULL
condition|)
return|return;
name|hname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|hevent
operator|->
name|foundname
argument_list|)
expr_stmt|;
for|for
control|(
name|event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|hevent
argument_list|,
name|ev_link
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
control|)
block|{
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|hname
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|event
operator|->
name|result
operator|=
name|result
expr_stmt|;
else|else
name|event
operator|->
name|result
operator|=
name|hevent
operator|->
name|result
expr_stmt|;
name|dns_db_attach
argument_list|(
name|hevent
operator|->
name|db
argument_list|,
operator|&
name|event
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_attachnode
argument_list|(
name|hevent
operator|->
name|db
argument_list|,
name|hevent
operator|->
name|node
argument_list|,
operator|&
name|event
operator|->
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|hevent
operator|->
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|hevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_clone
argument_list|(
name|hevent
operator|->
name|rdataset
argument_list|,
name|event
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
operator|(
name|hevent
operator|->
name|sigrdataset
operator|==
name|NULL
operator|&&
name|event
operator|->
name|sigrdataset
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hevent
operator|->
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|hevent
operator|->
name|sigrdataset
argument_list|)
operator|&&
name|event
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
name|dns_rdataset_clone
argument_list|(
name|hevent
operator|->
name|sigrdataset
argument_list|,
name|event
operator|->
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CACHE
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CACHE) != 0)
end_define

begin_define
define|#
directive|define
name|ANSWER
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_ANSWER) != 0)
end_define

begin_define
define|#
directive|define
name|ANSWERSIG
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_ANSWERSIG) != 0)
end_define

begin_define
define|#
directive|define
name|EXTERNAL
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_EXTERNAL) != 0)
end_define

begin_define
define|#
directive|define
name|CHAINING
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CHAINING) != 0)
end_define

begin_define
define|#
directive|define
name|CHASE
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CHASE) != 0)
end_define

begin_define
define|#
directive|define
name|CHECKNAMES
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CHECKNAMES) != 0)
end_define

begin_comment
comment|/*  * Destroy '*fctx' if it is ready to be destroyed (i.e., if it has  * no references and is no longer waiting for any events).  *  * Requires:  *      '*fctx' is shutting down.  *  * Returns:  *	true if the resolver is exiting and this is the last fctx in the bucket.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|maybe_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|locked
parameter_list|)
block|{
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
init|=
name|fctx
operator|->
name|res
decl_stmt|;
name|dns_validator_t
modifier|*
name|validator
decl_stmt|,
modifier|*
name|next_validator
decl_stmt|;
name|isc_boolean_t
name|dodestroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|pending
operator|!=
literal|0
operator|||
name|fctx
operator|->
name|nqueries
operator|!=
literal|0
condition|)
goto|goto
name|unlock
goto|;
for|for
control|(
name|validator
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
init|;
name|validator
operator|!=
name|NULL
condition|;
name|validator
operator|=
name|next_validator
control|)
block|{
name|next_validator
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_validator_cancel
argument_list|(
name|validator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
block|{
name|bucket_empty
operator|=
name|fctx_unlink
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|dodestroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|unlock
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dodestroy
condition|)
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|bucket_empty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The validator has finished.  */
end_comment

begin_function
specifier|static
name|void
name|validated
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|nsnode
init|=
name|NULL
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|hevent
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|ardataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|asigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_valarg_t
modifier|*
name|valarg
decl_stmt|;
name|dns_validatorevent_t
modifier|*
name|vevent
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_boolean_t
name|chaining
decl_stmt|;
name|isc_boolean_t
name|negative
decl_stmt|;
name|isc_boolean_t
name|sentresponse
decl_stmt|;
name|isc_result_t
name|eresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|isc_uint32_t
name|bucketnum
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|/* for now */
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_VALIDATORDONE
argument_list|)
expr_stmt|;
name|valarg
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|fctx
operator|=
name|valarg
operator|->
name|fctx
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|addrinfo
operator|=
name|valarg
operator|->
name|addrinfo
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|vevent
operator|=
operator|(
name|dns_validatorevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|fctx
operator|->
name|vresult
operator|=
name|vevent
operator|->
name|result
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"received validation completion event"
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|validators
argument_list|,
name|vevent
operator|->
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|validator
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Destroy the validator early so that we can 	 * destroy the fctx if necessary. 	 */
name|dns_validator_destroy
argument_list|(
operator|&
name|vevent
operator|->
name|validator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|mctx
argument_list|,
name|valarg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|valarg
argument_list|)
argument_list|)
expr_stmt|;
name|negative
operator|=
name|ISC_TF
argument_list|(
name|vevent
operator|->
name|rdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sentresponse
operator|=
name|ISC_TF
argument_list|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If shutting down, ignore the results.  Check to see if we're 	 * done waiting for validator completions and ADB pending events; if 	 * so, destroy the fctx. 	 */
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
operator|&&
operator|!
name|sentresponse
condition|)
block|{
name|isc_boolean_t
name|bucket_empty
decl_stmt|;
name|bucket_empty
operator|=
name|maybe_destroy
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_event
goto|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * If chaining, we need to make sure that the right result code is 	 * returned, and that the rdatasets are bound. 	 */
if|if
condition|(
name|vevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|negative
operator|&&
name|vevent
operator|->
name|rdataset
operator|!=
name|NULL
operator|&&
name|CHAINING
argument_list|(
name|vevent
operator|->
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|vevent
operator|->
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|eresult
operator|=
name|DNS_R_CNAME
expr_stmt|;
else|else
block|{
name|INSIST
argument_list|(
name|vevent
operator|->
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_DNAME
expr_stmt|;
block|}
name|chaining
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|chaining
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Either we're not shutting down, or we are shutting down but want 	 * to cache the result anyway (if this was a validation started by 	 * a query with cd set) 	 */
name|hevent
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|hevent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|negative
operator|&&
operator|!
name|chaining
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_sig
operator|)
condition|)
block|{
comment|/* 			 * Don't bind rdatasets; the caller 			 * will iterate the node. 			 */
block|}
else|else
block|{
name|ardataset
operator|=
name|hevent
operator|->
name|rdataset
expr_stmt|;
name|asigrdataset
operator|=
name|hevent
operator|->
name|sigrdataset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vevent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"validation failed"
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_valfail
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|valfail
operator|++
expr_stmt|;
name|fctx
operator|->
name|vresult
operator|=
name|vevent
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|vresult
operator|!=
name|DNS_R_BROKENCHAIN
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|vevent
operator|->
name|rdataset
operator|!=
name|NULL
condition|)
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|(
name|void
operator|)
name|dns_db_deleterdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|vevent
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_db_deleterdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|vevent
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fctx
operator|->
name|vresult
operator|==
name|DNS_R_BROKENCHAIN
operator|&&
operator|!
name|negative
condition|)
block|{
comment|/* 			 * Cache the data as pending for later validation. 			 */
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|vevent
operator|->
name|rdataset
operator|!=
name|NULL
condition|)
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|vevent
operator|->
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|vevent
operator|->
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|fctx
operator|->
name|vresult
expr_stmt|;
name|add_bad
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|result
argument_list|,
name|badns_validation
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|validator
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|validator
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|validator
operator|!=
name|NULL
condition|)
name|dns_validator_send
argument_list|(
name|fctx
operator|->
name|validator
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sentresponse
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_BROKENCHAIN
condition|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_time_t
name|expire
decl_stmt|;
name|isc_interval_t
name|i
decl_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
name|DNS_BADCACHE_TTL
argument_list|(
name|fctx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|expire
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_dnskey
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_dlv
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|)
operator|&&
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_resolver_addbadcache
argument_list|(
name|res
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
operator|&
name|expire
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
block|}
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
return|return;
block|}
if|if
condition|(
name|negative
condition|)
block|{
name|dns_rdatatype_t
name|covers
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"nonexistence validation OK"
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_valnegsuccess
argument_list|)
expr_stmt|;
comment|/* 		 * Cache DS NXDOMAIN seperately to other types. 		 */
if|if
condition|(
name|fctx
operator|->
name|rmessage
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_ds
condition|)
name|covers
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|covers
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|noanswer_response
goto|;
comment|/* 		 * If we are asking for a SOA record set the cache time 		 * to zero to facilitate locating the containing zone of 		 * a arbitrary zone. 		 */
name|ttl
operator|=
name|res
operator|->
name|view
operator|->
name|maxncachettl
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|covers
operator|==
name|dns_rdatatype_any
operator|&&
name|res
operator|->
name|zero_no_soa_ttl
condition|)
name|ttl
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ncache_adderesult
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|ttl
argument_list|,
name|vevent
operator|->
name|optout
argument_list|,
name|vevent
operator|->
name|secure
argument_list|,
name|ardataset
argument_list|,
operator|&
name|eresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|noanswer_response
goto|;
goto|goto
name|answer_response
goto|;
block|}
else|else
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_valsuccess
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"validation OK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vevent
operator|->
name|proofs
index|[
name|DNS_VALIDATOR_NOQNAMEPROOF
index|]
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rdataset_addnoqname
argument_list|(
name|vevent
operator|->
name|rdataset
argument_list|,
name|vevent
operator|->
name|proofs
index|[
name|DNS_VALIDATOR_NOQNAMEPROOF
index|]
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vevent
operator|->
name|sigrdataset
operator|->
name|ttl
operator|=
name|vevent
operator|->
name|rdataset
operator|->
name|ttl
expr_stmt|;
if|if
condition|(
name|vevent
operator|->
name|proofs
index|[
name|DNS_VALIDATOR_CLOSESTENCLOSER
index|]
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rdataset_addclosest
argument_list|(
name|vevent
operator|->
name|rdataset
argument_list|,
name|vevent
operator|->
name|proofs
index|[
name|DNS_VALIDATOR_CLOSESTENCLOSER
index|]
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vevent
operator|->
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_answer
operator|&&
name|vevent
operator|->
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
name|dns_name_t
modifier|*
name|noqname
init|=
name|NULL
decl_stmt|;
name|tresult
operator|=
name|findnoqname
argument_list|(
name|fctx
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|vevent
operator|->
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|noqname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|dns_rdataset_addnoqname
argument_list|(
name|vevent
operator|->
name|rdataset
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|tresult
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The data was already cached as pending data. 	 * Re-cache it as secure and bind the cached 	 * rdatasets to the first event on the fetch 	 * event list. 	 */
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|noanswer_response
goto|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|vevent
operator|->
name|rdataset
argument_list|,
literal|0
argument_list|,
name|ardataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_UNCHANGED
condition|)
goto|goto
name|noanswer_response
goto|;
if|if
condition|(
name|ardataset
operator|!=
name|NULL
operator|&&
name|NEGATIVE
argument_list|(
name|ardataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|ardataset
argument_list|)
condition|)
name|eresult
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|eresult
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|vevent
operator|->
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|asigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_UNCHANGED
condition|)
goto|goto
name|noanswer_response
goto|;
block|}
if|if
condition|(
name|sentresponse
condition|)
block|{
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 		 * If we only deferred the destroy because we wanted to cache 		 * the data, destroy now. 		 */
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
condition|)
name|bucket_empty
operator|=
name|maybe_destroy
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_event
goto|;
block|}
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|negative
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_sig
argument_list|)
expr_stmt|;
comment|/* 		 * Don't send a response yet - we have 		 * more rdatasets that still need to 		 * be validated. 		 */
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|dns_validator_send
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_event
goto|;
block|}
name|answer_response
label|:
comment|/* 	 * Cache any NS/NSEC records that happened to be validated. 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_ns
operator|&&
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec
operator|)
operator|||
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
condition|)
continue|continue;
for|for
control|(
name|sigrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|sigrdataset
operator|!=
name|NULL
condition|;
name|sigrdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sigrdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|sigrdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
operator|||
name|sigrdataset
operator|->
name|covers
operator|!=
name|rdataset
operator|->
name|type
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
condition|)
continue|continue;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|nsnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|nsnode
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|nsnode
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|nsnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
comment|/* 	 * Respond with an answer, positive or negative, 	 * as opposed to an error.  'node' must be non-NULL. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_HAVEANSWER
expr_stmt|;
if|if
condition|(
name|hevent
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Negative results must be indicated in event->result. 		 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|hevent
operator|->
name|rdataset
argument_list|)
operator|&&
name|NEGATIVE
argument_list|(
name|hevent
operator|->
name|rdataset
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|eresult
operator|==
name|DNS_R_NCACHENXDOMAIN
operator|||
name|eresult
operator|==
name|DNS_R_NCACHENXRRSET
argument_list|)
expr_stmt|;
block|}
name|hevent
operator|->
name|result
operator|=
name|eresult
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_copy
argument_list|(
name|vevent
operator|->
name|name
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|hevent
operator|->
name|foundname
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|hevent
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_transfernode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|hevent
operator|->
name|node
argument_list|)
expr_stmt|;
name|clone_results
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
name|noanswer_response
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
name|cleanup_event
label|:
name|INSIST
argument_list|(
name|node
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_log
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
init|=
name|arg
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|level
argument_list|,
literal|"fctx %p(%s): %s"
argument_list|,
name|fctx
argument_list|,
name|fctx
operator|->
name|info
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|findnoqname
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|noqnamep
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|nrdataset
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|dns_section_t
name|section
decl_stmt|;
name|dns_name_t
modifier|*
name|zonename
decl_stmt|;
name|dns_fixedname_t
name|fzonename
decl_stmt|;
name|dns_name_t
modifier|*
name|closest
decl_stmt|;
name|dns_fixedname_t
name|fclosest
decl_stmt|;
name|dns_name_t
modifier|*
name|nearest
decl_stmt|;
name|dns_fixedname_t
name|fnearest
decl_stmt|;
name|dns_rdatatype_t
name|found
init|=
name|dns_rdatatype_none
decl_stmt|;
name|dns_name_t
modifier|*
name|noqname
init|=
name|NULL
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"findnoqname"
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|noqnamep
operator|!=
name|NULL
operator|&&
operator|*
name|noqnamep
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find the SIG for this rdataset, if we have it. 	 */
for|for
control|(
name|sigrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|sigrdataset
operator|!=
name|NULL
condition|;
name|sigrdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sigrdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|sigrdataset
operator|->
name|covers
operator|==
name|type
condition|)
break|break;
block|}
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|sigrdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Wildcard has rrsig.labels< labels - 1. */
if|if
condition|(
name|rrsig
operator|.
name|labels
operator|+
literal|1U
operator|>=
name|labels
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fzonename
argument_list|)
expr_stmt|;
name|zonename
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fzonename
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fclosest
argument_list|)
expr_stmt|;
name|closest
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fclosest
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnearest
argument_list|)
expr_stmt|;
name|nearest
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnearest
argument_list|)
expr_stmt|;
define|#
directive|define
name|NXND
parameter_list|(
name|x
parameter_list|)
value|((x) == ISC_R_SUCCESS)
name|section
operator|=
name|DNS_SECTION_AUTHORITY
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
control|)
block|{
name|dns_name_t
modifier|*
name|nsec
init|=
name|NULL
decl_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|,
operator|&
name|nsec
argument_list|)
expr_stmt|;
for|for
control|(
name|nrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|nsec
operator|->
name|list
argument_list|)
init|;
name|nrdataset
operator|!=
name|NULL
condition|;
name|nrdataset
operator|=
name|next
control|)
block|{
name|isc_boolean_t
name|data
init|=
name|ISC_FALSE
decl_stmt|,
name|exists
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|optout
init|=
name|ISC_FALSE
decl_stmt|,
name|unknown
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|setclosest
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|setnearest
init|=
name|ISC_FALSE
decl_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec
operator|&&
name|nrdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec3
condition|)
continue|continue;
if|if
condition|(
name|nrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
operator|&&
name|NXND
argument_list|(
name|dns_nsec_noexistnodata
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|nsec
argument_list|,
name|nrdataset
argument_list|,
operator|&
name|exists
argument_list|,
operator|&
name|data
argument_list|,
name|NULL
argument_list|,
name|fctx_log
argument_list|,
name|fctx
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|noqname
operator|=
name|nsec
expr_stmt|;
name|found
operator|=
name|dns_rdatatype_nsec
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|&&
name|NXND
argument_list|(
name|dns_nsec3_noexistnodata
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|nsec
argument_list|,
name|nrdataset
argument_list|,
name|zonename
argument_list|,
operator|&
name|exists
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|optout
argument_list|,
operator|&
name|unknown
argument_list|,
operator|&
name|setclosest
argument_list|,
operator|&
name|setnearest
argument_list|,
name|closest
argument_list|,
name|nearest
argument_list|,
name|fctx_log
argument_list|,
name|fctx
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|exists
operator|&&
name|setnearest
condition|)
block|{
name|noqname
operator|=
name|nsec
expr_stmt|;
name|found
operator|=
name|dns_rdatatype_nsec3
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|sigrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|noqname
operator|->
name|list
argument_list|)
init|;
name|sigrdataset
operator|!=
name|NULL
condition|;
name|sigrdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sigrdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|sigrdataset
operator|->
name|covers
operator|==
name|found
condition|)
break|break;
block|}
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
operator|*
name|noqnamep
operator|=
name|noqname
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cache_name
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|addedrdataset
decl_stmt|,
modifier|*
name|ardataset
decl_stmt|,
modifier|*
name|asigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|valrdataset
init|=
name|NULL
decl_stmt|,
modifier|*
name|valsigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|anodep
decl_stmt|;
name|dns_db_t
modifier|*
modifier|*
name|adbp
decl_stmt|;
name|dns_name_t
modifier|*
name|aname
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|need_validation
decl_stmt|,
name|secure_domain
decl_stmt|,
name|have_answer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_boolean_t
name|fail
decl_stmt|;
name|unsigned
name|int
name|valoptions
init|=
literal|0
decl_stmt|;
comment|/* 	 * The appropriate bucket lock must be held. 	 */
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
name|POST
argument_list|(
name|need_validation
argument_list|)
expr_stmt|;
name|secure_domain
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_answer
operator|=
name|ISC_FALSE
expr_stmt|;
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|task
operator|=
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
expr_stmt|;
comment|/* 	 * Is DNSSEC validation required for this name? 	 */
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|enablevalidation
condition|)
block|{
name|result
operator|=
name|dns_view_issecuredomain
argument_list|(
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
operator|!
name|secure_domain
operator|&&
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
block|{
name|valoptions
operator|=
name|DNS_VALIDATOR_DLV
expr_stmt|;
name|secure_domain
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
condition|)
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
else|else
name|need_validation
operator|=
name|secure_domain
expr_stmt|;
name|adbp
operator|=
name|NULL
expr_stmt|;
name|aname
operator|=
name|NULL
expr_stmt|;
name|anodep
operator|=
name|NULL
expr_stmt|;
name|ardataset
operator|=
name|NULL
expr_stmt|;
name|asigrdataset
operator|=
name|NULL
expr_stmt|;
name|event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ANSWER
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|need_validation
condition|)
block|{
name|have_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|adbp
operator|=
operator|&
name|event
operator|->
name|db
expr_stmt|;
name|aname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|aname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|anodep
operator|=
operator|&
name|event
operator|->
name|node
expr_stmt|;
comment|/* 			 * If this is an ANY, SIG or RRSIG query, we're not 			 * going to return any rdatasets, unless we encountered 			 * a CNAME or DNAME as "the answer".  In this case, 			 * we're going to return DNS_R_CNAME or DNS_R_DNAME 			 * and we must set up the rdatasets. 			 */
if|if
condition|(
operator|(
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_sig
operator|)
operator|||
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_CHAINING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ardataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
name|asigrdataset
operator|=
name|event
operator|->
name|sigrdataset
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Find or create the cache node. 	 */
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Cache or validate each cacheable rdataset. 	 */
name|fail
operator|=
name|ISC_TF
argument_list|(
operator|(
name|fctx
operator|->
name|res
operator|->
name|options
operator|&
name|DNS_RESOLVER_CHECKNAMESFAIL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|rdataset
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|CHECKNAMES
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"check-names %s %s/%s/%s"
argument_list|,
name|fail
condition|?
literal|"failure"
else|:
literal|"warning"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
block|{
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_BADNAME
operator|)
return|;
block|}
continue|continue;
block|}
block|}
comment|/* 		 * Enforce the configure maximum cache TTL. 		 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|>
name|res
operator|->
name|view
operator|->
name|maxcachettl
condition|)
name|rdataset
operator|->
name|ttl
operator|=
name|res
operator|->
name|view
operator|->
name|maxcachettl
expr_stmt|;
comment|/* 		 * Find the SIG for this rdataset, if we have it. 		 */
for|for
control|(
name|sigrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|sigrdataset
operator|!=
name|NULL
condition|;
name|sigrdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sigrdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|sigrdataset
operator|->
name|covers
operator|==
name|rdataset
operator|->
name|type
condition|)
break|break;
block|}
comment|/* 		 * If this RRset is in a secure domain, is in bailiwick, 		 * and is not glue, attempt DNSSEC validation.	(We do not 		 * attempt to validate glue or out-of-bailiwick data--even 		 * though there might be some performance benefit to doing 		 * so--because it makes it simpler and safer to ensure that 		 * records from a secure domain are only cached if validated 		 * within the context of a query to the domain that owns 		 * them.) 		 */
if|if
condition|(
name|secure_domain
operator|&&
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_glue
operator|&&
operator|!
name|EXTERNAL
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|dns_trust_t
name|trust
decl_stmt|;
comment|/* 			 * RRSIGs are validated as part of validating the 			 * type they cover. 			 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
continue|continue;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|need_validation
condition|)
block|{
comment|/* 					 * Ignore non-answer rdatasets that 					 * are missing signatures. 					 */
continue|continue;
block|}
block|}
comment|/* 			 * Normalize the rdataset and sigrdataset TTLs. 			 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
name|rdataset
operator|->
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
name|sigrdataset
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|sigrdataset
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
block|}
comment|/* 			 * Cache this rdataset/sigrdataset pair as 			 * pending data.  Track whether it was additional 			 * or not. 			 */
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_additional
condition|)
name|trust
operator|=
name|dns_trust_pending_additional
expr_stmt|;
else|else
name|trust
operator|=
name|dns_trust_pending_answer
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|trust
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdataset
operator|->
name|trust
operator|=
name|trust
expr_stmt|;
if|if
condition|(
operator|!
name|need_validation
operator|||
operator|!
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
name|dns_name_t
modifier|*
name|noqname
init|=
name|NULL
decl_stmt|;
name|tresult
operator|=
name|findnoqname
argument_list|(
name|fctx
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|noqname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|dns_rdataset_addnoqname
argument_list|(
name|rdataset
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|tresult
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
name|addedrdataset
operator|=
name|ardataset
expr_stmt|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|!
name|need_validation
operator|&&
name|ardataset
operator|!=
name|NULL
operator|&&
name|NEGATIVE
argument_list|(
name|ardataset
argument_list|)
condition|)
block|{
comment|/* 						 * The answer in the cache is 						 * better than the answer we 						 * found, and is a negative 						 * cache entry, so we must set 						 * eresult appropriately. 						 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|ardataset
argument_list|)
condition|)
name|eresult
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|eresult
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
comment|/* 						 * We have a negative response 						 * from the cache so don't 						 * attempt to add the RRSIG 						 * rrset. 						 */
continue|continue;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
name|addedrdataset
operator|=
name|asigrdataset
expr_stmt|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|need_validation
condition|)
block|{
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_sig
condition|)
block|{
comment|/* 					 * This is The Answer.  We will 					 * validate it, but first we cache 					 * the rest of the response - it may 					 * contain useful keys. 					 */
name|INSIST
argument_list|(
name|valrdataset
operator|==
name|NULL
operator|&&
name|valsigrdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|valrdataset
operator|=
name|rdataset
expr_stmt|;
name|valsigrdataset
operator|=
name|sigrdataset
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * This is one of (potentially) 					 * multiple answers to an ANY 					 * or SIG query.  To keep things 					 * simple, we just start the 					 * validator right away rather 					 * than caching first and 					 * having to remember which 					 * rdatasets needed validation. 					 */
name|result
operator|=
name|valcreate
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|valoptions
argument_list|,
name|task
argument_list|)
expr_stmt|;
comment|/* 					 * Defer any further validations. 					 * This prevents multiple validators 					 * from manipulating fctx->rmessage 					 * simultaneously. 					 */
name|valoptions
operator||=
name|DNS_VALIDATOR_DEFER
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CHAINING
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|eresult
operator|=
name|DNS_R_CNAME
expr_stmt|;
else|else
block|{
name|INSIST
argument_list|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_DNAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|EXTERNAL
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 			 * It's OK to cache this rdataset now. 			 */
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
name|addedrdataset
operator|=
name|ardataset
expr_stmt|;
elseif|else
if|if
condition|(
name|ANSWERSIG
argument_list|(
name|rdataset
argument_list|)
condition|)
name|addedrdataset
operator|=
name|asigrdataset
expr_stmt|;
else|else
name|addedrdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|CHAINING
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|eresult
operator|=
name|DNS_R_CNAME
expr_stmt|;
else|else
block|{
name|INSIST
argument_list|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_DNAME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|&&
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_ns
operator|)
operator|)
condition|)
block|{
comment|/* 				 * If the trust level is 'dns_trust_glue' 				 * then we are adding data from a referral 				 * we got while executing the search algorithm. 				 * New referral data always takes precedence 				 * over the existing cache contents. 				 */
name|options
operator|=
name|DNS_DBADD_FORCE
expr_stmt|;
block|}
else|else
name|options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
name|dns_name_t
modifier|*
name|noqname
init|=
name|NULL
decl_stmt|;
name|tresult
operator|=
name|findnoqname
argument_list|(
name|fctx
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|noqname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|dns_rdataset_addnoqname
argument_list|(
name|rdataset
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|tresult
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Now we can add the rdataset. 			 */
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|,
name|options
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
block|{
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|ardataset
operator|!=
name|NULL
operator|&&
name|NEGATIVE
argument_list|(
name|ardataset
argument_list|)
condition|)
block|{
comment|/* 					 * The answer in the cache is better 					 * than the answer we found, and is 					 * a negative cache entry, so we 					 * must set eresult appropriately. 					 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|ardataset
argument_list|)
condition|)
name|eresult
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|eresult
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|valrdataset
operator|!=
name|NULL
condition|)
block|{
name|dns_rdatatype_t
name|vtype
init|=
name|fctx
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|CHAINING
argument_list|(
name|valrdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|valrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|vtype
operator|=
name|dns_rdatatype_cname
expr_stmt|;
else|else
name|vtype
operator|=
name|dns_rdatatype_dname
expr_stmt|;
block|}
name|result
operator|=
name|valcreate
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|name
argument_list|,
name|vtype
argument_list|,
name|valrdataset
argument_list|,
name|valsigrdataset
argument_list|,
name|valoptions
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|have_answer
condition|)
block|{
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_HAVEANSWER
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Negative results must be indicated in event->result. 			 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|event
operator|->
name|rdataset
argument_list|)
operator|&&
name|NEGATIVE
argument_list|(
name|event
operator|->
name|rdataset
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|eresult
operator|==
name|DNS_R_NCACHENXDOMAIN
operator|||
name|eresult
operator|==
name|DNS_R_NCACHENXRRSET
argument_list|)
expr_stmt|;
block|}
name|event
operator|->
name|result
operator|=
name|eresult
expr_stmt|;
name|dns_db_attach
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|adbp
argument_list|)
expr_stmt|;
name|dns_db_transfernode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|,
name|anodep
argument_list|)
expr_stmt|;
name|clone_results
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cache_message
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_section_t
name|section
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"cache_message"
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_WANTCACHE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|section
operator|=
name|DNS_SECTION_ANSWER
init|;
name|section
operator|<=
name|DNS_SECTION_ADDITIONAL
condition|;
name|section
operator|++
control|)
block|{
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_CACHE
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|cache_name
argument_list|(
name|fctx
argument_list|,
name|name
argument_list|,
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do what dns_ncache_addoptout() does, and then compute an appropriate eresult.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|ncache_adderesult
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_db_t
modifier|*
name|cache
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_ttl_t
name|maxttl
parameter_list|,
name|isc_boolean_t
name|optout
parameter_list|,
name|isc_boolean_t
name|secure
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|isc_result_t
modifier|*
name|eresultp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
if|if
condition|(
name|ardataset
operator|==
name|NULL
condition|)
block|{
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|ardataset
operator|=
operator|&
name|rdataset
expr_stmt|;
block|}
if|if
condition|(
name|secure
condition|)
name|result
operator|=
name|dns_ncache_addoptout
argument_list|(
name|message
argument_list|,
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|maxttl
argument_list|,
name|optout
argument_list|,
name|ardataset
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|dns_ncache_add
argument_list|(
name|message
argument_list|,
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|maxttl
argument_list|,
name|ardataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * If the cache now contains a negative entry and we 		 * care about whether it is DNS_R_NCACHENXDOMAIN or 		 * DNS_R_NCACHENXRRSET then extract it. 		 */
if|if
condition|(
name|NEGATIVE
argument_list|(
name|ardataset
argument_list|)
condition|)
block|{
comment|/* 			 * The cache data is a negative cache entry. 			 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|ardataset
argument_list|)
condition|)
operator|*
name|eresultp
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
operator|*
name|eresultp
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Either we don't care about the nature of the 			 * cache rdataset (because no fetch is interested 			 * in the outcome), or the cache rdataset is not 			 * a negative cache entry.  Whichever case it is, 			 * we can return success. 			 * 			 * XXXRTH  There's a CNAME/DNAME problem here. 			 */
operator|*
name|eresultp
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|ardataset
operator|==
operator|&
name|rdataset
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|ardataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|ardataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|ncache_message
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_db_t
modifier|*
modifier|*
name|adbp
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|anodep
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|ardataset
decl_stmt|;
name|isc_boolean_t
name|need_validation
decl_stmt|,
name|secure_domain
decl_stmt|;
name|dns_name_t
modifier|*
name|aname
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|unsigned
name|int
name|valoptions
init|=
literal|0
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"ncache_message"
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_WANTNCACHE
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
name|POST
argument_list|(
name|need_validation
argument_list|)
expr_stmt|;
name|secure_domain
operator|=
name|ISC_FALSE
expr_stmt|;
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|name
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * XXXMPA remove when we follow cnames and adjust the setting 	 * of FCTX_ATTR_WANTNCACHE in noanswer_response(). 	 */
name|INSIST
argument_list|(
name|fctx
operator|->
name|rmessage
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Is DNSSEC validation required for this name? 	 */
if|if
condition|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|enablevalidation
condition|)
block|{
name|result
operator|=
name|dns_view_issecuredomain
argument_list|(
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
operator|!
name|secure_domain
operator|&&
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
block|{
name|valoptions
operator|=
name|DNS_VALIDATOR_DLV
expr_stmt|;
name|secure_domain
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
condition|)
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
else|else
name|need_validation
operator|=
name|secure_domain
expr_stmt|;
if|if
condition|(
name|secure_domain
condition|)
block|{
comment|/* 		 * Mark all rdatasets as pending. 		 */
name|dns_rdataset_t
modifier|*
name|trdataset
decl_stmt|;
name|dns_name_t
modifier|*
name|tname
decl_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|tname
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
for|for
control|(
name|trdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|tname
operator|->
name|list
argument_list|)
init|;
name|trdataset
operator|!=
name|NULL
condition|;
name|trdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|trdataset
argument_list|,
name|link
argument_list|)
control|)
name|trdataset
operator|->
name|trust
operator|=
name|dns_trust_pending_answer
expr_stmt|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|need_validation
condition|)
block|{
comment|/* 		 * Do negative response validation. 		 */
name|result
operator|=
name|valcreate
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|valoptions
argument_list|,
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
comment|/* 		 * If validation is necessary, return now.  Otherwise continue 		 * to process the message, letting the validation complete 		 * in its own good time. 		 */
return|return
operator|(
name|result
operator|)
return|;
block|}
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|adbp
operator|=
name|NULL
expr_stmt|;
name|aname
operator|=
name|NULL
expr_stmt|;
name|anodep
operator|=
name|NULL
expr_stmt|;
name|ardataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|adbp
operator|=
operator|&
name|event
operator|->
name|db
expr_stmt|;
name|aname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|aname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
name|anodep
operator|=
operator|&
name|event
operator|->
name|node
expr_stmt|;
name|ardataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
block|}
block|}
else|else
name|event
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * If we are asking for a SOA record set the cache time 	 * to zero to facilitate locating the containing zone of 	 * a arbitrary zone. 	 */
name|ttl
operator|=
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|maxncachettl
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|covers
operator|==
name|dns_rdatatype_any
operator|&&
name|fctx
operator|->
name|res
operator|->
name|zero_no_soa_ttl
condition|)
name|ttl
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ncache_adderesult
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|ttl
argument_list|,
name|ISC_FALSE
argument_list|,
name|ISC_FALSE
argument_list|,
name|ardataset
argument_list|,
operator|&
name|eresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
if|if
condition|(
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_HAVEANSWER
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|event
operator|->
name|result
operator|=
name|eresult
expr_stmt|;
name|dns_db_attach
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|adbp
argument_list|)
expr_stmt|;
name|dns_db_transfernode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|,
name|anodep
argument_list|)
expr_stmt|;
name|clone_results
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mark_related
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_boolean_t
name|external
parameter_list|,
name|isc_boolean_t
name|gluing
parameter_list|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
if|if
condition|(
name|gluing
condition|)
block|{
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_glue
expr_stmt|;
comment|/* 		 * Glue with 0 TTL causes problems.  We force the TTL to 		 * 1 second to prevent this. 		 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|==
literal|0
condition|)
name|rdataset
operator|->
name|ttl
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
comment|/* 	 * Avoid infinite loops by only marking new rdatasets. 	 */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CHASE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHASE
expr_stmt|;
block|}
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
if|if
condition|(
name|external
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_EXTERNAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_section
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|addname
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|arg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_boolean_t
name|external
decl_stmt|;
name|dns_rdatatype_t
name|rtype
decl_stmt|;
name|isc_boolean_t
name|gluing
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|CHECK_FOR_GLUE_IN_ANSWER
if|if
condition|(
name|section
operator|==
name|DNS_SECTION_ANSWER
operator|&&
name|type
operator|!=
name|dns_rdatatype_a
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|GLUING
argument_list|(
name|fctx
argument_list|)
condition|)
name|gluing
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|gluing
operator|=
name|ISC_FALSE
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|,
name|addname
argument_list|,
name|dns_rdatatype_any
argument_list|,
literal|0
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|external
operator|=
name|ISC_TF
argument_list|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_a
condition|)
block|{
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|rtype
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
else|else
name|rtype
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|dns_rdatatype_a
operator|||
name|rtype
operator|==
name|dns_rdatatype_aaaa
condition|)
name|mark_related
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|external
argument_list|,
name|gluing
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|mark_related
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|external
argument_list|,
name|gluing
argument_list|)
expr_stmt|;
comment|/* 				 * Do we have its SIG too? 				 */
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|mark_related
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|external
argument_list|,
name|gluing
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_related
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|addname
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
return|return
operator|(
name|check_section
argument_list|(
name|arg
argument_list|,
name|addname
argument_list|,
name|type
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CHECK_FOR_GLUE_IN_ANSWER
end_ifndef

begin_define
define|#
directive|define
name|CHECK_FOR_GLUE_IN_ANSWER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CHECK_FOR_GLUE_IN_ANSWER
end_if

begin_function
specifier|static
name|isc_result_t
name|check_answer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|addname
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
return|return
operator|(
name|check_section
argument_list|(
name|arg
argument_list|,
name|addname
argument_list|,
name|type
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|chase_additional
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_boolean_t
name|rescan
decl_stmt|;
name|dns_section_t
name|section
init|=
name|DNS_SECTION_ADDITIONAL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|again
label|:
name|rescan
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
control|)
block|{
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_CHASE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_CHASE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|CHASE
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator|&=
operator|~
name|DNS_RDATASETATTR_CHASE
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
name|rescan
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rescan
condition|)
goto|goto
name|again
goto|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cname_target
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|tname
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_cname_t
name|cname
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_name_init
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|cname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|dname_target
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|oname
parameter_list|,
name|dns_fixedname_t
modifier|*
name|fixeddname
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|;
name|int
name|order
decl_stmt|;
name|dns_namereln_t
name|namereln
decl_stmt|;
name|dns_rdata_dname_t
name|dname
decl_stmt|;
name|dns_fixedname_t
name|prefix
decl_stmt|;
comment|/* 	 * Get the target name of the DNAME. 	 */
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|dname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Get the prefix of qname. 	 */
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|qname
argument_list|,
name|oname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
if|if
condition|(
name|namereln
operator|!=
name|dns_namereln_subdomain
condition|)
block|{
name|char
name|qbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|obuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|qname
argument_list|,
name|qbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|oname
argument_list|,
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|)
expr_stmt|;
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"unrelated DNAME in answer: "
literal|"%s is not in %s"
argument_list|,
name|qbuf
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|prefix
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|qname
argument_list|,
name|nlabels
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|prefix
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
name|fixeddname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|prefix
argument_list|)
argument_list|,
operator|&
name|dname
operator|.
name|dname
argument_list|,
name|dns_fixedname_name
argument_list|(
name|fixeddname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|is_answeraddress_allowed
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|struct
name|in6_addr
name|in6a
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|typebuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|match
decl_stmt|;
comment|/* By default, we allow any addresses. */
if|if
condition|(
name|view
operator|->
name|denyansweracl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * If the owner name matches one in the exclusion list, either exactly 	 * or partially, allow it. 	 */
if|if
condition|(
name|view
operator|->
name|answeracl_exclude
operator|!=
name|NULL
condition|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|view
operator|->
name|answeracl_exclude
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* 	 * Otherwise, search the filter list for a match for each address 	 * record.  If a match is found, the address should be filtered, 	 * so should the entire answer. 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_a
condition|)
block|{
name|INSIST
argument_list|(
name|rdata
operator|.
name|length
operator|==
sizeof|sizeof
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|ina
operator|.
name|s_addr
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|ina
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|rdata
operator|.
name|length
operator|==
sizeof|sizeof
argument_list|(
name|in6a
operator|.
name|s6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|in6a
operator|.
name|s6_addr
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|in6a
operator|.
name|s6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin6
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|in6a
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|NULL
argument_list|,
name|view
operator|->
name|denyansweracl
argument_list|,
operator|&
name|view
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
block|{
name|isc_netaddr_format
argument_list|(
operator|&
name|netaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"answer address %s denied for %s/%s/%s"
argument_list|,
name|addrbuf
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|is_answertarget_allowed
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|tname
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|char
name|qnamebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|tnamebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|typebuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* By default, we allow any target name. */
if|if
condition|(
name|view
operator|->
name|denyanswernames
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * If the owner name matches one in the exclusion list, either exactly 	 * or partially, allow it. 	 */
if|if
condition|(
name|view
operator|->
name|answernames_exclude
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|view
operator|->
name|answernames_exclude
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* 	 * If the target name is a subdomain of the search domain, allow it. 	 */
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|tname
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Otherwise, apply filters. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|view
operator|->
name|denyanswernames
argument_list|,
name|tname
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|qnamebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|qnamebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|tname
argument_list|,
name|tnamebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tnamebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|view
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"%s target %s denied for %s/%s"
argument_list|,
name|typebuf
argument_list|,
name|tnamebuf
argument_list|,
name|qnamebuf
argument_list|,
name|classbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trim_ns_ttl
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|char
name|ns_namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|tbuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|fctx
operator|->
name|ns_ttl_ok
operator|&&
name|rdataset
operator|->
name|ttl
operator|>
name|fctx
operator|->
name|ns_ttl
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|ns_namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ns_namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|fctx
operator|->
name|type
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"fctx %p: trimming ttl of %s/NS for %s/%s: "
literal|"%u -> %u"
argument_list|,
name|fctx
argument_list|,
name|ns_namebuf
argument_list|,
name|namebuf
argument_list|,
name|tbuf
argument_list|,
name|rdataset
operator|->
name|ttl
argument_list|,
name|fctx
operator|->
name|ns_ttl
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|ttl
operator|=
name|fctx
operator|->
name|ns_ttl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle a no-answer response (NXDOMAIN, NXRRSET, or referral).  * If look_in_options has LOOK_FOR_NS_IN_ANSWER then we look in the answer  * section for the NS RRset if the query type is NS; if it has  * LOOK_FOR_GLUE_IN_ANSWER we look for glue incorrectly returned in the answer  * section for A and AAAA queries.  */
end_comment

begin_define
define|#
directive|define
name|LOOK_FOR_NS_IN_ANSWER
value|0x1
end_define

begin_define
define|#
directive|define
name|LOOK_FOR_GLUE_IN_ANSWER
value|0x2
end_define

begin_function
specifier|static
name|isc_result_t
name|noanswer_response
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|oqname
parameter_list|,
name|unsigned
name|int
name|look_in_options
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|,
modifier|*
name|ns_name
decl_stmt|,
modifier|*
name|soa_name
decl_stmt|,
modifier|*
name|ds_name
decl_stmt|,
modifier|*
name|save_name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|ns_rdataset
decl_stmt|;
name|isc_boolean_t
name|aa
decl_stmt|,
name|negative_response
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|,
name|save_type
decl_stmt|;
name|dns_section_t
name|section
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"noanswer_response"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|look_in_options
operator|&
name|LOOK_FOR_NS_IN_ANSWER
operator|)
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
name|section
operator|=
name|DNS_SECTION_ANSWER
expr_stmt|;
block|}
else|else
name|section
operator|=
name|DNS_SECTION_AUTHORITY
expr_stmt|;
name|message
operator|=
name|fctx
operator|->
name|rmessage
expr_stmt|;
comment|/* 	 * Setup qname. 	 */
if|if
condition|(
name|oqname
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We have a normal, non-chained negative response or 		 * referral. 		 */
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
condition|)
name|aa
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|aa
operator|=
name|ISC_FALSE
expr_stmt|;
name|qname
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're being invoked by answer_response() after it has 		 * followed a CNAME/DNAME chain. 		 */
name|qname
operator|=
name|oqname
expr_stmt|;
name|aa
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * If the current qname is not a subdomain of the query 		 * domain, there's no point in looking at the authority 		 * section without doing DNSSEC validation. 		 * 		 * Until we do that validation, we'll just return success 		 * in this case. 		 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|qname
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * We have to figure out if this is a negative response, or a 	 * referral. 	 */
comment|/* 	 * Sometimes we can tell if its a negative response by looking at 	 * the message header. 	 */
name|negative_response
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|||
operator|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
operator|&&
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|==
literal|0
operator|)
condition|)
name|negative_response
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Process the authority section. 	 */
name|ns_name
operator|=
name|NULL
expr_stmt|;
name|ns_rdataset
operator|=
name|NULL
expr_stmt|;
name|soa_name
operator|=
name|NULL
expr_stmt|;
name|ds_name
operator|=
name|NULL
expr_stmt|;
name|save_name
operator|=
name|NULL
expr_stmt|;
name|save_type
operator|=
name|dns_rdatatype_none
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
comment|/* 			 * Look for NS/SOA RRsets first. 			 */
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|type
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|type
operator|==
name|dns_rdatatype_soa
operator|)
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|qname
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
name|char
name|qbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|tbuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|qname
argument_list|,
name|qbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"unrelated %s %s in "
literal|"%s authority section"
argument_list|,
name|tbuf
argument_list|,
name|nbuf
argument_list|,
name|qbuf
argument_list|)
expr_stmt|;
goto|goto
name|nextname
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 					 * NS or RRSIG NS. 					 * 					 * Only one set of NS RRs is allowed. 					 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
if|if
condition|(
name|ns_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|ns_name
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"multiple NS "
literal|"RRsets in "
literal|"authority "
literal|"section"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|ns_name
operator|=
name|name
expr_stmt|;
name|ns_rdataset
operator|=
name|rdataset
expr_stmt|;
block|}
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_glue
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
comment|/* 					 * SOA, or RRSIG SOA. 					 * 					 * Only one SOA is allowed. 					 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
if|if
condition|(
name|soa_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|soa_name
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"multiple SOA "
literal|"RRs in "
literal|"authority "
literal|"section"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|soa_name
operator|=
name|name
expr_stmt|;
block|}
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_NCACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NCACHE
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFORWARDER
argument_list|(
name|fctx
operator|->
name|addrinfo
argument_list|)
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
block|}
block|}
block|}
name|nextname
label|:
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
break|break;
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|log_ns_ttl
argument_list|(
name|fctx
argument_list|,
literal|"noanswer_response"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_rdataset
operator|!=
name|NULL
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|ns_name
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|ns_name
argument_list|,
name|dns_rootname
argument_list|)
condition|)
name|trim_ns_ttl
argument_list|(
name|fctx
argument_list|,
name|ns_name
argument_list|,
name|ns_rdataset
argument_list|)
expr_stmt|;
comment|/* 	 * A negative response has a SOA record (Type 2) 	 * and a optional NS RRset (Type 1) or it has neither 	 * a SOA or a NS RRset (Type 3, handled above) or 	 * rcode is NXDOMAIN (handled above) in which case 	 * the NS RRset is allowed (Type 4). 	 */
if|if
condition|(
name|soa_name
operator|!=
name|NULL
condition|)
name|negative_response
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|type
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
block|{
comment|/* 					 * NSEC or RRSIG NSEC. 					 */
if|if
condition|(
name|negative_response
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_NCACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NCACHE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
block|}
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFORWARDER
argument_list|(
name|fctx
operator|->
name|addrinfo
argument_list|)
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
comment|/* 					 * No additional data needs to be 					 * marked. 					 */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ds
condition|)
block|{
comment|/* 					 * DS or SIG DS. 					 * 					 * These should only be here if 					 * this is a referral, and there 					 * should only be one DS RRset. 					 */
if|if
condition|(
name|ns_name
operator|==
name|NULL
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"DS with no "
literal|"referral"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ds
condition|)
block|{
if|if
condition|(
name|ds_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|ds_name
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"DS doesn't "
literal|"match "
literal|"referral "
literal|"(NS)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|ds_name
operator|=
name|name
expr_stmt|;
block|}
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFORWARDER
argument_list|(
name|fctx
operator|->
name|addrinfo
argument_list|)
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|save_name
operator|=
name|name
expr_stmt|;
name|save_type
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
operator|->
name|type
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
break|break;
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Trigger lookups for DNS nameservers. 	 */
if|if
condition|(
name|negative_response
operator|&&
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|&&
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|&&
name|soa_name
operator|!=
name|NULL
operator|&&
name|dns_name_equal
argument_list|(
name|soa_name
argument_list|,
name|qname
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|qname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_CHASEDSSERVERS
operator|)
return|;
comment|/* 	 * Did we find anything? 	 */
if|if
condition|(
operator|!
name|negative_response
operator|&&
name|ns_name
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Nope. 		 */
if|if
condition|(
name|oqname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We've already got a partial CNAME/DNAME chain, 			 * and haven't found else anything useful here, but 			 * no error has occurred since we have an answer. 			 */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * The responder is insane. 			 */
if|if
condition|(
name|save_name
operator|==
name|NULL
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"invalid response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|save_name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
name|char
name|nbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|dbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|tbuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdatatype_format
argument_list|(
name|save_type
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|save_name
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|dbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"Name %s (%s) not subdomain"
literal|" of zone %s -- invalid response"
argument_list|,
name|nbuf
argument_list|,
name|tbuf
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"invalid response"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
block|}
comment|/* 	 * If we found both NS and SOA, they should be the same name. 	 */
if|if
condition|(
name|ns_name
operator|!=
name|NULL
operator|&&
name|soa_name
operator|!=
name|NULL
operator|&&
name|ns_name
operator|!=
name|soa_name
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"NS/SOA mismatch"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 	 * Do we have a referral?  (We only want to follow a referral if 	 * we're not following a chain.) 	 */
if|if
condition|(
operator|!
name|negative_response
operator|&&
name|ns_name
operator|!=
name|NULL
operator|&&
name|oqname
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We already know ns_name is a subdomain of fctx->domain. 		 * If ns_name is equal to fctx->domain, we're not making 		 * progress.  We return DNS_R_FORMERR so that we'll keep 		 * trying other servers. 		 */
if|if
condition|(
name|dns_name_equal
argument_list|(
name|ns_name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"non-improving referral"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 		 * If the referral name is not a parent of the query 		 * name, consider the responder insane. 		 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|ns_name
argument_list|)
condition|)
block|{
comment|/* Logged twice */
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"referral to non-parent"
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"referral to non-parent"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 		 * Mark any additional data related to this rdataset. 		 * It's important that we do this before we change the 		 * query domain. 		 */
name|INSIST
argument_list|(
name|ns_rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_GLUING
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|ns_rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
if|#
directive|if
name|CHECK_FOR_GLUE_IN_ANSWER
comment|/* 		 * Look in the answer section for "glue" that is incorrectly 		 * returned as a answer.  This is needed if the server also 		 * minimizes the response size by not adding records to the 		 * additional section that are in the answer section or if 		 * the record gets dropped due to message size constraints. 		 */
if|if
condition|(
operator|(
name|look_in_options
operator|&
name|LOOK_FOR_GLUE_IN_ANSWER
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_a
operator|)
condition|)
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|ns_rdataset
argument_list|,
name|check_answer
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_GLUING
expr_stmt|;
comment|/* 		 * NS rdatasets with 0 TTL cause problems. 		 * dns_view_findzonecut() will not find them when we 		 * try to follow the referral, and we'll SERVFAIL 		 * because the best nameservers are now above QDOMAIN. 		 * We force the TTL to 1 second to prevent this. 		 */
if|if
condition|(
name|ns_rdataset
operator|->
name|ttl
operator|==
literal|0
condition|)
name|ns_rdataset
operator|->
name|ttl
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Set the current query domain to the referral name. 		 * 		 * XXXRTH  We should check if we're in forward-only mode, and 		 *		if so we should bail out. 		 */
name|INSIST
argument_list|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|fcount_decr
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|ns_name
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|result
operator|=
name|fcount_incr
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_WANTCACHE
expr_stmt|;
name|fctx
operator|->
name|ns_ttl_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|log_ns_ttl
argument_list|(
name|fctx
argument_list|,
literal|"DELEGATION"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_DELEGATION
operator|)
return|;
block|}
comment|/* 	 * Since we're not doing a referral, we don't want to cache any 	 * NS RRs we may have found. 	 */
if|if
condition|(
name|ns_name
operator|!=
name|NULL
condition|)
name|ns_name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_CACHE
expr_stmt|;
if|if
condition|(
name|negative_response
operator|&&
name|oqname
operator|==
name|NULL
condition|)
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_WANTNCACHE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|answer_response
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|,
name|tname
decl_stmt|,
modifier|*
name|ns_name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|ns_rdataset
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|,
name|external
decl_stmt|,
name|chaining
decl_stmt|,
name|aa
decl_stmt|,
name|found
decl_stmt|,
name|want_chaining
decl_stmt|;
name|isc_boolean_t
name|have_answer
decl_stmt|,
name|found_cname
decl_stmt|,
name|found_type
decl_stmt|,
name|wanted_chaining
decl_stmt|;
name|unsigned
name|int
name|aflag
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_fixedname_t
name|dname
decl_stmt|,
name|fqname
decl_stmt|;
name|dns_view_t
modifier|*
name|view
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"answer_response"
argument_list|)
expr_stmt|;
name|message
operator|=
name|fctx
operator|->
name|rmessage
expr_stmt|;
comment|/* 	 * Examine the answer section, marking those rdatasets which are 	 * part of the answer and should be cached. 	 */
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|found_cname
operator|=
name|ISC_FALSE
expr_stmt|;
name|found_type
operator|=
name|ISC_FALSE
expr_stmt|;
name|chaining
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_answer
operator|=
name|ISC_FALSE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
name|POST
argument_list|(
name|want_chaining
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
condition|)
name|aa
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|aa
operator|=
name|ISC_FALSE
expr_stmt|;
name|qname
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
name|type
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
name|view
operator|=
name|fctx
operator|->
name|res
operator|->
name|view
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|external
operator|=
name|ISC_TF
argument_list|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|qname
argument_list|)
condition|)
block|{
name|wanted_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
name|aflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
block|{
comment|/* 					 * NSEC3 records are not allowed to 					 * appear in the answer section. 					 */
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"NSEC3 in answer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 				 * Apply filters, if given, on answers to reject 				 * a malicious attempt of rebinding. 				 */
if|if
condition|(
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_a
operator|||
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
operator|)
operator|&&
operator|!
name|is_answeraddress_allowed
argument_list|(
name|view
argument_list|,
name|name
argument_list|,
name|rdataset
argument_list|)
condition|)
block|{
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|type
operator|&&
operator|!
name|found_cname
condition|)
block|{
comment|/* 					 * We've found an ordinary answer. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_type
operator|=
name|ISC_TRUE
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
block|{
comment|/* 					 * We've found an answer matching 					 * an ANY query.  There may be 					 * more. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|type
operator|&&
operator|!
name|found_cname
condition|)
block|{
comment|/* 					 * We've found a signature that 					 * covers the type we're looking for. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_type
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWERSIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
operator|!
name|found_type
condition|)
block|{
comment|/* 					 * We're looking for something else, 					 * but we found a CNAME. 					 * 					 * Getting a CNAME response for some 					 * query types is an error, see 					 * RFC 4035, Section 2.5. 					 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
name|char
name|buf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdatatype_format
argument_list|(
name|fctx
operator|->
name|type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"CNAME response "
literal|"for %s RR"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_cname
operator|=
name|ISC_TRUE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
name|result
operator|=
name|cname_target
argument_list|(
name|rdataset
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* Apply filters on the target name. */
if|if
condition|(
operator|!
name|is_answertarget_allowed
argument_list|(
name|view
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|tname
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_cname
operator|&&
operator|!
name|found_type
condition|)
block|{
comment|/* 					 * We're looking for something else, 					 * but we found a SIG CNAME. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_cname
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWERSIG
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* 					 * We've found an answer to our 					 * question. 					 */
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
if|if
condition|(
operator|!
name|chaining
condition|)
block|{
comment|/* 						 * This data is "the" answer 						 * to our question only if 						 * we're not chaining (i.e. 						 * if we haven't followed 						 * a CNAME or DNAME). 						 */
name|INSIST
argument_list|(
operator|!
name|external
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
name|DNS_RDATASETATTR_ANSWER
condition|)
name|have_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ANSWER
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|aflag
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authanswer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|external
condition|)
block|{
comment|/* 						 * This data is outside of 						 * our query domain, and 						 * may not be cached. 						 */
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_EXTERNAL
expr_stmt|;
block|}
comment|/* 					 * Mark any additional data related 					 * to this rdataset. 					 */
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
comment|/* 					 * CNAME chaining. 					 */
if|if
condition|(
name|want_chaining
condition|)
block|{
name|wanted_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CHAINING
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHAINING
expr_stmt|;
name|qname
operator|=
operator|&
name|tname
expr_stmt|;
block|}
block|}
comment|/* 				 * We could add an "else" clause here and 				 * log that we're ignoring this rdataset. 				 */
block|}
comment|/* 			 * If wanted_chaining is true, we've done 			 * some chaining as the result of processing 			 * this node, and thus we need to set 			 * chaining to true. 			 * 			 * We don't set chaining inside of the 			 * rdataset loop because doing that would 			 * cause us to ignore the signatures of 			 * CNAMEs. 			 */
if|if
condition|(
name|wanted_chaining
condition|)
name|chaining
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Look for a DNAME (or its SIG).  Anything else is 			 * ignored. 			 */
name|wanted_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_boolean_t
name|found_dname
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_name_t
modifier|*
name|dname_name
decl_stmt|;
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
name|aflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
condition|)
block|{
comment|/* 					 * We're looking for something else, 					 * but we found a DNAME. 					 * 					 * If we're not chaining, then the 					 * DNAME should not be external. 					 */
if|if
condition|(
operator|!
name|chaining
operator|&&
name|external
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"external DNAME"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|POST
argument_list|(
name|want_chaining
argument_list|)
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
name|result
operator|=
name|dname_target
argument_list|(
name|fctx
argument_list|,
name|rdataset
argument_list|,
name|qname
argument_list|,
name|name
argument_list|,
operator|&
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
comment|/* 						 * We can't construct the 						 * DNAME target.  Do not 						 * try to continue. 						 */
name|want_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
name|POST
argument_list|(
name|want_chaining
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|else
name|found_dname
operator|=
name|ISC_TRUE
expr_stmt|;
name|dname_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_answertarget_allowed
argument_list|(
name|view
argument_list|,
name|qname
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|dname_name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_dname
condition|)
block|{
comment|/* 					 * We've found a signature that 					 * covers the DNAME. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWERSIG
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* 					 * We've found an answer to our 					 * question. 					 */
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
if|if
condition|(
operator|!
name|chaining
condition|)
block|{
comment|/* 						 * This data is "the" answer 						 * to our question only if 						 * we're not chaining. 						 */
name|INSIST
argument_list|(
operator|!
name|external
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
name|DNS_RDATASETATTR_ANSWER
condition|)
name|have_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ANSWER
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|aflag
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authanswer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|external
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_EXTERNAL
expr_stmt|;
block|}
comment|/* 					 * DNAME chaining. 					 */
if|if
condition|(
name|found_dname
condition|)
block|{
comment|/* 						 * Copy the dname into the 						 * qname fixed name. 						 * 						 * Although we check for 						 * failure of the copy 						 * operation, in practice it 						 * should never fail since 						 * we already know that the 						 * result fits in a fixedname. 						 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fqname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|dname
argument_list|)
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fqname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|wanted_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CHAINING
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHAINING
expr_stmt|;
name|qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fqname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|wanted_chaining
condition|)
name|chaining
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * We should have found an answer. 	 */
if|if
condition|(
operator|!
name|have_answer
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"reply has no answer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 	 * This response is now potentially cacheable. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_WANTCACHE
expr_stmt|;
comment|/* 	 * Did chaining end before we got the final answer? 	 */
if|if
condition|(
name|chaining
condition|)
block|{
comment|/* 		 * Yes.  This may be a negative reply, so hand off 		 * authority section processing to the noanswer code. 		 * If it isn't a noanswer response, no harm will be 		 * done. 		 */
return|return
operator|(
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|qname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * We didn't end with an incomplete chain, so the rcode should be 	 * "no error". 	 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
condition|)
block|{
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"CNAME/DNAME chain complete, but RCODE "
literal|"indicates error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 	 * Examine the authority section (if there is one). 	 * 	 * We expect there to be only one owner name for all the rdatasets 	 * in this section, and we expect that it is not external. 	 */
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|ns_name
operator|=
name|NULL
expr_stmt|;
name|ns_rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|external
operator|=
name|ISC_TF
argument_list|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
block|{
comment|/* 			 * We expect to find NS or SIG NS rdatasets, and 			 * nothing else. 			 */
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_ns
operator|)
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
if|if
condition|(
name|aa
operator|&&
operator|!
name|chaining
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
name|ns_name
operator|=
name|name
expr_stmt|;
name|ns_rdataset
operator|=
name|rdataset
expr_stmt|;
block|}
comment|/* 					 * Mark any additional data related 					 * to this rdataset. 					 */
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|log_ns_ttl
argument_list|(
name|fctx
argument_list|,
literal|"answer_response"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_rdataset
operator|!=
name|NULL
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|ns_name
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|ns_name
argument_list|,
name|dns_rootname
argument_list|)
condition|)
name|trim_ns_ttl
argument_list|(
name|fctx
argument_list|,
name|ns_name
argument_list|,
name|ns_rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_increference
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|fctx_decreference
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No one cares about the result of this fetch anymore. 		 */
if|if
condition|(
name|fctx
operator|->
name|pending
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|nqueries
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
operator|&&
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 			 * This fctx is already shutdown; we were just 			 * waiting for the last reference to go away. 			 */
name|bucket_empty
operator|=
name|fctx_unlink
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Initiate shutdown. 			 */
name|fctx_shutdown
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|bucket_empty
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_dslookup
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|fevent
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
decl_stmt|;
name|isc_boolean_t
name|locked
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|dns_rdataset_t
name|nameservers
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|domain
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|fevent
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|fctx
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"resume_dslookup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fevent
operator|->
name|db
argument_list|,
operator|&
name|fevent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|fevent
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|nameservers
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|result
operator|==
name|ISC_R_CANCELED
condition|)
block|{
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|ISC_R_CANCELED
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"resuming DS lookup"
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|ns_ttl
operator|=
name|fctx
operator|->
name|nameservers
operator|.
name|ttl
expr_stmt|;
name|fctx
operator|->
name|ns_ttl_ok
operator|=
name|ISC_TRUE
expr_stmt|;
name|log_ns_ttl
argument_list|(
name|fctx
argument_list|,
literal|"resume_dslookup"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|fcount_decr
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|result
operator|=
name|fcount_incr
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
comment|/* 		 * Try again. 		 */
name|fctx_try
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|nsrdataset
init|=
name|NULL
decl_stmt|;
comment|/* 		 * Retrieve state from fctx->nsfetch before we destroy it. 		 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|domain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
operator|->
name|private
operator|->
name|domain
argument_list|,
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|domain
argument_list|)
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
operator|->
name|private
operator|->
name|nameservers
argument_list|)
condition|)
block|{
name|dns_rdataset_clone
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
operator|->
name|private
operator|->
name|nameservers
argument_list|,
operator|&
name|nameservers
argument_list|)
expr_stmt|;
name|nsrdataset
operator|=
operator|&
name|nameservers
expr_stmt|;
block|}
else|else
name|domain
operator|=
name|NULL
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"continuing to look for parent's NS records"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|domain
argument_list|,
name|nsrdataset
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|task
argument_list|,
name|resume_dslookup
argument_list|,
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|nsrrset
argument_list|,
name|NULL
argument_list|,
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|ISC_TRUE
expr_stmt|;
name|fctx
operator|->
name|references
operator|++
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nameservers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fevent
operator|->
name|sigrdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|bucket_empty
operator|=
name|fctx_decreference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|checknamessection
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
control|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdata_checkowner
argument_list|(
name|name
argument_list|,
name|rdata
operator|.
name|rdclass
argument_list|,
name|rdata
operator|.
name|type
argument_list|,
name|ISC_FALSE
argument_list|)
operator|||
operator|!
name|dns_rdata_checknames
argument_list|(
operator|&
name|rdata
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHECKNAMES
expr_stmt|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|checknames
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|)
block|{
name|checknamessection
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|checknamessection
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|checknamessection
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log server NSID at log level 'level'  */
end_comment

begin_function
specifier|static
name|void
name|log_nsid
parameter_list|(
name|isc_buffer_t
modifier|*
name|opt
parameter_list|,
name|size_t
name|nsid_len
parameter_list|,
name|resquery_t
modifier|*
name|query
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[
literal|17
index|]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_uint16_t
name|buflen
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|nsid
decl_stmt|;
comment|/* Allocate buffer for storing hex version of the NSID */
name|buflen
operator|=
operator|(
name|isc_uint16_t
operator|)
name|nsid_len
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
comment|/* Convert to hex */
name|p
operator|=
name|buf
expr_stmt|;
name|nsid
operator|=
name|isc_buffer_current
argument_list|(
name|opt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsid_len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|hex
index|[
operator|(
name|nsid
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hex
index|[
name|nsid
index|[
literal|0
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
name|nsid
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|level
argument_list|,
literal|"received NSID '%s' from %s"
argument_list|,
name|buf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
comment|/* Clean up */
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|log_packet
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_buffer_t
name|buffer
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|len
init|=
literal|1024
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
comment|/* 	 * Note that these are multiline debug messages.  We want a newline 	 * to appear in the log after each message. 	 */
do|do
block|{
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
break|break;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_totext
argument_list|(
name|message
argument_list|,
operator|&
name|dns_master_style_debug
argument_list|,
literal|0
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|level
argument_list|,
literal|"received packet:\n%.*s"
argument_list|,
operator|(
name|int
operator|)
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
do|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|iscname
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|dns_rdatatype_cname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|betterreferral
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|fctx
operator|->
name|rmessage
decl_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
control|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isstrictsubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_opt
parameter_list|(
name|resquery_t
modifier|*
name|query
parameter_list|,
name|dns_rdataset_t
modifier|*
name|opt
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
decl_stmt|;
name|isc_buffer_t
name|optbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint16_t
name|optcode
decl_stmt|;
name|isc_uint16_t
name|optlen
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|opt
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|optbuf
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|optbuf
argument_list|,
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|isc_buffer_remaininglength
argument_list|(
operator|&
name|optbuf
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|optcode
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|optbuf
argument_list|)
expr_stmt|;
name|optlen
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|optbuf
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|optlen
operator|<=
name|isc_buffer_remaininglength
argument_list|(
operator|&
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optcode
condition|)
block|{
case|case
name|DNS_OPT_NSID
case|:
if|if
condition|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_WANTNSID
condition|)
name|log_nsid
argument_list|(
operator|&
name|optbuf
argument_list|,
name|optlen
argument_list|,
name|query
argument_list|,
name|ISC_LOG_INFO
argument_list|,
name|query
operator|->
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_buffer_forward
argument_list|(
operator|&
name|optbuf
argument_list|,
name|optlen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|isc_buffer_forward
argument_list|(
operator|&
name|optbuf
argument_list|,
name|optlen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|INSIST
argument_list|(
name|isc_buffer_remaininglength
argument_list|(
operator|&
name|optbuf
argument_list|)
operator|==
literal|0U
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_response
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|devent
init|=
operator|(
name|dns_dispatchevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|isc_boolean_t
name|keep_trying
decl_stmt|,
name|get_nameservers
decl_stmt|,
name|resend
decl_stmt|;
name|isc_boolean_t
name|truncated
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|opt
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_fixedname_t
name|foundname
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_time_t
name|tnow
decl_stmt|,
modifier|*
name|finish
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|findoptions
decl_stmt|;
name|isc_result_t
name|broken_server
decl_stmt|;
name|badnstype_t
name|broken_type
init|=
name|badns_response
decl_stmt|;
name|isc_boolean_t
name|no_response
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_QUERY
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|options
operator|=
name|query
operator|->
name|options
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_DISPATCH
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"response"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
operator|==
name|PF_INET
condition|)
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_responsev4
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_responsev6
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_timer_touch
argument_list|(
name|fctx
operator|->
name|timer
argument_list|)
expr_stmt|;
name|keep_trying
operator|=
name|ISC_FALSE
expr_stmt|;
name|broken_server
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|get_nameservers
operator|=
name|ISC_FALSE
expr_stmt|;
name|resend
operator|=
name|ISC_FALSE
expr_stmt|;
name|truncated
operator|=
name|ISC_FALSE
expr_stmt|;
name|finish
operator|=
name|NULL
expr_stmt|;
name|no_response
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|exiting
condition|)
block|{
name|result
operator|=
name|ISC_R_SHUTTINGDOWN
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"resolver shutting down"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fctx
operator|->
name|timeouts
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|timeout
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|addrinfo
operator|=
name|query
operator|->
name|addrinfo
expr_stmt|;
comment|/* 	 * XXXRTH  We should really get the current time just once.  We 	 *		need a routine to convert from an isc_time_t to an 	 *		isc_stdtime_t. 	 */
name|TIME_NOW
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|finish
operator|=
operator|&
name|tnow
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Did the dispatcher have a problem? 	 */
if|if
condition|(
name|devent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|devent
operator|->
name|result
operator|==
name|ISC_R_EOF
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The problem might be that they 			 * don't understand EDNS0.  Turn it 			 * off and try again. 			 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
name|add_bad_edns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There's no hope for this query. 			 */
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * If this is a network error on an exclusive query 			 * socket, mark the server as bad so that we won't try 			 * it for this fetch again.  Also adjust finish and 			 * no_response so that we penalize this address in SRTT 			 * adjustment later. 			 */
if|if
condition|(
name|query
operator|->
name|exclusivesocket
operator|&&
operator|(
name|devent
operator|->
name|result
operator|==
name|ISC_R_HOSTUNREACH
operator|||
name|devent
operator|->
name|result
operator|==
name|ISC_R_NETUNREACH
operator|||
name|devent
operator|->
name|result
operator|==
name|ISC_R_CONNREFUSED
operator|||
name|devent
operator|->
name|result
operator|==
name|ISC_R_CANCELED
operator|)
condition|)
block|{
name|broken_server
operator|=
name|devent
operator|->
name|result
expr_stmt|;
name|broken_type
operator|=
name|badns_unreachable
expr_stmt|;
name|finish
operator|=
name|NULL
expr_stmt|;
name|no_response
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|FCTXTRACE3
argument_list|(
literal|"dispatcher failure"
argument_list|,
name|devent
operator|->
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|message
operator|=
name|fctx
operator|->
name|rmessage
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tsig
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_message_setquerytsig
argument_list|(
name|message
argument_list|,
name|query
operator|->
name|tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE3
argument_list|(
literal|"unable to set query tsig"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|query
operator|->
name|tsigkey
condition|)
block|{
name|result
operator|=
name|dns_message_settsigkey
argument_list|(
name|message
argument_list|,
name|query
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE3
argument_list|(
literal|"unable to set tsig key"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|dns_message_setclass
argument_list|(
name|message
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|rdclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|==
literal|0
condition|)
name|dns_adb_plainresponse
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_parse
argument_list|(
name|message
argument_list|,
operator|&
name|devent
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE3
argument_list|(
literal|"message failed to parse"
argument_list|,
name|result
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_UNEXPECTEDEND
case|:
if|if
condition|(
operator|!
name|message
operator|->
name|question_ok
operator|||
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|==
literal|0
operator|||
operator|(
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Either the message ended prematurely, 				 * and/or wasn't marked as being truncated, 				 * and/or this is a response to a query we 				 * sent over TCP.  In all of these cases, 				 * something is wrong with the remote 				 * server and we don't want to retry using 				 * TCP. 				 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * The problem might be that they 					 * don't understand EDNS0.  Turn it 					 * off and try again. 					 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
name|add_bad_edns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_edns0fail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|broken_server
operator|=
name|result
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 			 * We defer retrying via TCP for a bit so we can 			 * check out this message further. 			 */
name|truncated
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
name|DNS_R_FORMERR
case|:
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The problem might be that they 				 * don't understand EDNS0.  Turn it 				 * off and try again. 				 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
name|add_bad_edns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_edns0fail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDRCODE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
default|default:
comment|/* 			 * Something bad has happened. 			 */
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Log the incoming packet. 	 */
name|log_packet
argument_list|(
name|message
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|->
name|rdclass
operator|!=
name|fctx
operator|->
name|res
operator|->
name|rdclass
condition|)
block|{
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"bad class"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Process receive opt record. 	 */
name|opt
operator|=
name|dns_message_getopt
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|NULL
condition|)
name|process_opt
argument_list|(
name|query
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * If the message is signed, check the signature.  If not, this 	 * returns success anyway. 	 */
name|result
operator|=
name|dns_message_checksig
argument_list|(
name|message
argument_list|,
name|res
operator|->
name|view
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE3
argument_list|(
literal|"signature check failed"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * The dispatcher should ensure we only get responses with QR set. 	 */
name|INSIST
argument_list|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * INSIST() that the message comes from the place we sent it to, 	 * since the dispatch code should ensure this. 	 * 	 * INSIST() that the message id is correct (this should also be 	 * ensured by the dispatch code). 	 */
comment|/* 	 * We have an affirmative response to the query and we have 	 * previously got a response from this server which indicated 	 * EDNS may not be supported so we can now cache the lack of 	 * EDNS support. 	 */
if|if
condition|(
name|opt
operator|==
name|NULL
operator|&&
operator|!
name|EDNSOK
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|&&
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_refused
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_yxdomain
operator|)
operator|&&
name|bad_edns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
block|{
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we get a non error EDNS response record the fact so we 	 * won't fallback to plain DNS in the future for this server. 	 */
if|if
condition|(
name|opt
operator|!=
name|NULL
operator|&&
operator|!
name|EDNSOK
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
operator|&&
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_refused
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_yxdomain
operator|)
condition|)
block|{
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|FCTX_ADDRINFO_EDNSOK
argument_list|,
name|FCTX_ADDRINFO_EDNSOK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Deal with truncated responses by retrying using TCP. 	 */
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|!=
literal|0
condition|)
name|truncated
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|truncated
condition|)
block|{
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_truncated
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|broken_server
operator|=
name|DNS_R_TRUNCATEDTCP
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|options
operator||=
name|DNS_FETCHOPT_TCP
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|FCTXTRACE3
argument_list|(
literal|"message truncated"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is it a query response? 	 */
if|if
condition|(
name|message
operator|->
name|opcode
operator|!=
name|dns_opcode_query
condition|)
block|{
comment|/* XXXRTH Log */
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDOPCODE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"invalid message opcode"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Update statistics about erroneous responses. 	 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
condition|)
block|{
switch|switch
condition|(
name|message
operator|->
name|rcode
condition|)
block|{
case|case
name|dns_rcode_nxdomain
case|:
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_nxdomain
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_rcode_servfail
case|:
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_servfail
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_rcode_formerr
case|:
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_formerr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_othererror
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Is the remote server broken, or does it dislike us? 	 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
operator|&&
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_nxdomain
condition|)
block|{
name|isc_buffer_t
name|b
decl_stmt|;
name|char
name|code
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_notimp
operator|)
operator|||
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_servfail
operator|&&
name|dns_message_getopt
argument_list|(
name|message
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * It's very likely they don't like EDNS0. 			 * If the response code is SERVFAIL, also check if the 			 * response contains an OPT RR and don't cache the 			 * failure since it can be returned for various other 			 * reasons. 			 * 			 * XXXRTH  We should check if the question 			 *		we're asking requires EDNS0, and 			 *		if so, we should bail out. 			 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * Remember that they may not like EDNS0. 			 */
name|add_bad_edns
argument_list|(
name|fctx
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_edns0fail
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
condition|)
block|{
if|if
condition|(
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
condition|)
block|{
comment|/* 				 * This forwarder doesn't understand us, 				 * but other forwarders might.  Keep trying. 				 */
name|broken_server
operator|=
name|DNS_R_REMOTEFORMERR
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The server doesn't understand us.  Since 				 * all servers for a zone need similar 				 * capabilities, we assume that we will get 				 * FORMERR from all servers, and thus we 				 * cannot make any more progress with this 				 * fetch. 				 */
name|log_formerr
argument_list|(
name|fctx
argument_list|,
literal|"server sent FORMERR"
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_FORMERR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_yxdomain
condition|)
block|{
comment|/* 			 * DNAME mapping failed because the new name 			 * was too long.  There's no chance of success 			 * for this fetch. 			 */
name|result
operator|=
name|DNS_R_YXDOMAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_badvers
condition|)
block|{
comment|/* 			 * This should be impossible as we only send EDNS 			 * version 0 requests and to return BADVERS you 			 * need to support EDNS as it is a extended rcode. 			 */
name|broken_server
operator|=
name|DNS_R_BADVERS
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXXRTH log. 			 */
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDRCODE
expr_stmt|;
name|INSIST
argument_list|(
name|broken_server
operator|!=
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dns_rcode_totext
argument_list|(
name|fctx
operator|->
name|rmessage
operator|->
name|rcode
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|code
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|FCTXTRACE2
argument_list|(
literal|"remote server broken: returned "
argument_list|,
name|code
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is the question the same as the one we asked? 	 */
name|result
operator|=
name|same_question
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* XXXRTH Log */
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
name|FCTXTRACE3
argument_list|(
literal|"response did not match question"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is the server lame? 	 */
if|if
condition|(
name|res
operator|->
name|lame_ttl
operator|!=
literal|0
operator|&&
operator|!
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|&&
name|is_lame
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_lame
argument_list|)
expr_stmt|;
name|log_lame
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_adb_marklame
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
name|now
operator|+
name|res
operator|->
name|lame_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"could not mark server as lame: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|broken_server
operator|=
name|DNS_R_LAME
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"lame server"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Enforce delegations only zones like NET and COM. 	 */
if|if
condition|(
operator|!
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|&&
name|dns_view_isdelegationonly
argument_list|(
name|res
operator|->
name|view
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|)
operator|&&
name|fix_mustbedelegationornxdomain
argument_list|(
name|message
argument_list|,
name|fctx
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|typebuf
index|[
literal|64
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|fctx
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|res
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DELEGATION_ONLY
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"enforced delegation-only for '%s' (%s/%s/%s) "
literal|"from %s"
argument_list|,
name|domainbuf
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|res
operator|->
name|options
operator|&
name|DNS_RESOLVER_CHECKNAMES
operator|)
operator|!=
literal|0
condition|)
name|checknames
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* 	 * Clear cache bits. 	 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
operator|(
name|FCTX_ATTR_WANTNCACHE
operator||
name|FCTX_ATTR_WANTCACHE
operator|)
expr_stmt|;
comment|/* 	 * Did we get any answers? 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|>
literal|0
operator|&&
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|)
condition|)
block|{
comment|/* 		 * [normal case] 		 * We've got answers.  If it has an authoritative answer or an 		 * answer from a forwarder, we're done. 		 */
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
operator|||
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|answer_response
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FCTXTRACE3
argument_list|(
literal|"answer_response (AA/fwd)"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iscname
argument_list|(
name|fctx
argument_list|)
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 			 * A BIND8 server could return a non-authoritative 			 * answer when a CNAME is followed.  We should treat 			 * it as a valid answer. 			 */
name|result
operator|=
name|answer_response
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FCTXTRACE3
argument_list|(
literal|"answer_response (!ANY/!CNAME)"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_ns
operator|&&
operator|!
name|betterreferral
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 			 * Lame response !!!. 			 */
name|result
operator|=
name|answer_response
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FCTXTRACE3
argument_list|(
literal|"answer_response (!NS)"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * A BIND 8 server could incorrectly return a 				 * non-authoritative answer to an NS query 				 * instead of a referral. Since this answer 				 * lacks the SIGs necessary to do DNSSEC 				 * validation, we must invoke the following 				 * special kludge to treat it as a referral. 				 */
name|result
operator|=
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|NULL
argument_list|,
name|LOOK_FOR_NS_IN_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FCTXTRACE3
argument_list|(
literal|"noanswer_response (NS)"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Some other servers may still somehow include 				 * an answer when it should return a referral 				 * with an empty answer.  Check to see if we can 				 * treat this as a referral by ignoring the 				 * answer.  Further more, there may be an 				 * implementation that moves A/AAAA glue records 				 * to the answer section for that type of 				 * delegation when the query is for that glue 				 * record.  LOOK_FOR_GLUE_IN_ANSWER will handle 				 * such a corner case. 				 */
name|result
operator|=
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|NULL
argument_list|,
name|LOOK_FOR_GLUE_IN_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FCTXTRACE3
argument_list|(
literal|"noanswer_response"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|DNS_R_DELEGATION
condition|)
block|{
comment|/* 				 * At this point, AA is not set, the response 				 * is not a referral, and the server is not a 				 * forwarder.  It is technically lame and it's 				 * easier to treat it as such than to figure out 				 * some more elaborate course of action. 				 */
name|broken_server
operator|=
name|DNS_R_LAME
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|force_referral
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|>
literal|0
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
block|{
comment|/* 		 * NXDOMAIN, NXRDATASET, or referral. 		 */
name|result
operator|=
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|DNS_R_CHASEDSSERVERS
case|:
break|break;
case|case
name|DNS_R_DELEGATION
case|:
name|force_referral
label|:
comment|/* 			 * We don't have the answer, but we know a better 			 * place to look. 			 */
name|get_nameservers
operator|=
name|ISC_TRUE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * We have a new set of name servers, and it 			 * has not experienced any restarts yet. 			 */
name|fctx
operator|->
name|restarts
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Update local statistics counters collected for each 			 * new zone. 			 */
name|fctx
operator|->
name|referrals
operator|++
expr_stmt|;
name|fctx
operator|->
name|querysent
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|lamecount
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|quotacount
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|neterr
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|badresp
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|adberr
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Something has gone wrong. 			 */
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
name|FCTXTRACE3
argument_list|(
literal|"noanswer_response"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The server is insane. 		 */
comment|/* XXXRTH Log */
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDRCODE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"broken server: unexpected rcode"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Follow additional section data chains. 	 */
name|chase_additional
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* 	 * Cache the cacheable parts of the message.  This may also cause 	 * work to be queued to the DNSSEC validator. 	 */
if|if
condition|(
name|WANTCACHE
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|result
operator|=
name|cache_message
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE3
argument_list|(
literal|"cache_message complete"
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Ncache the negatively cacheable parts of the message.  This may 	 * also cause work to be queued to the DNSSEC validator. 	 */
if|if
condition|(
name|WANTNCACHE
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|dns_rdatatype_t
name|covers
decl_stmt|;
comment|/* 		 * Cache DS NXDOMAIN seperately to other types. 		 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_ds
condition|)
name|covers
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|covers
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
comment|/* 		 * Cache any negative cache entries in the message. 		 */
name|result
operator|=
name|ncache_message
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|covers
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FCTXTRACE3
argument_list|(
literal|"ncache_message complete"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Remember the query's addrinfo, in case we need to mark the 	 * server as broken. 	 */
name|addrinfo
operator|=
name|query
operator|->
name|addrinfo
expr_stmt|;
name|FCTXTRACE4
argument_list|(
literal|"query canceled in response(); "
argument_list|,
name|no_response
condition|?
literal|"no response"
else|:
literal|"responding"
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel the query. 	 * 	 * XXXRTH  Don't cancel the query if waiting for validation? 	 */
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
operator|&
name|devent
argument_list|,
name|finish
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_trying
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|broken_server
operator|=
name|DNS_R_FORMERR
expr_stmt|;
if|if
condition|(
name|broken_server
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Add this server to the list of bad servers for 			 * this fctx. 			 */
name|add_bad
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|broken_server
argument_list|,
name|broken_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_nameservers
condition|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
name|findoptions
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|fctx
operator|->
name|type
argument_list|)
condition|)
name|findoptions
operator||=
name|DNS_DBFIND_NOEXACT
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_UNSHARED
operator|)
operator|==
literal|0
condition|)
name|name
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
else|else
name|name
operator|=
operator|&
name|fctx
operator|->
name|domain
expr_stmt|;
name|result
operator|=
name|dns_view_findzonecut
argument_list|(
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|fname
argument_list|,
name|now
argument_list|,
name|findoptions
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"couldn't find a zonecut"
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
comment|/* 				 * The best nameservers are now above our 				 * QDOMAIN. 				 */
name|FCTXTRACE
argument_list|(
literal|"nameservers now above QDOMAIN"
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|fcount_decr
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|fname
argument_list|,
name|fctx
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|result
operator|=
name|fcount_incr
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|fctx
operator|->
name|ns_ttl
operator|=
name|fctx
operator|->
name|nameservers
operator|.
name|ttl
expr_stmt|;
name|fctx
operator|->
name|ns_ttl_ok
operator|=
name|ISC_TRUE
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Try again. 		 */
name|fctx_try
argument_list|(
name|fctx
argument_list|,
operator|!
name|get_nameservers
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resend
condition|)
block|{
comment|/* 		 * Resend (probably with changed options). 		 */
name|FCTXTRACE
argument_list|(
literal|"resend"
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|res
argument_list|,
name|dns_resstatscounter_retry
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|fctx_increference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_query
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|bucket_empty
operator|=
name|fctx_decreference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 		 * All has gone well so far, but we are waiting for the 		 * DNSSEC validator to validate the answer. 		 */
name|FCTXTRACE
argument_list|(
literal|"wait for validator"
argument_list|)
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * We must not retransmit while the validator is working; 		 * it has references to the current rmessage. 		 */
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_CHASEDSSERVERS
condition|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|add_bad
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|result
argument_list|,
name|broken_type
argument_list|)
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"suspending DS lookup to find parent's NS records"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|res
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|task
argument_list|,
name|resume_dslookup
argument_list|,
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|nsrrset
argument_list|,
name|NULL
argument_list|,
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
block|{
name|fctx_increference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We're done. 		 */
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***  *** Resolver Methods  ***/
end_comment

begin_function
specifier|static
name|void
name|destroy_badcache
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|dns_badcache_t
modifier|*
name|bad
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|res
operator|->
name|badcache
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|badhash
condition|;
name|i
operator|++
control|)
for|for
control|(
name|bad
operator|=
name|res
operator|->
name|badcache
index|[
name|i
index|]
init|;
name|bad
operator|!=
name|NULL
condition|;
name|bad
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|res
operator|->
name|badcount
operator|--
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|badcache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
operator|->
name|badcache
argument_list|)
operator|*
name|res
operator|->
name|badhash
argument_list|)
expr_stmt|;
name|res
operator|->
name|badcache
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|badhash
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|badcount
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|alternate_t
modifier|*
name|a
decl_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|primefetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"destroy"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|nfctx
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
argument_list|)
expr_stmt|;
name|isc_task_shutdown
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|buckets
argument_list|,
name|res
operator|->
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|fctxbucket_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RES_DOMAIN_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|dbuckets
argument_list|,
name|RES_DOMAIN_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
name|zonebucket_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
if|if
condition|(
name|res
operator|->
name|dispatches4
operator|!=
name|NULL
condition|)
name|dns_dispatchset_destroy
argument_list|(
operator|&
name|res
operator|->
name|dispatches4
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatches6
operator|!=
name|NULL
condition|)
name|dns_dispatchset_destroy
argument_list|(
operator|&
name|res
operator|->
name|dispatches6
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|alternates
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|alternates
argument_list|,
name|a
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|isaddress
condition|)
name|dns_name_free
argument_list|(
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_resolver_reset_algorithms
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|destroy_badcache
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|dns_resolver_resetmustbesecure
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|isc_rwlock_destroy
argument_list|(
operator|&
name|res
operator|->
name|alglock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_MBSLOCK
name|isc_rwlock_destroy
argument_list|(
operator|&
name|res
operator|->
name|mbslock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isc_timer_detach
argument_list|(
operator|&
name|res
operator|->
name|spillattimer
argument_list|)
expr_stmt|;
name|res
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_shutdown_events
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|isc_task_t
modifier|*
name|etask
decl_stmt|;
comment|/* 	 * Caller must be holding the resolver lock. 	 */
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|etask
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|res
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|etask
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|empty_bucket
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|RTRACE
argument_list|(
literal|"empty_bucket"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|activebuckets
operator|>
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|activebuckets
operator|--
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|activebuckets
operator|==
literal|0
condition|)
name|send_shutdown_events
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spillattimer_countdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|isc_boolean_t
name|logit
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|res
operator|->
name|exiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|spillat
operator|>
name|res
operator|->
name|spillatmin
condition|)
block|{
name|res
operator|->
name|spillat
operator|--
expr_stmt|;
name|logit
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|spillat
operator|<=
name|res
operator|->
name|spillatmin
condition|)
block|{
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|res
operator|->
name|spillattimer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|res
operator|->
name|spillat
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|logit
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"clients-per-query decreased to %u"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_create
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|unsigned
name|int
name|ntasks
parameter_list|,
name|unsigned
name|int
name|ndisp
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|socketmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_dispatchmgr_t
modifier|*
name|dispatchmgr
parameter_list|,
name|dns_dispatch_t
modifier|*
name|dispatchv4
parameter_list|,
name|dns_dispatch_t
modifier|*
name|dispatchv6
parameter_list|,
name|dns_resolver_t
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|buckets_created
init|=
literal|0
decl_stmt|;
name|isc_task_t
modifier|*
name|task
init|=
name|NULL
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|dispattr
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|unsigned
name|int
name|dbuckets_created
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
comment|/* 	 * Create a resolver. 	 */
name|REQUIRE
argument_list|(
name|DNS_VIEW_VALID
argument_list|(
name|view
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ntasks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ndisp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
operator|&&
operator|*
name|resp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispatchmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispatchv4
operator|!=
name|NULL
operator|||
name|dispatchv6
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|=
name|isc_mem_get
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|RTRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
name|res
operator|->
name|mctx
operator|=
name|view
operator|->
name|mctx
expr_stmt|;
name|res
operator|->
name|rdclass
operator|=
name|view
operator|->
name|rdclass
expr_stmt|;
name|res
operator|->
name|socketmgr
operator|=
name|socketmgr
expr_stmt|;
name|res
operator|->
name|timermgr
operator|=
name|timermgr
expr_stmt|;
name|res
operator|->
name|taskmgr
operator|=
name|taskmgr
expr_stmt|;
name|res
operator|->
name|dispatchmgr
operator|=
name|dispatchmgr
expr_stmt|;
name|res
operator|->
name|view
operator|=
name|view
expr_stmt|;
name|res
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|res
operator|->
name|lame_ttl
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|alternates
argument_list|)
expr_stmt|;
name|res
operator|->
name|udpsize
operator|=
name|RECV_BUFFER_SIZE
expr_stmt|;
name|res
operator|->
name|algorithms
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|badcache
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|badcount
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|badhash
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|badsweep
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|mustbesecure
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|spillatmin
operator|=
name|res
operator|->
name|spillat
operator|=
literal|10
expr_stmt|;
name|res
operator|->
name|spillatmax
operator|=
literal|100
expr_stmt|;
name|res
operator|->
name|spillattimer
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|zspill
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|zero_no_soa_ttl
operator|=
name|ISC_FALSE
expr_stmt|;
name|res
operator|->
name|query_timeout
operator|=
name|DEFAULT_QUERY_TIMEOUT
expr_stmt|;
name|res
operator|->
name|maxdepth
operator|=
name|DEFAULT_RECURSION_DEPTH
expr_stmt|;
name|res
operator|->
name|maxqueries
operator|=
name|DEFAULT_MAX_QUERIES
expr_stmt|;
name|res
operator|->
name|quotaresp
index|[
name|dns_quotatype_zone
index|]
operator|=
name|DNS_R_DROP
expr_stmt|;
name|res
operator|->
name|quotaresp
index|[
name|dns_quotatype_server
index|]
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
name|res
operator|->
name|nbuckets
operator|=
name|ntasks
expr_stmt|;
name|res
operator|->
name|activebuckets
operator|=
name|ntasks
expr_stmt|;
name|res
operator|->
name|buckets
operator|=
name|isc_mem_get
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|ntasks
operator|*
sizeof|sizeof
argument_list|(
name|fctxbucket_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buckets
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_res
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntasks
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_buckets
goto|;
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_buckets
goto|;
block|}
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|mctx
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"res%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 		 * Use a separate memory context for each bucket to reduce 		 * contention among multiple threads.  Do this only when 		 * enabling threads because it will be require more memory. 		 */
name|result
operator|=
name|isc_mem_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_buckets
goto|;
block|}
name|isc_mem_setname
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|isc_mem_attach
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isc_task_setname
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|,
name|name
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
expr_stmt|;
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|buckets_created
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|res
operator|->
name|dbuckets
operator|=
name|isc_mem_get
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|RES_DOMAIN_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
name|zonebucket_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dbuckets
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_buckets
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RES_DOMAIN_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_detach
argument_list|(
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_dbuckets
goto|;
block|}
name|dbuckets_created
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|res
operator|->
name|dispatches4
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dispatchv4
operator|!=
name|NULL
condition|)
block|{
name|dns_dispatchset_create
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|socketmgr
argument_list|,
name|taskmgr
argument_list|,
name|dispatchv4
argument_list|,
operator|&
name|res
operator|->
name|dispatches4
argument_list|,
name|ndisp
argument_list|)
expr_stmt|;
name|dispattr
operator|=
name|dns_dispatch_getattributes
argument_list|(
name|dispatchv4
argument_list|)
expr_stmt|;
name|res
operator|->
name|exclusivev4
operator|=
name|ISC_TF
argument_list|(
operator|(
name|dispattr
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|dispatches6
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dispatchv6
operator|!=
name|NULL
condition|)
block|{
name|dns_dispatchset_create
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|socketmgr
argument_list|,
name|taskmgr
argument_list|,
name|dispatchv6
argument_list|,
operator|&
name|res
operator|->
name|dispatches6
argument_list|,
name|ndisp
argument_list|)
expr_stmt|;
name|dispattr
operator|=
name|dns_dispatch_getattributes
argument_list|(
name|dispatchv6
argument_list|)
expr_stmt|;
name|res
operator|->
name|exclusivev6
operator|=
name|ISC_TF
argument_list|(
operator|(
name|dispattr
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|res
operator|->
name|frozen
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|res
operator|->
name|primefetch
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|nfctx
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_dispatches
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_lock
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_nlock
goto|;
name|task
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_primelock
goto|;
name|result
operator|=
name|isc_timer_create
argument_list|(
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|task
argument_list|,
name|spillattimer_countdown
argument_list|,
name|res
argument_list|,
operator|&
name|res
operator|->
name|spillattimer
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_primelock
goto|;
if|#
directive|if
name|USE_ALGLOCK
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|res
operator|->
name|alglock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_spillattimer
goto|;
endif|#
directive|endif
if|#
directive|if
name|USE_MBSLOCK
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|res
operator|->
name|mbslock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_alglock
goto|;
endif|#
directive|endif
name|res
operator|->
name|magic
operator|=
name|RES_MAGIC
expr_stmt|;
operator|*
name|resp
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|#
directive|if
name|USE_MBSLOCK
name|cleanup_alglock
label|:
if|#
directive|if
name|USE_ALGLOCK
name|isc_rwlock_destroy
argument_list|(
operator|&
name|res
operator|->
name|alglock
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|USE_ALGLOCK
operator|||
name|USE_MBSLOCK
name|cleanup_spillattimer
label|:
name|isc_timer_detach
argument_list|(
operator|&
name|res
operator|->
name|spillattimer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup_primelock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|cleanup_nlock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|cleanup_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cleanup_dispatches
label|:
if|if
condition|(
name|res
operator|->
name|dispatches6
operator|!=
name|NULL
condition|)
name|dns_dispatchset_destroy
argument_list|(
operator|&
name|res
operator|->
name|dispatches6
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatches4
operator|!=
name|NULL
condition|)
name|dns_dispatchset_destroy
argument_list|(
operator|&
name|res
operator|->
name|dispatches4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|cleanup_dbuckets
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbuckets_created
condition|;
name|i
operator|++
control|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|res
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|dbuckets
argument_list|,
name|RES_DOMAIN_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
name|zonebucket_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT*/
name|cleanup_buckets
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buckets_created
condition|;
name|i
operator|++
control|)
block|{
name|isc_mem_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_task_shutdown
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|buckets
argument_list|,
name|res
operator|->
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|fctxbucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_res
label|:
name|isc_mem_put
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
specifier|static
name|void
name|prime_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|fevent
decl_stmt|;
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|fevent
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|res
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|fetch
operator|=
name|res
operator|->
name|primefetch
expr_stmt|;
name|res
operator|->
name|primefetch
operator|=
name|NULL
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|res
operator|->
name|view
operator|->
name|cache
operator|!=
name|NULL
operator|&&
name|res
operator|->
name|view
operator|->
name|hints
operator|!=
name|NULL
condition|)
block|{
name|dns_cache_attachdb
argument_list|(
name|res
operator|->
name|view
operator|->
name|cache
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|dns_root_checkhints
argument_list|(
name|res
operator|->
name|view
argument_list|,
name|res
operator|->
name|view
operator|->
name|hints
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fevent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fevent
operator|->
name|db
argument_list|,
operator|&
name|fevent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|fevent
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fevent
operator|->
name|sigrdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fevent
operator|->
name|rdataset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fevent
operator|->
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fetch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_prime
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|isc_boolean_t
name|want_priming
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"dns_resolver_prime"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|exiting
operator|&&
operator|!
name|res
operator|->
name|priming
condition|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|primefetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_TRUE
expr_stmt|;
name|want_priming
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_priming
condition|)
block|{
comment|/* 		 * To avoid any possible recursive locking problems, we 		 * start the priming fetch like any other fetch, and holding 		 * no resolver locks.  No one else will try to start it 		 * because we're the ones who set res->priming to true. 		 * Any other callers of dns_resolver_prime() while we're 		 * running will see that res->priming is already true and 		 * do nothing. 		 */
name|RTRACE
argument_list|(
literal|"priming"
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|isc_mem_get
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|primefetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|res
argument_list|,
name|dns_rootname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|res
operator|->
name|buckets
index|[
literal|0
index|]
operator|.
name|task
argument_list|,
name|prime_done
argument_list|,
name|res
argument_list|,
name|rdataset
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
operator|->
name|primefetch
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_function
name|void
name|dns_resolver_freeze
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
comment|/* 	 * Freeze resolver. 	 */
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|frozen
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_attach
parameter_list|(
name|dns_resolver_t
modifier|*
name|source
parameter_list|,
name|dns_resolver_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RRTRACE
argument_list|(
name|source
argument_list|,
literal|"attach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|source
operator|->
name|exiting
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_whenshutdown
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|eventp
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|clone
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|eventp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|event
operator|=
operator|*
name|eventp
expr_stmt|;
operator|*
name|eventp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|exiting
operator|&&
name|res
operator|->
name|activebuckets
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're already shutdown.  Send the event. 		 */
name|event
operator|->
name|ev_sender
operator|=
name|res
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clone
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|clone
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|clone
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_shutdown
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|exiting
condition|)
block|{
name|RTRACE
argument_list|(
literal|"exiting"
argument_list|)
expr_stmt|;
name|res
operator|->
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|fctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
init|;
name|fctx
operator|!=
name|NULL
condition|;
name|fctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
control|)
name|fctx_shutdown
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatches4
operator|!=
name|NULL
operator|&&
operator|!
name|res
operator|->
name|exclusivev4
condition|)
block|{
name|dns_dispatchset_cancelall
argument_list|(
name|res
operator|->
name|dispatches4
argument_list|,
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|dispatches6
operator|!=
name|NULL
operator|&&
operator|!
name|res
operator|->
name|exclusivev6
condition|)
block|{
name|dns_dispatchset_cancelall
argument_list|(
name|res
operator|->
name|dispatches6
argument_list|,
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|activebuckets
operator|>
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|activebuckets
operator|--
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|activebuckets
operator|==
literal|0
condition|)
name|send_shutdown_events
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|res
operator|->
name|spillattimer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_detach
parameter_list|(
name|dns_resolver_t
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|need_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|=
operator|*
name|resp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"detach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|exiting
operator|&&
name|res
operator|->
name|activebuckets
operator|==
literal|0
argument_list|)
expr_stmt|;
name|need_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_destroy
condition|)
name|destroy
argument_list|(
name|res
argument_list|)
expr_stmt|;
operator|*
name|resp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|fctx_match
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
comment|/* 	 * Don't match fetch contexts that are shutting down. 	 */
if|if
condition|(
name|fctx
operator|->
name|cloned
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
operator|||
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|type
operator|||
name|fctx
operator|->
name|options
operator|!=
name|options
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_fetch
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/* 	 * If there's no chance of logging it, don't render (format) the 	 * name and RDATA type (further below), and return early. 	 */
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|level
argument_list|,
literal|"createfetch: %s %s"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_createfetch
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|dns_forwarders_t
modifier|*
name|forwarders
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_fetch_t
modifier|*
modifier|*
name|fetchp
parameter_list|)
block|{
return|return
operator|(
name|dns_resolver_createfetch3
argument_list|(
name|res
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|domain
argument_list|,
name|nameservers
argument_list|,
name|forwarders
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fetchp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_createfetch2
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|dns_forwarders_t
modifier|*
name|forwarders
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|client
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_fetch_t
modifier|*
modifier|*
name|fetchp
parameter_list|)
block|{
return|return
operator|(
name|dns_resolver_createfetch3
argument_list|(
name|res
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|domain
argument_list|,
name|nameservers
argument_list|,
name|forwarders
argument_list|,
name|client
argument_list|,
name|id
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fetchp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_createfetch3
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|dns_forwarders_t
modifier|*
name|forwarders
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|client
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|unsigned
name|int
name|depth
parameter_list|,
name|isc_counter_t
modifier|*
name|qc
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_fetch_t
modifier|*
modifier|*
name|fetchp
parameter_list|)
block|{
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|new_fctx
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|spillat
decl_stmt|;
name|unsigned
name|int
name|spillatmin
decl_stmt|;
name|isc_boolean_t
name|dodestroy
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|forwarders
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|frozen
argument_list|)
expr_stmt|;
comment|/* XXXRTH  Check for meta type */
if|if
condition|(
name|domain
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|DNS_RDATASET_VALID
argument_list|(
name|nameservers
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nameservers
operator|->
name|type
operator|==
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
block|}
else|else
name|REQUIRE
argument_list|(
name|nameservers
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|forwarders
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fetchp
operator|!=
name|NULL
operator|&&
operator|*
name|fetchp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|log_fetch
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH  use a mempool? 	 */
name|fetch
operator|=
name|isc_mem_get
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|fetch
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fetch
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|dns_name_fullhash
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|)
operator|%
name|res
operator|->
name|nbuckets
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spillat
operator|=
name|res
operator|->
name|spillat
expr_stmt|;
name|spillatmin
operator|=
name|res
operator|->
name|spillatmin
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|exiting
condition|)
block|{
name|result
operator|=
name|ISC_R_SHUTTINGDOWN
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_UNSHARED
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|fctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|)
init|;
name|fctx
operator|!=
name|NULL
condition|;
name|fctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|fctx_match
argument_list|(
name|fctx
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|options
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Is this a duplicate? 	 */
if|if
condition|(
name|fctx
operator|!=
name|NULL
operator|&&
name|client
operator|!=
name|NULL
condition|)
block|{
name|dns_fetchevent_t
modifier|*
name|fevent
decl_stmt|;
for|for
control|(
name|fevent
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|fevent
operator|!=
name|NULL
condition|;
name|fevent
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|fevent
argument_list|,
name|ev_link
argument_list|)
control|)
block|{
if|if
condition|(
name|fevent
operator|->
name|client
operator|!=
name|NULL
operator|&&
name|fevent
operator|->
name|id
operator|==
name|id
operator|&&
name|isc_sockaddr_equal
argument_list|(
name|fevent
operator|->
name|client
argument_list|,
name|client
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_DUPLICATE
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>=
name|spillatmin
operator|&&
name|spillatmin
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|fctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|spillat
condition|)
name|fctx
operator|->
name|spilled
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|spilled
condition|)
block|{
name|result
operator|=
name|DNS_R_DROP
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
if|if
condition|(
name|fctx
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|fctx_create
argument_list|(
name|res
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|domain
argument_list|,
name|nameservers
argument_list|,
name|options
argument_list|,
name|bucketnum
argument_list|,
name|depth
argument_list|,
name|qc
argument_list|,
operator|&
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
name|new_fctx
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fctx
operator|->
name|depth
operator|>
name|depth
condition|)
name|fctx
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|result
operator|=
name|fctx_join
argument_list|(
name|fctx
argument_list|,
name|task
argument_list|,
name|client
argument_list|,
name|id
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fctx
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Launch this fctx. 			 */
name|event
operator|=
operator|&
name|fctx
operator|->
name|control_event
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
name|event
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_FETCHCONTROL
argument_list|,
name|fctx_start
argument_list|,
name|fctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We don't care about the result of fctx_unlink() 			 * since we know we're not exiting. 			 */
operator|(
name|void
operator|)
name|fctx_unlink
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|dodestroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dodestroy
condition|)
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|FTRACE
argument_list|(
literal|"created"
argument_list|)
expr_stmt|;
operator|*
name|fetchp
operator|=
name|fetch
expr_stmt|;
block|}
else|else
name|isc_mem_putanddetach
argument_list|(
operator|&
name|fetch
operator|->
name|mctx
argument_list|,
name|fetch
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_cancelfetch
parameter_list|(
name|dns_fetch_t
modifier|*
name|fetch
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|isc_task_t
modifier|*
name|etask
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_FETCH_VALID
argument_list|(
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|fetch
operator|->
name|private
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|FTRACE
argument_list|(
literal|"cancelfetch"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Find the completion event for this fetch (as opposed 	 * to those for other fetches that have joined the same 	 * fctx) and send it with result = ISC_R_CANCELED. 	 */
name|event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_done
condition|)
block|{
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|fetch
operator|==
name|fetch
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|etask
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|fctx
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|etask
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The fctx continues running even if no fetches remain; 	 * the answer is still cached. 	 */
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_destroyfetch
parameter_list|(
name|dns_fetch_t
modifier|*
modifier|*
name|fetchp
parameter_list|)
block|{
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
decl_stmt|;
name|REQUIRE
argument_list|(
name|fetchp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fetch
operator|=
operator|*
name|fetchp
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_FETCH_VALID
argument_list|(
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|fetch
operator|->
name|private
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|FTRACE
argument_list|(
literal|"destroyfetch"
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check: the caller should have gotten its event before 	 * trying to destroy the fetch. 	 */
name|event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_done
condition|)
block|{
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|event
operator|->
name|fetch
operator|!=
name|fetch
argument_list|)
expr_stmt|;
block|}
block|}
name|bucket_empty
operator|=
name|fctx_decreference
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|fetch
operator|->
name|mctx
argument_list|,
name|fetch
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fetchp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_logfetch
parameter_list|(
name|dns_fetch_t
modifier|*
name|fetch
parameter_list|,
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_boolean_t
name|duplicateok
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_FETCH_VALID
argument_list|(
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|fetch
operator|->
name|private
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|exitline
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fctx
operator|->
name|logged
operator|||
name|duplicateok
condition|)
block|{
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"fetch completed at %s:%d for %s in "
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u."
literal|"%06"
name|ISC_PRINT_QUADFORMAT
literal|"u: %s/%s "
literal|"[domain:%s,referral:%u,restart:%u,qrysent:%u,"
literal|"timeout:%u,lame:%u,"
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
literal|"quota:%u,"
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
literal|"neterr:%u,"
literal|"badresp:%u,adberr:%u,findfail:%u,valfail:%u]"
argument_list|,
name|__FILE__
argument_list|,
name|fctx
operator|->
name|exitline
argument_list|,
name|fctx
operator|->
name|info
argument_list|,
name|fctx
operator|->
name|duration
operator|/
name|US_PER_SEC
argument_list|,
name|fctx
operator|->
name|duration
operator|%
name|US_PER_SEC
argument_list|,
name|isc_result_totext
argument_list|(
name|fctx
operator|->
name|result
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|fctx
operator|->
name|vresult
argument_list|)
argument_list|,
name|domainbuf
argument_list|,
name|fctx
operator|->
name|referrals
argument_list|,
name|fctx
operator|->
name|restarts
argument_list|,
name|fctx
operator|->
name|querysent
argument_list|,
name|fctx
operator|->
name|timeouts
argument_list|,
name|fctx
operator|->
name|lamecount
argument_list|,
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|fctx
operator|->
name|quotacount
argument_list|,
endif|#
directive|endif
comment|/* ENABLE_FETCHLIMIT */
name|fctx
operator|->
name|neterr
argument_list|,
name|fctx
operator|->
name|badresp
argument_list|,
name|fctx
operator|->
name|adberr
argument_list|,
name|fctx
operator|->
name|findfail
argument_list|,
name|fctx
operator|->
name|valfail
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|logged
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_dispatchmgr_t
modifier|*
name|dns_resolver_dispatchmgr
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|dispatchmgr
operator|)
return|;
block|}
end_function

begin_function
name|dns_dispatch_t
modifier|*
name|dns_resolver_dispatchv4
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_dispatchset_get
argument_list|(
name|resolver
operator|->
name|dispatches4
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dns_dispatch_t
modifier|*
name|dns_resolver_dispatchv6
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_dispatchset_get
argument_list|(
name|resolver
operator|->
name|dispatches6
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_socketmgr_t
modifier|*
name|dns_resolver_socketmgr
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|socketmgr
operator|)
return|;
block|}
end_function

begin_function
name|isc_taskmgr_t
modifier|*
name|dns_resolver_taskmgr
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|taskmgr
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_resolver_getlamettl
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|lame_ttl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setlamettl
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint32_t
name|lame_ttl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|lame_ttl
operator|=
name|lame_ttl
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_resolver_nrunning
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|n
operator|=
name|resolver
operator|->
name|nfctx
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|nlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_addalternate
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|alt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|in_port_t
name|port
parameter_list|)
block|{
name|alternate_t
modifier|*
name|a
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|resolver
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|alt
operator|==
name|NULL
operator|)
operator|^
operator|(
name|name
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|alt
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|isaddress
operator|=
name|ISC_TRUE
expr_stmt|;
name|a
operator|->
name|_u
operator|.
name|addr
operator|=
operator|*
name|alt
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|isaddress
operator|=
name|ISC_FALSE
expr_stmt|;
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|name
argument_list|,
name|resolver
operator|->
name|mctx
argument_list|,
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
name|ISC_LINK_INIT
argument_list|(
name|a
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|resolver
operator|->
name|alternates
argument_list|,
name|a
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setudpsize
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint16_t
name|udpsize
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|udpsize
operator|=
name|udpsize
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint16_t
name|dns_resolver_getudpsize
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|udpsize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_flushbadcache
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_badcache_t
modifier|*
name|bad
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* 	 * Drop all entries that match the name, and also all expired 	 * entries from the badcache. 	 */
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcache
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|isc_time_t
name|now
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_time_now
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_time_settoepoch
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|i
operator|=
name|dns_name_hash
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|)
operator|%
name|resolver
operator|->
name|badhash
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bad
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
init|;
name|bad
operator|!=
name|NULL
condition|;
name|bad
operator|=
name|next
control|)
block|{
name|int
name|n
decl_stmt|;
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|n
operator|=
name|isc_time_compare
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|bad
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
operator|=
name|bad
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|--
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|bad
expr_stmt|;
block|}
block|}
else|else
name|destroy_badcache
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resizehash
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|,
name|isc_boolean_t
name|grow
parameter_list|)
block|{
name|unsigned
name|int
name|newsize
decl_stmt|;
name|dns_badcache_t
modifier|*
modifier|*
name|new
decl_stmt|,
modifier|*
name|bad
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* 	 * The number of buckets in the hashtable is modified in this 	 * function. Afterwards, all the entries are remapped into the 	 * corresponding new slot. Rehashing (hash computation) is 	 * unnecessary as the hash values had been saved. 	 */
if|if
condition|(
name|grow
condition|)
name|newsize
operator|=
name|resolver
operator|->
name|badhash
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
else|else
name|newsize
operator|=
operator|(
name|resolver
operator|->
name|badhash
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|new
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resolver
operator|->
name|badcache
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resolver
operator|->
name|badcache
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Because the hashtable implements a simple modulus mapping 	 * from hash to bucket (no extendible hashing is used), every 	 * name in the hashtable has to be remapped to its new slot. 	 * Entries that have expired (time) are dropped. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|resolver
operator|->
name|badhash
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|bad
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
init|;
name|bad
operator|!=
name|NULL
condition|;
name|bad
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
name|now
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|--
expr_stmt|;
block|}
else|else
block|{
name|bad
operator|->
name|next
operator|=
name|new
index|[
name|bad
operator|->
name|hashval
operator|%
name|newsize
index|]
expr_stmt|;
name|new
index|[
name|bad
operator|->
name|hashval
operator|%
name|newsize
index|]
operator|=
name|bad
expr_stmt|;
block|}
block|}
block|}
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|resolver
operator|->
name|badcache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resolver
operator|->
name|badcache
argument_list|)
operator|*
name|resolver
operator|->
name|badhash
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badhash
operator|=
name|newsize
expr_stmt|;
name|resolver
operator|->
name|badcache
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_addbadcache
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|isc_time_t
modifier|*
name|expire
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|hashval
decl_stmt|;
name|dns_badcache_t
modifier|*
name|bad
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* 	 * The badcache is implemented as a hashtable keyed on the name, 	 * and each bucket slot points to a linked list (separate 	 * chaining). 	 * 	 * To avoid long list chains, if the number of entries in the 	 * hashtable goes over number-of-buckets * 8, the 	 * number-of-buckets is doubled. Similarly, if the number of 	 * entries goes below number-of-buckets * 2, the number-of-buckets 	 * is halved. See resizehash(). 	 */
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcache
operator|==
name|NULL
condition|)
block|{
name|resolver
operator|->
name|badcache
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resolver
operator|->
name|badcache
argument_list|)
operator|*
name|DNS_BADCACHE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcache
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|resolver
operator|->
name|badhash
operator|=
name|DNS_BADCACHE_SIZE
expr_stmt|;
name|memset
argument_list|(
name|resolver
operator|->
name|badcache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resolver
operator|->
name|badcache
argument_list|)
operator|*
name|resolver
operator|->
name|badhash
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|isc_time_now
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_time_settoepoch
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|hashval
operator|=
name|dns_name_hash
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|i
operator|=
name|hashval
operator|%
name|resolver
operator|->
name|badhash
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bad
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
init|;
name|bad
operator|!=
name|NULL
condition|;
name|bad
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bad
operator|->
name|type
operator|==
name|type
operator|&&
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|bad
operator|->
name|name
argument_list|)
condition|)
break|break;
comment|/* Drop expired entries when walking the chain. */
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
operator|&
name|now
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
operator|=
name|bad
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|--
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|bad
expr_stmt|;
block|}
if|if
condition|(
name|bad
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Insert the name into the badcache hashtable at the 		 * head of the linked list at the appropriate slot. The 		 * name data follows right after the allocation for the 		 * linked list node. 		 */
name|isc_buffer_t
name|buffer
decl_stmt|;
name|bad
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|bad
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|bad
operator|->
name|hashval
operator|=
name|hashval
expr_stmt|;
name|bad
operator|->
name|expire
operator|=
operator|*
name|expire
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|bad
operator|+
literal|1
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|bad
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|name
argument_list|,
operator|&
name|bad
operator|->
name|name
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|bad
operator|->
name|next
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
expr_stmt|;
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
operator|=
name|bad
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|++
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcount
operator|>
name|resolver
operator|->
name|badhash
operator|*
literal|8
condition|)
name|resizehash
argument_list|(
name|resolver
argument_list|,
operator|&
name|now
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcount
operator|<
name|resolver
operator|->
name|badhash
operator|*
literal|2
operator|&&
name|resolver
operator|->
name|badhash
operator|>
name|DNS_BADCACHE_SIZE
condition|)
name|resizehash
argument_list|(
name|resolver
argument_list|,
operator|&
name|now
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|bad
operator|->
name|expire
operator|=
operator|*
name|expire
expr_stmt|;
name|cleanup
label|:
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_getbadcache
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
block|{
name|dns_badcache_t
modifier|*
name|bad
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcache
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|i
operator|=
name|dns_name_hash
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|)
operator|%
name|resolver
operator|->
name|badhash
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bad
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
init|;
name|bad
operator|!=
name|NULL
condition|;
name|bad
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
comment|/* 		 * Search the hash list. Clean out expired records as we go. 		 */
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
name|now
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
else|else
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bad
operator|->
name|type
operator|==
name|type
operator|&&
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|bad
operator|->
name|name
argument_list|)
condition|)
block|{
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|bad
expr_stmt|;
block|}
comment|/* 	 * Slow sweep to clean out stale records. 	 */
name|i
operator|=
name|resolver
operator|->
name|badsweep
operator|++
operator|%
name|resolver
operator|->
name|badhash
expr_stmt|;
name|bad
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bad
operator|!=
name|NULL
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
name|now
argument_list|)
operator|<
literal|0
condition|)
block|{
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|--
expr_stmt|;
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_printbadcache
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_badcache_t
modifier|*
name|bad
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_uint64_t
name|t
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";\n; Bad cache\n;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolver
operator|->
name|badcache
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|resolver
operator|->
name|badhash
condition|;
name|i
operator|++
control|)
block|{
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bad
operator|=
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
init|;
name|bad
operator|!=
name|NULL
condition|;
name|bad
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
operator|&
name|now
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|bad
operator|->
name|next
expr_stmt|;
else|else
name|resolver
operator|->
name|badcache
index|[
name|i
index|]
operator|=
name|bad
operator|->
name|next
expr_stmt|;
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bad
argument_list|)
operator|+
name|bad
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|badcount
operator|--
expr_stmt|;
continue|continue;
block|}
name|prev
operator|=
name|bad
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|bad
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|bad
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|isc_time_microdiff
argument_list|(
operator|&
name|bad
operator|->
name|expire
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|t
operator|/=
literal|1000
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"; %s/%s [ttl "
literal|"%"
name|ISC_PLATFORM_QUADFORMAT
literal|"u]\n"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_algorithm
parameter_list|(
name|void
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|algorithms
init|=
name|node
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|arg
decl_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|algorithms
argument_list|,
operator|*
name|algorithms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_reset_algorithms
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|algorithms
operator|!=
name|NULL
condition|)
name|dns_rbt_destroy
argument_list|(
operator|&
name|resolver
operator|->
name|algorithms
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_disable_algorithm
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|alg
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|algorithms
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Whether an algorithm is disabled (or not) is stored in a 	 * per-name bitfield that is stored as the node data of an 	 * RBT. 	 */
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alg
operator|>
literal|255
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
if|#
directive|if
name|USE_ALGLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|algorithms
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|free_algorithm
argument_list|,
name|resolver
operator|->
name|mctx
argument_list|,
operator|&
name|resolver
operator|->
name|algorithms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|len
operator|=
name|alg
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|alg
operator|%
literal|8
operator|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|resolver
operator|->
name|algorithms
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_EXISTS
condition|)
block|{
name|algorithms
operator|=
name|node
operator|->
name|data
expr_stmt|;
comment|/* 		 * If algorithms is set, algorithms[0] contains its 		 * length. 		 */
if|if
condition|(
name|algorithms
operator|==
name|NULL
operator|||
name|len
operator|>
operator|*
name|algorithms
condition|)
block|{
comment|/* 			 * If no bitfield exists in the node data, or if 			 * it is not long enough, allocate a new 			 * bitfield and copy the old (smaller) bitfield 			 * into it if one exists. 			 */
name|new
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|algorithms
operator|!=
name|NULL
condition|)
name|memmove
argument_list|(
name|new
argument_list|,
name|algorithms
argument_list|,
operator|*
name|algorithms
argument_list|)
expr_stmt|;
name|new
index|[
name|len
operator|-
literal|1
index|]
operator||=
name|mask
expr_stmt|;
comment|/* new[0] should contain the length of new. */
operator|*
name|new
operator|=
name|len
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|new
expr_stmt|;
comment|/* Free the older bitfield. */
if|if
condition|(
name|algorithms
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|algorithms
argument_list|,
operator|*
name|algorithms
argument_list|)
expr_stmt|;
block|}
else|else
name|algorithms
index|[
name|len
operator|-
literal|1
index|]
operator||=
name|mask
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|cleanup
label|:
if|#
directive|if
name|USE_ALGLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_algorithm_supported
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|alg
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|char
modifier|*
name|algorithms
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|found
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * DH is unsupported for DNSKEYs, see RFC 4034 sec. A.1. 	 */
if|if
condition|(
operator|(
name|alg
operator|==
name|DST_ALG_DH
operator|)
operator|||
operator|(
name|alg
operator|==
name|DST_ALG_INDIRECT
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|#
directive|if
name|USE_ALGLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|algorithms
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|result
operator|=
name|dns_rbt_findname
argument_list|(
name|resolver
operator|->
name|algorithms
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|len
operator|=
name|alg
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|alg
operator|%
literal|8
operator|)
expr_stmt|;
name|algorithms
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|len
operator|<=
operator|*
name|algorithms
operator|&&
operator|(
name|algorithms
index|[
name|len
operator|-
literal|1
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|unlock
label|:
if|#
directive|if
name|USE_ALGLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|dst_algorithm_supported
argument_list|(
name|alg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_digest_supported
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|unsigned
name|int
name|digest
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_ds_digest_supported
argument_list|(
name|digest
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_resetmustbesecure
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|mustbesecure
operator|!=
name|NULL
condition|)
name|dns_rbt_destroy
argument_list|(
operator|&
name|resolver
operator|->
name|mustbesecure
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|yes
init|=
name|ISC_TRUE
decl_stmt|,
name|no
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|dns_resolver_setmustbesecure
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|value
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|mustbesecure
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|resolver
operator|->
name|mustbesecure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|dns_rbt_addname
argument_list|(
name|resolver
operator|->
name|mustbesecure
argument_list|,
name|name
argument_list|,
name|value
condition|?
operator|&
name|yes
else|:
operator|&
name|no
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|#
directive|if
name|USE_MBSLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_getmustbesecure
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|value
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|mustbesecure
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|result
operator|=
name|dns_rbt_findname
argument_list|(
name|resolver
operator|->
name|mustbesecure
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|value
operator|=
operator|*
operator|(
name|isc_boolean_t
operator|*
operator|)
name|data
expr_stmt|;
name|unlock
label|:
if|#
directive|if
name|USE_MBSLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_getclientsperquery
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint32_t
modifier|*
name|cur
parameter_list|,
name|isc_uint32_t
modifier|*
name|min
parameter_list|,
name|isc_uint32_t
modifier|*
name|max
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
operator|*
name|cur
operator|=
name|resolver
operator|->
name|spillat
expr_stmt|;
if|if
condition|(
name|min
operator|!=
name|NULL
condition|)
operator|*
name|min
operator|=
name|resolver
operator|->
name|spillatmin
expr_stmt|;
if|if
condition|(
name|max
operator|!=
name|NULL
condition|)
operator|*
name|max
operator|=
name|resolver
operator|->
name|spillatmax
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setclientsperquery
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint32_t
name|min
parameter_list|,
name|isc_uint32_t
name|max
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|spillatmin
operator|=
name|resolver
operator|->
name|spillat
operator|=
name|min
expr_stmt|;
name|resolver
operator|->
name|spillatmax
operator|=
name|max
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setfetchesperzone
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint32_t
name|clients
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|zspill
operator|=
name|clients
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|clients
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_getzeronosoattl
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|zero_no_soa_ttl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setzeronosoattl
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_boolean_t
name|state
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|zero_no_soa_ttl
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_resolver_getoptions
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|options
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_resolver_gettimeout
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|query_timeout
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_settimeout
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|unsigned
name|int
name|seconds
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seconds
operator|==
literal|0
condition|)
name|seconds
operator|=
name|DEFAULT_QUERY_TIMEOUT
expr_stmt|;
if|if
condition|(
name|seconds
operator|>
name|MAXIMUM_QUERY_TIMEOUT
condition|)
name|seconds
operator|=
name|MAXIMUM_QUERY_TIMEOUT
expr_stmt|;
if|if
condition|(
name|seconds
operator|<
name|MINIMUM_QUERY_TIMEOUT
condition|)
name|seconds
operator|=
name|MINIMUM_QUERY_TIMEOUT
expr_stmt|;
name|resolver
operator|->
name|query_timeout
operator|=
name|seconds
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setmaxdepth
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|unsigned
name|int
name|maxdepth
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|maxdepth
operator|=
name|maxdepth
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_resolver_getmaxdepth
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|maxdepth
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setmaxqueries
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|unsigned
name|int
name|queries
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|maxqueries
operator|=
name|queries
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_resolver_getmaxqueries
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|maxqueries
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_dumpfetches
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RES_DOMAIN_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|fctxcount_t
modifier|*
name|fc
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|fc
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|resolver
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|list
argument_list|)
init|;
name|fc
operator|!=
name|NULL
condition|;
name|fc
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_name_print
argument_list|(
name|fc
operator|->
name|domain
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|": %d active (%d spilled, %d allowed)\n"
argument_list|,
name|fc
operator|->
name|count
argument_list|,
name|fc
operator|->
name|dropped
argument_list|,
name|fc
operator|->
name|allowed
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|dbuckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|UNUSED
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
block|}
end_function

begin_function
name|void
name|dns_resolver_setquotaresponse
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_quotatype_t
name|which
parameter_list|,
name|isc_result_t
name|resp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|which
operator|==
name|dns_quotatype_zone
operator|||
name|which
operator|==
name|dns_quotatype_server
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|==
name|DNS_R_DROP
operator|||
name|resp
operator|==
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|quotaresp
index|[
name|which
index|]
operator|=
name|resp
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|which
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_getquotaresponse
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_quotatype_t
name|which
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_FETCHLIMIT
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|which
operator|==
name|dns_quotatype_zone
operator|||
name|which
operator|==
name|dns_quotatype_server
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|quotaresp
index|[
name|which
index|]
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|which
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
comment|/* !ENABLE_FETCHLIMIT */
block|}
end_function

end_unit

