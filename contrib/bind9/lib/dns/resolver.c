begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: resolver.c,v 1.218.2.18.4.64.4.2 2007/01/11 05:05:10 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/adb.h>
end_include

begin_include
include|#
directive|include
file|<dns/cache.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<dns/ds.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/forward.h>
end_include

begin_include
include|#
directive|include
file|<dns/keytable.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/ncache.h>
end_include

begin_include
include|#
directive|include
file|<dns/opcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/peer.h>
end_include

begin_include
include|#
directive|include
file|<dns/rbt.h>
end_include

begin_include
include|#
directive|include
file|<dns/rcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rootns.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_include
include|#
directive|include
file|<dns/validator.h>
end_include

begin_define
define|#
directive|define
name|DNS_RESOLVER_TRACE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RESOLVER_TRACE
end_ifdef

begin_define
define|#
directive|define
name|RTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "res %p: %s", res, (m))
end_define

begin_define
define|#
directive|define
name|RRTRACE
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "res %p: %s", (r), (m))
end_define

begin_define
define|#
directive|define
name|FCTXTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fctx %p(%s'): %s", fctx, fctx->info, (m))
end_define

begin_define
define|#
directive|define
name|FCTXTRACE2
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
define|\
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fctx %p(%s): %s %s", \ 				      fctx, fctx->info, (m1), (m2))
end_define

begin_define
define|#
directive|define
name|FTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "fetch %p (fctx %p(%s)): %s", \ 				      fetch, fetch->private, \ 				      fetch->private->info, (m))
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_RESOLVER, \ 				      DNS_LOGMODULE_RESOLVER, \ 				      ISC_LOG_DEBUG(3), \ 				      "resquery %p (fctx %p(%s)): %s", \ 				      query, query->fctx, \ 				      query->fctx->info, (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RTRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|RRTRACE
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|FCTXTRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|FTRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Maximum EDNS0 input packet size.  */
end_comment

begin_define
define|#
directive|define
name|RECV_BUFFER_SIZE
value|4096
end_define

begin_comment
comment|/* XXXRTH  Constant. */
end_comment

begin_comment
comment|/*  * This defines the maximum number of timeouts we will permit before we  * disable EDNS0 on the query.  */
end_comment

begin_define
define|#
directive|define
name|MAX_EDNS0_TIMEOUTS
value|3
end_define

begin_typedef
typedef|typedef
name|struct
name|fetchctx
name|fetchctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|query
block|{
comment|/* Locked by task event serialization. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|dispatchmgr
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|dispatch
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|isc_socket_t
modifier|*
name|tcpsocket
decl_stmt|;
name|isc_time_t
name|start
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|dispentry
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct query
argument_list|)
name|link
expr_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_buffer_t
modifier|*
name|tsig
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|tsigkey
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|unsigned
name|int
name|sends
decl_stmt|;
name|unsigned
name|int
name|connects
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|512
index|]
decl_stmt|;
block|}
name|resquery_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|QUERY_MAGIC
value|ISC_MAGIC('Q', '!', '!', '!')
end_define

begin_define
define|#
directive|define
name|VALID_QUERY
parameter_list|(
name|query
parameter_list|)
value|ISC_MAGIC_VALID(query, QUERY_MAGIC)
end_define

begin_define
define|#
directive|define
name|RESQUERY_ATTR_CANCELED
value|0x02
end_define

begin_define
define|#
directive|define
name|RESQUERY_CONNECTING
parameter_list|(
name|q
parameter_list|)
value|((q)->connects> 0)
end_define

begin_define
define|#
directive|define
name|RESQUERY_CANCELED
parameter_list|(
name|q
parameter_list|)
value|(((q)->attributes& \ 					  RESQUERY_ATTR_CANCELED) != 0)
end_define

begin_define
define|#
directive|define
name|RESQUERY_SENDING
parameter_list|(
name|q
parameter_list|)
value|((q)->sends> 0)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|fetchstate_init
init|=
literal|0
block|,
comment|/* Start event has not run yet. */
name|fetchstate_active
block|,
name|fetchstate_done
comment|/* FETCHDONE events posted. */
block|}
name|fetchstate
typedef|;
end_typedef

begin_struct
struct|struct
name|fetchctx
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Locked by appropriate bucket lock. */
name|fetchstate
name|state
decl_stmt|;
name|isc_boolean_t
name|want_shutdown
decl_stmt|;
name|isc_boolean_t
name|cloned
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_event_t
name|control_event
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct fetchctx
argument_list|)
name|link
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_fetchevent_t
argument_list|)
name|events
expr_stmt|;
comment|/* Locked by task event serialization. */
name|dns_name_t
name|domain
decl_stmt|;
name|dns_rdataset_t
name|nameservers
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|isc_time_t
name|expires
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|dns_message_t
modifier|*
name|qmessage
decl_stmt|;
name|dns_message_t
modifier|*
name|rmessage
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|resquery_t
argument_list|)
name|queries
expr_stmt|;
name|dns_adbfindlist_t
name|finds
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_adbfindlist_t
name|altfinds
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|altfind
decl_stmt|;
name|dns_adbaddrinfolist_t
name|forwaddrs
decl_stmt|;
name|dns_adbaddrinfolist_t
name|altaddrs
decl_stmt|;
name|isc_sockaddrlist_t
name|forwarders
decl_stmt|;
name|dns_fwdpolicy_t
name|fwdpolicy
decl_stmt|;
name|isc_sockaddrlist_t
name|bad
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_validator_t
argument_list|)
name|validators
expr_stmt|;
name|dns_db_t
modifier|*
name|cache
decl_stmt|;
name|dns_adb_t
modifier|*
name|adb
decl_stmt|;
comment|/* 	 * The number of events we're waiting for. 	 */
name|unsigned
name|int
name|pending
decl_stmt|;
comment|/* 	 * The number of times we've "restarted" the current 	 * nameserver set.  This acts as a failsafe to prevent 	 * us from pounding constantly on a particular set of 	 * servers that, for whatever reason, are not giving 	 * us useful responses, but are responding in such a 	 * way that they are not marked "bad". 	 */
name|unsigned
name|int
name|restarts
decl_stmt|;
comment|/* 	 * The number of timeouts that have occurred since we  	 * last successfully received a response packet.  This 	 * is used for EDNS0 black hole detection. 	 */
name|unsigned
name|int
name|timeouts
decl_stmt|;
comment|/* 	 * Look aside state for DS lookups. 	 */
name|dns_name_t
name|nsname
decl_stmt|;
name|dns_fetch_t
modifier|*
name|nsfetch
decl_stmt|;
name|dns_rdataset_t
name|nsrrset
decl_stmt|;
comment|/*% 	 * Number of queries that reference this context. 	 */
name|unsigned
name|int
name|nqueries
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FCTX_MAGIC
value|ISC_MAGIC('F', '!', '!', '!')
end_define

begin_define
define|#
directive|define
name|VALID_FCTX
parameter_list|(
name|fctx
parameter_list|)
value|ISC_MAGIC_VALID(fctx, FCTX_MAGIC)
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_HAVEANSWER
value|0x0001
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_GLUING
value|0x0002
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_ADDRWAIT
value|0x0004
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_SHUTTINGDOWN
value|0x0008
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_WANTCACHE
value|0x0010
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_WANTNCACHE
value|0x0020
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_NEEDEDNS0
value|0x0040
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_TRIEDFIND
value|0x0080
end_define

begin_define
define|#
directive|define
name|FCTX_ATTR_TRIEDALT
value|0x0100
end_define

begin_define
define|#
directive|define
name|HAVE_ANSWER
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_HAVEANSWER) != \ 				 0)
end_define

begin_define
define|#
directive|define
name|GLUING
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_GLUING) != \ 				 0)
end_define

begin_define
define|#
directive|define
name|ADDRWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_ADDRWAIT) != \ 				 0)
end_define

begin_define
define|#
directive|define
name|SHUTTINGDOWN
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_SHUTTINGDOWN) \  				 != 0)
end_define

begin_define
define|#
directive|define
name|WANTCACHE
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_WANTCACHE) != 0)
end_define

begin_define
define|#
directive|define
name|WANTNCACHE
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_WANTNCACHE) != 0)
end_define

begin_define
define|#
directive|define
name|NEEDEDNS0
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_NEEDEDNS0) != 0)
end_define

begin_define
define|#
directive|define
name|TRIEDFIND
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_TRIEDFIND) != 0)
end_define

begin_define
define|#
directive|define
name|TRIEDALT
parameter_list|(
name|f
parameter_list|)
value|(((f)->attributes& FCTX_ATTR_TRIEDALT) != 0)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
block|}
name|dns_valarg_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_fetch
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|fetchctx_t
modifier|*
name|private
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_FETCH_MAGIC
value|ISC_MAGIC('F', 't', 'c', 'h')
end_define

begin_define
define|#
directive|define
name|DNS_FETCH_VALID
parameter_list|(
name|fetch
parameter_list|)
value|ISC_MAGIC_VALID(fetch, DNS_FETCH_MAGIC)
end_define

begin_typedef
typedef|typedef
struct|struct
name|fctxbucket
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|fetchctx_t
argument_list|)
name|fctxs
expr_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
block|}
name|fctxbucket_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|alternate
block|{
name|isc_boolean_t
name|isaddress
decl_stmt|;
union|union
block|{
name|isc_sockaddr_t
name|addr
decl_stmt|;
struct|struct
block|{
name|dns_name_t
name|name
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
block|}
name|_n
struct|;
block|}
name|_u
union|;
name|ISC_LINK
argument_list|(
argument|struct alternate
argument_list|)
name|link
expr_stmt|;
block|}
name|alternate_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_resolver
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_mutex_t
name|nlock
decl_stmt|;
name|isc_mutex_t
name|primelock
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|socketmgr
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|timermgr
decl_stmt|;
name|isc_taskmgr_t
modifier|*
name|taskmgr
decl_stmt|;
name|dns_view_t
modifier|*
name|view
decl_stmt|;
name|isc_boolean_t
name|frozen
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|dispatchmgr
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|dispatchv4
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|dispatchv6
decl_stmt|;
name|unsigned
name|int
name|nbuckets
decl_stmt|;
name|fctxbucket_t
modifier|*
name|buckets
decl_stmt|;
name|isc_uint32_t
name|lame_ttl
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|alternate_t
argument_list|)
name|alternates
expr_stmt|;
name|isc_uint16_t
name|udpsize
decl_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|isc_rwlock_t
name|alglock
decl_stmt|;
endif|#
directive|endif
name|dns_rbt_t
modifier|*
name|algorithms
decl_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|isc_rwlock_t
name|mbslock
decl_stmt|;
endif|#
directive|endif
name|dns_rbt_t
modifier|*
name|mustbesecure
decl_stmt|;
comment|/* Locked by lock. */
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
name|isc_eventlist_t
name|whenshutdown
decl_stmt|;
name|unsigned
name|int
name|activebuckets
decl_stmt|;
name|isc_boolean_t
name|priming
decl_stmt|;
comment|/* Locked by primelock. */
name|dns_fetch_t
modifier|*
name|primefetch
decl_stmt|;
comment|/* Locked by nlock. */
name|unsigned
name|int
name|nfctx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RES_MAGIC
value|ISC_MAGIC('R', 'e', 's', '!')
end_define

begin_define
define|#
directive|define
name|VALID_RESOLVER
parameter_list|(
name|res
parameter_list|)
value|ISC_MAGIC_VALID(res, RES_MAGIC)
end_define

begin_comment
comment|/*  * Private addrinfo flags.  These must not conflict with DNS_FETCHOPT_NOEDNS0,  * which we also use as an addrinfo flag.  */
end_comment

begin_define
define|#
directive|define
name|FCTX_ADDRINFO_MARK
value|0x0001
end_define

begin_define
define|#
directive|define
name|FCTX_ADDRINFO_FORWARDER
value|0x1000
end_define

begin_define
define|#
directive|define
name|UNMARKED
parameter_list|(
name|a
parameter_list|)
value|(((a)->flags& FCTX_ADDRINFO_MARK) \ 					 == 0)
end_define

begin_define
define|#
directive|define
name|ISFORWARDER
parameter_list|(
name|a
parameter_list|)
value|(((a)->flags& \ 					 FCTX_ADDRINFO_FORWARDER) != 0)
end_define

begin_define
define|#
directive|define
name|NXDOMAIN
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_NXDOMAIN) != 0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|empty_bucket
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|resquery_send
parameter_list|(
name|resquery_t
modifier|*
name|query
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resquery_response
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resquery_connected
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fctx_try
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|fctx_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|ncache_adderesult
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_db_t
modifier|*
name|cache
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_ttl_t
name|maxttl
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|isc_result_t
modifier|*
name|eresultp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validated
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|isc_result_t
name|valcreate
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|unsigned
name|int
name|valoptions
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|dns_validator_t
modifier|*
name|validator
init|=
name|NULL
decl_stmt|;
name|dns_valarg_t
modifier|*
name|valarg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|valarg
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|valarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valarg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|valarg
operator|->
name|fctx
operator|=
name|fctx
expr_stmt|;
name|valarg
operator|->
name|addrinfo
operator|=
name|addrinfo
expr_stmt|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
name|INSIST
argument_list|(
operator|(
name|valoptions
operator|&
name|DNS_VALIDATOR_DEFER
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_validator_create
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fctx
operator|->
name|rmessage
argument_list|,
name|valoptions
argument_list|,
name|task
argument_list|,
name|validated
argument_list|,
name|valarg
argument_list|,
operator|&
name|validator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|validators
argument_list|,
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
name|valarg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|valarg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|fix_mustbedelegationornxdomain
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_name_t
modifier|*
name|domain
init|=
operator|&
name|fctx
operator|->
name|domain
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|keep_auth
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * Look for BIND 8 style delegations. 	 * Also look for answers to ANY queries where the duplicate NS RRset 	 * may have been stripped from the authority section. 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|!=
literal|0
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|)
condition|)
block|{
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_ns
condition|)
continue|continue;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for referral. */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|==
literal|0
condition|)
goto|goto
name|munge
goto|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
name|keep_auth
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_ns
operator|&&
name|type
operator|!=
name|dns_rdatatype_soa
condition|)
continue|continue;
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
goto|goto
name|munge
goto|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|munge
label|:
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_nxdomain
expr_stmt|;
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keep_auth
condition|)
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|=
literal|0
expr_stmt|;
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ADDITIONAL
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_starttimer
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
comment|/* 	 * Start the lifetime timer for fctx. 	 * 	 * This is also used for stopping the idle timer; in that 	 * case we must purge events already posted to ensure that 	 * no further idle events are delivered. 	 */
return|return
operator|(
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
operator|&
name|fctx
operator|->
name|expires
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_stoptimer
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * We don't return a result if resetting the timer to inactive fails 	 * since there's nothing to be done about it.  Resetting to inactive 	 * should never fail anyway, since the code as currently written 	 * cannot fail in that case. 	 */
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|timer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timer_reset(): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_startidletimer
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
comment|/* 	 * Start the idle timer for fctx.  The lifetime timer continues 	 * to be in effect. 	 */
return|return
operator|(
name|isc_timer_reset
argument_list|(
name|fctx
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
operator|&
name|fctx
operator|->
name|expires
argument_list|,
operator|&
name|fctx
operator|->
name|interval
argument_list|,
name|ISC_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stopping the idle timer is equivalent to calling fctx_starttimer(), but  * we use fctx_stopidletimer for readability in the code below.  */
end_comment

begin_define
define|#
directive|define
name|fctx_stopidletimer
value|fctx_starttimer
end_define

begin_function
specifier|static
specifier|inline
name|void
name|resquery_destroy
parameter_list|(
name|resquery_t
modifier|*
modifier|*
name|queryp
parameter_list|)
block|{
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|REQUIRE
argument_list|(
name|queryp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|query
operator|=
operator|*
name|queryp
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|query
operator|->
name|tcpsocket
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|query
operator|->
name|fctx
operator|->
name|nqueries
operator|--
expr_stmt|;
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|query
operator|->
name|fctx
argument_list|)
condition|)
name|maybe_destroy
argument_list|(
name|query
operator|->
name|fctx
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
name|query
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|query
operator|->
name|mctx
argument_list|,
name|query
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|queryp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cancelquery
parameter_list|(
name|resquery_t
modifier|*
modifier|*
name|queryp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
modifier|*
name|deventp
parameter_list|,
name|isc_time_t
modifier|*
name|finish
parameter_list|,
name|isc_boolean_t
name|no_response
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|unsigned
name|int
name|rtt
decl_stmt|;
name|unsigned
name|int
name|factor
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|query
operator|=
operator|*
name|queryp
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"cancelquery"
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|RESQUERY_CANCELED
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|->
name|attributes
operator||=
name|RESQUERY_ATTR_CANCELED
expr_stmt|;
comment|/* 	 * Should we update the RTT? 	 */
if|if
condition|(
name|finish
operator|!=
name|NULL
operator|||
name|no_response
condition|)
block|{
if|if
condition|(
name|finish
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have both the start and finish times for this 			 * packet, so we can compute a real RTT. 			 */
name|rtt
operator|=
operator|(
name|unsigned
name|int
operator|)
name|isc_time_microdiff
argument_list|(
name|finish
argument_list|,
operator|&
name|query
operator|->
name|start
argument_list|)
expr_stmt|;
name|factor
operator|=
name|DNS_ADB_RTTADJDEFAULT
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We don't have an RTT for this query.  Maybe the 			 * packet was lost, or maybe this server is very 			 * slow.  We don't know.  Increase the RTT. 			 */
name|INSIST
argument_list|(
name|no_response
argument_list|)
expr_stmt|;
name|rtt
operator|=
name|query
operator|->
name|addrinfo
operator|->
name|srtt
operator|+
operator|(
literal|200000
operator|*
name|fctx
operator|->
name|restarts
operator|)
expr_stmt|;
if|if
condition|(
name|rtt
operator|>
literal|10000000
condition|)
name|rtt
operator|=
literal|10000000
expr_stmt|;
comment|/* 			 * Replace the current RTT with our value. 			 */
name|factor
operator|=
name|DNS_ADB_RTTADJREPLACE
expr_stmt|;
block|}
name|dns_adb_adjustsrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|rtt
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Age RTTs of servers not tried. 	 */
name|factor
operator|=
name|DNS_ADB_RTTADJAGE
expr_stmt|;
if|if
condition|(
name|finish
operator|!=
name|NULL
condition|)
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_adjustsrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
literal|0
argument_list|,
name|factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish
operator|!=
name|NULL
operator|&&
name|TRIEDFIND
argument_list|(
name|fctx
argument_list|)
condition|)
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
control|)
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_adjustsrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
literal|0
argument_list|,
name|factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish
operator|!=
name|NULL
operator|&&
name|TRIEDALT
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_adjustsrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
literal|0
argument_list|,
name|factor
argument_list|)
expr_stmt|;
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
control|)
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
name|dns_adb_adjustsrtt
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|addrinfo
argument_list|,
literal|0
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|->
name|dispentry
operator|!=
name|NULL
condition|)
name|dns_dispatch_removeresponse
argument_list|(
operator|&
name|query
operator|->
name|dispentry
argument_list|,
name|deventp
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|queries
argument_list|,
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tsig
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|query
operator|->
name|tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tsigkey
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|query
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
comment|/* 	 * Check for any outstanding socket events.  If they exist, cancel 	 * them and let the event handlers finish the cleanup.  The resolver 	 * only needs to worry about managing the connect and send events; 	 * the dispatcher manages the recv events. 	 */
if|if
condition|(
name|RESQUERY_CONNECTING
argument_list|(
name|query
argument_list|)
condition|)
comment|/* 		 * Cancel the connect. 		 */
name|isc_socket_cancel
argument_list|(
name|query
operator|->
name|tcpsocket
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKCANCEL_CONNECT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RESQUERY_SENDING
argument_list|(
name|query
argument_list|)
condition|)
comment|/* 		 * Cancel the pending send. 		 */
name|isc_socket_cancel
argument_list|(
name|dns_dispatch_getsocket
argument_list|(
name|query
operator|->
name|dispatch
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKCANCEL_SEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|dispatch
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|RESQUERY_CONNECTING
argument_list|(
name|query
argument_list|)
operator|||
name|RESQUERY_SENDING
argument_list|(
name|query
argument_list|)
operator|)
condition|)
comment|/* 		 * It's safe to destroy the query now. 		 */
name|resquery_destroy
argument_list|(
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cancelqueries
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|no_response
parameter_list|)
block|{
name|resquery_t
modifier|*
name|query
decl_stmt|,
modifier|*
name|next_query
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"cancelqueries"
argument_list|)
expr_stmt|;
for|for
control|(
name|query
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
init|;
name|query
operator|!=
name|NULL
condition|;
name|query
operator|=
name|next_query
control|)
block|{
name|next_query
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupfinds
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|,
modifier|*
name|next_find
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|next_find
control|)
block|{
name|next_find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|finds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupaltfinds
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|,
modifier|*
name|next_find
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
init|;
name|find
operator|!=
name|NULL
condition|;
name|find
operator|=
name|next_find
control|)
block|{
name|next_find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|altfind
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupforwaddrs
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addr
decl_stmt|,
modifier|*
name|next_addr
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_addr
control|)
block|{
name|next_addr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|,
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_freeaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_cleanupaltaddrs
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|addr
decl_stmt|,
modifier|*
name|next_addr
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_addr
control|)
block|{
name|next_addr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|,
name|addr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|dns_adb_freeaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_stopeverything
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_boolean_t
name|no_response
parameter_list|)
block|{
name|FCTXTRACE
argument_list|(
literal|"stopeverything"
argument_list|)
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_stoptimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_sendevents
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
comment|/* 	 * Caller must be holding the appropriate bucket lock. 	 */
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"sendevents"
argument_list|)
expr_stmt|;
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|task
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|fctx
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
name|event
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|||
name|dns_rdataset_isassociated
argument_list|(
name|event
operator|->
name|rdataset
argument_list|)
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_sig
argument_list|)
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_done
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|no_response
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|no_response
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|no_response
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx_stopeverything
argument_list|(
name|fctx
argument_list|,
name|no_response
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|state
operator|=
name|fetchstate_done
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
name|fctx_sendevents
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_senddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|retry
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_SENDDONE
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"senddone"
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH 	 * 	 * Currently we don't wait for the senddone event before retrying 	 * a query.  This means that if we get really behind, we may end 	 * up doing extra work! 	 */
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|RESQUERY_SENDING
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|->
name|sends
operator|--
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
if|if
condition|(
name|RESQUERY_CANCELED
argument_list|(
name|query
argument_list|)
condition|)
block|{
if|if
condition|(
name|query
operator|->
name|sends
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This query was canceled while the 			 * isc_socket_sendto() was in progress. 			 */
if|if
condition|(
name|query
operator|->
name|tcpsocket
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|resquery_destroy
argument_list|(
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|sevent
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
break|break;
case|case
name|ISC_R_HOSTUNREACH
case|:
case|case
name|ISC_R_NETUNREACH
case|:
case|case
name|ISC_R_NOPERM
case|:
case|case
name|ISC_R_ADDRNOTAVAIL
case|:
case|case
name|ISC_R_CONNREFUSED
case|:
comment|/* 			 * No route to remote. 			 */
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|retry
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
default|default:
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
condition|)
block|{
comment|/* 		 * Behave as if the idle timer has expired.  For TCP 		 * this may not actually reflect the latest timer. 		 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_addopt
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rdatalist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|message
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdata
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|message
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|rdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_opt
expr_stmt|;
name|rdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set Maximum UDP buffer size. 	 */
name|rdatalist
operator|->
name|rdclass
operator|=
name|res
operator|->
name|udpsize
expr_stmt|;
comment|/* 	 * Set EXTENDED-RCODE, VERSION, and Z to 0, and the DO bit to 1. 	 */
name|rdatalist
operator|->
name|ttl
operator|=
name|DNS_MESSAGEEXTFLAG_DO
expr_stmt|;
comment|/* 	 * No EDNS options. 	 */
name|rdata
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|rdata
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|rdata
operator|->
name|rdclass
operator|=
name|rdatalist
operator|->
name|rdclass
expr_stmt|;
name|rdata
operator|->
name|type
operator|=
name|rdatalist
operator|->
name|type
expr_stmt|;
name|rdata
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
name|rdatalist
argument_list|,
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_message_setopt
argument_list|(
name|message
argument_list|,
name|rdataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fctx_setretryinterval
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|unsigned
name|int
name|rtt
parameter_list|)
block|{
name|unsigned
name|int
name|seconds
decl_stmt|;
comment|/* 	 * We retry every 2 seconds the first two times through the address 	 * list, and then we do exponential back-off. 	 */
if|if
condition|(
name|fctx
operator|->
name|restarts
operator|<
literal|3
condition|)
name|seconds
operator|=
literal|2
expr_stmt|;
else|else
name|seconds
operator|=
operator|(
literal|2
operator|<<
operator|(
name|fctx
operator|->
name|restarts
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Double the round-trip time and convert to seconds. 	 */
name|rtt
operator|/=
literal|500000
expr_stmt|;
comment|/* 	 * Always wait for at least the doubled round-trip time. 	 */
if|if
condition|(
name|seconds
operator|<
name|rtt
condition|)
name|seconds
operator|=
name|rtt
expr_stmt|;
comment|/* 	 * But don't ever wait for more than 30 seconds. 	 */
if|if
condition|(
name|seconds
operator|>
literal|30
condition|)
name|seconds
operator|=
literal|30
expr_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|fctx
operator|->
name|interval
argument_list|,
name|seconds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fctx_query
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|resquery_t
modifier|*
name|query
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"query"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|task
operator|=
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
expr_stmt|;
name|fctx_setretryinterval
argument_list|(
name|fctx
argument_list|,
name|addrinfo
operator|->
name|srtt
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_startidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|dns_message_reset
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|)
expr_stmt|;
name|query
operator|=
name|isc_mem_get
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|stop_idle_timer
goto|;
block|}
name|query
operator|->
name|mctx
operator|=
name|res
operator|->
name|mctx
expr_stmt|;
name|query
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|query
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|sends
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|connects
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Note that the caller MUST guarantee that 'addrinfo' will remain 	 * valid until this query is canceled. 	 */
name|query
operator|->
name|addrinfo
operator|=
name|addrinfo
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|query
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a TCP query, then we need to make a socket and 	 * a dispatch for it here.  Otherwise we use the resolver's 	 * shared dispatch. 	 */
name|query
operator|->
name|dispatchmgr
operator|=
name|res
operator|->
name|dispatchmgr
expr_stmt|;
name|query
operator|->
name|dispatch
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|tcpsocket
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_sockaddr_t
name|addr
decl_stmt|;
name|int
name|pf
decl_stmt|;
name|pf
operator|=
name|isc_sockaddr_pf
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pf
condition|)
block|{
case|case
name|PF_INET
case|:
name|result
operator|=
name|dns_dispatch_getlocaladdress
argument_list|(
name|res
operator|->
name|dispatchv4
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|result
operator|=
name|dns_dispatch_getlocaladdress
argument_list|(
name|res
operator|->
name|dispatchv6
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_query
goto|;
name|isc_sockaddr_setport
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_create
argument_list|(
name|res
operator|->
name|socketmgr
argument_list|,
name|pf
argument_list|,
name|isc_sockettype_tcp
argument_list|,
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_query
goto|;
ifndef|#
directive|ifndef
name|BROKEN_TCP_BIND_BEFORE_CONNECT
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|query
operator|->
name|tcpsocket
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_socket
goto|;
endif|#
directive|endif
comment|/* 		 * A dispatch will be created once the connect succeeds. 		 */
block|}
else|else
block|{
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
name|dns_dispatch_attach
argument_list|(
name|res
operator|->
name|dispatchv4
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|dns_dispatch_attach
argument_list|(
name|res
operator|->
name|dispatchv6
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|cleanup_query
goto|;
block|}
comment|/* 		 * We should always have a valid dispatcher here.  If we 		 * don't support a protocol family, then its dispatcher 		 * will be NULL, but we shouldn't be finding addresses for 		 * protocol types we don't support, so the dispatcher 		 * we found should never be NULL. 		 */
name|INSIST
argument_list|(
name|query
operator|->
name|dispatch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|query
operator|->
name|dispentry
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|fctx
operator|=
name|fctx
expr_stmt|;
name|query
operator|->
name|tsig
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|tsigkey
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query
operator|->
name|magic
operator|=
name|QUERY_MAGIC
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Connect to the remote server. 		 * 		 * XXXRTH  Should we attach to the socket? 		 */
name|result
operator|=
name|isc_socket_connect
argument_list|(
name|query
operator|->
name|tcpsocket
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|task
argument_list|,
name|resquery_connected
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_socket
goto|;
name|query
operator|->
name|connects
operator|++
expr_stmt|;
name|QTRACE
argument_list|(
literal|"connecting via TCP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|resquery_send
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_dispatch
goto|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|queries
argument_list|,
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query
operator|->
name|fctx
operator|->
name|nqueries
operator|++
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_socket
label|:
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|cleanup_dispatch
label|:
if|if
condition|(
name|query
operator|->
name|dispatch
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|cleanup_query
label|:
name|query
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|query
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|stop_idle_timer
label|:
name|RUNTIME_CHECK
argument_list|(
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|resquery_send
parameter_list|(
name|resquery_t
modifier|*
name|query
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|qname
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|qrdataset
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
name|isc_buffer_t
name|tcpbuffer
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|address
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_netaddr_t
name|ipaddr
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|tsigkey
init|=
name|NULL
decl_stmt|;
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|useedns
decl_stmt|;
name|dns_compress_t
name|cctx
decl_stmt|;
name|isc_boolean_t
name|cleanup_cctx
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|secure_domain
decl_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|QTRACE
argument_list|(
literal|"send"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|task
operator|=
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
expr_stmt|;
name|address
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Reserve space for the TCP message length. 		 */
name|isc_buffer_init
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
name|query
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|buffer
argument_list|,
name|query
operator|->
name|data
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|data
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|&
name|tcpbuffer
expr_stmt|;
block|}
else|else
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|buffer
argument_list|,
name|query
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|&
name|query
operator|->
name|buffer
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_temps
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_temps
goto|;
comment|/* 	 * Get a query id from the dispatch. 	 */
name|result
operator|=
name|dns_dispatch_addresponse
argument_list|(
name|query
operator|->
name|dispatch
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|task
argument_list|,
name|resquery_response
argument_list|,
name|query
argument_list|,
operator|&
name|query
operator|->
name|id
argument_list|,
operator|&
name|query
operator|->
name|dispentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_temps
goto|;
name|fctx
operator|->
name|qmessage
operator|->
name|opcode
operator|=
name|dns_opcode_query
expr_stmt|;
comment|/* 	 * Set up question. 	 */
name|dns_name_init
argument_list|(
name|qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|qrdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_makequestion
argument_list|(
name|qrdataset
argument_list|,
name|res
operator|->
name|rdclass
argument_list|,
name|fctx
operator|->
name|type
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qname
operator|->
name|list
argument_list|,
name|qrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|qname
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
name|qname
operator|=
name|NULL
expr_stmt|;
name|qrdataset
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Set RD if the client has requested that we do a recursive query, 	 * or if we're sending to a forwarder. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_RECURSIVE
operator|)
operator|!=
literal|0
operator|||
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
condition|)
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_RD
expr_stmt|;
comment|/* 	 * Set CD if the client says don't validate or the question is 	 * under a secure entry point. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|dns_keytable_issecuredomain
argument_list|(
name|res
operator|->
name|view
operator|->
name|secroots
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|secure_domain
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
name|secure_domain
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|secure_domain
condition|)
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
block|}
else|else
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
comment|/* 	 * We don't have to set opcode because it defaults to query. 	 */
name|fctx
operator|->
name|qmessage
operator|->
name|id
operator|=
name|query
operator|->
name|id
expr_stmt|;
comment|/* 	 * Convert the question to wire format. 	 */
name|result
operator|=
name|dns_compress_init
argument_list|(
operator|&
name|cctx
argument_list|,
operator|-
literal|1
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|cleanup_cctx
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dns_message_renderbegin
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|cctx
argument_list|,
operator|&
name|query
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|peer
operator|=
name|NULL
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|ipaddr
argument_list|,
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|ipaddr
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * The ADB does not know about servers with "edns no".  Check this, 	 * and then inform the ADB for future use. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|addrinfo
operator|->
name|flags
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
operator|&&
name|peer
operator|!=
name|NULL
operator|&&
name|dns_peer_getsupportedns
argument_list|(
name|peer
argument_list|,
operator|&
name|useedns
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|useedns
condition|)
block|{
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Use EDNS0, unless the caller doesn't want it, or we know that 	 * the remote server doesn't like it. 	 */
if|if
condition|(
name|fctx
operator|->
name|timeouts
operator|>=
name|MAX_EDNS0_TIMEOUTS
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"too many timeouts, disabling EDNS0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|query
operator|->
name|addrinfo
operator|->
name|flags
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|fctx_addopt
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * We couldn't add the OPT, but we'll press on. 				 * We're not using EDNS0, so set the NOEDNS0 				 * bit. 				 */
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We know this server doesn't like EDNS0, so we 			 * won't use it.  Set the NOEDNS0 bit since we're 			 * not using EDNS0. 			 */
name|query
operator|->
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
block|}
block|}
comment|/* 	 * If we need EDNS0 to do this query and aren't using it, we lose. 	 */
if|if
condition|(
name|NEEDEDNS0
argument_list|(
name|fctx
argument_list|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup_message
goto|;
block|}
comment|/* 	 * Clear CD if EDNS is not in use. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|!=
literal|0
condition|)
name|fctx
operator|->
name|qmessage
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
comment|/* 	 * Add TSIG record tailored to the current recipient. 	 */
name|result
operator|=
name|dns_view_getpeertsig
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
operator|&
name|ipaddr
argument_list|,
operator|&
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|cleanup_message
goto|;
if|if
condition|(
name|tsigkey
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_message_settsigkey
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|tsigkey
argument_list|)
expr_stmt|;
name|dns_tsigkey_detach
argument_list|(
operator|&
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
block|}
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|result
operator|=
name|dns_message_renderend
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|cleanup_cctx
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|dns_message_gettsigkey
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dns_tsigkey_attach
argument_list|(
name|dns_message_gettsigkey
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|)
argument_list|,
operator|&
name|query
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_getquerytsig
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|query
operator|->
name|tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
block|}
comment|/* 	 * If using TCP, write the length of the message at the beginning 	 * of the buffer. 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_buffer_usedregion
argument_list|(
operator|&
name|query
operator|->
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're now done with the query message. 	 */
name|dns_message_reset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|)
expr_stmt|;
name|socket
operator|=
name|dns_dispatch_getsocket
argument_list|(
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
comment|/* 	 * Send the query! 	 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|==
literal|0
condition|)
name|address
operator|=
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH  Make sure we don't send to ourselves!  We should probably 	 *	   prune out these addresses when we get them from the ADB. 	 */
name|result
operator|=
name|isc_socket_sendto
argument_list|(
name|socket
argument_list|,
operator|&
name|r
argument_list|,
name|task
argument_list|,
name|resquery_senddone
argument_list|,
name|query
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_message
goto|;
name|query
operator|->
name|sends
operator|++
expr_stmt|;
name|QTRACE
argument_list|(
literal|"sent"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_message
label|:
if|if
condition|(
name|cleanup_cctx
condition|)
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|dns_message_reset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the dispatcher from listening. 	 */
name|dns_dispatch_removeresponse
argument_list|(
operator|&
name|query
operator|->
name|dispentry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cleanup_temps
label|:
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qrdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|fctx
operator|->
name|qmessage
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_connected
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|retry
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|attrs
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_CONNECT
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_QUERY
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"connected"
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH 	 * 	 * Currently we don't wait for the connect event before retrying 	 * a query.  This means that if we get really behind, we may end 	 * up doing extra work! 	 */
name|query
operator|->
name|connects
operator|--
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
if|if
condition|(
name|RESQUERY_CANCELED
argument_list|(
name|query
argument_list|)
condition|)
block|{
comment|/* 		 * This query was canceled while the connect() was in 		 * progress. 		 */
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|resquery_destroy
argument_list|(
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|sevent
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
comment|/* 			 * We are connected.  Create a dispatcher and 			 * send the query. 			 */
name|attrs
operator|=
literal|0
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_TCP
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_PRIVATE
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_CONNECTED
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|)
operator|==
name|AF_INET
condition|)
name|attrs
operator||=
name|DNS_DISPATCHATTR_IPV4
expr_stmt|;
else|else
name|attrs
operator||=
name|DNS_DISPATCHATTR_IPV6
expr_stmt|;
name|attrs
operator||=
name|DNS_DISPATCHATTR_MAKEQUERY
expr_stmt|;
name|result
operator|=
name|dns_dispatch_createtcp
argument_list|(
name|query
operator|->
name|dispatchmgr
argument_list|,
name|query
operator|->
name|tcpsocket
argument_list|,
name|query
operator|->
name|fctx
operator|->
name|res
operator|->
name|taskmgr
argument_list|,
literal|4096
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|attrs
argument_list|,
operator|&
name|query
operator|->
name|dispatch
argument_list|)
expr_stmt|;
comment|/* 			 * Regardless of whether dns_dispatch_create() 			 * succeeded or not, we don't need our reference 			 * to the socket anymore. 			 */
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|resquery_send
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ISC_R_NETUNREACH
case|:
case|case
name|ISC_R_HOSTUNREACH
case|:
case|case
name|ISC_R_CONNREFUSED
case|:
case|case
name|ISC_R_NOPERM
case|:
case|case
name|ISC_R_ADDRNOTAVAIL
case|:
case|case
name|ISC_R_CONNECTIONRESET
case|:
comment|/* 			 * No route to remote. 			 */
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|retry
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
default|default:
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
condition|)
block|{
comment|/* 		 * Behave as if the idle timer has expired.  For TCP 		 * connections this may not actually reflect the latest timer. 		 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_finddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|want_try
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|want_done
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|find
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|fctx
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"finddone"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|pending
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|pending
operator|--
expr_stmt|;
if|if
condition|(
name|ADDRWAIT
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 		 * The fetch is waiting for a name to be found. 		 */
name|INSIST
argument_list|(
operator|!
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_ADBMOREADDRESSES
condition|)
name|want_try
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fctx
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We've got nothing else to wait for and don't 			 * know the answer.  There's nothing to do but 			 * fail the fctx. 			 */
name|want_done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
operator|&&
name|fctx
operator|->
name|pending
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|nqueries
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
block|{
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we had to wait until we had the lock before 		 * looking at fctx->references. 		 */
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
name|bucket_empty
operator|=
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_try
condition|)
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_done
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|ISC_R_FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|bad_server
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|bad
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
name|sa
argument_list|,
name|address
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|mark_bad
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|curr
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|isc_boolean_t
name|all_bad
init|=
name|ISC_TRUE
decl_stmt|;
comment|/* 	 * Mark all known bad servers, so we don't try to talk to them 	 * again. 	 */
comment|/* 	 * Mark any bad nameservers. 	 */
for|for
control|(
name|curr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
control|)
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
comment|/* 	 * Mark any bad forwarders. 	 */
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Mark any bad alternates. 	 */
for|for
control|(
name|curr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
control|)
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|)
condition|)
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
else|else
name|all_bad
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
return|return
operator|(
name|all_bad
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_bad
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_result_t
name|reason
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|typebuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|code
index|[
literal|64
index|]
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep1
decl_stmt|,
modifier|*
name|sep2
decl_stmt|;
if|if
condition|(
name|bad_server
argument_list|(
name|fctx
argument_list|,
name|address
argument_list|)
condition|)
block|{
comment|/* 		 * We already know this server is bad. 		 */
return|return;
block|}
name|FCTXTRACE
argument_list|(
literal|"add_bad"
argument_list|)
expr_stmt|;
name|sa
operator|=
name|isc_mem_get
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return;
operator|*
name|sa
operator|=
operator|*
name|address
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|fctx
operator|->
name|bad
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|DNS_R_LAME
condition|)
comment|/* already logged */
return|return;
if|if
condition|(
name|reason
operator|==
name|DNS_R_UNEXPECTEDRCODE
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dns_rcode_totext
argument_list|(
name|fctx
operator|->
name|rmessage
operator|->
name|rcode
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|code
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sep1
operator|=
literal|"("
expr_stmt|;
name|sep2
operator|=
literal|") "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|DNS_R_UNEXPECTEDOPCODE
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dns_opcode_totext
argument_list|(
operator|(
name|dns_opcode_t
operator|)
name|fctx
operator|->
name|rmessage
operator|->
name|opcode
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|code
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sep1
operator|=
literal|"("
expr_stmt|;
name|sep2
operator|=
literal|") "
expr_stmt|;
block|}
else|else
block|{
name|code
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sep1
operator|=
literal|""
expr_stmt|;
name|sep2
operator|=
literal|""
expr_stmt|;
block|}
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|fctx
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_LAME_SERVERS
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s %s%s%sresolving '%s/%s/%s': %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|reason
argument_list|)
argument_list|,
name|sep1
argument_list|,
name|code
argument_list|,
name|sep2
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_adbfind
parameter_list|(
name|dns_adbfind_t
modifier|*
name|find
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|best
decl_stmt|,
modifier|*
name|curr
decl_stmt|;
name|dns_adbaddrinfolist_t
name|sorted
decl_stmt|;
comment|/* 	 * Lame N^2 bubble sort. 	 */
name|ISC_LIST_INIT
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|find
operator|->
name|list
argument_list|)
condition|)
block|{
name|best
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|srtt
operator|<
name|best
operator|->
name|srtt
condition|)
name|best
operator|=
name|curr
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
name|find
operator|->
name|list
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|sorted
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|find
operator|->
name|list
operator|=
name|sorted
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_finds
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|best
decl_stmt|,
modifier|*
name|curr
decl_stmt|;
name|dns_adbfindlist_t
name|sorted
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|,
modifier|*
name|bestaddrinfo
decl_stmt|;
comment|/* 	 * Lame N^2 bubble sort. 	 */
name|ISC_LIST_INIT
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
condition|)
block|{
name|best
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
name|bestaddrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|best
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|bestaddrinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|addrinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|->
name|srtt
operator|<
name|bestaddrinfo
operator|->
name|srtt
condition|)
block|{
name|best
operator|=
name|curr
expr_stmt|;
name|bestaddrinfo
operator|=
name|addrinfo
expr_stmt|;
block|}
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|finds
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|sorted
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|finds
operator|=
name|sorted
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
condition|)
block|{
name|best
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
name|bestaddrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|best
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|bestaddrinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|curr
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|addrinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|->
name|srtt
operator|<
name|bestaddrinfo
operator|->
name|srtt
condition|)
block|{
name|best
operator|=
name|curr
expr_stmt|;
name|bestaddrinfo
operator|=
name|addrinfo
expr_stmt|;
block|}
name|curr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|curr
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|sorted
argument_list|,
name|best
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|fctx
operator|->
name|altfinds
operator|=
name|sorted
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|findname
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|in_port_t
name|port
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
modifier|*
name|pruned
parameter_list|,
name|isc_boolean_t
modifier|*
name|need_alternate
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|ai
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|unshared
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|unshared
operator|=
name|ISC_TF
argument_list|(
operator|(
name|fctx
operator|->
name|options
operator||
name|DNS_FETCHOPT_UNSHARED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this name is a subdomain of the query domain, tell 	 * the ADB to start looking using zone/hint data. This keeps us 	 * from getting stuck if the nameserver is beneath the zone cut 	 * and we don't know its address (e.g. because the A record has 	 * expired). 	 */
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
name|options
operator||=
name|DNS_ADBFIND_STARTATZONE
expr_stmt|;
name|options
operator||=
name|DNS_ADBFIND_GLUEOK
expr_stmt|;
name|options
operator||=
name|DNS_ADBFIND_HINTOK
expr_stmt|;
comment|/* 	 * See what we know about this address. 	 */
name|find
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_adb_createfind
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
argument_list|,
name|fctx_finddone
argument_list|,
name|fctx
argument_list|,
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|options
argument_list|,
name|now
argument_list|,
name|NULL
argument_list|,
name|res
operator|->
name|view
operator|->
name|dstport
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_ALIAS
condition|)
block|{
comment|/* 			 * XXXRTH  Follow the CNAME/DNAME chain? 			 */
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|find
operator|->
name|list
argument_list|)
condition|)
block|{
comment|/* 		 * We have at least some of the addresses for the 		 * name. 		 */
name|INSIST
argument_list|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_WANTEVENT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sort_adbfind
argument_list|(
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|0
operator|||
name|port
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|ai
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ai
argument_list|,
name|publink
argument_list|)
control|)
block|{
name|ai
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|port
operator|!=
literal|0
condition|)
name|isc_sockaddr_setport
argument_list|(
operator|&
name|ai
operator|->
name|sockaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|FCTX_ADDRINFO_FORWARDER
operator|)
operator|!=
literal|0
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|finds
argument_list|,
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't know any of the addresses for this 		 * name. 		 */
if|if
condition|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_WANTEVENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We're looking for them and will get an 			 * event about it later. 			 */
name|fctx
operator|->
name|pending
operator|++
expr_stmt|;
comment|/* 			 * Bootstrap. 			 */
if|if
condition|(
name|need_alternate
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|need_alternate
operator|&&
name|unshared
operator|&&
operator|(
operator|(
name|res
operator|->
name|dispatchv4
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v6
operator|!=
name|DNS_R_NXDOMAIN
operator|)
operator|||
operator|(
name|res
operator|->
name|dispatchv6
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v4
operator|!=
name|DNS_R_NXDOMAIN
operator|)
operator|)
condition|)
operator|*
name|need_alternate
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we know there are no addresses for 			 * the family we are using then try to add 			 * an alternative server. 			 */
if|if
condition|(
name|need_alternate
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|need_alternate
operator|&&
operator|(
operator|(
name|res
operator|->
name|dispatchv4
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v6
operator|==
name|DNS_R_NXRRSET
operator|)
operator|||
operator|(
name|res
operator|->
name|dispatchv6
operator|==
name|NULL
operator|&&
name|find
operator|->
name|result_v4
operator|==
name|DNS_R_NXRRSET
operator|)
operator|)
condition|)
operator|*
name|need_alternate
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * And ADB isn't going to send us any events 			 * either.  This find loses. 			 */
if|if
condition|(
operator|(
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_LAMEPRUNED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * The ADB pruned lame servers for 				 * this name.  Remember that in case 				 * we get desperate later on. 				 */
operator|*
name|pruned
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|dns_adb_destroyfind
argument_list|(
operator|&
name|find
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fctx_getaddresses
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|unsigned
name|int
name|stdoptions
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|ai
decl_stmt|;
name|isc_boolean_t
name|pruned
decl_stmt|,
name|all_bad
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|isc_boolean_t
name|need_alternate
init|=
name|ISC_FALSE
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"getaddresses"
argument_list|)
expr_stmt|;
comment|/* 	 * Don't pound on remote servers.  (Failsafe!) 	 */
name|fctx
operator|->
name|restarts
operator|++
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|restarts
operator|>
literal|10
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"too many restarts"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|pruned
operator|=
name|ISC_FALSE
expr_stmt|;
name|stdoptions
operator|=
literal|0
expr_stmt|;
comment|/* Keep compiler happy. */
comment|/* 	 * Forwarders. 	 */
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this fctx has forwarders, use them; otherwise use any 	 * selective forwarders specified in the view; otherwise use the 	 * resolver's forwarders (if any). 	 */
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
block|{
name|dns_forwarders_t
modifier|*
name|forwarders
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
operator|&
name|fctx
operator|->
name|name
decl_stmt|;
name|dns_name_t
name|suffix
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
comment|/* 		 * DS records are found in the parent server. 		 * Strip label to get the correct forwarder (if any). 		 */
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|&&
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|>
literal|1
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|suffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|suffix
argument_list|)
expr_stmt|;
name|name
operator|=
operator|&
name|suffix
expr_stmt|;
block|}
name|result
operator|=
name|dns_fwdtable_find
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|fwdtable
argument_list|,
name|name
argument_list|,
operator|&
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|forwarders
operator|->
name|addrs
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|fwdpolicy
operator|=
name|forwarders
operator|->
name|fwdpolicy
expr_stmt|;
block|}
block|}
while|while
condition|(
name|sa
operator|!=
name|NULL
condition|)
block|{
name|ai
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_adb_findaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|sa
argument_list|,
operator|&
name|ai
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXMLG */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|cur
decl_stmt|;
name|ai
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_FORWARDER
expr_stmt|;
name|cur
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|NULL
operator|&&
name|cur
operator|->
name|srtt
operator|<
name|ai
operator|->
name|srtt
condition|)
name|cur
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|cur
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
name|ISC_LIST_INSERTBEFORE
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|,
name|cur
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
name|sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the forwarding policy is "only", we don't need the addresses 	 * of the nameservers. 	 */
if|if
condition|(
name|fctx
operator|->
name|fwdpolicy
operator|==
name|dns_fwdpolicy_only
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Normal nameservers. 	 */
name|stdoptions
operator|=
name|DNS_ADBFIND_WANTEVENT
operator||
name|DNS_ADBFIND_EMPTYEVENT
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|restarts
operator|==
literal|1
condition|)
block|{
comment|/* 		 * To avoid sending out a flood of queries likely to 		 * result in NXRRSET, we suppress fetches for address 		 * families we don't have the first time through, 		 * provided that we have addresses in some family we 		 * can use. 		 * 		 * We don't want to set this option all the time, since 		 * if fctx->restarts> 1, we've clearly been having trouble 		 * with the addresses we had, so getting more could help. 		 */
name|stdoptions
operator||=
name|DNS_ADBFIND_AVOIDFETCHES
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|dispatchv4
operator|!=
name|NULL
condition|)
name|stdoptions
operator||=
name|DNS_ADBFIND_INET
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatchv6
operator|!=
name|NULL
condition|)
name|stdoptions
operator||=
name|DNS_ADBFIND_INET6
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|restart
label|:
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 		 * Extract the name from the NS record. 		 */
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|findname
argument_list|(
name|fctx
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
literal|0
argument_list|,
name|stdoptions
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
operator|&
name|pruned
argument_list|,
operator|&
name|need_alternate
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Do we need to use 6 to 4? 	 */
if|if
condition|(
name|need_alternate
condition|)
block|{
name|int
name|family
decl_stmt|;
name|alternate_t
modifier|*
name|a
decl_stmt|;
name|family
operator|=
operator|(
name|res
operator|->
name|dispatchv6
operator|!=
name|NULL
operator|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
for|for
control|(
name|a
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|alternates
argument_list|)
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|a
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|a
operator|->
name|isaddress
condition|)
block|{
name|findname
argument_list|(
name|fctx
argument_list|,
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|,
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|port
argument_list|,
name|stdoptions
argument_list|,
name|FCTX_ADDRINFO_FORWARDER
argument_list|,
name|now
argument_list|,
operator|&
name|pruned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|a
operator|->
name|_u
operator|.
name|addr
argument_list|)
operator|!=
name|family
condition|)
continue|continue;
name|ai
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_adb_findaddrinfo
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
operator|&
name|a
operator|->
name|_u
operator|.
name|addr
argument_list|,
operator|&
name|ai
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|cur
decl_stmt|;
name|ai
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_FORWARDER
expr_stmt|;
name|cur
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|NULL
operator|&&
name|cur
operator|->
name|srtt
operator|<
name|ai
operator|->
name|srtt
condition|)
name|cur
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|cur
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
name|ISC_LIST_INSERTBEFORE
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|,
name|cur
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|,
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
comment|/* 	 * Mark all known bad servers. 	 */
name|all_bad
operator|=
name|mark_bad
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* 	 * How are we doing? 	 */
if|if
condition|(
name|all_bad
condition|)
block|{
comment|/* 		 * We've got no addresses. 		 */
if|if
condition|(
name|fctx
operator|->
name|pending
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We're fetching the addresses, but don't have any 			 * yet.   Tell the caller to wait for an answer. 			 */
name|result
operator|=
name|DNS_R_WAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pruned
condition|)
block|{
comment|/* 			 * Some addresses were removed by lame pruning. 			 * Turn pruning off and try again. 			 */
name|FCTXTRACE
argument_list|(
literal|"restarting with returnlame"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|stdoptions
operator|&
name|DNS_ADBFIND_RETURNLAME
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|stdoptions
operator||=
name|DNS_ADBFIND_RETURNLAME
expr_stmt|;
name|pruned
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
else|else
block|{
comment|/* 			 * We've lost completely.  We don't know any 			 * addresses, and the ADB has told us it can't get 			 * them. 			 */
name|FCTXTRACE
argument_list|(
literal|"no addresses"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We've found some addresses.  We might still be looking 		 * for more addresses. 		 */
name|sort_finds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|possibly_mark
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addr
parameter_list|)
block|{
name|isc_netaddr_t
name|na
decl_stmt|;
name|char
name|buf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|isc_boolean_t
name|aborted
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|bogus
decl_stmt|;
name|dns_acl_t
modifier|*
name|blackhole
decl_stmt|;
name|isc_netaddr_t
name|ipaddr
decl_stmt|;
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|sa
operator|=
operator|&
name|addr
operator|->
name|sockaddr
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|ipaddr
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|blackhole
operator|=
name|dns_dispatchmgr_getblackhole
argument_list|(
name|res
operator|->
name|dispatchmgr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|res
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|ipaddr
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|blackhole
operator|!=
name|NULL
condition|)
block|{
name|int
name|match
decl_stmt|;
if|if
condition|(
name|dns_acl_match
argument_list|(
operator|&
name|ipaddr
argument_list|,
name|NULL
argument_list|,
name|blackhole
argument_list|,
operator|&
name|res
operator|->
name|view
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
name|aborted
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|!=
name|NULL
operator|&&
name|dns_peer_getbogus
argument_list|(
name|peer
argument_list|,
operator|&
name|bogus
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|bogus
condition|)
name|aborted
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|aborted
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring blackholed / bogus server: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isc_sockaddr_ismulticast
argument_list|(
name|sa
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring multicast address: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isc_sockaddr_isexperimental
argument_list|(
name|sa
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring experimental address: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET6
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa
operator|->
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring IPv6 mapped IPV4 address: "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_V4COMPAT
argument_list|(
operator|&
name|sa
operator|->
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|addr
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|msg
operator|=
literal|"ignoring IPv6 compatibility IPV4 address: "
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
return|return;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|na
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|FCTXTRACE2
argument_list|(
name|msg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_adbaddrinfo_t
modifier|*
name|fctx_nextaddress
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|faddrinfo
decl_stmt|;
comment|/* 	 * Return the next untried address, if any. 	 */
comment|/* 	 * Find the first unmarked forwarder (if any). 	 */
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
block|{
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|fctx
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|addrinfo
operator|)
return|;
block|}
block|}
comment|/* 	 * No forwarders.  Move to the next find. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_TRIEDFIND
expr_stmt|;
name|find
operator|=
name|fctx
operator|->
name|find
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
else|else
block|{
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the first unmarked addrinfo. 	 */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|find
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|find
expr_stmt|;
do|do
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
block|{
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|addrinfo
operator|!=
name|NULL
condition|)
break|break;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|find
operator|!=
name|start
condition|)
do|;
block|}
name|fctx
operator|->
name|find
operator|=
name|find
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|!=
name|NULL
condition|)
return|return
operator|(
name|addrinfo
operator|)
return|;
comment|/* 	 * No nameservers left.  Try alternates. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_TRIEDALT
expr_stmt|;
name|find
operator|=
name|fctx
operator|->
name|altfind
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
else|else
block|{
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the first unmarked addrinfo. 	 */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|find
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|find
expr_stmt|;
do|do
block|{
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
block|{
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|addrinfo
operator|!=
name|NULL
condition|)
break|break;
name|find
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|find
argument_list|,
name|publink
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
name|find
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|find
operator|!=
name|start
condition|)
do|;
block|}
name|faddrinfo
operator|=
name|addrinfo
expr_stmt|;
comment|/* 	 * See if we have a better alternate server by address. 	 */
for|for
control|(
name|addrinfo
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
init|;
name|addrinfo
operator|!=
name|NULL
condition|;
name|addrinfo
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|addrinfo
argument_list|,
name|publink
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
condition|)
continue|continue;
name|possibly_mark
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNMARKED
argument_list|(
name|addrinfo
argument_list|)
operator|&&
operator|(
name|faddrinfo
operator|==
name|NULL
operator|||
name|addrinfo
operator|->
name|srtt
operator|<
name|faddrinfo
operator|->
name|srtt
operator|)
condition|)
block|{
if|if
condition|(
name|faddrinfo
operator|!=
name|NULL
condition|)
name|faddrinfo
operator|->
name|flags
operator|&=
operator|~
name|FCTX_ADDRINFO_MARK
expr_stmt|;
name|addrinfo
operator|->
name|flags
operator||=
name|FCTX_ADDRINFO_MARK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|addrinfo
operator|==
name|NULL
condition|)
block|{
name|addrinfo
operator|=
name|faddrinfo
expr_stmt|;
name|fctx
operator|->
name|altfind
operator|=
name|find
expr_stmt|;
block|}
return|return
operator|(
name|addrinfo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_try
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"try"
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ADDRWAIT
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|fctx_nextaddress
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrinfo
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We have no more addresses.  Start over. 		 */
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_getaddresses
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_WAIT
condition|)
block|{
comment|/* 			 * Sleep waiting for addresses. 			 */
name|FCTXTRACE
argument_list|(
literal|"addrwait"
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Something bad happened. 			 */
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|addrinfo
operator|=
name|fctx_nextaddress
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* 		 * While we may have addresses from the ADB, they 		 * might be bad ones.  In this case, return SERVFAIL. 		 */
if|if
condition|(
name|addrinfo
operator|==
name|NULL
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|result
operator|=
name|fctx_query
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|fctx
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|fctx_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|sa
decl_stmt|,
modifier|*
name|next_sa
decl_stmt|;
comment|/* 	 * Caller must be holding the bucket lock. 	 */
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_init
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fctx
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"destroy"
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|,
name|fctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Free bad. 	 */
for|for
control|(
name|sa
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|bad
argument_list|)
init|;
name|sa
operator|!=
name|NULL
condition|;
name|sa
operator|=
name|next_sa
control|)
block|{
name|next_sa
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|bad
argument_list|,
name|sa
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_timer_detach
argument_list|(
operator|&
name|fctx
operator|->
name|timer
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|rmessage
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|0
condition|)
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|fctx
operator|->
name|cache
argument_list|)
expr_stmt|;
name|dns_adb_detach
argument_list|(
operator|&
name|fctx
operator|->
name|adb
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|res
operator|->
name|nfctx
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|exiting
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch event handlers.  */
end_comment

begin_function
specifier|static
name|void
name|fctx_timeout
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_LIFE
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|ISC_R_TIMEDOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_result_t
name|result
decl_stmt|;
name|fctx
operator|->
name|timeouts
operator|++
expr_stmt|;
comment|/* 		 * We could cancel the running queries here, or we could let 		 * them keep going.  Right now we choose the latter... 		 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
comment|/* 		 * Our timer has triggered.  Reestablish the fctx lifetime 		 * timer. 		 */
name|result
operator|=
name|fctx_starttimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
comment|/* 			 * Keep trying. 			 */
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_shutdown
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|cevent
decl_stmt|;
comment|/* 	 * Start the shutdown process for fctx, if it isn't already underway. 	 */
name|FCTXTRACE
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
comment|/* 	 * The caller must be holding the appropriate bucket lock. 	 */
if|if
condition|(
name|fctx
operator|->
name|want_shutdown
condition|)
return|return;
name|fctx
operator|->
name|want_shutdown
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Unless we're still initializing (in which case the 	 * control event is still outstanding), we need to post 	 * the control event to tell the fetch we want it to 	 * exit. 	 */
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_init
condition|)
block|{
name|cevent
operator|=
operator|&
name|fctx
operator|->
name|control_event
expr_stmt|;
name|isc_task_send
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
argument_list|,
operator|&
name|cevent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_doshutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|dns_validator_t
modifier|*
name|validator
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"doshutdown"
argument_list|)
expr_stmt|;
comment|/* 	 * An fctx that is shutting down is no longer in ADDRWAIT mode. 	 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_ADDRWAIT
expr_stmt|;
comment|/* 	 * Cancel all pending validators.  Note that this must be done 	 * without the bucket lock held, since that could cause deadlock. 	 */
name|validator
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
expr_stmt|;
while|while
condition|(
name|validator
operator|!=
name|NULL
condition|)
block|{
name|dns_validator_cancel
argument_list|(
name|validator
argument_list|)
expr_stmt|;
name|validator
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fctx
operator|->
name|nsfetch
operator|!=
name|NULL
condition|)
name|dns_resolver_cancelfetch
argument_list|(
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
comment|/* 	 * Shut down anything that is still running on behalf of this 	 * fetch.  To avoid deadlock with the ADB, we must do this 	 * before we lock the bucket lock. 	 */
name|fctx_stopeverything
argument_list|(
name|fctx
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_SHUTTINGDOWN
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_active
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|want_shutdown
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_done
condition|)
block|{
name|fctx
operator|->
name|state
operator|=
name|fetchstate_done
expr_stmt|;
name|fctx_sendevents
argument_list|(
name|fctx
argument_list|,
name|ISC_R_CANCELED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|pending
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|nqueries
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
name|bucket_empty
operator|=
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fctx_start
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|,
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|state
operator|==
name|fetchstate_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|want_shutdown
condition|)
block|{
comment|/* 		 * We haven't started this fctx yet, and we've been requested 		 * to shut it down. 		 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_SHUTTINGDOWN
expr_stmt|;
name|fctx
operator|->
name|state
operator|=
name|fetchstate_done
expr_stmt|;
name|fctx_sendevents
argument_list|(
name|fctx
argument_list|,
name|ISC_R_CANCELED
argument_list|)
expr_stmt|;
comment|/* 		 * Since we haven't started, we INSIST that we have no 		 * pending ADB finds and no pending validations. 		 */
name|INSIST
argument_list|(
name|fctx
operator|->
name|pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|nqueries
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
block|{
comment|/* 			 * It's now safe to destroy this fctx. 			 */
name|bucket_empty
operator|=
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Normal fctx startup. 		 */
name|fctx
operator|->
name|state
operator|=
name|fetchstate_active
expr_stmt|;
comment|/* 		 * Reset the control event for later use in shutting down 		 * the fctx. 		 */
name|ISC_EVENT_INIT
argument_list|(
name|event
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_FETCHCONTROL
argument_list|,
name|fctx_doshutdown
argument_list|,
name|fctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 		 * All is well.  Start working on the fetch. 		 */
name|result
operator|=
name|fctx_starttimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch Creation, Joining, and Cancelation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|fctx_join
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_fetch_t
modifier|*
name|fetch
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|clone
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"join"
argument_list|)
expr_stmt|;
comment|/* 	 * We store the task we're going to send this event to in the 	 * sender field.  We'll make the fetch the sender when we actually 	 * send the event. 	 */
name|clone
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|clone
argument_list|)
expr_stmt|;
name|event
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
name|clone
argument_list|,
name|DNS_EVENT_FETCHDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
name|isc_task_detach
argument_list|(
operator|&
name|clone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|event
operator|->
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
name|event
operator|->
name|qtype
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
name|event
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|event
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|event
operator|->
name|rdataset
operator|=
name|rdataset
expr_stmt|;
name|event
operator|->
name|sigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|event
operator|->
name|fetch
operator|=
name|fetch
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that we can store the sigrdataset in the 	 * first event if it is needed by any of the events. 	 */
if|if
condition|(
name|event
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
name|ISC_LIST_PREPEND
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|++
expr_stmt|;
name|fetch
operator|->
name|magic
operator|=
name|DNS_FETCH_MAGIC
expr_stmt|;
name|fetch
operator|->
name|private
operator|=
name|fctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|fctx_create
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|unsigned
name|int
name|bucketnum
parameter_list|,
name|fetchctx_t
modifier|*
modifier|*
name|fctxp
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|iresult
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|unsigned
name|int
name|findoptions
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
operator|+
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_t
name|suffix
decl_stmt|;
comment|/* 	 * Caller must be holding the lock for bucket number 'bucketnum'. 	 */
name|REQUIRE
argument_list|(
name|fctxp
operator|!=
name|NULL
operator|&&
operator|*
name|fctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|isc_mem_get
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|/* checked */
name|strcat
argument_list|(
name|buf
argument_list|,
name|typebuf
argument_list|)
expr_stmt|;
comment|/* checked */
name|fctx
operator|->
name|info
operator|=
name|isc_mem_strdup
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|info
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_fetch
goto|;
block|}
name|FCTXTRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|name
argument_list|,
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_info
goto|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|fctx
operator|->
name|options
operator|=
name|options
expr_stmt|;
comment|/* 	 * Note!  We do not attach to the task.  We are relying on the 	 * resolver to ensure that this task doesn't go away while we are 	 * using it. 	 */
name|fctx
operator|->
name|res
operator|=
name|res
expr_stmt|;
name|fctx
operator|->
name|references
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|bucketnum
operator|=
name|bucketnum
expr_stmt|;
name|fctx
operator|->
name|state
operator|=
name|fetchstate_init
expr_stmt|;
name|fctx
operator|->
name|want_shutdown
operator|=
name|ISC_FALSE
expr_stmt|;
name|fctx
operator|->
name|cloned
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|queries
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|finds
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|altfinds
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|forwaddrs
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|altaddrs
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|forwarders
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|fwdpolicy
operator|=
name|dns_fwdpolicy_none
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|bad
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|altfind
operator|=
name|NULL
expr_stmt|;
name|fctx
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|restarts
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|timeouts
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|fctx
operator|->
name|nqueries
operator|=
literal|0
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|nsfetch
operator|=
name|NULL
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|fctx
operator|->
name|nsrrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
block|{
name|dns_forwarders_t
modifier|*
name|forwarders
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
comment|/* 		 * DS records are found in the parent server. 		 * Strip label to get the correct forwarder (if any). 		 */
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|&&
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|>
literal|1
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|suffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|suffix
argument_list|)
expr_stmt|;
name|name
operator|=
operator|&
name|suffix
expr_stmt|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|domain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_fwdtable_find2
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|fwdtable
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
operator|&
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|fctx
operator|->
name|fwdpolicy
operator|=
name|forwarders
operator|->
name|fwdpolicy
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|fwdpolicy
operator|!=
name|dns_fwdpolicy_only
condition|)
block|{
comment|/* 			 * The caller didn't supply a query domain and 			 * nameservers, and we're not in forward-only mode, 			 * so find the best nameservers to use. 			 */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|type
argument_list|)
condition|)
name|findoptions
operator||=
name|DNS_DBFIND_NOEXACT
expr_stmt|;
name|result
operator|=
name|dns_view_findzonecut
argument_list|(
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|domain
argument_list|,
literal|0
argument_list|,
name|findoptions
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_name
goto|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_name
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * We're in forward-only mode.  Set the query domain. 			 */
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_name
goto|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|dns_name_dup
argument_list|(
name|domain
argument_list|,
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_name
goto|;
name|dns_rdataset_clone
argument_list|(
name|nameservers
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|dns_name_issubdomain
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|qmessage
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|,
operator|&
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_domain
goto|;
name|fctx
operator|->
name|rmessage
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|fctx
operator|->
name|rmessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_qmessage
goto|;
comment|/* 	 * Compute an expiration time for the entire fetch. 	 */
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXRTH constant */
name|iresult
operator|=
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|fctx
operator|->
name|expires
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|iresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_time_nowplusinterval: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|iresult
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_rmessage
goto|;
block|}
comment|/* 	 * Default retry interval initialization.  We set the interval now 	 * mostly so it won't be uninitialized.  It will be set to the 	 * correct value before a query is issued. 	 */
name|isc_interval_set
argument_list|(
operator|&
name|fctx
operator|->
name|interval
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Create an inactive timer.  It will be made active when the fetch 	 * is actually started. 	 */
name|fctx
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|iresult
operator|=
name|isc_timer_create
argument_list|(
name|res
operator|->
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|task
argument_list|,
name|fctx_timeout
argument_list|,
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|iresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timer_create: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|iresult
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_rmessage
goto|;
block|}
comment|/* 	 * Attach to the view's cache and adb. 	 */
name|fctx
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|res
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|fctx
operator|->
name|cache
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|adb
operator|=
name|NULL
expr_stmt|;
name|dns_adb_attach
argument_list|(
name|res
operator|->
name|view
operator|->
name|adb
argument_list|,
operator|&
name|fctx
operator|->
name|adb
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|magic
operator|=
name|FCTX_MAGIC
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|,
name|fctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|res
operator|->
name|nfctx
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
operator|*
name|fctxp
operator|=
name|fctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_rmessage
label|:
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|rmessage
argument_list|)
expr_stmt|;
name|cleanup_qmessage
label|:
name|dns_message_destroy
argument_list|(
operator|&
name|fctx
operator|->
name|qmessage
argument_list|)
expr_stmt|;
name|cleanup_domain
label|:
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|0
condition|)
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|cleanup_name
label|:
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|cleanup_info
label|:
name|isc_mem_free
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fctx
operator|->
name|info
argument_list|)
expr_stmt|;
name|cleanup_fetch
label|:
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle Responses  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|is_lame
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_message_t
modifier|*
name|message
init|=
name|fctx
operator|->
name|rmessage
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
operator|&&
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_nxdomain
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_namereln_t
name|namereln
decl_stmt|;
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_ns
condition|)
continue|continue;
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|namereln
operator|==
name|dns_namereln_equal
operator|&&
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|namereln
operator|==
name|dns_namereln_subdomain
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_lame
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_LAME_SERVERS
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"lame server resolving '%s' (in '%s'?): %s"
argument_list|,
name|namebuf
argument_list|,
name|domainbuf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|same_question
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|fctx
operator|->
name|rmessage
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
comment|/* 	 * Caller must be holding the fctx lock. 	 */
comment|/* 	 * XXXRTH  Currently we support only one question. 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_QUESTION
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|rdataset
operator|->
name|type
operator|||
name|fctx
operator|->
name|res
operator|->
name|rdclass
operator|!=
name|rdataset
operator|->
name|rdclass
operator|||
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clone_results
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|hevent
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|hname
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"clone_results"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up any other events to have the same data as the first 	 * event. 	 * 	 * Caller must be holding the appropriate lock. 	 */
name|fctx
operator|->
name|cloned
operator|=
name|ISC_TRUE
expr_stmt|;
name|hevent
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|hevent
operator|==
name|NULL
condition|)
return|return;
name|hname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|hevent
operator|->
name|foundname
argument_list|)
expr_stmt|;
for|for
control|(
name|event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|hevent
argument_list|,
name|ev_link
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
control|)
block|{
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|hname
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|event
operator|->
name|result
operator|=
name|result
expr_stmt|;
else|else
name|event
operator|->
name|result
operator|=
name|hevent
operator|->
name|result
expr_stmt|;
name|dns_db_attach
argument_list|(
name|hevent
operator|->
name|db
argument_list|,
operator|&
name|event
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_attachnode
argument_list|(
name|hevent
operator|->
name|db
argument_list|,
name|hevent
operator|->
name|node
argument_list|,
operator|&
name|event
operator|->
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|hevent
operator|->
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|hevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_clone
argument_list|(
name|hevent
operator|->
name|rdataset
argument_list|,
name|event
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
operator|(
name|hevent
operator|->
name|sigrdataset
operator|==
name|NULL
operator|&&
name|event
operator|->
name|sigrdataset
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hevent
operator|->
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|hevent
operator|->
name|sigrdataset
argument_list|)
operator|&&
name|event
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
name|dns_rdataset_clone
argument_list|(
name|hevent
operator|->
name|sigrdataset
argument_list|,
name|event
operator|->
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CACHE
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CACHE) != 0)
end_define

begin_define
define|#
directive|define
name|ANSWER
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_ANSWER) != 0)
end_define

begin_define
define|#
directive|define
name|ANSWERSIG
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_ANSWERSIG) != 0)
end_define

begin_define
define|#
directive|define
name|EXTERNAL
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_EXTERNAL) != 0)
end_define

begin_define
define|#
directive|define
name|CHAINING
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CHAINING) != 0)
end_define

begin_define
define|#
directive|define
name|CHASE
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CHASE) != 0)
end_define

begin_define
define|#
directive|define
name|CHECKNAMES
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& DNS_RDATASETATTR_CHECKNAMES) != 0)
end_define

begin_comment
comment|/*  * Destroy '*fctx' if it is ready to be destroyed (i.e., if it has  * no references and is no longer waiting for any events).  If this  * was the last fctx in the resolver, destroy the resolver.  *  * Requires:  *	'*fctx' is shutting down.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_destroy
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
init|=
name|fctx
operator|->
name|res
decl_stmt|;
name|dns_validator_t
modifier|*
name|validator
decl_stmt|;
name|REQUIRE
argument_list|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|pending
operator|!=
literal|0
operator|||
name|fctx
operator|->
name|nqueries
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|validator
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
init|;
name|validator
operator|!=
name|NULL
condition|;
name|validator
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|validators
argument_list|,
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_validator_cancel
argument_list|(
name|validator
argument_list|)
expr_stmt|;
name|dns_validator_destroy
argument_list|(
operator|&
name|validator
argument_list|)
expr_stmt|;
block|}
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
name|bucket_empty
operator|=
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The validator has finished.  */
end_comment

begin_function
specifier|static
name|void
name|validated
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|eresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_validatorevent_t
modifier|*
name|vevent
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|hevent
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|ardataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|asigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|negative
decl_stmt|;
name|isc_boolean_t
name|chaining
decl_stmt|;
name|isc_boolean_t
name|sentresponse
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|nsnode
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_valarg_t
modifier|*
name|valarg
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|/* for now */
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_VALIDATORDONE
argument_list|)
expr_stmt|;
name|valarg
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|fctx
operator|=
name|valarg
operator|->
name|fctx
expr_stmt|;
name|addrinfo
operator|=
name|valarg
operator|->
name|addrinfo
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
name|vevent
operator|=
operator|(
name|dns_validatorevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"received validation completion event"
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|validators
argument_list|,
name|vevent
operator|->
name|validator
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the validator early so that we can 	 * destroy the fctx if necessary. 	 */
name|dns_validator_destroy
argument_list|(
operator|&
name|vevent
operator|->
name|validator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
name|valarg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|valarg
argument_list|)
argument_list|)
expr_stmt|;
name|negative
operator|=
name|ISC_TF
argument_list|(
name|vevent
operator|->
name|rdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sentresponse
operator|=
name|ISC_TF
argument_list|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If shutting down, ignore the results.  Check to see if we're 	 * done waiting for validator completions and ADB pending events; if 	 * so, destroy the fctx. 	 */
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
operator|&&
operator|!
name|sentresponse
condition|)
block|{
name|maybe_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
goto|goto
name|cleanup_event
goto|;
block|}
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If chaining, we need to make sure that the right result code is 	 * returned, and that the rdatasets are bound. 	 */
if|if
condition|(
name|vevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|negative
operator|&&
name|vevent
operator|->
name|rdataset
operator|!=
name|NULL
operator|&&
name|CHAINING
argument_list|(
name|vevent
operator|->
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|vevent
operator|->
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|eresult
operator|=
name|DNS_R_CNAME
expr_stmt|;
else|else
block|{
name|INSIST
argument_list|(
name|vevent
operator|->
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_DNAME
expr_stmt|;
block|}
name|chaining
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|chaining
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Either we're not shutting down, or we are shutting down but want 	 * to cache the result anyway (if this was a validation started by 	 * a query with cd set) 	 */
name|hevent
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|hevent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|negative
operator|&&
operator|!
name|chaining
operator|&&
operator|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_sig
operator|)
condition|)
block|{
comment|/* 			 * Don't bind rdatasets; the caller 			 * will iterate the node. 			 */
block|}
else|else
block|{
name|ardataset
operator|=
name|hevent
operator|->
name|rdataset
expr_stmt|;
name|asigrdataset
operator|=
name|hevent
operator|->
name|sigrdataset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vevent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"validation failed"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|vevent
operator|->
name|rdataset
operator|!=
name|NULL
condition|)
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|(
name|void
operator|)
name|dns_db_deleterdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|vevent
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_db_deleterdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|vevent
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|result
operator|=
name|vevent
operator|->
name|result
expr_stmt|;
name|add_bad
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
name|dns_validator_send
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sentresponse
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
else|else
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
return|return;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|dns_rdatatype_t
name|covers
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"nonexistence validation OK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|rmessage
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
name|covers
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|covers
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|noanswer_response
goto|;
comment|/* 		 * If we are asking for a SOA record set the cache time 		 * to zero to facilitate locating the containing zone of 		 * a arbitary zone. 		 */
name|ttl
operator|=
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|maxncachettl
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|covers
operator|==
name|dns_rdatatype_any
condition|)
name|ttl
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ncache_adderesult
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|ttl
argument_list|,
name|ardataset
argument_list|,
operator|&
name|eresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|noanswer_response
goto|;
goto|goto
name|answer_response
goto|;
block|}
name|FCTXTRACE
argument_list|(
literal|"validation OK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vevent
operator|->
name|proofs
index|[
name|DNS_VALIDATOR_NOQNAMEPROOF
index|]
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rdataset_addnoqname
argument_list|(
name|vevent
operator|->
name|rdataset
argument_list|,
name|vevent
operator|->
name|proofs
index|[
name|DNS_VALIDATOR_NOQNAMEPROOF
index|]
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vevent
operator|->
name|sigrdataset
operator|->
name|ttl
operator|=
name|vevent
operator|->
name|rdataset
operator|->
name|ttl
expr_stmt|;
block|}
comment|/* 	 * The data was already cached as pending data. 	 * Re-cache it as secure and bind the cached 	 * rdatasets to the first event on the fetch 	 * event list. 	 */
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|vevent
operator|->
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|noanswer_response
goto|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|vevent
operator|->
name|rdataset
argument_list|,
literal|0
argument_list|,
name|ardataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_UNCHANGED
condition|)
goto|goto
name|noanswer_response
goto|;
if|if
condition|(
name|vevent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|vevent
operator|->
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|asigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_UNCHANGED
condition|)
goto|goto
name|noanswer_response
goto|;
block|}
if|if
condition|(
name|sentresponse
condition|)
block|{
comment|/* 		 * If we only deferred the destroy because we wanted to cache 		 * the data, destroy now. 		 */
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
condition|)
name|maybe_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
goto|goto
name|cleanup_event
goto|;
block|}
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|negative
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_sig
argument_list|)
expr_stmt|;
comment|/* 		 * Don't send a response yet - we have 		 * more rdatasets that still need to 		 * be validated. 		 */
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|dns_validator_send
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_event
goto|;
block|}
name|answer_response
label|:
comment|/* 	 * Cache any NS/NSEC records that happened to be validated. 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_ns
operator|&&
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec
operator|)
operator|||
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
condition|)
continue|continue;
for|for
control|(
name|sigrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|sigrdataset
operator|!=
name|NULL
condition|;
name|sigrdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sigrdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|sigrdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
operator|||
name|sigrdataset
operator|->
name|covers
operator|!=
name|rdataset
operator|->
name|type
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
condition|)
continue|continue;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|nsnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|nsnode
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|nsnode
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|nsnode
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
comment|/* 	 * Respond with an answer, positive or negative, 	 * as opposed to an error.  'node' must be non-NULL. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_HAVEANSWER
expr_stmt|;
if|if
condition|(
name|hevent
operator|!=
name|NULL
condition|)
block|{
name|hevent
operator|->
name|result
operator|=
name|eresult
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_copy
argument_list|(
name|vevent
operator|->
name|name
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|hevent
operator|->
name|foundname
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|hevent
operator|->
name|db
argument_list|)
expr_stmt|;
name|hevent
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|clone_results
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
name|noanswer_response
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* Locks bucket. */
name|cleanup_event
label|:
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cache_name
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|addedrdataset
decl_stmt|,
modifier|*
name|ardataset
decl_stmt|,
modifier|*
name|asigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|valrdataset
init|=
name|NULL
decl_stmt|,
modifier|*
name|valsigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|anodep
decl_stmt|;
name|dns_db_t
modifier|*
modifier|*
name|adbp
decl_stmt|;
name|dns_name_t
modifier|*
name|aname
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|need_validation
decl_stmt|,
name|secure_domain
decl_stmt|,
name|have_answer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_boolean_t
name|fail
decl_stmt|;
name|unsigned
name|int
name|valoptions
init|=
literal|0
decl_stmt|;
comment|/* 	 * The appropriate bucket lock must be held. 	 */
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
name|secure_domain
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_answer
operator|=
name|ISC_FALSE
expr_stmt|;
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|task
operator|=
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
expr_stmt|;
comment|/* 	 * Is DNSSEC validation required for this name? 	 */
name|result
operator|=
name|dns_keytable_issecuredomain
argument_list|(
name|res
operator|->
name|view
operator|->
name|secroots
argument_list|,
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
operator|!
name|secure_domain
operator|&&
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
block|{
name|valoptions
operator|=
name|DNS_VALIDATOR_DLV
expr_stmt|;
name|secure_domain
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
condition|)
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
else|else
name|need_validation
operator|=
name|secure_domain
expr_stmt|;
name|adbp
operator|=
name|NULL
expr_stmt|;
name|aname
operator|=
name|NULL
expr_stmt|;
name|anodep
operator|=
name|NULL
expr_stmt|;
name|ardataset
operator|=
name|NULL
expr_stmt|;
name|asigrdataset
operator|=
name|NULL
expr_stmt|;
name|event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ANSWER
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|need_validation
condition|)
block|{
name|have_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|adbp
operator|=
operator|&
name|event
operator|->
name|db
expr_stmt|;
name|aname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|aname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|anodep
operator|=
operator|&
name|event
operator|->
name|node
expr_stmt|;
comment|/* 			 * If this is an ANY, SIG or RRSIG query, we're not 			 * going to return any rdatasets, unless we encountered 			 * a CNAME or DNAME as "the answer".  In this case, 			 * we're going to return DNS_R_CNAME or DNS_R_DNAME 			 * and we must set up the rdatasets. 			 */
if|if
condition|(
operator|(
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_sig
operator|)
operator|||
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_CHAINING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ardataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
name|asigrdataset
operator|=
name|event
operator|->
name|sigrdataset
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Find or create the cache node. 	 */
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Cache or validate each cacheable rdataset. 	 */
name|fail
operator|=
name|ISC_TF
argument_list|(
operator|(
name|fctx
operator|->
name|res
operator|->
name|options
operator|&
name|DNS_RESOLVER_CHECKNAMESFAIL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|rdataset
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|CHECKNAMES
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"check-names %s %s/%s/%s"
argument_list|,
name|fail
condition|?
literal|"failure"
else|:
literal|"warning"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
block|{
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_BADNAME
operator|)
return|;
continue|continue;
block|}
block|}
comment|/* 		 * Enforce the configure maximum cache TTL. 		 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|>
name|res
operator|->
name|view
operator|->
name|maxcachettl
condition|)
name|rdataset
operator|->
name|ttl
operator|=
name|res
operator|->
name|view
operator|->
name|maxcachettl
expr_stmt|;
comment|/* 		 * If this rrset is in a secure domain, do DNSSEC validation 		 * for it, unless it is glue. 		 */
if|if
condition|(
name|secure_domain
operator|&&
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_glue
condition|)
block|{
comment|/* 			 * RRSIGs are validated as part of validating the 			 * type they cover. 			 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
continue|continue;
comment|/* 			 * Find the SIG for this rdataset, if we have it. 			 */
for|for
control|(
name|sigrdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|sigrdataset
operator|!=
name|NULL
condition|;
name|sigrdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sigrdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|sigrdataset
operator|->
name|covers
operator|==
name|rdataset
operator|->
name|type
condition|)
break|break;
block|}
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|need_validation
condition|)
block|{
comment|/* 					 * Ignore non-answer rdatasets that 					 * are missing signatures. 					 */
continue|continue;
block|}
block|}
comment|/* 			 * Normalize the rdataset and sigrdataset TTLs. 			 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
name|rdataset
operator|->
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
name|sigrdataset
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|sigrdataset
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
block|}
comment|/* 			 * Cache this rdataset/sigrdataset pair as 			 * pending data. 			 */
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_pending
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdataset
operator|->
name|trust
operator|=
name|dns_trust_pending
expr_stmt|;
if|if
condition|(
operator|!
name|need_validation
condition|)
name|addedrdataset
operator|=
name|ardataset
expr_stmt|;
else|else
name|addedrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|need_validation
condition|)
name|addedrdataset
operator|=
name|asigrdataset
expr_stmt|;
else|else
name|addedrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|need_validation
condition|)
block|{
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
operator|&&
name|fctx
operator|->
name|type
operator|!=
name|dns_rdatatype_sig
condition|)
block|{
comment|/* 					 * This is The Answer.  We will 					 * validate it, but first we cache 					 * the rest of the response - it may 					 * contain useful keys. 					 */
name|INSIST
argument_list|(
name|valrdataset
operator|==
name|NULL
operator|&&
name|valsigrdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|valrdataset
operator|=
name|rdataset
expr_stmt|;
name|valsigrdataset
operator|=
name|sigrdataset
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * This is one of (potentially) 					 * multiple answers to an ANY 					 * or SIG query.  To keep things 					 * simple, we just start the 					 * validator right away rather 					 * than caching first and 					 * having to remember which 					 * rdatasets needed validation. 					 */
name|result
operator|=
name|valcreate
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|valoptions
argument_list|,
name|task
argument_list|)
expr_stmt|;
comment|/* 					 * Defer any further validations. 					 * This prevents multiple validators 					 * from manipulating fctx->rmessage 					 * simultaniously. 					 */
name|valoptions
operator||=
name|DNS_VALIDATOR_DEFER
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CHAINING
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|eresult
operator|=
name|DNS_R_CNAME
expr_stmt|;
else|else
block|{
name|INSIST
argument_list|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_DNAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|EXTERNAL
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 			 * It's OK to cache this rdataset now. 			 */
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
condition|)
name|addedrdataset
operator|=
name|ardataset
expr_stmt|;
elseif|else
if|if
condition|(
name|ANSWERSIG
argument_list|(
name|rdataset
argument_list|)
condition|)
name|addedrdataset
operator|=
name|asigrdataset
expr_stmt|;
else|else
name|addedrdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|CHAINING
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
name|eresult
operator|=
name|DNS_R_CNAME
expr_stmt|;
else|else
block|{
name|INSIST
argument_list|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_DNAME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|&&
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_ns
operator|)
operator|)
condition|)
block|{
comment|/* 				 * If the trust level is 'dns_trust_glue' 				 * then we are adding data from a referral 				 * we got while executing the search algorithm. 				 * New referral data always takes precedence 				 * over the existing cache contents. 				 */
name|options
operator|=
name|DNS_DBADD_FORCE
expr_stmt|;
block|}
else|else
name|options
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Now we can add the rdataset. 			 */
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|,
name|options
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
block|{
if|if
condition|(
name|ANSWER
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|ardataset
operator|!=
name|NULL
operator|&&
name|ardataset
operator|->
name|type
operator|==
literal|0
condition|)
block|{
comment|/* 					 * The answer in the cache is better 					 * than the answer we found, and is 					 * a negative cache entry, so we 					 * must set eresult appropriately. 					 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|ardataset
argument_list|)
condition|)
name|eresult
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|eresult
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|valrdataset
operator|!=
name|NULL
condition|)
name|result
operator|=
name|valcreate
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
name|valrdataset
argument_list|,
name|valsigrdataset
argument_list|,
name|valoptions
argument_list|,
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|have_answer
condition|)
block|{
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_HAVEANSWER
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|event
operator|->
name|result
operator|=
name|eresult
expr_stmt|;
name|dns_db_attach
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|adbp
argument_list|)
expr_stmt|;
operator|*
name|anodep
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|clone_results
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cache_message
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_section_t
name|section
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"cache_message"
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_WANTCACHE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|section
operator|=
name|DNS_SECTION_ANSWER
init|;
name|section
operator|<=
name|DNS_SECTION_ADDITIONAL
condition|;
name|section
operator|++
control|)
block|{
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_CACHE
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|cache_name
argument_list|(
name|fctx
argument_list|,
name|name
argument_list|,
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do what dns_ncache_add() does, and then compute an appropriate eresult.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|ncache_adderesult
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_db_t
modifier|*
name|cache
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_ttl_t
name|maxttl
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|isc_result_t
modifier|*
name|eresultp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
if|if
condition|(
name|ardataset
operator|==
name|NULL
condition|)
block|{
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|ardataset
operator|=
operator|&
name|rdataset
expr_stmt|;
block|}
name|result
operator|=
name|dns_ncache_add
argument_list|(
name|message
argument_list|,
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|maxttl
argument_list|,
name|ardataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * If the cache now contains a negative entry and we 		 * care about whether it is DNS_R_NCACHENXDOMAIN or 		 * DNS_R_NCACHENXRRSET then extract it. 		 */
if|if
condition|(
name|ardataset
operator|->
name|type
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The cache data is a negative cache entry. 			 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|ardataset
argument_list|)
condition|)
operator|*
name|eresultp
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
operator|*
name|eresultp
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Either we don't care about the nature of the 			 * cache rdataset (because no fetch is interested 			 * in the outcome), or the cache rdataset is not 			 * a negative cache entry.  Whichever case it is, 			 * we can return success. 			 * 			 * XXXRTH  There's a CNAME/DNAME problem here. 			 */
operator|*
name|eresultp
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|ardataset
operator|==
operator|&
name|rdataset
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|ardataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|ardataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|ncache_message
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_db_t
modifier|*
modifier|*
name|adbp
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|anodep
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|ardataset
decl_stmt|;
name|isc_boolean_t
name|need_validation
decl_stmt|,
name|secure_domain
decl_stmt|;
name|dns_name_t
modifier|*
name|aname
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|unsigned
name|int
name|valoptions
init|=
literal|0
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"ncache_message"
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_WANTNCACHE
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
name|secure_domain
operator|=
name|ISC_FALSE
expr_stmt|;
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|name
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * XXXMPA remove when we follow cnames and adjust the setting 	 * of FCTX_ATTR_WANTNCACHE in noanswer_response(). 	 */
name|INSIST
argument_list|(
name|fctx
operator|->
name|rmessage
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Is DNSSEC validation required for this name? 	 */
name|result
operator|=
name|dns_keytable_issecuredomain
argument_list|(
name|res
operator|->
name|view
operator|->
name|secroots
argument_list|,
name|name
argument_list|,
operator|&
name|secure_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
operator|!
name|secure_domain
operator|&&
name|res
operator|->
name|view
operator|->
name|dlv
operator|!=
name|NULL
condition|)
block|{
name|valoptions
operator|=
name|DNS_VALIDATOR_DLV
expr_stmt|;
name|secure_domain
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fctx
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOVALIDATE
operator|)
operator|!=
literal|0
condition|)
name|need_validation
operator|=
name|ISC_FALSE
expr_stmt|;
else|else
name|need_validation
operator|=
name|secure_domain
expr_stmt|;
if|if
condition|(
name|secure_domain
condition|)
block|{
comment|/* 		 * Mark all rdatasets as pending. 		 */
name|dns_rdataset_t
modifier|*
name|trdataset
decl_stmt|;
name|dns_name_t
modifier|*
name|tname
decl_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|tname
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
for|for
control|(
name|trdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|tname
operator|->
name|list
argument_list|)
init|;
name|trdataset
operator|!=
name|NULL
condition|;
name|trdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|trdataset
argument_list|,
name|link
argument_list|)
control|)
name|trdataset
operator|->
name|trust
operator|=
name|dns_trust_pending
expr_stmt|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|need_validation
condition|)
block|{
comment|/* 		 * Do negative response validation. 		 */
name|result
operator|=
name|valcreate
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|name
argument_list|,
name|fctx
operator|->
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|valoptions
argument_list|,
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
comment|/* 		 * If validation is necessary, return now.  Otherwise continue 		 * to process the message, letting the validation complete 		 * in its own good time. 		 */
return|return
operator|(
name|result
operator|)
return|;
block|}
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|adbp
operator|=
name|NULL
expr_stmt|;
name|aname
operator|=
name|NULL
expr_stmt|;
name|anodep
operator|=
name|NULL
expr_stmt|;
name|ardataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|adbp
operator|=
operator|&
name|event
operator|->
name|db
expr_stmt|;
name|aname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|aname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
name|anodep
operator|=
operator|&
name|event
operator|->
name|node
expr_stmt|;
name|ardataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
block|}
block|}
else|else
name|event
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * If we are asking for a SOA record set the cache time 	 * to zero to facilitate locating the containing zone of 	 * a arbitary zone. 	 */
name|ttl
operator|=
name|fctx
operator|->
name|res
operator|->
name|view
operator|->
name|maxncachettl
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|covers
operator|==
name|dns_rdatatype_any
condition|)
name|ttl
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ncache_adderesult
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|fctx
operator|->
name|cache
argument_list|,
name|node
argument_list|,
name|covers
argument_list|,
name|now
argument_list|,
name|ttl
argument_list|,
name|ardataset
argument_list|,
operator|&
name|eresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
if|if
condition|(
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_HAVEANSWER
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|event
operator|->
name|result
operator|=
name|eresult
expr_stmt|;
name|dns_db_attach
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
name|adbp
argument_list|)
expr_stmt|;
operator|*
name|anodep
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|clone_results
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fctx
operator|->
name|cache
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mark_related
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_boolean_t
name|external
parameter_list|,
name|isc_boolean_t
name|gluing
parameter_list|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
if|if
condition|(
name|gluing
condition|)
block|{
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_glue
expr_stmt|;
comment|/* 		 * Glue with 0 TTL causes problems.  We force the TTL to 		 * 1 second to prevent this. 		 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|==
literal|0
condition|)
name|rdataset
operator|->
name|ttl
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
comment|/* 	 * Avoid infinite loops by only marking new rdatasets. 	 */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CHASE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHASE
expr_stmt|;
block|}
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
if|if
condition|(
name|external
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_EXTERNAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_related
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|addname
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
init|=
name|arg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_boolean_t
name|external
decl_stmt|;
name|dns_rdatatype_t
name|rtype
decl_stmt|;
name|isc_boolean_t
name|gluing
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLUING
argument_list|(
name|fctx
argument_list|)
condition|)
name|gluing
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|gluing
operator|=
name|ISC_FALSE
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
name|addname
argument_list|,
name|dns_rdatatype_any
argument_list|,
literal|0
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|external
operator|=
name|ISC_TF
argument_list|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_a
condition|)
block|{
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|rtype
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
else|else
name|rtype
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|dns_rdatatype_a
operator|||
name|rtype
operator|==
name|dns_rdatatype_aaaa
condition|)
name|mark_related
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|external
argument_list|,
name|gluing
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|mark_related
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|external
argument_list|,
name|gluing
argument_list|)
expr_stmt|;
comment|/* 				 * Do we have its SIG too? 				 */
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|mark_related
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|external
argument_list|,
name|gluing
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chase_additional
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_boolean_t
name|rescan
decl_stmt|;
name|dns_section_t
name|section
init|=
name|DNS_SECTION_ADDITIONAL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|again
label|:
name|rescan
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|section
argument_list|)
control|)
block|{
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_message_currentname
argument_list|(
name|fctx
operator|->
name|rmessage
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_CHASE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_CHASE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|CHASE
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator|&=
operator|~
name|DNS_RDATASETATTR_CHASE
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
name|rescan
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rescan
condition|)
goto|goto
name|again
goto|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cname_target
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|tname
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_cname_t
name|cname
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_name_init
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|cname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|dname_target
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|oname
parameter_list|,
name|dns_fixedname_t
modifier|*
name|fixeddname
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|;
name|int
name|order
decl_stmt|;
name|dns_namereln_t
name|namereln
decl_stmt|;
name|dns_rdata_dname_t
name|dname
decl_stmt|;
name|dns_fixedname_t
name|prefix
decl_stmt|;
comment|/* 	 * Get the target name of the DNAME. 	 */
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|dname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Get the prefix of qname. 	 */
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|qname
argument_list|,
name|oname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
if|if
condition|(
name|namereln
operator|!=
name|dns_namereln_subdomain
condition|)
block|{
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|prefix
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|qname
argument_list|,
name|nlabels
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|prefix
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
name|fixeddname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|prefix
argument_list|)
argument_list|,
operator|&
name|dname
operator|.
name|dname
argument_list|,
name|dns_fixedname_name
argument_list|(
name|fixeddname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a no-answer response (NXDOMAIN, NXRRSET, or referral).  * If bind8_ns_resp is ISC_TRUE, this is a suspected BIND 8  * response to an NS query that should be treated as a referral  * even though the NS records occur in the answer section  * rather than the authority section.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|noanswer_response
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|oqname
parameter_list|,
name|isc_boolean_t
name|bind8_ns_resp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|,
modifier|*
name|ns_name
decl_stmt|,
modifier|*
name|soa_name
decl_stmt|,
modifier|*
name|ds_name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|ns_rdataset
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|,
name|aa
decl_stmt|,
name|negative_response
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_section_t
name|section
init|=
name|bind8_ns_resp
condition|?
name|DNS_SECTION_ANSWER
else|:
name|DNS_SECTION_AUTHORITY
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"noanswer_response"
argument_list|)
expr_stmt|;
name|message
operator|=
name|fctx
operator|->
name|rmessage
expr_stmt|;
comment|/* 	 * Setup qname. 	 */
if|if
condition|(
name|oqname
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We have a normal, non-chained negative response or 		 * referral. 		 */
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
condition|)
name|aa
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|aa
operator|=
name|ISC_FALSE
expr_stmt|;
name|qname
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're being invoked by answer_response() after it has 		 * followed a CNAME/DNAME chain. 		 */
name|qname
operator|=
name|oqname
expr_stmt|;
name|aa
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * If the current qname is not a subdomain of the query 		 * domain, there's no point in looking at the authority 		 * section without doing DNSSEC validation. 		 * 		 * Until we do that validation, we'll just return success 		 * in this case. 		 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|qname
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * We have to figure out if this is a negative response, or a 	 * referral. 	 */
comment|/* 	 * Sometimes we can tell if its a negative response by looking at 	 * the message header. 	 */
name|negative_response
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|||
operator|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
operator|&&
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|==
literal|0
operator|)
condition|)
name|negative_response
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Process the authority section. 	 */
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|ns_name
operator|=
name|NULL
expr_stmt|;
name|ns_rdataset
operator|=
name|NULL
expr_stmt|;
name|soa_name
operator|=
name|NULL
expr_stmt|;
name|ds_name
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
comment|/* 			 * Look for NS/SOA RRsets first. 			 */
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|type
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|type
operator|==
name|dns_rdatatype_soa
operator|)
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|qname
argument_list|,
name|name
argument_list|)
operator|)
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 					 * NS or RRSIG NS. 					 * 					 * Only one set of NS RRs is allowed. 					 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
if|if
condition|(
name|ns_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|ns_name
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
name|ns_name
operator|=
name|name
expr_stmt|;
name|ns_rdataset
operator|=
name|rdataset
expr_stmt|;
block|}
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_glue
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
comment|/* 					 * SOA, or RRSIG SOA. 					 * 					 * Only one SOA is allowed. 					 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
if|if
condition|(
name|soa_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|soa_name
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
name|soa_name
operator|=
name|name
expr_stmt|;
block|}
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_NCACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NCACHE
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
block|}
block|}
comment|/* 			 * A negative response has a SOA record (Type 2)  			 * and a optional NS RRset (Type 1) or it has neither 			 * a SOA or a NS RRset (Type 3, handled above) or 			 * rcode is NXDOMAIN (handled above) in which case 			 * the NS RRset is allowed (Type 4). 			 */
if|if
condition|(
name|soa_name
operator|!=
name|NULL
condition|)
name|negative_response
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|type
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
comment|/* 					 * NSEC or RRSIG NSEC. 					 */
if|if
condition|(
name|negative_response
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_NCACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NCACHE
expr_stmt|;
block|}
else|else
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
block|}
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
comment|/* 					 * No additional data needs to be 					 * marked. 					 */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ds
condition|)
block|{
comment|/* 					 * DS or SIG DS. 					 * 					 * These should only be here if 					 * this is a referral, and there 					 * should only be one DS. 					 */
if|if
condition|(
name|ns_name
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ds
condition|)
block|{
if|if
condition|(
name|ds_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|ds_name
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
name|ds_name
operator|=
name|name
expr_stmt|;
block|}
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
break|break;
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Trigger lookups for DNS nameservers. 	 */
if|if
condition|(
name|negative_response
operator|&&
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|&&
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|&&
name|soa_name
operator|!=
name|NULL
operator|&&
name|dns_name_equal
argument_list|(
name|soa_name
argument_list|,
name|qname
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|qname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_CHASEDSSERVERS
operator|)
return|;
comment|/* 	 * Did we find anything? 	 */
if|if
condition|(
operator|!
name|negative_response
operator|&&
name|ns_name
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Nope. 		 */
if|if
condition|(
name|oqname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We've already got a partial CNAME/DNAME chain, 			 * and haven't found else anything useful here, but 			 * no error has occurred since we have an answer. 			 */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * The responder is insane. 			 */
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
block|}
comment|/* 	 * If we found both NS and SOA, they should be the same name. 	 */
if|if
condition|(
name|ns_name
operator|!=
name|NULL
operator|&&
name|soa_name
operator|!=
name|NULL
operator|&&
name|ns_name
operator|!=
name|soa_name
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
comment|/* 	 * Do we have a referral?  (We only want to follow a referral if 	 * we're not following a chain.) 	 */
if|if
condition|(
operator|!
name|negative_response
operator|&&
name|ns_name
operator|!=
name|NULL
operator|&&
name|oqname
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We already know ns_name is a subdomain of fctx->domain. 		 * If ns_name is equal to fctx->domain, we're not making 		 * progress.  We return DNS_R_FORMERR so that we'll keep 		 * trying other servers. 		 */
if|if
condition|(
name|dns_name_equal
argument_list|(
name|ns_name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
comment|/* 		 * If the referral name is not a parent of the query 		 * name, consider the responder insane. 		 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|ns_name
argument_list|)
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"referral to non-parent"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
comment|/* 		 * Mark any additional data related to this rdataset. 		 * It's important that we do this before we change the 		 * query domain. 		 */
name|INSIST
argument_list|(
name|ns_rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_GLUING
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|ns_rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|attributes
operator|&=
operator|~
name|FCTX_ATTR_GLUING
expr_stmt|;
comment|/* 		 * NS rdatasets with 0 TTL cause problems. 		 * dns_view_findzonecut() will not find them when we 		 * try to follow the referral, and we'll SERVFAIL 		 * because the best nameservers are now above QDOMAIN. 		 * We force the TTL to 1 second to prevent this. 		 */
if|if
condition|(
name|ns_rdataset
operator|->
name|ttl
operator|==
literal|0
condition|)
name|ns_rdataset
operator|->
name|ttl
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Set the current query domain to the referral name. 		 * 		 * XXXRTH  We should check if we're in forward-only mode, and 		 *	   if so we should bail out. 		 */
name|INSIST
argument_list|(
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|ns_name
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_WANTCACHE
expr_stmt|;
return|return
operator|(
name|DNS_R_DELEGATION
operator|)
return|;
block|}
comment|/* 	 * Since we're not doing a referral, we don't want to cache any 	 * NS RRs we may have found. 	 */
if|if
condition|(
name|ns_name
operator|!=
name|NULL
condition|)
name|ns_name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_CACHE
expr_stmt|;
if|if
condition|(
name|negative_response
operator|&&
name|oqname
operator|==
name|NULL
condition|)
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_WANTNCACHE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|answer_response
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|,
name|tname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|,
name|external
decl_stmt|,
name|chaining
decl_stmt|,
name|aa
decl_stmt|,
name|found
decl_stmt|,
name|want_chaining
decl_stmt|;
name|isc_boolean_t
name|have_answer
decl_stmt|,
name|found_cname
decl_stmt|,
name|found_type
decl_stmt|,
name|wanted_chaining
decl_stmt|;
name|unsigned
name|int
name|aflag
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_fixedname_t
name|dname
decl_stmt|,
name|fqname
decl_stmt|;
name|FCTXTRACE
argument_list|(
literal|"answer_response"
argument_list|)
expr_stmt|;
name|message
operator|=
name|fctx
operator|->
name|rmessage
expr_stmt|;
comment|/* 	 * Examine the answer section, marking those rdatasets which are 	 * part of the answer and should be cached. 	 */
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|found_cname
operator|=
name|ISC_FALSE
expr_stmt|;
name|found_type
operator|=
name|ISC_FALSE
expr_stmt|;
name|chaining
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_answer
operator|=
name|ISC_FALSE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|!=
literal|0
condition|)
name|aa
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|aa
operator|=
name|ISC_FALSE
expr_stmt|;
name|qname
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
name|type
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|external
operator|=
name|ISC_TF
argument_list|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|qname
argument_list|)
condition|)
block|{
name|wanted_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
name|aflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|type
operator|&&
operator|!
name|found_cname
condition|)
block|{
comment|/* 					 * We've found an ordinary answer. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_type
operator|=
name|ISC_TRUE
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
block|{
comment|/* 					 * We've found an answer matching 					 * an ANY query.  There may be 					 * more. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|type
operator|&&
operator|!
name|found_cname
condition|)
block|{
comment|/* 					 * We've found a signature that 					 * covers the type we're looking for. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_type
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWERSIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
operator|!
name|found_type
condition|)
block|{
comment|/* 					 * We're looking for something else, 					 * but we found a CNAME. 					 * 					 * Getting a CNAME response for some 					 * query types is an error. 					 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|type
operator|==
name|dns_rdatatype_dnskey
operator|||
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_cname
operator|=
name|ISC_TRUE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
name|result
operator|=
name|cname_target
argument_list|(
name|rdataset
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_cname
operator|&&
operator|!
name|found_type
condition|)
block|{
comment|/* 					 * We're looking for something else, 					 * but we found a SIG CNAME. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|found_cname
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWERSIG
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* 					 * We've found an answer to our 					 * question. 					 */
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
if|if
condition|(
operator|!
name|chaining
condition|)
block|{
comment|/* 						 * This data is "the" answer 						 * to our question only if 						 * we're not chaining (i.e. 						 * if we haven't followed 						 * a CNAME or DNAME). 						 */
name|INSIST
argument_list|(
operator|!
name|external
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
name|DNS_RDATASETATTR_ANSWER
condition|)
name|have_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ANSWER
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|aflag
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authanswer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|external
condition|)
block|{
comment|/* 						 * This data is outside of 						 * our query domain, and 						 * may only be cached if it 						 * comes from a secure zone 						 * and validates. 						 */
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_EXTERNAL
expr_stmt|;
block|}
comment|/* 					 * Mark any additional data related 					 * to this rdataset. 					 */
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
comment|/* 					 * CNAME chaining. 					 */
if|if
condition|(
name|want_chaining
condition|)
block|{
name|wanted_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CHAINING
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHAINING
expr_stmt|;
name|qname
operator|=
operator|&
name|tname
expr_stmt|;
block|}
block|}
comment|/* 				 * We could add an "else" clause here and 				 * log that we're ignoring this rdataset. 				 */
block|}
comment|/* 			 * If wanted_chaining is true, we've done 			 * some chaining as the result of processing 			 * this node, and thus we need to set 			 * chaining to true. 			 * 			 * We don't set chaining inside of the 			 * rdataset loop because doing that would 			 * cause us to ignore the signatures of 			 * CNAMEs. 			 */
if|if
condition|(
name|wanted_chaining
condition|)
name|chaining
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Look for a DNAME (or its SIG).  Anything else is 			 * ignored. 			 */
name|wanted_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_boolean_t
name|found_dname
init|=
name|ISC_FALSE
decl_stmt|;
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
name|aflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dname
condition|)
block|{
comment|/* 					 * We're looking for something else, 					 * but we found a DNAME. 					 * 					 * If we're not chaining, then the 					 * DNAME should not be external. 					 */
if|if
condition|(
operator|!
name|chaining
operator|&&
name|external
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|want_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWER
expr_stmt|;
name|result
operator|=
name|dname_target
argument_list|(
name|rdataset
argument_list|,
name|qname
argument_list|,
name|name
argument_list|,
operator|&
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
comment|/* 						 * We can't construct the 						 * DNAME target.  Do not 						 * try to continue. 						 */
name|want_chaining
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|else
name|found_dname
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_dname
condition|)
block|{
comment|/* 					 * We've found a signature that 					 * covers the DNAME. 					 */
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|aflag
operator|=
name|DNS_RDATASETATTR_ANSWERSIG
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* 					 * We've found an answer to our 					 * question. 					 */
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_answer
expr_stmt|;
if|if
condition|(
operator|!
name|chaining
condition|)
block|{
comment|/* 						 * This data is "the" answer 						 * to our question only if 						 * we're not chaining. 						 */
name|INSIST
argument_list|(
operator|!
name|external
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
name|DNS_RDATASETATTR_ANSWER
condition|)
name|have_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ANSWER
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|aflag
expr_stmt|;
if|if
condition|(
name|aa
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authanswer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|external
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_EXTERNAL
expr_stmt|;
block|}
comment|/* 					 * DNAME chaining. 					 */
if|if
condition|(
name|found_dname
condition|)
block|{
comment|/* 						 * Copy the the dname into the 						 * qname fixed name. 						 * 						 * Although we check for 						 * failure of the copy 						 * operation, in practice it 						 * should never fail since 						 * we already know that the 						 * result fits in a fixedname. 						 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fqname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|dname
argument_list|)
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fqname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|wanted_chaining
operator|=
name|ISC_TRUE
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CHAINING
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHAINING
expr_stmt|;
name|qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fqname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|wanted_chaining
condition|)
name|chaining
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * We should have found an answer. 	 */
if|if
condition|(
operator|!
name|have_answer
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
comment|/* 	 * This response is now potentially cacheable. 	 */
name|fctx
operator|->
name|attributes
operator||=
name|FCTX_ATTR_WANTCACHE
expr_stmt|;
comment|/* 	 * Did chaining end before we got the final answer? 	 */
if|if
condition|(
name|chaining
condition|)
block|{
comment|/* 		 * Yes.  This may be a negative reply, so hand off 		 * authority section processing to the noanswer code. 		 * If it isn't a noanswer response, no harm will be 		 * done. 		 */
return|return
operator|(
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|qname
argument_list|,
name|ISC_FALSE
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * We didn't end with an incomplete chain, so the rcode should be 	 * "no error". 	 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
condition|)
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
comment|/* 	 * Examine the authority section (if there is one). 	 * 	 * We expect there to be only one owner name for all the rdatasets 	 * in this section, and we expect that it is not external. 	 */
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|external
operator|=
name|ISC_TF
argument_list|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
block|{
comment|/* 			 * We expect to find NS or SIG NS rdatasets, and 			 * nothing else. 			 */
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_ns
operator|)
condition|)
block|{
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_CACHE
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CACHE
expr_stmt|;
if|if
condition|(
name|aa
operator|&&
operator|!
name|chaining
condition|)
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_authauthority
expr_stmt|;
else|else
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_additional
expr_stmt|;
comment|/* 					 * Mark any additional data related 					 * to this rdataset. 					 */
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|check_related
argument_list|,
name|fctx
argument_list|)
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_dslookup
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|fevent
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|locked
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|dns_rdataset_t
name|nameservers
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|domain
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|fevent
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|fctx
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"resume_dslookup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fevent
operator|->
name|db
argument_list|,
operator|&
name|fevent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|fevent
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|nameservers
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|result
operator|==
name|ISC_R_CANCELED
condition|)
block|{
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|ISC_R_CANCELED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"resuming DS lookup"
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Try again. 		 */
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|nsrdataset
init|=
name|NULL
decl_stmt|;
comment|/* 		 * Retrieve state from fctx->nsfetch before we destroy it. 		 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|domain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
operator|->
name|private
operator|->
name|domain
argument_list|,
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|domain
argument_list|)
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
operator|->
name|private
operator|->
name|nameservers
argument_list|)
condition|)
block|{
name|dns_rdataset_clone
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
operator|->
name|private
operator|->
name|nameservers
argument_list|,
operator|&
name|nameservers
argument_list|)
expr_stmt|;
name|nsrdataset
operator|=
operator|&
name|nameservers
expr_stmt|;
block|}
else|else
name|domain
operator|=
name|NULL
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"continuing to look for parent's NS records"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|domain
argument_list|,
name|nsrdataset
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|task
argument_list|,
name|resume_dslookup
argument_list|,
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|nsrrset
argument_list|,
name|NULL
argument_list|,
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|ISC_TRUE
expr_stmt|;
name|fctx
operator|->
name|references
operator|++
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|nameservers
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nameservers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fevent
operator|->
name|sigrdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
name|bucket_empty
operator|=
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|checknamessection
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|section
argument_list|)
control|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdata_checkowner
argument_list|(
name|name
argument_list|,
name|rdata
operator|.
name|rdclass
argument_list|,
name|rdata
operator|.
name|type
argument_list|,
name|ISC_FALSE
argument_list|)
operator|||
operator|!
name|dns_rdata_checknames
argument_list|(
operator|&
name|rdata
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CHECKNAMES
expr_stmt|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|checknames
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|)
block|{
name|checknamessection
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|checknamessection
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|checknamessection
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_packet
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_buffer_t
name|buffer
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|len
init|=
literal|1024
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
comment|/* 	 * Note that these are multiline debug messages.  We want a newline 	 * to appear in the log after each message. 	 */
do|do
block|{
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
break|break;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_totext
argument_list|(
name|message
argument_list|,
operator|&
name|dns_master_style_debug
argument_list|,
literal|0
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|level
argument_list|,
literal|"received packet:\n%.*s"
argument_list|,
operator|(
name|int
operator|)
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
do|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resquery_response
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|resquery_t
modifier|*
name|query
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|devent
init|=
operator|(
name|dns_dispatchevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|isc_boolean_t
name|keep_trying
decl_stmt|,
name|get_nameservers
decl_stmt|,
name|resend
decl_stmt|;
name|isc_boolean_t
name|truncated
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_fixedname_t
name|foundname
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_time_t
name|tnow
decl_stmt|,
modifier|*
name|finish
decl_stmt|;
name|dns_adbaddrinfo_t
modifier|*
name|addrinfo
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|findoptions
decl_stmt|;
name|isc_result_t
name|broken_server
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_QUERY
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|query
operator|->
name|fctx
expr_stmt|;
name|options
operator|=
name|query
operator|->
name|options
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_DISPATCH
argument_list|)
expr_stmt|;
name|QTRACE
argument_list|(
literal|"response"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_timer_touch
argument_list|(
name|fctx
operator|->
name|timer
argument_list|)
expr_stmt|;
name|keep_trying
operator|=
name|ISC_FALSE
expr_stmt|;
name|broken_server
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|get_nameservers
operator|=
name|ISC_FALSE
expr_stmt|;
name|resend
operator|=
name|ISC_FALSE
expr_stmt|;
name|truncated
operator|=
name|ISC_FALSE
expr_stmt|;
name|finish
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|res
operator|->
name|exiting
condition|)
block|{
name|result
operator|=
name|ISC_R_SHUTTINGDOWN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fctx
operator|->
name|timeouts
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXXRTH  We should really get the current time just once.  We 	 *	   need a routine to convert from an isc_time_t to an 	 *	   isc_stdtime_t. 	 */
name|TIME_NOW
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|finish
operator|=
operator|&
name|tnow
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Did the dispatcher have a problem? 	 */
if|if
condition|(
name|devent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|devent
operator|->
name|result
operator|==
name|ISC_R_EOF
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The problem might be that they 			 * don't understand EDNS0.  Turn it 			 * off and try again. 			 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * Remember that they don't like EDNS0. 			 */
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There's no hope for this query. 			 */
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|message
operator|=
name|fctx
operator|->
name|rmessage
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tsig
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_message_setquerytsig
argument_list|(
name|message
argument_list|,
name|query
operator|->
name|tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|query
operator|->
name|tsigkey
condition|)
block|{
name|result
operator|=
name|dns_message_settsigkey
argument_list|(
name|message
argument_list|,
name|query
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|dns_message_parse
argument_list|(
name|message
argument_list|,
operator|&
name|devent
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_UNEXPECTEDEND
case|:
if|if
condition|(
operator|!
name|message
operator|->
name|question_ok
operator|||
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|==
literal|0
operator|||
operator|(
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Either the message ended prematurely, 				 * and/or wasn't marked as being truncated, 				 * and/or this is a response to a query we 				 * sent over TCP.  In all of these cases, 				 * something is wrong with the remote 				 * server and we don't want to retry using 				 * TCP. 				 */
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * The problem might be that they 					 * don't understand EDNS0.  Turn it 					 * off and try again. 					 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 					 * Remember that they don't like EDNS0. 					 */
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|broken_server
operator|=
name|result
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 			 * We defer retrying via TCP for a bit so we can 			 * check out this message further. 			 */
name|truncated
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
name|DNS_R_FORMERR
case|:
if|if
condition|(
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The problem might be that they 				 * don't understand EDNS0.  Turn it 				 * off and try again. 				 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * Remember that they don't like EDNS0. 				 */
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDRCODE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
default|default:
comment|/* 			 * Something bad has happened. 			 */
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Log the incoming packet. 	 */
name|log_packet
argument_list|(
name|message
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
comment|/* 	 * If the message is signed, check the signature.  If not, this 	 * returns success anyway. 	 */
name|result
operator|=
name|dns_message_checksig
argument_list|(
name|message
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * The dispatcher should ensure we only get responses with QR set. 	 */
name|INSIST
argument_list|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * INSIST() that the message comes from the place we sent it to, 	 * since the dispatch code should ensure this. 	 * 	 * INSIST() that the message id is correct (this should also be 	 * ensured by the dispatch code). 	 */
comment|/* 	 * Deal with truncated responses by retrying using TCP. 	 */
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|!=
literal|0
condition|)
name|truncated
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|truncated
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|broken_server
operator|=
name|DNS_R_TRUNCATEDTCP
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|options
operator||=
name|DNS_FETCHOPT_TCP
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is it a query response? 	 */
if|if
condition|(
name|message
operator|->
name|opcode
operator|!=
name|dns_opcode_query
condition|)
block|{
comment|/* XXXRTH Log */
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDOPCODE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is the remote server broken, or does it dislike us? 	 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
operator|&&
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_nxdomain
condition|)
block|{
if|if
condition|(
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_notimp
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_servfail
operator|)
operator|&&
operator|(
name|query
operator|->
name|options
operator|&
name|DNS_FETCHOPT_NOEDNS0
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * It's very likely they don't like EDNS0. 			 * 			 * XXXRTH  We should check if the question 			 *	   we're asking requires EDNS0, and 			 *	   if so, we should bail out. 			 */
name|options
operator||=
name|DNS_FETCHOPT_NOEDNS0
expr_stmt|;
name|resend
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * Remember that they don't like EDNS0. 			 */
if|if
condition|(
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_servfail
condition|)
name|dns_adb_changeflags
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|,
name|DNS_FETCHOPT_NOEDNS0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
condition|)
block|{
if|if
condition|(
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
condition|)
block|{
comment|/* 				 * This forwarder doesn't understand us, 				 * but other forwarders might.  Keep trying. 				 */
name|broken_server
operator|=
name|DNS_R_REMOTEFORMERR
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The server doesn't understand us.  Since 				 * all servers for a zone need similar 				 * capabilities, we assume that we will get 				 * FORMERR from all servers, and thus we 				 * cannot make any more progress with this 				 * fetch. 				 */
name|result
operator|=
name|DNS_R_FORMERR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_yxdomain
condition|)
block|{
comment|/* 			 * DNAME mapping failed because the new name 			 * was too long.  There's no chance of success 			 * for this fetch. 			 */
name|result
operator|=
name|DNS_R_YXDOMAIN
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXXRTH log. 			 */
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDRCODE
expr_stmt|;
name|INSIST
argument_list|(
name|broken_server
operator|!=
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is the question the same as the one we asked? 	 */
name|result
operator|=
name|same_question
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* XXXRTH Log */
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Is the server lame? 	 */
if|if
condition|(
name|fctx
operator|->
name|res
operator|->
name|lame_ttl
operator|!=
literal|0
operator|&&
operator|!
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|&&
name|is_lame
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|log_lame
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_adb_marklame
argument_list|(
name|fctx
operator|->
name|adb
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|now
operator|+
name|fctx
operator|->
name|res
operator|->
name|lame_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"could not mark server as lame: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|broken_server
operator|=
name|DNS_R_LAME
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Enforce delegations only zones like NET and COM. 	 */
if|if
condition|(
operator|!
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
operator|&&
name|dns_view_isdelegationonly
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
operator|&
name|fctx
operator|->
name|name
argument_list|)
operator|&&
name|fix_mustbedelegationornxdomain
argument_list|(
name|message
argument_list|,
name|fctx
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|domainbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|typebuf
index|[
literal|64
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|domainbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|domainbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|fctx
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|query
operator|->
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DELEGATION_ONLY
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"enforced delegation-only for '%s' (%s/%s/%s) "
literal|"from %s"
argument_list|,
name|domainbuf
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fctx
operator|->
name|res
operator|->
name|options
operator|&
name|DNS_RESOLVER_CHECKNAMES
operator|)
operator|!=
literal|0
condition|)
name|checknames
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* 	 * Clear cache bits. 	 */
name|fctx
operator|->
name|attributes
operator|&=
operator|~
operator|(
name|FCTX_ATTR_WANTNCACHE
operator||
name|FCTX_ATTR_WANTCACHE
operator|)
expr_stmt|;
comment|/* 	 * Did we get any answers? 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|>
literal|0
operator|&&
operator|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|)
condition|)
block|{
comment|/* 		 * We've got answers.  However, if we sent 		 * a BIND 8 server an NS query, it may have 		 * incorrectly responded with a non-authoritative 		 * answer instead of a referral.  Since this 		 * answer lacks the SIGs necessary to do DNSSEC 		 * validation, we must invoke the following special 		 * kludge to treat it as a referral. 		 */
if|if
condition|(
name|fctx
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|==
literal|0
operator|&&
operator|!
name|ISFORWARDER
argument_list|(
name|query
operator|->
name|addrinfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DNS_R_DELEGATION
condition|)
block|{
comment|/* 				 * The answer section must have contained 				 * something other than the NS records 				 * we asked for.  Since AA is not set 				 * and the server is not a forwarder, 				 * it is technically lame and it's easier 				 * to treat it as such than to figure out 				 * some more elaborate course of action. 				 */
name|broken_server
operator|=
name|DNS_R_LAME
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|force_referral
goto|;
block|}
name|result
operator|=
name|answer_response
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_AUTHORITY
index|]
operator|>
literal|0
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
block|{
comment|/* 		 * NXDOMAIN, NXRDATASET, or referral. 		 */
name|result
operator|=
name|noanswer_response
argument_list|(
name|fctx
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_CHASEDSSERVERS
condition|)
block|{ 		}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
block|{
name|force_referral
label|:
comment|/* 			 * We don't have the answer, but we know a better 			 * place to look. 			 */
name|get_nameservers
operator|=
name|ISC_TRUE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 			 * We have a new set of name servers, and it 			 * has not experienced any restarts yet. 			 */
name|fctx
operator|->
name|restarts
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Something has gone wrong. 			 */
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The server is insane. 		 */
comment|/* XXXRTH Log */
name|broken_server
operator|=
name|DNS_R_UNEXPECTEDRCODE
expr_stmt|;
name|keep_trying
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Follow additional section data chains. 	 */
name|chase_additional
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
comment|/* 	 * Cache the cacheable parts of the message.  This may also cause 	 * work to be queued to the DNSSEC validator. 	 */
if|if
condition|(
name|WANTCACHE
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|result
operator|=
name|cache_message
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Ncache the negatively cacheable parts of the message.  This may 	 * also cause work to be queued to the DNSSEC validator. 	 */
if|if
condition|(
name|WANTNCACHE
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
name|dns_rdatatype_t
name|covers
decl_stmt|;
if|if
condition|(
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
name|covers
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|covers
operator|=
name|fctx
operator|->
name|type
expr_stmt|;
comment|/* 		 * Cache any negative cache entries in the message. 		 */
name|result
operator|=
name|ncache_message
argument_list|(
name|fctx
argument_list|,
name|query
operator|->
name|addrinfo
argument_list|,
name|covers
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Remember the query's addrinfo, in case we need to mark the 	 * server as broken. 	 */
name|addrinfo
operator|=
name|query
operator|->
name|addrinfo
expr_stmt|;
comment|/* 	 * Cancel the query. 	 * 	 * XXXRTH  Don't cancel the query if waiting for validation? 	 */
name|fctx_cancelquery
argument_list|(
operator|&
name|query
argument_list|,
operator|&
name|devent
argument_list|,
name|finish
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_trying
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_FORMERR
condition|)
name|broken_server
operator|=
name|DNS_R_FORMERR
expr_stmt|;
if|if
condition|(
name|broken_server
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Add this server to the list of bad servers for 			 * this fctx. 			 */
name|add_bad
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|broken_server
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_nameservers
condition|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|findoptions
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|fctx
operator|->
name|type
argument_list|)
condition|)
name|findoptions
operator||=
name|DNS_DBFIND_NOEXACT
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_UNSHARED
operator|)
operator|==
literal|0
condition|)
name|name
operator|=
operator|&
name|fctx
operator|->
name|name
expr_stmt|;
else|else
name|name
operator|=
operator|&
name|fctx
operator|->
name|domain
expr_stmt|;
name|result
operator|=
name|dns_view_findzonecut
argument_list|(
name|fctx
operator|->
name|res
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|fname
argument_list|,
name|now
argument_list|,
name|findoptions
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|fctx
operator|->
name|nameservers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|FCTXTRACE
argument_list|(
literal|"couldn't find a zonecut"
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
condition|)
block|{
comment|/* 				 * The best nameservers are now above our 				 * QDOMAIN. 				 */
name|FCTXTRACE
argument_list|(
literal|"nameservers now above QDOMAIN"
argument_list|)
expr_stmt|;
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|dns_name_free
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|fctx
operator|->
name|domain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|fname
argument_list|,
name|fctx
operator|->
name|res
operator|->
name|mctx
argument_list|,
operator|&
name|fctx
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupaltaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Try again. 		 */
name|fctx_try
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resend
condition|)
block|{
comment|/* 		 * Resend (probably with changed options). 		 */
name|FCTXTRACE
argument_list|(
literal|"resend"
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_query
argument_list|(
name|fctx
argument_list|,
name|addrinfo
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|HAVE_ANSWER
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 		 * All has gone well so far, but we are waiting for the 		 * DNSSEC validator to validate the answer. 		 */
name|FCTXTRACE
argument_list|(
literal|"wait for validator"
argument_list|)
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * We must not retransmit while the validator is working; 		 * it has references to the current rmessage. 		 */
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_CHASEDSSERVERS
condition|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|add_bad
argument_list|(
name|fctx
argument_list|,
operator|&
name|addrinfo
operator|->
name|sockaddr
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|fctx_cancelqueries
argument_list|(
name|fctx
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|fctx_cleanupfinds
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|fctx_cleanupforwaddrs
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|)
expr_stmt|;
name|FCTXTRACE
argument_list|(
literal|"suspending DS lookup to find parent's NS records"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|fctx
operator|->
name|res
argument_list|,
operator|&
name|fctx
operator|->
name|nsname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|task
argument_list|,
name|resume_dslookup
argument_list|,
name|fctx
argument_list|,
operator|&
name|fctx
operator|->
name|nsrrset
argument_list|,
name|NULL
argument_list|,
operator|&
name|fctx
operator|->
name|nsfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|fctx
operator|->
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|fctx_stopidletimer
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're done. 		 */
name|fctx_done
argument_list|(
name|fctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***  *** Resolver Methods  ***/
end_comment

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|alternate_t
modifier|*
name|a
decl_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|primefetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"destroy"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|nfctx
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
argument_list|)
expr_stmt|;
name|isc_task_shutdown
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|buckets
argument_list|,
name|res
operator|->
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|fctxbucket_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatchv4
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|res
operator|->
name|dispatchv4
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatchv6
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|res
operator|->
name|dispatchv6
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|alternates
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|alternates
argument_list|,
name|a
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|isaddress
condition|)
name|dns_name_free
argument_list|(
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|,
name|res
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_resolver_reset_algorithms
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|dns_resolver_resetmustbesecure
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|isc_rwlock_destroy
argument_list|(
operator|&
name|res
operator|->
name|alglock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_MBSLOCK
name|isc_rwlock_destroy
argument_list|(
operator|&
name|res
operator|->
name|mbslock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_shutdown_events
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|isc_task_t
modifier|*
name|etask
decl_stmt|;
comment|/* 	 * Caller must be holding the resolver lock. 	 */
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|etask
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|res
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|etask
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|empty_bucket
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|RTRACE
argument_list|(
literal|"empty_bucket"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|activebuckets
operator|>
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|activebuckets
operator|--
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|activebuckets
operator|==
literal|0
condition|)
name|send_shutdown_events
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_create
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|unsigned
name|int
name|ntasks
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|socketmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_dispatchmgr_t
modifier|*
name|dispatchmgr
parameter_list|,
name|dns_dispatch_t
modifier|*
name|dispatchv4
parameter_list|,
name|dns_dispatch_t
modifier|*
name|dispatchv6
parameter_list|,
name|dns_resolver_t
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|buckets_created
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * Create a resolver. 	 */
name|REQUIRE
argument_list|(
name|DNS_VIEW_VALID
argument_list|(
name|view
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ntasks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
operator|&&
operator|*
name|resp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispatchmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispatchv4
operator|!=
name|NULL
operator|||
name|dispatchv6
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|=
name|isc_mem_get
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|RTRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
name|res
operator|->
name|mctx
operator|=
name|view
operator|->
name|mctx
expr_stmt|;
name|res
operator|->
name|rdclass
operator|=
name|view
operator|->
name|rdclass
expr_stmt|;
name|res
operator|->
name|socketmgr
operator|=
name|socketmgr
expr_stmt|;
name|res
operator|->
name|timermgr
operator|=
name|timermgr
expr_stmt|;
name|res
operator|->
name|taskmgr
operator|=
name|taskmgr
expr_stmt|;
name|res
operator|->
name|dispatchmgr
operator|=
name|dispatchmgr
expr_stmt|;
name|res
operator|->
name|view
operator|=
name|view
expr_stmt|;
name|res
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|res
operator|->
name|lame_ttl
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|alternates
argument_list|)
expr_stmt|;
name|res
operator|->
name|udpsize
operator|=
name|RECV_BUFFER_SIZE
expr_stmt|;
name|res
operator|->
name|algorithms
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|mustbesecure
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|nbuckets
operator|=
name|ntasks
expr_stmt|;
name|res
operator|->
name|activebuckets
operator|=
name|ntasks
expr_stmt|;
name|res
operator|->
name|buckets
operator|=
name|isc_mem_get
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|ntasks
operator|*
sizeof|sizeof
argument_list|(
name|fctxbucket_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buckets
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_res
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntasks
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_buckets
goto|;
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_buckets
goto|;
block|}
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"res%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|isc_task_setname
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|,
name|name
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
expr_stmt|;
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|buckets_created
operator|++
expr_stmt|;
block|}
name|res
operator|->
name|dispatchv4
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dispatchv4
operator|!=
name|NULL
condition|)
name|dns_dispatch_attach
argument_list|(
name|dispatchv4
argument_list|,
operator|&
name|res
operator|->
name|dispatchv4
argument_list|)
expr_stmt|;
name|res
operator|->
name|dispatchv6
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dispatchv6
operator|!=
name|NULL
condition|)
name|dns_dispatch_attach
argument_list|(
name|dispatchv6
argument_list|,
operator|&
name|res
operator|->
name|dispatchv6
argument_list|)
expr_stmt|;
name|res
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|res
operator|->
name|frozen
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|res
operator|->
name|primefetch
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|nfctx
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_dispatches
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_lock
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_nlock
goto|;
if|#
directive|if
name|USE_ALGLOCK
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|res
operator|->
name|alglock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_primelock
goto|;
endif|#
directive|endif
if|#
directive|if
name|USE_MBSLOCK
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|res
operator|->
name|mbslock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_alglock
goto|;
endif|#
directive|endif
name|res
operator|->
name|magic
operator|=
name|RES_MAGIC
expr_stmt|;
operator|*
name|resp
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|#
directive|if
name|USE_MBSLOCK
name|cleanup_alglock
label|:
if|#
directive|if
name|USE_ALGLOCK
name|isc_rwlock_destroy
argument_list|(
operator|&
name|res
operator|->
name|alglock
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|USE_ALGLOCK
operator|||
name|USE_MBSLOCK
name|cleanup_primelock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup_nlock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|cleanup_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cleanup_dispatches
label|:
if|if
condition|(
name|res
operator|->
name|dispatchv6
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|res
operator|->
name|dispatchv6
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatchv4
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|res
operator|->
name|dispatchv4
argument_list|)
expr_stmt|;
name|cleanup_buckets
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buckets_created
condition|;
name|i
operator|++
control|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_task_shutdown
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|res
operator|->
name|buckets
argument_list|,
name|res
operator|->
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|fctxbucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_res
label|:
name|isc_mem_put
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prime_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|fevent
decl_stmt|;
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|fevent
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|res
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|fetch
operator|=
name|res
operator|->
name|primefetch
expr_stmt|;
name|res
operator|->
name|primefetch
operator|=
name|NULL
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|fevent
operator|->
name|db
argument_list|,
operator|&
name|fevent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fevent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|fevent
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|fevent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fevent
operator|->
name|sigrdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fevent
operator|->
name|rdataset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fevent
operator|->
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fetch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_prime
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|isc_boolean_t
name|want_priming
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"dns_resolver_prime"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|exiting
operator|&&
operator|!
name|res
operator|->
name|priming
condition|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|primefetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_TRUE
expr_stmt|;
name|want_priming
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_priming
condition|)
block|{
comment|/* 		 * To avoid any possible recursive locking problems, we 		 * start the priming fetch like any other fetch, and holding 		 * no resolver locks.  No one else will try to start it 		 * because we're the ones who set res->priming to true. 		 * Any other callers of dns_resolver_prime() while we're 		 * running will see that res->priming is already true and 		 * do nothing. 		 */
name|RTRACE
argument_list|(
literal|"priming"
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|isc_mem_get
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|primefetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|res
argument_list|,
name|dns_rootname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|res
operator|->
name|buckets
index|[
literal|0
index|]
operator|.
name|task
argument_list|,
name|prime_done
argument_list|,
name|res
argument_list|,
name|rdataset
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
operator|->
name|primefetch
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|primelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|priming
argument_list|)
expr_stmt|;
name|res
operator|->
name|priming
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|dns_resolver_freeze
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
comment|/* 	 * Freeze resolver. 	 */
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|res
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|res
operator|->
name|frozen
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_attach
parameter_list|(
name|dns_resolver_t
modifier|*
name|source
parameter_list|,
name|dns_resolver_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RRTRACE
argument_list|(
name|source
argument_list|,
literal|"attach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|source
operator|->
name|exiting
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_whenshutdown
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|eventp
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|clone
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|eventp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|event
operator|=
operator|*
name|eventp
expr_stmt|;
operator|*
name|eventp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|exiting
operator|&&
name|res
operator|->
name|activebuckets
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're already shutdown.  Send the event. 		 */
name|event
operator|->
name|ev_sender
operator|=
name|res
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clone
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|clone
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|clone
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|res
operator|->
name|whenshutdown
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_shutdown
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|exiting
condition|)
block|{
name|RTRACE
argument_list|(
literal|"exiting"
argument_list|)
expr_stmt|;
name|res
operator|->
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|fctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
init|;
name|fctx
operator|!=
name|NULL
condition|;
name|fctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
control|)
name|fctx_shutdown
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispatchv4
operator|!=
name|NULL
condition|)
block|{
name|sock
operator|=
name|dns_dispatch_getsocket
argument_list|(
name|res
operator|->
name|dispatchv4
argument_list|)
expr_stmt|;
name|isc_socket_cancel
argument_list|(
name|sock
argument_list|,
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|,
name|ISC_SOCKCANCEL_ALL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|dispatchv6
operator|!=
name|NULL
condition|)
block|{
name|sock
operator|=
name|dns_dispatch_getsocket
argument_list|(
name|res
operator|->
name|dispatchv6
argument_list|)
expr_stmt|;
name|isc_socket_cancel
argument_list|(
name|sock
argument_list|,
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|task
argument_list|,
name|ISC_SOCKCANCEL_ALL
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|fctxs
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|activebuckets
operator|>
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|activebuckets
operator|--
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|activebuckets
operator|==
literal|0
condition|)
name|send_shutdown_events
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_detach
parameter_list|(
name|dns_resolver_t
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|isc_boolean_t
name|need_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|=
operator|*
name|resp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|RTRACE
argument_list|(
literal|"detach"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|res
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|exiting
operator|&&
name|res
operator|->
name|activebuckets
operator|==
literal|0
argument_list|)
expr_stmt|;
name|need_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_destroy
condition|)
name|destroy
argument_list|(
name|res
argument_list|)
expr_stmt|;
operator|*
name|resp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|fctx_match
parameter_list|(
name|fetchctx_t
modifier|*
name|fctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
if|if
condition|(
name|fctx
operator|->
name|type
operator|!=
name|type
operator|||
name|fctx
operator|->
name|options
operator|!=
name|options
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|dns_name_equal
argument_list|(
operator|&
name|fctx
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_fetch
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RESOLVER
argument_list|,
name|DNS_LOGMODULE_RESOLVER
argument_list|,
name|level
argument_list|,
literal|"createfetch: %s %s"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_createfetch
parameter_list|(
name|dns_resolver_t
modifier|*
name|res
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|domain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|dns_forwarders_t
modifier|*
name|forwarders
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_fetch_t
modifier|*
modifier|*
name|fetchp
parameter_list|)
block|{
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|new_fctx
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|UNUSED
argument_list|(
name|forwarders
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|res
operator|->
name|frozen
argument_list|)
expr_stmt|;
comment|/* XXXRTH  Check for meta type */
if|if
condition|(
name|domain
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|DNS_RDATASET_VALID
argument_list|(
name|nameservers
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nameservers
operator|->
name|type
operator|==
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
block|}
else|else
name|REQUIRE
argument_list|(
name|nameservers
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|forwarders
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fetchp
operator|!=
name|NULL
operator|&&
operator|*
name|fetchp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|log_fetch
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRTH  use a mempool? 	 */
name|fetch
operator|=
name|isc_mem_get
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|bucketnum
operator|=
name|dns_name_hash
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|)
operator|%
name|res
operator|->
name|nbuckets
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|exiting
condition|)
block|{
name|result
operator|=
name|ISC_R_SHUTTINGDOWN
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_FETCHOPT_UNSHARED
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|fctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|fctxs
argument_list|)
init|;
name|fctx
operator|!=
name|NULL
condition|;
name|fctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|fctx
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|fctx_match
argument_list|(
name|fctx
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|options
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * If we didn't have a fetch, would attach to a done fetch, this 	 * fetch has already cloned its results, or if the fetch has gone 	 * "idle" (no one was interested in it), we need to start a new 	 * fetch instead of joining with the existing one. 	 */
if|if
condition|(
name|fctx
operator|==
name|NULL
operator|||
name|fctx
operator|->
name|state
operator|==
name|fetchstate_done
operator|||
name|fctx
operator|->
name|cloned
operator|||
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
condition|)
block|{
name|fctx
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|fctx_create
argument_list|(
name|res
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|domain
argument_list|,
name|nameservers
argument_list|,
name|options
argument_list|,
name|bucketnum
argument_list|,
operator|&
name|fctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
name|new_fctx
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|result
operator|=
name|fctx_join
argument_list|(
name|fctx
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fctx
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Launch this fctx. 			 */
name|event
operator|=
operator|&
name|fctx
operator|->
name|control_event
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
name|event
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_FETCHCONTROL
argument_list|,
name|fctx_start
argument_list|,
name|fctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We don't care about the result of fctx_destroy() 			 * since we know we're not exiting. 			 */
operator|(
name|void
operator|)
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|FTRACE
argument_list|(
literal|"created"
argument_list|)
expr_stmt|;
operator|*
name|fetchp
operator|=
name|fetch
expr_stmt|;
block|}
else|else
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fetch
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_cancelfetch
parameter_list|(
name|dns_fetch_t
modifier|*
name|fetch
parameter_list|)
block|{
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|isc_task_t
modifier|*
name|etask
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_FETCH_VALID
argument_list|(
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|fetch
operator|->
name|private
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|FTRACE
argument_list|(
literal|"cancelfetch"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Find the completion event for this fetch (as opposed 	 * to those for other fetches that have joined the same 	 * fctx) and send it with result = ISC_R_CANCELED. 	 */
name|event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_done
condition|)
block|{
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|fetch
operator|==
name|fetch
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|fctx
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|etask
operator|=
name|event
operator|->
name|ev_sender
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|fctx
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|etask
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The fctx continues running even if no fetches remain; 	 * the answer is still cached. 	 */
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|fctx
operator|->
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_destroyfetch
parameter_list|(
name|dns_fetch_t
modifier|*
modifier|*
name|fetchp
parameter_list|)
block|{
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|dns_resolver_t
modifier|*
name|res
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|event
decl_stmt|,
modifier|*
name|next_event
decl_stmt|;
name|fetchctx_t
modifier|*
name|fctx
decl_stmt|;
name|unsigned
name|int
name|bucketnum
decl_stmt|;
name|isc_boolean_t
name|bucket_empty
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|fetchp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fetch
operator|=
operator|*
name|fetchp
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_FETCH_VALID
argument_list|(
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
name|fctx
operator|=
name|fetch
operator|->
name|private
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_FCTX
argument_list|(
name|fctx
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|fctx
operator|->
name|res
expr_stmt|;
name|FTRACE
argument_list|(
literal|"destroyfetch"
argument_list|)
expr_stmt|;
name|bucketnum
operator|=
name|fctx
operator|->
name|bucketnum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check: the caller should have gotten its event before 	 * trying to destroy the fetch. 	 */
name|event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|state
operator|!=
name|fetchstate_done
condition|)
block|{
for|for
control|(
name|event
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fctx
operator|->
name|events
argument_list|)
init|;
name|event
operator|!=
name|NULL
condition|;
name|event
operator|=
name|next_event
control|)
block|{
name|next_event
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|event
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|event
operator|->
name|fetch
operator|!=
name|fetch
argument_list|)
expr_stmt|;
block|}
block|}
name|INSIST
argument_list|(
name|fctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|fctx
operator|->
name|references
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No one cares about the result of this fetch anymore. 		 */
if|if
condition|(
name|fctx
operator|->
name|pending
operator|==
literal|0
operator|&&
name|fctx
operator|->
name|nqueries
operator|==
literal|0
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|fctx
operator|->
name|validators
argument_list|)
operator|&&
name|SHUTTINGDOWN
argument_list|(
name|fctx
argument_list|)
condition|)
block|{
comment|/* 			 * This fctx is already shutdown; we were just 			 * waiting for the last reference to go away. 			 */
name|bucket_empty
operator|=
name|fctx_destroy
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Initiate shutdown. 			 */
name|fctx_shutdown
argument_list|(
name|fctx
argument_list|)
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|res
operator|->
name|buckets
index|[
name|bucketnum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|res
operator|->
name|mctx
argument_list|,
name|fetch
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fetchp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bucket_empty
condition|)
name|empty_bucket
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_dispatchmgr_t
modifier|*
name|dns_resolver_dispatchmgr
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|dispatchmgr
operator|)
return|;
block|}
end_function

begin_function
name|dns_dispatch_t
modifier|*
name|dns_resolver_dispatchv4
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|dispatchv4
operator|)
return|;
block|}
end_function

begin_function
name|dns_dispatch_t
modifier|*
name|dns_resolver_dispatchv6
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|dispatchv6
operator|)
return|;
block|}
end_function

begin_function
name|isc_socketmgr_t
modifier|*
name|dns_resolver_socketmgr
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|socketmgr
operator|)
return|;
block|}
end_function

begin_function
name|isc_taskmgr_t
modifier|*
name|dns_resolver_taskmgr
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|taskmgr
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_resolver_getlamettl
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|lame_ttl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setlamettl
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint32_t
name|lame_ttl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|lame_ttl
operator|=
name|lame_ttl
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_resolver_nrunning
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|resolver
operator|->
name|nlock
argument_list|)
expr_stmt|;
name|n
operator|=
name|resolver
operator|->
name|nfctx
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|nlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_addalternate
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|alt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|in_port_t
name|port
parameter_list|)
block|{
name|alternate_t
modifier|*
name|a
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|resolver
operator|->
name|frozen
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|alt
operator|==
name|NULL
operator|)
operator|^
operator|(
name|name
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|alt
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|isaddress
operator|=
name|ISC_TRUE
expr_stmt|;
name|a
operator|->
name|_u
operator|.
name|addr
operator|=
operator|*
name|alt
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|isaddress
operator|=
name|ISC_FALSE
expr_stmt|;
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|name
argument_list|,
name|resolver
operator|->
name|mctx
argument_list|,
operator|&
name|a
operator|->
name|_u
operator|.
name|_n
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
name|ISC_LINK_INIT
argument_list|(
name|a
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|resolver
operator|->
name|alternates
argument_list|,
name|a
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_setudpsize
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|isc_uint16_t
name|udpsize
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|->
name|udpsize
operator|=
name|udpsize
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint16_t
name|dns_resolver_getudpsize
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resolver
operator|->
name|udpsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_algorithm
parameter_list|(
name|void
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|algorithms
init|=
name|node
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|arg
decl_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|algorithms
argument_list|,
operator|*
name|algorithms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_resolver_reset_algorithms
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|algorithms
operator|!=
name|NULL
condition|)
name|dns_rbt_destroy
argument_list|(
operator|&
name|resolver
operator|->
name|algorithms
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|dns_resolver_disable_algorithm
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|alg
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|algorithms
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alg
operator|>
literal|255
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
if|#
directive|if
name|USE_ALGLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|algorithms
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|free_algorithm
argument_list|,
name|resolver
operator|->
name|mctx
argument_list|,
operator|&
name|resolver
operator|->
name|algorithms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|len
operator|=
name|alg
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|alg
operator|%
literal|8
operator|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|resolver
operator|->
name|algorithms
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_EXISTS
condition|)
block|{
name|algorithms
operator|=
name|node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|algorithms
operator|==
name|NULL
operator|||
name|len
operator|>
operator|*
name|algorithms
condition|)
block|{
name|new
operator|=
name|isc_mem_get
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|algorithms
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|new
argument_list|,
name|algorithms
argument_list|,
operator|*
name|algorithms
argument_list|)
expr_stmt|;
name|new
index|[
name|len
operator|-
literal|1
index|]
operator||=
name|mask
expr_stmt|;
operator|*
name|new
operator|=
name|len
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|algorithms
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|algorithms
argument_list|,
operator|*
name|algorithms
argument_list|)
expr_stmt|;
block|}
else|else
name|algorithms
index|[
name|len
operator|-
literal|1
index|]
operator||=
name|mask
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|cleanup
label|:
if|#
directive|if
name|USE_ALGLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_algorithm_supported
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|alg
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|char
modifier|*
name|algorithms
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|found
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_ALGLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|algorithms
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|result
operator|=
name|dns_rbt_findname
argument_list|(
name|resolver
operator|->
name|algorithms
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|len
operator|=
name|alg
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|alg
operator|%
literal|8
operator|)
expr_stmt|;
name|algorithms
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|len
operator|<=
operator|*
name|algorithms
operator|&&
operator|(
name|algorithms
index|[
name|len
operator|-
literal|1
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|unlock
label|:
if|#
directive|if
name|USE_ALGLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|alglock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|dst_algorithm_supported
argument_list|(
name|alg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_resolver_resetmustbesecure
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|mustbesecure
operator|!=
name|NULL
condition|)
name|dns_rbt_destroy
argument_list|(
operator|&
name|resolver
operator|->
name|mustbesecure
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|yes
init|=
name|ISC_TRUE
decl_stmt|,
name|no
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|dns_resolver_setmustbesecure
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|value
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|mustbesecure
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|resolver
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|resolver
operator|->
name|mustbesecure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|dns_rbt_addname
argument_list|(
name|resolver
operator|->
name|mustbesecure
argument_list|,
name|name
argument_list|,
name|value
condition|?
operator|&
name|yes
else|:
operator|&
name|no
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|#
directive|if
name|USE_MBSLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_resolver_getmustbesecure
parameter_list|(
name|dns_resolver_t
modifier|*
name|resolver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|value
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESOLVER
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_MBSLOCK
name|RWLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resolver
operator|->
name|mustbesecure
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|result
operator|=
name|dns_rbt_findname
argument_list|(
name|resolver
operator|->
name|mustbesecure
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|value
operator|=
operator|*
operator|(
name|isc_boolean_t
operator|*
operator|)
name|data
expr_stmt|;
name|unlock
label|:
if|#
directive|if
name|USE_MBSLOCK
name|RWUNLOCK
argument_list|(
operator|&
name|resolver
operator|->
name|mbslock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

end_unit

