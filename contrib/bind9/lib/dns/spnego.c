begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006-2011  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: spnego.c,v 1.16.10.2 2011-04-04 11:10:57 marka Exp $ */
end_comment

begin_comment
comment|/*! \file  * \brief  * Portable SPNEGO implementation.  *  * This is part of a portable implementation of the SPNEGO protocol  * (RFCs 2478 and 4178).  This implementation uses the RFC 4178 ASN.1  * module but is not a full implementation of the RFC 4178 protocol;  * at the moment, we only support GSS-TSIG with Kerberos  * authentication, so we only need enough of the SPNEGO protocol to  * support that.  *  * The files that make up this portable SPNEGO implementation are:  * \li	spnego.c	(this file)  * \li	spnego.h	(API SPNEGO exports to the rest of lib/dns)  * \li	spnego.asn1	(SPNEGO ASN.1 module)  * \li	spnego_asn1.c	(routines generated from spngo.asn1)  * \li	spnego_asn1.pl	(perl script to generate spnego_asn1.c)  *  * Everything but the functions exported in spnego.h is static, to  * avoid possible conflicts with other libraries (particularly Heimdal,  * since much of this code comes from Heimdal by way of mod_auth_kerb).  *  * spnego_asn1.c is shipped as part of lib/dns because generating it  * requires both Perl and the Heimdal ASN.1 compiler.  See  * spnego_asn1.pl for further details.  We've tried to eliminate all  * compiler warnings from the generated code, but you may see a few  * when using a compiler version we haven't tested yet.  */
end_comment

begin_comment
comment|/*  * Portions of this code were derived from mod_auth_kerb and Heimdal.  * These packages are available from:  *  *   http://modauthkerb.sourceforge.net/  *   http://www.pdc.kth.se/heimdal/  *  * and were released under the following licenses:  *  * ----------------------------------------------------------------  *  * Copyright (c) 2004 Masarykova universita  * (Masaryk University, Brno, Czech Republic)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the University nor the names of its contributors may  *    be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * ----------------------------------------------------------------  *  * Copyright (c) 1997 - 2003 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * XXXSRA We should omit this file entirely in Makefile.in via autoconf,  * but this will keep it from generating errors until that's written.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_comment
comment|/*  * XXXSRA Some of the following files are almost certainly unnecessary,  * but using this list (borrowed from gssapictx.c) gets rid of some  * whacky compilation errors when building with MSVC and should be  * harmless in any case.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/dir.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/lex.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/types.h>
end_include

begin_include
include|#
directive|include
file|<dns/keyvalues.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dst/gssapi.h>
end_include

begin_include
include|#
directive|include
file|<dst/result.h>
end_include

begin_include
include|#
directive|include
file|"dst_internal.h"
end_include

begin_comment
comment|/*  * The API we export  */
end_comment

begin_include
include|#
directive|include
file|"spnego.h"
end_include

begin_comment
comment|/* asn1_err.h */
end_comment

begin_comment
comment|/* Generated from ../../../lib/asn1/asn1_err.et */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ERROR_TABLE_BASE_asn1
end_ifndef

begin_comment
comment|/* these may be brought in already via gssapi_krb5.h */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|asn1_error_number
block|{
name|ASN1_BAD_TIMEFORMAT
init|=
literal|1859794432
block|,
name|ASN1_MISSING_FIELD
init|=
literal|1859794433
block|,
name|ASN1_MISPLACED_FIELD
init|=
literal|1859794434
block|,
name|ASN1_TYPE_MISMATCH
init|=
literal|1859794435
block|,
name|ASN1_OVERFLOW
init|=
literal|1859794436
block|,
name|ASN1_OVERRUN
init|=
literal|1859794437
block|,
name|ASN1_BAD_ID
init|=
literal|1859794438
block|,
name|ASN1_BAD_LENGTH
init|=
literal|1859794439
block|,
name|ASN1_BAD_FORMAT
init|=
literal|1859794440
block|,
name|ASN1_PARSE_ERROR
init|=
literal|1859794441
block|}
name|asn1_error_number
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ERROR_TABLE_BASE_asn1
value|1859794432
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__asn1_common_definitions__
end_define

begin_typedef
typedef|typedef
struct|struct
name|octet_string
block|{
name|size_t
name|length
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
name|octet_string
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|general_string
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|utf8_string
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|oid
block|{
name|size_t
name|length
decl_stmt|;
name|unsigned
modifier|*
name|components
decl_stmt|;
block|}
name|oid
typedef|;
end_typedef

begin_comment
comment|/* der.h */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ASN1_C_UNIV
init|=
literal|0
block|,
name|ASN1_C_APPL
init|=
literal|1
block|,
name|ASN1_C_CONTEXT
init|=
literal|2
block|,
name|ASN1_C_PRIVATE
init|=
literal|3
block|}
name|Der_class
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|PRIM
init|=
literal|0
block|,
name|CONS
init|=
literal|1
block|}
name|Der_type
typedef|;
end_typedef

begin_comment
comment|/* Universal tags */
end_comment

begin_enum
enum|enum
block|{
name|UT_Boolean
init|=
literal|1
block|,
name|UT_Integer
init|=
literal|2
block|,
name|UT_BitString
init|=
literal|3
block|,
name|UT_OctetString
init|=
literal|4
block|,
name|UT_Null
init|=
literal|5
block|,
name|UT_OID
init|=
literal|6
block|,
name|UT_Enumerated
init|=
literal|10
block|,
name|UT_Sequence
init|=
literal|16
block|,
name|UT_Set
init|=
literal|17
block|,
name|UT_PrintableString
init|=
literal|19
block|,
name|UT_IA5String
init|=
literal|22
block|,
name|UT_UTCTime
init|=
literal|23
block|,
name|UT_GeneralizedTime
init|=
literal|24
block|,
name|UT_VisibleString
init|=
literal|26
block|,
name|UT_GeneralString
init|=
literal|27
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ASN1_INDEFINITE
value|0xdce0deed
end_define

begin_function_decl
specifier|static
name|int
name|der_get_length
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
modifier|*
name|val
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_get_octet_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|octet_string
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_get_oid
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|oid
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_get_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
modifier|*
name|class
parameter_list|,
name|Der_type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|tag
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_match_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_match_tag_and_length
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
name|length_ret
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_oid
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|oid
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_enumerated
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|num
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_octet_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|octet_string
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_put_int
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|val
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_put_length
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
name|val
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_put_octet_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|octet_string
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_put_oid
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|oid
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_put_tag
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|der_put_length_and_tag
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|Der_class
parameter_list|,
name|Der_type
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|encode_enumerated
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|encode_octet_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|octet_string
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|encode_oid
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|oid
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_octet_string
parameter_list|(
name|octet_string
modifier|*
name|k
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_oid
parameter_list|(
name|oid
modifier|*
name|k
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|length_len
parameter_list|(
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fix_dce
parameter_list|(
name|size_t
name|reallen
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Include stuff generated by the ASN.1 compiler.  */
end_comment

begin_include
include|#
directive|include
file|"spnego_asn1.c"
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|gss_krb5_mech_oid_bytes
index|[]
init|=
block|{
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x86
block|,
literal|0xf7
block|,
literal|0x12
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID_desc
name|gss_krb5_mech_oid_desc
init|=
block|{
sizeof|sizeof
argument_list|(
name|gss_krb5_mech_oid_bytes
argument_list|)
block|,
name|gss_krb5_mech_oid_bytes
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID
name|GSS_KRB5_MECH
init|=
operator|&
name|gss_krb5_mech_oid_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|gss_mskrb5_mech_oid_bytes
index|[]
init|=
block|{
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x82
block|,
literal|0xf7
block|,
literal|0x12
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID_desc
name|gss_mskrb5_mech_oid_desc
init|=
block|{
sizeof|sizeof
argument_list|(
name|gss_mskrb5_mech_oid_bytes
argument_list|)
block|,
name|gss_mskrb5_mech_oid_bytes
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID
name|GSS_MSKRB5_MECH
init|=
operator|&
name|gss_mskrb5_mech_oid_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|gss_spnego_mech_oid_bytes
index|[]
init|=
block|{
literal|0x2b
block|,
literal|0x06
block|,
literal|0x01
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID_desc
name|gss_spnego_mech_oid_desc
init|=
block|{
sizeof|sizeof
argument_list|(
name|gss_spnego_mech_oid_bytes
argument_list|)
block|,
name|gss_spnego_mech_oid_bytes
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID
name|GSS_SPNEGO_MECH
init|=
operator|&
name|gss_spnego_mech_oid_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spnegokrb5_locl.h */
end_comment

begin_function_decl
specifier|static
name|OM_uint32
name|gssapi_spnego_encapsulate
parameter_list|(
name|OM_uint32
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|gss_buffer_t
parameter_list|,
specifier|const
name|gss_OID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|OM_uint32
name|gssapi_spnego_decapsulate
parameter_list|(
name|OM_uint32
modifier|*
parameter_list|,
name|gss_buffer_t
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
specifier|const
name|gss_OID
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* mod_auth_kerb.c */
end_comment

begin_function
specifier|static
name|int
name|cmp_gss_type
parameter_list|(
name|gss_buffer_t
name|token
parameter_list|,
name|gss_OID
name|oid
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|length
operator|==
literal|0U
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|=
name|token
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x60
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|len
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|&
literal|0x7f
operator|)
operator|>
literal|4U
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
name|len
operator|&
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x06
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|OM_uint32
operator|)
operator|*
name|p
operator|++
operator|)
operator|!=
name|oid
operator|->
name|length
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
return|return
operator|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|oid
operator|->
name|elements
argument_list|,
name|oid
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* accept_sec_context.c */
end_comment

begin_comment
comment|/*  * SPNEGO wrapper for Kerberos5 GSS-API kouril@ics.muni.cz, 2003 (mostly  * based on Heimdal code)  */
end_comment

begin_function
specifier|static
name|OM_uint32
name|code_NegTokenArg
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
specifier|const
name|NegTokenResp
modifier|*
name|resp
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|size_t
modifier|*
name|outbuf_size
parameter_list|)
block|{
name|OM_uint32
name|ret
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|,
name|buf_len
init|=
literal|0
decl_stmt|;
name|buf_size
operator|=
literal|1024
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
do|do
block|{
name|ret
operator|=
name|encode_NegTokenResp
argument_list|(
name|buf
operator|+
name|buf_size
operator|-
literal|1
argument_list|,
name|buf_size
argument_list|,
name|resp
argument_list|,
operator|&
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|size_t
name|tmp
decl_stmt|;
name|ret
operator|=
name|der_put_length_and_tag
argument_list|(
name|buf
operator|+
name|buf_size
operator|-
name|buf_len
operator|-
literal|1
argument_list|,
name|buf_size
operator|-
name|buf_len
argument_list|,
name|buf_len
argument_list|,
name|ASN1_C_CONTEXT
argument_list|,
name|CONS
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|buf_len
operator|+=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ASN1_OVERFLOW
condition|)
block|{
name|u_char
modifier|*
name|tmp
decl_stmt|;
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
name|buf
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
block|}
block|}
do|while
condition|(
name|ret
operator|==
name|ASN1_OVERFLOW
condition|)
do|;
operator|*
name|outbuf
operator|=
name|malloc
argument_list|(
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|outbuf
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|outbuf
argument_list|,
name|buf
operator|+
name|buf_size
operator|-
name|buf_len
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
operator|*
name|outbuf_size
operator|=
name|buf_len
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|send_reject
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|)
block|{
name|NegTokenResp
name|resp
decl_stmt|;
name|OM_uint32
name|ret
decl_stmt|;
name|resp
operator|.
name|negState
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
operator|.
name|negState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|negState
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
operator|*
operator|(
name|resp
operator|.
name|negState
operator|)
operator|=
name|reject
expr_stmt|;
name|resp
operator|.
name|supportedMech
operator|=
name|NULL
expr_stmt|;
name|resp
operator|.
name|responseToken
operator|=
name|NULL
expr_stmt|;
name|resp
operator|.
name|mechListMIC
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|code_NegTokenArg
argument_list|(
name|minor_status
argument_list|,
operator|&
name|resp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|output_token
operator|->
name|value
argument_list|,
operator|&
name|output_token
operator|->
name|length
argument_list|)
expr_stmt|;
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
name|GSS_S_BAD_MECH
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|send_accept
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|gss_buffer_t
name|mech_token
parameter_list|,
specifier|const
name|gss_OID
name|pref
parameter_list|)
block|{
name|NegTokenResp
name|resp
decl_stmt|;
name|OM_uint32
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|resp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|.
name|negState
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
operator|.
name|negState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|negState
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
operator|*
operator|(
name|resp
operator|.
name|negState
operator|)
operator|=
name|accept_completed
expr_stmt|;
name|resp
operator|.
name|supportedMech
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
operator|.
name|supportedMech
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|supportedMech
operator|==
name|NULL
condition|)
block|{
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
name|ret
operator|=
name|der_get_oid
argument_list|(
name|pref
operator|->
name|elements
argument_list|,
name|pref
operator|->
name|length
argument_list|,
name|resp
operator|.
name|supportedMech
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|mech_token
operator|!=
name|NULL
operator|&&
name|mech_token
operator|->
name|length
operator|!=
literal|0U
condition|)
block|{
name|resp
operator|.
name|responseToken
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
operator|.
name|responseToken
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|responseToken
operator|==
name|NULL
condition|)
block|{
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
name|resp
operator|.
name|responseToken
operator|->
name|length
operator|=
name|mech_token
operator|->
name|length
expr_stmt|;
name|resp
operator|.
name|responseToken
operator|->
name|data
operator|=
name|mech_token
operator|->
name|value
expr_stmt|;
block|}
name|ret
operator|=
name|code_NegTokenArg
argument_list|(
name|minor_status
argument_list|,
operator|&
name|resp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|output_token
operator|->
name|value
argument_list|,
operator|&
name|output_token
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|responseToken
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|resp
operator|.
name|responseToken
argument_list|)
expr_stmt|;
name|resp
operator|.
name|responseToken
operator|=
name|NULL
expr_stmt|;
block|}
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|OM_uint32
name|gss_accept_sec_context_spnego
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|context_handle
parameter_list|,
specifier|const
name|gss_cred_id_t
name|acceptor_cred_handle
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token_buffer
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
name|gss_name_t
modifier|*
name|src_name
parameter_list|,
name|gss_OID
modifier|*
name|mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|,
name|gss_cred_id_t
modifier|*
name|delegated_cred_handle
parameter_list|)
block|{
name|NegTokenInit
name|init_token
decl_stmt|;
name|OM_uint32
name|major_status
decl_stmt|;
name|OM_uint32
name|minor_status2
decl_stmt|;
name|gss_buffer_desc
name|ibuf
decl_stmt|,
name|obuf
decl_stmt|;
name|gss_buffer_t
name|ot
init|=
name|NULL
decl_stmt|;
name|gss_OID
name|pref
init|=
name|GSS_KRB5_MECH
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|taglen
decl_stmt|,
name|ni_len
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* 	 * Before doing anything else, see whether this is a SPNEGO 	 * PDU.  If not, dispatch to the GSSAPI library and get out. 	 */
if|if
condition|(
name|cmp_gss_type
argument_list|(
name|input_token_buffer
argument_list|,
name|GSS_SPNEGO_MECH
argument_list|)
condition|)
return|return
operator|(
name|gss_accept_sec_context
argument_list|(
name|minor_status
argument_list|,
name|context_handle
argument_list|,
name|acceptor_cred_handle
argument_list|,
name|input_token_buffer
argument_list|,
name|input_chan_bindings
argument_list|,
name|src_name
argument_list|,
name|mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|,
name|delegated_cred_handle
argument_list|)
operator|)
return|;
comment|/* 	 * If we get here, it's SPNEGO. 	 */
name|memset
argument_list|(
operator|&
name|init_token
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|init_token
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gssapi_spnego_decapsulate
argument_list|(
name|minor_status
argument_list|,
name|input_token_buffer
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|GSS_SPNEGO_MECH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|der_match_tag_and_length
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
name|ASN1_C_CONTEXT
argument_list|,
name|CONS
argument_list|,
literal|0
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|decode_NegTokenInit
argument_list|(
name|buf
operator|+
name|taglen
argument_list|,
name|len
argument_list|,
operator|&
name|init_token
argument_list|,
operator|&
name|ni_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|init_token
operator|.
name|mechTypes
operator|.
name|len
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|char
name|mechbuf
index|[
literal|17
index|]
decl_stmt|;
name|size_t
name|mech_len
decl_stmt|;
name|ret
operator|=
name|der_put_oid
argument_list|(
name|mechbuf
operator|+
sizeof|sizeof
argument_list|(
name|mechbuf
argument_list|)
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mechbuf
argument_list|)
argument_list|,
operator|&
name|init_token
operator|.
name|mechTypes
operator|.
name|val
index|[
name|i
index|]
argument_list|,
operator|&
name|mech_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|mech_len
operator|==
name|GSS_KRB5_MECH
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|GSS_KRB5_MECH
operator|->
name|elements
argument_list|,
name|mechbuf
operator|+
sizeof|sizeof
argument_list|(
name|mechbuf
argument_list|)
operator|-
name|mech_len
argument_list|,
name|mech_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mech_len
operator|==
name|GSS_MSKRB5_MECH
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|GSS_MSKRB5_MECH
operator|->
name|elements
argument_list|,
name|mechbuf
operator|+
sizeof|sizeof
argument_list|(
name|mechbuf
argument_list|)
operator|-
name|mech_len
argument_list|,
name|mech_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|pref
operator|=
name|GSS_MSKRB5_MECH
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|send_reject
argument_list|(
name|minor_status
argument_list|,
name|output_token
argument_list|)
operator|)
return|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|init_token
operator|.
name|mechToken
operator|!=
name|NULL
condition|)
block|{
name|ibuf
operator|.
name|length
operator|=
name|init_token
operator|.
name|mechToken
operator|->
name|length
expr_stmt|;
name|ibuf
operator|.
name|value
operator|=
name|init_token
operator|.
name|mechToken
operator|->
name|data
expr_stmt|;
name|major_status
operator|=
name|gss_accept_sec_context
argument_list|(
name|minor_status
argument_list|,
name|context_handle
argument_list|,
name|acceptor_cred_handle
argument_list|,
operator|&
name|ibuf
argument_list|,
name|input_chan_bindings
argument_list|,
name|src_name
argument_list|,
name|mech_type
argument_list|,
operator|&
name|obuf
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|,
name|delegated_cred_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|major_status
argument_list|)
condition|)
block|{
name|send_reject
argument_list|(
operator|&
name|minor_status2
argument_list|,
name|output_token
argument_list|)
expr_stmt|;
return|return
operator|(
name|major_status
operator|)
return|;
block|}
name|ot
operator|=
operator|&
name|obuf
expr_stmt|;
block|}
name|ret
operator|=
name|send_accept
argument_list|(
operator|&
name|minor_status2
argument_list|,
name|output_token
argument_list|,
name|ot
argument_list|,
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ot
operator|!=
name|NULL
operator|&&
name|ot
operator|->
name|length
operator|!=
literal|0U
condition|)
name|gss_release_buffer
argument_list|(
operator|&
name|minor_status2
argument_list|,
name|ot
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* decapsulate.c */
end_comment

begin_function
specifier|static
name|OM_uint32
name|gssapi_verify_mech_header
parameter_list|(
name|u_char
modifier|*
modifier|*
name|str
parameter_list|,
name|size_t
name|total_len
parameter_list|,
specifier|const
name|gss_OID
name|mech
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|len_len
decl_stmt|,
name|mech_len
decl_stmt|,
name|foo
decl_stmt|;
name|int
name|e
decl_stmt|;
name|u_char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
name|total_len
operator|<
literal|1U
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x60
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|total_len
operator|-
literal|1
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|len_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|||
literal|1
operator|+
name|len_len
operator|+
name|len
operator|!=
name|total_len
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
name|len_len
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x06
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|total_len
operator|-
literal|1
operator|-
name|len_len
operator|-
literal|1
argument_list|,
operator|&
name|mech_len
argument_list|,
operator|&
name|foo
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
name|foo
expr_stmt|;
if|if
condition|(
name|mech_len
operator|!=
name|mech
operator|->
name|length
condition|)
return|return
operator|(
name|GSS_S_BAD_MECH
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|mech
operator|->
name|elements
argument_list|,
name|mech
operator|->
name|length
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|GSS_S_BAD_MECH
operator|)
return|;
name|p
operator|+=
name|mech_len
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the GSS-API wrapping from `in_token' giving `buf and buf_size' Does  * not copy data, so just free `in_token'.  */
end_comment

begin_function
specifier|static
name|OM_uint32
name|gssapi_spnego_decapsulate
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_buffer_t
name|input_token_buffer
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buf_len
parameter_list|,
specifier|const
name|gss_OID
name|mech
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|OM_uint32
name|ret
decl_stmt|;
name|p
operator|=
name|input_token_buffer
operator|->
name|value
expr_stmt|;
name|ret
operator|=
name|gssapi_verify_mech_header
argument_list|(
operator|&
name|p
argument_list|,
name|input_token_buffer
operator|->
name|length
argument_list|,
name|mech
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
operator|*
name|buf_len
operator|=
name|input_token_buffer
operator|->
name|length
operator|-
operator|(
name|p
operator|-
operator|(
name|u_char
operator|*
operator|)
name|input_token_buffer
operator|->
name|value
operator|)
expr_stmt|;
operator|*
name|buf
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* der_free.c */
end_comment

begin_function
specifier|static
name|void
name|free_octet_string
parameter_list|(
name|octet_string
modifier|*
name|k
parameter_list|)
block|{
name|free
argument_list|(
name|k
operator|->
name|data
argument_list|)
expr_stmt|;
name|k
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_oid
parameter_list|(
name|oid
modifier|*
name|k
parameter_list|)
block|{
name|free
argument_list|(
name|k
operator|->
name|components
argument_list|)
expr_stmt|;
name|k
operator|->
name|components
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* der_get.c */
end_comment

begin_comment
comment|/*  * All decoding functions take a pointer `p' to first position in which to  * read, from the left, `len' which means the maximum number of characters we  * are able to read, `ret' were the value will be returned and `size' where  * the number of used bytes is stored. Either 0 or an error code is returned.  */
end_comment

begin_function
specifier|static
name|int
name|der_get_unsigned
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
modifier|*
name|ret
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|val
init|=
literal|0
decl_stmt|;
name|size_t
name|oldlen
init|=
name|len
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|val
operator|=
name|val
operator|*
literal|256
operator|+
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|ret
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|oldlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_get_int
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
name|size_t
name|oldlen
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0U
condition|)
block|{
name|val
operator|=
operator|(
name|signed
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|len
condition|)
name|val
operator|=
name|val
operator|*
literal|256
operator|+
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|ret
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|oldlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_get_length
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
modifier|*
name|val
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|v
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0U
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
operator|--
name|len
expr_stmt|;
name|v
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|<
literal|128U
condition|)
block|{
operator|*
name|val
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|e
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|unsigned
name|tmp
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|0x80U
condition|)
block|{
operator|*
name|val
operator|=
name|ASN1_INDEFINITE
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|v
operator|&=
literal|0x7F
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|v
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
name|e
operator|=
name|der_get_unsigned
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
operator|*
name|val
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|l
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_get_octet_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|octet_string
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|data
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|data
operator|==
name|NULL
operator|&&
name|data
operator|->
name|length
operator|!=
literal|0U
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memcpy
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_get_oid
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|oid
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|size_t
name|oldlen
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
name|data
operator|->
name|components
operator|=
name|malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|data
operator|->
name|components
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|components
operator|==
name|NULL
operator|&&
name|len
operator|!=
literal|0U
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|data
operator|->
name|components
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|p
operator|)
operator|/
literal|40
expr_stmt|;
name|data
operator|->
name|components
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|p
operator|)
operator|%
literal|40
expr_stmt|;
operator|--
name|len
expr_stmt|;
operator|++
name|p
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|2
init|;
name|len
operator|>
literal|0U
condition|;
operator|++
name|n
control|)
block|{
name|unsigned
name|u
init|=
literal|0
decl_stmt|;
do|do
block|{
operator|--
name|len
expr_stmt|;
name|u
operator|=
name|u
operator|*
literal|128
operator|+
operator|(
operator|*
name|p
operator|++
operator|%
literal|128
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|0U
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|&
literal|0x80
condition|)
do|;
name|data
operator|->
name|components
index|[
name|n
index|]
operator|=
name|u
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|&
literal|0x80
condition|)
block|{
name|free_oid
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
block|}
name|data
operator|->
name|length
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|oldlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_get_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
modifier|*
name|class
parameter_list|,
name|Der_type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|tag
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
operator|*
name|class
operator|=
call|(
name|Der_class
call|)
argument_list|(
operator|(
operator|(
operator|*
name|p
operator|)
operator|>>
literal|6
operator|)
operator|&
literal|0x03
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
call|(
name|Der_type
call|)
argument_list|(
operator|(
operator|(
operator|*
name|p
operator|)
operator|>>
literal|5
operator|)
operator|&
literal|0x01
argument_list|)
expr_stmt|;
operator|*
name|tag
operator|=
operator|(
operator|*
name|p
operator|)
operator|&
literal|0x1F
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_match_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
name|Der_class
name|thisclass
decl_stmt|;
name|Der_type
name|thistype
decl_stmt|;
name|int
name|thistag
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_get_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|thisclass
argument_list|,
operator|&
name|thistype
argument_list|,
operator|&
name|thistag
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
if|if
condition|(
name|class
operator|!=
name|thisclass
operator|||
name|type
operator|!=
name|thistype
condition|)
return|return
operator|(
name|ASN1_BAD_ID
operator|)
return|;
if|if
condition|(
name|tag
operator|>
name|thistag
condition|)
return|return
operator|(
name|ASN1_MISPLACED_FIELD
operator|)
return|;
if|if
condition|(
name|tag
operator|<
name|thistag
condition|)
return|return
operator|(
name|ASN1_MISSING_FIELD
operator|)
return|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_match_tag_and_length
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
name|length_ret
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_match_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|tag
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|length_ret
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_enumerated
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|num
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|,
name|reallen
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_match_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_C_UNIV
argument_list|,
name|PRIM
argument_list|,
name|UT_Enumerated
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|reallen
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_get_int
argument_list|(
name|p
argument_list|,
name|reallen
argument_list|,
name|num
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_octet_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|octet_string
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|e
operator|=
name|der_match_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_C_UNIV
argument_list|,
name|PRIM
argument_list|,
name|UT_OctetString
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|slen
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|slen
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
name|e
operator|=
name|der_get_octet_string
argument_list|(
name|p
argument_list|,
name|slen
argument_list|,
name|k
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_oid
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|oid
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|e
operator|=
name|der_match_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_C_UNIV
argument_list|,
name|PRIM
argument_list|,
name|UT_OID
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|slen
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|slen
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
name|e
operator|=
name|der_get_oid
argument_list|(
name|p
argument_list|,
name|slen
argument_list|,
name|k
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fix_dce
parameter_list|(
name|size_t
name|reallen
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|reallen
operator|==
name|ASN1_INDEFINITE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|len
operator|<
name|reallen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|len
operator|=
name|reallen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* der_length.c */
end_comment

begin_function
specifier|static
name|size_t
name|len_unsigned
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
do|do
block|{
operator|++
name|ret
expr_stmt|;
name|val
operator|/=
literal|256
expr_stmt|;
block|}
do|while
condition|(
name|val
condition|)
do|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|length_len
parameter_list|(
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|128U
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|len_unsigned
argument_list|(
name|len
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* der_put.c */
end_comment

begin_comment
comment|/*  * All encoding functions take a pointer `p' to first position in which to  * write, from the right, `len' which means the maximum number of characters  * we are able to write.  The function returns the number of characters  * written in `size' (if non-NULL). The return value is 0 or an error.  */
end_comment

begin_function
specifier|static
name|int
name|der_put_unsigned
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|val
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base
init|=
name|p
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
while|while
condition|(
name|len
operator|>
literal|0U
operator|&&
name|val
condition|)
block|{
operator|*
name|p
operator|--
operator|=
name|val
operator|%
literal|256
expr_stmt|;
name|val
operator|/=
literal|256
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
else|else
block|{
operator|*
name|size
operator|=
name|base
operator|-
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
else|else
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|*
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|der_put_int
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|val
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base
init|=
name|p
decl_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
block|{
do|do
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
name|val
operator|%
literal|256
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|val
operator|/=
literal|256
expr_stmt|;
block|}
do|while
condition|(
name|val
condition|)
do|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>=
literal|128
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
literal|0
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
operator|~
name|val
expr_stmt|;
do|do
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
operator|~
operator|(
name|val
operator|%
literal|256
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|val
operator|/=
literal|256
expr_stmt|;
block|}
do|while
condition|(
name|val
condition|)
do|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<
literal|128
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
literal|0xff
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|base
operator|-
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_put_length
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
name|val
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|128U
condition|)
block|{
operator|*
name|p
operator|=
name|val
expr_stmt|;
operator|*
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_put_unsigned
argument_list|(
name|p
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|val
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
operator|*
name|p
operator|=
literal|0x80
operator||
name|l
expr_stmt|;
operator|*
name|size
operator|=
name|l
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|der_put_octet_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|octet_string
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
name|data
operator|->
name|length
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
name|p
operator|-=
name|data
operator|->
name|length
expr_stmt|;
name|len
operator|-=
name|data
operator|->
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|data
operator|->
name|data
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|data
operator|->
name|length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_put_oid
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|oid
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base
init|=
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|data
operator|->
name|length
operator|-
literal|1
init|;
name|n
operator|>=
literal|2
condition|;
operator|--
name|n
control|)
block|{
name|unsigned
name|u
init|=
name|data
operator|->
name|components
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
name|u
operator|%
literal|128
expr_stmt|;
name|u
operator|/=
literal|128
expr_stmt|;
operator|--
name|len
expr_stmt|;
while|while
condition|(
name|u
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
literal|128
operator|+
name|u
operator|%
literal|128
expr_stmt|;
name|u
operator|/=
literal|128
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|--
operator|=
literal|40
operator|*
name|data
operator|->
name|components
index|[
literal|0
index|]
operator|+
name|data
operator|->
name|components
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|size
operator|=
name|base
operator|-
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_put_tag
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|1U
condition|)
return|return
operator|(
name|ASN1_OVERFLOW
operator|)
return|;
operator|*
name|p
operator|=
operator|(
name|class
operator|<<
literal|6
operator|)
operator||
operator|(
name|type
operator|<<
literal|5
operator|)
operator||
name|tag
expr_stmt|;
comment|/* XXX */
operator|*
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|der_put_length_and_tag
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
name|len_val
parameter_list|,
name|Der_class
name|class
parameter_list|,
name|Der_type
name|type
parameter_list|,
name|int
name|tag
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_put_length
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|len_val
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_put_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|tag
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_enumerated
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|num
init|=
operator|*
operator|(
specifier|const
name|unsigned
operator|*
operator|)
name|data
decl_stmt|;
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_put_int
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|num
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_put_length_and_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|l
argument_list|,
name|ASN1_C_UNIV
argument_list|,
name|PRIM
argument_list|,
name|UT_Enumerated
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_octet_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|octet_string
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_put_octet_string
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|k
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_put_length_and_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|l
argument_list|,
name|ASN1_C_UNIV
argument_list|,
name|PRIM
argument_list|,
name|UT_OctetString
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_oid
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|oid
modifier|*
name|k
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|;
name|e
operator|=
name|der_put_oid
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|k
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
name|e
operator|=
name|der_put_length_and_tag
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|l
argument_list|,
name|ASN1_C_UNIV
argument_list|,
name|PRIM
argument_list|,
name|UT_OID
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|p
operator|-=
name|l
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|ret
operator|+=
name|l
expr_stmt|;
operator|*
name|size
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* encapsulate.c */
end_comment

begin_function
specifier|static
name|void
name|gssapi_encap_length
parameter_list|(
name|size_t
name|data_len
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|size_t
modifier|*
name|total_len
parameter_list|,
specifier|const
name|gss_OID
name|mech
parameter_list|)
block|{
name|size_t
name|len_len
decl_stmt|;
operator|*
name|len
operator|=
literal|1
operator|+
literal|1
operator|+
name|mech
operator|->
name|length
operator|+
name|data_len
expr_stmt|;
name|len_len
operator|=
name|length_len
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
operator|*
name|total_len
operator|=
literal|1
operator|+
name|len_len
operator|+
operator|*
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|gssapi_mech_make_header
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|gss_OID
name|mech
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
name|size_t
name|len_len
decl_stmt|,
name|foo
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x60
expr_stmt|;
name|len_len
operator|=
name|length_len
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|e
operator|=
name|der_put_length
argument_list|(
name|p
operator|+
name|len_len
operator|-
literal|1
argument_list|,
name|len_len
argument_list|,
name|len
argument_list|,
operator|&
name|foo
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|||
name|foo
operator|!=
name|len_len
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|+=
name|len_len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x06
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|mech
operator|->
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|mech
operator|->
name|elements
argument_list|,
name|mech
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|mech
operator|->
name|length
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give it a krb5_data and it will encapsulate with extra GSS-API wrappings.  */
end_comment

begin_function
specifier|static
name|OM_uint32
name|gssapi_spnego_encapsulate
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buf_size
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
specifier|const
name|gss_OID
name|mech
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|outer_len
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|gssapi_encap_length
argument_list|(
name|buf_size
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|outer_len
argument_list|,
name|mech
argument_list|)
expr_stmt|;
name|output_token
operator|->
name|length
operator|=
name|outer_len
expr_stmt|;
name|output_token
operator|->
name|value
operator|=
name|malloc
argument_list|(
name|outer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_token
operator|->
name|value
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
name|p
operator|=
name|gssapi_mech_make_header
argument_list|(
name|output_token
operator|->
name|value
argument_list|,
name|len
argument_list|,
name|mech
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|output_token
operator|->
name|length
operator|!=
literal|0U
condition|)
name|gss_release_buffer
argument_list|(
name|minor_status
argument_list|,
name|output_token
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* init_sec_context.c */
end_comment

begin_comment
comment|/*  * SPNEGO wrapper for Kerberos5 GSS-API kouril@ics.muni.cz, 2003 (mostly  * based on Heimdal code)  */
end_comment

begin_function
specifier|static
name|int
name|add_mech
parameter_list|(
name|MechTypeList
modifier|*
name|mech_list
parameter_list|,
name|gss_OID
name|mech
parameter_list|)
block|{
name|MechType
modifier|*
name|tmp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
name|mech_list
operator|->
name|val
argument_list|,
operator|(
name|mech_list
operator|->
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mech_list
operator|->
name|val
operator|=
name|tmp
expr_stmt|;
name|ret
operator|=
name|der_get_oid
argument_list|(
name|mech
operator|->
name|elements
argument_list|,
name|mech
operator|->
name|length
argument_list|,
operator|&
name|mech_list
operator|->
name|val
index|[
name|mech_list
operator|->
name|len
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|mech_list
operator|->
name|len
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return the length of the mechanism in token or -1  * (which implies that the token was bad - GSS_S_DEFECTIVE_TOKEN  */
end_comment

begin_function
specifier|static
name|ssize_t
name|gssapi_krb5_get_mech
parameter_list|(
specifier|const
name|u_char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|total_len
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|mech_ret
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|len_len
decl_stmt|,
name|mech_len
decl_stmt|,
name|foo
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
name|int
name|e
decl_stmt|;
if|if
condition|(
name|total_len
operator|<
literal|1U
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x60
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|total_len
operator|-
literal|1
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|len_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|||
literal|1
operator|+
name|len_len
operator|+
name|len
operator|!=
name|total_len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|+=
name|len_len
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x06
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|e
operator|=
name|der_get_length
argument_list|(
name|p
argument_list|,
name|total_len
operator|-
literal|1
operator|-
name|len_len
operator|-
literal|1
argument_list|,
operator|&
name|mech_len
argument_list|,
operator|&
name|foo
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|+=
name|foo
expr_stmt|;
operator|*
name|mech_ret
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|mech_len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|spnego_initial
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
specifier|const
name|gss_cred_id_t
name|initiator_cred_handle
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|context_handle
parameter_list|,
specifier|const
name|gss_name_t
name|target_name
parameter_list|,
specifier|const
name|gss_OID
name|mech_type
parameter_list|,
name|OM_uint32
name|req_flags
parameter_list|,
name|OM_uint32
name|time_req
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token
parameter_list|,
name|gss_OID
modifier|*
name|actual_mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|)
block|{
name|NegTokenInit
name|token_init
decl_stmt|;
name|OM_uint32
name|major_status
decl_stmt|,
name|minor_status2
decl_stmt|;
name|gss_buffer_desc
name|krb5_output_token
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|mech_type
expr_stmt|;
name|memset
argument_list|(
operator|&
name|token_init
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|token_init
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|add_mech
argument_list|(
operator|&
name|token_init
operator|.
name|mechTypes
argument_list|,
name|GSS_KRB5_MECH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|major_status
operator|=
name|gss_init_sec_context
argument_list|(
name|minor_status
argument_list|,
name|initiator_cred_handle
argument_list|,
name|context_handle
argument_list|,
name|target_name
argument_list|,
name|GSS_KRB5_MECH
argument_list|,
name|req_flags
argument_list|,
name|time_req
argument_list|,
name|input_chan_bindings
argument_list|,
name|input_token
argument_list|,
name|actual_mech_type
argument_list|,
operator|&
name|krb5_output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|major_status
argument_list|)
condition|)
block|{
name|ret
operator|=
name|major_status
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|krb5_output_token
operator|.
name|length
operator|>
literal|0U
condition|)
block|{
name|token_init
operator|.
name|mechToken
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|token_init
operator|.
name|mechToken
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_init
operator|.
name|mechToken
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|token_init
operator|.
name|mechToken
operator|->
name|data
operator|=
name|krb5_output_token
operator|.
name|value
expr_stmt|;
name|token_init
operator|.
name|mechToken
operator|->
name|length
operator|=
name|krb5_output_token
operator|.
name|length
expr_stmt|;
block|}
comment|/* 	 * The MS implementation of SPNEGO seems to not like the mechListMIC 	 * field, so we omit it (it's optional anyway) 	 */
name|buf_size
operator|=
literal|1024
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|encode_NegTokenInit
argument_list|(
name|buf
operator|+
name|buf_size
operator|-
literal|1
argument_list|,
name|buf_size
argument_list|,
operator|&
name|token_init
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|size_t
name|tmp
decl_stmt|;
name|ret
operator|=
name|der_put_length_and_tag
argument_list|(
name|buf
operator|+
name|buf_size
operator|-
name|len
operator|-
literal|1
argument_list|,
name|buf_size
operator|-
name|len
argument_list|,
name|len
argument_list|,
name|ASN1_C_CONTEXT
argument_list|,
name|CONS
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|len
operator|+=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ASN1_OVERFLOW
condition|)
block|{
name|u_char
modifier|*
name|tmp
decl_stmt|;
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|buf
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
block|}
do|while
condition|(
name|ret
operator|==
name|ASN1_OVERFLOW
condition|)
do|;
name|ret
operator|=
name|gssapi_spnego_encapsulate
argument_list|(
name|minor_status
argument_list|,
name|buf
operator|+
name|buf_size
operator|-
name|len
argument_list|,
name|len
argument_list|,
name|output_token
argument_list|,
name|GSS_SPNEGO_MECH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GSS_S_COMPLETE
condition|)
name|ret
operator|=
name|major_status
expr_stmt|;
name|end
label|:
if|if
condition|(
name|token_init
operator|.
name|mechToken
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|token_init
operator|.
name|mechToken
argument_list|)
expr_stmt|;
name|token_init
operator|.
name|mechToken
operator|=
name|NULL
expr_stmt|;
block|}
name|free_NegTokenInit
argument_list|(
operator|&
name|token_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb5_output_token
operator|.
name|length
operator|!=
literal|0U
condition|)
name|gss_release_buffer
argument_list|(
operator|&
name|minor_status2
argument_list|,
operator|&
name|krb5_output_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|spnego_reply
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
specifier|const
name|gss_cred_id_t
name|initiator_cred_handle
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|context_handle
parameter_list|,
specifier|const
name|gss_name_t
name|target_name
parameter_list|,
specifier|const
name|gss_OID
name|mech_type
parameter_list|,
name|OM_uint32
name|req_flags
parameter_list|,
name|OM_uint32
name|time_req
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token
parameter_list|,
name|gss_OID
modifier|*
name|actual_mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|)
block|{
name|OM_uint32
name|ret
decl_stmt|;
name|NegTokenResp
name|resp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|;
name|u_char
name|oidbuf
index|[
literal|17
index|]
decl_stmt|;
name|size_t
name|oidlen
decl_stmt|;
name|gss_buffer_desc
name|sub_token
decl_stmt|;
name|ssize_t
name|mech_len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|taglen
decl_stmt|;
operator|(
name|void
operator|)
name|mech_type
expr_stmt|;
name|output_token
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|output_token
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * SPNEGO doesn't include gss wrapping on SubsequentContextToken 	 * like the Kerberos 5 mech does. But lets check for it anyway. 	 */
name|mech_len
operator|=
name|gssapi_krb5_get_mech
argument_list|(
name|input_token
operator|->
name|value
argument_list|,
name|input_token
operator|->
name|length
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mech_len
operator|<
literal|0
condition|)
block|{
name|buf
operator|=
name|input_token
operator|->
name|value
expr_stmt|;
name|buf_size
operator|=
name|input_token
operator|->
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|mech_len
operator|==
name|GSS_KRB5_MECH
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|GSS_KRB5_MECH
operator|->
name|elements
argument_list|,
name|p
argument_list|,
name|mech_len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gss_init_sec_context
argument_list|(
name|minor_status
argument_list|,
name|initiator_cred_handle
argument_list|,
name|context_handle
argument_list|,
name|target_name
argument_list|,
name|GSS_KRB5_MECH
argument_list|,
name|req_flags
argument_list|,
name|time_req
argument_list|,
name|input_chan_bindings
argument_list|,
name|input_token
argument_list|,
name|actual_mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|mech_len
operator|==
name|GSS_SPNEGO_MECH
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|GSS_SPNEGO_MECH
operator|->
name|elements
argument_list|,
name|p
argument_list|,
name|mech_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|gssapi_spnego_decapsulate
argument_list|(
name|minor_status
argument_list|,
name|input_token
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|GSS_SPNEGO_MECH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
return|return
operator|(
name|GSS_S_BAD_MECH
operator|)
return|;
name|ret
operator|=
name|der_match_tag_and_length
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
name|ASN1_C_CONTEXT
argument_list|,
name|CONS
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|len
operator|>
name|buf_size
operator|-
name|taglen
condition|)
return|return
operator|(
name|ASN1_OVERRUN
operator|)
return|;
name|ret
operator|=
name|decode_NegTokenResp
argument_list|(
name|buf
operator|+
name|taglen
argument_list|,
name|len
argument_list|,
operator|&
name|resp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|resp
operator|.
name|negState
operator|==
name|NULL
operator|||
operator|*
operator|(
name|resp
operator|.
name|negState
operator|)
operator|==
name|reject
operator|||
name|resp
operator|.
name|supportedMech
operator|==
name|NULL
condition|)
block|{
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_BAD_MECH
operator|)
return|;
block|}
name|ret
operator|=
name|der_put_oid
argument_list|(
name|oidbuf
operator|+
sizeof|sizeof
argument_list|(
name|oidbuf
argument_list|)
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|oidbuf
argument_list|)
argument_list|,
name|resp
operator|.
name|supportedMech
argument_list|,
operator|&
name|oidlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|||
name|oidlen
operator|!=
name|GSS_KRB5_MECH
operator|->
name|length
operator|||
name|memcmp
argument_list|(
name|oidbuf
operator|+
sizeof|sizeof
argument_list|(
name|oidbuf
argument_list|)
operator|-
name|oidlen
argument_list|,
name|GSS_KRB5_MECH
operator|->
name|elements
argument_list|,
name|oidlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
return|return
name|GSS_S_BAD_MECH
return|;
block|}
if|if
condition|(
name|resp
operator|.
name|responseToken
operator|!=
name|NULL
condition|)
block|{
name|sub_token
operator|.
name|length
operator|=
name|resp
operator|.
name|responseToken
operator|->
name|length
expr_stmt|;
name|sub_token
operator|.
name|value
operator|=
name|resp
operator|.
name|responseToken
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|sub_token
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|sub_token
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
name|gss_init_sec_context
argument_list|(
name|minor_status
argument_list|,
name|initiator_cred_handle
argument_list|,
name|context_handle
argument_list|,
name|target_name
argument_list|,
name|GSS_KRB5_MECH
argument_list|,
name|req_flags
argument_list|,
name|time_req
argument_list|,
name|input_chan_bindings
argument_list|,
operator|&
name|sub_token
argument_list|,
name|actual_mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * XXXSRA I don't think this limited implementation ever needs 	 * to check the MIC -- our preferred mechanism (Kerberos) 	 * authenticates its own messages and is the only mechanism 	 * we'll accept, so if the mechanism negotiation completes 	 * successfully, we don't need the MIC.  See RFC 4178. 	 */
name|free_NegTokenResp
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|OM_uint32
name|gss_init_sec_context_spnego
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
specifier|const
name|gss_cred_id_t
name|initiator_cred_handle
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|context_handle
parameter_list|,
specifier|const
name|gss_name_t
name|target_name
parameter_list|,
specifier|const
name|gss_OID
name|mech_type
parameter_list|,
name|OM_uint32
name|req_flags
parameter_list|,
name|OM_uint32
name|time_req
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token
parameter_list|,
name|gss_OID
modifier|*
name|actual_mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|)
block|{
comment|/* Dirty trick to suppress compiler warnings */
comment|/* Figure out whether we're starting over or processing a reply */
if|if
condition|(
name|input_token
operator|==
name|GSS_C_NO_BUFFER
operator|||
name|input_token
operator|->
name|length
operator|==
literal|0U
condition|)
return|return
operator|(
name|spnego_initial
argument_list|(
name|minor_status
argument_list|,
name|initiator_cred_handle
argument_list|,
name|context_handle
argument_list|,
name|target_name
argument_list|,
name|mech_type
argument_list|,
name|req_flags
argument_list|,
name|time_req
argument_list|,
name|input_chan_bindings
argument_list|,
name|input_token
argument_list|,
name|actual_mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|spnego_reply
argument_list|(
name|minor_status
argument_list|,
name|initiator_cred_handle
argument_list|,
name|context_handle
argument_list|,
name|target_name
argument_list|,
name|mech_type
argument_list|,
name|req_flags
argument_list|,
name|time_req
argument_list|,
name|input_chan_bindings
argument_list|,
name|input_token
argument_list|,
name|actual_mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GSSAPI */
end_comment

end_unit

