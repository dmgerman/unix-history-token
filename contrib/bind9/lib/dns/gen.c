begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: gen.c,v 1.65.2.5.2.9 2006/10/02 06:31:26 marka Exp $ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/*  * Silence compiler warnings about using strcpy and friends.  */
end_comment

begin_define
define|#
directive|define
name|_CRT_SECURE_NO_DEPRECATE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|"gen-win32.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"gen-unix.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FROMTEXTARGS
value|"rdclass, type, lexer, origin, options, target, callbacks"
end_define

begin_define
define|#
directive|define
name|FROMTEXTCLASS
value|"rdclass"
end_define

begin_define
define|#
directive|define
name|FROMTEXTTYPE
value|"type"
end_define

begin_define
define|#
directive|define
name|FROMTEXTDEF
value|"result = DNS_R_UNKNOWN"
end_define

begin_define
define|#
directive|define
name|TOTEXTARGS
value|"rdata, tctx, target"
end_define

begin_define
define|#
directive|define
name|TOTEXTCLASS
value|"rdata->rdclass"
end_define

begin_define
define|#
directive|define
name|TOTEXTTYPE
value|"rdata->type"
end_define

begin_define
define|#
directive|define
name|TOTEXTDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|FROMWIREARGS
value|"rdclass, type, source, dctx, options, target"
end_define

begin_define
define|#
directive|define
name|FROMWIRECLASS
value|"rdclass"
end_define

begin_define
define|#
directive|define
name|FROMWIRETYPE
value|"type"
end_define

begin_define
define|#
directive|define
name|FROMWIREDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|TOWIREARGS
value|"rdata, cctx, target"
end_define

begin_define
define|#
directive|define
name|TOWIRECLASS
value|"rdata->rdclass"
end_define

begin_define
define|#
directive|define
name|TOWIRETYPE
value|"rdata->type"
end_define

begin_define
define|#
directive|define
name|TOWIREDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|FROMSTRUCTARGS
value|"rdclass, type, source, target"
end_define

begin_define
define|#
directive|define
name|FROMSTRUCTCLASS
value|"rdclass"
end_define

begin_define
define|#
directive|define
name|FROMSTRUCTTYPE
value|"type"
end_define

begin_define
define|#
directive|define
name|FROMSTRUCTDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|TOSTRUCTARGS
value|"rdata, target, mctx"
end_define

begin_define
define|#
directive|define
name|TOSTRUCTCLASS
value|"rdata->rdclass"
end_define

begin_define
define|#
directive|define
name|TOSTRUCTTYPE
value|"rdata->type"
end_define

begin_define
define|#
directive|define
name|TOSTRUCTDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|FREESTRUCTARGS
value|"source"
end_define

begin_define
define|#
directive|define
name|FREESTRUCTCLASS
value|"common->rdclass"
end_define

begin_define
define|#
directive|define
name|FREESTRUCTTYPE
value|"common->rdtype"
end_define

begin_define
define|#
directive|define
name|FREESTRUCTDEF
value|NULL
end_define

begin_define
define|#
directive|define
name|COMPAREARGS
value|"rdata1, rdata2"
end_define

begin_define
define|#
directive|define
name|COMPARECLASS
value|"rdata1->rdclass"
end_define

begin_define
define|#
directive|define
name|COMPARETYPE
value|"rdata1->type"
end_define

begin_define
define|#
directive|define
name|COMPAREDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|ADDITIONALDATAARGS
value|"rdata, add, arg"
end_define

begin_define
define|#
directive|define
name|ADDITIONALDATACLASS
value|"rdata->rdclass"
end_define

begin_define
define|#
directive|define
name|ADDITIONALDATATYPE
value|"rdata->type"
end_define

begin_define
define|#
directive|define
name|ADDITIONALDATADEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|DIGESTARGS
value|"rdata, digest, arg"
end_define

begin_define
define|#
directive|define
name|DIGESTCLASS
value|"rdata->rdclass"
end_define

begin_define
define|#
directive|define
name|DIGESTTYPE
value|"rdata->type"
end_define

begin_define
define|#
directive|define
name|DIGESTDEF
value|"use_default = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|CHECKOWNERARGS
value|"name, rdclass, type, wildcard"
end_define

begin_define
define|#
directive|define
name|CHECKOWNERCLASS
value|"rdclass"
end_define

begin_define
define|#
directive|define
name|CHECKOWNERTYPE
value|"type"
end_define

begin_define
define|#
directive|define
name|CHECKOWNERDEF
value|"result = ISC_TRUE"
end_define

begin_define
define|#
directive|define
name|CHECKNAMESARGS
value|"rdata, owner, bad"
end_define

begin_define
define|#
directive|define
name|CHECKNAMESCLASS
value|"rdata->rdclass"
end_define

begin_define
define|#
directive|define
name|CHECKNAMESTYPE
value|"rdata->type"
end_define

begin_define
define|#
directive|define
name|CHECKNAMESDEF
value|"result = ISC_TRUE"
end_define

begin_decl_stmt
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"/*\n"
literal|" * Copyright (C) 2004%s Internet Systems Consortium, Inc. (\"ISC\")\n"
literal|" * Copyright (C) 1998-2003 Internet Software Consortium.\n"
literal|" *\n"
literal|" * Permission to use, copy, modify, and distribute this software for any\n"
literal|" * purpose with or without fee is hereby granted, provided that the above\n"
literal|" * copyright notice and this permission notice appear in all copies.\n"
literal|" *\n"
literal|" * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES WITH\n"
literal|" * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n"
literal|" * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,\n"
literal|" * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n"
literal|" * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n"
literal|" * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n"
literal|" * PERFORMANCE OF THIS SOFTWARE.\n"
literal|" */\n"
literal|"\n"
literal|"/***************\n"
literal|" ***************\n"
literal|" ***************   THIS FILE IS AUTOMATICALLY GENERATED BY gen.c.\n"
literal|" ***************   DO NOT EDIT!\n"
literal|" ***************\n"
literal|" ***************/\n"
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TYPENAMES
value|256
end_define

begin_struct
struct|struct
name|cc
block|{
name|struct
name|cc
modifier|*
name|next
decl_stmt|;
name|int
name|rdclass
decl_stmt|;
name|char
name|classname
index|[
literal|11
index|]
decl_stmt|;
block|}
modifier|*
name|classes
struct|;
end_struct

begin_struct
struct|struct
name|tt
block|{
name|struct
name|tt
modifier|*
name|next
decl_stmt|;
name|int
name|rdclass
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
name|classname
index|[
literal|11
index|]
decl_stmt|;
name|char
name|typename
index|[
literal|11
index|]
decl_stmt|;
name|char
name|dirname
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX Should be max path length */
block|}
modifier|*
name|types
struct|;
end_struct

begin_struct
struct|struct
name|ttnam
block|{
name|char
name|typename
index|[
literal|11
index|]
decl_stmt|;
name|char
name|macroname
index|[
literal|11
index|]
decl_stmt|;
name|char
name|attr
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|int
name|sorted
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|typenames
index|[
name|TYPENAMES
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|maxtype
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|upper
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|funname
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|doswitch
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dodecl
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sd
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_into_typenames
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * If you use more than 10 of these in, say, a printf(), you'll have problems.  */
end_comment

begin_function
name|char
modifier|*
name|upper
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|static
name|int
name|buf_to_use
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|10
index|]
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
name|buf_to_use
operator|++
expr_stmt|;
if|if
condition|(
name|buf_to_use
operator|>
literal|9
condition|)
name|buf_to_use
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|buf
index|[
name|buf_to_use
index|]
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
name|s
operator|++
operator|)
operator|&
literal|0xff
operator|)
condition|)
operator|*
name|b
operator|++
operator|=
name|islower
argument_list|(
name|c
argument_list|)
condition|?
name|toupper
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
index|[
name|buf_to_use
index|]
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|funname
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
block|{
operator|*
name|b
operator|++
operator|=
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|?
literal|'_'
else|:
name|c
expr_stmt|;
block|}
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|doswitch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|,
specifier|const
name|char
modifier|*
name|tsw
parameter_list|,
specifier|const
name|char
modifier|*
name|csw
parameter_list|,
specifier|const
name|char
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|tt
modifier|*
name|tt
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|lasttype
init|=
literal|0
decl_stmt|;
name|int
name|subswitch
init|=
literal|0
decl_stmt|;
name|char
name|buf1
index|[
literal|11
index|]
decl_stmt|,
name|buf2
index|[
literal|11
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
init|=
literal|" result ="
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|result
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
operator|!=
name|NULL
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n#define %s \\\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tswitch (%s) { \\\n"
comment|/*}*/
argument_list|,
name|tsw
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tt
operator|->
name|type
operator|!=
name|lasttype
operator|&&
name|subswitch
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tdefault: break; \\\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tdefault: %s; break; \\\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
comment|/*{*/
literal|"\t\t} \\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t\tbreak; \\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|subswitch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tt
operator|->
name|rdclass
operator|&&
name|tt
operator|->
name|type
operator|!=
name|lasttype
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tcase %d: switch (%s) { \\\n"
comment|/*}*/
argument_list|,
name|tt
operator|->
name|type
argument_list|,
name|csw
argument_list|)
expr_stmt|;
name|subswitch
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tt
operator|->
name|rdclass
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tcase %d:%s %s_%s(%s); break;"
argument_list|,
name|tt
operator|->
name|type
argument_list|,
name|result
argument_list|,
name|function
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tcase %d:%s %s_%s_%s(%s); break;"
argument_list|,
name|tt
operator|->
name|rdclass
argument_list|,
name|result
argument_list|,
name|function
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|classname
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|buf2
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" \\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lasttype
operator|=
name|tt
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|subswitch
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tdefault: break; \\\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tdefault: %s; break; \\\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
comment|/*{*/
literal|"\t\t} \\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t\tbreak; \\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n#define %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n#define %s %s;\n"
argument_list|,
name|name
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdefault: break; \\\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdefault: %s; break; \\\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
comment|/*{*/
literal|"\t}\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dodecl
parameter_list|(
name|char
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|function
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|tt
modifier|*
name|tt
decl_stmt|;
name|char
name|buf1
index|[
literal|11
index|]
decl_stmt|,
name|buf2
index|[
literal|11
index|]
decl_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
name|tt
operator|->
name|rdclass
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"static inline %s %s_%s_%s(%s);\n"
argument_list|,
name|type
argument_list|,
name|function
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|classname
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|buf2
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"static inline %s %s_%s(%s);\n"
argument_list|,
name|type
argument_list|,
name|function
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ttnam
modifier|*
name|find_typename
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPENAMES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|typenames
index|[
name|i
index|]
operator|.
name|typename
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|typenames
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
condition|)
return|return
operator|(
operator|&
name|typenames
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|insert_into_typenames
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|,
specifier|const
name|char
modifier|*
name|attr
parameter_list|)
block|{
name|struct
name|ttnam
modifier|*
name|ttn
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
name|tmp
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPENAMES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|typenames
index|[
name|i
index|]
operator|.
name|typename
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|typenames
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
operator|&&
name|strcmp
argument_list|(
name|typename
argument_list|,
name|typenames
index|[
name|i
index|]
operator|.
name|typename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error:  type %d has two names: %s, %s\n"
argument_list|,
name|type
argument_list|,
name|typenames
index|[
name|i
index|]
operator|.
name|typename
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typenames
index|[
name|i
index|]
operator|.
name|typename
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|ttn
operator|==
name|NULL
condition|)
name|ttn
operator|=
operator|&
name|typenames
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ttn
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: typenames array too small\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|typename
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|ttn
operator|->
name|typename
argument_list|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error:  type name %s is too long\n"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ttn
operator|->
name|typename
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|ttn
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|strcpy
argument_list|(
name|ttn
operator|->
name|macroname
argument_list|,
name|ttn
operator|->
name|typename
argument_list|)
expr_stmt|;
name|c
operator|=
name|strlen
argument_list|(
name|ttn
operator|->
name|macroname
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ttn
operator|->
name|macroname
index|[
name|c
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
name|ttn
operator|->
name|macroname
index|[
name|c
operator|-
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"RRTYPE_%s_ATTRIBUTES"
argument_list|,
name|upper
argument_list|(
name|ttn
operator|->
name|macroname
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ttn
operator|->
name|attr
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|attr
argument_list|,
name|ttn
operator|->
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error:  type %d has different attributes: "
literal|"%s, %s\n"
argument_list|,
name|type
argument_list|,
name|ttn
operator|->
name|attr
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|attr
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|ttn
operator|->
name|attr
argument_list|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error:  attr (%s) [name %s] is too long\n"
argument_list|,
name|attr
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ttn
operator|->
name|attr
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|ttn
operator|->
name|sorted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxtype
operator|<
name|type
condition|)
name|maxtype
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add
parameter_list|(
name|int
name|rdclass
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|)
block|{
name|struct
name|tt
modifier|*
name|newtt
init|=
operator|(
expr|struct
name|tt
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newtt
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|tt
modifier|*
name|tt
decl_stmt|,
modifier|*
name|oldtt
decl_stmt|;
name|struct
name|cc
modifier|*
name|newcc
decl_stmt|;
name|struct
name|cc
modifier|*
name|cc
decl_stmt|,
modifier|*
name|oldcc
decl_stmt|;
name|insert_into_typenames
argument_list|(
name|type
argument_list|,
name|typename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtt
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc() failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|newtt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newtt
operator|->
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|newtt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|strcpy
argument_list|(
name|newtt
operator|->
name|classname
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newtt
operator|->
name|typename
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newtt
operator|->
name|dirname
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|tt
operator|=
name|types
expr_stmt|;
name|oldtt
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|tt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tt
operator|->
name|type
operator|<
name|type
operator|)
condition|)
block|{
name|oldtt
operator|=
name|tt
expr_stmt|;
name|tt
operator|=
name|tt
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|tt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tt
operator|->
name|type
operator|==
name|type
operator|)
operator|&&
operator|(
name|tt
operator|->
name|rdclass
operator|<
name|rdclass
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|typename
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|oldtt
operator|=
name|tt
expr_stmt|;
name|tt
operator|=
name|tt
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tt
operator|->
name|type
operator|==
name|type
operator|)
operator|&&
operator|(
name|tt
operator|->
name|rdclass
operator|==
name|rdclass
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|newtt
operator|->
name|next
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|oldtt
operator|!=
name|NULL
condition|)
name|oldtt
operator|->
name|next
operator|=
name|newtt
expr_stmt|;
else|else
name|types
operator|=
name|newtt
expr_stmt|;
comment|/* 	 * Do a class switch for this type. 	 */
if|if
condition|(
name|rdclass
operator|==
literal|0
condition|)
return|return;
name|newcc
operator|=
operator|(
expr|struct
name|cc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newcc
argument_list|)
argument_list|)
expr_stmt|;
name|newcc
operator|->
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|strcpy
argument_list|(
name|newcc
operator|->
name|classname
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|cc
operator|=
name|classes
expr_stmt|;
name|oldcc
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cc
operator|->
name|rdclass
operator|<
name|rdclass
operator|)
condition|)
block|{
name|oldcc
operator|=
name|cc
expr_stmt|;
name|cc
operator|=
name|cc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc
operator|!=
name|NULL
operator|)
operator|&&
name|cc
operator|->
name|rdclass
operator|==
name|rdclass
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newcc
argument_list|)
expr_stmt|;
return|return;
block|}
name|newcc
operator|->
name|next
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|oldcc
operator|!=
name|NULL
condition|)
name|oldcc
operator|->
name|next
operator|=
name|newcc
expr_stmt|;
else|else
name|classes
operator|=
name|newcc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sd
parameter_list|(
name|int
name|rdclass
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|char
name|filetype
parameter_list|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"0123456789_65535.h"
argument_list|)
index|]
decl_stmt|;
name|char
name|fmt
index|[
sizeof|sizeof
argument_list|(
literal|"%10[-0-9a-z]_%d.h"
argument_list|)
index|]
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
name|typename
index|[
literal|11
index|]
decl_stmt|;
name|isc_dir_t
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|start_directory
argument_list|(
name|dirname
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
return|return;
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%s%c"
argument_list|,
literal|"%10[-0-9a-z]_%d."
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_file
argument_list|(
operator|&
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|dir
operator|.
name|filename
argument_list|,
name|fmt
argument_list|,
name|typename
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|type
operator|>
literal|65535
operator|)
operator|||
operator|(
name|type
operator|<
literal|0
operator|)
condition|)
continue|continue;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s_%d.%c"
argument_list|,
name|typename
argument_list|,
name|type
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|dir
operator|.
name|filename
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|add
argument_list|(
name|rdclass
argument_list|,
name|classname
argument_list|,
name|type
argument_list|,
name|typename
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
name|end_directory
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|HASH
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"n == 0?\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|b
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|a
operator|+
name|n
operator|)
operator|*
name|b
operator|)
operator|%
literal|256
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX Should be max path length */
name|char
name|srcdir
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX Should be max path length */
name|int
name|rdclass
decl_stmt|;
name|char
name|classname
index|[
literal|11
index|]
decl_stmt|;
name|struct
name|tt
modifier|*
name|tt
decl_stmt|;
name|struct
name|cc
modifier|*
name|cc
decl_stmt|;
name|struct
name|ttnam
modifier|*
name|ttn
decl_stmt|,
modifier|*
name|ttn2
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|year
index|[
literal|11
index|]
decl_stmt|;
name|int
name|lasttype
decl_stmt|;
name|int
name|code
init|=
literal|1
decl_stmt|;
name|int
name|class_enum
init|=
literal|0
decl_stmt|;
name|int
name|type_enum
init|=
literal|0
decl_stmt|;
name|int
name|structs
init|=
literal|0
decl_stmt|;
name|int
name|depend
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|buf1
index|[
literal|11
index|]
decl_stmt|;
name|char
name|filetype
init|=
literal|'c'
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|isc_dir_t
name|dir
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPENAMES
condition|;
name|i
operator|++
control|)
name|memset
argument_list|(
operator|&
name|typenames
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|typenames
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|srcdir
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|isc_commandline_parse
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cdits:F:P:S:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|depend
operator|=
literal|0
expr_stmt|;
name|type_enum
operator|=
literal|0
expr_stmt|;
name|class_enum
operator|=
literal|1
expr_stmt|;
name|filetype
operator|=
literal|'c'
expr_stmt|;
name|structs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|depend
operator|=
literal|1
expr_stmt|;
name|class_enum
operator|=
literal|0
expr_stmt|;
name|type_enum
operator|=
literal|0
expr_stmt|;
name|structs
operator|=
literal|0
expr_stmt|;
name|filetype
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|depend
operator|=
literal|0
expr_stmt|;
name|class_enum
operator|=
literal|0
expr_stmt|;
name|type_enum
operator|=
literal|1
expr_stmt|;
name|filetype
operator|=
literal|'c'
expr_stmt|;
name|structs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|depend
operator|=
literal|0
expr_stmt|;
name|class_enum
operator|=
literal|0
expr_stmt|;
name|type_enum
operator|=
literal|0
expr_stmt|;
name|structs
operator|=
literal|1
expr_stmt|;
name|filetype
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sprintf
argument_list|(
name|srcdir
argument_list|,
literal|"%s/"
argument_list|,
name|isc_commandline_argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|file
operator|=
name|isc_commandline_argument
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|prefix
operator|=
name|isc_commandline_argument
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|suffix
operator|=
name|isc_commandline_argument
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%srdata"
argument_list|,
name|srcdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_directory
argument_list|(
name|buf
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_file
argument_list|(
operator|&
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|dir
operator|.
name|filename
argument_list|,
literal|"%10[0-9a-z]_%d"
argument_list|,
name|classname
argument_list|,
operator|&
name|rdclass
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rdclass
operator|>
literal|65535
operator|)
operator|||
operator|(
name|rdclass
operator|<
literal|0
operator|)
condition|)
continue|continue;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%srdata/%s_%d"
argument_list|,
name|srcdir
argument_list|,
name|classname
argument_list|,
name|rdclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|+
literal|6
operator|+
name|strlen
argument_list|(
name|srcdir
argument_list|)
argument_list|,
name|dir
operator|.
name|filename
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|sd
argument_list|(
name|rdclass
argument_list|,
name|classname
argument_list|,
name|buf
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
block|}
name|end_directory
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%srdata/generic"
argument_list|,
name|srcdir
argument_list|)
expr_stmt|;
name|sd
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|,
name|buf
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
argument_list|(
operator|&
name|now
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|tm
operator|->
name|tm_year
operator|>
literal|104
condition|)
name|sprintf
argument_list|(
name|year
argument_list|,
literal|"-%d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|year
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|year
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|depend
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|copyright
argument_list|,
name|year
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|fputs
argument_list|(
literal|"#ifndef DNS_CODE_H\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#define DNS_CODE_H 1\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#include<isc/boolean.h>\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#include<isc/result.h>\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#include<dns/name.h>\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
operator|!=
name|NULL
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#include \"%s/%s_%d.c\"\n"
argument_list|,
name|tt
operator|->
name|dirname
argument_list|,
name|tt
operator|->
name|typename
argument_list|,
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"FROMTEXTSWITCH"
argument_list|,
literal|"fromtext"
argument_list|,
name|FROMTEXTARGS
argument_list|,
name|FROMTEXTTYPE
argument_list|,
name|FROMTEXTCLASS
argument_list|,
name|FROMTEXTDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"TOTEXTSWITCH"
argument_list|,
literal|"totext"
argument_list|,
name|TOTEXTARGS
argument_list|,
name|TOTEXTTYPE
argument_list|,
name|TOTEXTCLASS
argument_list|,
name|TOTEXTDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"FROMWIRESWITCH"
argument_list|,
literal|"fromwire"
argument_list|,
name|FROMWIREARGS
argument_list|,
name|FROMWIRETYPE
argument_list|,
name|FROMWIRECLASS
argument_list|,
name|FROMWIREDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"TOWIRESWITCH"
argument_list|,
literal|"towire"
argument_list|,
name|TOWIREARGS
argument_list|,
name|TOWIRETYPE
argument_list|,
name|TOWIRECLASS
argument_list|,
name|TOWIREDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"COMPARESWITCH"
argument_list|,
literal|"compare"
argument_list|,
name|COMPAREARGS
argument_list|,
name|COMPARETYPE
argument_list|,
name|COMPARECLASS
argument_list|,
name|COMPAREDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"FROMSTRUCTSWITCH"
argument_list|,
literal|"fromstruct"
argument_list|,
name|FROMSTRUCTARGS
argument_list|,
name|FROMSTRUCTTYPE
argument_list|,
name|FROMSTRUCTCLASS
argument_list|,
name|FROMSTRUCTDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"TOSTRUCTSWITCH"
argument_list|,
literal|"tostruct"
argument_list|,
name|TOSTRUCTARGS
argument_list|,
name|TOSTRUCTTYPE
argument_list|,
name|TOSTRUCTCLASS
argument_list|,
name|TOSTRUCTDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"FREESTRUCTSWITCH"
argument_list|,
literal|"freestruct"
argument_list|,
name|FREESTRUCTARGS
argument_list|,
name|FREESTRUCTTYPE
argument_list|,
name|FREESTRUCTCLASS
argument_list|,
name|FREESTRUCTDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"ADDITIONALDATASWITCH"
argument_list|,
literal|"additionaldata"
argument_list|,
name|ADDITIONALDATAARGS
argument_list|,
name|ADDITIONALDATATYPE
argument_list|,
name|ADDITIONALDATACLASS
argument_list|,
name|ADDITIONALDATADEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"DIGESTSWITCH"
argument_list|,
literal|"digest"
argument_list|,
name|DIGESTARGS
argument_list|,
name|DIGESTTYPE
argument_list|,
name|DIGESTCLASS
argument_list|,
name|DIGESTDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"CHECKOWNERSWITCH"
argument_list|,
literal|"checkowner"
argument_list|,
name|CHECKOWNERARGS
argument_list|,
name|CHECKOWNERTYPE
argument_list|,
name|CHECKOWNERCLASS
argument_list|,
name|CHECKOWNERDEF
argument_list|)
expr_stmt|;
name|doswitch
argument_list|(
literal|"CHECKNAMESSWITCH"
argument_list|,
literal|"checknames"
argument_list|,
name|CHECKNAMESARGS
argument_list|,
name|CHECKNAMESTYPE
argument_list|,
name|CHECKNAMESCLASS
argument_list|,
name|CHECKNAMESDEF
argument_list|)
expr_stmt|;
comment|/* 		 * From here down, we are processing the rdata names and 		 * attributes. 		 */
define|#
directive|define
name|PRINT_COMMA
parameter_list|(
name|x
parameter_list|)
value|(x == maxtype ? "" : ",")
define|#
directive|define
name|METANOTQUESTION
value|"DNS_RDATATYPEATTR_META | " \ 			 "DNS_RDATATYPEATTR_NOTQUESTION"
define|#
directive|define
name|METAQUESTIONONLY
value|"DNS_RDATATYPEATTR_META | " \ 			 "DNS_RDATATYPEATTR_QUESTIONONLY"
define|#
directive|define
name|RESERVED
value|"DNS_RDATATYPEATTR_RESERVED"
comment|/* 		 * Add in reserved/special types.  This will let us 		 * sort them without special cases. 		 */
name|insert_into_typenames
argument_list|(
literal|0
argument_list|,
literal|"reserved0"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|31
argument_list|,
literal|"eid"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|32
argument_list|,
literal|"nimloc"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|34
argument_list|,
literal|"atma"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|100
argument_list|,
literal|"uinfo"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|101
argument_list|,
literal|"uid"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|102
argument_list|,
literal|"gid"
argument_list|,
name|RESERVED
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|251
argument_list|,
literal|"ixfr"
argument_list|,
name|METAQUESTIONONLY
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|252
argument_list|,
literal|"axfr"
argument_list|,
name|METAQUESTIONONLY
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|253
argument_list|,
literal|"mailb"
argument_list|,
name|METAQUESTIONONLY
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|254
argument_list|,
literal|"maila"
argument_list|,
name|METAQUESTIONONLY
argument_list|)
expr_stmt|;
name|insert_into_typenames
argument_list|(
literal|255
argument_list|,
literal|"any"
argument_list|,
name|METAQUESTIONONLY
argument_list|)
expr_stmt|;
comment|/* 		 * Spit out a quick and dirty hash function.  Here, 		 * we walk through the list of type names, and calculate 		 * a hash.  This isn't perfect, but it will generate "pretty 		 * good" estimates.  Lowercase the characters before 		 * computing in all cases. 		 * 		 * Here, walk the list from top to bottom, calculating 		 * the hash (mod 256) for each name. 		 */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define RDATATYPE_COMPARE(_s, _d, _tn, _n, _tp) \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdo { \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tif (sizeof(_s) - 1 == _n&& \\\n"
literal|"\t\t    strncasecmp(_s,(_tn),"
literal|"(sizeof(_s) - 1)) == 0) { \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t\tif ((dns_rdatatype_attributes(_d)& "
literal|"DNS_RDATATYPEATTR_RESERVED) != 0) \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t\t\treturn (ISC_R_NOTIMPLEMENTED); \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t\t*(_tp) = _d; \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t\treturn (ISC_R_SUCCESS); \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t} \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t} while (0)\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define RDATATYPE_FROMTEXT_SW(_hash,"
literal|"_typename,_length,_typep) \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tswitch (_hash) { \\\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxtype
condition|;
name|i
operator|++
control|)
block|{
name|ttn
operator|=
name|find_typename
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttn
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 			 * Skip entries we already processed. 			 */
if|if
condition|(
name|ttn
operator|->
name|sorted
operator|!=
literal|0
condition|)
continue|continue;
name|hash
operator|=
name|HASH
argument_list|(
name|ttn
operator|->
name|typename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\tcase %u: \\\n"
argument_list|,
name|hash
argument_list|)
expr_stmt|;
comment|/* 			 * Find all other entries that happen to match 			 * this hash. 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxtype
condition|;
name|j
operator|++
control|)
block|{
name|ttn2
operator|=
name|find_typename
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttn2
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|hash
operator|==
name|HASH
argument_list|(
name|ttn2
operator|->
name|typename
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t\tRDATATYPE_COMPARE"
literal|"(\"%s\", %u, "
literal|"_typename, _length, _typep); \\\n"
argument_list|,
name|ttn2
operator|->
name|typename
argument_list|,
name|ttn2
operator|->
name|type
argument_list|)
expr_stmt|;
name|ttn2
operator|->
name|sorted
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t\t\tbreak; \\\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define RDATATYPE_ATTRIBUTE_SW \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tswitch (type) { \\\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxtype
condition|;
name|i
operator|++
control|)
block|{
name|ttn
operator|=
name|find_typename
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttn
operator|==
name|NULL
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tcase %u: return (%s); \\\n"
argument_list|,
name|i
argument_list|,
name|upper
argument_list|(
name|ttn
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define RDATATYPE_TOTEXT_SW \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tswitch (type) { \\\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxtype
condition|;
name|i
operator|++
control|)
block|{
name|ttn
operator|=
name|find_typename
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttn
operator|==
name|NULL
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tcase %u: return "
literal|"(str_totext(\"%s\", target)); \\\n"
argument_list|,
name|i
argument_list|,
name|upper
argument_list|(
name|ttn
operator|->
name|typename
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#endif /* DNS_CODE_H */\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_enum
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#ifndef DNS_ENUMTYPE_H\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define DNS_ENUMTYPE_H 1\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"enum {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_none = 0,\n"
argument_list|)
expr_stmt|;
name|lasttype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
operator|!=
name|NULL
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
name|tt
operator|->
name|type
operator|!=
name|lasttype
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_%s = %d,\n"
argument_list|,
name|funname
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|lasttype
operator|=
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_ixfr = 251,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_axfr = 252,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_mailb = 253,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_maila = 254,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdatatype_any = 255\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_none\t"
literal|"((dns_rdatatype_t)dns_rdatatype_none)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
operator|!=
name|NULL
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
name|tt
operator|->
name|type
operator|!=
name|lasttype
condition|)
block|{
name|s
operator|=
name|funname
argument_list|(
name|tt
operator|->
name|typename
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_%s\t%s"
literal|"((dns_rdatatype_t)dns_rdatatype_%s)"
literal|"\n"
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|2U
condition|?
literal|"\t"
else|:
literal|""
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lasttype
operator|=
name|tt
operator|->
name|type
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_ixfr\t"
literal|"((dns_rdatatype_t)dns_rdatatype_ixfr)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_axfr\t"
literal|"((dns_rdatatype_t)dns_rdatatype_axfr)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_mailb\t"
literal|"((dns_rdatatype_t)dns_rdatatype_mailb)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_maila\t"
literal|"((dns_rdatatype_t)dns_rdatatype_maila)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdatatype_any\t"
literal|"((dns_rdatatype_t)dns_rdatatype_any)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n#endif /* DNS_ENUMTYPE_H */\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class_enum
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|classnum
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#ifndef DNS_ENUMCLASS_H\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define DNS_ENUMCLASS_H 1\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"enum {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\tdns_rdataclass_reserved0 = 0,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#define dns_rdataclass_reserved0 \\\n\t\t\t\t"
literal|"((dns_rdataclass_t)dns_rdataclass_reserved0)\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|PRINTCLASS
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|)
define|\
value|do { \ 		s = funname(name, buf1); \ 		classnum = num; \ 		fprintf(stdout, "\tdns_rdataclass_%s = %d%s\n", s, classnum, \ 		       classnum != 255 ? "," : ""); \ 		fprintf(stdout, "#define dns_rdataclass_%s\t" \ 		       "((dns_rdataclass_t)dns_rdataclass_%s)\n", s, s); \ 	} while (0)
for|for
control|(
name|cc
operator|=
name|classes
init|;
name|cc
operator|!=
name|NULL
condition|;
name|cc
operator|=
name|cc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cc
operator|->
name|rdclass
operator|==
literal|4
condition|)
block|{
name|PRINTCLASS
argument_list|(
literal|"ch"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|PRINTCLASS
argument_list|(
literal|"chaos"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|->
name|rdclass
operator|==
literal|255
condition|)
block|{
name|PRINTCLASS
argument_list|(
literal|"none"
argument_list|,
literal|254
argument_list|)
expr_stmt|;
block|}
name|PRINTCLASS
argument_list|(
name|cc
operator|->
name|classname
argument_list|,
name|cc
operator|->
name|rdclass
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|PRINTCLASS
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"#endif /* DNS_ENUMCLASS_H */\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|structs
condition|)
block|{
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|prefix
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
operator|!=
name|NULL
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s_%d.h"
argument_list|,
name|tt
operator|->
name|dirname
argument_list|,
name|tt
operator|->
name|typename
argument_list|,
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|suffix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|suffix
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|depend
condition|)
block|{
for|for
control|(
name|tt
operator|=
name|types
init|;
name|tt
operator|!=
name|NULL
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s:\t%s/%s_%d.h\n"
argument_list|,
name|file
argument_list|,
name|tt
operator|->
name|dirname
argument_list|,
name|tt
operator|->
name|typename
argument_list|,
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

