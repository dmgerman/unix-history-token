begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2014  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/hex.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/pool.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/ratelimiter.h>
end_include

begin_include
include|#
directive|include
file|<isc/refcount.h>
end_include

begin_include
include|#
directive|include
file|<isc/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<isc/serial.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdtime.h>
end_include

begin_include
include|#
directive|include
file|<isc/strerror.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/taskpool.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acache.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/adb.h>
end_include

begin_include
include|#
directive|include
file|<dns/callbacks.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/dnssec.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/journal.h>
end_include

begin_include
include|#
directive|include
file|<dns/keydata.h>
end_include

begin_include
include|#
directive|include
file|<dns/keytable.h>
end_include

begin_include
include|#
directive|include
file|<dns/keyvalues.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/master.h>
end_include

begin_include
include|#
directive|include
file|<dns/masterdump.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec3.h>
end_include

begin_include
include|#
directive|include
file|<dns/peer.h>
end_include

begin_include
include|#
directive|include
file|<dns/private.h>
end_include

begin_include
include|#
directive|include
file|<dns/rbt.h>
end_include

begin_include
include|#
directive|include
file|<dns/rcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/request.h>
end_include

begin_include
include|#
directive|include
file|<dns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rriterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/soa.h>
end_include

begin_include
include|#
directive|include
file|<dns/ssu.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/time.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_include
include|#
directive|include
file|<dns/update.h>
end_include

begin_include
include|#
directive|include
file|<dns/xfrin.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_include
include|#
directive|include
file|<dns/zt.h>
end_include

begin_include
include|#
directive|include
file|<dst/dst.h>
end_include

begin_define
define|#
directive|define
name|ZONE_MAGIC
value|ISC_MAGIC('Z', 'O', 'N', 'E')
end_define

begin_define
define|#
directive|define
name|DNS_ZONE_VALID
parameter_list|(
name|zone
parameter_list|)
value|ISC_MAGIC_VALID(zone, ZONE_MAGIC)
end_define

begin_define
define|#
directive|define
name|NOTIFY_MAGIC
value|ISC_MAGIC('N', 't', 'f', 'y')
end_define

begin_define
define|#
directive|define
name|DNS_NOTIFY_VALID
parameter_list|(
name|notify
parameter_list|)
value|ISC_MAGIC_VALID(notify, NOTIFY_MAGIC)
end_define

begin_define
define|#
directive|define
name|STUB_MAGIC
value|ISC_MAGIC('S', 't', 'u', 'b')
end_define

begin_define
define|#
directive|define
name|DNS_STUB_VALID
parameter_list|(
name|stub
parameter_list|)
value|ISC_MAGIC_VALID(stub, STUB_MAGIC)
end_define

begin_define
define|#
directive|define
name|ZONEMGR_MAGIC
value|ISC_MAGIC('Z', 'm', 'g', 'r')
end_define

begin_define
define|#
directive|define
name|DNS_ZONEMGR_VALID
parameter_list|(
name|stub
parameter_list|)
value|ISC_MAGIC_VALID(stub, ZONEMGR_MAGIC)
end_define

begin_define
define|#
directive|define
name|LOAD_MAGIC
value|ISC_MAGIC('L', 'o', 'a', 'd')
end_define

begin_define
define|#
directive|define
name|DNS_LOAD_VALID
parameter_list|(
name|load
parameter_list|)
value|ISC_MAGIC_VALID(load, LOAD_MAGIC)
end_define

begin_define
define|#
directive|define
name|FORWARD_MAGIC
value|ISC_MAGIC('F', 'o', 'r', 'w')
end_define

begin_define
define|#
directive|define
name|DNS_FORWARD_VALID
parameter_list|(
name|load
parameter_list|)
value|ISC_MAGIC_VALID(load, FORWARD_MAGIC)
end_define

begin_define
define|#
directive|define
name|IO_MAGIC
value|ISC_MAGIC('Z', 'm', 'I', 'O')
end_define

begin_define
define|#
directive|define
name|DNS_IO_VALID
parameter_list|(
name|load
parameter_list|)
value|ISC_MAGIC_VALID(load, IO_MAGIC)
end_define

begin_comment
comment|/*%  * Ensure 'a' is at least 'min' but not more than 'max'.  */
end_comment

begin_define
define|#
directive|define
name|RANGE
parameter_list|(
name|a
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
define|\
value|(((a)< (min)) ? (min) : ((a)< (max) ? (a) : (max)))
end_define

begin_define
define|#
directive|define
name|NSEC3REMOVE
parameter_list|(
name|x
parameter_list|)
value|(((x)& DNS_NSEC3FLAG_REMOVE) != 0)
end_define

begin_comment
comment|/*%  * Key flags  */
end_comment

begin_define
define|#
directive|define
name|REVOKE
parameter_list|(
name|x
parameter_list|)
value|((dst_key_flags(x)& DNS_KEYFLAG_REVOKE) != 0)
end_define

begin_define
define|#
directive|define
name|KSK
parameter_list|(
name|x
parameter_list|)
value|((dst_key_flags(x)& DNS_KEYFLAG_KSK) != 0)
end_define

begin_define
define|#
directive|define
name|ALG
parameter_list|(
name|x
parameter_list|)
value|dst_key_alg(x)
end_define

begin_comment
comment|/*  * Default values.  */
end_comment

begin_define
define|#
directive|define
name|DNS_DEFAULT_IDLEIN
value|3600
end_define

begin_comment
comment|/*%< 1 hour */
end_comment

begin_define
define|#
directive|define
name|DNS_DEFAULT_IDLEOUT
value|3600
end_define

begin_comment
comment|/*%< 1 hour */
end_comment

begin_define
define|#
directive|define
name|MAX_XFER_TIME
value|(2*3600)
end_define

begin_comment
comment|/*%< Documented default is 2 hours */
end_comment

begin_define
define|#
directive|define
name|RESIGN_DELAY
value|3600
end_define

begin_comment
comment|/*%< 1 hour */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_MAX_EXPIRE
end_ifndef

begin_define
define|#
directive|define
name|DNS_MAX_EXPIRE
value|14515200
end_define

begin_comment
comment|/*%< 24 weeks */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DUMP_DELAY
end_ifndef

begin_define
define|#
directive|define
name|DNS_DUMP_DELAY
value|900
end_define

begin_comment
comment|/*%< 15 minutes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|dns_notify
name|dns_notify_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_stub
name|dns_stub_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_load
name|dns_load_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_forward
name|dns_forward_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_forward_t
argument_list|)
name|dns_forwardlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_io
name|dns_io_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_io_t
argument_list|)
name|dns_iolist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_signing
name|dns_signing_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_signing_t
argument_list|)
name|dns_signinglist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_nsec3chain
name|dns_nsec3chain_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_nsec3chain_t
argument_list|)
name|dns_nsec3chainlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_keyfetch
name|dns_keyfetch_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_asyncload
name|dns_asyncload_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DNS_ZONE_CHECKLOCK
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_ZONE_CHECKLOCK
end_ifdef

begin_define
define|#
directive|define
name|LOCK_ZONE
parameter_list|(
name|z
parameter_list|)
define|\
value|do { LOCK(&(z)->lock); \ 	      INSIST((z)->locked == ISC_FALSE); \ 	     (z)->locked = ISC_TRUE; \ 		} while (0)
end_define

begin_define
define|#
directive|define
name|UNLOCK_ZONE
parameter_list|(
name|z
parameter_list|)
define|\
value|do { (z)->locked = ISC_FALSE; UNLOCK(&(z)->lock); } while (0)
end_define

begin_define
define|#
directive|define
name|LOCKED_ZONE
parameter_list|(
name|z
parameter_list|)
value|((z)->locked)
end_define

begin_define
define|#
directive|define
name|TRYLOCK_ZONE
parameter_list|(
name|result
parameter_list|,
name|z
parameter_list|)
define|\
value|do { \ 	      result = isc_mutex_trylock(&(z)->lock); \ 	      if (result == ISC_R_SUCCESS) {  \ 		     INSIST((z)->locked == ISC_FALSE); \ 		     (z)->locked = ISC_TRUE; \ 	      } \ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOCK_ZONE
parameter_list|(
name|z
parameter_list|)
value|LOCK(&(z)->lock)
end_define

begin_define
define|#
directive|define
name|UNLOCK_ZONE
parameter_list|(
name|z
parameter_list|)
value|UNLOCK(&(z)->lock)
end_define

begin_define
define|#
directive|define
name|LOCKED_ZONE
parameter_list|(
name|z
parameter_list|)
value|ISC_TRUE
end_define

begin_define
define|#
directive|define
name|TRYLOCK_ZONE
parameter_list|(
name|result
parameter_list|,
name|z
parameter_list|)
define|\
value|do { result = isc_mutex_trylock(&(z)->lock); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
end_ifdef

begin_define
define|#
directive|define
name|ZONEDB_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_init((l), 0, 0)
end_define

begin_define
define|#
directive|define
name|ZONEDB_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_destroy(l)
end_define

begin_define
define|#
directive|define
name|ZONEDB_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWLOCK((l), (t))
end_define

begin_define
define|#
directive|define
name|ZONEDB_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWUNLOCK((l), (t))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZONEDB_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_mutex_init(l)
end_define

begin_define
define|#
directive|define
name|ZONEDB_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|DESTROYLOCK(l)
end_define

begin_define
define|#
directive|define
name|ZONEDB_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|LOCK(l)
end_define

begin_define
define|#
directive|define
name|ZONEDB_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|UNLOCK(l)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|dns_zone
block|{
comment|/* Unlocked */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
ifdef|#
directive|ifdef
name|DNS_ZONE_CHECKLOCK
name|isc_boolean_t
name|locked
decl_stmt|;
endif|#
directive|endif
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_refcount_t
name|erefs
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_t
name|dblock
decl_stmt|;
else|#
directive|else
name|isc_mutex_t
name|dblock
decl_stmt|;
endif|#
directive|endif
name|dns_db_t
modifier|*
name|db
decl_stmt|;
comment|/* Locked by dblock */
comment|/* Locked */
name|dns_zonemgr_t
modifier|*
name|zmgr
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_zone_t
argument_list|)
name|link
expr_stmt|;
comment|/* Used by zmgr. */
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|unsigned
name|int
name|irefs
decl_stmt|;
name|dns_name_t
name|origin
decl_stmt|;
name|char
modifier|*
name|masterfile
decl_stmt|;
name|dns_masterformat_t
name|masterformat
decl_stmt|;
name|char
modifier|*
name|journal
decl_stmt|;
name|isc_int32_t
name|journalsize
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|dns_zonetype_t
name|type
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|db_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|db_argv
decl_stmt|;
name|isc_time_t
name|expiretime
decl_stmt|;
name|isc_time_t
name|refreshtime
decl_stmt|;
name|isc_time_t
name|dumptime
decl_stmt|;
name|isc_time_t
name|loadtime
decl_stmt|;
name|isc_time_t
name|notifytime
decl_stmt|;
name|isc_time_t
name|resigntime
decl_stmt|;
name|isc_time_t
name|keywarntime
decl_stmt|;
name|isc_time_t
name|signingtime
decl_stmt|;
name|isc_time_t
name|nsec3chaintime
decl_stmt|;
name|isc_time_t
name|refreshkeytime
decl_stmt|;
name|isc_uint32_t
name|refreshkeyinterval
decl_stmt|;
name|isc_uint32_t
name|refreshkeycount
decl_stmt|;
name|isc_uint32_t
name|refresh
decl_stmt|;
name|isc_uint32_t
name|retry
decl_stmt|;
name|isc_uint32_t
name|expire
decl_stmt|;
name|isc_uint32_t
name|minimum
decl_stmt|;
name|isc_stdtime_t
name|key_expiry
decl_stmt|;
name|isc_stdtime_t
name|log_key_expired_timer
decl_stmt|;
name|char
modifier|*
name|keydirectory
decl_stmt|;
name|isc_uint32_t
name|maxrefresh
decl_stmt|;
name|isc_uint32_t
name|minrefresh
decl_stmt|;
name|isc_uint32_t
name|maxretry
decl_stmt|;
name|isc_uint32_t
name|minretry
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|masters
decl_stmt|;
name|dns_name_t
modifier|*
modifier|*
name|masterkeynames
decl_stmt|;
name|isc_boolean_t
modifier|*
name|mastersok
decl_stmt|;
name|unsigned
name|int
name|masterscnt
decl_stmt|;
name|unsigned
name|int
name|curmaster
decl_stmt|;
name|isc_sockaddr_t
name|masteraddr
decl_stmt|;
name|dns_notifytype_t
name|notifytype
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|notify
decl_stmt|;
name|dns_name_t
modifier|*
modifier|*
name|notifykeynames
decl_stmt|;
name|unsigned
name|int
name|notifycnt
decl_stmt|;
name|isc_sockaddr_t
name|notifyfrom
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_task_t
modifier|*
name|loadtask
decl_stmt|;
name|isc_sockaddr_t
name|notifysrc4
decl_stmt|;
name|isc_sockaddr_t
name|notifysrc6
decl_stmt|;
name|isc_sockaddr_t
name|xfrsource4
decl_stmt|;
name|isc_sockaddr_t
name|xfrsource6
decl_stmt|;
name|isc_sockaddr_t
name|altxfrsource4
decl_stmt|;
name|isc_sockaddr_t
name|altxfrsource6
decl_stmt|;
name|isc_sockaddr_t
name|sourceaddr
decl_stmt|;
name|dns_xfrin_ctx_t
modifier|*
name|xfr
decl_stmt|;
comment|/* task locked */
name|dns_tsigkey_t
modifier|*
name|tsigkey
decl_stmt|;
comment|/* key used for xfr */
comment|/* Access Control Lists */
name|dns_acl_t
modifier|*
name|update_acl
decl_stmt|;
name|dns_acl_t
modifier|*
name|forward_acl
decl_stmt|;
name|dns_acl_t
modifier|*
name|notify_acl
decl_stmt|;
name|dns_acl_t
modifier|*
name|query_acl
decl_stmt|;
name|dns_acl_t
modifier|*
name|queryon_acl
decl_stmt|;
name|dns_acl_t
modifier|*
name|xfr_acl
decl_stmt|;
name|isc_boolean_t
name|update_disabled
decl_stmt|;
name|isc_boolean_t
name|zero_no_soa_ttl
decl_stmt|;
name|dns_severity_t
name|check_names
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_notify_t
argument_list|)
name|notifies
expr_stmt|;
name|dns_request_t
modifier|*
name|request
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
decl_stmt|;
name|dns_io_t
modifier|*
name|readio
decl_stmt|;
name|dns_dumpctx_t
modifier|*
name|dctx
decl_stmt|;
name|dns_io_t
modifier|*
name|writeio
decl_stmt|;
name|isc_uint32_t
name|maxxfrin
decl_stmt|;
name|isc_uint32_t
name|maxxfrout
decl_stmt|;
name|isc_uint32_t
name|idlein
decl_stmt|;
name|isc_uint32_t
name|idleout
decl_stmt|;
name|isc_event_t
name|ctlevent
decl_stmt|;
name|dns_ssutable_t
modifier|*
name|ssutable
decl_stmt|;
name|isc_uint32_t
name|sigvalidityinterval
decl_stmt|;
name|isc_uint32_t
name|sigresigninginterval
decl_stmt|;
name|dns_view_t
modifier|*
name|view
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|dns_checkmxfunc_t
name|checkmx
decl_stmt|;
name|dns_checksrvfunc_t
name|checksrv
decl_stmt|;
name|dns_checknsfunc_t
name|checkns
decl_stmt|;
comment|/*% 	 * Zones in certain states such as "waiting for zone transfer" 	 * or "zone transfer in progress" are kept on per-state linked lists 	 * in the zone manager using the 'statelink' field.  The 'statelist' 	 * field points at the list the zone is currently on.  It the zone 	 * is not on any such list, statelist is NULL. 	 */
name|ISC_LINK
argument_list|(
argument|dns_zone_t
argument_list|)
name|statelink
expr_stmt|;
name|dns_zonelist_t
modifier|*
name|statelist
decl_stmt|;
comment|/*% 	 * Statistics counters about zone management. 	 */
name|isc_stats_t
modifier|*
name|stats
decl_stmt|;
comment|/*% 	 * Optional per-zone statistics counters.  Counted outside of this 	 * module. 	 */
name|dns_zonestat_level_t
name|statlevel
decl_stmt|;
name|isc_boolean_t
name|requeststats_on
decl_stmt|;
name|isc_stats_t
modifier|*
name|requeststats
decl_stmt|;
name|dns_stats_t
modifier|*
name|rcvquerystats
decl_stmt|;
name|isc_uint32_t
name|notifydelay
decl_stmt|;
name|dns_isselffunc_t
name|isself
decl_stmt|;
name|void
modifier|*
name|isselfarg
decl_stmt|;
name|char
modifier|*
name|strnamerd
decl_stmt|;
name|char
modifier|*
name|strname
decl_stmt|;
name|char
modifier|*
name|strrdclass
decl_stmt|;
name|char
modifier|*
name|strviewname
decl_stmt|;
comment|/*% 	 * Serial number for deferred journal compaction. 	 */
name|isc_uint32_t
name|compact_serial
decl_stmt|;
comment|/*% 	 * Keys that are signing the zone for the first time. 	 */
name|dns_signinglist_t
name|signing
decl_stmt|;
name|dns_nsec3chainlist_t
name|nsec3chain
decl_stmt|;
comment|/*% 	 * Signing / re-signing quantum stopping parameters. 	 */
name|isc_uint32_t
name|signatures
decl_stmt|;
name|isc_uint32_t
name|nodes
decl_stmt|;
name|dns_rdatatype_t
name|privatetype
decl_stmt|;
comment|/*% 	 * Autosigning/key-maintenance options 	 */
name|isc_uint32_t
name|keyopts
decl_stmt|;
comment|/*% 	 * True if added by "rndc addzone" 	 */
name|isc_boolean_t
name|added
decl_stmt|;
comment|/*% 	 * whether this is a response policy zone 	 */
name|isc_boolean_t
name|is_rpz
decl_stmt|;
comment|/*% 	 * Serial number update method. 	 */
name|dns_updatemethod_t
name|updatemethod
decl_stmt|;
comment|/*% 	 * whether ixfr is requested 	 */
name|isc_boolean_t
name|requestixfr
decl_stmt|;
comment|/*% 	 * Outstanding forwarded UPDATE requests. 	 */
name|dns_forwardlist_t
name|forwards
decl_stmt|;
name|dns_zone_t
modifier|*
name|raw
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
decl_stmt|;
name|isc_boolean_t
name|sourceserialset
decl_stmt|;
name|isc_uint32_t
name|sourceserial
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_diff_t
modifier|*
name|diff
decl_stmt|;
name|isc_boolean_t
name|offline
decl_stmt|;
block|}
name|zonediff_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|zonediff_init
parameter_list|(
name|z
parameter_list|,
name|d
parameter_list|)
define|\
value|do { \ 		zonediff_t *_z = (z); \ 		(_z)->diff = (d); \ 		(_z)->offline = ISC_FALSE; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|DNS_ZONE_FLAG
parameter_list|(
name|z
parameter_list|,
name|f
parameter_list|)
value|(ISC_TF(((z)->flags& (f)) != 0))
end_define

begin_define
define|#
directive|define
name|DNS_ZONE_SETFLAG
parameter_list|(
name|z
parameter_list|,
name|f
parameter_list|)
value|do { \ 		INSIST(LOCKED_ZONE(z)); \ 		(z)->flags |= (f); \ 		} while (0)
end_define

begin_define
define|#
directive|define
name|DNS_ZONE_CLRFLAG
parameter_list|(
name|z
parameter_list|,
name|f
parameter_list|)
value|do { \ 		INSIST(LOCKED_ZONE(z)); \ 		(z)->flags&= ~(f); \ 		} while (0)
end_define

begin_comment
comment|/* XXX MPA these may need to go back into zone.h */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_REFRESH
value|0x00000001U
end_define

begin_comment
comment|/*%< refresh check in progress */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NEEDDUMP
value|0x00000002U
end_define

begin_comment
comment|/*%< zone need consolidation */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_USEVC
value|0x00000004U
end_define

begin_comment
comment|/*%< use tcp for refresh query */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_DUMPING
value|0x00000008U
end_define

begin_comment
comment|/*%< a dump is in progress */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_HASINCLUDE
value|0x00000010U
end_define

begin_comment
comment|/*%< $INCLUDE in zone file */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_LOADED
value|0x00000020U
end_define

begin_comment
comment|/*%< database has loaded */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_EXITING
value|0x00000040U
end_define

begin_comment
comment|/*%< zone is being destroyed */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_EXPIRED
value|0x00000080U
end_define

begin_comment
comment|/*%< zone has expired */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NEEDREFRESH
value|0x00000100U
end_define

begin_comment
comment|/*%< refresh check needed */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_UPTODATE
value|0x00000200U
end_define

begin_comment
comment|/*%< zone contents are 						 * uptodate */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NEEDNOTIFY
value|0x00000400U
end_define

begin_comment
comment|/*%< need to send out notify 						 * messages */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_DIFFONRELOAD
value|0x00000800U
end_define

begin_comment
comment|/*%< generate a journal diff on 						 * reload */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NOMASTERS
value|0x00001000U
end_define

begin_comment
comment|/*%< an attempt to refresh a 						 * zone with no masters 						 * occurred */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_LOADING
value|0x00002000U
end_define

begin_comment
comment|/*%< load from disk in progress*/
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_HAVETIMERS
value|0x00004000U
end_define

begin_comment
comment|/*%< timer values have been set 						 * from SOA (if not set, we 						 * are still using 						 * default timer values) */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_FORCEXFER
value|0x00008000U
end_define

begin_comment
comment|/*%< Force a zone xfer */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NOREFRESH
value|0x00010000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_DIALNOTIFY
value|0x00020000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_DIALREFRESH
value|0x00040000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_SHUTDOWN
value|0x00080000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLAG_NOIXFR
value|0x00100000U
end_define

begin_comment
comment|/*%< IXFR failed, force AXFR */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_FLUSH
value|0x00200000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NOEDNS
value|0x00400000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_USEALTXFRSRC
value|0x00800000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_SOABEFOREAXFR
value|0x01000000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NEEDCOMPACT
value|0x02000000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_REFRESHING
value|0x04000000U
end_define

begin_comment
comment|/*%< Refreshing keydata */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_THAW
value|0x08000000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_LOADPENDING
value|0x10000000U
end_define

begin_comment
comment|/*%< Loading scheduled */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONEFLG_NODELAY
value|0x20000000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONEFLG_SENDSECURE
value|0x40000000U
end_define

begin_define
define|#
directive|define
name|DNS_ZONE_OPTION
parameter_list|(
name|z
parameter_list|,
name|o
parameter_list|)
value|(((z)->options& (o)) != 0)
end_define

begin_define
define|#
directive|define
name|DNS_ZONEKEY_OPTION
parameter_list|(
name|z
parameter_list|,
name|o
parameter_list|)
value|(((z)->keyopts& (o)) != 0)
end_define

begin_comment
comment|/* Flags for zone_load() */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONELOADFLAG_NOSTAT
value|0x00000001U
end_define

begin_comment
comment|/* Do not stat() master files */
end_comment

begin_define
define|#
directive|define
name|DNS_ZONELOADFLAG_THAW
value|0x00000002U
end_define

begin_comment
comment|/* Thaw the zone on successful 						   load. */
end_comment

begin_define
define|#
directive|define
name|UNREACH_CHACHE_SIZE
value|10U
end_define

begin_define
define|#
directive|define
name|UNREACH_HOLD_TIME
value|600
end_define

begin_comment
comment|/* 10 minutes */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|op
parameter_list|)
define|\
value|do { result = (op); \ 		if (result != ISC_R_SUCCESS) goto failure; \ 	} while (0)
end_define

begin_struct
struct|struct
name|dns_unreachable
block|{
name|isc_sockaddr_t
name|remote
decl_stmt|;
name|isc_sockaddr_t
name|local
decl_stmt|;
name|isc_uint32_t
name|expire
decl_stmt|;
name|isc_uint32_t
name|last
decl_stmt|;
name|isc_uint32_t
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_zonemgr
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|refs
decl_stmt|;
comment|/* Locked by rwlock */
name|isc_taskmgr_t
modifier|*
name|taskmgr
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|timermgr
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|socketmgr
decl_stmt|;
name|isc_taskpool_t
modifier|*
name|zonetasks
decl_stmt|;
name|isc_taskpool_t
modifier|*
name|loadtasks
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_pool_t
modifier|*
name|mctxpool
decl_stmt|;
name|isc_ratelimiter_t
modifier|*
name|notifyrl
decl_stmt|;
name|isc_ratelimiter_t
modifier|*
name|refreshrl
decl_stmt|;
name|isc_rwlock_t
name|rwlock
decl_stmt|;
name|isc_mutex_t
name|iolock
decl_stmt|;
name|isc_rwlock_t
name|urlock
decl_stmt|;
comment|/* Locked by rwlock. */
name|dns_zonelist_t
name|zones
decl_stmt|;
name|dns_zonelist_t
name|waiting_for_xfrin
decl_stmt|;
name|dns_zonelist_t
name|xfrin_in_progress
decl_stmt|;
comment|/* Configuration data. */
name|isc_uint32_t
name|transfersin
decl_stmt|;
name|isc_uint32_t
name|transfersperns
decl_stmt|;
name|unsigned
name|int
name|serialqueryrate
decl_stmt|;
comment|/* Locked by iolock */
name|isc_uint32_t
name|iolimit
decl_stmt|;
name|isc_uint32_t
name|ioactive
decl_stmt|;
name|dns_iolist_t
name|high
decl_stmt|;
name|dns_iolist_t
name|low
decl_stmt|;
comment|/* Locked by urlock. */
comment|/* LRU cache */
name|struct
name|dns_unreachable
name|unreachable
index|[
name|UNREACH_CHACHE_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * Hold notify state.  */
end_comment

begin_struct
struct|struct
name|dns_notify
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_adbfind_t
modifier|*
name|find
decl_stmt|;
name|dns_request_t
modifier|*
name|request
decl_stmt|;
name|dns_name_t
name|ns
decl_stmt|;
name|isc_sockaddr_t
name|dst
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|key
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_notify_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_NOTIFY_NOSOA
value|0x0001U
end_define

begin_comment
comment|/*%  *	dns_stub holds state while performing a 'stub' transfer.  *	'db' is the zone's 'db' or a new one if this is the initial  *	transfer.  */
end_comment

begin_struct
struct|struct
name|dns_stub
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  *	Hold load state.  */
end_comment

begin_struct
struct|struct
name|dns_load
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|isc_time_t
name|loadtime
decl_stmt|;
name|dns_rdatacallbacks_t
name|callbacks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  *	Hold forward state.  */
end_comment

begin_struct
struct|struct
name|dns_forward
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_buffer_t
modifier|*
name|msgbuf
decl_stmt|;
name|dns_request_t
modifier|*
name|request
decl_stmt|;
name|isc_uint32_t
name|which
decl_stmt|;
name|isc_sockaddr_t
name|addr
decl_stmt|;
name|dns_updatecallback_t
name|callback
decl_stmt|;
name|void
modifier|*
name|callback_arg
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_forward_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  *	Hold IO request state.  */
end_comment

begin_struct
struct|struct
name|dns_io
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_zonemgr_t
modifier|*
name|zmgr
decl_stmt|;
name|isc_boolean_t
name|high
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_io_t
argument_list|)
name|link
expr_stmt|;
name|isc_event_t
modifier|*
name|event
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  *	Hold state for when we are signing a zone with a new  *	DNSKEY as result of an update.  */
end_comment

begin_struct
struct|struct
name|dns_signing
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbiterator
decl_stmt|;
name|dns_secalg_t
name|algorithm
decl_stmt|;
name|isc_uint16_t
name|keyid
decl_stmt|;
name|isc_boolean_t
name|delete
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_signing_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_nsec3chain
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbiterator
decl_stmt|;
name|dns_rdata_nsec3param_t
name|nsec3param
decl_stmt|;
name|unsigned
name|char
name|salt
index|[
literal|255
index|]
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|isc_boolean_t
name|seen_nsec
decl_stmt|;
name|isc_boolean_t
name|delete_nsec
decl_stmt|;
name|isc_boolean_t
name|save_delete_nsec
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_nsec3chain_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%<  * 'dbiterator' contains a iterator for the database.  If we are creating  * a NSEC3 chain only the non-NSEC3 nodes will be iterated.  If we are  * removing a NSEC3 chain then both NSEC3 and non-NSEC3 nodes will be  * iterated.  *  * 'nsec3param' contains the parameters of the NSEC3 chain being created  * or removed.  *  * 'salt' is buffer space and is referenced via 'nsec3param.salt'.  *  * 'seen_nsec' will be set to true if, while iterating the zone to create a  * NSEC3 chain, a NSEC record is seen.  *  * 'delete_nsec' will be set to true if, at the completion of the creation  * of a NSEC3 chain, 'seen_nsec' is true.  If 'delete_nsec' is true then we  * are in the process of deleting the NSEC chain.  *  * 'save_delete_nsec' is used to store the initial state of 'delete_nsec'  * so it can be recovered in the event of a error.  */
end_comment

begin_struct
struct|struct
name|dns_keyfetch
block|{
name|dns_fixedname_t
name|name
decl_stmt|;
name|dns_rdataset_t
name|keydataset
decl_stmt|;
name|dns_rdataset_t
name|dnskeyset
decl_stmt|;
name|dns_rdataset_t
name|dnskeysigset
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * Hold state for an asynchronous load  */
end_comment

begin_struct
struct|struct
name|dns_asyncload
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_zt_zoneloaded_t
name|loaded
decl_stmt|;
name|void
modifier|*
name|loaded_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HOUR
value|3600
end_define

begin_define
define|#
directive|define
name|DAY
value|(24*HOUR)
end_define

begin_define
define|#
directive|define
name|MONTH
value|(30*DAY)
end_define

begin_define
define|#
directive|define
name|SEND_BUFFER_SIZE
value|2048
end_define

begin_function_decl
specifier|static
name|void
name|zone_settimer
parameter_list|(
name|dns_zone_t
modifier|*
parameter_list|,
name|isc_time_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_refresh
parameter_list|(
name|dns_zone_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_debuglog
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|debuglevel
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|4
operator|,
function_decl|5
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|notify_log
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|queue_xfrin
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|update_one_rr
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_diffop_t
name|op
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_unload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_expire
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_iattach
parameter_list|(
name|dns_zone_t
modifier|*
name|source
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_idetach
parameter_list|(
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_replacedb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|dump
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|zone_attachdb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|zone_detachdb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|default_journal
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_xfrdone
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_postload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_time_t
name|loadtime
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_needdump
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_shutdown
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_loaddone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_startload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_time_t
name|loadtime
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_namerd_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_name_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_rdclass_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_viewname_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_send_secureserial
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|serial
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ondestroy example */
end_comment

begin_endif
unit|static void dns_zonemgr_dbdestroyed(isc_task_t *task, isc_event_t *event);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|refresh_callback
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stub_callback
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_soa_query
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|soa_query
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ns_query
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdataset_t
modifier|*
name|soardataset
parameter_list|,
name|dns_stub_t
modifier|*
name|stub
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|message_count
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_section_t
name|section
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notify_cancel
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notify_find_address
parameter_list|(
name|dns_notify_t
modifier|*
name|notify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notify_send
parameter_list|(
name|dns_notify_t
modifier|*
name|notify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|notify_createmessage
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|dns_message_t
modifier|*
modifier|*
name|messagep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notify_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notify_send_toaddr
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_dump
parameter_list|(
name|dns_zone_t
modifier|*
parameter_list|,
name|isc_boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|got_transfer_quota
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zmgr_start_xfrin_ifquota
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zmgr_resume_xfrs
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_boolean_t
name|multi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zonemgr_free
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zonemgr_getio
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_boolean_t
name|high
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_io_t
modifier|*
modifier|*
name|iop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zonemgr_putio
parameter_list|(
name|dns_io_t
modifier|*
modifier|*
name|iop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zonemgr_cancelio
parameter_list|(
name|dns_io_t
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_get_from_db
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|unsigned
name|int
modifier|*
name|nscount
parameter_list|,
name|unsigned
name|int
modifier|*
name|soacount
parameter_list|,
name|isc_uint32_t
modifier|*
name|serial
parameter_list|,
name|isc_uint32_t
modifier|*
name|refresh
parameter_list|,
name|isc_uint32_t
modifier|*
name|retry
parameter_list|,
name|isc_uint32_t
modifier|*
name|expire
parameter_list|,
name|isc_uint32_t
modifier|*
name|minimum
parameter_list|,
name|unsigned
name|int
modifier|*
name|errors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_freedbargs
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|forward_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_saveunique
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|templat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_maintenance
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_notify
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_done
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_signwithkey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_secalg_t
name|algorithm
parameter_list|,
name|isc_uint16_t
name|keyid
parameter_list|,
name|isc_boolean_t
name|delete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|delete_nsec
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_rekey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|zone_send_securedb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ENTER
value|zone_debuglog(zone, me, 1, "enter")
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|dbargc_default
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dbargv_default
index|[]
init|=
block|{
literal|"rbt"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DNS_ZONE_JITTER_ADD
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do { \ 		isc_interval_t _i; \ 		isc_uint32_t _j; \ 		_j = isc_random_jitter((b), (b)/4); \ 		isc_interval_set(&_i, _j, 0); \ 		if (isc_time_add((a),&_i, (c)) != ISC_R_SUCCESS) { \ 			dns_zone_log(zone, ISC_LOG_WARNING, \ 				     "epoch approaching: upgrade required: " \ 				     "now + %s failed", #b); \ 			isc_interval_set(&_i, _j/2, 0); \ 			(void)isc_time_add((a),&_i, (c)); \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|DNS_ZONE_TIME_ADD
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do { \ 		isc_interval_t _i; \ 		isc_interval_set(&_i, (b), 0); \ 		if (isc_time_add((a),&_i, (c)) != ISC_R_SUCCESS) { \ 			dns_zone_log(zone, ISC_LOG_WARNING, \ 				     "epoch approaching: upgrade required: " \ 				     "now + %s failed", #b); \ 			isc_interval_set(&_i, (b)/2, 0); \ 			(void)isc_time_add((a),&_i, (c)); \ 		} \ 	} while (0)
end_define

begin_typedef
typedef|typedef
name|struct
name|nsec3param
name|nsec3param_t
typedef|;
end_typedef

begin_struct
struct|struct
name|nsec3param
block|{
name|unsigned
name|char
name|data
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|isc_boolean_t
name|nsec
decl_stmt|;
name|isc_boolean_t
name|replace
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|nsec3param_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|nsec3param_t
argument_list|)
name|nsec3paramlist_t
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|np3event
block|{
name|isc_event_t
name|event
decl_stmt|;
name|nsec3param_t
name|params
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * Increment resolver-related statistics counters.  Zone must be locked.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|inc_stats
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|->
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|zone
operator|->
name|stats
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***  ***	Public functions.  ***/
end_comment

begin_function
name|isc_result_t
name|dns_zone_create
parameter_list|(
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|zone
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_zone
goto|;
name|result
operator|=
name|ZONEDB_INITLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_mutex
goto|;
comment|/* XXX MPA check that all elements are initialised */
ifdef|#
directive|ifdef
name|DNS_ZONE_CHECKLOCK
name|zone
operator|->
name|locked
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
name|zone
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|zmgr
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Implicit attach. */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_dblock
goto|;
name|zone
operator|->
name|irefs
operator|=
literal|0
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strnamerd
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|strname
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|strrdclass
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|strviewname
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|masterfile
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|masterformat
operator|=
name|dns_masterformat_none
expr_stmt|;
name|zone
operator|->
name|keydirectory
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|journalsize
operator|=
operator|-
literal|1
expr_stmt|;
name|zone
operator|->
name|journal
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|rdclass
operator|=
name|dns_rdataclass_none
expr_stmt|;
name|zone
operator|->
name|type
operator|=
name|dns_zone_none
expr_stmt|;
name|zone
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|options
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|keyopts
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|db_argc
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|db_argv
operator|=
name|NULL
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|loadtime
argument_list|)
expr_stmt|;
name|zone
operator|->
name|notifytime
operator|=
name|now
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshkeyinterval
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|refreshkeycount
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|refresh
operator|=
name|DNS_ZONE_DEFAULTREFRESH
expr_stmt|;
name|zone
operator|->
name|retry
operator|=
name|DNS_ZONE_DEFAULTRETRY
expr_stmt|;
name|zone
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|minimum
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|maxrefresh
operator|=
name|DNS_ZONE_MAXREFRESH
expr_stmt|;
name|zone
operator|->
name|minrefresh
operator|=
name|DNS_ZONE_MINREFRESH
expr_stmt|;
name|zone
operator|->
name|maxretry
operator|=
name|DNS_ZONE_MAXRETRY
expr_stmt|;
name|zone
operator|->
name|minretry
operator|=
name|DNS_ZONE_MINRETRY
expr_stmt|;
name|zone
operator|->
name|masters
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|masterkeynames
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|mastersok
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|masterscnt
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|notify
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|notifykeynames
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|notifytype
operator|=
name|dns_notifytype_yes
expr_stmt|;
name|zone
operator|->
name|notifycnt
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|loadtask
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|update_acl
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|forward_acl
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|notify_acl
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|query_acl
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|queryon_acl
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|xfr_acl
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|update_disabled
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|->
name|zero_no_soa_ttl
operator|=
name|ISC_TRUE
expr_stmt|;
name|zone
operator|->
name|check_names
operator|=
name|dns_severity_ignore
expr_stmt|;
name|zone
operator|->
name|request
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|lctx
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|readio
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|dctx
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|writeio
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|idlein
operator|=
name|DNS_DEFAULT_IDLEIN
expr_stmt|;
name|zone
operator|->
name|idleout
operator|=
name|DNS_DEFAULT_IDLEOUT
expr_stmt|;
name|zone
operator|->
name|log_key_expired_timer
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zone
operator|->
name|notifies
argument_list|)
expr_stmt|;
name|isc_sockaddr_any
argument_list|(
operator|&
name|zone
operator|->
name|notifysrc4
argument_list|)
expr_stmt|;
name|isc_sockaddr_any6
argument_list|(
operator|&
name|zone
operator|->
name|notifysrc6
argument_list|)
expr_stmt|;
name|isc_sockaddr_any
argument_list|(
operator|&
name|zone
operator|->
name|xfrsource4
argument_list|)
expr_stmt|;
name|isc_sockaddr_any6
argument_list|(
operator|&
name|zone
operator|->
name|xfrsource6
argument_list|)
expr_stmt|;
name|isc_sockaddr_any
argument_list|(
operator|&
name|zone
operator|->
name|altxfrsource4
argument_list|)
expr_stmt|;
name|isc_sockaddr_any6
argument_list|(
operator|&
name|zone
operator|->
name|altxfrsource6
argument_list|)
expr_stmt|;
name|zone
operator|->
name|xfr
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|tsigkey
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|maxxfrin
operator|=
name|MAX_XFER_TIME
expr_stmt|;
name|zone
operator|->
name|maxxfrout
operator|=
name|MAX_XFER_TIME
expr_stmt|;
name|zone
operator|->
name|ssutable
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|sigvalidityinterval
operator|=
literal|30
operator|*
literal|24
operator|*
literal|3600
expr_stmt|;
name|zone
operator|->
name|sigresigninginterval
operator|=
literal|7
operator|*
literal|24
operator|*
literal|3600
expr_stmt|;
name|zone
operator|->
name|view
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|acache
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|checkmx
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|checksrv
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|checkns
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|zone
operator|->
name|statelist
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|requeststats_on
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|->
name|statlevel
operator|=
name|dns_zonestat_none
expr_stmt|;
name|zone
operator|->
name|requeststats
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|rcvquerystats
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|notifydelay
operator|=
literal|5
expr_stmt|;
name|zone
operator|->
name|isself
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|isselfarg
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
name|zone
operator|->
name|signatures
operator|=
literal|10
expr_stmt|;
name|zone
operator|->
name|nodes
operator|=
literal|100
expr_stmt|;
name|zone
operator|->
name|privatetype
operator|=
operator|(
name|dns_rdatatype_t
operator|)
literal|0xffffU
expr_stmt|;
name|zone
operator|->
name|added
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|->
name|is_rpz
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zone
operator|->
name|forwards
argument_list|)
expr_stmt|;
name|zone
operator|->
name|raw
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|secure
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|sourceserial
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|sourceserialset
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|->
name|magic
operator|=
name|ZONE_MAGIC
expr_stmt|;
comment|/* Must be after magic is set. */
name|result
operator|=
name|dns_zone_setdbtype
argument_list|(
name|zone
argument_list|,
name|dbargc_default
argument_list|,
name|dbargv_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_erefs
goto|;
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|zone
operator|->
name|ctlevent
argument_list|,
sizeof|sizeof
argument_list|(
name|zone
operator|->
name|ctlevent
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_ZONECONTROL
argument_list|,
name|zone_shutdown
argument_list|,
name|zone
argument_list|,
name|zone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|zonep
operator|=
name|zone
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|free_erefs
label|:
name|isc_refcount_decrement
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|)
expr_stmt|;
name|free_dblock
label|:
name|ZONEDB_DESTROYLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|)
expr_stmt|;
name|free_mutex
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_zone
label|:
name|isc_mem_putanddetach
argument_list|(
operator|&
name|zone
operator|->
name|mctx
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a zone.  Because we require that there be no more  * outstanding events or references, no locking is necessary.  */
end_comment

begin_function
specifier|static
name|void
name|zone_free
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|dns_signing_t
modifier|*
name|signing
decl_stmt|;
name|dns_nsec3chain_t
modifier|*
name|nsec3chain
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|isc_refcount_current
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|irefs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|timer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|zmgr
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Managed objects.  Order is important. 	 */
if|if
condition|(
name|zone
operator|->
name|request
operator|!=
name|NULL
condition|)
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
comment|/* XXXMPA */
name|INSIST
argument_list|(
name|zone
operator|->
name|readio
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|statelist
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|writeio
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|loadtask
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|zone
operator|->
name|loadtask
argument_list|)
expr_stmt|;
comment|/* Unmanaged objects */
for|for
control|(
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
init|;
name|signing
operator|!=
name|NULL
condition|;
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|signing
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|signing
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|signing
argument_list|,
sizeof|sizeof
expr|*
name|signing
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
init|;
name|nsec3chain
operator|!=
name|NULL
condition|;
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|nsec3chain
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3chain
argument_list|,
sizeof|sizeof
expr|*
name|nsec3chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|)
expr_stmt|;
name|zone
operator|->
name|masterfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|keydirectory
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|keydirectory
argument_list|)
expr_stmt|;
name|zone
operator|->
name|keydirectory
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|journalsize
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|journal
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|journal
argument_list|)
expr_stmt|;
name|zone
operator|->
name|journal
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_detach
argument_list|(
operator|&
name|zone
operator|->
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|requeststats
operator|!=
name|NULL
condition|)
name|isc_stats_detach
argument_list|(
operator|&
name|zone
operator|->
name|requeststats
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|rcvquerystats
operator|!=
name|NULL
condition|)
name|dns_stats_detach
argument_list|(
operator|&
name|zone
operator|->
name|rcvquerystats
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|zone_detachdb
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|acache
operator|!=
name|NULL
condition|)
name|dns_acache_detach
argument_list|(
operator|&
name|zone
operator|->
name|acache
argument_list|)
expr_stmt|;
name|zone_freedbargs
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_zone_setmasterswithkeys
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_zone_setalsonotify
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|zone
operator|->
name|check_names
operator|=
name|dns_severity_ignore
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|update_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|forward_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|forward_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|notify_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|notify_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|query_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|query_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|queryon_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|queryon_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|xfr_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|xfr_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strnamerd
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strname
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strrdclass
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strrdclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strviewname
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strviewname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
condition|)
name|dns_ssutable_detach
argument_list|(
operator|&
name|zone
operator|->
name|ssutable
argument_list|)
expr_stmt|;
comment|/* last stuff */
name|ZONEDB_DESTROYLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|)
expr_stmt|;
name|zone
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|zone
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns ISC_TRUE iff this the signed side of an inline-signing zone.  * Caller should hold zone lock.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|inline_secure
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|raw
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns ISC_TRUE iff this the unsigned side of an inline-signing zone  * Caller should hold zone lock.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|inline_raw
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|secure
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Single shot.  */
end_comment

begin_function
name|void
name|dns_zone_setclass
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|)
block|{
name|char
name|namebuf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rdclass
operator|!=
name|dns_rdataclass_none
argument_list|)
expr_stmt|;
comment|/* 	 * Test and set. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|rdclass
operator|==
name|dns_rdataclass_none
operator|||
name|zone
operator|->
name|rdclass
operator|==
name|rdclass
argument_list|)
expr_stmt|;
name|zone
operator|->
name|rdclass
operator|=
name|rdclass
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strnamerd
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strrdclass
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strrdclass
argument_list|)
expr_stmt|;
name|zone_namerd_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strnamerd
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|zone_rdclass_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strrdclass
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|dns_zone_setclass
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|rdclass
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_rdataclass_t
name|dns_zone_getclass
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|rdclass
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setnotifytype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_notifytype_t
name|notifytype
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|notifytype
operator|=
name|notifytype
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_getserial2
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
modifier|*
name|serialp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|soacount
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|serialp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
name|serialp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|soacount
operator|==
literal|0
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
name|result
operator|=
name|DNS_R_NOTLOADED
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getserial
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|;
name|result
operator|=
name|dns_zone_getserial2
argument_list|(
name|zone
argument_list|,
operator|&
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|serial
operator|=
literal|0
expr_stmt|;
comment|/* XXX: not really correct, but no other choice */
return|return
operator|(
name|serial
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Single shot.  */
end_comment

begin_function
name|void
name|dns_zone_settype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_zonetype_t
name|type
parameter_list|)
block|{
name|char
name|namebuf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|dns_zone_none
argument_list|)
expr_stmt|;
comment|/* 	 * Test and set. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_none
operator|||
name|zone
operator|->
name|type
operator|==
name|type
argument_list|)
expr_stmt|;
name|zone
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strnamerd
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|)
expr_stmt|;
name|zone_namerd_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strnamerd
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_freedbargs
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Free the old database argument list. */
if|if
condition|(
name|zone
operator|->
name|db_argv
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|db_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|db_argv
argument_list|,
name|zone
operator|->
name|db_argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|zone
operator|->
name|db_argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|db_argc
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|db_argv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_getdbtype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|argv
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|argv
operator|!=
name|NULL
operator|&&
operator|*
name|argv
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|zone
operator|->
name|db_argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
name|size
operator|+=
name|strlen
argument_list|(
name|zone
operator|->
name|db_argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mem
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|mem
expr_stmt|;
name|tmp2
operator|=
name|mem
expr_stmt|;
name|tmp2
operator|+=
operator|(
name|zone
operator|->
name|db_argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|tmp
operator|++
operator|=
name|tmp2
expr_stmt|;
name|strcpy
argument_list|(
name|tmp2
argument_list|,
name|zone
operator|->
name|db_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tmp2
operator|+=
name|strlen
argument_list|(
name|tmp2
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|tmp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|=
name|mem
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setdbtype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|dbargc
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|dbargv
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|char
modifier|*
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbargc
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbargv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Set up a new database argument list. */
name|new
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|dbargc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbargc
condition|;
name|i
operator|++
control|)
name|new
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbargc
condition|;
name|i
operator|++
control|)
block|{
name|new
index|[
name|i
index|]
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|dbargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
block|}
comment|/* Free the old list. */
name|zone_freedbargs
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|db_argc
operator|=
name|dbargc
expr_stmt|;
name|zone
operator|->
name|db_argv
operator|=
name|new
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|unlock
goto|;
name|nomem
label|:
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbargc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|new
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|new
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|new
argument_list|,
name|dbargc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setview
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_view_t
modifier|*
name|view
parameter_list|)
block|{
name|char
name|namebuf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|!=
name|NULL
condition|)
name|dns_view_weakdetach
argument_list|(
operator|&
name|zone
operator|->
name|view
argument_list|)
expr_stmt|;
name|dns_view_weakattach
argument_list|(
name|view
argument_list|,
operator|&
name|zone
operator|->
name|view
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strviewname
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strviewname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strnamerd
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|)
expr_stmt|;
name|zone_namerd_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strnamerd
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|zone_viewname_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strviewname
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|dns_zone_setview
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|view
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_view_t
modifier|*
name|dns_zone_getview
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|view
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setorigin
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|origin
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
name|namebuf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|origin
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
block|{
name|dns_name_free
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_name_dup
argument_list|(
name|origin
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strnamerd
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|strname
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|strname
argument_list|)
expr_stmt|;
name|zone_namerd_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strnamerd
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|zone_name_tostr
argument_list|(
name|zone
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|zone
operator|->
name|strname
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|result
operator|=
name|dns_zone_setorigin
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setacache
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|acache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|acache
operator|!=
name|NULL
condition|)
name|dns_acache_detach
argument_list|(
operator|&
name|zone
operator|->
name|acache
argument_list|)
expr_stmt|;
name|dns_acache_attach
argument_list|(
name|acache
argument_list|,
operator|&
name|zone
operator|->
name|acache
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 		 * If the zone reuses an existing DB, the DB needs to be 		 * set in the acache explicitly.  We can safely ignore the 		 * case where the DB is already set.  If other error happens, 		 * the acache will not work effectively. 		 */
name|result
operator|=
name|dns_acache_setdb
argument_list|(
name|acache
argument_list|,
name|zone
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"dns_acache_setdb() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dns_zone_setstring
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
modifier|*
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|copy
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
else|else
block|{
name|copy
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|field
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|*
name|field
argument_list|)
expr_stmt|;
operator|*
name|field
operator|=
name|copy
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setfile
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
return|return
operator|(
name|dns_zone_setfile2
argument_list|(
name|zone
argument_list|,
name|file
argument_list|,
name|dns_masterformat_text
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setfile2
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_zone_setstring
argument_list|(
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|masterfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|zone
operator|->
name|masterformat
operator|=
name|format
expr_stmt|;
name|result
operator|=
name|default_journal
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dns_zone_getfile
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|masterfile
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|default_journal
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|journal
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
comment|/* Calculate string length including '\0'. */
name|int
name|len
init|=
name|strlen
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".jnl"
argument_list|)
decl_stmt|;
name|journal
operator|=
name|isc_mem_allocate
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|strcpy
argument_list|(
name|journal
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|journal
argument_list|,
literal|".jnl"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|journal
operator|=
name|NULL
expr_stmt|;
block|}
name|result
operator|=
name|dns_zone_setstring
argument_list|(
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|journal
argument_list|,
name|journal
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|journal
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setjournal
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|journal
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_zone_setstring
argument_list|(
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|journal
argument_list|,
name|journal
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dns_zone_getjournal
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|journal
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true iff the zone is "dynamic", in the sense that the zone's  * master file (if any) is written by the server, rather than being  * updated manually and read by the server.  *  * This is true for slave zones, stub zones, key zones, and zones that  * allow dynamic updates either by having an update policy ("ssutable")  * or an "allow-update" ACL with a value other than exactly "{ none; }".  */
end_comment

begin_function
name|isc_boolean_t
name|dns_zone_isdynamic
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|ignore_freeze
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* If !ignore_freeze, we need check whether updates are disabled.  */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
operator|(
operator|!
name|zone
operator|->
name|update_disabled
operator|||
name|ignore_freeze
operator|)
operator|&&
operator|(
operator|(
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
operator|&&
operator|!
name|dns_acl_isnone
argument_list|(
name|zone
operator|->
name|update_acl
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the response policy index and information for a zone.  */
end_comment

begin_function
name|isc_result_t
name|dns_zone_rpz_enable
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
comment|/* 	 * Only RBTDB zones can be used for response policy zones, 	 * because only they have the code to load the create the summary data. 	 * Only zones that are loaded instead of mmap()ed create the 	 * summary data and so can be policy zones. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
literal|"rbt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
literal|"rbt64"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|zone
operator|->
name|is_rpz
operator|=
name|ISC_TRUE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zone_get_rpz
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
return|return
operator|(
name|zone
operator|->
name|is_rpz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a zone is a response policy zone, mark its new database.  */
end_comment

begin_function
name|isc_result_t
name|dns_zone_rpz_enable_db
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|zone
operator|->
name|is_rpz
condition|)
return|return
operator|(
name|dns_db_rpz_enabled
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_load
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|isc_time_t
name|loadtime
decl_stmt|,
name|filetime
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|rbt
decl_stmt|,
name|hasraw
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|hasraw
operator|=
name|inline_secure
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasraw
condition|)
block|{
name|result
operator|=
name|zone_load
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|LOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
block|}
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|type
operator|!=
name|dns_zone_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADING
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_ZONELOADFLAG_THAW
operator|)
operator|!=
literal|0
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_THAW
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|INSIST
argument_list|(
name|zone
operator|->
name|db_argc
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|rbt
operator|=
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
literal|"rbt"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
literal|"rbt64"
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|masterfile
operator|==
name|NULL
operator|&&
name|rbt
condition|)
block|{
comment|/* 		 * The zone has no master file configured. 		 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
operator|&&
name|dns_zone_isdynamic
argument_list|(
name|zone
argument_list|,
name|ISC_FALSE
argument_list|)
condition|)
block|{
comment|/* 		 * This is a slave, stub, or dynamically updated 		 * zone being reloaded.  Do nothing - the database 		 * we already have is guaranteed to be up-to-date. 		 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|result
operator|=
name|DNS_R_DYNAMIC
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Store the current time before the zone is loaded, so that if the 	 * file changes between the time of the load and the time that 	 * zone->loadtime is set, then the file will still be reloaded 	 * the next time dns_zone_load is called. 	 */
name|TIME_NOW
argument_list|(
operator|&
name|loadtime
argument_list|)
expr_stmt|;
comment|/* 	 * Don't do the load if the file that stores the zone is older 	 * than the last time the zone was loaded.  If the zone has not 	 * been loaded yet, zone->loadtime will be the epoch. 	 */
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The file is already loaded.	If we are just doing a 		 * "rndc reconfig", we are done. 		 */
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|loadtime
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|DNS_ZONELOADFLAG_NOSTAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|isc_file_getmodtime
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|,
operator|&
name|filetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HASINCLUDE
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|filetime
argument_list|,
operator|&
name|zone
operator|->
name|loadtime
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"skipping load: master file "
literal|"older than last load"
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_UPTODATE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|loadtime
operator|=
name|filetime
expr_stmt|;
block|}
block|}
comment|/* 	 * Built in zones (with the exception of empty zones) don't need 	 * to be reloaded. 	 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
literal|"_builtin"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|zone
operator|->
name|db_argc
operator|<
literal|2
operator|||
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|1
index|]
argument_list|,
literal|"empty"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|!=
name|NULL
operator|)
operator|)
operator|&&
name|rbt
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|==
name|NULL
operator|||
operator|!
name|isc_file_exists
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"no master file"
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|refreshtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"starting load"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
operator|)
condition|?
name|dns_dbtype_stub
else|:
name|dns_dbtype_zone
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|zone
operator|->
name|db_argc
operator|-
literal|1
argument_list|,
name|zone
operator|->
name|db_argv
operator|+
literal|1
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"loading zone: creating database: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_db_settask
argument_list|(
name|db
argument_list|,
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_db_ispersistent
argument_list|(
name|db
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_startload
argument_list|(
name|db
argument_list|,
name|zone
argument_list|,
name|loadtime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|DNS_R_NOMASTERFILE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|==
name|NULL
operator|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"loading zone: "
literal|"no master file configured"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"loading zone: "
literal|"no master file configured: continuing"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_CONTINUE
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_ZONELOADFLAG_THAW
operator|)
operator|!=
literal|0
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_THAW
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|zone_postload
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|loadtime
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|hasraw
condition|)
name|UNLOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_load
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
return|return
operator|(
name|zone_load
argument_list|(
name|zone
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_loadnew
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
return|return
operator|(
name|zone_load
argument_list|(
name|zone
argument_list|,
name|DNS_ZONELOADFLAG_NOSTAT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_asyncload
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_asyncload_t
modifier|*
name|asl
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|asl
operator|->
name|zone
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|->
name|ev_attributes
operator|&
name|ISC_EVENTATTR_CANCELED
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_CANCELED
operator|||
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADPENDING
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|zone_load
argument_list|(
name|zone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADPENDING
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Inform the zone table we've finished loading */
if|if
condition|(
name|asl
operator|->
name|loaded
operator|!=
name|NULL
condition|)
call|(
name|asl
operator|->
name|loaded
call|)
argument_list|(
name|asl
operator|->
name|loaded_arg
argument_list|,
name|zone
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|asl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|asl
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_asyncload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_zt_zoneloaded_t
name|done
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|dns_asyncload_t
modifier|*
name|asl
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|zmgr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|asl
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|asl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asl
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|asl
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|asl
operator|->
name|loaded
operator|=
name|done
expr_stmt|;
name|asl
operator|->
name|loaded_arg
operator|=
name|arg
expr_stmt|;
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zone
operator|->
name|zmgr
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|zmgr
argument_list|,
name|DNS_EVENT_ZONELOAD
argument_list|,
name|zone_asyncload
argument_list|,
name|asl
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|asl
operator|->
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADPENDING
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|loadtask
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
if|if
condition|(
name|asl
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|asl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|asl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns__zone_loadpending
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADPENDING
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_loadandthaw
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
name|result
operator|=
name|zone_load
argument_list|(
name|zone
operator|->
name|secure
argument_list|,
name|DNS_ZONELOADFLAG_THAW
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|zone_load
argument_list|(
name|zone
argument_list|,
name|DNS_ZONELOADFLAG_THAW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|DNS_R_CONTINUE
case|:
comment|/* Deferred thaw. */
break|break;
case|case
name|DNS_R_UPTODATE
case|:
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|DNS_R_SEENINCLUDE
case|:
name|zone
operator|->
name|update_disabled
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|DNS_R_NOMASTERFILE
case|:
name|zone
operator|->
name|update_disabled
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
default|default:
comment|/* Error, remain in disabled state. */
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|get_master_options
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|unsigned
name|int
name|options
decl_stmt|;
name|options
operator|=
name|DNS_MASTER_ZONE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|==
name|NULL
operator|)
condition|)
name|options
operator||=
name|DNS_MASTER_SLAVE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
condition|)
name|options
operator||=
name|DNS_MASTER_KEY
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKNS
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_CHECKNS
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_FATALNS
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_FATALNS
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKNAMES
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_CHECKNAMES
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKNAMESFAIL
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_CHECKNAMESFAIL
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKMX
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_CHECKMX
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKMXFAIL
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_CHECKMXFAIL
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKWILDCARD
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_CHECKWILDCARD
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
operator|(
operator|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
operator|&&
operator|!
name|dns_acl_isnone
argument_list|(
name|zone
operator|->
name|update_acl
argument_list|)
operator|)
operator|||
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
operator|)
operator|)
condition|)
name|options
operator||=
name|DNS_MASTER_RESIGN
expr_stmt|;
return|return
operator|(
name|options
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_gotreadhandle
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_load_t
modifier|*
name|load
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LOAD_VALID
argument_list|(
name|load
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|->
name|ev_attributes
operator|&
name|ISC_EVENTATTR_CANCELED
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_CANCELED
condition|)
goto|goto
name|fail
goto|;
name|options
operator|=
name|get_master_options
argument_list|(
name|load
operator|->
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_master_loadfileinc3
argument_list|(
name|load
operator|->
name|zone
operator|->
name|masterfile
argument_list|,
name|dns_db_origin
argument_list|(
name|load
operator|->
name|db
argument_list|)
argument_list|,
name|dns_db_origin
argument_list|(
name|load
operator|->
name|db
argument_list|)
argument_list|,
name|load
operator|->
name|zone
operator|->
name|rdclass
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
operator|&
name|load
operator|->
name|callbacks
argument_list|,
name|task
argument_list|,
name|zone_loaddone
argument_list|,
name|load
argument_list|,
operator|&
name|load
operator|->
name|zone
operator|->
name|lctx
argument_list|,
name|load
operator|->
name|zone
operator|->
name|mctx
argument_list|,
name|load
operator|->
name|zone
operator|->
name|masterformat
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_CONTINUE
operator|&&
name|result
operator|!=
name|DNS_R_SEENINCLUDE
condition|)
goto|goto
name|fail
goto|;
return|return;
name|fail
label|:
name|zone_loaddone
argument_list|(
name|load
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_raw_serial
parameter_list|(
name|dns_zone_t
modifier|*
name|raw
parameter_list|,
name|dns_masterrawheader_t
modifier|*
name|rawdata
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|soacount
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|raw
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|raw
argument_list|,
name|raw
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|rawdata
operator|->
name|sourceserial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|soacount
operator|>
literal|0U
condition|)
name|rawdata
operator|->
name|flags
operator||=
name|DNS_MASTERRAW_SOURCESERIALSET
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|raw
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_gotwritehandle
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_gotwritehandle"
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_masterrawheader_t
name|rawdata
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|->
name|ev_attributes
operator|&
name|ISC_EVENTATTR_CANCELED
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_CANCELED
condition|)
goto|goto
name|fail
goto|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|dns_master_style_t
modifier|*
name|output_style
decl_stmt|;
name|dns_db_currentversion
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|dns_master_initrawheader
argument_list|(
operator|&
name|rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|get_raw_serial
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
operator|&
name|rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
condition|)
name|output_style
operator|=
operator|&
name|dns_master_style_keyzone
expr_stmt|;
else|else
name|output_style
operator|=
operator|&
name|dns_master_style_default
expr_stmt|;
name|result
operator|=
name|dns_master_dumpinc3
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|version
argument_list|,
name|output_style
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|dump_done
argument_list|,
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|dctx
argument_list|,
name|zone
operator|->
name|masterformat
argument_list|,
operator|&
name|rawdata
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DNS_R_CONTINUE
condition|)
goto|goto
name|fail
goto|;
return|return;
name|fail
label|:
name|dump_done
argument_list|(
name|zone
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save the raw serial number for inline-signing zones.  * (XXX: Other information from the header will be used  * for other purposes in the future, but for now this is  * all we're interested in.)  */
end_comment

begin_function
specifier|static
name|void
name|zone_setrawdata
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_masterrawheader_t
modifier|*
name|header
parameter_list|)
block|{
if|if
condition|(
operator|(
name|header
operator|->
name|flags
operator|&
name|DNS_MASTERRAW_SOURCESERIALSET
operator|)
operator|==
literal|0
condition|)
return|return;
name|zone
operator|->
name|sourceserial
operator|=
name|header
operator|->
name|sourceserial
expr_stmt|;
name|zone
operator|->
name|sourceserialset
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setrawdata
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_masterrawheader_t
modifier|*
name|header
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|==
name|NULL
condition|)
return|return;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_setrawdata
argument_list|(
name|zone
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_startload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_time_t
name|loadtime
parameter_list|)
block|{
name|dns_load_t
modifier|*
name|load
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|result
operator|=
name|dns_zone_rpz_enable_db
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|options
operator|=
name|get_master_options
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_MANYERRORS
argument_list|)
condition|)
name|options
operator||=
name|DNS_MASTER_MANYERRORS
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|zmgr
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|db
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|loadtask
operator|!=
name|NULL
condition|)
block|{
name|load
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|load
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|load
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|load
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|load
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|load
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|load
operator|->
name|loadtime
operator|=
name|loadtime
expr_stmt|;
name|load
operator|->
name|magic
operator|=
name|LOAD_MAGIC
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|load
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|load
operator|->
name|zone
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|load
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_rdatacallbacks_init
argument_list|(
operator|&
name|load
operator|->
name|callbacks
argument_list|)
expr_stmt|;
name|load
operator|->
name|callbacks
operator|.
name|rawdata
operator|=
name|zone_setrawdata
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|load
operator|->
name|callbacks
operator|.
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_beginload
argument_list|(
name|db
argument_list|,
operator|&
name|load
operator|->
name|callbacks
operator|.
name|add
argument_list|,
operator|&
name|load
operator|->
name|callbacks
operator|.
name|add_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|zonemgr_getio
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
name|ISC_TRUE
argument_list|,
name|zone
operator|->
name|loadtask
argument_list|,
name|zone_gotreadhandle
argument_list|,
name|load
argument_list|,
operator|&
name|zone
operator|->
name|readio
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * We can't report multiple errors so ignore 			 * the result of dns_db_endload(). 			 */
operator|(
name|void
operator|)
name|dns_db_endload
argument_list|(
name|load
operator|->
name|db
argument_list|,
operator|&
name|load
operator|->
name|callbacks
operator|.
name|add_private
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
block|}
else|else
block|{
name|dns_rdatacallbacks_t
name|callbacks
decl_stmt|;
name|dns_rdatacallbacks_init
argument_list|(
operator|&
name|callbacks
argument_list|)
expr_stmt|;
name|callbacks
operator|.
name|rawdata
operator|=
name|zone_setrawdata
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|callbacks
operator|.
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_beginload
argument_list|(
name|db
argument_list|,
operator|&
name|callbacks
operator|.
name|add
argument_list|,
operator|&
name|callbacks
operator|.
name|add_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|zone_idetach
argument_list|(
operator|&
name|callbacks
operator|.
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|dns_master_loadfile3
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
operator|&
name|callbacks
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|masterformat
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_db_endload
argument_list|(
name|db
argument_list|,
operator|&
name|callbacks
operator|.
name|add_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
name|zone_idetach
argument_list|(
operator|&
name|callbacks
operator|.
name|zone
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
name|cleanup
label|:
name|load
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|load
operator|->
name|db
argument_list|)
expr_stmt|;
name|zone_idetach
argument_list|(
operator|&
name|load
operator|->
name|zone
argument_list|)
expr_stmt|;
name|zone_idetach
argument_list|(
operator|&
name|load
operator|->
name|callbacks
operator|.
name|zone
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|load
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|load
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|load
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_check_mx
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|owner
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
name|ownerbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|altbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|foundname
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* 	 * "." means the services does not exist. 	 */
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|dns_rootname
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Outside of zone. 	 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|checkmx
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
name|zone
operator|->
name|checkmx
call|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
else|else
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|foundname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|ownerbuf
argument_list|,
sizeof|sizeof
name|ownerbuf
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
operator|||
name|result
operator|==
name|DNS_R_NXDOMAIN
operator|||
name|result
operator|==
name|DNS_R_EMPTYNAME
condition|)
block|{
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKMXFAIL
argument_list|)
condition|)
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/MX '%s' has no address records (A or AAAA)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|level
operator|==
name|ISC_LOG_WARNING
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_CNAME
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_WARNMXCNAME
argument_list|)
operator|||
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNOREMXCNAME
argument_list|)
condition|)
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNOREMXCNAME
argument_list|)
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/MX '%s' is a CNAME (illegal)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|level
operator|==
name|ISC_LOG_WARNING
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_DNAME
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_WARNMXCNAME
argument_list|)
operator|||
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNOREMXCNAME
argument_list|)
condition|)
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNOREMXCNAME
argument_list|)
condition|)
block|{
name|dns_name_format
argument_list|(
name|foundname
argument_list|,
name|altbuf
argument_list|,
sizeof|sizeof
name|altbuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/MX '%s' is below a DNAME"
literal|" '%s' (illegal)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|,
name|altbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|level
operator|==
name|ISC_LOG_WARNING
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|->
name|checkmx
operator|!=
name|NULL
operator|&&
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
return|return
operator|(
call|(
name|zone
operator|->
name|checkmx
call|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_check_srv
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|owner
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
name|ownerbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|altbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|foundname
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* 	 * "." means the services does not exist. 	 */
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|dns_rootname
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Outside of zone. 	 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|checksrv
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
name|zone
operator|->
name|checksrv
call|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
else|else
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|foundname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|ownerbuf
argument_list|,
sizeof|sizeof
name|ownerbuf
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
operator|||
name|result
operator|==
name|DNS_R_NXDOMAIN
operator|||
name|result
operator|==
name|DNS_R_EMPTYNAME
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/SRV '%s' has no address records (A or AAAA)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
comment|/* XXX950 make fatal for 9.5.0. */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_CNAME
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_WARNSRVCNAME
argument_list|)
operator|||
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNORESRVCNAME
argument_list|)
condition|)
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNORESRVCNAME
argument_list|)
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/SRV '%s' is a CNAME (illegal)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|level
operator|==
name|ISC_LOG_WARNING
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_DNAME
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_WARNSRVCNAME
argument_list|)
operator|||
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNORESRVCNAME
argument_list|)
condition|)
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IGNORESRVCNAME
argument_list|)
condition|)
block|{
name|dns_name_format
argument_list|(
name|foundname
argument_list|,
name|altbuf
argument_list|,
sizeof|sizeof
name|altbuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/SRV '%s' is below a "
literal|"DNAME '%s' (illegal)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|,
name|altbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|level
operator|==
name|ISC_LOG_WARNING
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|->
name|checksrv
operator|!=
name|NULL
operator|&&
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
return|return
operator|(
call|(
name|zone
operator|->
name|checksrv
call|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_check_glue
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|owner
parameter_list|)
block|{
name|isc_boolean_t
name|answer
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|tresult
decl_stmt|;
name|char
name|ownerbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|altbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|foundname
decl_stmt|;
name|dns_rdataset_t
name|a
decl_stmt|;
name|dns_rdataset_t
name|aaaa
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* 	 * Outside of zone. 	 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|checkns
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
name|zone
operator|->
name|checkns
call|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
else|else
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|foundname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|aaaa
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|DNS_DBFIND_GLUEOK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
operator|&
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
operator|||
name|result
operator|==
name|DNS_R_DELEGATION
operator|||
name|result
operator|==
name|DNS_R_GLUE
condition|)
block|{
name|tresult
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|DNS_DBFIND_GLUEOK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
operator|&
name|aaaa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|aaaa
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|tresult
operator|==
name|DNS_R_DELEGATION
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|aaaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_GLUE
operator|||
name|tresult
operator|==
name|DNS_R_GLUE
condition|)
block|{
comment|/* 			 * Check glue against child zone. 			 */
if|if
condition|(
name|zone
operator|->
name|checkns
operator|!=
name|NULL
condition|)
name|answer
operator|=
call|(
name|zone
operator|->
name|checkns
call|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|aaaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|a
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|aaaa
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|aaaa
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
block|}
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|ownerbuf
argument_list|,
sizeof|sizeof
name|ownerbuf
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
operator|||
name|result
operator|==
name|DNS_R_NXDOMAIN
operator|||
name|result
operator|==
name|DNS_R_EMPTYNAME
operator|||
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
name|isc_boolean_t
name|required
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|owner
argument_list|)
condition|)
block|{
name|what
operator|=
literal|"REQUIRED GLUE "
expr_stmt|;
name|required
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
name|what
operator|=
literal|"SIBLING GLUE "
expr_stmt|;
else|else
name|what
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DNS_R_DELEGATION
operator|||
name|required
operator|||
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKSIBLING
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/NS '%s' has no %s"
literal|"address records (A or AAAA)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|,
name|what
argument_list|)
expr_stmt|;
comment|/* 			 * Log missing address record. 			 */
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
operator|&&
name|zone
operator|->
name|checkns
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
name|zone
operator|->
name|checkns
argument_list|)
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|owner
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|aaaa
argument_list|)
expr_stmt|;
comment|/* XXX950 make fatal for 9.5.0. */
comment|/* answer = ISC_FALSE; */
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_CNAME
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/NS '%s' is a CNAME (illegal)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
comment|/* XXX950 make fatal for 9.5.0. */
comment|/* answer = ISC_FALSE; */
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_DNAME
condition|)
block|{
name|dns_name_format
argument_list|(
name|foundname
argument_list|,
name|altbuf
argument_list|,
sizeof|sizeof
name|altbuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/NS '%s' is below a DNAME '%s' (illegal)"
argument_list|,
name|ownerbuf
argument_list|,
name|namebuf
argument_list|,
name|altbuf
argument_list|)
expr_stmt|;
comment|/* XXX950 make fatal for 9.5.0. */
comment|/* answer = ISC_FALSE; */
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|a
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|aaaa
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|aaaa
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_rrset_check_dup
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|owner
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|dns_rdataset_t
name|tmprdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|format
init|=
name|ISC_TRUE
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_WARNING
decl_stmt|;
name|char
name|ownerbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|count1
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKDUPRRFAIL
argument_list|)
condition|)
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|tmprdataset
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata1
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|int
name|count2
init|=
literal|0
decl_stmt|;
name|count1
operator|++
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata1
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|rdataset
argument_list|,
operator|&
name|tmprdataset
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|tmprdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|tmprdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata2
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|count2
operator|++
expr_stmt|;
if|if
condition|(
name|count1
operator|>=
name|count2
condition|)
continue|continue;
name|dns_rdataset_current
argument_list|(
operator|&
name|tmprdataset
argument_list|,
operator|&
name|rdata2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_casecompare
argument_list|(
operator|&
name|rdata1
argument_list|,
operator|&
name|rdata2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format
condition|)
block|{
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|ownerbuf
argument_list|,
sizeof|sizeof
name|ownerbuf
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdata1
operator|.
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/%s has "
literal|"semantically identical records"
argument_list|,
name|ownerbuf
argument_list|,
name|typebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|ISC_LOG_ERROR
condition|)
name|answer
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
block|}
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|tmprdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|format
condition|)
break|break;
block|}
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_check_dup
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_dbiterator_t
modifier|*
name|dbiterator
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsit
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|ok
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|db
argument_list|,
literal|0
argument_list|,
operator|&
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
for|for
control|(
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|dbiterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|dbiterator
argument_list|)
control|)
block|{
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|rdsit
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsit
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsit
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|rdsit
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone_rrset_check_dup
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
operator|&
name|rdataset
argument_list|)
condition|)
name|ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsit
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dbiterator
argument_list|)
expr_stmt|;
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|isspf
parameter_list|(
specifier|const
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
init|=
name|rdata
operator|->
name|data
decl_stmt|;
name|unsigned
name|int
name|rdl
init|=
name|rdata
operator|->
name|length
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|,
name|tl
decl_stmt|,
name|len
decl_stmt|;
while|while
condition|(
name|rdl
operator|>
literal|0U
condition|)
block|{
name|len
operator|=
name|tl
operator|=
operator|*
name|data
expr_stmt|;
operator|++
name|data
expr_stmt|;
operator|--
name|rdl
expr_stmt|;
name|INSIST
argument_list|(
name|tl
operator|<=
name|rdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|i
operator|-
literal|1
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|i
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
name|data
operator|+=
name|tl
expr_stmt|;
name|rdl
operator|-=
name|tl
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|6U
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"v=spf1"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|buf
index|[
literal|6
index|]
operator|==
literal|0
operator|||
name|buf
index|[
literal|6
index|]
operator|==
literal|' '
operator|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|integrity_checks
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_dbiterator_t
modifier|*
name|dbiterator
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_t
name|fixedbottom
decl_stmt|;
name|dns_rdata_mx_t
name|mx
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|dns_rdata_in_srv_t
name|srv
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_name_t
modifier|*
name|bottom
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|ok
init|=
name|ISC_TRUE
decl_stmt|,
name|have_spf
decl_stmt|,
name|have_txt
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedbottom
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedbottom
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|db
argument_list|,
literal|0
argument_list|,
operator|&
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|dbiterator
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * Is this name visible in the zone? 		 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
operator|||
operator|(
name|dns_name_countlabels
argument_list|(
name|bottom
argument_list|)
operator|>
literal|0
operator|&&
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|bottom
argument_list|)
operator|)
condition|)
goto|goto
name|next
goto|;
comment|/* 		 * Don't check the NS records at the origin. 		 */
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
goto|goto
name|checkmx
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|checkmx
goto|;
comment|/* 		 * Remember bottom of zone. 		 */
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|bottom
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone_check_glue
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
name|ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
name|checkmx
label|:
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_mx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|checksrv
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|mx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone_check_mx
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
operator|&
name|mx
operator|.
name|mx
argument_list|,
name|name
argument_list|)
condition|)
name|ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|checksrv
label|:
if|if
condition|(
name|zone
operator|->
name|rdclass
operator|!=
name|dns_rdataclass_in
condition|)
goto|goto
name|next
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_srv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|checkspf
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|srv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone_check_srv
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
operator|&
name|srv
operator|.
name|target
argument_list|,
name|name
argument_list|)
condition|)
name|ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|checkspf
label|:
comment|/* 		 * Check if there is a type SPF record without an 		 * SPF-formatted type TXT record also being present. 		 */
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKSPF
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|zone
operator|->
name|rdclass
operator|!=
name|dns_rdataclass_in
condition|)
goto|goto
name|next
goto|;
name|have_spf
operator|=
name|have_txt
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_spf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|have_spf
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_txt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|notxt
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|have_txt
operator|=
name|isspf
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_txt
condition|)
break|break;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|notxt
label|:
if|if
condition|(
name|have_spf
operator|&&
operator|!
name|have_txt
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"'%s' found type "
literal|"SPF record but no SPF TXT record found, "
literal|"add matching type TXT record"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
name|next
label|:
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|dbiterator
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dbiterator
argument_list|)
expr_stmt|;
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OpenSSL verification of RSA keys with exponent 3 is known to be  * broken prior OpenSSL 0.9.8c/0.9.7k.	Look for such keys and warn  * if they are in use.  */
end_comment

begin_function
specifier|static
name|void
name|zone_check_dnskeys
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|logit
decl_stmt|,
name|foundrsa
init|=
name|ISC_FALSE
decl_stmt|,
name|foundmd5
init|=
name|ISC_FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|algorithm
decl_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dnskey
operator|.
name|algorithm
operator|==
name|DST_ALG_RSASHA1
operator|||
name|dnskey
operator|.
name|algorithm
operator|==
name|DST_ALG_RSAMD5
operator|)
operator|&&
name|dnskey
operator|.
name|datalen
operator|>
literal|1
operator|&&
name|dnskey
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|dnskey
operator|.
name|data
index|[
literal|1
index|]
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|dnskey
operator|.
name|algorithm
operator|==
name|DST_ALG_RSASHA1
condition|)
block|{
name|logit
operator|=
operator|!
name|foundrsa
expr_stmt|;
name|foundrsa
operator|=
name|ISC_TRUE
expr_stmt|;
name|algorithm
operator|=
literal|"RSASHA1"
expr_stmt|;
block|}
else|else
block|{
name|logit
operator|=
operator|!
name|foundmd5
expr_stmt|;
name|foundmd5
operator|=
name|ISC_TRUE
expr_stmt|;
name|algorithm
operator|=
literal|"RSAMD5"
expr_stmt|;
block|}
if|if
condition|(
name|logit
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"weak %s (%u) key found "
literal|"(exponent=3)"
argument_list|,
name|algorithm
argument_list|,
name|dnskey
operator|.
name|algorithm
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundrsa
operator|&&
name|foundmd5
condition|)
break|break;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_signingwithkey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|.
name|length
operator|!=
literal|5
operator|||
name|rdata
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|rdata
operator|.
name|data
index|[
literal|4
index|]
operator|!=
literal|0
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|=
name|zone_signwithkey
argument_list|(
name|zone
argument_list|,
name|rdata
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
operator|(
name|rdata
operator|.
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|rdata
operator|.
name|data
index|[
literal|2
index|]
argument_list|,
name|ISC_TF
argument_list|(
name|rdata
operator|.
name|data
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_signwithkey failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_addnsec3chain
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdata_nsec3param_t
modifier|*
name|nsec3param
parameter_list|)
block|{
name|dns_nsec3chain_t
modifier|*
name|nsec3chain
decl_stmt|,
modifier|*
name|current
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|nseconly
init|=
name|ISC_FALSE
decl_stmt|,
name|nsec3ok
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|unsigned
name|int
name|options
init|=
literal|0
decl_stmt|;
name|char
name|saltbuf
index|[
literal|255
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|flags
index|[
sizeof|sizeof
argument_list|(
literal|"INITIAL|REMOVE|CREATE|NONSEC|OPTOUT"
argument_list|)
index|]
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_nsec_nseconly
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|nseconly
argument_list|)
expr_stmt|;
name|nsec3ok
operator|=
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|nseconly
operator|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsec3ok
operator|&&
operator|(
name|nsec3param
operator|->
name|flags
operator|&
name|DNS_NSEC3FLAG_REMOVE
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|nsec3chain
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
expr|*
name|nsec3chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|nsec3chain
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|nsec3chain
operator|->
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|nsec3chain
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|nsec3chain
operator|->
name|dbiterator
operator|=
name|NULL
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|common
operator|.
name|rdclass
operator|=
name|nsec3param
operator|->
name|common
operator|.
name|rdclass
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|common
operator|.
name|rdtype
operator|=
name|nsec3param
operator|->
name|common
operator|.
name|rdtype
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|hash
operator|=
name|nsec3param
operator|->
name|hash
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|iterations
operator|=
name|nsec3param
operator|->
name|iterations
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|flags
operator|=
name|nsec3param
operator|->
name|flags
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|salt_length
operator|=
name|nsec3param
operator|->
name|salt_length
expr_stmt|;
name|memmove
argument_list|(
name|nsec3chain
operator|->
name|salt
argument_list|,
name|nsec3param
operator|->
name|salt
argument_list|,
name|nsec3param
operator|->
name|salt_length
argument_list|)
expr_stmt|;
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|salt
operator|=
name|nsec3chain
operator|->
name|salt
expr_stmt|;
name|nsec3chain
operator|->
name|seen_nsec
operator|=
name|ISC_FALSE
expr_stmt|;
name|nsec3chain
operator|->
name|delete_nsec
operator|=
name|ISC_FALSE
expr_stmt|;
name|nsec3chain
operator|->
name|save_delete_nsec
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|->
name|flags
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|flags
argument_list|,
literal|"NONE"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|flags
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|->
name|flags
operator|&
name|DNS_NSEC3FLAG_REMOVE
condition|)
name|strlcat
argument_list|(
name|flags
argument_list|,
literal|"REMOVE"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|->
name|flags
operator|&
name|DNS_NSEC3FLAG_INITIAL
condition|)
block|{
if|if
condition|(
name|flags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcpy
argument_list|(
name|flags
argument_list|,
literal|"INITIAL"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|flags
argument_list|,
literal|"|INITIAL"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsec3param
operator|->
name|flags
operator|&
name|DNS_NSEC3FLAG_CREATE
condition|)
block|{
if|if
condition|(
name|flags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcpy
argument_list|(
name|flags
argument_list|,
literal|"CREATE"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|flags
argument_list|,
literal|"|CREATE"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsec3param
operator|->
name|flags
operator|&
name|DNS_NSEC3FLAG_NONSEC
condition|)
block|{
if|if
condition|(
name|flags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcpy
argument_list|(
name|flags
argument_list|,
literal|"NONSEC"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|flags
argument_list|,
literal|"|NONSEC"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsec3param
operator|->
name|flags
operator|&
name|DNS_NSEC3FLAG_OPTOUT
condition|)
block|{
if|if
condition|(
name|flags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcpy
argument_list|(
name|flags
argument_list|,
literal|"OPTOUT"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|flags
argument_list|,
literal|"|OPTOUT"
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsec3param
operator|->
name|salt_length
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|saltbuf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|saltbuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsec3param
operator|->
name|salt_length
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
operator|&
name|saltbuf
index|[
name|i
operator|*
literal|2
index|]
argument_list|,
literal|"%02X"
argument_list|,
name|nsec3chain
operator|->
name|salt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"zone_addnsec3chain(%u,%s,%u,%s)"
argument_list|,
name|nsec3param
operator|->
name|hash
argument_list|,
name|flags
argument_list|,
name|nsec3param
operator|->
name|iterations
argument_list|,
name|saltbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|current
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|current
operator|->
name|db
operator|==
name|db
operator|&&
name|current
operator|->
name|nsec3param
operator|.
name|hash
operator|==
name|nsec3param
operator|->
name|hash
operator|&&
name|current
operator|->
name|nsec3param
operator|.
name|iterations
operator|==
name|nsec3param
operator|->
name|iterations
operator|&&
name|current
operator|->
name|nsec3param
operator|.
name|salt_length
operator|==
name|nsec3param
operator|->
name|salt_length
operator|&&
operator|!
name|memcmp
argument_list|(
name|current
operator|->
name|nsec3param
operator|.
name|salt
argument_list|,
name|nsec3param
operator|->
name|salt
argument_list|,
name|nsec3param
operator|->
name|salt_length
argument_list|)
condition|)
name|current
operator|->
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|nsec3chain
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_CREATE
operator|)
operator|!=
literal|0
condition|)
name|options
operator|=
name|DNS_DB_NONSEC3
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|nsec3chain
operator|->
name|db
argument_list|,
name|options
argument_list|,
operator|&
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_dbiterator_first
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|nsec3chain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|)
condition|)
block|{
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone
operator|->
name|nsec3chaintime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nsec3chain
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|nsec3chain
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|->
name|dbiterator
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3chain
argument_list|,
sizeof|sizeof
expr|*
name|nsec3chain
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_addnsec3chain
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_nsec3param_t
name|nsec3param
decl_stmt|;
name|isc_boolean_t
name|nseconly
init|=
name|ISC_FALSE
decl_stmt|,
name|nsec3ok
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|privatetype
operator|==
literal|0
condition|)
return|return;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_nsec_nseconly
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|nseconly
argument_list|)
expr_stmt|;
name|nsec3ok
operator|=
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|nseconly
operator|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|unsigned
name|char
name|buf
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
index|]
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|private
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|private
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_nsec3param_fromprivate
argument_list|(
operator|&
name|private
argument_list|,
operator|&
name|rdata
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
continue|continue;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3param
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nsec3param
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_REMOVE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|nsec3param
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_CREATE
operator|)
operator|!=
literal|0
operator|&&
name|nsec3ok
operator|)
condition|)
block|{
name|result
operator|=
name|zone_addnsec3chain
argument_list|(
name|zone
argument_list|,
operator|&
name|nsec3param
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_addnsec3chain failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_resigntime
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|unsigned
name|int
name|resign
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|nanosecs
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
operator|=
name|dns_db_getsigningtime
argument_list|(
name|db
argument_list|,
operator|&
name|rdataset
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|resign
operator|=
name|rdataset
operator|.
name|resign
operator|-
name|zone
operator|->
name|sigresigninginterval
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|isc_random_get
argument_list|(
operator|&
name|nanosecs
argument_list|)
expr_stmt|;
name|nanosecs
operator|%=
literal|1000000000
expr_stmt|;
name|isc_time_set
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|,
name|resign
argument_list|,
name|nanosecs
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_nsec3param
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_rdata_nsec3param_t
name|nsec3param
decl_stmt|;
name|isc_boolean_t
name|ok
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_boolean_t
name|dynamic
init|=
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|)
condition|?
name|dns_zone_isdynamic
argument_list|(
name|zone
argument_list|,
name|ISC_FALSE
argument_list|)
else|:
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"nsec3param lookup failure: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"nsec3param lookup failure: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * For dynamic zones we must support every algorithm so we can 	 * regenerate all the NSEC3 chains. 	 * For non-dynamic zones we only need to find a supported algorithm. 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3param
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_NSEC3TESTZONE
argument_list|)
operator|&&
name|nsec3param
operator|.
name|hash
operator|==
name|DNS_NSEC3_UNKNOWNALG
operator|&&
operator|!
name|dynamic
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"nsec3 test \"unknown\" hash algorithm found: %u"
argument_list|,
name|nsec3param
operator|.
name|hash
argument_list|)
expr_stmt|;
name|ok
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dns_nsec3_supportedhash
argument_list|(
name|nsec3param
operator|.
name|hash
argument_list|)
condition|)
block|{
if|if
condition|(
name|dynamic
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unsupported nsec3 hash algorithm"
literal|" in dynamic zone: %u"
argument_list|,
name|nsec3param
operator|.
name|hash
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
comment|/* Stop second error message. */
name|ok
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
else|else
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unsupported nsec3 hash algorithm: %u"
argument_list|,
name|nsec3param
operator|.
name|hash
argument_list|)
expr_stmt|;
block|}
else|else
name|ok
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"no supported nsec3 hash algorithm"
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the timer for refreshing the key zone to the soonest future time  * of the set (current timer, keydata->refresh, keydata->addhd,  * keydata->removehd).  */
end_comment

begin_function
specifier|static
name|void
name|set_refreshkeytimer
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdata_keydata_t
modifier|*
name|key
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"set_refreshkeytimer"
decl_stmt|;
name|isc_stdtime_t
name|then
decl_stmt|;
name|isc_time_t
name|timenow
decl_stmt|,
name|timethen
decl_stmt|;
name|char
name|timebuf
index|[
literal|80
index|]
decl_stmt|;
name|ENTER
expr_stmt|;
name|then
operator|=
name|key
operator|->
name|refresh
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|addhd
operator|>
name|now
operator|&&
name|key
operator|->
name|addhd
operator|<
name|then
condition|)
name|then
operator|=
name|key
operator|->
name|addhd
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|removehd
operator|>
name|now
operator|&&
name|key
operator|->
name|removehd
operator|<
name|then
condition|)
name|then
operator|=
name|key
operator|->
name|removehd
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
if|if
condition|(
name|then
operator|>
name|now
condition|)
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|timenow
argument_list|,
name|then
operator|-
name|now
argument_list|,
operator|&
name|timethen
argument_list|)
expr_stmt|;
else|else
name|timethen
operator|=
name|timenow
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
operator|&
name|timenow
argument_list|)
operator|<
literal|0
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|timethen
argument_list|,
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
operator|<
literal|0
condition|)
name|zone
operator|->
name|refreshkeytime
operator|=
name|timethen
expr_stmt|;
name|isc_time_formattimestamp
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
name|timebuf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"next key refresh: %s"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|timenow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert key(s) linked from 'keynode' to KEYDATA and add to the key zone.  * If the key zone is changed, set '*changed' to ISC_TRUE.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|create_keydata
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_keytable_t
modifier|*
name|keytable
parameter_list|,
name|dns_keynode_t
modifier|*
modifier|*
name|keynodep
parameter_list|,
name|isc_boolean_t
modifier|*
name|changed
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"create_keydata"
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_buffer_t
name|keyb
decl_stmt|,
name|dstb
decl_stmt|;
name|unsigned
name|char
name|key_buf
index|[
literal|4096
index|]
decl_stmt|,
name|dst_buf
index|[
name|DST_KEY_MAXSIZE
index|]
decl_stmt|;
name|dns_rdata_keydata_t
name|keydata
decl_stmt|;
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_keynode_t
modifier|*
name|keynode
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dst_key_t
modifier|*
name|key
decl_stmt|;
name|REQUIRE
argument_list|(
name|keynodep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|keynode
operator|=
operator|*
name|keynodep
expr_stmt|;
name|ENTER
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Loop in case there's more than one key. */
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_keynode_t
modifier|*
name|nextnode
init|=
name|NULL
decl_stmt|;
name|key
operator|=
name|dns_keynode_key
argument_list|(
name|keynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
goto|goto
name|skip
goto|;
name|isc_buffer_init
argument_list|(
operator|&
name|dstb
argument_list|,
name|dst_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_buf
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dst_key_todns
argument_list|(
name|key
argument_list|,
operator|&
name|dstb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert DST key to DNSKEY. */
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|dstb
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
operator|&
name|rdata
argument_list|,
name|dst_key_class
argument_list|(
name|key
argument_list|)
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
comment|/* DSTKEY to KEYDATA. */
name|CHECK
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_keydata_fromdnskey
argument_list|(
operator|&
name|keydata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|now
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* KEYDATA to rdata. */
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|keyb
argument_list|,
name|key_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|key_buf
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rdata
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_keydata
argument_list|,
operator|&
name|keydata
argument_list|,
operator|&
name|keyb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add rdata to zone. */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|dst_key_name
argument_list|(
name|key
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changed
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* Refresh new keys from the zone apex as soon as possible. */
name|set_refreshkeytimer
argument_list|(
name|zone
argument_list|,
operator|&
name|keydata
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|skip
label|:
name|result
operator|=
name|dns_keytable_nextkeynode
argument_list|(
name|keytable
argument_list|,
name|keynode
argument_list|,
operator|&
name|nextnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|dns_keytable_detachkeynode
argument_list|(
name|keytable
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
name|keynode
operator|=
name|nextnode
expr_stmt|;
block|}
block|}
if|if
condition|(
name|keynode
operator|!=
name|NULL
condition|)
name|dns_keytable_detachkeynode
argument_list|(
name|keytable
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
operator|*
name|keynodep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove from the key zone all the KEYDATA records found in rdataset.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|delete_keydata
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|uresult
decl_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|uresult
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|uresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|uresult
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the DNSSEC key ID for a DNSKEY record.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|compute_tag
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdata_dnskey_t
modifier|*
name|dnskey
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_keytag_t
modifier|*
name|tag
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|4096
index|]
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|dst_key_t
modifier|*
name|dstkey
init|=
name|NULL
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rdata
argument_list|,
name|dnskey
operator|->
name|common
operator|.
name|rdclass
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dnskey
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_keyfromrdata
argument_list|(
name|name
argument_list|,
operator|&
name|rdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|*
name|tag
operator|=
name|dst_key_id
argument_list|(
name|dstkey
argument_list|)
expr_stmt|;
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add key to the security roots.  */
end_comment

begin_function
specifier|static
name|void
name|trust_key
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|keyname
parameter_list|,
name|dns_rdata_dnskey_t
modifier|*
name|dnskey
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|4096
index|]
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|dns_keytable_t
modifier|*
name|sr
init|=
name|NULL
decl_stmt|;
name|dst_key_t
modifier|*
name|dstkey
init|=
name|NULL
decl_stmt|;
comment|/* Convert dnskey to DST key. */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rdata
argument_list|,
name|dnskey
operator|->
name|common
operator|.
name|rdclass
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dnskey
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_view_getsecroots
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|CHECK
argument_list|(
name|dns_dnssec_keyfromrdata
argument_list|(
name|keyname
argument_list|,
operator|&
name|rdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_keytable_add
argument_list|(
name|sr
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|dstkey
argument_list|)
argument_list|)
expr_stmt|;
name|dns_keytable_detach
argument_list|(
operator|&
name|sr
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dstkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|dns_keytable_detach
argument_list|(
operator|&
name|sr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Add a null key to the security roots for so that all queries  * to the zone will fail.  */
end_comment

begin_function
specifier|static
name|void
name|fail_secure
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|keyname
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_keytable_t
modifier|*
name|sr
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_view_getsecroots
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_keytable_marksecure
argument_list|(
name|sr
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|dns_keytable_detach
argument_list|(
operator|&
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Scan a set of KEYDATA records from the key zone.  The ones that are  * valid (i.e., the add holddown timer has expired) become trusted keys.  */
end_comment

begin_function
specifier|static
name|void
name|load_secroots
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_keydata_t
name|keydata
decl_stmt|;
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|zone
operator|->
name|mctx
decl_stmt|;
name|int
name|trusted
init|=
literal|0
decl_stmt|,
name|revoked
init|=
literal|0
decl_stmt|,
name|pending
init|=
literal|0
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|dns_keytable_t
modifier|*
name|sr
init|=
name|NULL
decl_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_view_getsecroots
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_keytable_delete
argument_list|(
name|sr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dns_keytable_detach
argument_list|(
operator|&
name|sr
argument_list|)
expr_stmt|;
block|}
comment|/* Now insert all the accepted trust anchors from this keydata set. */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* Convert rdata to keydata. */
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|keydata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_UNEXPECTEDEND
condition|)
continue|continue;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Set the key refresh timer. */
name|set_refreshkeytimer
argument_list|(
name|zone
argument_list|,
operator|&
name|keydata
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* If the removal timer is nonzero, this key was revoked. */
if|if
condition|(
name|keydata
operator|.
name|removehd
operator|!=
literal|0
condition|)
block|{
name|revoked
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the add timer is still pending, this key is not 		 * trusted yet. 		 */
if|if
condition|(
name|now
operator|<
name|keydata
operator|.
name|addhd
condition|)
block|{
name|pending
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Convert keydata to dnskey. */
name|dns_keydata_todnskey
argument_list|(
operator|&
name|keydata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Add to keytables. */
name|trusted
operator|++
expr_stmt|;
name|trust_key
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
operator|&
name|dnskey
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trusted
operator|==
literal|0
operator|&&
name|pending
operator|!=
literal|0
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"No valid trust anchors for '%s'!"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%d key(s) revoked, %d still pending"
argument_list|,
name|revoked
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"All queries to '%s' will fail"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|fail_secure
argument_list|(
name|zone
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|do_one_tuple
parameter_list|(
name|dns_difftuple_t
modifier|*
modifier|*
name|tuple
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_diff_t
name|temp_diff
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Create a singleton diff. 	 */
name|dns_diff_init
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
operator|&
name|temp_diff
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|temp_diff
operator|.
name|tuples
argument_list|,
operator|*
name|tuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Apply it to the database. 	 */
name|result
operator|=
name|dns_diff_apply
argument_list|(
operator|&
name|temp_diff
argument_list|,
name|db
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|temp_diff
operator|.
name|tuples
argument_list|,
operator|*
name|tuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_difftuple_free
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Merge it into the current pending journal entry. 	 */
name|dns_diff_appendminimal
argument_list|(
name|diff
argument_list|,
name|tuple
argument_list|)
expr_stmt|;
comment|/* 	 * Do not clear temp_diff. 	 */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|update_one_rr
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_diffop_t
name|op
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_difftuple_create
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
return|return
operator|(
name|do_one_tuple
argument_list|(
operator|&
name|tuple
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|update_soa_serial
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_updatemethod_t
name|method
parameter_list|)
block|{
name|dns_difftuple_t
modifier|*
name|deltuple
init|=
name|NULL
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|addtuple
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|dns_db_createsoatuple
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|mctx
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
operator|&
name|deltuple
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_difftuple_copy
argument_list|(
name|deltuple
argument_list|,
operator|&
name|addtuple
argument_list|)
argument_list|)
expr_stmt|;
name|addtuple
operator|->
name|op
operator|=
name|DNS_DIFFOP_ADD
expr_stmt|;
name|serial
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|addtuple
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|serial
operator|=
name|dns_update_soaserial
argument_list|(
name|serial
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|dns_soa_setserial
argument_list|(
name|serial
argument_list|,
operator|&
name|addtuple
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|do_one_tuple
argument_list|(
operator|&
name|deltuple
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|do_one_tuple
argument_list|(
operator|&
name|addtuple
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|addtuple
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
operator|&
name|addtuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltuple
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
operator|&
name|deltuple
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write all transactions in 'diff' to the zone journal file.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|zone_journal
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|isc_uint32_t
modifier|*
name|sourceserial
parameter_list|,
specifier|const
name|char
modifier|*
name|caller
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_journal"
decl_stmt|;
specifier|const
name|char
modifier|*
name|journalfile
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_journal_t
modifier|*
name|journal
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|mode
init|=
name|DNS_JOURNAL_CREATE
operator||
name|DNS_JOURNAL_WRITE
decl_stmt|;
name|ENTER
expr_stmt|;
name|journalfile
operator|=
name|dns_zone_getjournal
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|journalfile
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_journal_open
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|journalfile
argument_list|,
name|mode
argument_list|,
operator|&
name|journal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s:dns_journal_open -> %s"
argument_list|,
name|caller
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|sourceserial
operator|!=
name|NULL
condition|)
name|dns_journal_set_sourceserial
argument_list|(
name|journal
argument_list|,
operator|*
name|sourceserial
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_journal_write_transaction
argument_list|(
name|journal
argument_list|,
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s:dns_journal_write_transaction -> %s"
argument_list|,
name|caller
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_journal_destroy
argument_list|(
operator|&
name|journal
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an SOA record for a newly-created zone  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|add_soa
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DNS_SOA_BUFFERSIZE
index|]
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"creating SOA"
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"add_soa:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Build SOA record */
name|result
operator|=
name|dns_soa_buildrdata
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rootname
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"add_soa:dns_soa_buildrdata -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|failure
label|:
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|ISC_TF
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Synchronize the set of initializing keys found in managed-keys {}  * statements with the set of trust anchors found in the managed-keys.bind  * zone.  If a domain is no longer named in managed-keys, delete all keys  * from that domain from the key zone.	If a domain is mentioned in in  * managed-keys but there are no references to it in the key zone, load  * the key zone with the initializing key(s) for that domain.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|sync_keyzone
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|changed
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|dns_fixedname_t
name|fn
decl_stmt|;
name|dns_name_t
name|foundname
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|dns_keynode_t
modifier|*
name|keynode
init|=
name|NULL
decl_stmt|;
name|dns_view_t
modifier|*
name|view
init|=
name|zone
operator|->
name|view
decl_stmt|;
name|dns_keytable_t
modifier|*
name|sr
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|dns_rriterator_t
name|rrit
decl_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"synchronizing trusted keys"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fn
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fn
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_view_getsecroots
argument_list|(
name|view
argument_list|,
operator|&
name|sr
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"sync_keyzone:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Walk the zone DB.  If we find any keys whose names are no longer 	 * in managed-keys (or *are* in trusted-keys, meaning they are 	 * permanent and not RFC5011-maintained), delete them from the 	 * zone.  Otherwise call load_secroots(), which loads keys into 	 * secroots as appropriate. 	 */
name|dns_rriterator_init
argument_list|(
operator|&
name|rrit
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rriterator_first
argument_list|(
operator|&
name|rrit
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rriterator_nextrrset
argument_list|(
operator|&
name|rrit
argument_list|)
control|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|rrname
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_rriterator_current
argument_list|(
operator|&
name|rrit
argument_list|,
operator|&
name|rrname
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|dns_rriterator_destroy
argument_list|(
operator|&
name|rrit
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_keydata
condition|)
continue|continue;
name|result
operator|=
name|dns_keytable_find
argument_list|(
name|sr
argument_list|,
name|rrname
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_PARTIALMATCH
operator|)
operator|||
name|dns_keynode_managed
argument_list|(
name|keynode
argument_list|)
operator|==
name|ISC_FALSE
condition|)
block|{
name|CHECK
argument_list|(
name|delete_keydata
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|rrname
argument_list|,
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|load_secroots
argument_list|(
name|zone
argument_list|,
name|rrname
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keynode
operator|!=
name|NULL
condition|)
name|dns_keytable_detachkeynode
argument_list|(
name|sr
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
block|}
name|dns_rriterator_destroy
argument_list|(
operator|&
name|rrit
argument_list|)
expr_stmt|;
comment|/* 	 * Now walk secroots to find any managed keys that aren't 	 * in the zone.  If we find any, we add them to the zone. 	 */
name|RWLOCK
argument_list|(
operator|&
name|sr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|chain
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_first
argument_list|(
operator|&
name|chain
argument_list|,
name|sr
operator|->
name|table
argument_list|,
operator|&
name|foundname
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|NULL
decl_stmt|;
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|chain
argument_list|,
operator|&
name|foundname
argument_list|,
name|origin
argument_list|,
operator|&
name|rbtnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtnode
operator|->
name|data
operator|==
name|NULL
condition|)
goto|goto
name|skip
goto|;
name|dns_keytable_attachkeynode
argument_list|(
name|sr
argument_list|,
name|rbtnode
operator|->
name|data
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_keynode_managed
argument_list|(
name|keynode
argument_list|)
condition|)
block|{
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
decl_stmt|;
name|dst_key_t
modifier|*
name|key
decl_stmt|;
name|key
operator|=
name|dns_keynode_key
argument_list|(
name|keynode
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
comment|/* fail_secure() was called. */
goto|goto
name|skip
goto|;
name|keyname
operator|=
name|dst_key_name
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|keyname
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_keydata
argument_list|,
name|DNS_DBFIND_NOWILD
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|create_keydata
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|sr
argument_list|,
operator|&
name|keynode
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
name|skip
label|:
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
operator|&
name|chain
argument_list|,
operator|&
name|foundname
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|!=
name|NULL
condition|)
name|dns_keytable_detachkeynode
argument_list|(
name|sr
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|sr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
comment|/* Write changes to journal file. */
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
operator|&
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"sync_keyzone"
argument_list|)
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unable to synchronize managed keys: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keynode
operator|!=
name|NULL
condition|)
name|dns_keytable_detachkeynode
argument_list|(
name|sr
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|dns_keytable_detach
argument_list|(
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_synckeyzone
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|!=
name|dns_zone_key
condition|)
return|return
operator|(
name|DNS_R_BADZONE
operator|)
return|;
name|CHECK
argument_list|(
name|dns_zone_getdb
argument_list|(
name|zone
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|sync_keyzone
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_send_secure
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * We've finished loading, or else failed to load, an inline-signing 	 * 'secure' zone.  We now need information about the status of the 	 * 'raw' zone.  If we failed to load, then we need it to send a 	 * copy of its database; if we succeeded, we need it to send its 	 * serial number so that we can sync with it.  If it has not yet 	 * loaded, we set a flag so that it will send the necessary 	 * information when it has finished loading. 	 */
if|if
condition|(
name|zone
operator|->
name|raw
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|isc_uint32_t
name|serial
decl_stmt|;
name|unsigned
name|int
name|soacount
decl_stmt|;
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|zone
operator|->
name|raw
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|serial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|soacount
operator|>
literal|0U
condition|)
name|zone_send_secureserial
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
else|else
name|zone_send_securedb
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|zone
operator|->
name|raw
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
else|else
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|DNS_ZONEFLG_SENDSECURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_unchanged
parameter_list|(
name|dns_db_t
modifier|*
name|db1
parameter_list|,
name|dns_db_t
modifier|*
name|db2
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_diffx
argument_list|(
operator|&
name|diff
argument_list|,
name|db1
argument_list|,
name|NULL
argument_list|,
name|db2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|.
name|tuples
argument_list|)
condition|)
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The zone is presumed to be locked.  * If this is a inline_raw zone the secure version is also locked.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|zone_postload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_time_t
name|loadtime
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|unsigned
name|int
name|soacount
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nscount
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|,
name|oldserial
decl_stmt|,
name|refresh
decl_stmt|,
name|retry
decl_stmt|,
name|expire
decl_stmt|,
name|minimum
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|isc_boolean_t
name|needdump
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|hasinclude
init|=
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HASINCLUDE
argument_list|)
decl_stmt|;
name|isc_boolean_t
name|nomaster
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|INSIST
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
name|INSIST
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
operator|->
name|secure
argument_list|)
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Initiate zone transfer?  We may need a error code that 	 * indicates that the "permanent" form does not exist. 	 * XXX better error feedback to log. 	 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_SEENINCLUDE
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"no master file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|!=
name|DNS_R_NOMASTERFILE
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"loading from master file %s "
literal|"failed: %s"
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|inline_secure
argument_list|(
name|zone
argument_list|)
operator|&&
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"no master file, requesting db"
argument_list|)
expr_stmt|;
name|maybe_send_secure
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|level
init|=
name|ISC_LOG_ERROR
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
operator|&&
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
name|level
operator|=
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"loading from master file %s failed: %s"
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|nomaster
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|!=
name|dns_zone_key
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"number of nodes in database: %u"
argument_list|,
name|dns_db_nodecount
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_SEENINCLUDE
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HASINCLUDE
argument_list|)
expr_stmt|;
else|else
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HASINCLUDE
argument_list|)
expr_stmt|;
comment|/* 	 * If there's no master file for a key zone, then the zone is new: 	 * create an SOA record.  (We do this now, instead of later, so that 	 * if there happens to be a journal file, we can roll forward from 	 * a sane starting point.) 	 */
if|if
condition|(
name|nomaster
operator|&&
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
condition|)
block|{
name|result
operator|=
name|add_soa
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Apply update log, if any, on initial load. 	 */
if|if
condition|(
name|zone
operator|->
name|journal
operator|!=
name|NULL
operator|&&
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_NOMERGE
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
operator|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
operator|||
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
operator|)
condition|)
name|options
operator|=
name|DNS_JOURNALOPT_RESIGN
expr_stmt|;
else|else
name|options
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|dns_journal_rollforward2
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|db
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|zone
operator|->
name|journal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
operator|&&
name|result
operator|!=
name|DNS_R_UPTODATE
operator|&&
name|result
operator|!=
name|DNS_R_NOJOURNAL
operator|&&
name|result
operator|!=
name|ISC_R_RANGE
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"journal rollforward failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
operator|||
name|result
operator|==
name|ISC_R_RANGE
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"journal rollforward failed: "
literal|"journal out of sync with zone"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"journal rollforward completed "
literal|"successfully: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|needdump
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 	 * Obtain ns, soa and cname counts for top of zone. 	 */
name|INSIST
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
operator|&
name|nscount
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|serial
argument_list|,
operator|&
name|refresh
argument_list|,
operator|&
name|retry
argument_list|,
operator|&
name|expire
argument_list|,
operator|&
name|minimum
argument_list|,
operator|&
name|errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|zone
operator|->
name|type
operator|!=
name|dns_zone_key
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"could not find NS and/or SOA records"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check to make sure the journal is up to date, and remove the 	 * journal file if it isn't, as we wouldn't be able to apply 	 * updates otherwise. 	 */
if|if
condition|(
name|zone
operator|->
name|journal
operator|!=
name|NULL
operator|&&
name|dns_zone_isdynamic
argument_list|(
name|zone
argument_list|,
name|ISC_TRUE
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IXFRFROMDIFFS
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|jserial
decl_stmt|;
name|dns_journal_t
modifier|*
name|journal
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_journal_open
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|DNS_JOURNAL_READ
argument_list|,
operator|&
name|journal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|jserial
operator|=
name|dns_journal_last_serial
argument_list|(
name|journal
argument_list|)
expr_stmt|;
name|dns_journal_destroy
argument_list|(
operator|&
name|journal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jserial
operator|=
name|serial
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|jserial
operator|!=
name|serial
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"journal file is out of date: "
literal|"removing journal file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|zone
operator|->
name|journal
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unable to remove journal "
literal|"'%s': '%s'"
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"loaded; checking validity"
argument_list|)
expr_stmt|;
comment|/* 	 * Master / Slave / Stub zones require both NS and SOA records at 	 * the top of the zone. 	 */
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_dlz
case|:
case|case
name|dns_zone_master
case|:
case|case
name|dns_zone_slave
case|:
case|case
name|dns_zone_stub
case|:
case|case
name|dns_zone_redirect
case|:
if|if
condition|(
name|soacount
operator|!=
literal|1
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"has %d SOA records"
argument_list|,
name|soacount
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
block|}
if|if
condition|(
name|nscount
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"has no NS records"
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|errors
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|!=
name|dns_zone_stub
operator|&&
name|zone
operator|->
name|type
operator|!=
name|dns_zone_redirect
condition|)
block|{
name|result
operator|=
name|check_nsec3param
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKINTEGRITY
argument_list|)
operator|&&
operator|!
name|integrity_checks
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKDUPRR
argument_list|)
operator|&&
operator|!
name|zone_check_dup
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|oldsoacount
decl_stmt|;
comment|/* 			 * This is checked in zone_replacedb() for slave zones 			 * as they don't reload from disk. 			 */
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldsoacount
argument_list|,
operator|&
name|oldserial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|soacount
operator|>
literal|0U
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IXFRFROMDIFFS
argument_list|)
operator|&&
operator|!
name|isc_serial_gt
argument_list|(
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|serialmin
decl_stmt|,
name|serialmax
decl_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial
operator|==
name|oldserial
operator|&&
name|zone_unchanged
argument_list|(
name|zone
operator|->
name|db
argument_list|,
name|db
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"ixfr-from-differences: "
literal|"unchanged"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|serialmin
operator|=
operator|(
name|oldserial
operator|+
literal|1
operator|)
operator|&
literal|0xffffffffU
expr_stmt|;
name|serialmax
operator|=
operator|(
name|oldserial
operator|+
literal|0x7fffffffU
operator|)
operator|&
literal|0xffffffffU
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"ixfr-from-differences: "
literal|"new serial (%u) out of range "
literal|"[%u - %u]"
argument_list|,
name|serial
argument_list|,
name|serialmin
argument_list|,
name|serialmax
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isc_serial_ge
argument_list|(
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone serial (%u/%u) has gone "
literal|"backwards"
argument_list|,
name|serial
argument_list|,
name|oldserial
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|serial
operator|==
name|oldserial
operator|&&
operator|!
name|hasinclude
operator|&&
name|strcmp
argument_list|(
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
literal|"_builtin"
argument_list|)
operator|!=
literal|0
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone serial (%u) unchanged. "
literal|"zone may fail to transfer "
literal|"to slaves."
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
operator|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
operator|||
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
operator|)
operator|&&
name|zone
operator|->
name|sigresigninginterval
operator|<
operator|(
literal|3
operator|*
name|refresh
operator|)
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"sig-re-signing-interval less than "
literal|"3 * refresh."
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|refresh
operator|=
name|RANGE
argument_list|(
name|refresh
argument_list|,
name|zone
operator|->
name|minrefresh
argument_list|,
name|zone
operator|->
name|maxrefresh
argument_list|)
expr_stmt|;
name|zone
operator|->
name|retry
operator|=
name|RANGE
argument_list|(
name|retry
argument_list|,
name|zone
operator|->
name|minretry
argument_list|,
name|zone
operator|->
name|maxretry
argument_list|)
expr_stmt|;
name|zone
operator|->
name|expire
operator|=
name|RANGE
argument_list|(
name|expire
argument_list|,
name|zone
operator|->
name|refresh
operator|+
name|zone
operator|->
name|retry
argument_list|,
name|DNS_MAX_EXPIRE
argument_list|)
expr_stmt|;
name|zone
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|!=
name|NULL
operator|)
condition|)
block|{
name|isc_time_t
name|t
decl_stmt|;
name|isc_uint32_t
name|delay
decl_stmt|;
name|result
operator|=
name|isc_file_getmodtime
argument_list|(
name|zone
operator|->
name|journal
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|isc_file_getmodtime
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|t
argument_list|,
name|zone
operator|->
name|expire
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
else|else
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|retry
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
name|delay
operator|=
name|isc_random_jitter
argument_list|(
name|zone
operator|->
name|retry
argument_list|,
operator|(
name|zone
operator|->
name|retry
operator|*
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|delay
argument_list|,
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|refreshtime
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
operator|>=
literal|0
condition|)
name|zone
operator|->
name|refreshtime
operator|=
name|now
expr_stmt|;
block|}
break|break;
case|case
name|dns_zone_key
case|:
name|result
operator|=
name|sync_keyzone
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
break|break;
default|default:
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unexpected zone type %d"
argument_list|,
name|zone
operator|->
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Check for weak DNSKEY's. 	 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|zone_check_dnskeys
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule DNSSEC key refresh. 	 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|DNS_ZONEKEY_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEKEY_MAINTAIN
argument_list|)
condition|)
name|zone
operator|->
name|refreshkeytime
operator|=
name|now
expr_stmt|;
if|#
directive|if
literal|0
comment|/* destroy notification example. */
block|{ 		isc_event_t *e = isc_event_allocate(zone->mctx, NULL, 						    DNS_EVENT_DBDESTROYED, 						    dns_zonemgr_dbdestroyed, 						    zone, 						    sizeof(isc_event_t)); 		dns_db_ondestroy(db, zone->task,&e); 	}
endif|#
directive|endif
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_replacedb
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
name|zone_attachdb
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
operator||
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SENDSECURE
argument_list|)
operator|&&
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|secure
operator|->
name|db
operator|==
name|NULL
condition|)
name|zone_send_securedb
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
else|else
name|zone_send_secureserial
argument_list|(
name|zone
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Finished loading inline-signing zone; need to get status 	 * from the raw side now. 	 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|maybe_send_secure
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|needdump
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
condition|)
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|30
argument_list|)
expr_stmt|;
else|else
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
block|{
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|resume_signingwithkey
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|resume_addnsec3chain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
operator|!
name|DNS_ZONEKEY_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEKEY_NORESIGN
argument_list|)
operator|&&
name|dns_zone_isdynamic
argument_list|(
name|zone
argument_list|,
name|ISC_FALSE
argument_list|)
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_rdataset_t
name|next
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getsigningtime
argument_list|(
name|db
argument_list|,
operator|&
name|next
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_stdtime_t
name|timenow
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|next
operator|.
name|covers
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"next resign: %s/%s in %d seconds"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|next
operator|.
name|resign
operator|-
name|timenow
operator|-
name|zone
operator|->
name|sigresigninginterval
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"signed dynamic zone has no "
literal|"resign event scheduled"
argument_list|)
expr_stmt|;
block|}
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dns_db_ispersistent
argument_list|(
name|db
argument_list|)
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"loaded serial %u%s"
argument_list|,
name|serial
argument_list|,
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|?
literal|" (DNSSEC signed)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|zone
operator|->
name|loadtime
operator|=
name|loadtime
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADPENDING
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|journal
operator|!=
name|NULL
condition|)
name|zone_saveunique
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
literal|"jn-XXXXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
name|zone_saveunique
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
literal|"db-XXXXXXXX"
argument_list|)
expr_stmt|;
comment|/* Mark the zone for immediate refresh. */
name|zone
operator|->
name|refreshtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
operator|&&
name|result
operator|==
name|ISC_R_FILENOTFOUND
operator|)
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"not loaded due to errors."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|exit_check
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SHUTDOWN
argument_list|)
operator|&&
name|zone
operator|->
name|irefs
operator|==
literal|0
condition|)
block|{
comment|/* 		 * DNS_ZONEFLG_SHUTDOWN can only be set if erefs == 0. 		 */
name|INSIST
argument_list|(
name|isc_refcount_current
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|zone_check_ns
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|logit
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|altbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|foundname
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_NOCHECKNS
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
else|else
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|foundname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
operator|||
name|result
operator|==
name|DNS_R_NXDOMAIN
operator|||
name|result
operator|==
name|DNS_R_EMPTYNAME
condition|)
block|{
if|if
condition|(
name|logit
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"NS '%s' has no address "
literal|"records (A or AAAA)"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_CNAME
condition|)
block|{
if|if
condition|(
name|logit
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"NS '%s' is a CNAME "
literal|"(illegal)"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_DNAME
condition|)
block|{
if|if
condition|(
name|logit
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|foundname
argument_list|,
name|altbuf
argument_list|,
sizeof|sizeof
name|altbuf
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"NS '%s' is below a DNAME "
literal|"'%s' (illegal)"
argument_list|,
name|namebuf
argument_list|,
name|altbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_count_ns_rr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|unsigned
name|int
modifier|*
name|nscount
parameter_list|,
name|unsigned
name|int
modifier|*
name|errors
parameter_list|,
name|isc_boolean_t
name|logit
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ecount
init|=
literal|0
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|invalidate_rdataset
goto|;
block|}
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|errors
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|rdclass
operator|==
name|dns_rdataclass_in
operator|&&
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|)
condition|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
operator|&&
operator|!
name|zone_check_ns
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|logit
argument_list|)
condition|)
name|ecount
operator|++
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|success
label|:
if|if
condition|(
name|nscount
operator|!=
name|NULL
condition|)
operator|*
name|nscount
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|errors
operator|!=
name|NULL
condition|)
operator|*
name|errors
operator|=
name|ecount
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|invalidate_rdataset
label|:
name|dns_rdataset_invalidate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_load_soa_rr
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|unsigned
name|int
modifier|*
name|soacount
parameter_list|,
name|isc_uint32_t
modifier|*
name|serial
parameter_list|,
name|isc_uint32_t
modifier|*
name|refresh
parameter_list|,
name|isc_uint32_t
modifier|*
name|retry
parameter_list|,
name|isc_uint32_t
modifier|*
name|expire
parameter_list|,
name|isc_uint32_t
modifier|*
name|minimum
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|soacount
operator|!=
name|NULL
condition|)
operator|*
name|soacount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
name|NULL
condition|)
operator|*
name|serial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|refresh
operator|!=
name|NULL
condition|)
operator|*
name|refresh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retry
operator|!=
name|NULL
condition|)
operator|*
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expire
operator|!=
name|NULL
condition|)
operator|*
name|expire
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|minimum
operator|!=
name|NULL
condition|)
operator|*
name|minimum
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|invalidate_rdataset
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|invalidate_rdataset
goto|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|soacount
operator|!=
name|NULL
condition|)
operator|*
name|soacount
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|serial
operator|!=
name|NULL
condition|)
operator|*
name|serial
operator|=
name|soa
operator|.
name|serial
expr_stmt|;
if|if
condition|(
name|refresh
operator|!=
name|NULL
condition|)
operator|*
name|refresh
operator|=
name|soa
operator|.
name|refresh
expr_stmt|;
if|if
condition|(
name|retry
operator|!=
name|NULL
condition|)
operator|*
name|retry
operator|=
name|soa
operator|.
name|retry
expr_stmt|;
if|if
condition|(
name|expire
operator|!=
name|NULL
condition|)
operator|*
name|expire
operator|=
name|soa
operator|.
name|expire
expr_stmt|;
if|if
condition|(
name|minimum
operator|!=
name|NULL
condition|)
operator|*
name|minimum
operator|=
name|soa
operator|.
name|minimum
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|soacount
operator|!=
name|NULL
condition|)
operator|*
name|soacount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
name|NULL
condition|)
operator|*
name|serial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|refresh
operator|!=
name|NULL
condition|)
operator|*
name|refresh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retry
operator|!=
name|NULL
condition|)
operator|*
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expire
operator|!=
name|NULL
condition|)
operator|*
name|expire
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|minimum
operator|!=
name|NULL
condition|)
operator|*
name|minimum
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|invalidate_rdataset
label|:
name|dns_rdataset_invalidate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zone must be locked.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|zone_get_from_db
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|unsigned
name|int
modifier|*
name|nscount
parameter_list|,
name|unsigned
name|int
modifier|*
name|soacount
parameter_list|,
name|isc_uint32_t
modifier|*
name|serial
parameter_list|,
name|isc_uint32_t
modifier|*
name|refresh
parameter_list|,
name|isc_uint32_t
modifier|*
name|retry
parameter_list|,
name|isc_uint32_t
modifier|*
name|expire
parameter_list|,
name|isc_uint32_t
modifier|*
name|minimum
parameter_list|,
name|unsigned
name|int
modifier|*
name|errors
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|answer
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|REQUIRE
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|nscount
operator|!=
name|NULL
condition|)
operator|*
name|nscount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|soacount
operator|!=
name|NULL
condition|)
operator|*
name|soacount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
name|NULL
condition|)
operator|*
name|serial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|refresh
operator|!=
name|NULL
condition|)
operator|*
name|refresh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retry
operator|!=
name|NULL
condition|)
operator|*
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expire
operator|!=
name|NULL
condition|)
operator|*
name|expire
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|errors
operator|!=
name|NULL
condition|)
operator|*
name|errors
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|answer
operator|=
name|result
expr_stmt|;
goto|goto
name|closeversion
goto|;
block|}
if|if
condition|(
name|nscount
operator|!=
name|NULL
operator|||
name|errors
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_count_ns_rr
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|nscount
argument_list|,
name|errors
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|answer
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
name|soacount
operator|!=
name|NULL
operator|||
name|serial
operator|!=
name|NULL
operator|||
name|refresh
operator|!=
name|NULL
operator|||
name|retry
operator|!=
name|NULL
operator|||
name|expire
operator|!=
name|NULL
operator|||
name|minimum
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_load_soa_rr
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|soacount
argument_list|,
name|serial
argument_list|,
name|refresh
argument_list|,
name|retry
argument_list|,
name|expire
argument_list|,
name|minimum
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|answer
operator|=
name|result
expr_stmt|;
block|}
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|closeversion
label|:
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_attach
parameter_list|(
name|dns_zone_t
modifier|*
name|source
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|source
operator|->
name|erefs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_detach
parameter_list|(
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_zone_t
modifier|*
name|raw
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|isc_boolean_t
name|free_now
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
name|DNS_ZONE_VALID
argument_list|(
operator|*
name|zonep
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|=
operator|*
name|zonep
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 		 * We just detached the last external reference. 		 */
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * This zone is being managed.	Post 			 * its control event and let it clean 			 * up synchronously in the context of 			 * its task. 			 */
name|isc_event_t
modifier|*
name|ev
init|=
operator|&
name|zone
operator|->
name|ctlevent
decl_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|task
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This zone is not being managed; it has 			 * no task and can have no outstanding 			 * events.  Free it immediately. 			 */
comment|/* 			 * Unmanaged zones should not have non-null views; 			 * we have no way of detaching from the view here 			 * without causing deadlock because this code is called 			 * with the view already locked. 			 */
name|INSIST
argument_list|(
name|zone
operator|->
name|view
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|free_now
operator|=
name|ISC_TRUE
expr_stmt|;
name|raw
operator|=
name|zone
operator|->
name|raw
expr_stmt|;
name|zone
operator|->
name|raw
operator|=
name|NULL
expr_stmt|;
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|zone
operator|->
name|secure
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
operator|*
name|zonep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|free_now
condition|)
block|{
if|if
condition|(
name|raw
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|raw
argument_list|)
expr_stmt|;
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|dns_zone_idetach
argument_list|(
operator|&
name|secure
argument_list|)
expr_stmt|;
name|zone_free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dns_zone_iattach
parameter_list|(
name|dns_zone_t
modifier|*
name|source
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|zone_iattach
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_iattach
parameter_list|(
name|dns_zone_t
modifier|*
name|source
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
comment|/* 	 * 'source' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|irefs
operator|+
name|isc_refcount_current
argument_list|(
operator|&
name|source
operator|->
name|erefs
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|source
operator|->
name|irefs
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|irefs
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_idetach
parameter_list|(
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
comment|/* 	 * 'zone' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
name|DNS_ZONE_VALID
argument_list|(
operator|*
name|zonep
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|=
operator|*
name|zonep
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
operator|*
name|zonep
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|zonep
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|+
name|isc_refcount_current
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_idetach
parameter_list|(
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_boolean_t
name|free_needed
decl_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
name|DNS_ZONE_VALID
argument_list|(
operator|*
name|zonep
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|=
operator|*
name|zonep
expr_stmt|;
operator|*
name|zonep
operator|=
name|NULL
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
name|free_needed
operator|=
name|exit_check
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_needed
condition|)
name|zone_free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_mem_t
modifier|*
name|dns_zone_getmctx
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|mctx
operator|)
return|;
block|}
end_function

begin_function
name|dns_zonemgr_t
modifier|*
name|dns_zone_getmgr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|zmgr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setflag
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|isc_boolean_t
name|value
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setoption
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|option
parameter_list|,
name|isc_boolean_t
name|value
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|zone
operator|->
name|options
operator||=
name|option
expr_stmt|;
else|else
name|zone
operator|->
name|options
operator|&=
operator|~
name|option
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_zone_getoptions
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|options
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setkeyopt
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|keyopt
parameter_list|,
name|isc_boolean_t
name|value
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|zone
operator|->
name|keyopts
operator||=
name|keyopt
expr_stmt|;
else|else
name|zone
operator|->
name|keyopts
operator|&=
operator|~
name|keyopt
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_zone_getkeyopts
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|keyopts
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setxfrsource4
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|xfrsource
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|xfrsource4
operator|=
operator|*
name|xfrsource
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|dns_zone_getxfrsource4
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|xfrsource4
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setxfrsource6
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|xfrsource
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|xfrsource6
operator|=
operator|*
name|xfrsource
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|dns_zone_getxfrsource6
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|xfrsource6
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setaltxfrsource4
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|altxfrsource
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|altxfrsource4
operator|=
operator|*
name|altxfrsource
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|dns_zone_getaltxfrsource4
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|altxfrsource4
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setaltxfrsource6
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|altxfrsource
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|altxfrsource6
operator|=
operator|*
name|altxfrsource
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|dns_zone_getaltxfrsource6
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|altxfrsource6
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setnotifysrc4
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|notifysrc
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|notifysrc4
operator|=
operator|*
name|notifysrc
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|dns_zone_getnotifysrc4
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|notifysrc4
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setnotifysrc6
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|notifysrc
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|notifysrc6
operator|=
operator|*
name|notifysrc
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|dns_zone_getnotifysrc6
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|notifysrc6
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|same_addrs
parameter_list|(
specifier|const
name|isc_sockaddr_t
modifier|*
name|old
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|new
parameter_list|,
name|isc_uint32_t
name|count
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isc_sockaddr_equal
argument_list|(
operator|&
name|old
index|[
name|i
index|]
argument_list|,
operator|&
name|new
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|same_keynames
parameter_list|(
name|dns_name_t
modifier|*
modifier|*
name|old
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|new
parameter_list|,
name|isc_uint32_t
name|count
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
operator|&&
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|NULL
operator|||
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|old
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|new
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|old
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|new
index|[
name|i
index|]
operator|==
name|NULL
operator|||
operator|!
name|dns_name_equal
argument_list|(
name|old
index|[
name|i
index|]
argument_list|,
name|new
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_addresskeylist
parameter_list|(
name|isc_sockaddr_t
modifier|*
modifier|*
name|addrsp
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
modifier|*
name|keynamesp
parameter_list|,
name|unsigned
name|int
modifier|*
name|countp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|addrs
decl_stmt|;
name|dns_name_t
modifier|*
modifier|*
name|keynames
decl_stmt|;
name|REQUIRE
argument_list|(
name|countp
operator|!=
name|NULL
operator|&&
name|addrsp
operator|!=
name|NULL
operator|&&
name|keynamesp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|count
operator|=
operator|*
name|countp
expr_stmt|;
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
name|addrs
operator|=
operator|*
name|addrsp
expr_stmt|;
operator|*
name|addrsp
operator|=
name|NULL
expr_stmt|;
name|keynames
operator|=
operator|*
name|keynamesp
expr_stmt|;
operator|*
name|keynamesp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|addrs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|isc_sockaddr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynames
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keynames
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|dns_name_free
argument_list|(
name|keynames
index|[
name|i
index|]
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|keynames
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_name_t
argument_list|)
argument_list|)
expr_stmt|;
name|keynames
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|keynames
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|dns_name_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|set_addrkeylist
parameter_list|(
name|unsigned
name|int
name|count
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|addrs
parameter_list|,
name|isc_sockaddr_t
modifier|*
modifier|*
name|newaddrsp
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|names
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
modifier|*
name|newnamesp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|newaddrs
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
modifier|*
name|newnames
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|newaddrsp
operator|!=
name|NULL
operator|&&
operator|*
name|newaddrsp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|newnamesp
operator|!=
name|NULL
operator|&&
operator|*
name|newnamesp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|newaddrs
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newaddrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newaddrs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memmove
argument_list|(
name|newaddrs
argument_list|,
name|addrs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newaddrs
argument_list|)
argument_list|)
expr_stmt|;
name|newnames
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|names
operator|!=
name|NULL
condition|)
block|{
name|newnames
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newnames
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnames
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|newaddrs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newaddrs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|newnames
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|newnames
index|[
name|i
index|]
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_name_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnames
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|allocfail
goto|;
name|dns_name_init
argument_list|(
name|newnames
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|mctx
argument_list|,
name|newnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|allocfail
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|newnames
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|dns_name_free
argument_list|(
name|newnames
index|[
name|i
index|]
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|newaddrs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newaddrs
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|newnames
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newnames
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
block|}
block|}
operator|*
name|newaddrsp
operator|=
name|newaddrs
expr_stmt|;
operator|*
name|newnamesp
operator|=
name|newnames
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setalsonotify
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|notify
parameter_list|,
name|isc_uint32_t
name|count
parameter_list|)
block|{
return|return
operator|(
name|dns_zone_setalsonotifywithkeys
argument_list|(
name|zone
argument_list|,
name|notify
argument_list|,
name|NULL
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setalsonotifywithkeys
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|notify
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|keynames
parameter_list|,
name|isc_uint32_t
name|count
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|newaddrs
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
modifier|*
name|newnames
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|count
operator|==
literal|0
operator|||
name|notify
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynames
operator|!=
name|NULL
condition|)
name|REQUIRE
argument_list|(
name|count
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|zone
operator|->
name|notifycnt
operator|&&
name|same_addrs
argument_list|(
name|zone
operator|->
name|notify
argument_list|,
name|notify
argument_list|,
name|count
argument_list|)
operator|&&
name|same_keynames
argument_list|(
name|zone
operator|->
name|notifykeynames
argument_list|,
name|keynames
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|unlock
goto|;
name|clear_addresskeylist
argument_list|(
operator|&
name|zone
operator|->
name|notify
argument_list|,
operator|&
name|zone
operator|->
name|notifykeynames
argument_list|,
operator|&
name|zone
operator|->
name|notifycnt
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * Set up the notify and notifykey lists 	 */
name|result
operator|=
name|set_addrkeylist
argument_list|(
name|count
argument_list|,
name|notify
argument_list|,
operator|&
name|newaddrs
argument_list|,
name|keynames
argument_list|,
operator|&
name|newnames
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * Everything is ok so attach to the zone. 	 */
name|zone
operator|->
name|notify
operator|=
name|newaddrs
expr_stmt|;
name|zone
operator|->
name|notifykeynames
operator|=
name|newnames
expr_stmt|;
name|zone
operator|->
name|notifycnt
operator|=
name|count
expr_stmt|;
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setmasters
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|masters
parameter_list|,
name|isc_uint32_t
name|count
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_zone_setmasterswithkeys
argument_list|(
name|zone
argument_list|,
name|masters
argument_list|,
name|NULL
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setmasterswithkeys
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|masters
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|keynames
parameter_list|,
name|isc_uint32_t
name|count
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|newaddrs
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
modifier|*
name|newnames
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
modifier|*
name|newok
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|count
operator|==
literal|0
operator|||
name|masters
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynames
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|count
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * The refresh code assumes that 'masters' wouldn't change under it. 	 * If it will change then kill off any current refresh in progress 	 * and update the masters info.  If it won't change then we can just 	 * unlock and exit. 	 */
if|if
condition|(
name|count
operator|!=
name|zone
operator|->
name|masterscnt
operator|||
operator|!
name|same_addrs
argument_list|(
name|zone
operator|->
name|masters
argument_list|,
name|masters
argument_list|,
name|count
argument_list|)
operator|||
operator|!
name|same_keynames
argument_list|(
name|zone
operator|->
name|masterkeynames
argument_list|,
name|keynames
argument_list|,
name|count
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|request
operator|!=
name|NULL
condition|)
name|dns_request_cancel
argument_list|(
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|unlock
goto|;
comment|/* 	 * This needs to happen before clear_addresskeylist() sets 	 * zone->masterscnt to 0: 	 */
if|if
condition|(
name|zone
operator|->
name|mastersok
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|mastersok
argument_list|,
name|zone
operator|->
name|masterscnt
operator|*
sizeof|sizeof
argument_list|(
name|isc_boolean_t
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|mastersok
operator|=
name|NULL
expr_stmt|;
block|}
name|clear_addresskeylist
argument_list|(
operator|&
name|zone
operator|->
name|masters
argument_list|,
operator|&
name|zone
operator|->
name|masterkeynames
argument_list|,
operator|&
name|zone
operator|->
name|masterscnt
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
comment|/* 	 * If count == 0, don't allocate any space for masters, mastersok or 	 * keynames so internally, those pointers are NULL if count == 0 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * mastersok must contain count elements 	 */
name|newok
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newok
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newok
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|newaddrs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newaddrs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|newok
index|[
name|i
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Now set up the masters and masterkey lists 	 */
name|result
operator|=
name|set_addrkeylist
argument_list|(
name|count
argument_list|,
name|masters
argument_list|,
operator|&
name|newaddrs
argument_list|,
name|keynames
argument_list|,
operator|&
name|newnames
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|newok
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newok
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 	 * Everything is ok so attach to the zone. 	 */
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|mastersok
operator|=
name|newok
expr_stmt|;
name|zone
operator|->
name|masters
operator|=
name|newaddrs
expr_stmt|;
name|zone
operator|->
name|masterkeynames
operator|=
name|newnames
expr_stmt|;
name|zone
operator|->
name|masterscnt
operator|=
name|count
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOMASTERS
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_getdb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dpb
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|==
name|NULL
condition|)
name|result
operator|=
name|DNS_R_NOTLOADED
expr_stmt|;
else|else
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
name|dpb
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setdb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_staticstub
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|db
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Co-ordinates the starting of routine jobs.  */
end_comment

begin_function
name|void
name|dns_zone_maintenance
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"dns_zone_maintenance"
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|was_dumping
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_boolean_t
name|dumping
decl_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|dumping
operator|=
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumping
condition|)
block|{
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dumping
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|find_zone_keys
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|unsigned
name|int
name|maxkeys
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keys
parameter_list|,
name|unsigned
name|int
modifier|*
name|nkeys
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|directory
init|=
name|dns_zone_getkeydirectory
argument_list|(
name|zone
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|keys
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|keys
argument_list|)
operator|*
name|maxkeys
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_findzonekeys2
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|node
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|directory
argument_list|,
name|mctx
argument_list|,
name|maxkeys
argument_list|,
name|keys
argument_list|,
name|nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|offline
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|zonediff_t
modifier|*
name|zonediff
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|rdata
operator|->
name|flags
operator|&
name|DNS_RDATA_OFFLINE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|result
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|DNS_DIFFOP_DELRESIGN
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdata
operator|->
name|flags
operator||=
name|DNS_RDATA_OFFLINE
expr_stmt|;
name|result
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|DNS_DIFFOP_ADDRESIGN
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
name|zonediff
operator|->
name|offline
operator|=
name|ISC_TRUE
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_key_expiry_warning
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_stdtime_t
name|when
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|unsigned
name|int
name|delta
decl_stmt|;
name|char
name|timebuf
index|[
literal|80
index|]
decl_stmt|;
name|zone
operator|->
name|key_expiry
operator|=
name|when
expr_stmt|;
if|if
condition|(
name|when
operator|<=
name|now
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"DNSKEY RRSIG(s) have expired"
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|when
operator|<
name|now
operator|+
literal|7
operator|*
literal|24
operator|*
literal|3600
condition|)
block|{
name|isc_time_t
name|t
decl_stmt|;
name|isc_time_set
argument_list|(
operator|&
name|t
argument_list|,
name|when
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_time_formattimestamp
argument_list|(
operator|&
name|t
argument_list|,
name|timebuf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"DNSKEY RRSIG(s) will expire within 7 days: %s"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
name|delta
operator|=
name|when
operator|-
name|now
expr_stmt|;
name|delta
operator|--
expr_stmt|;
comment|/* loop prevention */
name|delta
operator|/=
literal|24
operator|*
literal|3600
expr_stmt|;
comment|/* to whole days */
name|delta
operator|*=
literal|24
operator|*
literal|3600
expr_stmt|;
comment|/* to seconds */
name|isc_time_set
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|,
name|when
operator|-
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_time_set
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|,
name|when
operator|-
literal|7
operator|*
literal|24
operator|*
literal|3600
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_time_formattimestamp
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
name|timebuf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"setting keywarntime to %s"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Helper function to del_sigs(). We don't want to delete RRSIGs that  * have no new key.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|delsig_ok
parameter_list|(
name|dns_rdata_rrsig_t
modifier|*
name|rrsig_ptr
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keys
parameter_list|,
name|unsigned
name|int
name|nkeys
parameter_list|,
name|isc_boolean_t
modifier|*
name|warn
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|have_ksk
init|=
name|ISC_FALSE
decl_stmt|,
name|have_zsk
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|have_pksk
init|=
name|ISC_FALSE
decl_stmt|,
name|have_pzsk
init|=
name|ISC_FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rrsig_ptr
operator|->
name|algorithm
operator|!=
name|dst_key_alg
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dst_key_isprivate
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|KSK
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|have_ksk
operator|=
name|have_pksk
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|have_zsk
operator|=
name|have_pzsk
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|KSK
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
name|have_ksk
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|have_zsk
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_zsk
operator|&&
name|have_ksk
operator|&&
operator|!
name|have_pzsk
condition|)
operator|*
name|warn
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * It's okay to delete a signature if there is an active key 	 * with the same algorithm to replace it. 	 */
if|if
condition|(
name|have_pksk
operator|||
name|have_pzsk
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Failing that, it is *not* okay to delete a signature 	 * if the associated public key is still in the DNSKEY RRset 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rrsig_ptr
operator|->
name|algorithm
operator|==
name|dst_key_alg
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|rrsig_ptr
operator|->
name|keyid
operator|==
name|dst_key_id
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
comment|/* 	 * But if the key is gone, then go ahead. 	 */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete expired RRsigs and any RRsigs we are about to re-sign.  * See also update.c:del_keysigs().  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|del_sigs
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|zonediff_t
modifier|*
name|zonediff
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keys
parameter_list|,
name|unsigned
name|int
name|nkeys
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
name|incremental
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|isc_boolean_t
name|found
decl_stmt|,
name|changed
decl_stmt|;
name|isc_int64_t
name|warn
init|=
literal|0
decl_stmt|,
name|maybe
init|=
literal|0
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
name|result
operator|=
name|dns_db_findnsec3node
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|,
operator|(
name|isc_stdtime_t
operator|)
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|changed
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_dnskey
condition|)
block|{
name|isc_boolean_t
name|warn
init|=
name|ISC_FALSE
decl_stmt|,
name|deleted
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
name|delsig_ok
argument_list|(
operator|&
name|rrsig
argument_list|,
name|keys
argument_list|,
name|nkeys
argument_list|,
operator|&
name|warn
argument_list|)
condition|)
block|{
name|result
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|DNS_DIFFOP_DELRESIGN
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
name|changed
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|deleted
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
comment|/* 				 * At this point, we've got an RRSIG, 				 * which is signed by an inactive key. 				 * An administrator needs to provide a new 				 * key/alg, but until that time, we want to 				 * keep the old RRSIG.  Marking the key as 				 * offline will prevent us spinning waiting 				 * for the private part. 				 */
if|if
condition|(
name|incremental
operator|&&
operator|!
name|deleted
condition|)
block|{
name|result
operator|=
name|offline
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|changed
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
comment|/* 				 * Log the key id and algorithm of 				 * the inactive key with no replacement 				 */
if|if
condition|(
name|zone
operator|->
name|log_key_expired_timer
operator|<=
name|now
condition|)
block|{
name|char
name|origin
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|algbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|)
expr_stmt|;
name|dns_secalg_format
argument_list|(
name|rrsig
operator|.
name|algorithm
argument_list|,
name|algbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|algbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Key %s/%s/%d "
literal|"missing or inactive "
literal|"and has no replacement: "
literal|"retaining signatures."
argument_list|,
name|origin
argument_list|,
name|algbuf
argument_list|,
name|rrsig
operator|.
name|keyid
argument_list|)
expr_stmt|;
name|zone
operator|->
name|log_key_expired_timer
operator|=
name|now
operator|+
literal|3600
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* 		 * RRSIG(DNSKEY) requires special processing. 		 */
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rrsig
operator|.
name|algorithm
operator|==
name|dst_key_alg
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|&&
name|rrsig
operator|.
name|keyid
operator|==
name|dst_key_id
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * Mark offline RRSIG(DNSKEY). 				 * We want the earliest offline expire time 				 * iff there is a new offline signature. 				 */
if|if
condition|(
operator|!
name|dst_key_inactive
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|dst_key_isprivate
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|isc_int64_t
name|timeexpire
init|=
name|dns_time64_from32
argument_list|(
name|rrsig
operator|.
name|timeexpire
argument_list|)
decl_stmt|;
if|if
condition|(
name|warn
operator|!=
literal|0
operator|&&
name|warn
operator|>
name|timeexpire
condition|)
name|warn
operator|=
name|timeexpire
expr_stmt|;
if|if
condition|(
name|rdata
operator|.
name|flags
operator|&
name|DNS_RDATA_OFFLINE
condition|)
block|{
if|if
condition|(
name|maybe
operator|==
literal|0
operator|||
name|maybe
operator|>
name|timeexpire
condition|)
name|maybe
operator|=
name|timeexpire
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|warn
operator|==
literal|0
condition|)
name|warn
operator|=
name|maybe
expr_stmt|;
if|if
condition|(
name|warn
operator|==
literal|0
operator|||
name|warn
operator|>
name|timeexpire
condition|)
name|warn
operator|=
name|timeexpire
expr_stmt|;
name|result
operator|=
name|offline
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|changed
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|DNS_DIFFOP_DELRESIGN
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If there is not a matching DNSKEY then 		 * delete the RRSIG. 		 */
if|if
condition|(
operator|!
name|found
condition|)
name|result
operator|=
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|DNS_DIFFOP_DELRESIGN
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|changed
operator|&&
operator|(
name|rdataset
operator|.
name|attributes
operator|&
name|DNS_RDATASETATTR_RESIGN
operator|)
operator|!=
literal|0
condition|)
name|dns_db_resigned
argument_list|(
name|db
argument_list|,
operator|&
name|rdataset
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|warn
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|STDTIME_ON_32BITS
argument_list|)
name|isc_stdtime_t
name|stdwarn
init|=
operator|(
name|isc_stdtime_t
operator|)
name|warn
decl_stmt|;
if|if
condition|(
name|warn
operator|==
name|stdwarn
condition|)
endif|#
directive|endif
name|set_key_expiry_warning
argument_list|(
name|zone
argument_list|,
operator|(
name|isc_stdtime_t
operator|)
name|warn
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STDTIME_ON_32BITS
argument_list|)
else|else
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key expiry warning time out of range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_sigs
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keys
parameter_list|,
name|unsigned
name|int
name|nkeys
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_stdtime_t
name|inception
parameter_list|,
name|isc_stdtime_t
name|expire
parameter_list|,
name|isc_boolean_t
name|check_ksk
parameter_list|,
name|isc_boolean_t
name|keyset_kskonly
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|sig_rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|1024
index|]
decl_stmt|;
comment|/* XXX */
name|isc_buffer_t
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
name|result
operator|=
name|dns_db_findnsec3node
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|(
name|isc_stdtime_t
operator|)
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
name|isc_boolean_t
name|both
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|dst_key_isprivate
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|check_ksk
operator|&&
operator|!
name|REVOKE
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|isc_boolean_t
name|have_ksk
decl_stmt|,
name|have_nonksk
decl_stmt|;
if|if
condition|(
name|KSK
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|have_ksk
operator|=
name|ISC_TRUE
expr_stmt|;
name|have_nonksk
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|have_ksk
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_nonksk
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nkeys
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
operator|||
name|ALG
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|!=
name|ALG
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|REVOKE
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|KSK
argument_list|(
name|keys
index|[
name|j
index|]
argument_list|)
condition|)
name|have_ksk
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|have_nonksk
operator|=
name|ISC_TRUE
expr_stmt|;
name|both
operator|=
name|have_ksk
operator|&&
name|have_nonksk
expr_stmt|;
if|if
condition|(
name|both
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|both
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dnskey
condition|)
block|{
if|if
condition|(
operator|!
name|KSK
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|&&
name|keyset_kskonly
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|KSK
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|REVOKE
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|&&
name|type
operator|!=
name|dns_rdatatype_dnskey
condition|)
continue|continue;
comment|/* Calculate the signature, creating a RRSIG RDATA. */
name|isc_buffer_clear
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_dnssec_sign
argument_list|(
name|name
argument_list|,
operator|&
name|rdataset
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
operator|&
name|inception
argument_list|,
operator|&
name|expire
argument_list|,
name|mctx
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|sig_rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the database and journal with the RRSIG. */
comment|/* XXX inefficient - will cause dataset merging */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADDRESIGN
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|sig_rdata
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sig_rdata
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_resigninc
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|me
init|=
literal|"zone_resigninc"
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|_sig_diff
decl_stmt|;
name|zonediff_t
name|zonediff
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdatatype_t
name|covers
decl_stmt|;
name|dst_key_t
modifier|*
name|zone_keys
index|[
name|DNS_MAXZONEKEYS
index|]
decl_stmt|;
name|isc_boolean_t
name|check_ksk
decl_stmt|,
name|keyset_kskonly
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|,
name|inception
decl_stmt|,
name|soaexpire
decl_stmt|,
name|expire
decl_stmt|,
name|stop
decl_stmt|;
name|isc_uint32_t
name|jitter
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|nkeys
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|resign
decl_stmt|;
name|ENTER
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|zonediff_init
argument_list|(
operator|&
name|zonediff
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
comment|/* 	 * Zone is frozen or automatic resigning is disabled. 	 * Pause for 5 minutes. 	 */
if|if
condition|(
name|zone
operator|->
name|update_disabled
operator|||
name|DNS_ZONEKEY_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEKEY_NORESIGN
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|find_zone_keys
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MAXZONEKEYS
argument_list|,
name|zone_keys
argument_list|,
operator|&
name|nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:find_zone_keys -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|inception
operator|=
name|now
operator|-
literal|3600
expr_stmt|;
comment|/* Allow for clock skew. */
name|soaexpire
operator|=
name|now
operator|+
name|dns_zone_getsigvalidityinterval
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Spread out signatures over time if they happen to be 	 * clumped.  We don't do this for each add_sigs() call as 	 * we still want some clustering to occur. 	 */
name|isc_random_get
argument_list|(
operator|&
name|jitter
argument_list|)
expr_stmt|;
name|expire
operator|=
name|soaexpire
operator|-
name|jitter
operator|%
literal|3600
expr_stmt|;
name|stop
operator|=
name|now
operator|+
literal|5
expr_stmt|;
name|check_ksk
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_UPDATECHECKKSK
argument_list|)
expr_stmt|;
name|keyset_kskonly
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_DNSKEYKSKONLY
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getsigningtime
argument_list|(
name|db
argument_list|,
operator|&
name|rdataset
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:dns_db_getsigningtime -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|resign
operator|=
name|rdataset
operator|.
name|resign
operator|-
name|zone
operator|->
name|sigresigninginterval
expr_stmt|;
name|covers
operator|=
name|rdataset
operator|.
name|covers
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
comment|/* 		 * Stop if we hit the SOA as that means we have walked the 		 * entire zone.  The SOA record should always be the most 		 * recent signature. 		 */
comment|/* XXXMPA increase number of RRsets signed pre call */
if|if
condition|(
name|covers
operator|==
name|dns_rdatatype_soa
operator|||
name|i
operator|++
operator|>
name|zone
operator|->
name|signatures
operator|||
name|resign
operator|>
name|stop
condition|)
break|break;
name|result
operator|=
name|del_sigs
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|covers
argument_list|,
operator|&
name|zonediff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|now
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:del_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|add_sigs
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|covers
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:add_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|dns_db_getsigningtime
argument_list|(
name|db
argument_list|,
operator|&
name|rdataset
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|==
literal|0
operator|&&
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:dns_db_getsigningtime -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
operator|&&
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|del_sigs
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|zonediff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|now
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:del_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Did we change anything in the zone? 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|zonediff
operator|.
name|diff
operator|->
name|tuples
argument_list|)
condition|)
block|{
comment|/* 		 * Commit the changes if any key has been marked as offline.			 */
if|if
condition|(
name|zonediff
operator|.
name|offline
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Increment SOA serial if we have made changes */
name|result
operator|=
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:update_soa_serial -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Generate maximum life time signatures so that the above loop 	 * termination is sensible. 	 */
name|result
operator|=
name|add_sigs
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|inception
argument_list|,
name|soaexpire
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_resigninc:add_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Write changes to journal file. */
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"zone_resigninc"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Everything has succeeded. Commit the changes. */
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|failure
label|:
name|dns_diff_clear
argument_list|(
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
name|dst_key_free
argument_list|(
operator|&
name|zone_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|dns_db_closeversion
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Something failed.  Retry in 5 minutes. 		 */
name|isc_interval_t
name|ival
decl_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|ival
argument_list|,
literal|300
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|,
operator|&
name|ival
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|next_active
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|oldname
parameter_list|,
name|dns_name_t
modifier|*
name|newname
parameter_list|,
name|isc_boolean_t
name|bottom
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbit
init|=
name|NULL
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsit
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|dns_db_createiterator
argument_list|(
name|db
argument_list|,
name|DNS_DB_NONSEC3
argument_list|,
operator|&
name|dbit
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_dbiterator_seek
argument_list|(
name|dbit
argument_list|,
name|oldname
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|dbit
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|CHECK
argument_list|(
name|dns_dbiterator_first
argument_list|(
name|dbit
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_dbiterator_current
argument_list|(
name|dbit
argument_list|,
operator|&
name|node
argument_list|,
name|newname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottom
operator|&&
name|dns_name_issubdomain
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|)
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Is this node empty? 		 */
name|CHECK
argument_list|(
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|rdsit
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsit
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsit
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbit
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dbit
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|signed_with_key
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrsig
operator|.
name|algorithm
operator|==
name|dst_key_alg
argument_list|(
name|key
argument_list|)
operator|&&
name|rrsig
operator|.
name|keyid
operator|==
name|dst_key_id
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_nsec
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|isc_boolean_t
name|bottom
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|next
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|char
name|nsecbuffer
index|[
name|DNS_NSEC_BUFFERSIZE
index|]
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|next
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|next_active
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|next
argument_list|,
name|bottom
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_nsec_buildrdata
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
name|next
argument_list|,
name|nsecbuffer
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|sign_a_node
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_boolean_t
name|build_nsec3
parameter_list|,
name|isc_boolean_t
name|build_nsec
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_stdtime_t
name|inception
parameter_list|,
name|isc_stdtime_t
name|expire
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_boolean_t
name|is_ksk
parameter_list|,
name|isc_boolean_t
name|keyset_kskonly
parameter_list|,
name|isc_boolean_t
modifier|*
name|delegation
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|isc_int32_t
modifier|*
name|signatures
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|iterator
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|1024
index|]
decl_stmt|;
name|isc_boolean_t
name|seen_soa
decl_stmt|,
name|seen_ns
decl_stmt|,
name|seen_rr
decl_stmt|,
name|seen_dname
decl_stmt|,
name|seen_nsec
decl_stmt|,
name|seen_nsec3
decl_stmt|,
name|seen_ds
decl_stmt|;
name|isc_boolean_t
name|bottom
decl_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|seen_rr
operator|=
name|seen_soa
operator|=
name|seen_ns
operator|=
name|seen_dname
operator|=
name|seen_nsec
operator|=
name|seen_nsec3
operator|=
name|seen_ds
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iterator
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_soa
condition|)
name|seen_soa
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_ns
condition|)
name|seen_ns
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_ds
condition|)
name|seen_ds
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_dname
condition|)
name|seen_dname
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|seen_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
name|seen_nsec3
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
name|seen_rr
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|failure
goto|;
if|if
condition|(
name|seen_ns
operator|&&
operator|!
name|seen_soa
condition|)
operator|*
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Going from insecure to NSEC3. 	 * Don't generate NSEC3 records for NSEC3 records. 	 */
if|if
condition|(
name|build_nsec3
operator|&&
operator|!
name|seen_nsec3
operator|&&
name|seen_rr
condition|)
block|{
name|isc_boolean_t
name|unsecure
init|=
operator|!
name|seen_ds
operator|&&
name|seen_ns
operator|&&
operator|!
name|seen_soa
decl_stmt|;
name|CHECK
argument_list|(
name|dns_nsec3_addnsec3s
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|minimum
argument_list|,
name|unsecure
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|signatures
operator|)
operator|--
expr_stmt|;
block|}
comment|/* 	 * Going from insecure to NSEC. 	 * Don't generate NSEC records for NSEC3 records. 	 */
if|if
condition|(
name|build_nsec
operator|&&
operator|!
name|seen_nsec3
operator|&&
operator|!
name|seen_nsec
operator|&&
name|seen_rr
condition|)
block|{
comment|/* Build and add NSEC. */
name|bottom
operator|=
operator|(
name|seen_ns
operator|&&
operator|!
name|seen_soa
operator|)
operator|||
name|seen_dname
expr_stmt|;
comment|/* 		 * Build a NSEC record except at the origin. 		 */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|add_nsec
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|node
argument_list|,
name|minimum
argument_list|,
name|bottom
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Count a NSEC generation as a signature generation. */
operator|(
operator|*
name|signatures
operator|)
operator|--
expr_stmt|;
block|}
block|}
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_soa
operator|||
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
goto|goto
name|next_rdataset
goto|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
condition|)
block|{
if|if
condition|(
operator|!
name|is_ksk
operator|&&
name|keyset_kskonly
condition|)
goto|goto
name|next_rdataset
goto|;
block|}
elseif|else
if|if
condition|(
name|is_ksk
condition|)
goto|goto
name|next_rdataset
goto|;
if|if
condition|(
operator|*
name|delegation
operator|&&
name|rdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_ds
operator|&&
name|rdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_nsec
condition|)
goto|goto
name|next_rdataset
goto|;
if|if
condition|(
name|signed_with_key
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|rdataset
operator|.
name|type
argument_list|,
name|key
argument_list|)
condition|)
goto|goto
name|next_rdataset
goto|;
comment|/* Calculate the signature, creating a RRSIG RDATA. */
name|isc_buffer_clear
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_dnssec_sign
argument_list|(
name|name
argument_list|,
operator|&
name|rdataset
argument_list|,
name|key
argument_list|,
operator|&
name|inception
argument_list|,
operator|&
name|expire
argument_list|,
name|mctx
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the database and journal with the RRSIG. */
comment|/* XXX inefficient - will cause dataset merging */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADDRESIGN
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
operator|(
operator|*
name|signatures
operator|)
operator|--
expr_stmt|;
name|next_rdataset
label|:
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|seen_dname
condition|)
operator|*
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterator
operator|!=
name|NULL
condition|)
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If 'update_only' is set then don't create a NSEC RRset if it doesn't exist.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|updatesecure
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_ttl_t
name|minimum
parameter_list|,
name|isc_boolean_t
name|update_only
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_only
condition|)
block|{
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
block|}
name|CHECK
argument_list|(
name|delete_nsec
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|add_nsec
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|node
argument_list|,
name|minimum
argument_list|,
name|ISC_FALSE
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|success
label|:
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|updatesignwithkey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_signing_t
modifier|*
name|signing
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_boolean_t
name|build_nsec3
parameter_list|,
name|dns_ttl_t
name|minimum
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|5
index|]
decl_stmt|;
name|isc_boolean_t
name|seen_done
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|have_rr
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|signing
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|signing
operator|->
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 		 * If we don't match the algorithm or keyid skip the record. 		 */
if|if
condition|(
name|rdata
operator|.
name|length
operator|!=
literal|5
operator|||
name|rdata
operator|.
name|data
index|[
literal|0
index|]
operator|!=
name|signing
operator|->
name|algorithm
operator|||
name|rdata
operator|.
name|data
index|[
literal|1
index|]
operator|!=
operator|(
operator|(
name|signing
operator|->
name|keyid
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|||
name|rdata
operator|.
name|data
index|[
literal|2
index|]
operator|!=
operator|(
name|signing
operator|->
name|keyid
operator|&
literal|0xff
operator|)
condition|)
block|{
name|have_rr
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We have a match.  If we were signing (!signing->delete) 		 * and we already have a record indicating that we have 		 * finished signing (rdata.data[4] != 0) then keep it. 		 * Otherwise it needs to be deleted as we have removed all 		 * the signatures (signing->delete), so any record indicating 		 * completion is now out of date, or we have finished signing 		 * with the new record so we no longer need to remember that 		 * we need to sign the zone with the matching key across a 		 * nameserver re-start. 		 */
if|if
condition|(
operator|!
name|signing
operator|->
name|delete
operator|&&
name|rdata
operator|.
name|data
index|[
literal|4
index|]
operator|!=
literal|0
condition|)
block|{
name|seen_done
operator|=
name|ISC_TRUE
expr_stmt|;
name|have_rr
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|signing
operator|->
name|db
argument_list|,
name|version
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|!
name|signing
operator|->
name|delete
operator|&&
operator|!
name|seen_done
condition|)
block|{
comment|/* 		 * If we were signing then we need to indicate that we have 		 * finished signing the zone with this key.  If it is already 		 * there we don't need to add it a second time. 		 */
name|data
index|[
literal|0
index|]
operator|=
name|signing
operator|->
name|algorithm
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|signing
operator|->
name|keyid
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|signing
operator|->
name|keyid
operator|&
literal|0xff
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|rdata
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|rdata
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|rdata
operator|.
name|type
operator|=
name|zone
operator|->
name|privatetype
expr_stmt|;
name|rdata
operator|.
name|rdclass
operator|=
name|dns_db_class
argument_list|(
name|signing
operator|->
name|db
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|signing
operator|->
name|db
argument_list|,
name|version
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|have_rr
condition|)
block|{
name|dns_name_t
modifier|*
name|origin
init|=
name|dns_db_origin
argument_list|(
name|signing
operator|->
name|db
argument_list|)
decl_stmt|;
comment|/* 		 * Rebuild the NSEC/NSEC3 record for the origin as we no 		 * longer have any private records. 		 */
if|if
condition|(
name|build_nsec3
condition|)
name|CHECK
argument_list|(
name|dns_nsec3_addnsec3s
argument_list|(
name|signing
operator|->
name|db
argument_list|,
name|version
argument_list|,
name|origin
argument_list|,
name|minimum
argument_list|,
name|ISC_FALSE
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|updatesecure
argument_list|(
name|signing
operator|->
name|db
argument_list|,
name|version
argument_list|,
name|origin
argument_list|,
name|minimum
argument_list|,
name|ISC_TRUE
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|signing
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If 'active' is set then we are not done with the chain yet so only  * delete the nsec3param record which indicates a full chain exists  * (flags == 0).  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|fixup_nsec3param
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_nsec3chain_t
modifier|*
name|chain
parameter_list|,
name|isc_boolean_t
name|active
parameter_list|,
name|dns_rdatatype_t
name|privatetype
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|dns_db_origin
argument_list|(
name|db
argument_list|)
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_nsec3param_t
name|nsec3param
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|unsigned
name|char
name|parambuf
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
index|]
decl_stmt|;
name|dns_ttl_t
name|ttl
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|nseconly
init|=
name|ISC_FALSE
decl_stmt|,
name|nsec3ok
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|try_private
goto|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
comment|/* 	 * Preserve the existing ttl. 	 */
name|ttl
operator|=
name|rdataset
operator|.
name|ttl
expr_stmt|;
comment|/* 	 * Delete all NSEC3PARAM records which match that in nsec3chain. 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3param
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|.
name|hash
operator|!=
name|chain
operator|->
name|nsec3param
operator|.
name|hash
operator|||
operator|(
name|active
operator|&&
name|nsec3param
operator|.
name|flags
operator|!=
literal|0
operator|)
operator|||
name|nsec3param
operator|.
name|iterations
operator|!=
name|chain
operator|->
name|nsec3param
operator|.
name|iterations
operator|||
name|nsec3param
operator|.
name|salt_length
operator|!=
name|chain
operator|->
name|nsec3param
operator|.
name|salt_length
operator|||
name|memcmp
argument_list|(
name|nsec3param
operator|.
name|salt
argument_list|,
name|chain
operator|->
name|nsec3param
operator|.
name|salt
argument_list|,
name|nsec3param
operator|.
name|salt_length
argument_list|)
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|failure
goto|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|try_private
label|:
if|if
condition|(
name|active
condition|)
goto|goto
name|add
goto|;
name|result
operator|=
name|dns_nsec_nseconly
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|nseconly
argument_list|)
expr_stmt|;
name|nsec3ok
operator|=
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|nseconly
operator|)
expr_stmt|;
comment|/* 	 * Delete all private records which match that in nsec3chain. 	 */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|privatetype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|add
goto|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|private
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
index|]
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|private
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_nsec3param_fromprivate
argument_list|(
operator|&
name|private
argument_list|,
operator|&
name|rdata
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
continue|continue;
name|CHECK
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3param
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|nsec3ok
operator|&&
operator|(
name|nsec3param
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_INITIAL
operator|)
operator|!=
literal|0
operator|)
operator|||
name|nsec3param
operator|.
name|hash
operator|!=
name|chain
operator|->
name|nsec3param
operator|.
name|hash
operator|||
name|nsec3param
operator|.
name|iterations
operator|!=
name|chain
operator|->
name|nsec3param
operator|.
name|iterations
operator|||
name|nsec3param
operator|.
name|salt_length
operator|!=
name|chain
operator|->
name|nsec3param
operator|.
name|salt_length
operator|||
name|memcmp
argument_list|(
name|nsec3param
operator|.
name|salt
argument_list|,
name|chain
operator|->
name|nsec3param
operator|.
name|salt
argument_list|,
name|nsec3param
operator|.
name|salt_length
argument_list|)
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|private
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|failure
goto|;
name|add
label|:
if|if
condition|(
operator|(
name|chain
operator|->
name|nsec3param
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_REMOVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Add a NSEC3PARAM record which matches that in nsec3chain but 	 * with all flags bits cleared. 	 * 	 * Note: we do not clear chain->nsec3param.flags as this change 	 * may be reversed. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|parambuf
argument_list|,
sizeof|sizeof
argument_list|(
name|parambuf
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rdata
argument_list|,
name|dns_db_class
argument_list|(
name|db
argument_list|)
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
operator|&
name|chain
operator|->
name|nsec3param
argument_list|,
operator|&
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|rdata
operator|.
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Clear flag bits. */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|failure
label|:
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|delete_nsec
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|deletematchingnsec3
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|dns_rdata_nsec3param_t
modifier|*
name|param
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_nsec3_t
name|nsec3
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_nsec3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3
operator|.
name|hash
operator|!=
name|param
operator|->
name|hash
operator|||
name|nsec3
operator|.
name|iterations
operator|!=
name|param
operator|->
name|iterations
operator|||
name|nsec3
operator|.
name|salt_length
operator|!=
name|param
operator|->
name|salt_length
operator|||
name|memcmp
argument_list|(
name|nsec3
operator|.
name|salt
argument_list|,
name|param
operator|->
name|salt
argument_list|,
name|nsec3
operator|.
name|salt_length
argument_list|)
condition|)
continue|continue;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|need_nsec_chain
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
specifier|const
name|dns_rdata_nsec3param_t
modifier|*
name|param
parameter_list|,
name|isc_boolean_t
modifier|*
name|answer
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_nsec3param_t
name|myparam
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
operator|*
name|answer
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
operator|*
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|myparam
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 		 * Ignore any NSEC3PARAM removals. 		 */
if|if
condition|(
name|NSEC3REMOVE
argument_list|(
name|myparam
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Ignore the chain that we are in the process of deleting. 		 */
if|if
condition|(
name|myparam
operator|.
name|hash
operator|==
name|param
operator|->
name|hash
operator|&&
name|myparam
operator|.
name|iterations
operator|==
name|param
operator|->
name|iterations
operator|&&
name|myparam
operator|.
name|salt_length
operator|==
name|param
operator|->
name|salt_length
operator|&&
operator|!
name|memcmp
argument_list|(
name|myparam
operator|.
name|salt
argument_list|,
name|param
operator|->
name|salt
argument_list|,
name|myparam
operator|.
name|salt_length
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Found an active NSEC3 chain. 		 */
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
operator|*
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|update_sigs
parameter_list|(
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dst_key_t
modifier|*
name|zone_keys
index|[]
parameter_list|,
name|unsigned
name|int
name|nkeys
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_stdtime_t
name|inception
parameter_list|,
name|isc_stdtime_t
name|expire
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
name|check_ksk
parameter_list|,
name|isc_boolean_t
name|keyset_kskonly
parameter_list|,
name|zonediff_t
modifier|*
name|zonediff
parameter_list|)
block|{
name|dns_difftuple_t
modifier|*
name|tuple
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
for|for
control|(
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|tuple
operator|!=
name|NULL
condition|;
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
control|)
block|{
name|result
operator|=
name|del_sigs
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|tuple
operator|->
name|name
argument_list|,
name|tuple
operator|->
name|rdata
operator|.
name|type
argument_list|,
name|zonediff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|now
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"update_sigs:del_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|add_sigs
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|tuple
operator|->
name|name
argument_list|,
name|tuple
operator|->
name|rdata
operator|.
name|type
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"update_sigs:add_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
do|do
block|{
name|dns_difftuple_t
modifier|*
name|next
init|=
name|ISC_LIST_NEXT
argument_list|(
name|tuple
argument_list|,
name|link
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|!=
name|next
operator|->
name|rdata
operator|.
name|type
operator|||
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|tuple
operator|->
name|name
argument_list|,
operator|&
name|next
operator|->
name|name
argument_list|)
operator|)
condition|)
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|next
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|diff
operator|->
name|tuples
argument_list|,
name|tuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_diff_appendminimal
argument_list|(
name|zonediff
operator|->
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|tuple
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tuple
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tuple
operator|!=
name|NULL
condition|)
do|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incrementally build and sign a new NSEC3 chain using the parameters  * requested.  */
end_comment

begin_function
specifier|static
name|void
name|zone_nsec3chain
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|me
init|=
literal|"zone_nsec3chain"
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|_sig_diff
decl_stmt|;
name|dns_diff_t
name|nsec_diff
decl_stmt|;
name|dns_diff_t
name|nsec3_diff
decl_stmt|;
name|dns_diff_t
name|param_diff
decl_stmt|;
name|zonediff_t
name|zonediff
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_t
name|nextfixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|nextname
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_nsec3chain_t
modifier|*
name|nsec3chain
init|=
name|NULL
decl_stmt|,
modifier|*
name|nextnsec3chain
decl_stmt|;
name|dns_nsec3chainlist_t
name|cleanup
decl_stmt|;
name|dst_key_t
modifier|*
name|zone_keys
index|[
name|DNS_MAXZONEKEYS
index|]
decl_stmt|;
name|isc_int32_t
name|signatures
decl_stmt|;
name|isc_boolean_t
name|check_ksk
decl_stmt|,
name|keyset_kskonly
decl_stmt|;
name|isc_boolean_t
name|delegation
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|,
name|inception
decl_stmt|,
name|soaexpire
decl_stmt|,
name|expire
decl_stmt|;
name|isc_uint32_t
name|jitter
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|nkeys
init|=
literal|0
decl_stmt|;
name|isc_uint32_t
name|nodes
decl_stmt|;
name|isc_boolean_t
name|unsecure
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|seen_soa
decl_stmt|,
name|seen_ns
decl_stmt|,
name|seen_dname
decl_stmt|,
name|seen_ds
decl_stmt|;
name|isc_boolean_t
name|seen_nsec
decl_stmt|,
name|seen_nsec3
decl_stmt|,
name|seen_rr
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|iterator
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|buildnsecchain
decl_stmt|;
name|isc_boolean_t
name|updatensec
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdatatype_t
name|privatetype
init|=
name|zone
operator|->
name|privatetype
decl_stmt|;
name|ENTER
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|nextfixed
argument_list|)
expr_stmt|;
name|nextname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|nextfixed
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|param_diff
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|nsec3_diff
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|nsec_diff
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|zonediff_init
argument_list|(
operator|&
name|zonediff
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* 	 * Updates are disabled.  Pause for 5 minutes. 	 */
if|if
condition|(
name|zone
operator|->
name|update_disabled
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|find_zone_keys
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MAXZONEKEYS
argument_list|,
name|zone_keys
argument_list|,
operator|&
name|nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:find_zone_keys -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|inception
operator|=
name|now
operator|-
literal|3600
expr_stmt|;
comment|/* Allow for clock skew. */
name|soaexpire
operator|=
name|now
operator|+
name|dns_zone_getsigvalidityinterval
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Spread out signatures over time if they happen to be 	 * clumped.  We don't do this for each add_sigs() call as 	 * we still want some clustering to occur. 	 */
name|isc_random_get
argument_list|(
operator|&
name|jitter
argument_list|)
expr_stmt|;
name|expire
operator|=
name|soaexpire
operator|-
name|jitter
operator|%
literal|3600
expr_stmt|;
name|check_ksk
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_UPDATECHECKKSK
argument_list|)
expr_stmt|;
name|keyset_kskonly
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_DNSKEYKSKONLY
argument_list|)
expr_stmt|;
comment|/* 	 * We keep pulling nodes off each iterator in turn until 	 * we have no more nodes to pull off or we reach the limits 	 * for this quantum. 	 */
name|nodes
operator|=
name|zone
operator|->
name|nodes
expr_stmt|;
name|signatures
operator|=
name|zone
operator|->
name|signatures
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
name|nsec3chain
operator|->
name|save_delete_nsec
operator|=
name|nsec3chain
operator|->
name|delete_nsec
expr_stmt|;
comment|/* 	 * Generate new NSEC3 chains first. 	 */
while|while
condition|(
name|nsec3chain
operator|!=
name|NULL
operator|&&
name|nodes
operator|--
operator|>
literal|0
operator|&&
name|signatures
operator|>
literal|0
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nextnsec3chain
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|->
name|done
operator|||
name|nsec3chain
operator|->
name|db
operator|!=
name|zone
operator|->
name|db
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|cleanup
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_TAIL
argument_list|(
name|cleanup
argument_list|)
operator|==
name|nsec3chain
condition|)
goto|goto
name|next_addchain
goto|;
comment|/* 		 * Possible future db. 		 */
if|if
condition|(
name|nsec3chain
operator|->
name|db
operator|!=
name|db
condition|)
block|{
goto|goto
name|next_addchain
goto|;
block|}
if|if
condition|(
name|NSEC3REMOVE
argument_list|(
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|flags
argument_list|)
condition|)
goto|goto
name|next_addchain
goto|;
name|dns_dbiterator_current
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|->
name|delete_nsec
condition|)
block|{
name|delegation
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|delete_nsec
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
operator|&
name|nsec_diff
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_addnode
goto|;
block|}
comment|/* 		 * On the first pass we need to check if the current node 		 * has not been obscured. 		 */
name|delegation
operator|=
name|ISC_FALSE
expr_stmt|;
name|unsecure
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|dns_fixedname_t
name|ffound
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|ffound
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ffound
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|DNS_DBFIND_NOWILD
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|found
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|==
name|DNS_R_DELEGATION
operator|||
name|result
operator|==
name|DNS_R_DNAME
operator|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|found
argument_list|)
condition|)
block|{
comment|/* 				 * Remember the obscuring name so that 				 * we skip all obscured names. 				 */
name|dns_name_copy
argument_list|(
name|found
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_addnode
goto|;
block|}
block|}
comment|/* 		 * Check to see if this is a bottom of zone node. 		 */
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
comment|/* Empty node? */
goto|goto
name|next_addnode
goto|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|seen_soa
operator|=
name|seen_ns
operator|=
name|seen_dname
operator|=
name|seen_ds
operator|=
name|seen_nsec
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iterator
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_nsec3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_soa
condition|)
name|seen_soa
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_ns
condition|)
name|seen_ns
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_dname
condition|)
name|seen_dname
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_ds
condition|)
name|seen_ds
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|seen_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
comment|/* 		 * Is there a NSEC chain than needs to be cleaned up? 		 */
if|if
condition|(
name|seen_nsec
condition|)
name|nsec3chain
operator|->
name|seen_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|seen_ns
operator|&&
operator|!
name|seen_soa
operator|&&
operator|!
name|seen_ds
condition|)
name|unsecure
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|seen_ns
operator|&&
operator|!
name|seen_soa
operator|)
operator|||
name|seen_dname
condition|)
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Process one node. 		 */
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_nsec3_addnsec3
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
operator|&
name|nsec3chain
operator|->
name|nsec3param
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|unsecure
argument_list|,
operator|&
name|nsec3_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"dns_nsec3_addnsec3 -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 		 * Treat each call to dns_nsec3_addnsec3() as if it's cost is 		 * two signatures.  Additionally there will, in general, be 		 * two signature generated below. 		 * 		 * If we are only changing the optout flag the cost is half 		 * that of the cost of generating a completely new chain. 		 */
name|signatures
operator|-=
literal|4
expr_stmt|;
comment|/* 		 * Go onto next node. 		 */
name|next_addnode
label|:
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
operator|&&
name|nsec3chain
operator|->
name|delete_nsec
condition|)
block|{
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|fixup_nsec3param
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|nsec3chain
argument_list|,
name|ISC_FALSE
argument_list|,
name|privatetype
argument_list|,
operator|&
name|param_diff
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|cleanup
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|next_addchain
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|->
name|seen_nsec
condition|)
block|{
name|CHECK
argument_list|(
name|fixup_nsec3param
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|nsec3chain
argument_list|,
name|ISC_TRUE
argument_list|,
name|privatetype
argument_list|,
operator|&
name|param_diff
argument_list|)
argument_list|)
expr_stmt|;
name|nsec3chain
operator|->
name|delete_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|same_addchain
goto|;
block|}
name|CHECK
argument_list|(
name|fixup_nsec3param
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|nsec3chain
argument_list|,
name|ISC_FALSE
argument_list|,
name|privatetype
argument_list|,
operator|&
name|param_diff
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|cleanup
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|next_addchain
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"dns_dbiterator_next -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
elseif|else
if|if
condition|(
name|delegation
condition|)
block|{
name|dns_dbiterator_current
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|nextname
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|nextname
argument_list|,
name|name
argument_list|)
condition|)
break|break;
block|}
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
continue|continue;
name|same_addchain
label|:
name|CHECK
argument_list|(
name|dns_dbiterator_first
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
name|next_addchain
label|:
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|nsec3chain
operator|=
name|nextnsec3chain
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
name|nsec3chain
operator|->
name|save_delete_nsec
operator|=
name|nsec3chain
operator|->
name|delete_nsec
expr_stmt|;
block|}
comment|/* 	 * Process removals. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
name|buildnsecchain
operator|=
name|ISC_FALSE
expr_stmt|;
while|while
condition|(
name|nsec3chain
operator|!=
name|NULL
operator|&&
name|nodes
operator|--
operator|>
literal|0
operator|&&
name|signatures
operator|>
literal|0
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nextnsec3chain
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|->
name|db
operator|!=
name|db
condition|)
goto|goto
name|next_removechain
goto|;
if|if
condition|(
operator|!
name|NSEC3REMOVE
argument_list|(
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|flags
argument_list|)
condition|)
goto|goto
name|next_removechain
goto|;
comment|/* 		 * Work out if we need to build a NSEC chain as a consequence 		 * of removing this NSEC3 chain. 		 */
if|if
condition|(
name|first
operator|&&
operator|!
name|updatensec
operator|&&
operator|(
name|nsec3chain
operator|->
name|nsec3param
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_NONSEC
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|need_nsec_chain
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|nsec3chain
operator|->
name|nsec3param
argument_list|,
operator|&
name|buildnsecchain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"need_nsec_chain -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
if|if
condition|(
name|first
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"zone_nsec3chain:"
literal|"buildnsecchain = %u\n"
argument_list|,
name|buildnsecchain
argument_list|)
expr_stmt|;
name|dns_dbiterator_current
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|delegation
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|buildnsecchain
condition|)
block|{
comment|/* 			 * Delete the NSECPARAM record that matches this chain. 			 */
if|if
condition|(
name|first
condition|)
block|{
name|result
operator|=
name|fixup_nsec3param
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|nsec3chain
argument_list|,
name|ISC_TRUE
argument_list|,
name|privatetype
argument_list|,
operator|&
name|param_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"fixup_nsec3param -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
comment|/* 			 *  Delete the NSEC3 records. 			 */
name|result
operator|=
name|deletematchingnsec3
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
operator|&
name|nsec3chain
operator|->
name|nsec3param
argument_list|,
operator|&
name|nsec3_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"deletematchingnsec3 -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
goto|goto
name|next_removenode
goto|;
block|}
if|if
condition|(
name|first
condition|)
block|{
name|dns_fixedname_t
name|ffound
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|ffound
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ffound
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|DNS_DBFIND_NOWILD
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|found
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|==
name|DNS_R_DELEGATION
operator|||
name|result
operator|==
name|DNS_R_DNAME
operator|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|found
argument_list|)
condition|)
block|{
comment|/* 				 * Remember the obscuring name so that 				 * we skip all obscured names. 				 */
name|dns_name_copy
argument_list|(
name|found
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_removenode
goto|;
block|}
block|}
comment|/* 		 * Check to see if this is a bottom of zone node. 		 */
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
comment|/* Empty node? */
goto|goto
name|next_removenode
goto|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|seen_soa
operator|=
name|seen_ns
operator|=
name|seen_dname
operator|=
name|seen_nsec3
operator|=
name|seen_nsec
operator|=
name|seen_rr
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iterator
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_soa
condition|)
name|seen_soa
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_ns
condition|)
name|seen_ns
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_dname
condition|)
name|seen_dname
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|seen_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
name|seen_nsec3
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
name|seen_rr
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seen_rr
operator|||
name|seen_nsec3
operator|||
name|seen_nsec
condition|)
goto|goto
name|next_removenode
goto|;
if|if
condition|(
operator|(
name|seen_ns
operator|&&
operator|!
name|seen_soa
operator|)
operator|||
name|seen_dname
condition|)
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Add a NSEC record except at the origin. 		 */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|)
condition|)
block|{
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|add_nsec
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|node
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|delegation
argument_list|,
operator|&
name|nsec_diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|next_removenode
label|:
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
operator|&&
name|buildnsecchain
condition|)
block|{
comment|/* 				 * The NSEC chain should now be built. 				 * We can now remove the NSEC3 chain. 				 */
name|updatensec
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|same_removechain
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|cleanup
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|result
operator|=
name|fixup_nsec3param
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|nsec3chain
argument_list|,
name|ISC_FALSE
argument_list|,
name|privatetype
argument_list|,
operator|&
name|param_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"fixup_nsec3param -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
goto|goto
name|next_removechain
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"dns_dbiterator_next -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
elseif|else
if|if
condition|(
name|delegation
condition|)
block|{
name|dns_dbiterator_current
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|nextname
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|nextname
argument_list|,
name|name
argument_list|)
condition|)
break|break;
block|}
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
continue|continue;
name|same_removechain
label|:
name|CHECK
argument_list|(
name|dns_dbiterator_first
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
argument_list|)
expr_stmt|;
name|buildnsecchain
operator|=
name|ISC_FALSE
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
name|next_removechain
label|:
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|nsec3chain
operator|=
name|nextnsec3chain
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 	 * We may need to update the NSEC/NSEC3 records for the zone apex. 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|param_diff
operator|.
name|tuples
argument_list|)
condition|)
block|{
name|isc_boolean_t
name|rebuild_nsec
init|=
name|ISC_FALSE
decl_stmt|,
name|rebuild_nsec3
init|=
name|ISC_FALSE
decl_stmt|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"dns_db_allrdatasets -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iterator
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|rebuild_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3param
condition|)
name|rebuild_nsec3
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rebuild_nsec
condition|)
block|{
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|result
operator|=
name|updatesecure
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|nsec_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"updatesecure -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
if|if
condition|(
name|rebuild_nsec3
condition|)
block|{
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_nsec3_addnsec3s
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|nsec3_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"dns_nsec3_addnsec3s -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
block|}
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
comment|/* 	 * Add / update signatures for the NSEC3 records. 	 */
if|if
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|result
operator|=
name|update_sigs
argument_list|(
operator|&
name|nsec3_diff
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|now
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|,
operator|&
name|zonediff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"update_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * We have changed the NSEC3PARAM or private RRsets 	 * above so we need to update the signatures. 	 */
name|result
operator|=
name|update_sigs
argument_list|(
operator|&
name|param_diff
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|now
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|,
operator|&
name|zonediff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"update_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|updatensec
condition|)
block|{
name|result
operator|=
name|updatesecure
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|nsec_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"updatesecure -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|result
operator|=
name|update_sigs
argument_list|(
operator|&
name|nsec_diff
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|now
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|,
operator|&
name|zonediff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"update_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * If we made no effective changes to the zone then we can just 	 * cleanup otherwise we need to increment the serial. 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|zonediff
operator|.
name|diff
operator|->
name|tuples
argument_list|)
condition|)
block|{
comment|/* 		 * No need to call dns_db_closeversion() here as it is 		 * called with commit = ISC_TRUE below. 		 */
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|del_sigs
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|zonediff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|now
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"del_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"update_soa_serial -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|add_sigs
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|inception
argument_list|,
name|soaexpire
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain:"
literal|"add_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Write changes to journal file. */
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"zone_nsec3chain"
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Pause all iterators so that dns_db_closeversion() can succeed. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
for|for
control|(
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
init|;
name|nsec3chain
operator|!=
name|NULL
condition|;
name|nsec3chain
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3chain
argument_list|,
name|link
argument_list|)
control|)
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Everything has succeeded. Commit the changes. 	 * Unconditionally commit as zonediff.offline not checked above. 	 */
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Everything succeeded so we can clean these up now. 	 */
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
while|while
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|cleanup
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|nsec3chain
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3chain
argument_list|,
sizeof|sizeof
expr|*
name|nsec3chain
argument_list|)
expr_stmt|;
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_nsec3chain: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * On error roll back the current nsec3chain. 	 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|nsec3chain
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nsec3chain
operator|->
name|done
condition|)
block|{
name|dns_db_detach
argument_list|(
operator|&
name|nsec3chain
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3chain
argument_list|,
sizeof|sizeof
expr|*
name|nsec3chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|nsec3chain
operator|->
name|delete_nsec
operator|=
name|nsec3chain
operator|->
name|save_delete_nsec
expr_stmt|;
block|}
block|}
comment|/* 	 * Rollback the cleanup list. 	 */
name|nsec3chain
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
while|while
condition|(
name|nsec3chain
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|cleanup
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3chain
operator|->
name|done
condition|)
block|{
name|dns_db_detach
argument_list|(
operator|&
name|nsec3chain
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3chain
argument_list|,
sizeof|sizeof
expr|*
name|nsec3chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|,
name|nsec3chain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|nsec3chain
operator|->
name|delete_nsec
operator|=
name|nsec3chain
operator|->
name|save_delete_nsec
expr_stmt|;
block|}
name|nsec3chain
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
for|for
control|(
name|nsec3chain
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
init|;
name|nsec3chain
operator|!=
name|NULL
condition|;
name|nsec3chain
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3chain
argument_list|,
name|link
argument_list|)
control|)
name|dns_dbiterator_pause
argument_list|(
name|nsec3chain
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|param_diff
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|nsec3_diff
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|nsec_diff
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterator
operator|!=
name|NULL
condition|)
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
name|dst_key_free
argument_list|(
operator|&
name|zone_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|nsec3chain
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|isc_interval_t
name|i
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|update_disabled
operator|||
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 1 minute */
else|else
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|del_sig
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|unsigned
name|int
name|nkeys
parameter_list|,
name|dns_secalg_t
name|algorithm
parameter_list|,
name|isc_uint16_t
name|keyid
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|iterator
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iterator
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|==
literal|0
operator|&&
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|failure
goto|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrsig
operator|.
name|algorithm
operator|!=
name|algorithm
operator|||
name|rrsig
operator|.
name|keyid
operator|!=
name|keyid
condition|)
continue|continue;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DELRESIGN
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incrementally sign the zone using the keys requested.  * Builds the NSEC chain if required.  */
end_comment

begin_function
specifier|static
name|void
name|zone_sign
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|me
init|=
literal|"zone_sign"
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|_sig_diff
decl_stmt|;
name|dns_diff_t
name|post_diff
decl_stmt|;
name|zonediff_t
name|zonediff
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_t
name|nextfixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|nextname
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_signing_t
modifier|*
name|signing
decl_stmt|,
modifier|*
name|nextsigning
decl_stmt|;
name|dns_signinglist_t
name|cleanup
decl_stmt|;
name|dst_key_t
modifier|*
name|zone_keys
index|[
name|DNS_MAXZONEKEYS
index|]
decl_stmt|;
name|isc_int32_t
name|signatures
decl_stmt|;
name|isc_boolean_t
name|check_ksk
decl_stmt|,
name|keyset_kskonly
decl_stmt|,
name|is_ksk
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|delegation
decl_stmt|;
name|isc_boolean_t
name|build_nsec
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|build_nsec3
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|,
name|inception
decl_stmt|,
name|soaexpire
decl_stmt|,
name|expire
decl_stmt|;
name|isc_uint32_t
name|jitter
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|nkeys
init|=
literal|0
decl_stmt|;
name|isc_uint32_t
name|nodes
decl_stmt|;
name|ENTER
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|nextfixed
argument_list|)
expr_stmt|;
name|nextname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|nextfixed
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|post_diff
argument_list|)
expr_stmt|;
name|zonediff_init
argument_list|(
operator|&
name|zonediff
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* 	 * Updates are disabled.  Pause for 5 minutes. 	 */
if|if
condition|(
name|zone
operator|->
name|update_disabled
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|find_zone_keys
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MAXZONEKEYS
argument_list|,
name|zone_keys
argument_list|,
operator|&
name|nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:find_zone_keys -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|inception
operator|=
name|now
operator|-
literal|3600
expr_stmt|;
comment|/* Allow for clock skew. */
name|soaexpire
operator|=
name|now
operator|+
name|dns_zone_getsigvalidityinterval
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Spread out signatures over time if they happen to be 	 * clumped.  We don't do this for each add_sigs() call as 	 * we still want some clustering to occur. 	 */
name|isc_random_get
argument_list|(
operator|&
name|jitter
argument_list|)
expr_stmt|;
name|expire
operator|=
name|soaexpire
operator|-
name|jitter
operator|%
literal|3600
expr_stmt|;
comment|/* 	 * We keep pulling nodes off each iterator in turn until 	 * we have no more nodes to pull off or we reach the limits 	 * for this quantum. 	 */
name|nodes
operator|=
name|zone
operator|->
name|nodes
expr_stmt|;
name|signatures
operator|=
name|zone
operator|->
name|signatures
expr_stmt|;
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
name|check_ksk
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_UPDATECHECKKSK
argument_list|)
expr_stmt|;
name|keyset_kskonly
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_DNSKEYKSKONLY
argument_list|)
expr_stmt|;
comment|/* Determine which type of chain to build */
name|CHECK
argument_list|(
name|dns_private_chains
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
operator|&
name|build_nsec
argument_list|,
operator|&
name|build_nsec3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If neither chain is found, default to NSEC */
if|if
condition|(
operator|!
name|build_nsec
operator|&&
operator|!
name|build_nsec3
condition|)
name|build_nsec
operator|=
name|ISC_TRUE
expr_stmt|;
while|while
condition|(
name|signing
operator|!=
name|NULL
operator|&&
name|nodes
operator|--
operator|>
literal|0
operator|&&
name|signatures
operator|>
literal|0
condition|)
block|{
name|nextsigning
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|signing
operator|->
name|done
operator|||
name|signing
operator|->
name|db
operator|!=
name|zone
operator|->
name|db
condition|)
block|{
comment|/* 			 * The zone has been reloaded.	We will have 			 * created new signings as part of the reload 			 * process so we can destroy this one. 			 */
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|signing
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|cleanup
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
goto|goto
name|next_signing
goto|;
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|signing
operator|->
name|db
operator|!=
name|db
condition|)
goto|goto
name|next_signing
goto|;
name|delegation
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|signing
operator|->
name|delete
condition|)
block|{
comment|/* 			 * Remove the key we are deleting from consideration. 			 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * Find the key we want to remove. 				 */
if|if
condition|(
name|ALG
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
operator|==
name|signing
operator|->
name|algorithm
operator|&&
name|dst_key_id
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
operator|==
name|signing
operator|->
name|keyid
condition|)
block|{
if|if
condition|(
name|KSK
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
condition|)
name|dst_key_free
argument_list|(
operator|&
name|zone_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zone_keys
index|[
name|j
index|]
operator|=
name|zone_keys
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nkeys
operator|=
name|j
expr_stmt|;
block|}
name|dns_dbiterator_current
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|signing
operator|->
name|delete
condition|)
block|{
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|del_sig
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|node
argument_list|,
name|nkeys
argument_list|,
name|signing
operator|->
name|algorithm
argument_list|,
name|signing
operator|->
name|keyid
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * On the first pass we need to check if the current node 		 * has not been obscured. 		 */
if|if
condition|(
name|first
condition|)
block|{
name|dns_fixedname_t
name|ffound
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|ffound
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ffound
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|DNS_DBFIND_NOWILD
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|found
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|==
name|DNS_R_DELEGATION
operator|||
name|result
operator|==
name|DNS_R_DNAME
operator|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|found
argument_list|)
condition|)
block|{
comment|/* 				 * Remember the obscuring name so that 				 * we skip all obscured names. 				 */
name|dns_name_copy
argument_list|(
name|found
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delegation
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_node
goto|;
block|}
block|}
comment|/* 		 * Process one node. 		 */
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
name|isc_boolean_t
name|both
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 			 * Find the keys we want to sign with. 			 */
if|if
condition|(
operator|!
name|dst_key_isprivate
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
comment|/* 			 * When adding look for the specific key. 			 */
if|if
condition|(
operator|!
name|signing
operator|->
name|delete
operator|&&
operator|(
name|dst_key_alg
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
operator|!=
name|signing
operator|->
name|algorithm
operator|||
name|dst_key_id
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
operator|!=
name|signing
operator|->
name|keyid
operator|)
condition|)
continue|continue;
comment|/* 			 * When deleting make sure we are properly signed 			 * with the algorithm that was being removed. 			 */
if|if
condition|(
name|signing
operator|->
name|delete
operator|&&
name|ALG
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
operator|!=
name|signing
operator|->
name|algorithm
condition|)
continue|continue;
comment|/* 			 * Do we do KSK processing? 			 */
if|if
condition|(
name|check_ksk
operator|&&
operator|!
name|REVOKE
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|isc_boolean_t
name|have_ksk
decl_stmt|,
name|have_nonksk
decl_stmt|;
if|if
condition|(
name|KSK
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|have_ksk
operator|=
name|ISC_TRUE
expr_stmt|;
name|have_nonksk
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|have_ksk
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_nonksk
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nkeys
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
operator|||
name|ALG
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
operator|!=
name|ALG
argument_list|(
name|zone_keys
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|REVOKE
argument_list|(
name|zone_keys
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|KSK
argument_list|(
name|zone_keys
index|[
name|j
index|]
argument_list|)
condition|)
name|have_ksk
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|have_nonksk
operator|=
name|ISC_TRUE
expr_stmt|;
name|both
operator|=
name|have_ksk
operator|&&
name|have_nonksk
expr_stmt|;
if|if
condition|(
name|both
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|both
operator|||
name|REVOKE
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
condition|)
name|is_ksk
operator|=
name|KSK
argument_list|(
name|zone_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|is_ksk
operator|=
name|ISC_FALSE
expr_stmt|;
name|CHECK
argument_list|(
name|sign_a_node
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|build_nsec3
argument_list|,
name|build_nsec
argument_list|,
name|zone_keys
index|[
name|i
index|]
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|is_ksk
argument_list|,
name|ISC_TF
argument_list|(
name|both
operator|&&
name|keyset_kskonly
argument_list|)
argument_list|,
operator|&
name|delegation
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
operator|&
name|signatures
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If we are adding we are done.  Look for other keys 			 * of the same algorithm if deleting. 			 */
if|if
condition|(
operator|!
name|signing
operator|->
name|delete
condition|)
break|break;
block|}
comment|/* 		 * Go onto next node. 		 */
name|next_node
label|:
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|signing
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|cleanup
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|!=
literal|0
operator|&&
name|build_nsec
condition|)
block|{
comment|/* 					 * We have finished regenerating the 					 * zone with a zone signing key. 					 * The NSEC chain is now complete and 					 * there is a full set of signatures 					 * for the zone.  We can now clear the 					 * OPT bit from the NSEC record. 					 */
name|result
operator|=
name|updatesecure
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|post_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"updatesecure -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|result
operator|=
name|updatesignwithkey
argument_list|(
name|zone
argument_list|,
name|signing
argument_list|,
name|version
argument_list|,
name|build_nsec3
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
operator|&
name|post_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"updatesignwithkey -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|build_nsec
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|next_signing
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:dns_dbiterator_next -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
elseif|else
if|if
condition|(
name|delegation
condition|)
block|{
name|dns_dbiterator_current
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|,
operator|&
name|node
argument_list|,
name|nextname
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|nextname
argument_list|,
name|name
argument_list|)
condition|)
break|break;
block|}
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
continue|continue;
name|next_signing
label|:
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|signing
operator|=
name|nextsigning
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|post_diff
operator|.
name|tuples
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|update_sigs
argument_list|(
operator|&
name|post_diff
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
argument_list|,
name|inception
argument_list|,
name|expire
argument_list|,
name|now
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|,
operator|&
name|zonediff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:"
literal|"update_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
comment|/* 	 * Have we changed anything? 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|zonediff
operator|.
name|diff
operator|->
name|tuples
argument_list|)
condition|)
block|{
if|if
condition|(
name|zonediff
operator|.
name|offline
condition|)
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|pauseall
goto|;
block|}
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|del_sigs
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|zonediff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|now
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:del_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:update_soa_serial -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Generate maximum life time signatures so that the above loop 	 * termination is sensible. 	 */
name|result
operator|=
name|add_sigs
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|inception
argument_list|,
name|soaexpire
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_sign:add_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Write changes to journal file. 	 */
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"zone_sign"
argument_list|)
argument_list|)
expr_stmt|;
name|pauseall
label|:
comment|/* 	 * Pause all iterators so that dns_db_closeversion() can succeed. 	 */
for|for
control|(
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
init|;
name|signing
operator|!=
name|NULL
condition|;
name|signing
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|signing
argument_list|,
name|link
argument_list|)
control|)
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
for|for
control|(
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
init|;
name|signing
operator|!=
name|NULL
condition|;
name|signing
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|signing
argument_list|,
name|link
argument_list|)
control|)
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
comment|/* 	 * Everything has succeeded. Commit the changes. 	 */
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|commit
argument_list|)
expr_stmt|;
comment|/* 	 * Everything succeeded so we can clean these up now. 	 */
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
while|while
condition|(
name|signing
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|cleanup
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|signing
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|signing
argument_list|,
sizeof|sizeof
expr|*
name|signing
argument_list|)
expr_stmt|;
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
comment|/* 	 * Rollback the cleanup list. 	 */
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
while|while
condition|(
name|signing
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|cleanup
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|zone
operator|->
name|signing
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_dbiterator_first
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|signing
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
init|;
name|signing
operator|!=
name|NULL
condition|;
name|signing
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|signing
argument_list|,
name|link
argument_list|)
control|)
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
name|dst_key_free
argument_list|(
operator|&
name|zone_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|isc_interval_t
name|i
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|update_disabled
operator|||
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 1 minute */
else|else
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|normalize_key
parameter_list|(
name|dns_rdata_t
modifier|*
name|rr
parameter_list|,
name|dns_rdata_t
modifier|*
name|target
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|dns_rdata_keydata_t
name|keydata
decl_stmt|;
name|isc_buffer_t
name|buf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_reset
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rr
operator|->
name|type
condition|)
block|{
case|case
name|dns_rdatatype_dnskey
case|:
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
name|rr
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dnskey
operator|.
name|flags
operator|&=
operator|~
name|DNS_KEYFLAG_REVOKE
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
name|target
argument_list|,
name|rr
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|dnskey
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_rdatatype_keydata
case|:
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
name|rr
argument_list|,
operator|&
name|keydata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_UNEXPECTEDEND
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_keydata_todnskey
argument_list|(
operator|&
name|keydata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
name|target
argument_list|,
name|rr
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|dnskey
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'rdset' contains either a DNSKEY rdataset from the zone apex, or  * a KEYDATA rdataset from the key zone.  *  * 'rr' contains either a DNSKEY record, or a KEYDATA record  *  * After normalizing keys to the same format (DNSKEY, with revoke bit  * cleared), return ISC_TRUE if a key that matches 'rr' is found in  * 'rdset', or ISC_FALSE if not.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|matchkey
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rr
parameter_list|)
block|{
name|unsigned
name|char
name|data1
index|[
literal|4096
index|]
decl_stmt|,
name|data2
index|[
literal|4096
index|]
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|,
name|rdata1
decl_stmt|,
name|rdata2
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata1
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata2
argument_list|)
expr_stmt|;
name|result
operator|=
name|normalize_key
argument_list|(
name|rr
argument_list|,
operator|&
name|rdata1
argument_list|,
name|data1
argument_list|,
sizeof|sizeof
argument_list|(
name|data1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|normalize_key
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rdata2
argument_list|,
name|data2
argument_list|,
sizeof|sizeof
argument_list|(
name|data2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|rdata1
argument_list|,
operator|&
name|rdata2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the refresh interval for a keydata zone, per  * RFC5011: MAX(1 hr,  *		MIN(15 days,  *		    1/2 * OrigTTL,  *		    1/2 * RRSigExpirationInterval))  * or for retries: MAX(1 hr,  *		       MIN(1 day,  *			   1/10 * OrigTTL,  *			   1/10 * RRSigExpirationInterval))  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_stdtime_t
name|refresh_time
parameter_list|(
name|dns_keyfetch_t
modifier|*
name|kfetch
parameter_list|,
name|isc_boolean_t
name|retry
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|t
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdset
decl_stmt|;
name|dns_rdata_t
name|sigrr
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_sig_t
name|sig
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
condition|)
name|rdset
operator|=
operator|&
name|kfetch
operator|->
name|dnskeysigset
expr_stmt|;
else|else
return|return
operator|(
name|now
operator|+
name|HOUR
operator|)
return|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|now
operator|+
name|HOUR
operator|)
return|;
name|dns_rdataset_current
argument_list|(
name|rdset
argument_list|,
operator|&
name|sigrr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrr
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|t
operator|=
name|sig
operator|.
name|originalttl
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|isc_serial_gt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|exp
init|=
operator|(
name|sig
operator|.
name|timeexpire
operator|-
name|now
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|t
operator|>
name|exp
condition|)
name|t
operator|=
name|exp
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|>
operator|(
literal|15
operator|*
name|DAY
operator|)
condition|)
name|t
operator|=
operator|(
literal|15
operator|*
name|DAY
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|HOUR
condition|)
name|t
operator|=
name|HOUR
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|sig
operator|.
name|originalttl
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|isc_serial_gt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|exp
init|=
operator|(
name|sig
operator|.
name|timeexpire
operator|-
name|now
operator|)
operator|/
literal|10
decl_stmt|;
if|if
condition|(
name|t
operator|>
name|exp
condition|)
name|t
operator|=
name|exp
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|>
name|DAY
condition|)
name|t
operator|=
name|DAY
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|HOUR
condition|)
name|t
operator|=
name|HOUR
expr_stmt|;
block|}
return|return
operator|(
name|now
operator|+
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called when no changes are needed in a KEYDATA  * record except to simply update the refresh timer.  Caller should  * hold zone lock.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|minimal_update
parameter_list|(
name|dns_keyfetch_t
modifier|*
name|kfetch
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|keyb
decl_stmt|;
name|unsigned
name|char
name|key_buf
index|[
literal|4096
index|]
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_keydata_t
name|keydata
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|kfetch
operator|->
name|zone
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|kfetch
operator|->
name|name
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* Delete old version */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update refresh timer */
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|keydata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_UNEXPECTEDEND
condition|)
continue|continue;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|keydata
operator|.
name|refresh
operator|=
name|refresh_time
argument_list|(
name|kfetch
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|set_refreshkeytimer
argument_list|(
name|zone
argument_list|,
operator|&
name|keydata
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|keyb
argument_list|,
name|key_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|key_buf
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rdata
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_keydata
argument_list|,
operator|&
name|keydata
argument_list|,
operator|&
name|keyb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert updated version */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that DNSKEY set is signed by the key specified in 'keydata'.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|revocable
parameter_list|(
name|dns_keyfetch_t
modifier|*
name|kfetch
parameter_list|,
name|dns_rdata_keydata_t
modifier|*
name|keydata
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_rdata_t
name|sigrr
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|rr
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|dst_key_t
modifier|*
name|dstkey
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|key_buf
index|[
literal|4096
index|]
decl_stmt|;
name|isc_buffer_t
name|keyb
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|kfetch
operator|!=
name|NULL
operator|&&
name|keydata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
argument_list|)
expr_stmt|;
name|keyname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|kfetch
operator|->
name|name
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|kfetch
operator|->
name|zone
operator|->
name|view
operator|->
name|mctx
expr_stmt|;
comment|/* Generate a key from keydata */
name|isc_buffer_init
argument_list|(
operator|&
name|keyb
argument_list|,
name|key_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|key_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_keydata_todnskey
argument_list|(
name|keydata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rr
argument_list|,
name|keydata
operator|->
name|common
operator|.
name|rdclass
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|dnskey
argument_list|,
operator|&
name|keyb
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_keyfromrdata
argument_list|(
name|keyname
argument_list|,
operator|&
name|rr
argument_list|,
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* See if that key generated any of the signatures */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
control|)
block|{
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrr
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|,
operator|&
name|sigrr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrr
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_key_alg
argument_list|(
name|dstkey
argument_list|)
operator|==
name|sig
operator|.
name|algorithm
operator|&&
operator|(
name|dst_key_id
argument_list|(
name|dstkey
argument_list|)
operator|==
name|sig
operator|.
name|keyid
operator|||
name|dst_key_rid
argument_list|(
name|dstkey
argument_list|)
operator|==
name|sig
operator|.
name|keyid
operator|)
condition|)
block|{
name|result
operator|=
name|dns_dnssec_verify2
argument_list|(
name|keyname
argument_list|,
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|,
name|dstkey
argument_list|,
name|ISC_FALSE
argument_list|,
name|mctx
argument_list|,
operator|&
name|sigrr
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|kfetch
operator|->
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"Confirm revoked DNSKEY is self-signed: "
literal|"%s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A DNSKEY set has been fetched from the zone apex of a zone whose trust  * anchors are being managed; scan the keyset, and update the key zone and the  * local trust anchors according to RFC5011.  */
end_comment

begin_function
specifier|static
name|void
name|keyfetch_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fetchevent_t
modifier|*
name|devent
decl_stmt|;
name|dns_keyfetch_t
modifier|*
name|kfetch
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|dns_keytable_t
modifier|*
name|secroots
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|isc_boolean_t
name|alldone
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
decl_stmt|;
name|dns_rdata_t
name|sigrr
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|dnskeyrr
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|keydatarr
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|dns_rdata_keydata_t
name|keydata
decl_stmt|;
name|isc_boolean_t
name|initializing
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|key_buf
index|[
literal|4096
index|]
decl_stmt|;
name|isc_buffer_t
name|keyb
decl_stmt|;
name|dst_key_t
modifier|*
name|dstkey
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|int
name|pending
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|secure
decl_stmt|;
name|isc_boolean_t
name|free_needed
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|!=
name|NULL
operator|&&
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_arg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|kfetch
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|zone
operator|=
name|kfetch
operator|->
name|zone
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|keyname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|kfetch
operator|->
name|name
argument_list|)
expr_stmt|;
name|devent
operator|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|eresult
operator|=
name|devent
operator|->
name|result
expr_stmt|;
comment|/* Free resources which are not of interest */
if|if
condition|(
name|devent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|devent
operator|->
name|db
argument_list|,
operator|&
name|devent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|devent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|devent
operator|->
name|db
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|kfetch
operator|->
name|fetch
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
operator|||
name|zone
operator|->
name|view
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|keyname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_view_getsecroots
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|secroots
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_newversion
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
operator|&
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshkeycount
operator|--
expr_stmt|;
name|alldone
operator|=
name|ISC_TF
argument_list|(
name|zone
operator|->
name|refreshkeycount
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alldone
condition|)
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESHING
argument_list|)
expr_stmt|;
comment|/* Fetch failed */
if|if
condition|(
name|eresult
operator|!=
name|ISC_R_SUCCESS
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Unable to fetch DNSKEY set "
literal|"'%s': %s"
argument_list|,
name|namebuf
argument_list|,
name|dns_result_totext
argument_list|(
name|eresult
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|minimal_update
argument_list|(
name|kfetch
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* No RRSIGs found */
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"No DNSKEY RRSIGs found for "
literal|"'%s': %s"
argument_list|,
name|namebuf
argument_list|,
name|dns_result_totext
argument_list|(
name|eresult
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|minimal_update
argument_list|(
name|kfetch
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Validate the dnskeyset against the current trusted keys. 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
control|)
block|{
name|dns_keynode_t
modifier|*
name|keynode
init|=
name|NULL
decl_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrr
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|,
operator|&
name|sigrr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrr
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_keytable_find
argument_list|(
name|secroots
argument_list|,
name|keyname
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_keynode_t
modifier|*
name|nextnode
init|=
name|NULL
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dstkey
operator|=
name|dns_keynode_key
argument_list|(
name|keynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstkey
operator|==
name|NULL
condition|)
comment|/* fail_secure() was called */
break|break;
if|if
condition|(
name|dst_key_alg
argument_list|(
name|dstkey
argument_list|)
operator|==
name|sig
operator|.
name|algorithm
operator|&&
name|dst_key_id
argument_list|(
name|dstkey
argument_list|)
operator|==
name|sig
operator|.
name|keyid
condition|)
block|{
name|result
operator|=
name|dns_dnssec_verify2
argument_list|(
name|keyname
argument_list|,
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|,
name|dstkey
argument_list|,
name|ISC_FALSE
argument_list|,
name|zone
operator|->
name|view
operator|->
name|mctx
argument_list|,
operator|&
name|sigrr
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"Verifying DNSKEY set for zone "
literal|"'%s': %s"
argument_list|,
name|namebuf
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|kfetch
operator|->
name|dnskeyset
operator|.
name|trust
operator|=
name|dns_trust_secure
expr_stmt|;
name|kfetch
operator|->
name|dnskeysigset
operator|.
name|trust
operator|=
name|dns_trust_secure
expr_stmt|;
name|dns_keytable_detachkeynode
argument_list|(
name|secroots
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|result
operator|=
name|dns_keytable_nextkeynode
argument_list|(
name|secroots
argument_list|,
name|keynode
argument_list|,
operator|&
name|nextnode
argument_list|)
expr_stmt|;
name|dns_keytable_detachkeynode
argument_list|(
name|secroots
argument_list|,
operator|&
name|keynode
argument_list|)
expr_stmt|;
name|keynode
operator|=
name|nextnode
expr_stmt|;
block|}
if|if
condition|(
name|kfetch
operator|->
name|dnskeyset
operator|.
name|trust
operator|==
name|dns_trust_secure
condition|)
break|break;
block|}
comment|/* 	 * If we were not able to verify the answer using the current 	 * trusted keys then all we can do is look at any revoked keys. 	 */
name|secure
operator|=
name|ISC_TF
argument_list|(
name|kfetch
operator|->
name|dnskeyset
operator|.
name|trust
operator|==
name|dns_trust_secure
argument_list|)
expr_stmt|;
comment|/* 	 * First scan keydataset to find keys that are not in dnskeyset 	 *   - Missing keys which are not scheduled for removal, 	 *     log a warning 	 *   - Missing keys which are scheduled for removal and 	 *     the remove hold-down timer has completed should 	 *     be removed from the key zone 	 *   - Missing keys whose acceptance timers have not yet 	 *     completed, log a warning and reset the acceptance 	 *     timer to 30 days in the future 	 *   - All keys not being removed have their refresh timers 	 *     updated 	 */
name|initializing
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|,
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|keydatarr
argument_list|,
operator|&
name|keydata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 		 * If any keydata record has a nonzero add holddown, then 		 * there was a pre-existing trust anchor for this domain; 		 * that means we are *not* initializing it and shouldn't 		 * automatically trust all the keys we find at the zone apex. 		 */
name|initializing
operator|=
name|initializing
operator|&&
name|ISC_TF
argument_list|(
name|keydata
operator|.
name|addhd
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matchkey
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|,
operator|&
name|keydatarr
argument_list|)
condition|)
block|{
name|isc_boolean_t
name|deletekey
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|secure
condition|)
block|{
if|if
condition|(
name|now
operator|>
name|keydata
operator|.
name|removehd
condition|)
name|deletekey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now
operator|<
name|keydata
operator|.
name|addhd
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Pending key unexpectedly missing "
literal|"from %s; restarting acceptance "
literal|"timer"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|keydata
operator|.
name|addhd
operator|=
name|now
operator|+
name|MONTH
expr_stmt|;
name|keydata
operator|.
name|refresh
operator|=
name|refresh_time
argument_list|(
name|kfetch
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keydata
operator|.
name|addhd
operator|==
literal|0
condition|)
block|{
name|keydata
operator|.
name|addhd
operator|=
name|now
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keydata
operator|.
name|removehd
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Active key unexpectedly missing "
literal|"from %s"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|keydata
operator|.
name|refresh
operator|=
name|now
operator|+
name|HOUR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now
operator|>
name|keydata
operator|.
name|removehd
condition|)
block|{
name|deletekey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|keydata
operator|.
name|refresh
operator|=
name|refresh_time
argument_list|(
name|kfetch
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secure
operator|||
name|deletekey
condition|)
block|{
comment|/* Delete old version */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|keyname
argument_list|,
literal|0
argument_list|,
operator|&
name|keydatarr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|secure
operator|||
name|deletekey
condition|)
continue|continue;
name|dns_rdata_reset
argument_list|(
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|keyb
argument_list|,
name|key_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|key_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|keydatarr
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_keydata
argument_list|,
operator|&
name|keydata
argument_list|,
operator|&
name|keyb
argument_list|)
expr_stmt|;
comment|/* Insert updated version */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|keyname
argument_list|,
literal|0
argument_list|,
operator|&
name|keydatarr
argument_list|)
argument_list|)
expr_stmt|;
name|set_refreshkeytimer
argument_list|(
name|zone
argument_list|,
operator|&
name|keydata
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Next scan dnskeyset: 	 *   - If new keys are found (i.e., lacking a match in keydataset) 	 *     add them to the key zone and set the acceptance timer 	 *     to 30 days in the future (or to immediately if we've 	 *     determined that we're initializing the zone for the 	 *     first time) 	 *   - Previously-known keys that have been revoked 	 *     must be scheduled for removal from the key zone (or, 	 *     if they hadn't been accepted as trust anchors yet 	 *     anyway, removed at once) 	 *   - Previously-known unrevoked keys whose acceptance timers 	 *     have completed are promoted to trust anchors 	 *   - All keys not being removed have their refresh 	 *     timers updated 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|)
control|)
block|{
name|isc_boolean_t
name|revoked
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|newkey
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|updatekey
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|deletekey
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|trustkey
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|dnskeyrr
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|,
operator|&
name|dnskeyrr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|dnskeyrr
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Skip ZSK's */
if|if
condition|(
operator|!
name|ISC_TF
argument_list|(
name|dnskey
operator|.
name|flags
operator|&
name|DNS_KEYFLAG_KSK
argument_list|)
condition|)
continue|continue;
name|revoked
operator|=
name|ISC_TF
argument_list|(
name|dnskey
operator|.
name|flags
operator|&
name|DNS_KEYFLAG_REVOKE
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchkey
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|,
operator|&
name|dnskeyrr
argument_list|)
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|,
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|keydatarr
argument_list|,
operator|&
name|keydata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|revoked
operator|&&
name|revocable
argument_list|(
name|kfetch
argument_list|,
operator|&
name|keydata
argument_list|)
condition|)
block|{
if|if
condition|(
name|keydata
operator|.
name|addhd
operator|>
name|now
condition|)
block|{
comment|/* 					 * Key wasn't trusted yet, and now 					 * it's been revoked?  Just remove it 					 */
name|deletekey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keydata
operator|.
name|removehd
operator|==
literal|0
condition|)
block|{
comment|/* Remove from secroots */
name|dns_view_untrust
argument_list|(
name|zone
operator|->
name|view
argument_list|,
name|keyname
argument_list|,
operator|&
name|dnskey
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
comment|/* If initializing, delete now */
if|if
condition|(
name|keydata
operator|.
name|addhd
operator|==
literal|0
condition|)
name|deletekey
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|keydata
operator|.
name|removehd
operator|=
name|now
operator|+
name|MONTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keydata
operator|.
name|removehd
operator|<
name|now
condition|)
block|{
comment|/* Scheduled for removal */
name|deletekey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|revoked
condition|)
block|{
if|if
condition|(
name|secure
operator|&&
name|keydata
operator|.
name|removehd
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Active key for zone "
literal|"'%s' is revoked but "
literal|"did not self-sign; "
literal|"ignoring."
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|secure
condition|)
block|{
if|if
condition|(
name|keydata
operator|.
name|removehd
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * Key isn't revoked--but it 					 * seems it used to be. 					 * Remove it now and add it 					 * back as if it were a fresh key. 					 */
name|deletekey
operator|=
name|ISC_TRUE
expr_stmt|;
name|newkey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keydata
operator|.
name|addhd
operator|>
name|now
condition|)
name|pending
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|keydata
operator|.
name|addhd
operator|==
literal|0
condition|)
name|keydata
operator|.
name|addhd
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|keydata
operator|.
name|addhd
operator|<=
name|now
condition|)
name|trustkey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deletekey
operator|&&
operator|!
name|newkey
condition|)
name|updatekey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secure
condition|)
block|{
comment|/* 			 * Key wasn't in the key zone but it's 			 * revoked now anyway, so just skip it 			 */
if|if
condition|(
name|revoked
condition|)
continue|continue;
comment|/* Key wasn't in the key zone: add it */
name|newkey
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|initializing
condition|)
block|{
name|dns_keytag_t
name|tag
init|=
literal|0
decl_stmt|;
name|CHECK
argument_list|(
name|compute_tag
argument_list|(
name|keyname
argument_list|,
operator|&
name|dnskey
argument_list|,
name|mctx
argument_list|,
operator|&
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Initializing automatic trust "
literal|"anchor management for zone '%s'; "
literal|"DNSKEY ID %d is now trusted, "
literal|"waiving the normal 30-day "
literal|"waiting period."
argument_list|,
name|namebuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|trustkey
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * No previously known key, and the key is not 			 * secure, so skip it. 			 */
continue|continue;
block|}
comment|/* Delete old version */
if|if
condition|(
name|deletekey
operator|||
operator|!
name|newkey
condition|)
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|keyname
argument_list|,
literal|0
argument_list|,
operator|&
name|keydatarr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|updatekey
condition|)
block|{
comment|/* Set refresh timer */
name|keydata
operator|.
name|refresh
operator|=
name|refresh_time
argument_list|(
name|kfetch
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|keyb
argument_list|,
name|key_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|key_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|keydatarr
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_keydata
argument_list|,
operator|&
name|keydata
argument_list|,
operator|&
name|keyb
argument_list|)
expr_stmt|;
comment|/* Insert updated version */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|keyname
argument_list|,
literal|0
argument_list|,
operator|&
name|keydatarr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newkey
condition|)
block|{
comment|/* Convert DNSKEY to KEYDATA */
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|dnskeyrr
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_keydata_fromdnskey
argument_list|(
operator|&
name|keydata
argument_list|,
operator|&
name|dnskey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|keydata
operator|.
name|addhd
operator|=
name|initializing
condition|?
name|now
else|:
name|now
operator|+
name|MONTH
expr_stmt|;
name|keydata
operator|.
name|refresh
operator|=
name|refresh_time
argument_list|(
name|kfetch
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|keydatarr
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|keyb
argument_list|,
name|key_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|key_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|keydatarr
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_keydata
argument_list|,
operator|&
name|keydata
argument_list|,
operator|&
name|keyb
argument_list|)
expr_stmt|;
comment|/* Insert into key zone */
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|keyname
argument_list|,
literal|0
argument_list|,
operator|&
name|keydatarr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trustkey
condition|)
block|{
comment|/* Trust this key. */
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|dnskeyrr
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|trust_key
argument_list|(
name|zone
argument_list|,
name|keyname
argument_list|,
operator|&
name|dnskey
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secure
operator|&&
operator|!
name|deletekey
condition|)
block|{
name|INSIST
argument_list|(
name|newkey
operator|||
name|updatekey
argument_list|)
expr_stmt|;
name|set_refreshkeytimer
argument_list|(
name|zone
argument_list|,
operator|&
name|keydata
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * RFC5011 says, "A trust point that has all of its trust anchors 	 * revoked is considered deleted and is treated as if the trust 	 * point was never configured."  But if someone revoked their 	 * active key before the standby was trusted, that would mean the 	 * zone would suddenly be nonsecured.  We avoid this by checking to 	 * see if there's pending keydata.  If so, we put a null key in 	 * the security roots; then all queries to the zone will fail. 	 */
if|if
condition|(
name|pending
operator|!=
literal|0
condition|)
name|fail_secure
argument_list|(
name|zone
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|.
name|tuples
argument_list|)
condition|)
block|{
comment|/* Write changes to journal file. */
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
operator|&
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"keyfetch_done"
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|30
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|kfetch
operator|->
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|dns_db_detach
argument_list|(
operator|&
name|kfetch
operator|->
name|db
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
name|kfetch
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
name|keyname
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|kfetch
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_keyfetch_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|secroots
operator|!=
name|NULL
condition|)
name|dns_keytable_detach
argument_list|(
operator|&
name|secroots
argument_list|)
expr_stmt|;
name|free_needed
operator|=
name|exit_check
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_needed
condition|)
name|zone_free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Refresh the data in the key zone.  Initiate a fetch to get new DNSKEY  * records from the zone apex.  */
end_comment

begin_function
specifier|static
name|void
name|zone_refreshkeys
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_refreshkeys"
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rriterator_t
name|rrit
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_keydata_t
name|kd
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|fetching
init|=
name|ISC_FALSE
decl_stmt|,
name|fetch_err
init|=
name|ISC_FALSE
decl_stmt|;
name|ENTER
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return;
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESHING
argument_list|)
expr_stmt|;
name|dns_rriterator_init
argument_list|(
operator|&
name|rrit
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rriterator_first
argument_list|(
operator|&
name|rrit
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rriterator_nextrrset
argument_list|(
operator|&
name|rrit
argument_list|)
control|)
block|{
name|isc_stdtime_t
name|timer
init|=
literal|0xffffffff
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|kname
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|kdset
init|=
name|NULL
decl_stmt|;
name|dns_keyfetch_t
modifier|*
name|kfetch
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_rriterator_current
argument_list|(
operator|&
name|rrit
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|kdset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdset
operator|==
name|NULL
operator|||
name|kdset
operator|->
name|type
operator|!=
name|dns_rdatatype_keydata
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|kdset
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Scan the stored keys looking for ones that need 		 * removal or refreshing 		 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|kdset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|kdset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|kdset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|kd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Removal timer expired? */
if|if
condition|(
name|kd
operator|.
name|removehd
operator|!=
literal|0
operator|&&
name|kd
operator|.
name|removehd
operator|<
name|now
condition|)
block|{
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Acceptance timer expired? */
if|if
condition|(
name|kd
operator|.
name|addhd
operator|!=
literal|0
operator|&&
name|kd
operator|.
name|addhd
operator|<
name|now
condition|)
name|timer
operator|=
name|kd
operator|.
name|addhd
expr_stmt|;
comment|/* Or do we just need to refresh the keyset? */
if|if
condition|(
name|timer
operator|>
name|kd
operator|.
name|refresh
condition|)
name|timer
operator|=
name|kd
operator|.
name|refresh
expr_stmt|;
block|}
if|if
condition|(
name|timer
operator|>
name|now
condition|)
continue|continue;
name|kfetch
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_keyfetch_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfetch
operator|==
name|NULL
condition|)
block|{
name|fetch_err
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|zone
operator|->
name|refreshkeycount
operator|++
expr_stmt|;
name|kfetch
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
name|zone
operator|->
name|irefs
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|kfetch
operator|->
name|name
argument_list|)
expr_stmt|;
name|kname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|kfetch
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_name_dup
argument_list|(
name|name
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|kname
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|kdset
argument_list|,
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
expr_stmt|;
name|kfetch
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|kfetch
operator|->
name|db
argument_list|)
expr_stmt|;
name|kfetch
operator|->
name|fetch
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|zone
operator|->
name|view
operator|->
name|resolver
argument_list|,
name|kname
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DNS_FETCHOPT_NOVALIDATE
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|keyfetch_done
argument_list|,
name|kfetch
argument_list|,
operator|&
name|kfetch
operator|->
name|dnskeyset
argument_list|,
operator|&
name|kfetch
operator|->
name|dnskeysigset
argument_list|,
operator|&
name|kfetch
operator|->
name|fetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|fetching
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
block|{
name|zone
operator|->
name|refreshkeycount
operator|--
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|kfetch
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|kfetch
operator|->
name|keydataset
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
name|kname
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|kfetch
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_keyfetch_t
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"Failed to create fetch for "
literal|"DNSKEY update"
argument_list|)
expr_stmt|;
name|fetch_err
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|.
name|tuples
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
operator|&
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"zone_refreshkeys"
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|30
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|fetch_err
condition|)
block|{
comment|/* 		 * Error during a key fetch; retry in an hour. 		 */
name|isc_time_t
name|timenow
decl_stmt|,
name|timethen
decl_stmt|;
name|char
name|timebuf
index|[
literal|80
index|]
decl_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|timenow
argument_list|,
name|HOUR
argument_list|,
operator|&
name|timethen
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshkeytime
operator|=
name|timethen
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|isc_time_formattimestamp
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
name|timebuf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"retry key refresh: %s"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fetching
condition|)
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESHING
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
block|{
name|dns_rriterator_destroy
argument_list|(
operator|&
name|rrit
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_maintenance
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_maintenance"
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|dumping
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
comment|/* 	 * Are we pending load/reload? 	 */
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADPENDING
argument_list|)
condition|)
return|return;
comment|/* 	 * Configuring the view of this zone may have 	 * failed, for example because the config file 	 * had a syntax error.	In that case, the view 	 * adb or resolver will be NULL, and we had better not try 	 * to do further maintenance on it. 	 */
if|if
condition|(
name|zone
operator|->
name|view
operator|==
name|NULL
operator|||
name|zone
operator|->
name|view
operator|->
name|adb
operator|==
name|NULL
condition|)
return|return;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Expire check. 	 */
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_redirect
case|:
if|if
condition|(
name|zone
operator|->
name|masters
operator|==
name|NULL
condition|)
break|break;
case|case
name|dns_zone_slave
case|:
case|case
name|dns_zone_stub
case|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
operator|>=
literal|0
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
name|zone_expire
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshtime
operator|=
name|now
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Up to date check. 	 */
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_redirect
case|:
if|if
condition|(
name|zone
operator|->
name|masters
operator|==
name|NULL
condition|)
break|break;
case|case
name|dns_zone_slave
case|:
case|case
name|dns_zone_stub
case|:
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALREFRESH
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
operator|>=
literal|0
condition|)
name|dns_zone_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Slaves send notifies before backing up to disk, masters after. 	 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|notifytime
argument_list|)
operator|>=
literal|0
condition|)
name|zone_notify
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Do we need to consolidate the backing store? 	 */
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_master
case|:
case|case
name|dns_zone_slave
case|:
case|case
name|dns_zone_key
case|:
case|case
name|dns_zone_redirect
case|:
case|case
name|dns_zone_stub
case|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
operator|>=
literal|0
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
condition|)
block|{
name|dumping
operator|=
name|was_dumping
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
name|dumping
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumping
condition|)
block|{
name|result
operator|=
name|zone_dump
argument_list|(
name|zone
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* task locked */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"dump failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Master/redirect zones send notifies now, if needed 	 */
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_master
case|:
case|case
name|dns_zone_redirect
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|notifytime
argument_list|)
operator|>=
literal|0
condition|)
name|zone_notify
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
comment|/* 	 * Do we need to refresh keys? 	 */
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_key
case|:
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESHING
argument_list|)
condition|)
block|{
name|zone_refreshkeys
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|dns_zone_master
case|:
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
operator|>=
literal|0
condition|)
name|zone_rekey
argument_list|(
name|zone
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_master
case|:
case|case
name|dns_zone_redirect
case|:
case|case
name|dns_zone_slave
case|:
comment|/* 		 * Do we need to sign/resign some RRsets? 		 */
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|signingtime
argument_list|)
operator|>=
literal|0
condition|)
name|zone_sign
argument_list|(
name|zone
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|resigntime
argument_list|)
operator|>=
literal|0
condition|)
name|zone_resigninc
argument_list|(
name|zone
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|)
operator|>=
literal|0
condition|)
name|zone_nsec3chain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 		 * Do we need to issue a key expiry warning? 		 */
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|zone
operator|->
name|keywarntime
argument_list|)
operator|>=
literal|0
condition|)
name|set_key_expiry_warning
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|key_expiry
argument_list|,
name|isc_time_seconds
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_markdirty
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_uint32_t
name|serial
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Obtaining a lock on the zone->secure (see zone_send_secureserial) 	 * could result in a deadlock due to a LOR so we will spin if we 	 * can't obtain the both locks. 	 */
name|again
label|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
block|{
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|soacount
decl_stmt|;
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|INSIST
argument_list|(
name|secure
operator|!=
name|zone
argument_list|)
expr_stmt|;
name|TRYLOCK_ZONE
argument_list|(
name|result
argument_list|,
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|secure
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_thread_yield
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|serial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|DNS_R_NOTLOADED
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|soacount
operator|>
literal|0U
condition|)
name|zone_send_secureserial
argument_list|(
name|zone
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
comment|/* XXXMPA make separate call back */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|UNLOCK_ZONE
argument_list|(
name|secure
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_expire
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_expire
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_expire
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
comment|/* 	 * 'zone' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"expired"
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXPIRED
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refresh
operator|=
name|DNS_ZONE_DEFAULTREFRESH
expr_stmt|;
name|zone
operator|->
name|retry
operator|=
name|DNS_ZONE_DEFAULTRETRY
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
expr_stmt|;
name|zone_unload
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_refresh
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_interval_t
name|i
decl_stmt|;
name|isc_uint32_t
name|oldflags
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
return|return;
comment|/* 	 * Set DNS_ZONEFLG_REFRESH so that there is only one refresh operation 	 * in progress at a time. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|oldflags
operator|=
name|zone
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|masterscnt
operator|==
literal|0
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOMASTERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|DNS_ZONEFLG_NOMASTERS
operator|)
operator|==
literal|0
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"cannot refresh: no masters"
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
operator|(
name|DNS_ZONEFLG_REFRESH
operator||
name|DNS_ZONEFLG_LOADING
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * Set the next refresh time as if refresh check has failed. 	 * Setting this to the retry time will do that.  XXXMLG 	 * If we are successful it will be reset using zone->refresh. 	 */
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
name|isc_random_jitter
argument_list|(
name|zone
operator|->
name|retry
argument_list|,
name|zone
operator|->
name|retry
operator|/
literal|4
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|zone
operator|->
name|refreshtime
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"isc_time_nowplusinterval() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * When lacking user-specified timer values from the SOA, 	 * do exponential backoff of the retry time up to a 	 * maximum of six hours. 	 */
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
condition|)
name|zone
operator|->
name|retry
operator|=
name|ISC_MIN
argument_list|(
name|zone
operator|->
name|retry
operator|*
literal|2
argument_list|,
literal|6
operator|*
literal|3600
argument_list|)
expr_stmt|;
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zone
operator|->
name|masterscnt
condition|;
name|j
operator|++
control|)
name|zone
operator|->
name|mastersok
index|[
name|j
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* initiate soa query */
name|queue_soa_query
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_flush
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|dumping
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_ALREADYRUNNING
expr_stmt|;
name|dumping
operator|=
name|was_dumping
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
name|dumping
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumping
condition|)
name|result
operator|=
name|zone_dump
argument_list|(
name|zone
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* Unknown task. */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_dump
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_ALREADYRUNNING
decl_stmt|;
name|isc_boolean_t
name|dumping
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dumping
operator|=
name|was_dumping
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumping
condition|)
name|result
operator|=
name|zone_dump
argument_list|(
name|zone
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* Unknown task. */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_needdump
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|delay
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_needdump"
decl_stmt|;
name|isc_time_t
name|dumptime
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
comment|/* 	 * 'zone' locked by caller 	 */
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
comment|/* 	 * Do we have a place to dump to and are we loaded? 	 */
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|==
name|NULL
operator|||
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* add some noise */
name|DNS_ZONE_JITTER_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|delay
argument_list|,
operator|&
name|dumptime
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|,
operator|&
name|dumptime
argument_list|)
operator|>
literal|0
condition|)
name|zone
operator|->
name|dumptime
operator|=
name|dumptime
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_done
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"dump_done"
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|arg
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|isc_boolean_t
name|again
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|compact
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|zone
operator|->
name|journal
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|journalsize
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We don't own these, zone->dctx must stay valid. 		 */
name|db
operator|=
name|dns_dumpctx_db
argument_list|(
name|zone
operator|->
name|dctx
argument_list|)
expr_stmt|;
name|version
operator|=
name|dns_dumpctx_version
argument_list|(
name|zone
operator|->
name|dctx
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_db_getsoaserial
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|serial
argument_list|)
expr_stmt|;
comment|/* 		 * If there is a secure version of this zone 		 * use its serial if it is less than ours. 		 */
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|inline_raw
argument_list|(
name|zone
argument_list|)
operator|&&
name|zone
operator|->
name|secure
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|isc_uint32_t
name|sserial
decl_stmt|;
name|isc_result_t
name|mresult
decl_stmt|;
name|mresult
operator|=
name|dns_db_getsoaserial
argument_list|(
name|zone
operator|->
name|secure
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|sserial
argument_list|)
expr_stmt|;
if|if
condition|(
name|mresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|isc_serial_lt
argument_list|(
name|sserial
argument_list|,
name|serial
argument_list|)
condition|)
name|serial
operator|=
name|sserial
expr_stmt|;
block|}
comment|/* 		 * Note: we are task locked here so we can test 		 * zone->xfr safely. 		 */
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|zone
operator|->
name|xfr
operator|==
name|NULL
condition|)
block|{
name|tresult
operator|=
name|dns_journal_compact
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|serial
argument_list|,
name|zone
operator|->
name|journalsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tresult
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|ISC_R_NOSPACE
case|:
case|case
name|ISC_R_NOTFOUND
case|:
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"dns_journal_compact: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|tresult
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dns_journal_compact failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|tresult
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|compact
operator|=
name|ISC_TRUE
expr_stmt|;
name|zone
operator|->
name|compact_serial
operator|=
name|serial
expr_stmt|;
block|}
block|}
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
expr_stmt|;
if|if
condition|(
name|compact
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDCOMPACT
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_CANCELED
condition|)
block|{
comment|/* 		 * Try again in a short while. 		 */
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
expr_stmt|;
name|again
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|dctx
operator|!=
name|NULL
condition|)
name|dns_dumpctx_detach
argument_list|(
operator|&
name|zone
operator|->
name|dctx
argument_list|)
expr_stmt|;
name|zonemgr_putio
argument_list|(
operator|&
name|zone
operator|->
name|writeio
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
condition|)
operator|(
name|void
operator|)
name|zone_dump
argument_list|(
name|zone
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_dump
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|compact
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_dump"
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|again
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|masterfile
init|=
name|NULL
decl_stmt|;
name|dns_masterformat_t
name|masterformat
init|=
name|dns_masterformat_none
decl_stmt|;
comment|/*  * 'compact' MUST only be set if we are task locked.  */
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|redo
label|:
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
name|masterfile
operator|=
name|isc_mem_strdup
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|)
expr_stmt|;
name|masterformat
operator|=
name|zone
operator|->
name|masterformat
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|DNS_R_NOTLOADED
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|masterfile
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|DNS_R_NOMASTERFILE
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|compact
operator|&&
name|zone
operator|->
name|type
operator|!=
name|dns_zone_stub
condition|)
block|{
name|dns_zone_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|result
operator|=
name|zonemgr_getio
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
name|ISC_FALSE
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|zone_gotwritehandle
argument_list|,
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|writeio
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|zone_idetach
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|dns_master_style_t
modifier|*
name|output_style
decl_stmt|;
name|dns_masterrawheader_t
name|rawdata
decl_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|dns_master_initrawheader
argument_list|(
operator|&
name|rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|get_raw_serial
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
operator|&
name|rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
condition|)
name|output_style
operator|=
operator|&
name|dns_master_style_keyzone
expr_stmt|;
else|else
name|output_style
operator|=
operator|&
name|dns_master_style_default
expr_stmt|;
name|result
operator|=
name|dns_master_dump3
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|output_style
argument_list|,
name|masterfile
argument_list|,
name|masterformat
argument_list|,
operator|&
name|rawdata
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterfile
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|masterfile
argument_list|)
expr_stmt|;
name|masterfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_CONTINUE
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* XXXMPA */
name|again
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Try again in a short while. 		 */
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
expr_stmt|;
name|again
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
condition|)
goto|goto
name|redo
goto|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dumptostream
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|,
specifier|const
name|isc_uint32_t
name|rawversion
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_masterrawheader_t
name|rawdata
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_NOTLOADED
operator|)
return|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|dns_master_initrawheader
argument_list|(
operator|&
name|rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawversion
operator|==
literal|0
condition|)
name|rawdata
operator|.
name|flags
operator||=
name|DNS_MASTERRAW_COMPAT
expr_stmt|;
elseif|else
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|get_raw_serial
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
operator|&
name|rawdata
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zone
operator|->
name|sourceserialset
condition|)
block|{
name|rawdata
operator|.
name|flags
operator|=
name|DNS_MASTERRAW_SOURCESERIALSET
expr_stmt|;
name|rawdata
operator|.
name|sourceserial
operator|=
name|zone
operator|->
name|sourceserial
expr_stmt|;
block|}
name|result
operator|=
name|dns_master_dumptostream3
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|style
argument_list|,
name|format
argument_list|,
operator|&
name|rawdata
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_dumptostream3
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
specifier|const
name|isc_uint32_t
name|rawversion
parameter_list|)
block|{
return|return
operator|(
name|dumptostream
argument_list|(
name|zone
argument_list|,
name|fd
argument_list|,
name|style
argument_list|,
name|format
argument_list|,
name|rawversion
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_dumptostream2
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|)
block|{
return|return
operator|(
name|dumptostream
argument_list|(
name|zone
argument_list|,
name|fd
argument_list|,
name|style
argument_list|,
name|format
argument_list|,
name|DNS_RAWFORMAT_VERSION
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_dumptostream
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
return|return
operator|(
name|dumptostream
argument_list|(
name|zone
argument_list|,
name|fd
argument_list|,
operator|&
name|dns_master_style_default
argument_list|,
name|dns_masterformat_text
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_fulldumptostream
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
return|return
operator|(
name|dumptostream
argument_list|(
name|zone
argument_list|,
name|fd
argument_list|,
operator|&
name|dns_master_style_full
argument_list|,
name|dns_masterformat_text
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_unload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_unload
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_cancel
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|dns_notify_t
modifier|*
name|notify
decl_stmt|;
comment|/* 	 * 'zone' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|notify
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|notifies
argument_list|)
init|;
name|notify
operator|!=
name|NULL
condition|;
name|notify
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|notify
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|notify
operator|->
name|find
operator|!=
name|NULL
condition|)
name|dns_adb_cancelfind
argument_list|(
name|notify
operator|->
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|->
name|request
operator|!=
name|NULL
condition|)
name|dns_request_cancel
argument_list|(
name|notify
operator|->
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|forward_cancel
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|dns_forward_t
modifier|*
name|forward
decl_stmt|;
comment|/* 	 * 'zone' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|forward
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|forwards
argument_list|)
init|;
name|forward
operator|!=
name|NULL
condition|;
name|forward
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|forward
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|forward
operator|->
name|request
operator|!=
name|NULL
condition|)
name|dns_request_cancel
argument_list|(
name|forward
operator|->
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zone_unload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
comment|/* 	 * 'zone' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
operator|||
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|writeio
operator|!=
name|NULL
condition|)
name|zonemgr_cancelio
argument_list|(
name|zone
operator|->
name|writeio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|dctx
operator|!=
name|NULL
condition|)
name|dns_dumpctx_cancel
argument_list|(
name|zone
operator|->
name|dctx
argument_list|)
expr_stmt|;
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|zone_detachdb
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setminrefreshtime
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|val
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|val
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|minrefresh
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setmaxrefreshtime
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|val
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|val
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|maxrefresh
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setminretrytime
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|val
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|val
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|minretry
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setmaxretrytime
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|val
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|val
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|maxretry
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|notify_isqueued
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|)
block|{
name|dns_notify_t
modifier|*
name|notify
decl_stmt|;
for|for
control|(
name|notify
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|notifies
argument_list|)
init|;
name|notify
operator|!=
name|NULL
condition|;
name|notify
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|notify
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|notify
operator|->
name|request
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|dns_name_dynamic
argument_list|(
operator|&
name|notify
operator|->
name|ns
argument_list|)
operator|&&
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|notify
operator|->
name|ns
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|isc_sockaddr_equal
argument_list|(
name|addr
argument_list|,
operator|&
name|notify
operator|->
name|dst
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|notify_isself
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dst
parameter_list|)
block|{
name|dns_tsigkey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|isc_sockaddr_t
name|src
decl_stmt|;
name|isc_sockaddr_t
name|any
decl_stmt|;
name|isc_boolean_t
name|isself
decl_stmt|;
name|isc_netaddr_t
name|dstaddr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|==
name|NULL
operator|||
name|zone
operator|->
name|isself
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
name|dst
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
name|src
operator|=
name|zone
operator|->
name|notifysrc4
expr_stmt|;
name|isc_sockaddr_any
argument_list|(
operator|&
name|any
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|src
operator|=
name|zone
operator|->
name|notifysrc6
expr_stmt|;
name|isc_sockaddr_any6
argument_list|(
operator|&
name|any
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
comment|/* 	 * When sending from any the kernel will assign a source address 	 * that matches the destination address. 	 */
if|if
condition|(
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|any
argument_list|,
operator|&
name|src
argument_list|)
condition|)
name|src
operator|=
operator|*
name|dst
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|dstaddr
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_view_getpeertsig
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|dstaddr
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|isself
operator|=
call|(
name|zone
operator|->
name|isself
call|)
argument_list|(
name|zone
operator|->
name|view
argument_list|,
name|key
argument_list|,
operator|&
name|src
argument_list|,
name|dst
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|zone
operator|->
name|isselfarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|isself
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_destroy
parameter_list|(
name|dns_notify_t
modifier|*
name|notify
parameter_list|,
name|isc_boolean_t
name|locked
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 	 * Caller holds zone lock. 	 */
name|REQUIRE
argument_list|(
name|DNS_NOTIFY_VALID
argument_list|(
name|notify
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|->
name|zone
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|locked
condition|)
name|LOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|notify
argument_list|,
name|link
argument_list|)
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|notifies
argument_list|,
name|notify
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|UNLOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|zone_idetach
argument_list|(
operator|&
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
else|else
name|dns_zone_idetach
argument_list|(
operator|&
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notify
operator|->
name|find
operator|!=
name|NULL
condition|)
name|dns_adb_destroyfind
argument_list|(
operator|&
name|notify
operator|->
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|->
name|request
operator|!=
name|NULL
condition|)
name|dns_request_destroy
argument_list|(
operator|&
name|notify
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|notify
operator|->
name|ns
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|notify
operator|->
name|ns
argument_list|,
name|notify
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|->
name|key
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|notify
operator|->
name|key
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|notify
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|notify
operator|->
name|mctx
argument_list|,
name|notify
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|notify
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|notify_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|dns_notify_t
modifier|*
modifier|*
name|notifyp
parameter_list|)
block|{
name|dns_notify_t
modifier|*
name|notify
decl_stmt|;
name|REQUIRE
argument_list|(
name|notifyp
operator|!=
name|NULL
operator|&&
operator|*
name|notifyp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|notify
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|notify
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|notify
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|notify
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|notify
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|notify
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|notify
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
name|notify
operator|->
name|request
operator|=
name|NULL
expr_stmt|;
name|notify
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|isc_sockaddr_any
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|notify
operator|->
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|notify
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|notify
operator|->
name|magic
operator|=
name|NOTIFY_MAGIC
expr_stmt|;
operator|*
name|notifyp
operator|=
name|notify
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXXAG should check for DNS_ZONEFLG_EXITING  */
end_comment

begin_function
specifier|static
name|void
name|process_adb_event
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|dns_notify_t
modifier|*
name|notify
decl_stmt|;
name|isc_eventtype_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|notify
operator|=
name|ev
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_NOTIFY_VALID
argument_list|(
name|notify
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|notify
operator|->
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|result
operator|=
name|ev
operator|->
name|ev_type
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_EVENT_ADBMOREADDRESSES
condition|)
block|{
name|dns_adb_destroyfind
argument_list|(
operator|&
name|notify
operator|->
name|find
argument_list|)
expr_stmt|;
name|notify_find_address
argument_list|(
name|notify
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_EVENT_ADBNOMOREADDRESSES
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|notify_send
argument_list|(
name|notify
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
block|}
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_find_address
parameter_list|(
name|dns_notify_t
modifier|*
name|notify
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_NOTIFY_VALID
argument_list|(
name|notify
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|=
name|DNS_ADBFIND_WANTEVENT
operator||
name|DNS_ADBFIND_INET
operator||
name|DNS_ADBFIND_INET6
operator||
name|DNS_ADBFIND_RETURNLAME
expr_stmt|;
if|if
condition|(
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|adb
operator|==
name|NULL
condition|)
goto|goto
name|destroy
goto|;
name|result
operator|=
name|dns_adb_createfind
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|adb
argument_list|,
name|notify
operator|->
name|zone
operator|->
name|task
argument_list|,
name|process_adb_event
argument_list|,
name|notify
argument_list|,
operator|&
name|notify
operator|->
name|ns
argument_list|,
name|dns_rootname
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|dstport
argument_list|,
operator|&
name|notify
operator|->
name|find
argument_list|)
expr_stmt|;
comment|/* Something failed? */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|destroy
goto|;
comment|/* More addresses pending? */
if|if
condition|(
operator|(
name|notify
operator|->
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_WANTEVENT
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* We have as many addresses as we can get. */
name|LOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|notify_send
argument_list|(
name|notify
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|destroy
label|:
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|notify_send_queue
parameter_list|(
name|dns_notify_t
modifier|*
name|notify
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|notify
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_NOTIFYSENDTOADDR
argument_list|,
name|notify_send_toaddr
argument_list|,
name|notify
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|e
operator|->
name|ev_arg
operator|=
name|notify
expr_stmt|;
name|e
operator|->
name|ev_sender
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_enqueue
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|zmgr
operator|->
name|notifyrl
argument_list|,
name|notify
operator|->
name|zone
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_event_free
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_send_toaddr
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_notify_t
modifier|*
name|notify
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|dstip
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_t
name|src
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|isc_boolean_t
name|have_notifysource
init|=
name|ISC_FALSE
decl_stmt|;
name|notify
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_NOTIFY_VALID
argument_list|(
name|notify
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|(
name|event
operator|->
name|ev_attributes
operator|&
name|ISC_EVENTATTR_CANCELED
operator|)
operator|!=
literal|0
operator|||
name|DNS_ZONE_FLAG
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
operator|||
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|requestmgr
operator|==
name|NULL
operator|||
name|notify
operator|->
name|zone
operator|->
name|db
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * The raw IPv4 address should also exist.  Don't send to the 	 * mapped form. 	 */
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|)
operator|==
name|PF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|notify
operator|->
name|dst
operator|.
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|notify_log
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"notify: ignoring IPv6 mapped IPV4 address: %s"
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|notify_createmessage
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|notify
operator|->
name|flags
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|notify
operator|->
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* Transfer ownership of key */
name|key
operator|=
name|notify
operator|->
name|key
expr_stmt|;
name|notify
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|dstip
argument_list|,
operator|&
name|notify
operator|->
name|dst
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_view_getpeertsig
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|view
argument_list|,
operator|&
name|dstip
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|notify_log
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"NOTIFY to %s not sent. "
literal|"Peer TSIG key lookup failure."
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_message
goto|;
block|}
block|}
comment|/* XXX: should we log the tsig key too? */
name|notify_log
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"sending notify to %s"
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|peers
operator|!=
name|NULL
condition|)
block|{
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_peerlist_peerbyaddr
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|dstip
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_peer_getnotifysource
argument_list|(
name|peer
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_notifysource
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
if|if
condition|(
operator|!
name|have_notifysource
condition|)
name|src
operator|=
name|notify
operator|->
name|zone
operator|->
name|notifysrc4
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
if|if
condition|(
operator|!
name|have_notifysource
condition|)
name|src
operator|=
name|notify
operator|->
name|zone
operator|->
name|notifysrc6
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|cleanup_key
goto|;
block|}
name|timeout
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
argument_list|)
condition|)
name|timeout
operator|=
literal|30
expr_stmt|;
name|result
operator|=
name|dns_request_createvia2
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|view
operator|->
name|requestmgr
argument_list|,
name|message
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|notify
operator|->
name|dst
argument_list|,
literal|0
argument_list|,
name|key
argument_list|,
name|timeout
operator|*
literal|3
argument_list|,
name|timeout
argument_list|,
name|notify
operator|->
name|zone
operator|->
name|task
argument_list|,
name|notify_done
argument_list|,
name|notify
argument_list|,
operator|&
name|notify
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
name|inc_stats
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|dns_zonestatscounter_notifyoutv4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inc_stats
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|dns_zonestatscounter_notifyoutv6
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup_key
label|:
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|cleanup_message
label|:
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|UNLOCK_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_send
parameter_list|(
name|dns_notify_t
modifier|*
name|notify
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|ai
decl_stmt|;
name|isc_sockaddr_t
name|dst
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_notify_t
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Zone lock held by caller. 	 */
name|REQUIRE
argument_list|(
name|DNS_NOTIFY_VALID
argument_list|(
name|notify
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|notify
operator|->
name|zone
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|notify
operator|->
name|find
operator|->
name|list
argument_list|)
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ai
argument_list|,
name|publink
argument_list|)
control|)
block|{
name|dst
operator|=
name|ai
operator|->
name|sockaddr
expr_stmt|;
if|if
condition|(
name|notify_isqueued
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|notify_isself
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
operator|&
name|dst
argument_list|)
condition|)
continue|continue;
name|new
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|notify_create
argument_list|(
name|notify
operator|->
name|mctx
argument_list|,
operator|(
name|notify
operator|->
name|flags
operator|&
name|DNS_NOTIFY_NOSOA
operator|)
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|zone_iattach
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
operator|&
name|new
operator|->
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|new
operator|->
name|zone
operator|->
name|notifies
argument_list|,
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|new
operator|->
name|dst
operator|=
name|dst
expr_stmt|;
name|result
operator|=
name|notify_send_queue
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|new
operator|=
name|NULL
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
name|notify_destroy
argument_list|(
name|new
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_notify
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_notify
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|zonedb
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
init|=
name|NULL
decl_stmt|;
name|dns_name_t
name|master
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
name|nsrdset
decl_stmt|;
name|dns_rdataset_t
name|soardset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_notify_t
modifier|*
name|notify
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_sockaddr_t
name|dst
decl_stmt|;
name|isc_boolean_t
name|isqueued
decl_stmt|;
name|dns_notifytype_t
name|notifytype
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|loggednotify
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|notifytype
operator|=
name|zone
operator|->
name|notifytype
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
name|now
argument_list|,
name|zone
operator|->
name|notifydelay
argument_list|,
operator|&
name|zone
operator|->
name|notifytime
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
return|return;
if|if
condition|(
name|notifytype
operator|==
name|dns_notifytype_no
condition|)
return|return;
if|if
condition|(
name|notifytype
operator|==
name|dns_notifytype_masteronly
operator|&&
name|zone
operator|->
name|type
operator|!=
name|dns_zone_master
condition|)
return|return;
name|origin
operator|=
operator|&
name|zone
operator|->
name|origin
expr_stmt|;
comment|/* 	 * If the zone is dialup we are done as we don't want to send 	 * the current soa so as to force a refresh query. 	 */
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
argument_list|)
condition|)
name|flags
operator||=
name|DNS_NOTIFY_NOSOA
expr_stmt|;
comment|/* 	 * Get SOA RRset. 	 */
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|zonedb
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonedb
operator|==
name|NULL
condition|)
return|return;
name|dns_db_currentversion
argument_list|(
name|zonedb
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|zonedb
argument_list|,
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup1
goto|;
name|dns_rdataset_init
argument_list|(
operator|&
name|soardset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|zonedb
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|soardset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup2
goto|;
comment|/* 	 * Find serial and master server's name. 	 */
name|dns_name_init
argument_list|(
operator|&
name|master
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|soardset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup3
goto|;
name|dns_rdataset_current
argument_list|(
operator|&
name|soardset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|soa
operator|.
name|origin
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|master
argument_list|)
expr_stmt|;
name|serial
operator|=
name|soa
operator|.
name|serial
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|soardset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup3
goto|;
comment|/* 	 * Enqueue notify requests for 'also-notify' servers. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|notifycnt
condition|;
name|i
operator|++
control|)
block|{
name|dns_tsigkey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|dst
operator|=
name|zone
operator|->
name|notify
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|notify_isqueued
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
argument_list|)
condition|)
continue|continue;
name|result
operator|=
name|notify_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|flags
argument_list|,
operator|&
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|notify
operator|->
name|dst
operator|=
name|dst
expr_stmt|;
if|if
condition|(
operator|(
name|zone
operator|->
name|notifykeynames
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|zone
operator|->
name|notifykeynames
index|[
name|i
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dns_view_t
modifier|*
name|view
init|=
name|dns_zone_getview
argument_list|(
name|zone
argument_list|)
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
init|=
name|zone
operator|->
name|notifykeynames
index|[
name|i
index|]
decl_stmt|;
name|result
operator|=
name|dns_view_gettsig
argument_list|(
name|view
argument_list|,
name|keyname
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|notify
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ISC_LIST_APPEND
argument_list|(
name|zone
operator|->
name|notifies
argument_list|,
name|notify
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|notify_send_queue
argument_list|(
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loggednotify
condition|)
block|{
name|notify_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"sending notifies (serial %u)"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|loggednotify
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|notify
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|notifytype
operator|==
name|dns_notifytype_explicit
condition|)
goto|goto
name|cleanup3
goto|;
comment|/* 	 * Process NS RRset to generate notifies. 	 */
name|dns_rdataset_init
argument_list|(
operator|&
name|nsrdset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|zonedb
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|nsrdset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup3
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|nsrdset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|nsrdset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 		 * Don't notify the master server unless explicitly 		 * configured to do so. 		 */
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_NOTIFYTOSOA
argument_list|)
operator|&&
name|dns_name_compare
argument_list|(
operator|&
name|master
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|nsrdset
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|loggednotify
condition|)
block|{
name|notify_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"sending notifies (serial %u)"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|loggednotify
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|isqueued
operator|=
name|notify_isqueued
argument_list|(
name|zone
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|isqueued
condition|)
block|{
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|nsrdset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|=
name|notify_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|flags
argument_list|,
operator|&
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|dns_zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|notify
operator|->
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|notify
operator|->
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|zone
operator|->
name|notifies
argument_list|,
name|notify
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|notify_find_address
argument_list|(
name|notify
argument_list|)
expr_stmt|;
name|notify
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|nsrdset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsrdset
argument_list|)
expr_stmt|;
name|cleanup3
label|:
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|master
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|master
argument_list|,
name|zone
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|cleanup2
label|:
name|dns_db_detachnode
argument_list|(
name|zonedb
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|cleanup1
label|:
name|dns_db_closeversion
argument_list|(
name|zonedb
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|zonedb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***  *** Private  ***/
end_comment

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|save_nsrrset
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|nsrdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
comment|/* 	 * Extract NS RRset from message. 	 */
name|result
operator|=
name|dns_message_findname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Add NS rdataset. 	 */
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
name|nsrdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Add glue rdatasets. 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|nsrdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|nsrdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|nsrdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|fail
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stub_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"stub_callback"
decl_stmt|;
name|dns_requestevent_t
modifier|*
name|revent
init|=
operator|(
name|dns_requestevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|dns_stub_t
modifier|*
name|stub
init|=
name|NULL
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
name|char
name|master
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|source
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_uint32_t
name|nscnt
decl_stmt|,
name|cnamecnt
decl_stmt|,
name|refresh
decl_stmt|,
name|retry
decl_stmt|,
name|expire
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|isc_boolean_t
name|exiting
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_interval_t
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|,
name|soacount
decl_stmt|;
name|stub
operator|=
name|revent
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_STUB_VALID
argument_list|(
name|stub
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|zone
operator|=
name|stub
operator|->
name|zone
expr_stmt|;
name|ENTER
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"exiting"
argument_list|)
expr_stmt|;
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|isc_sockaddr_format
argument_list|(
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
name|master
argument_list|,
sizeof|sizeof
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|revent
operator|->
name|result
operator|==
name|ISC_R_TIMEDOUT
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"refreshing stub: timeout retrying "
literal|" without EDNS master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
name|dns_zonemgr_unreachableadd
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"could not refresh stub from master %s"
literal|" (source %s): %s"
argument_list|,
name|master
argument_list|,
name|source
argument_list|,
name|dns_result_totext
argument_list|(
name|revent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|result
operator|=
name|dns_message_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|next_master
goto|;
name|result
operator|=
name|dns_request_getresponse
argument_list|(
name|revent
operator|->
name|request
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|next_master
goto|;
comment|/* 	 * Unexpected rcode. 	 */
if|if
condition|(
name|msg
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
condition|)
block|{
name|char
name|rcode
index|[
literal|128
index|]
decl_stmt|;
name|isc_buffer_t
name|rb
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|rb
argument_list|,
name|rcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rcode_totext
argument_list|(
name|msg
operator|->
name|rcode
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
operator|&&
operator|(
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_servfail
operator|||
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_notimp
operator|||
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
operator|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"refreshing stub: rcode (%.*s) retrying "
literal|"without EDNS master %s (source %s)"
argument_list|,
operator|(
name|int
operator|)
name|rb
operator|.
name|used
argument_list|,
name|rcode
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: "
literal|"unexpected rcode (%.*s) from %s (source %s)"
argument_list|,
operator|(
name|int
operator|)
name|rb
operator|.
name|used
argument_list|,
name|rcode
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * We need complete messages. 	 */
if|if
condition|(
operator|(
name|msg
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dns_request_usedtcp
argument_list|(
name|revent
operator|->
name|request
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: truncated TCP "
literal|"response from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEVC
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
comment|/* 	 * If non-auth log and next master. 	 */
if|if
condition|(
operator|(
name|msg
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: "
literal|"non-authoritative answer from "
literal|"master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * Sanity checks. 	 */
name|cnamecnt
operator|=
name|message_count
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
name|dns_rdatatype_cname
argument_list|)
expr_stmt|;
name|nscnt
operator|=
name|message_count
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnamecnt
operator|!=
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: unexpected CNAME response "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
if|if
condition|(
name|nscnt
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: no NS records in response "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * Save answer. 	 */
name|result
operator|=
name|save_nsrrset
argument_list|(
name|msg
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|stub
operator|->
name|db
argument_list|,
name|stub
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: unable to save NS records "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * Tidy up. 	 */
name|dns_db_closeversion
argument_list|(
name|stub
operator|->
name|db
argument_list|,
operator|&
name|stub
operator|->
name|version
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|==
name|NULL
condition|)
name|zone_attachdb
argument_list|(
name|zone
argument_list|,
name|stub
operator|->
name|db
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
name|NULL
argument_list|,
operator|&
name|refresh
argument_list|,
operator|&
name|retry
argument_list|,
operator|&
name|expire
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|soacount
operator|>
literal|0U
condition|)
block|{
name|zone
operator|->
name|refresh
operator|=
name|RANGE
argument_list|(
name|refresh
argument_list|,
name|zone
operator|->
name|minrefresh
argument_list|,
name|zone
operator|->
name|maxrefresh
argument_list|)
expr_stmt|;
name|zone
operator|->
name|retry
operator|=
name|RANGE
argument_list|(
name|retry
argument_list|,
name|zone
operator|->
name|minretry
argument_list|,
name|zone
operator|->
name|maxretry
argument_list|)
expr_stmt|;
name|zone
operator|->
name|expire
operator|=
name|RANGE
argument_list|(
name|expire
argument_list|,
name|zone
operator|->
name|refresh
operator|+
name|zone
operator|->
name|retry
argument_list|,
name|DNS_MAX_EXPIRE
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
expr_stmt|;
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|stub
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|DNS_ZONE_JITTER_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|refresh
argument_list|,
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
expr_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|i
argument_list|,
name|zone
operator|->
name|expire
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|expire
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
goto|goto
name|free_stub
goto|;
name|next_master
label|:
if|if
condition|(
name|stub
operator|->
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|stub
operator|->
name|db
argument_list|,
operator|&
name|stub
operator|->
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|stub
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Skip to next failed / untried master. 	 */
do|do
block|{
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
do|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
if|if
condition|(
name|exiting
operator|||
name|zone
operator|->
name|curmaster
operator|>=
name|zone
operator|->
name|masterscnt
condition|)
block|{
name|isc_boolean_t
name|done
init|=
name|ISC_TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|exiting
operator|&&
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_USEALTXFRSRC
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
block|{
comment|/* 			 * Did we get a good answer from all the masters? 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zone
operator|->
name|masterscnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|zone
operator|->
name|mastersok
index|[
name|j
index|]
operator|==
name|ISC_FALSE
condition|)
block|{
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Find the next failed master. 			 */
while|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
goto|goto
name|free_stub
goto|;
block|}
block|}
name|queue_soa_query
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|free_stub
goto|;
name|same_master
label|:
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
name|ns_query
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
name|free_stub
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|stub
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|stub
operator|->
name|zone
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|stub
operator|->
name|db
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|stub
operator|->
name|version
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|stub
operator|->
name|mctx
argument_list|,
name|stub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stub
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|INSIST
argument_list|(
name|event
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * An SOA query has finished (successfully or not).  */
end_comment

begin_function
specifier|static
name|void
name|refresh_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"refresh_callback"
decl_stmt|;
name|dns_requestevent_t
modifier|*
name|revent
init|=
operator|(
name|dns_requestevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|soacnt
decl_stmt|,
name|cnamecnt
decl_stmt|,
name|soacount
decl_stmt|,
name|nscount
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|char
name|master
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|source
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|,
name|oldserial
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|isc_boolean_t
name|do_queue_xfrin
init|=
name|ISC_FALSE
decl_stmt|;
name|zone
operator|=
name|revent
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
comment|/* 	 * if timeout log and next master; 	 */
name|isc_sockaddr_format
argument_list|(
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
name|master
argument_list|,
sizeof|sizeof
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|revent
operator|->
name|result
operator|==
name|ISC_R_TIMEDOUT
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"refresh: timeout retrying without EDNS "
literal|"master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
if|if
condition|(
name|revent
operator|->
name|result
operator|==
name|ISC_R_TIMEDOUT
operator|&&
operator|!
name|dns_request_usedtcp
argument_list|(
name|revent
operator|->
name|request
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: retry limit for "
literal|"master %s exceeded (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* Try with slave with TCP. */
if|if
condition|(
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|)
operator|&&
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_TRYTCPREFRESH
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dns_zonemgr_unreachable
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SOABEFOREAXFR
argument_list|)
expr_stmt|;
goto|goto
name|tcp_transfer
goto|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"refresh: skipped tcp fallback "
literal|"as master %s (source %s) is "
literal|"unreachable (cached)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: failure trying master "
literal|"%s (source %s): %s"
argument_list|,
name|master
argument_list|,
name|source
argument_list|,
name|dns_result_totext
argument_list|(
name|revent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|result
operator|=
name|dns_message_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|next_master
goto|;
name|result
operator|=
name|dns_request_getresponse
argument_list|(
name|revent
operator|->
name|request
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: failure trying master "
literal|"%s (source %s): %s"
argument_list|,
name|master
argument_list|,
name|source
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * Unexpected rcode. 	 */
if|if
condition|(
name|msg
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
condition|)
block|{
name|char
name|rcode
index|[
literal|128
index|]
decl_stmt|;
name|isc_buffer_t
name|rb
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|rb
argument_list|,
name|rcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rcode_totext
argument_list|(
name|msg
operator|->
name|rcode
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
operator|&&
operator|(
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_servfail
operator|||
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_notimp
operator|||
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
operator|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"refresh: rcode (%.*s) retrying without "
literal|"EDNS master %s (source %s)"
argument_list|,
operator|(
name|int
operator|)
name|rb
operator|.
name|used
argument_list|,
name|rcode
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: unexpected rcode (%.*s) from "
literal|"master %s (source %s)"
argument_list|,
operator|(
name|int
operator|)
name|rb
operator|.
name|used
argument_list|,
name|rcode
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* 		 * Perhaps AXFR/IXFR is allowed even if SOA queries aren't. 		 */
if|if
condition|(
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_refused
operator|&&
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|)
condition|)
goto|goto
name|tcp_transfer
goto|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * If truncated punt to zone transfer which will query again. 	 */
if|if
condition|(
operator|(
name|msg
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: truncated UDP answer, "
literal|"initiating TCP zone xfer "
literal|"for master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SOABEFOREAXFR
argument_list|)
expr_stmt|;
goto|goto
name|tcp_transfer
goto|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_request_usedtcp
argument_list|(
name|revent
operator|->
name|request
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: truncated TCP response "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEVC
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
block|}
comment|/* 	 * if non-auth log and next master; 	 */
if|if
condition|(
operator|(
name|msg
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: non-authoritative answer from "
literal|"master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|cnamecnt
operator|=
name|message_count
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
name|dns_rdatatype_cname
argument_list|)
expr_stmt|;
name|soacnt
operator|=
name|message_count
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
name|dns_rdatatype_soa
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|message_count
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
name|soacount
operator|=
name|message_count
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
name|dns_rdatatype_soa
argument_list|)
expr_stmt|;
comment|/* 	 * There should not be a CNAME record at top of zone. 	 */
if|if
condition|(
name|cnamecnt
operator|!=
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: CNAME at top of zone "
literal|"in master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * if referral log and next master; 	 */
if|if
condition|(
name|soacnt
operator|==
literal|0
operator|&&
name|soacount
operator|==
literal|0
operator|&&
name|nscount
operator|!=
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: referral response "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * if nodata log and next master; 	 */
if|if
condition|(
name|soacnt
operator|==
literal|0
operator|&&
operator|(
name|nscount
operator|==
literal|0
operator|||
name|soacount
operator|!=
literal|0
operator|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: NODATA response "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * Only one soa at top of zone. 	 */
if|if
condition|(
name|soacnt
operator|!=
literal|1
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: answer SOA count (%d) != 1 "
literal|"from master %s (source %s)"
argument_list|,
name|soacnt
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* 	 * Extract serial 	 */
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: unable to get SOA record "
literal|"from master %s (source %s)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: dns_rdataset_first() failed"
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|serial
operator|=
name|soa
operator|.
name|serial
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|soacount
decl_stmt|;
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|oldserial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|soacount
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"serial: new %u, old %u"
argument_list|,
name|serial
argument_list|,
name|oldserial
argument_list|)
expr_stmt|;
block|}
else|else
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"serial: new %u, old not loaded"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|||
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
operator|||
name|isc_serial_gt
argument_list|(
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
block|{
if|if
condition|(
name|dns_zonemgr_unreachable
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refresh: skipping %s as master %s "
literal|"(source %s) is unreachable (cached)"
argument_list|,
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|)
condition|?
literal|"zone transfer"
else|:
literal|"NS query"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|tcp_transfer
label|:
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
condition|)
block|{
name|do_queue_xfrin
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_stub
argument_list|)
expr_stmt|;
name|ns_query
argument_list|(
name|zone
argument_list|,
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isc_serial_eq
argument_list|(
name|soa
operator|.
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|journal
operator|!=
name|NULL
condition|)
name|result
operator|=
name|isc_file_settime
argument_list|(
name|zone
operator|->
name|journal
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
condition|)
block|{
name|result
operator|=
name|isc_file_settime
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|isc_file_settime
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Someone removed the file from underneath us! */
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
block|{
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"refresh: could not set file "
literal|"modification time of '%s': %s"
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DNS_ZONE_JITTER_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|refresh
argument_list|,
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|expire
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_MULTIMASTER
argument_list|)
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"serial number (%u) "
literal|"received from master %s< ours (%u)"
argument_list|,
name|soa
operator|.
name|serial
argument_list|,
name|master
argument_list|,
name|oldserial
argument_list|)
expr_stmt|;
else|else
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"ahead"
argument_list|)
expr_stmt|;
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
name|next_master
label|:
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Skip to next failed / untried master. 	 */
do|do
block|{
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
do|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|curmaster
operator|>=
name|zone
operator|->
name|masterscnt
condition|)
block|{
name|isc_boolean_t
name|done
init|=
name|ISC_TRUE
decl_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_USEALTXFRSRC
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
block|{
comment|/* 			 * Did we get a good answer from all the masters? 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zone
operator|->
name|masterscnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|zone
operator|->
name|mastersok
index|[
name|j
index|]
operator|==
name|ISC_FALSE
condition|)
block|{
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
expr_stmt|;
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Find the next failed master. 			 */
while|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
goto|goto
name|requeue
goto|;
block|}
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDREFRESH
argument_list|)
condition|)
block|{
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDREFRESH
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshtime
operator|=
name|now
expr_stmt|;
block|}
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|requeue
label|:
name|queue_soa_query
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
name|same_master
label|:
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
name|queue_soa_query
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|detach
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_queue_xfrin
condition|)
name|queue_xfrin
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_soa_query
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"queue_soa_query"
decl_stmt|;
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|dns_zone_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|ENTER
expr_stmt|;
comment|/* 	 * Locked by caller 	 */
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|cancel_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return;
block|}
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_ZONE
argument_list|,
name|soa_query
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|cancel_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Attach so that we won't clean up 	 * until the event is delivered. 	 */
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|e
operator|->
name|ev_arg
operator|=
name|zone
expr_stmt|;
name|e
operator|->
name|ev_sender
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_enqueue
argument_list|(
name|zone
operator|->
name|zmgr
operator|->
name|refreshrl
argument_list|,
name|zone
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|zone_idetach
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|cancel_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|create_query
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdatatype_t
name|rdtype
parameter_list|,
name|dns_message_t
modifier|*
modifier|*
name|messagep
parameter_list|)
block|{
name|dns_message_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|qname
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|qrdataset
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|message
operator|->
name|opcode
operator|=
name|dns_opcode_query
expr_stmt|;
name|message
operator|->
name|rdclass
operator|=
name|zone
operator|->
name|rdclass
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|message
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Make question. 	 */
name|dns_name_init
argument_list|(
name|qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|qrdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_makequestion
argument_list|(
name|qrdataset
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|rdtype
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qname
operator|->
name|list
argument_list|,
name|qrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|message
argument_list|,
name|qname
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
operator|*
name|messagep
operator|=
name|message
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|message
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qrdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_opt
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|isc_uint16_t
name|udpsize
parameter_list|,
name|isc_boolean_t
name|reqnsid
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_ednsopt_t
name|ednsopts
index|[
name|DNS_EDNSOPTIONS
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Set EDNS options if applicable */
if|if
condition|(
name|reqnsid
condition|)
block|{
name|INSIST
argument_list|(
name|count
operator|<
name|DNS_EDNSOPTIONS
argument_list|)
expr_stmt|;
name|ednsopts
index|[
name|count
index|]
operator|.
name|code
operator|=
name|DNS_OPT_NSID
expr_stmt|;
name|ednsopts
index|[
name|count
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|ednsopts
index|[
name|count
index|]
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_buildopt
argument_list|(
name|message
argument_list|,
operator|&
name|rdataset
argument_list|,
literal|0
argument_list|,
name|udpsize
argument_list|,
literal|0
argument_list|,
name|ednsopts
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
return|return
operator|(
name|dns_message_setopt
argument_list|(
name|message
argument_list|,
name|rdataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|soa_query
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"soa_query"
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|dns_zone_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|masterip
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|options
decl_stmt|;
name|isc_boolean_t
name|cancel
init|=
name|ISC_TRUE
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|isc_boolean_t
name|have_xfrsource
decl_stmt|,
name|reqnsid
decl_stmt|;
name|isc_uint16_t
name|udpsize
init|=
name|SEND_BUFFER_SIZE
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|event
operator|->
name|ev_attributes
operator|&
name|ISC_EVENTATTR_CANCELED
operator|)
operator|!=
literal|0
operator|)
operator|||
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
operator|||
name|zone
operator|->
name|view
operator|->
name|requestmgr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
name|cancel
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * XXX Optimisation: Create message when zone is setup and reuse. 	 */
name|result
operator|=
name|create_query
argument_list|(
name|zone
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|again
label|:
name|INSIST
argument_list|(
name|zone
operator|->
name|masterscnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
argument_list|)
expr_stmt|;
name|zone
operator|->
name|masteraddr
operator|=
name|zone
operator|->
name|masters
index|[
name|zone
operator|->
name|curmaster
index|]
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|masterip
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
expr_stmt|;
comment|/* 	 * First, look for a tsig key in the master statement, then 	 * try for a server key. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|masterkeynames
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|zone
operator|->
name|masterkeynames
index|[
name|zone
operator|->
name|curmaster
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dns_view_t
modifier|*
name|view
init|=
name|dns_zone_getview
argument_list|(
name|zone
argument_list|)
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
init|=
name|zone
operator|->
name|masterkeynames
index|[
name|zone
operator|->
name|curmaster
index|]
decl_stmt|;
name|result
operator|=
name|dns_view_gettsig
argument_list|(
name|view
argument_list|,
name|keyname
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|keyname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unable to find key: %s"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
goto|goto
name|skip_master
goto|;
block|}
block|}
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_view_getpeertsig
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|char
name|addrbuf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|masterip
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unable to find TSIG key for %s"
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
goto|goto
name|skip_master
goto|;
block|}
block|}
name|have_xfrsource
operator|=
name|ISC_FALSE
expr_stmt|;
name|reqnsid
operator|=
name|zone
operator|->
name|view
operator|->
name|requestnsid
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|->
name|peers
operator|!=
name|NULL
condition|)
block|{
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|edns
decl_stmt|;
name|result
operator|=
name|dns_peerlist_peerbyaddr
argument_list|(
name|zone
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_peer_getsupportedns
argument_list|(
name|peer
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|edns
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_peer_gettransfersource
argument_list|(
name|peer
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_xfrsource
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|->
name|resolver
operator|!=
name|NULL
condition|)
name|udpsize
operator|=
name|dns_resolver_getudpsize
argument_list|(
name|zone
operator|->
name|view
operator|->
name|resolver
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peer_getudpsize
argument_list|(
name|peer
argument_list|,
operator|&
name|udpsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peer_getrequestnsid
argument_list|(
name|peer
argument_list|,
operator|&
name|reqnsid
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zone
operator|->
name|altxfrsource4
argument_list|,
operator|&
name|zone
operator|->
name|xfrsource4
argument_list|)
condition|)
goto|goto
name|skip_master
goto|;
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|altxfrsource4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|have_xfrsource
condition|)
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|xfrsource4
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zone
operator|->
name|altxfrsource6
argument_list|,
operator|&
name|zone
operator|->
name|xfrsource6
argument_list|)
condition|)
goto|goto
name|skip_master
goto|;
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|altxfrsource6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|have_xfrsource
condition|)
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|xfrsource6
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|options
operator|=
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEVC
argument_list|)
condition|?
name|DNS_REQUESTOPT_TCP
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
condition|)
block|{
name|result
operator|=
name|add_opt
argument_list|(
name|message
argument_list|,
name|udpsize
argument_list|,
name|reqnsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"unable to add opt record: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALREFRESH
argument_list|)
condition|)
name|timeout
operator|=
literal|30
expr_stmt|;
name|result
operator|=
name|dns_request_createvia2
argument_list|(
name|zone
operator|->
name|view
operator|->
name|requestmgr
argument_list|,
name|message
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
name|options
argument_list|,
name|key
argument_list|,
name|timeout
operator|*
literal|3
argument_list|,
name|timeout
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|refresh_callback
argument_list|,
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|zone_idetach
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"dns_request_createvia2() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
operator|==
name|PF_INET
condition|)
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_soaoutv4
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_soaoutv6
argument_list|)
expr_stmt|;
block|}
name|cancel
operator|=
name|ISC_FALSE
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel
condition|)
name|cancel_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
return|return;
name|skip_master
label|:
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * Skip to next failed / untried master. 	 */
do|do
block|{
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
do|;
if|if
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
condition|)
goto|goto
name|again
goto|;
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_query
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdataset_t
modifier|*
name|soardataset
parameter_list|,
name|dns_stub_t
modifier|*
name|stub
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"ns_query"
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|masterip
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|isc_boolean_t
name|have_xfrsource
init|=
name|ISC_FALSE
decl_stmt|,
name|reqnsid
decl_stmt|;
name|isc_uint16_t
name|udpsize
init|=
name|SEND_BUFFER_SIZE
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|soardataset
operator|!=
name|NULL
operator|&&
name|stub
operator|==
name|NULL
operator|)
operator|||
operator|(
name|soardataset
operator|==
name|NULL
operator|&&
name|stub
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|stub
operator|==
name|NULL
operator|||
name|DNS_STUB_VALID
argument_list|(
name|stub
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
if|if
condition|(
name|stub
operator|==
name|NULL
condition|)
block|{
name|stub
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|stub
operator|->
name|magic
operator|=
name|STUB_MAGIC
expr_stmt|;
name|stub
operator|->
name|mctx
operator|=
name|zone
operator|->
name|mctx
expr_stmt|;
name|stub
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|stub
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|stub
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Attach so that the zone won't disappear from under us. 		 */
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|stub
operator|->
name|zone
argument_list|)
expr_stmt|;
comment|/* 		 * If a db exists we will update it, otherwise we create a 		 * new one and attach it to the zone once we have the NS 		 * RRset and glue. 		 */
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|stub
operator|->
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|db_argc
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_dbtype_stub
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|zone
operator|->
name|db_argc
operator|-
literal|1
argument_list|,
name|zone
operator|->
name|db_argv
operator|+
literal|1
argument_list|,
operator|&
name|stub
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"refreshing stub: "
literal|"could not create "
literal|"database: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_db_settask
argument_list|(
name|stub
operator|->
name|db
argument_list|,
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|stub
operator|->
name|db
argument_list|,
operator|&
name|stub
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: "
literal|"dns_db_newversion() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Update SOA record. 		 */
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|stub
operator|->
name|db
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: "
literal|"dns_db_findnode() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|stub
operator|->
name|db
argument_list|,
name|node
argument_list|,
name|stub
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|soardataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|stub
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refreshing stub: "
literal|"dns_db_addrdataset() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * XXX Optimisation: Create message when zone is setup and reuse. 	 */
name|result
operator|=
name|create_query
argument_list|(
name|zone
argument_list|,
name|dns_rdatatype_ns
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|masterscnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
argument_list|)
expr_stmt|;
name|zone
operator|->
name|masteraddr
operator|=
name|zone
operator|->
name|masters
index|[
name|zone
operator|->
name|curmaster
index|]
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|masterip
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
expr_stmt|;
comment|/* 	 * First, look for a tsig key in the master statement, then 	 * try for a server key. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|masterkeynames
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|zone
operator|->
name|masterkeynames
index|[
name|zone
operator|->
name|curmaster
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dns_view_t
modifier|*
name|view
init|=
name|dns_zone_getview
argument_list|(
name|zone
argument_list|)
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
init|=
name|zone
operator|->
name|masterkeynames
index|[
name|zone
operator|->
name|curmaster
index|]
decl_stmt|;
name|result
operator|=
name|dns_view_gettsig
argument_list|(
name|view
argument_list|,
name|keyname
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|keyname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unable to find key: %s"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_view_getpeertsig
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|reqnsid
operator|=
name|zone
operator|->
name|view
operator|->
name|requestnsid
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|->
name|peers
operator|!=
name|NULL
condition|)
block|{
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|edns
decl_stmt|;
name|result
operator|=
name|dns_peerlist_peerbyaddr
argument_list|(
name|zone
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_peer_getsupportedns
argument_list|(
name|peer
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|edns
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_peer_gettransfersource
argument_list|(
name|peer
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_xfrsource
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|->
name|resolver
operator|!=
name|NULL
condition|)
name|udpsize
operator|=
name|dns_resolver_getudpsize
argument_list|(
name|zone
operator|->
name|view
operator|->
name|resolver
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peer_getudpsize
argument_list|(
name|peer
argument_list|,
operator|&
name|udpsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peer_getrequestnsid
argument_list|(
name|peer
argument_list|,
operator|&
name|reqnsid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOEDNS
argument_list|)
condition|)
block|{
name|result
operator|=
name|add_opt
argument_list|(
name|message
argument_list|,
name|udpsize
argument_list|,
name|reqnsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"unable to add opt record: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Always use TCP so that we shouldn't truncate in additional section. 	 */
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|altxfrsource4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|have_xfrsource
condition|)
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|xfrsource4
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|altxfrsource6
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|have_xfrsource
condition|)
name|zone
operator|->
name|sourceaddr
operator|=
name|zone
operator|->
name|xfrsource6
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
name|POST
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|timeout
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALREFRESH
argument_list|)
condition|)
name|timeout
operator|=
literal|30
expr_stmt|;
name|result
operator|=
name|dns_request_createvia2
argument_list|(
name|zone
operator|->
name|view
operator|->
name|requestmgr
argument_list|,
name|message
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
name|DNS_REQUESTOPT_TCP
argument_list|,
name|key
argument_list|,
name|timeout
operator|*
literal|3
argument_list|,
name|timeout
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|stub_callback
argument_list|,
name|stub
argument_list|,
operator|&
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|1
argument_list|,
literal|"dns_request_createvia() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
name|cleanup
label|:
name|cancel_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|!=
name|NULL
condition|)
block|{
name|stub
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stub
operator|->
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|stub
operator|->
name|db
argument_list|,
operator|&
name|stub
operator|->
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|stub
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|->
name|zone
operator|!=
name|NULL
condition|)
name|zone_idetach
argument_list|(
operator|&
name|stub
operator|->
name|zone
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|stub
operator|->
name|mctx
argument_list|,
name|stub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stub
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
name|unlock
label|:
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Handle the control event.  Note that although this event causes the zone  * to shut down, it is not a shutdown event in the sense of the task library.  */
end_comment

begin_function
specifier|static
name|void
name|zone_shutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
init|=
operator|(
name|dns_zone_t
operator|*
operator|)
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|free_needed
decl_stmt|,
name|linked
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_zone_t
modifier|*
name|raw
init|=
name|NULL
decl_stmt|,
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_ZONECONTROL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|isc_refcount_current
argument_list|(
operator|&
name|zone
operator|->
name|erefs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
literal|"zone_shutdown"
argument_list|,
literal|3
argument_list|,
literal|"shutting down"
argument_list|)
expr_stmt|;
comment|/* 	 * Stop things being restarted after we cancel them below. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * If we were waiting for xfrin quota, step out of 	 * the queue. 	 * If there's no zone manager, we can't be waiting for the 	 * xfrin quota 	 */
if|if
condition|(
name|zone
operator|->
name|zmgr
operator|!=
name|NULL
condition|)
block|{
name|RWLOCK
argument_list|(
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|statelist
operator|==
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|waiting_for_xfrin
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|,
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|linked
operator|=
name|ISC_TRUE
expr_stmt|;
name|zone
operator|->
name|statelist
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|statelist
operator|==
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|xfrin_in_progress
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|zmgr
operator|->
name|xfrin_in_progress
argument_list|,
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|zone
operator|->
name|statelist
operator|=
name|NULL
expr_stmt|;
name|zmgr_resume_xfrs
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In task context, no locking required.  See zone_xfrdone(). 	 */
if|if
condition|(
name|zone
operator|->
name|xfr
operator|!=
name|NULL
condition|)
name|dns_xfrin_shutdown
argument_list|(
name|zone
operator|->
name|xfr
argument_list|)
expr_stmt|;
comment|/* Safe to release the zone now */
if|if
condition|(
name|zone
operator|->
name|zmgr
operator|!=
name|NULL
condition|)
name|dns_zonemgr_releasezone
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|linked
condition|)
block|{
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|request
operator|!=
name|NULL
condition|)
block|{
name|dns_request_cancel
argument_list|(
name|zone
operator|->
name|request
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|readio
operator|!=
name|NULL
condition|)
name|zonemgr_cancelio
argument_list|(
name|zone
operator|->
name|readio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|lctx
operator|!=
name|NULL
condition|)
name|dns_loadctx_cancel
argument_list|(
name|zone
operator|->
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FLUSH
argument_list|)
operator|||
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|writeio
operator|!=
name|NULL
condition|)
name|zonemgr_cancelio
argument_list|(
name|zone
operator|->
name|writeio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|dctx
operator|!=
name|NULL
condition|)
name|dns_dumpctx_cancel
argument_list|(
name|zone
operator|->
name|dctx
argument_list|)
expr_stmt|;
block|}
name|notify_cancel
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|forward_cancel
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|timer
operator|!=
name|NULL
condition|)
block|{
name|isc_timer_detach
argument_list|(
operator|&
name|zone
operator|->
name|timer
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|view
operator|!=
name|NULL
condition|)
name|dns_view_weakdetach
argument_list|(
operator|&
name|zone
operator|->
name|view
argument_list|)
expr_stmt|;
comment|/* 	 * We have now canceled everything set the flag to allow exit_check() 	 * to succeed.	We must not unlock between setting this flag and 	 * calling exit_check(). 	 */
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SHUTDOWN
argument_list|)
expr_stmt|;
name|free_needed
operator|=
name|exit_check
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|raw
operator|=
name|zone
operator|->
name|raw
expr_stmt|;
name|zone
operator|->
name|raw
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|zone
operator|->
name|secure
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|raw
argument_list|)
expr_stmt|;
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|dns_zone_idetach
argument_list|(
operator|&
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_needed
condition|)
name|zone_free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_timer
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_timer"
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
operator|(
name|dns_zone_t
operator|*
operator|)
name|event
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|zone_maintenance
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_settimer
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"zone_settimer"
decl_stmt|;
name|isc_time_t
name|next
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|ENTER
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
return|return;
name|isc_time_settoepoch
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_redirect
case|:
if|if
condition|(
name|zone
operator|->
name|masters
operator|!=
name|NULL
condition|)
goto|goto
name|treat_as_slave
goto|;
comment|/* FALLTHROUGH */
case|case
name|dns_zone_master
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
condition|)
name|next
operator|=
name|zone
operator|->
name|notifytime
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|dumptime
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
condition|)
break|break;
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESHING
argument_list|)
operator|&&
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|refreshkeytime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|resigntime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|resigntime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|keywarntime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|keywarntime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|signingtime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|nsec3chaintime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|nsec3chaintime
expr_stmt|;
block|}
break|break;
case|case
name|dns_zone_slave
case|:
name|treat_as_slave
label|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
condition|)
name|next
operator|=
name|zone
operator|->
name|notifytime
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|dns_zone_stub
case|:
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOMASTERS
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOREFRESH
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADING
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|refreshtime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|refreshtime
expr_stmt|;
block|}
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|&&
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|expiretime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|expiretime
expr_stmt|;
block|}
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|dumptime
expr_stmt|;
block|}
break|break;
case|case
name|dns_zone_key
case|:
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDDUMP
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DUMPING
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|dumptime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
condition|)
name|next
operator|=
name|zone
operator|->
name|dumptime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESHING
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
operator|||
operator|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
operator|&
name|next
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|next
operator|=
name|zone
operator|->
name|refreshkeytime
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|next
argument_list|)
condition|)
block|{
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
name|me
argument_list|,
literal|10
argument_list|,
literal|"settimer inactive"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|zone
operator|->
name|timer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"could not deactivate zone timer: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|next
argument_list|,
name|now
argument_list|)
operator|<=
literal|0
condition|)
name|next
operator|=
operator|*
name|now
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|zone
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"could not reset zone timer: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cancel_refresh
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"cancel_refresh"
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
comment|/* 	 * 'zone' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|notify_createmessage
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|dns_message_t
modifier|*
modifier|*
name|messagep
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|zonedb
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_name_t
modifier|*
name|tempname
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
modifier|*
name|temprdata
init|=
name|NULL
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|temprdatalist
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|temprdataset
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|messagep
operator|!=
name|NULL
operator|&&
operator|*
name|messagep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|message
operator|->
name|opcode
operator|=
name|dns_opcode_notify
expr_stmt|;
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
name|message
operator|->
name|rdclass
operator|=
name|zone
operator|->
name|rdclass
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|message
argument_list|,
operator|&
name|tempname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|temprdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Make question. 	 */
name|dns_name_init
argument_list|(
name|tempname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|temprdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_makequestion
argument_list|(
name|temprdataset
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_soa
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|tempname
operator|->
name|list
argument_list|,
name|temprdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|message
argument_list|,
name|tempname
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
name|tempname
operator|=
name|NULL
expr_stmt|;
name|temprdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_NOTIFY_NOSOA
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|message
argument_list|,
operator|&
name|tempname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|message
argument_list|,
operator|&
name|temprdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|temprdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|message
argument_list|,
operator|&
name|temprdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXXJT: is this assumption correct? */
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|zonedb
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|tempname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|zonedb
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|zonedb
argument_list|,
name|tempname
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|zonedb
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_toregion
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|isc_buffer_putmem
argument_list|(
name|b
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
name|temprdata
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|temprdata
argument_list|,
name|rdata
operator|.
name|rdclass
argument_list|,
name|rdata
operator|.
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_message_takebuffer
argument_list|(
name|message
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|soa_cleanup
goto|;
name|temprdatalist
operator|->
name|rdclass
operator|=
name|rdata
operator|.
name|rdclass
expr_stmt|;
name|temprdatalist
operator|->
name|type
operator|=
name|rdata
operator|.
name|type
expr_stmt|;
name|temprdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|temprdatalist
operator|->
name|ttl
operator|=
name|rdataset
operator|.
name|ttl
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|temprdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|temprdatalist
operator|->
name|rdata
argument_list|,
name|temprdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|temprdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatalist_tordataset
argument_list|(
name|temprdatalist
argument_list|,
name|temprdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|soa_cleanup
goto|;
name|ISC_LIST_APPEND
argument_list|(
name|tempname
operator|->
name|list
argument_list|,
name|temprdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|message
argument_list|,
name|tempname
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|temprdatalist
operator|=
name|NULL
expr_stmt|;
name|temprdataset
operator|=
name|NULL
expr_stmt|;
name|temprdata
operator|=
name|NULL
expr_stmt|;
name|tempname
operator|=
name|NULL
expr_stmt|;
name|soa_cleanup
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|zonedb
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|zonedb
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonedb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|zonedb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|message
argument_list|,
operator|&
name|tempname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temprdata
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdata
argument_list|(
name|message
argument_list|,
operator|&
name|temprdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|temprdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|temprdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temprdatalist
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdatalist
argument_list|(
name|message
argument_list|,
operator|&
name|temprdatalist
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|messagep
operator|=
name|message
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|tempname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|message
argument_list|,
operator|&
name|tempname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temprdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|temprdataset
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_notifyreceive
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|from
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|fromtext
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|isc_sockaddr_t
name|local
decl_stmt|,
name|remote
decl_stmt|;
name|dns_tsigkey_t
modifier|*
name|tsigkey
decl_stmt|;
name|dns_name_t
modifier|*
name|tsig
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If type != T_SOA return DNS_R_NOTIMP.  We don't yet support 	 * ROLLOVER. 	 * 	 * SOA:	RFC1996 	 * Check that 'from' is a valid notify source, (zone->masters). 	 *	Return DNS_R_REFUSED if not. 	 * 	 * If the notify message contains a serial number check it 	 * against the zones serial and return if<= current serial 	 * 	 * If a refresh check is progress, if so just record the 	 * fact we received a NOTIFY and from where and return. 	 * We will perform a new refresh check when the current one 	 * completes. Return ISC_R_SUCCESS. 	 * 	 * Otherwise initiate a refresh check using 'from' as the 	 * first address to check.  Return ISC_R_SUCCESS. 	 */
name|isc_sockaddr_format
argument_list|(
name|from
argument_list|,
name|fromtext
argument_list|,
sizeof|sizeof
argument_list|(
name|fromtext
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Notify messages are processed by the raw zone. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|result
operator|=
name|dns_zone_notifyreceive
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|from
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 *  We only handle NOTIFY (SOA) at the present. 	 */
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
name|from
argument_list|)
operator|==
name|PF_INET
condition|)
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_notifyinv4
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_notifyinv6
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|counts
index|[
name|DNS_SECTION_QUESTION
index|]
operator|==
literal|0
operator|||
name|dns_message_findname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|counts
index|[
name|DNS_SECTION_QUESTION
index|]
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"NOTIFY with no "
literal|"question section from: %s"
argument_list|,
name|fromtext
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_FORMERR
operator|)
return|;
block|}
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"NOTIFY zone does not match"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_NOTIMP
operator|)
return|;
block|}
comment|/* 	 * If we are a master zone just succeed. 	 */
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
name|from
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|masterscnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isc_sockaddr_eqaddr
argument_list|(
name|from
argument_list|,
operator|&
name|zone
operator|->
name|masters
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|zone
operator|->
name|view
operator|->
name|aclenv
operator|.
name|match_mapped
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|from
operator|->
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|isc_sockaddr_pf
argument_list|(
operator|&
name|zone
operator|->
name|masters
index|[
name|i
index|]
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
name|isc_netaddr_t
name|na1
decl_stmt|,
name|na2
decl_stmt|;
name|isc_netaddr_fromv4mapped
argument_list|(
operator|&
name|na1
argument_list|,
operator|&
name|netaddr
argument_list|)
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na2
argument_list|,
operator|&
name|zone
operator|->
name|masters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_netaddr_equal
argument_list|(
operator|&
name|na1
argument_list|,
operator|&
name|na2
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Accept notify requests from non masters if they are on 	 * 'zone->notify_acl'. 	 */
name|tsigkey
operator|=
name|dns_message_gettsigkey
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|tsig
operator|=
name|dns_tsigkey_identity
argument_list|(
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|notify_acl
operator|!=
name|NULL
operator|&&
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|tsig
argument_list|,
name|zone
operator|->
name|notify_acl
argument_list|,
operator|&
name|zone
operator|->
name|view
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
block|{
comment|/* Accept notify. */
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|zone
operator|->
name|masterscnt
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"refused notify from non-master: %s"
argument_list|,
name|fromtext
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_notifyrej
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
block|}
comment|/* 	 * If the zone is loaded and there are answers check the serial 	 * to see if we need to do a refresh.  Do not worry about this 	 * check if we are a dialup zone as we use the notify request 	 * to trigger a refresh check. 	 */
if|if
condition|(
name|msg
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|>
literal|0
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOREFRESH
argument_list|)
condition|)
block|{
name|result
operator|=
name|dns_message_findname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_uint32_t
name|serial
init|=
literal|0
decl_stmt|,
name|oldserial
decl_stmt|;
name|unsigned
name|int
name|soacount
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|serial
operator|=
name|soa
operator|.
name|serial
expr_stmt|;
comment|/* 			 * The following should safely be performed without DB 			 * lock and succeed in this context. 			 */
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|oldserial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|soacount
operator|>
literal|0U
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_serial_le
argument_list|(
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"notify from %s: "
literal|"zone is up to date"
argument_list|,
name|fromtext
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * If we got this far and there was a refresh in progress just 	 * let it complete.  Record where we got the notify from so we 	 * can perform a refresh check when the current one completes 	 */
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDREFRESH
argument_list|)
expr_stmt|;
name|zone
operator|->
name|notifyfrom
operator|=
operator|*
name|from
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"notify from %s: refresh in progress, "
literal|"refresh check queued"
argument_list|,
name|fromtext
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|zone
operator|->
name|notifyfrom
operator|=
operator|*
name|from
expr_stmt|;
name|local
operator|=
name|zone
operator|->
name|masteraddr
expr_stmt|;
name|remote
operator|=
name|zone
operator|->
name|sourceaddr
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_zonemgr_unreachabledel
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
operator|&
name|local
argument_list|,
operator|&
name|remote
argument_list|)
expr_stmt|;
name|dns_zone_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setnotifyacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|notify_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|notify_acl
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|acl
argument_list|,
operator|&
name|zone
operator|->
name|notify_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setqueryacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|query_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|query_acl
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|acl
argument_list|,
operator|&
name|zone
operator|->
name|query_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setqueryonacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|queryon_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|queryon_acl
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|acl
argument_list|,
operator|&
name|zone
operator|->
name|queryon_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setupdateacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|update_acl
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|acl
argument_list|,
operator|&
name|zone
operator|->
name|update_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setforwardacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|forward_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|forward_acl
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|acl
argument_list|,
operator|&
name|zone
operator|->
name|forward_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setxfracl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|xfr_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|xfr_acl
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|acl
argument_list|,
operator|&
name|zone
operator|->
name|xfr_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_zone_getnotifyacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|notify_acl
operator|)
return|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_zone_getqueryacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|query_acl
operator|)
return|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_zone_getqueryonacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|queryon_acl
operator|)
return|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_zone_getupdateacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|update_acl
operator|)
return|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_zone_getforwardacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|forward_acl
operator|)
return|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_zone_getxfracl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|xfr_acl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_clearupdateacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|update_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|update_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_clearforwardacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|forward_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|forward_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_clearnotifyacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|notify_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|notify_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_clearqueryacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|query_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|query_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_clearqueryonacl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|queryon_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|queryon_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_clearxfracl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|xfr_acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|zone
operator|->
name|xfr_acl
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zone_getupdatedisabled
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|update_disabled
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setupdatedisabled
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|state
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|update_disabled
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zone_getzeronosoattl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|zero_no_soa_ttl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setzeronosoattl
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|state
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|zero_no_soa_ttl
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setchecknames
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_severity_t
name|severity
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|check_names
operator|=
name|severity
expr_stmt|;
block|}
end_function

begin_function
name|dns_severity_t
name|dns_zone_getchecknames
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|check_names
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setjournalsize
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_int32_t
name|size
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|journalsize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
name|isc_int32_t
name|dns_zone_getjournalsize
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|journalsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_namerd_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|length
operator|>
literal|1U
argument_list|)
expr_stmt|;
comment|/* 	 * Leave space for terminating '\0'. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|!=
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|type
operator|!=
name|dns_zone_key
condition|)
block|{
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
name|result
operator|=
name|dns_name_totext
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
operator|>=
operator|(
sizeof|sizeof
argument_list|(
literal|"<UNKNOWN>"
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
operator|>
literal|0
condition|)
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataclass_totext
argument_list|(
name|zone
operator|->
name|rdclass
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|view
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zone
operator|->
name|view
operator|->
name|name
argument_list|,
literal|"_bind"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|zone
operator|->
name|view
operator|->
name|name
argument_list|,
literal|"_default"
argument_list|)
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|zone
operator|->
name|view
operator|->
name|name
argument_list|)
operator|<
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
name|zone
operator|->
name|view
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
operator|&&
literal|9U
operator|<
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" (signed)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
operator|&&
literal|11U
operator|<
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" (unsigned)"
argument_list|)
expr_stmt|;
name|buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_name_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|length
operator|>
literal|1U
argument_list|)
expr_stmt|;
comment|/* 	 * Leave space for terminating '\0'. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
name|result
operator|=
name|dns_name_totext
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
operator|>=
operator|(
sizeof|sizeof
argument_list|(
literal|"<UNKNOWN>"
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_rdclass_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|isc_buffer_t
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|length
operator|>
literal|1U
argument_list|)
expr_stmt|;
comment|/* 	 * Leave space for terminating '\0'. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataclass_totext
argument_list|(
name|zone
operator|->
name|rdclass
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_viewname_tostr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|isc_buffer_t
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|length
operator|>
literal|1U
argument_list|)
expr_stmt|;
comment|/* 	 * Leave space for terminating '\0'. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|view
operator|==
name|NULL
condition|)
block|{
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"_none"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|zone
operator|->
name|view
operator|->
name|name
argument_list|)
operator|<
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
name|zone
operator|->
name|view
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_buffer_putstr
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"_toolong"
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_name
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zone_namerd_tostr
argument_list|(
name|zone
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_log
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|message
index|[
literal|4096
index|]
decl_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
operator|==
name|ISC_FALSE
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_NOTIFY
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|level
argument_list|,
literal|"zone %s: %s"
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_logc
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|message
index|[
literal|4096
index|]
decl_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
operator|==
name|ISC_FALSE
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|level
argument_list|,
literal|"%s%s: %s"
argument_list|,
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
operator|)
condition|?
literal|"managed-keys-zone"
else|:
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|)
condition|?
literal|"redirect-zone"
else|:
literal|"zone "
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_log
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|message
index|[
literal|4096
index|]
decl_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
operator|==
name|ISC_FALSE
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|level
argument_list|,
literal|"%s%s: %s"
argument_list|,
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_key
operator|)
condition|?
literal|"managed-keys-zone"
else|:
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|)
condition|?
literal|"redirect-zone"
else|:
literal|"zone "
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_debuglog
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|me
parameter_list|,
name|int
name|debuglevel
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|message
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_DEBUG
argument_list|(
name|debuglevel
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zstr
decl_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
operator|==
name|ISC_FALSE
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zone
operator|->
name|type
condition|)
block|{
case|case
name|dns_zone_key
case|:
name|zstr
operator|=
literal|"managed-keys-zone"
expr_stmt|;
break|break;
case|case
name|dns_zone_redirect
case|:
name|zstr
operator|=
literal|"redirect-zone"
expr_stmt|;
break|break;
default|default:
name|zstr
operator|=
literal|"zone"
expr_stmt|;
block|}
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|level
argument_list|,
literal|"%s: %s %s: %s"
argument_list|,
name|me
argument_list|,
name|zstr
argument_list|,
name|zone
operator|->
name|strnamerd
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|message_count
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_section_t
name|section
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|curr
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|curr
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|ISC_LIST_PREV
argument_list|(
name|curr
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|type
operator|==
name|type
condition|)
name|count
operator|++
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setmaxxfrin
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|maxxfrin
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|maxxfrin
operator|=
name|maxxfrin
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getmaxxfrin
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|maxxfrin
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setmaxxfrout
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|maxxfrout
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|maxxfrout
operator|=
name|maxxfrout
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getmaxxfrout
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|maxxfrout
operator|)
return|;
block|}
end_function

begin_function
name|dns_zonetype_t
name|dns_zone_gettype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
name|dns_name_t
modifier|*
name|dns_zone_getorigin
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|zone
operator|->
name|origin
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_settask
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_settask
argument_list|(
name|zone
operator|->
name|db
argument_list|,
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_gettask
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_task_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|isc_task_attach
argument_list|(
name|zone
operator|->
name|task
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setidlein
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|idlein
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idlein
operator|==
literal|0
condition|)
name|idlein
operator|=
name|DNS_DEFAULT_IDLEIN
expr_stmt|;
name|zone
operator|->
name|idlein
operator|=
name|idlein
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getidlein
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|idlein
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setidleout
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|idleout
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|idleout
operator|=
name|idleout
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getidleout
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|idleout
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_requestevent_t
modifier|*
name|revent
init|=
operator|(
name|dns_requestevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|dns_notify_t
modifier|*
name|notify
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|isc_buffer_t
name|buf
decl_stmt|;
name|char
name|rcode
index|[
literal|128
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|notify
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_NOTIFY_VALID
argument_list|(
name|notify
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|notify
operator|->
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|rcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|notify
operator|->
name|dst
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|revent
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_message_create
argument_list|(
name|notify
operator|->
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_request_getresponse
argument_list|(
name|revent
operator|->
name|request
argument_list|,
name|message
argument_list|,
name|DNS_MESSAGEPARSE_PRESERVEORDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_rcode_totext
argument_list|(
name|message
operator|->
name|rcode
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|notify_log
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"notify response from %s: %.*s"
argument_list|,
name|addrbuf
argument_list|,
operator|(
name|int
operator|)
name|buf
operator|.
name|used
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
else|else
name|notify_log
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"notify to %s failed: %s"
argument_list|,
name|addrbuf
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Old bind's return formerr if they see a soa record.	Retry w/o 	 * the soa if we see a formerr and had sent a SOA. 	 */
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
operator|&&
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_formerr
operator|&&
operator|(
name|notify
operator|->
name|flags
operator|&
name|DNS_NOTIFY_NOSOA
operator|)
operator|==
literal|0
condition|)
block|{
name|notify
operator|->
name|flags
operator||=
name|DNS_NOTIFY_NOSOA
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|notify
operator|->
name|request
argument_list|)
expr_stmt|;
name|result
operator|=
name|notify_send_queue
argument_list|(
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_TIMEDOUT
condition|)
name|notify_log
argument_list|(
name|notify
operator|->
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"notify to %s: retries exceeded"
argument_list|,
name|addrbuf
argument_list|)
expr_stmt|;
name|notify_destroy
argument_list|(
name|notify
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|secure_event
block|{
name|isc_event_t
name|e
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|update_log_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|sync_secure_journal
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_journal_t
modifier|*
name|journal
parameter_list|,
name|isc_uint32_t
name|start
parameter_list|,
name|isc_uint32_t
name|end
parameter_list|,
name|dns_difftuple_t
modifier|*
modifier|*
name|soatuplep
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|dns_diffop_t
name|op
init|=
name|DNS_DIFFOP_ADD
decl_stmt|;
name|int
name|n_soa
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|soatuplep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
name|CHECK
argument_list|(
name|dns_journal_iter_init
argument_list|(
name|journal
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_journal_first_rr
argument_list|(
name|journal
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_journal_next_rr
argument_list|(
name|journal
argument_list|)
control|)
block|{
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|dns_journal_current_rr
argument_list|(
name|journal
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
name|n_soa
operator|++
expr_stmt|;
if|if
condition|(
name|n_soa
operator|==
literal|2
condition|)
block|{
comment|/* 				 * Save the latest raw SOA record. 				 */
if|if
condition|(
operator|*
name|soatuplep
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
name|soatuplep
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_difftuple_create
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|,
name|soatuplep
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_soa
operator|==
literal|3
condition|)
name|n_soa
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Sanity. */
if|if
condition|(
name|n_soa
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"corrupt journal file: '%s'\n"
argument_list|,
name|zone
operator|->
name|raw
operator|->
name|journal
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|->
name|privatetype
operator|!=
literal|0
operator|&&
name|rdata
operator|->
name|type
operator|==
name|zone
operator|->
name|privatetype
condition|)
continue|continue;
if|if
condition|(
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_dnskey
operator|||
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3param
condition|)
continue|continue;
name|op
operator|=
operator|(
name|n_soa
operator|==
literal|1
operator|)
condition|?
name|DNS_DIFFOP_DEL
else|:
name|DNS_DIFFOP_ADD
expr_stmt|;
name|CHECK
argument_list|(
name|dns_difftuple_create
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|,
operator|&
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_appendminimal
argument_list|(
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|sync_secure_db
parameter_list|(
name|dns_zone_t
modifier|*
name|seczone
parameter_list|,
name|dns_db_t
modifier|*
name|secdb
parameter_list|,
name|dns_dbversion_t
modifier|*
name|secver
parameter_list|,
name|dns_difftuple_t
modifier|*
modifier|*
name|soatuple
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_db_t
modifier|*
name|rawdb
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|rawver
init|=
name|NULL
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|oldtuple
init|=
name|NULL
decl_stmt|,
modifier|*
name|newtuple
init|=
name|NULL
decl_stmt|;
name|dns_rdata_soa_t
name|oldsoa
decl_stmt|,
name|newsoa
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|seczone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|inline_secure
argument_list|(
name|seczone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|soatuple
operator|!=
name|NULL
operator|&&
operator|*
name|soatuple
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seczone
operator|->
name|sourceserialset
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
name|dns_db_attach
argument_list|(
name|seczone
operator|->
name|raw
operator|->
name|db
argument_list|,
operator|&
name|rawdb
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|rawdb
argument_list|,
operator|&
name|rawver
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_diffx
argument_list|(
name|diff
argument_list|,
name|rawdb
argument_list|,
name|rawver
argument_list|,
name|secdb
argument_list|,
name|secver
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|rawdb
argument_list|,
operator|&
name|rawver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|rawdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|tuple
operator|!=
name|NULL
condition|;
name|tuple
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|tuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
operator|||
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3param
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
operator|->
name|tuples
argument_list|,
name|tuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_difftuple_free
argument_list|(
operator|&
name|tuple
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
if|if
condition|(
name|tuple
operator|->
name|op
operator|==
name|DNS_DIFFOP_DEL
condition|)
block|{
name|INSIST
argument_list|(
name|oldtuple
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|oldtuple
operator|=
name|tuple
expr_stmt|;
block|}
if|if
condition|(
name|tuple
operator|->
name|op
operator|==
name|DNS_DIFFOP_ADD
condition|)
block|{
name|INSIST
argument_list|(
name|newtuple
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|newtuple
operator|=
name|tuple
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|oldtuple
operator|!=
name|NULL
operator|&&
name|newtuple
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|oldtuple
operator|->
name|rdata
argument_list|,
operator|&
name|oldsoa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|newtuple
operator|->
name|rdata
argument_list|,
operator|&
name|newsoa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 		 * If the SOA records are the same except for the serial 		 * remove them from the diff. 		 */
if|if
condition|(
name|oldsoa
operator|.
name|refresh
operator|==
name|newsoa
operator|.
name|refresh
operator|&&
name|oldsoa
operator|.
name|retry
operator|==
name|newsoa
operator|.
name|retry
operator|&&
name|oldsoa
operator|.
name|minimum
operator|==
name|newsoa
operator|.
name|minimum
operator|&&
name|oldsoa
operator|.
name|expire
operator|==
name|newsoa
operator|.
name|expire
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|oldsoa
operator|.
name|origin
argument_list|,
operator|&
name|newsoa
operator|.
name|origin
argument_list|)
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|oldsoa
operator|.
name|contact
argument_list|,
operator|&
name|newsoa
operator|.
name|contact
argument_list|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
operator|->
name|tuples
argument_list|,
name|oldtuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_difftuple_free
argument_list|(
operator|&
name|oldtuple
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|diff
operator|->
name|tuples
argument_list|,
name|newtuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_difftuple_free
argument_list|(
operator|&
name|newtuple
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
comment|/* 	 * If there are still SOA records in the diff they can now be removed 	 * saving the new SOA record. 	 */
if|if
condition|(
name|oldtuple
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
operator|->
name|tuples
argument_list|,
name|oldtuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_difftuple_free
argument_list|(
operator|&
name|oldtuple
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newtuple
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
operator|->
name|tuples
argument_list|,
name|newtuple
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|soatuple
operator|=
name|newtuple
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|receive_secure_serial
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|static
name|char
name|me
index|[]
init|=
literal|"receive_secure_serial"
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_journal_t
modifier|*
name|rjournal
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|newver
init|=
name|NULL
decl_stmt|,
modifier|*
name|oldver
init|=
name|NULL
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|,
modifier|*
name|soatuple
init|=
name|NULL
decl_stmt|;
name|dns_update_log_t
name|log
init|=
block|{
name|update_log_cb
block|,
name|NULL
block|}
decl_stmt|;
name|isc_time_t
name|timenow
decl_stmt|;
name|zone
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|end
operator|=
operator|(
operator|(
expr|struct
name|secure_event
operator|*
operator|)
name|event
operator|)
operator|->
name|serial
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * zone->db may be NULL if the load from disk failed. 	 */
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
operator|!
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * We first attempt to sync the raw zone to the secure zone 	 * by using the raw zone's journal, applying all the deltas 	 * from the latest source-serial of the secure zone up to 	 * the current serial number of the raw zone. 	 * 	 * If that fails, then we'll fall back to a direct comparison 	 * between raw and secure zones. 	 */
name|result
operator|=
name|dns_journal_open
argument_list|(
name|zone
operator|->
name|raw
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|raw
operator|->
name|journal
argument_list|,
name|DNS_JOURNAL_WRITE
argument_list|,
operator|&
name|rjournal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
else|else
block|{
name|dns_journal_t
modifier|*
name|sjournal
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_journal_open
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|DNS_JOURNAL_READ
argument_list|,
operator|&
name|sjournal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|failure
goto|;
if|if
condition|(
operator|!
name|dns_journal_get_sourceserial
argument_list|(
name|rjournal
argument_list|,
operator|&
name|start
argument_list|)
condition|)
block|{
name|start
operator|=
name|dns_journal_first_serial
argument_list|(
name|rjournal
argument_list|)
expr_stmt|;
name|dns_journal_set_sourceserial
argument_list|(
name|rjournal
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sjournal
operator|!=
name|NULL
condition|)
block|{
name|isc_uint32_t
name|serial
decl_stmt|;
comment|/* 			 * We read the secure journal first, if that exists 			 * use its value provided it is greater that from the 			 * raw journal. 			 */
if|if
condition|(
name|dns_journal_get_sourceserial
argument_list|(
name|sjournal
argument_list|,
operator|&
name|serial
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_serial_gt
argument_list|(
name|serial
argument_list|,
name|start
argument_list|)
condition|)
name|start
operator|=
name|serial
expr_stmt|;
block|}
name|dns_journal_destroy
argument_list|(
operator|&
name|sjournal
argument_list|)
expr_stmt|;
block|}
block|}
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try to apply diffs from the raw zone's journal to the secure 	 * zone.  If that fails, we recover by syncing up the databases 	 * directly. 	 */
name|result
operator|=
name|sync_secure_journal
argument_list|(
name|zone
argument_list|,
name|rjournal
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|soatuple
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
goto|goto
name|failure
goto|;
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|CHECK
argument_list|(
name|sync_secure_db
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|oldver
argument_list|,
operator|&
name|soatuple
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_diff_apply
argument_list|(
operator|&
name|diff
argument_list|,
name|db
argument_list|,
name|newver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|soatuple
operator|!=
name|NULL
condition|)
block|{
name|isc_uint32_t
name|oldserial
decl_stmt|,
name|newserial
decl_stmt|,
name|desired
decl_stmt|;
name|CHECK
argument_list|(
name|dns_db_createsoatuple
argument_list|(
name|db
argument_list|,
name|oldver
argument_list|,
name|diff
operator|.
name|mctx
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
operator|&
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|oldserial
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|tuple
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|newserial
operator|=
name|desired
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|soatuple
operator|->
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_serial_gt
argument_list|(
name|newserial
argument_list|,
name|oldserial
argument_list|)
condition|)
block|{
name|newserial
operator|=
name|oldserial
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newserial
operator|==
literal|0
condition|)
name|newserial
operator|++
expr_stmt|;
name|dns_soa_setserial
argument_list|(
name|newserial
argument_list|,
operator|&
name|soatuple
operator|->
name|rdata
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|do_one_tuple
argument_list|(
operator|&
name|tuple
argument_list|,
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|do_one_tuple
argument_list|(
operator|&
name|soatuple
argument_list|,
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"serial %u (unsigned %u)"
argument_list|,
name|newserial
argument_list|,
name|desired
argument_list|)
expr_stmt|;
block|}
else|else
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_update_signatures
argument_list|(
operator|&
name|log
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|oldver
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|sigvalidityinterval
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
operator|&
name|diff
argument_list|,
operator|&
name|end
argument_list|,
literal|"receive_secure_serial"
argument_list|)
argument_list|)
expr_stmt|;
name|dns_journal_set_sourceserial
argument_list|(
name|rjournal
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|dns_journal_commit
argument_list|(
name|rjournal
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|zone
operator|->
name|sourceserial
operator|=
name|end
expr_stmt|;
name|zone
operator|->
name|sourceserialset
operator|=
name|ISC_TRUE
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|failure
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"receive_secure_serial: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tuple
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
operator|&
name|tuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|soatuple
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
operator|&
name|soatuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|oldver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rjournal
operator|!=
name|NULL
condition|)
name|dns_journal_destroy
argument_list|(
operator|&
name|rjournal
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_send_secureserial
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|serial
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|dns_zone_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zone
operator|->
name|secure
operator|->
name|mctx
argument_list|,
name|zone
argument_list|,
name|DNS_EVENT_ZONESECURESERIAL
argument_list|,
name|receive_secure_serial
argument_list|,
name|zone
operator|->
name|secure
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secure_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|(
operator|(
expr|struct
name|secure_event
operator|*
operator|)
name|e
operator|)
operator|->
name|serial
operator|=
name|serial
expr_stmt|;
name|INSIST
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
operator|->
name|secure
argument_list|)
argument_list|)
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
operator|->
name|secure
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|secure
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SENDSECURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|checkandaddsoa
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_uint32_t
name|oldserial
parameter_list|)
block|{
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdatalist_t
name|temprdatalist
decl_stmt|;
name|dns_rdataset_t
name|temprdataset
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DNS_SOA_BUFFERSIZE
index|]
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_serial_gt
argument_list|(
name|soa
operator|.
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
return|return
operator|(
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
comment|/* 	 * Always bump the serial. 	 */
name|oldserial
operator|++
expr_stmt|;
if|if
condition|(
name|oldserial
operator|==
literal|0
condition|)
name|oldserial
operator|++
expr_stmt|;
name|soa
operator|.
name|serial
operator|=
name|oldserial
expr_stmt|;
comment|/* 	 * Construct a replacement rdataset. 	 */
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|rdata
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|soa
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|temprdatalist
operator|.
name|rdclass
operator|=
name|rdata
operator|.
name|rdclass
expr_stmt|;
name|temprdatalist
operator|.
name|type
operator|=
name|rdata
operator|.
name|type
expr_stmt|;
name|temprdatalist
operator|.
name|covers
operator|=
literal|0
expr_stmt|;
name|temprdatalist
operator|.
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|temprdatalist
operator|.
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|temprdatalist
operator|.
name|rdata
argument_list|,
operator|&
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|temprdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatalist_tordataset
argument_list|(
operator|&
name|temprdatalist
argument_list|,
operator|&
name|temprdataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|temprdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function should populate an nsec3paramlist_t with the  * nsecparam_t data from a zone.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|save_nsec3param
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|nsec3paramlist_t
modifier|*
name|nsec3list
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|,
name|prdataset
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|nsec3param_t
modifier|*
name|nsec3param
init|=
name|NULL
decl_stmt|;
name|nsec3param_t
modifier|*
name|nsec3p
init|=
name|NULL
decl_stmt|;
name|nsec3param_t
modifier|*
name|next
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nsec3list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|nsec3list
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|prdataset
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|getprivate
goto|;
comment|/* 	 * walk nsec3param rdataset making a list of parameters (note that 	 * multiple simultaneous nsec3 chains are annoyingly legal -- this 	 * is why we use an nsec3list, even tho we will usually only have 	 * one) 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|private
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"looping through nsec3param data"
argument_list|)
expr_stmt|;
name|nsec3param
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec3param_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|nsec3param
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * now transfer the data from the rdata to 		 * the nsec3param 		 */
name|dns_nsec3param_toprivate
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|private
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|nsec3param
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec3param
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|nsec3param
operator|->
name|length
operator|=
name|private
operator|.
name|length
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|nsec3list
argument_list|,
name|nsec3param
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|getprivate
label|:
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|prdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * walk private type records, converting them to nsec3 parameters 	 * using dns_nsec3param_fromprivate(), do the right thing based on 	 * CREATE and REMOVE flags 	 */
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|prdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|prdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|private
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|prdataset
argument_list|,
operator|&
name|private
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"looping through nsec3param private data"
argument_list|)
expr_stmt|;
comment|/* 		 * Do we have a valid private record? 		 */
if|if
condition|(
operator|!
name|dns_nsec3param_fromprivate
argument_list|(
operator|&
name|private
argument_list|,
operator|&
name|rdata
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Remove any NSEC3PARAM records scheduled to be removed. 		 */
if|if
condition|(
name|NSEC3REMOVE
argument_list|(
name|rdata
operator|.
name|data
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 			 * Zero out the flags. 			 */
name|rdata
operator|.
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nsec3p
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsec3list
argument_list|)
init|;
name|nsec3p
operator|!=
name|NULL
condition|;
name|nsec3p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3p
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3p
operator|->
name|length
operator|==
name|rdata
operator|.
name|length
operator|+
literal|1
operator|&&
name|memcmp
argument_list|(
name|rdata
operator|.
name|data
argument_list|,
name|nsec3p
operator|->
name|data
operator|+
literal|1
argument_list|,
name|nsec3p
operator|->
name|length
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|nsec3list
argument_list|,
name|nsec3p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3p
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec3param_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|nsec3param
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec3param_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|nsec3param
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * Copy the remaining private records so the nsec/nsec3 		 * chain gets created. 		 */
name|INSIST
argument_list|(
name|private
operator|.
name|length
operator|<=
sizeof|sizeof
argument_list|(
name|nsec3param
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|nsec3param
operator|->
name|data
argument_list|,
name|private
operator|.
name|data
argument_list|,
name|private
operator|.
name|length
argument_list|)
expr_stmt|;
name|nsec3param
operator|->
name|length
operator|=
name|private
operator|.
name|length
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|nsec3list
argument_list|,
name|nsec3param
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
operator|||
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|prdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|prdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of the nsec3 chains desired for the zone, converting  * parameters to private type records using dns_nsec3param_toprivate(),  * and insert them into the new zone db.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|restore_nsec3param
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|nsec3paramlist_t
modifier|*
name|nsec3list
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
name|nsec3param_t
modifier|*
name|nsec3p
init|=
name|NULL
decl_stmt|;
name|nsec3param_t
modifier|*
name|next
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|nsec3list
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through the list of private-type records, set the INITIAL 	 * and CREATE flags, and the add the record to the apex of the tree 	 * in db. 	 */
for|for
control|(
name|nsec3p
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsec3list
argument_list|)
init|;
name|nsec3p
operator|!=
name|NULL
condition|;
name|nsec3p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|nsec3p
operator|->
name|data
index|[
literal|2
index|]
operator|=
name|DNS_NSEC3FLAG_CREATE
operator||
name|DNS_NSEC3FLAG_INITIAL
expr_stmt|;
name|rdata
operator|.
name|length
operator|=
name|nsec3p
operator|->
name|length
expr_stmt|;
name|rdata
operator|.
name|data
operator|=
name|nsec3p
operator|->
name|data
expr_stmt|;
name|rdata
operator|.
name|type
operator|=
name|zone
operator|->
name|privatetype
expr_stmt|;
name|rdata
operator|.
name|rdclass
operator|=
name|zone
operator|->
name|rdclass
expr_stmt|;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
for|for
control|(
name|nsec3p
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsec3list
argument_list|)
init|;
name|nsec3p
operator|!=
name|NULL
condition|;
name|nsec3p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsec3p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|nsec3list
argument_list|,
name|nsec3p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3p
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec3param_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|receive_secure_db
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|rawdb
decl_stmt|,
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|rawnode
init|=
name|NULL
decl_stmt|,
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbiterator
init|=
name|NULL
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsit
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
name|isc_time_t
name|loadtime
decl_stmt|;
name|unsigned
name|int
name|oldserial
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|have_oldserial
init|=
name|ISC_FALSE
decl_stmt|;
name|nsec3paramlist_t
name|nsec3list
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|nsec3list
argument_list|)
expr_stmt|;
name|zone
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|rawdb
operator|=
operator|(
operator|(
expr|struct
name|secure_event
operator|*
operator|)
name|event
operator|)
operator|->
name|db
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
operator|||
operator|!
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_SHUTTINGDOWN
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|TIME_NOW
argument_list|(
operator|&
name|loadtime
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_db_getsoaserial
argument_list|(
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldserial
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_oldserial
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * assemble nsec3parameters from the old zone, and set a flag 		 * if any are found 		 */
name|result
operator|=
name|save_nsec3param
argument_list|(
name|zone
argument_list|,
operator|&
name|nsec3list
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|db_argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_dbtype_zone
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|zone
operator|->
name|db_argc
operator|-
literal|1
argument_list|,
name|zone
operator|->
name|db_argv
operator|+
literal|1
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|rawdb
argument_list|,
literal|0
argument_list|,
operator|&
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|dbiterator
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|dbiterator
argument_list|)
control|)
block|{
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|dbiterator
argument_list|,
operator|&
name|rawnode
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|rawdb
argument_list|,
name|rawnode
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|rdsit
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsit
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsit
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|rdsit
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
operator|||
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_nsec3param
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rdataset
operator|.
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
name|have_oldserial
condition|)
block|{
name|result
operator|=
name|checkandaddsoa
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
operator|&
name|rdataset
argument_list|,
name|oldserial
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsit
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|rawdb
argument_list|,
operator|&
name|rawnode
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Call restore_nsec3param() to create private-type records from 	 * the old nsec3 parameters and insert them into db 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|nsec3list
argument_list|)
condition|)
name|restore_nsec3param
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|nsec3list
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Lock hierarchy: zmgr, zone, raw. 	 */
name|INSIST
argument_list|(
name|zone
operator|!=
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_postload
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|loadtime
argument_list|,
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXMPA */
name|UNLOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
name|failure
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"receive_secure_db: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|nsec3list
argument_list|)
condition|)
block|{
name|nsec3param_t
modifier|*
name|nsec3p
decl_stmt|;
name|nsec3p
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|nsec3list
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|nsec3list
argument_list|,
name|nsec3p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|nsec3p
argument_list|,
sizeof|sizeof
argument_list|(
name|nsec3param_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rawnode
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|rawdb
argument_list|,
operator|&
name|rawnode
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|rawdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbiterator
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dbiterator
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_send_securedb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|dns_db_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zone
operator|->
name|secure
operator|->
name|mctx
argument_list|,
name|zone
argument_list|,
name|DNS_EVENT_ZONESECUREDB
argument_list|,
name|receive_secure_db
argument_list|,
name|zone
operator|->
name|secure
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secure_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|secure_event
operator|*
operator|)
name|e
operator|)
operator|->
name|db
operator|=
name|dummy
expr_stmt|;
name|INSIST
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
operator|->
name|secure
argument_list|)
argument_list|)
expr_stmt|;
name|zone_iattach
argument_list|(
name|zone
operator|->
name|secure
argument_list|,
operator|&
name|secure
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|secure
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SENDSECURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_replacedb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|dump
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|again
label|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|INSIST
argument_list|(
name|secure
operator|!=
name|zone
argument_list|)
expr_stmt|;
name|TRYLOCK_ZONE
argument_list|(
name|result
argument_list|,
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|secure
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ISC_PLATFORM_USETHREADS
name|isc_thread_yield
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
block|}
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_replacedb
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|dump
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|UNLOCK_ZONE
argument_list|(
name|secure
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_replacedb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|dump
parameter_list|)
block|{
name|dns_dbversion_t
modifier|*
name|ver
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|soacount
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nscount
init|=
literal|0
decl_stmt|;
comment|/* 	 * 'zone' and 'zonedb' locked by caller. 	 */
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
name|REQUIRE
argument_list|(
name|LOCKED_ZONE
argument_list|(
name|zone
operator|->
name|secure
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
operator|&
name|nscount
argument_list|,
operator|&
name|soacount
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|soacount
operator|!=
literal|1
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"has %d SOA records"
argument_list|,
name|soacount
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
block|}
if|if
condition|(
name|nscount
operator|==
literal|0
operator|&&
name|zone
operator|->
name|type
operator|!=
name|dns_zone_key
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"has no NS records"
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADZONE
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"retrieving SOA and NS records failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|check_nsec3param
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|ver
operator|=
name|NULL
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
expr_stmt|;
comment|/* 	 * The initial version of a slave zone is always dumped; 	 * subsequent versions may be journaled instead if this 	 * is enabled in the configuration. 	 */
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|journal
operator|!=
name|NULL
operator|&&
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_IXFRFROMDIFFS
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|serial
decl_stmt|,
name|oldserial
decl_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"generating diffs"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getsoaserial
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"ixfr-from-differences: unable to get "
literal|"new serial"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 		 * This is checked in zone_postload() for master zones. 		 */
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|oldserial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|soacount
operator|>
literal|0U
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_slave
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|isc_serial_gt
argument_list|(
name|serial
argument_list|,
name|oldserial
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|serialmin
decl_stmt|,
name|serialmax
decl_stmt|;
name|serialmin
operator|=
operator|(
name|oldserial
operator|+
literal|1
operator|)
operator|&
literal|0xffffffffU
expr_stmt|;
name|serialmax
operator|=
operator|(
name|oldserial
operator|+
literal|0x7fffffffU
operator|)
operator|&
literal|0xffffffffU
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"ixfr-from-differences: failed: "
literal|"new serial (%u) out of range [%u - %u]"
argument_list|,
name|serial
argument_list|,
name|serialmin
argument_list|,
name|serialmax
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|dns_db_diff
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|zone
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
name|zone
operator|->
name|journal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|dump
condition|)
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zone
operator|->
name|journalsize
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|dns_journal_compact
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|serial
argument_list|,
name|zone
operator|->
name|journalsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|ISC_R_NOSPACE
case|:
case|case
name|ISC_R_NOTFOUND
case|:
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"dns_journal_compact: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dns_journal_compact failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
name|zone_send_secureserial
argument_list|(
name|zone
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dump
operator|&&
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If DNS_ZONEFLG_FORCEXFER was set we don't want 			 * to keep the old masterfile. 			 */
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
operator|&&
name|remove
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unable to remove masterfile "
literal|"'%s': '%s'"
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
operator|==
literal|0
condition|)
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NODELAY
argument_list|)
expr_stmt|;
else|else
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump
operator|&&
name|zone
operator|->
name|journal
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The in-memory database just changed, and 			 * because 'dump' is set, it didn't change by 			 * being loaded from disk.  Also, we have not 			 * journaled diffs for this change. 			 * Therefore, the on-disk journal is missing 			 * the deltas for this change.	Since it can 			 * no longer be used to bring the zone 			 * up-to-date, it is useless and should be 			 * removed. 			 */
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"removing journal file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|zone
operator|->
name|journal
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unable to remove journal "
literal|"'%s': '%s'"
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
name|zone_send_securedb
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"replacing zone database"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|zone_detachdb
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_attachdb
argument_list|(
name|zone
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|dns_db_settask
argument_list|(
name|zone
operator|->
name|db
argument_list|,
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
operator||
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|fail
label|:
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The caller must hold the dblock as a writer. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|zone_attachdb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|zone
operator|->
name|db
operator|==
name|NULL
operator|&&
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|zone
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|acache
operator|!=
name|NULL
condition|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_acache_setdb
argument_list|(
name|zone
operator|->
name|acache
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"dns_acache_setdb() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The caller must hold the dblock as a writer. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|zone_detachdb
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|zone
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|acache
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_acache_putdb
argument_list|(
name|zone
operator|->
name|acache
argument_list|,
name|zone
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|zone
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_xfrdone
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
name|isc_boolean_t
name|again
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|soacount
decl_stmt|;
name|unsigned
name|int
name|nscount
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|,
name|refresh
decl_stmt|,
name|retry
decl_stmt|,
name|expire
decl_stmt|,
name|minimum
decl_stmt|;
name|isc_result_t
name|xfrresult
init|=
name|result
decl_stmt|;
name|isc_boolean_t
name|free_needed
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"zone transfer finished: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Obtaining a lock on the zone->secure (see zone_send_secureserial) 	 * could result in a deadlock due to a LOR so we will spin if we 	 * can't obtain the both locks. 	 */
name|again
label|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|INSIST
argument_list|(
name|secure
operator|!=
name|zone
argument_list|)
expr_stmt|;
name|TRYLOCK_ZONE
argument_list|(
name|result
argument_list|,
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|secure
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ISC_PLATFORM_USETHREADS
name|isc_thread_yield
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
block|}
name|INSIST
argument_list|(
operator|(
name|zone
operator|->
name|flags
operator|&
name|DNS_ZONEFLG_REFRESH
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SOABEFOREAXFR
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|DNS_R_UPTODATE
case|:
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
expr_stmt|;
comment|/* 		 * Has the zone expired underneath us? 		 */
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|==
name|NULL
condition|)
block|{
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
block|}
comment|/* 		 * Update the zone structure's data from the actual 		 * SOA received. 		 */
name|nscount
operator|=
literal|0
expr_stmt|;
name|soacount
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_get_from_db
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|db
argument_list|,
operator|&
name|nscount
argument_list|,
operator|&
name|soacount
argument_list|,
operator|&
name|serial
argument_list|,
operator|&
name|refresh
argument_list|,
operator|&
name|retry
argument_list|,
operator|&
name|expire
argument_list|,
operator|&
name|minimum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|soacount
operator|!=
literal|1
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"transferred zone "
literal|"has %d SOA record%s"
argument_list|,
name|soacount
argument_list|,
operator|(
name|soacount
operator|!=
literal|0
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nscount
operator|==
literal|0
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"transferred zone "
literal|"has no NS records"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
condition|)
block|{
name|zone
operator|->
name|refresh
operator|=
name|DNS_ZONE_DEFAULTREFRESH
expr_stmt|;
name|zone
operator|->
name|retry
operator|=
name|DNS_ZONE_DEFAULTRETRY
expr_stmt|;
block|}
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
expr_stmt|;
name|zone_unload
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|zone
operator|->
name|refresh
operator|=
name|RANGE
argument_list|(
name|refresh
argument_list|,
name|zone
operator|->
name|minrefresh
argument_list|,
name|zone
operator|->
name|maxrefresh
argument_list|)
expr_stmt|;
name|zone
operator|->
name|retry
operator|=
name|RANGE
argument_list|(
name|retry
argument_list|,
name|zone
operator|->
name|minretry
argument_list|,
name|zone
operator|->
name|maxretry
argument_list|)
expr_stmt|;
name|zone
operator|->
name|expire
operator|=
name|RANGE
argument_list|(
name|expire
argument_list|,
name|zone
operator|->
name|refresh
operator|+
name|zone
operator|->
name|retry
argument_list|,
name|DNS_MAX_EXPIRE
argument_list|)
expr_stmt|;
name|zone
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_HAVETIMERS
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set our next update/expire times. 		 */
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDREFRESH
argument_list|)
condition|)
block|{
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDREFRESH
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshtime
operator|=
name|now
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|expire
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DNS_ZONE_JITTER_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|refresh
argument_list|,
operator|&
name|zone
operator|->
name|refreshtime
argument_list|)
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|now
argument_list|,
name|zone
operator|->
name|expire
argument_list|,
operator|&
name|zone
operator|->
name|expiretime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|xfrresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
operator|+
sizeof|sizeof
argument_list|(
literal|": TSIG ''"
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|tsigkey
operator|!=
name|NULL
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|zone
operator|->
name|tsigkey
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": TSIG '%s'"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"transferred serial %u%s"
argument_list|,
name|serial
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
name|zone_send_secureserial
argument_list|(
name|zone
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * This is not necessary if we just performed a AXFR 		 * however it is necessary for an IXFR / UPTODATE and 		 * won't hurt with an AXFR. 		 */
if|if
condition|(
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
operator|||
name|zone
operator|->
name|journal
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|delay
init|=
name|DNS_DUMP_DELAY
decl_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|journal
operator|!=
name|NULL
condition|)
name|result
operator|=
name|isc_file_settime
argument_list|(
name|zone
operator|->
name|journal
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
name|result
operator|=
name|isc_file_settime
argument_list|(
name|zone
operator|->
name|masterfile
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NODELAY
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
name|delay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_FILENOTFOUND
operator|)
operator|&&
name|zone
operator|->
name|masterfile
operator|!=
name|NULL
condition|)
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|delay
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"transfer: could not set file "
literal|"modification time of '%s': %s"
argument_list|,
name|zone
operator|->
name|masterfile
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NODELAY
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_xfrsuccess
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_R_BADIXFR
case|:
comment|/* Force retry with AXFR. */
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLAG_NOIXFR
argument_list|)
expr_stmt|;
goto|goto
name|same_master
goto|;
default|default:
name|next_master
label|:
comment|/* 		 * Skip to next failed / untried master. 		 */
do|do
block|{
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
do|;
comment|/* FALLTHROUGH */
name|same_master
label|:
if|if
condition|(
name|zone
operator|->
name|curmaster
operator|>=
name|zone
operator|->
name|masterscnt
condition|)
block|{
name|zone
operator|->
name|curmaster
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_USEALTXFRSRC
argument_list|)
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
condition|)
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
expr_stmt|;
while|while
condition|(
name|zone
operator|->
name|curmaster
operator|<
name|zone
operator|->
name|masterscnt
operator|&&
name|zone
operator|->
name|mastersok
index|[
name|zone
operator|->
name|curmaster
index|]
condition|)
name|zone
operator|->
name|curmaster
operator|++
expr_stmt|;
name|again
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_USEALTXFRSRC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
expr_stmt|;
name|again
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_xfrfail
argument_list|)
expr_stmt|;
break|break;
block|}
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * If creating the transfer object failed, zone->xfr is NULL. 	 * Otherwise, we are called as the done callback of a zone 	 * transfer object that just entered its shutting-down 	 * state.  Since we are no longer responsible for shutting 	 * it down, we can detach our reference. 	 */
if|if
condition|(
name|zone
operator|->
name|xfr
operator|!=
name|NULL
condition|)
name|dns_xfrin_detach
argument_list|(
operator|&
name|zone
operator|->
name|xfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|tsigkey
operator|!=
name|NULL
condition|)
name|dns_tsigkey_detach
argument_list|(
operator|&
name|zone
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
comment|/* 	 * Handle any deferred journal compaction. 	 */
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDCOMPACT
argument_list|)
condition|)
block|{
name|result
operator|=
name|dns_journal_compact
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|journal
argument_list|,
name|zone
operator|->
name|compact_serial
argument_list|,
name|zone
operator|->
name|journalsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|ISC_R_NOSPACE
case|:
case|case
name|ISC_R_NOTFOUND
case|:
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"dns_journal_compact: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dns_journal_compact failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDCOMPACT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|UNLOCK_ZONE
argument_list|(
name|secure
argument_list|)
expr_stmt|;
comment|/* 	 * This transfer finishing freed up a transfer quota slot. 	 * Let any other zones waiting for quota have it. 	 */
if|if
condition|(
name|zone
operator|->
name|zmgr
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|statelist
operator|==
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|xfrin_in_progress
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|zone
operator|->
name|zmgr
operator|->
name|xfrin_in_progress
argument_list|,
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|zone
operator|->
name|statelist
operator|=
name|NULL
expr_stmt|;
name|zmgr_resume_xfrs
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Retry with a different server if necessary. 	 */
if|if
condition|(
name|again
operator|&&
operator|!
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
name|queue_soa_query
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|--
expr_stmt|;
name|free_needed
operator|=
name|exit_check
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_needed
condition|)
name|zone_free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_loaddone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
specifier|static
name|char
name|me
index|[]
init|=
literal|"zone_loaddone"
decl_stmt|;
name|dns_load_t
modifier|*
name|load
init|=
name|arg
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LOAD_VALID
argument_list|(
name|load
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|=
name|load
operator|->
name|zone
expr_stmt|;
name|ENTER
expr_stmt|;
name|tresult
operator|=
name|dns_db_endload
argument_list|(
name|load
operator|->
name|db
argument_list|,
operator|&
name|load
operator|->
name|callbacks
operator|.
name|add_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_SEENINCLUDE
operator|)
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
comment|/* 	 * Lock hierarchy: zmgr, zone, raw. 	 */
name|again
label|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|LOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|TRYLOCK_ZONE
argument_list|(
name|result
argument_list|,
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|secure
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ISC_PLATFORM_USETHREADS
name|isc_thread_yield
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
block|}
operator|(
name|void
operator|)
name|zone_postload
argument_list|(
name|zone
argument_list|,
name|load
operator|->
name|db
argument_list|,
name|load
operator|->
name|loadtime
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|zonemgr_putio
argument_list|(
operator|&
name|zone
operator|->
name|readio
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADING
argument_list|)
expr_stmt|;
name|zone_idetach
argument_list|(
operator|&
name|load
operator|->
name|callbacks
operator|.
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Leave the zone frozen if the reload fails. 	 */
if|if
condition|(
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_SEENINCLUDE
operator|)
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_THAW
argument_list|)
condition|)
name|zone
operator|->
name|update_disabled
operator|=
name|ISC_FALSE
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_THAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|UNLOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|UNLOCK_ZONE
argument_list|(
name|secure
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|load
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|load
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|load
operator|->
name|zone
operator|->
name|lctx
operator|!=
name|NULL
condition|)
name|dns_loadctx_detach
argument_list|(
operator|&
name|load
operator|->
name|zone
operator|->
name|lctx
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|load
operator|->
name|zone
argument_list|)
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|load
operator|->
name|mctx
argument_list|,
name|load
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|load
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_getssutable
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_ssutable_t
modifier|*
modifier|*
name|table
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|*
name|table
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
condition|)
name|dns_ssutable_attach
argument_list|(
name|zone
operator|->
name|ssutable
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setssutable
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_ssutable_t
modifier|*
name|table
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|ssutable
operator|!=
name|NULL
condition|)
name|dns_ssutable_detach
argument_list|(
operator|&
name|zone
operator|->
name|ssutable
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|NULL
condition|)
name|dns_ssutable_attach
argument_list|(
name|table
argument_list|,
operator|&
name|zone
operator|->
name|ssutable
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setsigvalidityinterval
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|interval
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|sigvalidityinterval
operator|=
name|interval
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getsigvalidityinterval
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|sigvalidityinterval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setsigresigninginterval
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|interval
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|sigresigninginterval
operator|=
name|interval
expr_stmt|;
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
block|{
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getsigresigninginterval
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|sigresigninginterval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_xfrin
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"queue_xfrin"
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_zonemgr_t
modifier|*
name|zmgr
init|=
name|zone
operator|->
name|zmgr
decl_stmt|;
name|ENTER
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|statelist
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|,
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|irefs
operator|++
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|statelist
operator|=
operator|&
name|zmgr
operator|->
name|waiting_for_xfrin
expr_stmt|;
name|result
operator|=
name|zmgr_start_xfrin_ifquota
argument_list|(
name|zmgr
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_QUOTA
condition|)
block|{
name|dns_zone_logc
argument_list|(
name|zone
argument_list|,
name|DNS_LOGCATEGORY_XFER_IN
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"zone transfer deferred due to quota"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_logc
argument_list|(
name|zone
argument_list|,
name|DNS_LOGCATEGORY_XFER_IN
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"starting zone transfer: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This event callback is called when a zone has received  * any necessary zone transfer quota.  This is the time  * to go ahead and start the transfer.  */
end_comment

begin_function
specifier|static
name|void
name|got_transfer_quota
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|char
name|master
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|source
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdatatype_t
name|xfrtype
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_netaddr_t
name|masterip
decl_stmt|;
name|isc_sockaddr_t
name|sourceaddr
decl_stmt|;
name|isc_sockaddr_t
name|masteraddr
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
specifier|const
name|char
modifier|*
name|soa_before
init|=
literal|""
decl_stmt|;
name|isc_boolean_t
name|loaded
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
name|master
argument_list|,
sizeof|sizeof
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zonemgr_unreachable
argument_list|(
name|zone
operator|->
name|zmgr
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|,
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|zone
operator|->
name|sourceaddr
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"got_transfer_quota: skipping zone transfer as "
literal|"master %s (source %s) is unreachable (cached)"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|masterip
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|zone
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SOABEFOREAXFR
argument_list|)
condition|)
name|soa_before
operator|=
literal|"SOA before "
expr_stmt|;
comment|/* 	 * Decide whether we should request IXFR or AXFR. 	 */
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|loaded
operator|=
name|ISC_TF
argument_list|(
name|zone
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loaded
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"no database exists yet, requesting AXFR of "
literal|"initial version from %s"
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|xfrtype
operator|=
name|dns_rdatatype_axfr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"forced reload, requesting AXFR of "
literal|"initial version from %s"
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|xfrtype
operator|=
name|dns_rdatatype_axfr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLAG_NOIXFR
argument_list|)
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"retrying with AXFR from %s due to "
literal|"previous IXFR failure"
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|xfrtype
operator|=
name|dns_rdatatype_axfr
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLAG_NOIXFR
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_boolean_t
name|use_ixfr
init|=
name|ISC_TRUE
decl_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
name|result
operator|=
name|dns_peer_getrequestixfr
argument_list|(
name|peer
argument_list|,
operator|&
name|use_ixfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
operator|||
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|use_ixfr
operator|=
name|zone
operator|->
name|requestixfr
expr_stmt|;
if|if
condition|(
name|use_ixfr
operator|==
name|ISC_FALSE
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"IXFR disabled, requesting %sAXFR from %s"
argument_list|,
name|soa_before
argument_list|,
name|master
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_SOABEFOREAXFR
argument_list|)
condition|)
name|xfrtype
operator|=
name|dns_rdatatype_soa
expr_stmt|;
else|else
name|xfrtype
operator|=
name|dns_rdatatype_axfr
expr_stmt|;
block|}
else|else
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"requesting IXFR from %s"
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|xfrtype
operator|=
name|dns_rdatatype_ixfr
expr_stmt|;
block|}
block|}
comment|/* 	 * Determine if we should attempt to sign the request with TSIG. 	 */
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
comment|/* 	 * First, look for a tsig key in the master statement, then 	 * try for a server key. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|masterkeynames
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|zone
operator|->
name|masterkeynames
index|[
name|zone
operator|->
name|curmaster
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dns_view_t
modifier|*
name|view
init|=
name|dns_zone_getview
argument_list|(
name|zone
argument_list|)
decl_stmt|;
name|dns_name_t
modifier|*
name|keyname
init|=
name|zone
operator|->
name|masterkeynames
index|[
name|zone
operator|->
name|curmaster
index|]
decl_stmt|;
name|result
operator|=
name|dns_view_gettsig
argument_list|(
name|view
argument_list|,
name|keyname
argument_list|,
operator|&
name|zone
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|tsigkey
operator|==
name|NULL
condition|)
name|result
operator|=
name|dns_view_getpeertsig
argument_list|(
name|zone
operator|->
name|view
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|zone
operator|->
name|tsigkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"could not get TSIG key for zone transfer: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|masteraddr
operator|=
name|zone
operator|->
name|masteraddr
expr_stmt|;
name|sourceaddr
operator|=
name|zone
operator|->
name|sourceaddr
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|masteraddr
argument_list|)
operator|==
name|isc_sockaddr_pf
argument_list|(
operator|&
name|sourceaddr
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_xfrin_create2
argument_list|(
name|zone
argument_list|,
name|xfrtype
argument_list|,
operator|&
name|masteraddr
argument_list|,
operator|&
name|sourceaddr
argument_list|,
name|zone
operator|->
name|tsigkey
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|zmgr
operator|->
name|timermgr
argument_list|,
name|zone
operator|->
name|zmgr
operator|->
name|socketmgr
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|zone_xfrdone
argument_list|,
operator|&
name|zone
operator|->
name|xfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfrtype
operator|==
name|dns_rdatatype_axfr
condition|)
block|{
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|masteraddr
argument_list|)
operator|==
name|PF_INET
condition|)
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_axfrreqv4
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_axfrreqv6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfrtype
operator|==
name|dns_rdatatype_ixfr
condition|)
block|{
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|masteraddr
argument_list|)
operator|==
name|PF_INET
condition|)
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_ixfrreqv4
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|zone
argument_list|,
name|dns_zonestatscounter_ixfrreqv6
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* 	 * Any failure in this function is handled like a failed 	 * zone transfer.  This ensures that we get removed from 	 * zmgr->xfrin_in_progress. 	 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|zone_xfrdone
argument_list|(
name|zone
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update forwarding support.  */
end_comment

begin_function
specifier|static
name|void
name|forward_destroy
parameter_list|(
name|dns_forward_t
modifier|*
name|forward
parameter_list|)
block|{
name|forward
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|forward
operator|->
name|request
operator|!=
name|NULL
condition|)
name|dns_request_destroy
argument_list|(
operator|&
name|forward
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
operator|->
name|msgbuf
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|forward
operator|->
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
operator|->
name|zone
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|forward
operator|->
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|forward
argument_list|,
name|link
argument_list|)
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|forward
operator|->
name|zone
operator|->
name|forwards
argument_list|,
name|forward
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|forward
operator|->
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|forward
operator|->
name|zone
argument_list|)
expr_stmt|;
block|}
name|isc_mem_putanddetach
argument_list|(
operator|&
name|forward
operator|->
name|mctx
argument_list|,
name|forward
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|forward
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|sendtomaster
parameter_list|(
name|dns_forward_t
modifier|*
name|forward
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_sockaddr_t
name|src
decl_stmt|;
name|LOCK_ZONE
argument_list|(
name|forward
operator|->
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|forward
operator|->
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|forward
operator|->
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CANCELED
operator|)
return|;
block|}
if|if
condition|(
name|forward
operator|->
name|which
operator|>=
name|forward
operator|->
name|zone
operator|->
name|masterscnt
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|forward
operator|->
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
name|forward
operator|->
name|addr
operator|=
name|forward
operator|->
name|zone
operator|->
name|masters
index|[
name|forward
operator|->
name|which
index|]
expr_stmt|;
comment|/* 	 * Always use TCP regardless of whether the original update 	 * used TCP. 	 * XXX The timeout may but a bit small if we are far down a 	 * transfer graph and the master has to try several masters. 	 */
switch|switch
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|forward
operator|->
name|addr
argument_list|)
condition|)
block|{
case|case
name|PF_INET
case|:
name|src
operator|=
name|forward
operator|->
name|zone
operator|->
name|xfrsource4
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|src
operator|=
name|forward
operator|->
name|zone
operator|->
name|xfrsource6
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|result
operator|=
name|dns_request_createraw
argument_list|(
name|forward
operator|->
name|zone
operator|->
name|view
operator|->
name|requestmgr
argument_list|,
name|forward
operator|->
name|msgbuf
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|forward
operator|->
name|addr
argument_list|,
name|DNS_REQUESTOPT_TCP
argument_list|,
literal|15
comment|/* XXX */
argument_list|,
name|forward
operator|->
name|zone
operator|->
name|task
argument_list|,
name|forward_callback
argument_list|,
name|forward
argument_list|,
operator|&
name|forward
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|forward
argument_list|,
name|link
argument_list|)
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|forward
operator|->
name|zone
operator|->
name|forwards
argument_list|,
name|forward
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|forward
operator|->
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|forward_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
name|me
index|[]
init|=
literal|"forward_callback"
decl_stmt|;
name|dns_requestevent_t
modifier|*
name|revent
init|=
operator|(
name|dns_requestevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|char
name|master
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_forward_t
modifier|*
name|forward
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|forward
operator|=
name|revent
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_FORWARD_VALID
argument_list|(
name|forward
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|=
name|forward
operator|->
name|zone
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|forward
operator|->
name|addr
argument_list|,
name|master
argument_list|,
sizeof|sizeof
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"could not forward dynamic update to %s: %s"
argument_list|,
name|master
argument_list|,
name|dns_result_totext
argument_list|(
name|revent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
name|result
operator|=
name|dns_message_create
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|next_master
goto|;
name|result
operator|=
name|dns_request_getresponse
argument_list|(
name|revent
operator|->
name|request
argument_list|,
name|msg
argument_list|,
name|DNS_MESSAGEPARSE_PRESERVEORDER
operator||
name|DNS_MESSAGEPARSE_CLONEBUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|next_master
goto|;
switch|switch
condition|(
name|msg
operator|->
name|rcode
condition|)
block|{
comment|/* 	 * Pass these rcodes back to client. 	 */
case|case
name|dns_rcode_noerror
case|:
case|case
name|dns_rcode_yxdomain
case|:
case|case
name|dns_rcode_yxrrset
case|:
case|case
name|dns_rcode_nxrrset
case|:
case|case
name|dns_rcode_refused
case|:
case|case
name|dns_rcode_nxdomain
case|:
block|{
name|char
name|rcode
index|[
literal|128
index|]
decl_stmt|;
name|isc_buffer_t
name|rb
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|rb
argument_list|,
name|rcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rcode_totext
argument_list|(
name|msg
operator|->
name|rcode
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"forwarded dynamic update: "
literal|"master %s returned: %.*s"
argument_list|,
name|master
argument_list|,
operator|(
name|int
operator|)
name|rb
operator|.
name|used
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* These should not occur if the masters/zone are valid. */
case|case
name|dns_rcode_notzone
case|:
case|case
name|dns_rcode_notauth
case|:
block|{
name|char
name|rcode
index|[
literal|128
index|]
decl_stmt|;
name|isc_buffer_t
name|rb
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|rb
argument_list|,
name|rcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rcode_totext
argument_list|(
name|msg
operator|->
name|rcode
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"forwarding dynamic update: "
literal|"unexpected response: master %s returned: %.*s"
argument_list|,
name|master
argument_list|,
operator|(
name|int
operator|)
name|rb
operator|.
name|used
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
goto|goto
name|next_master
goto|;
block|}
comment|/* Try another server for these rcodes. */
case|case
name|dns_rcode_formerr
case|:
case|case
name|dns_rcode_servfail
case|:
case|case
name|dns_rcode_notimp
case|:
case|case
name|dns_rcode_badvers
case|:
default|default:
goto|goto
name|next_master
goto|;
block|}
comment|/* call callback */
call|(
name|forward
operator|->
name|callback
call|)
argument_list|(
name|forward
operator|->
name|callback_arg
argument_list|,
name|ISC_R_SUCCESS
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|forward
operator|->
name|request
argument_list|)
expr_stmt|;
name|forward_destroy
argument_list|(
name|forward
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
name|next_master
label|:
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|forward
operator|->
name|which
operator|++
expr_stmt|;
name|dns_request_destroy
argument_list|(
operator|&
name|forward
operator|->
name|request
argument_list|)
expr_stmt|;
name|result
operator|=
name|sendtomaster
argument_list|(
name|forward
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* call callback */
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"exhausted dynamic update forwarder list"
argument_list|)
expr_stmt|;
call|(
name|forward
operator|->
name|callback
call|)
argument_list|(
name|forward
operator|->
name|callback_arg
argument_list|,
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|forward_destroy
argument_list|(
name|forward
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_forwardupdate
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_updatecallback_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|dns_forward_t
modifier|*
name|forward
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
modifier|*
name|mr
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|msg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|callback
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|forward
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|forward
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|forward
operator|->
name|request
operator|=
name|NULL
expr_stmt|;
name|forward
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|forward
operator|->
name|msgbuf
operator|=
name|NULL
expr_stmt|;
name|forward
operator|->
name|which
operator|=
literal|0
expr_stmt|;
name|forward
operator|->
name|mctx
operator|=
literal|0
expr_stmt|;
name|forward
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|forward
operator|->
name|callback_arg
operator|=
name|callback_arg
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|forward
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|forward
operator|->
name|magic
operator|=
name|FORWARD_MAGIC
expr_stmt|;
name|mr
operator|=
name|dns_message_getrawmessage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_UNEXPECTEDEND
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|forward
operator|->
name|msgbuf
argument_list|,
name|mr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|isc_buffer_copyregion
argument_list|(
name|forward
operator|->
name|msgbuf
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|isc_mem_attach
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|forward
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|forward
operator|->
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|sendtomaster
argument_list|(
name|forward
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|forward_destroy
argument_list|(
name|forward
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_next
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|next
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|next
operator|!=
name|NULL
operator|&&
operator|*
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
else|else
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_first
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|first
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|first
operator|!=
name|NULL
operator|&&
operator|*
name|first
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|first
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
else|else
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  ***	Zone manager.  ***/
end_comment

begin_function
name|isc_result_t
name|dns_zonemgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|socketmgr
parameter_list|,
name|dns_zonemgr_t
modifier|*
modifier|*
name|zmgrp
parameter_list|)
block|{
name|dns_zonemgr_t
modifier|*
name|zmgr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|zmgr
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|zmgr
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|zmgr
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|taskmgr
operator|=
name|taskmgr
expr_stmt|;
name|zmgr
operator|->
name|timermgr
operator|=
name|timermgr
expr_stmt|;
name|zmgr
operator|->
name|socketmgr
operator|=
name|socketmgr
expr_stmt|;
name|zmgr
operator|->
name|zonetasks
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|loadtasks
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|mctxpool
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|notifyrl
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|refreshrl
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zmgr
operator|->
name|xfrin_in_progress
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|zmgr
operator|->
name|unreachable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zmgr
operator|->
name|unreachable
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_mem
goto|;
name|zmgr
operator|->
name|transfersin
operator|=
literal|10
expr_stmt|;
name|zmgr
operator|->
name|transfersperns
operator|=
literal|2
expr_stmt|;
comment|/* Unreachable lock. */
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_rwlock
goto|;
comment|/* Create a single task for queueing of SOA queries. */
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|1
argument_list|,
operator|&
name|zmgr
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_urlock
goto|;
name|isc_task_setname
argument_list|(
name|zmgr
operator|->
name|task
argument_list|,
literal|"zmgr"
argument_list|,
name|zmgr
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_create
argument_list|(
name|mctx
argument_list|,
name|timermgr
argument_list|,
name|zmgr
operator|->
name|task
argument_list|,
operator|&
name|zmgr
operator|->
name|notifyrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_task
goto|;
name|result
operator|=
name|isc_ratelimiter_create
argument_list|(
name|mctx
argument_list|,
name|timermgr
argument_list|,
name|zmgr
operator|->
name|task
argument_list|,
operator|&
name|zmgr
operator|->
name|refreshrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_notifyrl
goto|;
comment|/* default to 20 refresh queries / notifies per second. */
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
literal|0
argument_list|,
literal|1000000000
operator|/
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_setinterval
argument_list|(
name|zmgr
operator|->
name|notifyrl
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_ratelimiter_setpertic
argument_list|(
name|zmgr
operator|->
name|notifyrl
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_setinterval
argument_list|(
name|zmgr
operator|->
name|refreshrl
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_ratelimiter_setpertic
argument_list|(
name|zmgr
operator|->
name|refreshrl
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|iolimit
operator|=
literal|1
expr_stmt|;
name|zmgr
operator|->
name|ioactive
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zmgr
operator|->
name|high
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|zmgr
operator|->
name|low
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_refreshrl
goto|;
name|zmgr
operator|->
name|magic
operator|=
name|ZONEMGR_MAGIC
expr_stmt|;
operator|*
name|zmgrp
operator|=
name|zmgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|#
directive|if
literal|0
block|free_iolock: 	DESTROYLOCK(&zmgr->iolock);
endif|#
directive|endif
name|free_refreshrl
label|:
name|isc_ratelimiter_detach
argument_list|(
operator|&
name|zmgr
operator|->
name|refreshrl
argument_list|)
expr_stmt|;
name|free_notifyrl
label|:
name|isc_ratelimiter_detach
argument_list|(
operator|&
name|zmgr
operator|->
name|notifyrl
argument_list|)
expr_stmt|;
name|free_task
label|:
name|isc_task_detach
argument_list|(
operator|&
name|zmgr
operator|->
name|task
argument_list|)
expr_stmt|;
name|free_urlock
label|:
name|isc_rwlock_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|)
expr_stmt|;
name|free_rwlock
label|:
name|isc_rwlock_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|)
expr_stmt|;
name|free_mem
label|:
name|isc_mem_put
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|zmgr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zonemgr_createzone
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|mctxpool
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|item
operator|=
name|isc_pool_get
argument_list|(
name|zmgr
operator|->
name|mctxpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|isc_mem_attach
argument_list|(
operator|(
name|isc_mem_t
operator|*
operator|)
name|item
argument_list|,
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_zone_create
argument_list|(
operator|&
name|zone
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|*
name|zonep
operator|=
name|zone
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zonemgr_managezone
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|zonetasks
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|task
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|timer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|zmgr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_taskpool_gettask
argument_list|(
name|zmgr
operator|->
name|zonetasks
argument_list|,
operator|&
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_taskpool_gettask
argument_list|(
name|zmgr
operator|->
name|loadtasks
argument_list|,
operator|&
name|zone
operator|->
name|loadtask
argument_list|)
expr_stmt|;
comment|/* 	 * Set the task name.  The tag will arbitrarily point to one 	 * of the zones sharing the task (in practice, the one 	 * to be managed last). 	 */
name|isc_task_setname
argument_list|(
name|zone
operator|->
name|task
argument_list|,
literal|"zone"
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|isc_task_setname
argument_list|(
name|zone
operator|->
name|loadtask
argument_list|,
literal|"loadzone"
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_create
argument_list|(
name|zmgr
operator|->
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|zone_timer
argument_list|,
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_tasks
goto|;
comment|/* 	 * The timer "holds" a iref. 	 */
name|zone
operator|->
name|irefs
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|irefs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|,
name|zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|zone
operator|->
name|zmgr
operator|=
name|zmgr
expr_stmt|;
name|zmgr
operator|->
name|refs
operator|++
expr_stmt|;
goto|goto
name|unlock
goto|;
name|cleanup_tasks
label|:
name|isc_task_detach
argument_list|(
operator|&
name|zone
operator|->
name|loadtask
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|zone
operator|->
name|task
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_releasezone
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_boolean_t
name|free_now
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|zmgr
operator|==
name|zmgr
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|,
name|zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|zone
operator|->
name|zmgr
operator|=
name|NULL
expr_stmt|;
name|zmgr
operator|->
name|refs
operator|--
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|refs
operator|==
literal|0
condition|)
name|free_now
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_now
condition|)
name|zonemgr_free
argument_list|(
name|zmgr
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|zone
operator|->
name|zmgr
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_attach
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|source
parameter_list|,
name|dns_zonemgr_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|source
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|source
operator|->
name|refs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|source
operator|->
name|refs
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|refs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|source
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_detach
parameter_list|(
name|dns_zonemgr_t
modifier|*
modifier|*
name|zmgrp
parameter_list|)
block|{
name|dns_zonemgr_t
modifier|*
name|zmgr
decl_stmt|;
name|isc_boolean_t
name|free_now
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|zmgrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zmgr
operator|=
operator|*
name|zmgrp
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|refs
operator|--
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|refs
operator|==
literal|0
condition|)
name|free_now
operator|=
name|ISC_TRUE
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_now
condition|)
name|zonemgr_free
argument_list|(
name|zmgr
argument_list|)
expr_stmt|;
operator|*
name|zmgrp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zonemgr_forcemaint
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|p
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_zone_maintenance
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Recent configuration changes may have increased the 	 * amount of available transfers quota.  Make sure any 	 * transfers currently blocked on quota get started if 	 * possible. 	 */
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|zmgr_resume_xfrs
argument_list|(
name|zmgr
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_resumexfrs
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|zmgr_resume_xfrs
argument_list|(
name|zmgr
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_shutdown
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|isc_ratelimiter_shutdown
argument_list|(
name|zmgr
operator|->
name|notifyrl
argument_list|)
expr_stmt|;
name|isc_ratelimiter_shutdown
argument_list|(
name|zmgr
operator|->
name|refreshrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|zonetasks
operator|!=
name|NULL
condition|)
name|isc_taskpool_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|zonetasks
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|loadtasks
operator|!=
name|NULL
condition|)
name|isc_taskpool_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|loadtasks
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|mctxpool
operator|!=
name|NULL
condition|)
name|isc_pool_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|mctxpool
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
init|;
name|zone
operator|!=
name|NULL
condition|;
name|zone
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|link
argument_list|)
control|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|forward_cancel
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|mctxinit
parameter_list|(
name|void
modifier|*
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mem_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_mem_setname
argument_list|(
name|mctx
argument_list|,
literal|"zonemgr-pool"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|mctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mctxfree
parameter_list|(
name|void
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
init|=
operator|*
operator|(
name|isc_mem_t
operator|*
operator|*
operator|)
name|target
decl_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ZONES_PER_TASK
value|100
end_define

begin_define
define|#
directive|define
name|ZONES_PER_MCTX
value|1000
end_define

begin_function
name|isc_result_t
name|dns_zonemgr_setsize
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|int
name|num_zones
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|int
name|ntasks
init|=
name|num_zones
operator|/
name|ZONES_PER_TASK
decl_stmt|;
name|int
name|nmctx
init|=
name|num_zones
operator|/
name|ZONES_PER_MCTX
decl_stmt|;
name|isc_taskpool_t
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
name|isc_pool_t
modifier|*
name|mctxpool
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * For anything fewer than 1000 zones we use 10 tasks in 	 * the task pools.  More than that, and we'll scale at one 	 * task per 100 zones.  Similarly, for anything smaller than 	 * 2000 zones we use 2 memory contexts, then scale at 1:1000. 	 */
if|if
condition|(
name|ntasks
operator|<
literal|10
condition|)
name|ntasks
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|nmctx
operator|<
literal|2
condition|)
name|nmctx
operator|=
literal|2
expr_stmt|;
comment|/* Create or resize the zone task pools. */
if|if
condition|(
name|zmgr
operator|->
name|zonetasks
operator|==
name|NULL
condition|)
name|result
operator|=
name|isc_taskpool_create
argument_list|(
name|zmgr
operator|->
name|taskmgr
argument_list|,
name|zmgr
operator|->
name|mctx
argument_list|,
name|ntasks
argument_list|,
literal|2
argument_list|,
operator|&
name|pool
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|isc_taskpool_expand
argument_list|(
operator|&
name|zmgr
operator|->
name|zonetasks
argument_list|,
name|ntasks
argument_list|,
operator|&
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|zmgr
operator|->
name|zonetasks
operator|=
name|pool
expr_stmt|;
name|pool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|loadtasks
operator|==
name|NULL
condition|)
name|result
operator|=
name|isc_taskpool_create
argument_list|(
name|zmgr
operator|->
name|taskmgr
argument_list|,
name|zmgr
operator|->
name|mctx
argument_list|,
name|ntasks
argument_list|,
literal|2
argument_list|,
operator|&
name|pool
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|isc_taskpool_expand
argument_list|(
operator|&
name|zmgr
operator|->
name|loadtasks
argument_list|,
name|ntasks
argument_list|,
operator|&
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|zmgr
operator|->
name|loadtasks
operator|=
name|pool
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND9
comment|/* 	 * We always set all tasks in the zone-load task pool to 	 * privileged.  This prevents other tasks in the system from 	 * running while the server task manager is in privileged 	 * mode. 	 * 	 * NOTE: If we start using task privileges for any other 	 * part of the system than zone tasks, then this will need to be 	 * revisted.  In that case we'd want to turn on privileges for 	 * zone tasks only when we were loading, and turn them off the 	 * rest of the time.  For now, however, it's okay to just 	 * set it and forget it. 	 */
name|isc_taskpool_setprivilege
argument_list|(
name|zmgr
operator|->
name|loadtasks
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create or resize the zone memory context pool. */
if|if
condition|(
name|zmgr
operator|->
name|mctxpool
operator|==
name|NULL
condition|)
name|result
operator|=
name|isc_pool_create
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|nmctx
argument_list|,
name|mctxfree
argument_list|,
name|mctxinit
argument_list|,
name|NULL
argument_list|,
operator|&
name|mctxpool
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|isc_pool_expand
argument_list|(
operator|&
name|zmgr
operator|->
name|mctxpool
argument_list|,
name|nmctx
argument_list|,
operator|&
name|mctxpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|zmgr
operator|->
name|mctxpool
operator|=
name|mctxpool
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zonemgr_free
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|INSIST
argument_list|(
name|zmgr
operator|->
name|refs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
name|isc_ratelimiter_detach
argument_list|(
operator|&
name|zmgr
operator|->
name|notifyrl
argument_list|)
expr_stmt|;
name|isc_ratelimiter_detach
argument_list|(
operator|&
name|zmgr
operator|->
name|refreshrl
argument_list|)
expr_stmt|;
name|isc_rwlock_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|)
expr_stmt|;
name|isc_rwlock_destroy
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|zmgr
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|zmgr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_settransfersin
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_uint32_t
name|value
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|transfersin
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zonemgr_getttransfersin
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zmgr
operator|->
name|transfersin
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_settransfersperns
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_uint32_t
name|value
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|transfersperns
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zonemgr_getttransfersperns
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zmgr
operator|->
name|transfersperns
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to start a new incoming zone transfer to fill a quota  * slot that was just vacated.  *  * Requires:  *	The zone manager is locked by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|zmgr_resume_xfrs
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_boolean_t
name|multi
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_zone_t
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|)
init|;
name|zone
operator|!=
name|NULL
condition|;
name|zone
operator|=
name|next
control|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|result
operator|=
name|zmgr_start_xfrin_ifquota
argument_list|(
name|zmgr
argument_list|,
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|multi
condition|)
continue|continue;
comment|/* 			 * We successfully filled the slot.  We're done. 			 */
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_QUOTA
condition|)
block|{
comment|/* 			 * Not enough quota.  This is probably the per-server 			 * quota, because we usually get called when a unit of 			 * global quota has just been freed.  Try the next 			 * zone, it may succeed if it uses another master. 			 */
continue|continue;
block|}
else|else
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"starting zone transfer: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Try to start an incoming zone transfer for 'zone', quota permitting.  *  * Requires:  *	The zone manager is locked by the caller.  *  * Returns:  *	ISC_R_SUCCESS	There was enough quota and we attempted to  *			start a transfer.  zone_xfrdone() has been or will  *			be called.  *	ISC_R_QUOTA	Not enough quota.  *	Others		Failure.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|zmgr_start_xfrin_ifquota
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|masterip
decl_stmt|;
name|isc_uint32_t
name|nxfrsin
decl_stmt|,
name|nxfrsperns
decl_stmt|;
name|dns_zone_t
modifier|*
name|x
decl_stmt|;
name|isc_uint32_t
name|maxtransfersin
decl_stmt|,
name|maxtransfersperns
decl_stmt|;
name|isc_event_t
modifier|*
name|e
decl_stmt|;
comment|/* 	 * If we are exiting just pretend we got quota so the zone will 	 * be cleaned up in the zone's task context. 	 */
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_EXITING
argument_list|)
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|gotquota
goto|;
block|}
comment|/* 	 * Find any configured information about the server we'd 	 * like to transfer this zone from. 	 */
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|masterip
argument_list|,
operator|&
name|zone
operator|->
name|masteraddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|zone
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|masterip
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the total maximum number of simultaneous 	 * transfers allowed, and the maximum for this specific 	 * master. 	 */
name|maxtransfersin
operator|=
name|zmgr
operator|->
name|transfersin
expr_stmt|;
name|maxtransfersperns
operator|=
name|zmgr
operator|->
name|transfersperns
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_peer_gettransfers
argument_list|(
name|peer
argument_list|,
operator|&
name|maxtransfersperns
argument_list|)
expr_stmt|;
comment|/* 	 * Count the total number of transfers that are in progress, 	 * and the number of transfers in progress from this master. 	 * We linearly scan a list of all transfers; if this turns 	 * out to be too slow, we could hash on the master address. 	 */
name|nxfrsin
operator|=
name|nxfrsperns
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|xfrin_in_progress
argument_list|)
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|x
argument_list|,
name|statelink
argument_list|)
control|)
block|{
name|isc_netaddr_t
name|xip
decl_stmt|;
name|LOCK_ZONE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|xip
argument_list|,
operator|&
name|x
operator|->
name|masteraddr
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|nxfrsin
operator|++
expr_stmt|;
if|if
condition|(
name|isc_netaddr_equal
argument_list|(
operator|&
name|xip
argument_list|,
operator|&
name|masterip
argument_list|)
condition|)
name|nxfrsperns
operator|++
expr_stmt|;
block|}
comment|/* Enforce quota. */
if|if
condition|(
name|nxfrsin
operator|>=
name|maxtransfersin
condition|)
return|return
operator|(
name|ISC_R_QUOTA
operator|)
return|;
if|if
condition|(
name|nxfrsperns
operator|>=
name|maxtransfersperns
condition|)
return|return
operator|(
name|ISC_R_QUOTA
operator|)
return|;
name|gotquota
label|:
comment|/* 	 * We have sufficient quota.  Move the zone to the "xfrin_in_progress" 	 * list and send it an event to let it start the actual transfer in the 	 * context of its own task. 	 */
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|zmgr
argument_list|,
name|DNS_EVENT_ZONESTARTXFRIN
argument_list|,
name|got_transfer_quota
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zone
operator|->
name|statelist
operator|==
operator|&
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|,
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|zmgr
operator|->
name|xfrin_in_progress
argument_list|,
name|zone
argument_list|,
name|statelink
argument_list|)
expr_stmt|;
name|zone
operator|->
name|statelist
operator|=
operator|&
name|zmgr
operator|->
name|xfrin_in_progress
expr_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"Transfer started."
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_setiolimit
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_uint32_t
name|iolimit
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iolimit
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|iolimit
operator|=
name|iolimit
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zonemgr_getiolimit
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zmgr
operator|->
name|iolimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get permission to request a file handle from the OS.  * An event will be sent to action when one is available.  * There are two queues available (high and low), the high  * queue will be serviced before the low one.  *  * zonemgr_putio() must be called after the event is delivered to  * 'action'.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|zonemgr_getio
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_boolean_t
name|high
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_io_t
modifier|*
modifier|*
name|iop
parameter_list|)
block|{
name|dns_io_t
modifier|*
name|io
decl_stmt|;
name|isc_boolean_t
name|queue
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iop
operator|!=
name|NULL
operator|&&
operator|*
name|iop
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|io
operator|=
name|isc_mem_get
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|io
operator|->
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
name|DNS_EVENT_IOREADY
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
operator|->
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|event
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|io
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|io
operator|->
name|zmgr
operator|=
name|zmgr
expr_stmt|;
name|io
operator|->
name|high
operator|=
name|high
expr_stmt|;
name|io
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|io
operator|->
name|task
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|io
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|io
operator|->
name|magic
operator|=
name|IO_MAGIC
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|ioactive
operator|++
expr_stmt|;
name|queue
operator|=
name|ISC_TF
argument_list|(
name|zmgr
operator|->
name|ioactive
operator|>
name|zmgr
operator|->
name|iolimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|high
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|zmgr
operator|->
name|high
argument_list|,
name|io
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_APPEND
argument_list|(
name|zmgr
operator|->
name|low
argument_list|,
name|io
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
operator|*
name|iop
operator|=
name|io
expr_stmt|;
if|if
condition|(
operator|!
name|queue
condition|)
name|isc_task_send
argument_list|(
name|io
operator|->
name|task
argument_list|,
operator|&
name|io
operator|->
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zonemgr_putio
parameter_list|(
name|dns_io_t
modifier|*
modifier|*
name|iop
parameter_list|)
block|{
name|dns_io_t
modifier|*
name|io
decl_stmt|;
name|dns_io_t
modifier|*
name|next
decl_stmt|;
name|dns_zonemgr_t
modifier|*
name|zmgr
decl_stmt|;
name|REQUIRE
argument_list|(
name|iop
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|io
operator|=
operator|*
name|iop
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_IO_VALID
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|iop
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|io
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|io
operator|->
name|event
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zmgr
operator|=
name|io
operator|->
name|zmgr
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|io
operator|->
name|task
argument_list|)
expr_stmt|;
name|io
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zmgr
operator|->
name|mctx
argument_list|,
name|io
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zmgr
operator|->
name|ioactive
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|ioactive
operator|--
expr_stmt|;
name|next
operator|=
name|HEAD
argument_list|(
name|zmgr
operator|->
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|next
operator|=
name|HEAD
argument_list|(
name|zmgr
operator|->
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|high
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|zmgr
operator|->
name|high
argument_list|,
name|next
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_UNLINK
argument_list|(
name|zmgr
operator|->
name|low
argument_list|,
name|next
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|next
operator|->
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|isc_task_send
argument_list|(
name|next
operator|->
name|task
argument_list|,
operator|&
name|next
operator|->
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zonemgr_cancelio
parameter_list|(
name|dns_io_t
modifier|*
name|io
parameter_list|)
block|{
name|isc_boolean_t
name|send_event
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_IO_VALID
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are queued to be run then dequeue. 	 */
name|LOCK
argument_list|(
operator|&
name|io
operator|->
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|io
argument_list|,
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|high
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|io
operator|->
name|zmgr
operator|->
name|high
argument_list|,
name|io
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_UNLINK
argument_list|(
name|io
operator|->
name|zmgr
operator|->
name|low
argument_list|,
name|io
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|send_event
operator|=
name|ISC_TRUE
expr_stmt|;
name|INSIST
argument_list|(
name|io
operator|->
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|io
operator|->
name|zmgr
operator|->
name|iolock
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_event
condition|)
block|{
name|io
operator|->
name|event
operator|->
name|ev_attributes
operator||=
name|ISC_EVENTATTR_CANCELED
expr_stmt|;
name|isc_task_send
argument_list|(
name|io
operator|->
name|task
argument_list|,
operator|&
name|io
operator|->
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zone_saveunique
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|templat
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|templat
argument_list|)
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|result
operator|=
name|isc_file_template
argument_list|(
name|path
argument_list|,
name|templat
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|isc_file_renameunique
argument_list|(
name|path
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unable to load from '%s'; "
literal|"renaming file to '%s' for failure analysis and "
literal|"retransferring."
argument_list|,
name|path
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Hook for ondestroy notification from a database. */
end_comment

begin_endif
unit|static void dns_zonemgr_dbdestroyed(isc_task_t *task, isc_event_t *event) { 	dns_db_t *db = event->sender; 	UNUSED(task);  	isc_event_free(&event);  	isc_log_write(dns_lctx, DNS_LOGCATEGORY_GENERAL, 		      DNS_LOGMODULE_ZONE, ISC_LOG_DEBUG(3), 		      "database (%p) destroyed", (void*) db); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|dns_zonemgr_setserialqueryrate
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_uint32_t
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|isc_uint32_t
name|pertic
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|s
operator|=
literal|1
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
name|pertic
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|<=
literal|10
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|ns
operator|=
literal|1000000000
operator|/
name|value
expr_stmt|;
name|pertic
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|ns
operator|=
operator|(
literal|1000000000
operator|/
name|value
operator|)
operator|*
literal|10
expr_stmt|;
name|pertic
operator|=
literal|10
expr_stmt|;
block|}
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_setinterval
argument_list|(
name|zmgr
operator|->
name|notifyrl
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_ratelimiter_setpertic
argument_list|(
name|zmgr
operator|->
name|notifyrl
argument_list|,
name|pertic
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_ratelimiter_setinterval
argument_list|(
name|zmgr
operator|->
name|refreshrl
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_ratelimiter_setpertic
argument_list|(
name|zmgr
operator|->
name|refreshrl
argument_list|,
name|pertic
argument_list|)
expr_stmt|;
name|zmgr
operator|->
name|serialqueryrate
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_zonemgr_getserialqueryrate
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zmgr
operator|->
name|serialqueryrate
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zonemgr_unreachable
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|remote
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|seconds
init|=
name|isc_time_seconds
argument_list|(
name|now
argument_list|)
decl_stmt|;
name|isc_uint32_t
name|count
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNREACH_CHACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|expire
operator|>=
name|seconds
operator|&&
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|remote
argument_list|,
name|remote
argument_list|)
operator|&&
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|local
argument_list|,
name|local
argument_list|)
condition|)
block|{
name|result
operator|=
name|isc_rwlock_tryupgrade
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|last
operator|=
name|seconds
expr_stmt|;
name|count
operator|=
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
break|break;
block|}
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|i
operator|<
name|UNREACH_CHACHE_SIZE
operator|&&
name|count
operator|>
literal|1U
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_unreachabledel
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|remote
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|master
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|source
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_format
argument_list|(
name|remote
argument_list|,
name|master
argument_list|,
sizeof|sizeof
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
name|local
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNREACH_CHACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|remote
argument_list|,
name|remote
argument_list|)
operator|&&
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|local
argument_list|,
name|local
argument_list|)
condition|)
block|{
if|if
condition|(
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|expire
operator|==
literal|0
condition|)
break|break;
name|result
operator|=
name|isc_rwlock_tryupgrade
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"master %s (source %s) deleted "
literal|"from unreachable cache"
argument_list|,
name|master
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zonemgr_unreachableadd
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|remote
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
block|{
name|isc_uint32_t
name|seconds
init|=
name|isc_time_seconds
argument_list|(
name|now
argument_list|)
decl_stmt|;
name|isc_uint32_t
name|last
init|=
name|seconds
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|slot
init|=
name|UNREACH_CHACHE_SIZE
decl_stmt|,
name|oldest
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNREACH_CHACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* Existing entry? */
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|remote
argument_list|,
name|remote
argument_list|)
operator|&&
name|isc_sockaddr_equal
argument_list|(
operator|&
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|local
argument_list|,
name|local
argument_list|)
condition|)
break|break;
comment|/* Empty slot? */
if|if
condition|(
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|expire
operator|<
name|seconds
condition|)
name|slot
operator|=
name|i
expr_stmt|;
comment|/* Least recently used slot? */
if|if
condition|(
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|last
operator|<
name|last
condition|)
block|{
name|last
operator|=
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|last
expr_stmt|;
name|oldest
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|UNREACH_CHACHE_SIZE
condition|)
block|{
comment|/* 		 * Found a existing entry.  Update the expire timer and 		 * last usage timestamps. 		 */
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|seconds
operator|+
name|UNREACH_HOLD_TIME
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|last
operator|=
name|seconds
expr_stmt|;
if|if
condition|(
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|expire
operator|<
name|seconds
condition|)
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
else|else
name|zmgr
operator|->
name|unreachable
index|[
name|i
index|]
operator|.
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slot
operator|!=
name|UNREACH_CHACHE_SIZE
condition|)
block|{
comment|/* 		 * Found a empty slot. Add a new entry to the cache. 		 */
name|zmgr
operator|->
name|unreachable
index|[
name|slot
index|]
operator|.
name|expire
operator|=
name|seconds
operator|+
name|UNREACH_HOLD_TIME
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|slot
index|]
operator|.
name|last
operator|=
name|seconds
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|slot
index|]
operator|.
name|remote
operator|=
operator|*
name|remote
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|slot
index|]
operator|.
name|local
operator|=
operator|*
name|local
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|slot
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Replace the least recently used entry in the cache. 		 */
name|zmgr
operator|->
name|unreachable
index|[
name|oldest
index|]
operator|.
name|expire
operator|=
name|seconds
operator|+
name|UNREACH_HOLD_TIME
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|oldest
index|]
operator|.
name|last
operator|=
name|seconds
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|oldest
index|]
operator|.
name|remote
operator|=
operator|*
name|remote
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|oldest
index|]
operator|.
name|local
operator|=
operator|*
name|local
expr_stmt|;
name|zmgr
operator|->
name|unreachable
index|[
name|oldest
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|urlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_forcereload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|||
operator|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_redirect
operator|&&
name|zone
operator|->
name|masters
operator|==
name|NULL
operator|)
condition|)
return|return;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_zone_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zone_isforced
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_FORCEXFER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setstatistics
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|on
parameter_list|)
block|{
comment|/* 	 * This function is obsoleted. 	 */
name|UNUSED
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint64_t
modifier|*
name|dns_zone_getstatscounters
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
comment|/* 	 * This function is obsoleted. 	 */
name|UNUSED
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setstats
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|stats
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|isc_stats_attach
argument_list|(
name|stats
argument_list|,
operator|&
name|zone
operator|->
name|stats
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setrequeststats
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|requeststats_on
operator|&&
name|stats
operator|==
name|NULL
condition|)
name|zone
operator|->
name|requeststats_on
operator|=
name|ISC_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|zone
operator|->
name|requeststats_on
operator|&&
name|stats
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|requeststats
operator|==
name|NULL
condition|)
block|{
name|isc_stats_attach
argument_list|(
name|stats
argument_list|,
operator|&
name|zone
operator|->
name|requeststats
argument_list|)
expr_stmt|;
name|zone
operator|->
name|requeststats_on
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEWSTATS
end_ifdef

begin_function
name|void
name|dns_zone_setrcvquerystats
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|requeststats_on
operator|&&
name|stats
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|rcvquerystats
operator|==
name|NULL
condition|)
block|{
name|dns_stats_attach
argument_list|(
name|stats
argument_list|,
operator|&
name|zone
operator|->
name|rcvquerystats
argument_list|)
expr_stmt|;
name|zone
operator|->
name|requeststats_on
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_stats_t
modifier|*
name|dns_zone_getrequeststats
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
comment|/* 	 * We don't lock zone for efficiency reason.  This is not catastrophic 	 * because requeststats must always be valid when requeststats_on is 	 * true. 	 * Some counters may be incremented while requeststats_on is becoming 	 * false, or some cannot be incremented just after the statistics are 	 * installed, but it shouldn't matter much in practice. 	 */
if|if
condition|(
name|zone
operator|->
name|requeststats_on
condition|)
return|return
operator|(
name|zone
operator|->
name|requeststats
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEWSTATS
end_ifdef

begin_comment
comment|/*  * Return the received query stats bucket  * see note from dns_zone_getrequeststats()  */
end_comment

begin_function
name|dns_stats_t
modifier|*
name|dns_zone_getrcvquerystats
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|->
name|requeststats_on
condition|)
return|return
operator|(
name|zone
operator|->
name|rcvquerystats
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dns_zone_dialup
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone_debuglog
argument_list|(
name|zone
argument_list|,
literal|"dns_zone_dialup"
argument_list|,
literal|3
argument_list|,
literal|"notify = %d, refresh = %d"
argument_list|,
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
argument_list|)
argument_list|,
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALREFRESH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
argument_list|)
condition|)
name|dns_zone_notify
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|!=
name|dns_zone_master
operator|&&
name|zone
operator|->
name|masters
operator|!=
name|NULL
operator|&&
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALREFRESH
argument_list|)
condition|)
name|dns_zone_refresh
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setdialup
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_dialuptype_t
name|dialup
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_CLRFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
operator||
name|DNS_ZONEFLG_DIALREFRESH
operator||
name|DNS_ZONEFLG_NOREFRESH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dialup
condition|)
block|{
case|case
name|dns_dialuptype_no
case|:
break|break;
case|case
name|dns_dialuptype_yes
case|:
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
operator|(
name|DNS_ZONEFLG_DIALNOTIFY
operator||
name|DNS_ZONEFLG_DIALREFRESH
operator||
name|DNS_ZONEFLG_NOREFRESH
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_dialuptype_notify
case|:
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_dialuptype_notifypassive
case|:
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALNOTIFY
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOREFRESH
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_dialuptype_refresh
case|:
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_DIALREFRESH
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOREFRESH
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_dialuptype_passive
case|:
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NOREFRESH
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setkeydirectory
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_zone_setstring
argument_list|(
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|keydirectory
argument_list|,
name|directory
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dns_zone_getkeydirectory
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|keydirectory
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_zonemgr_getcount
parameter_list|(
name|dns_zonemgr_t
modifier|*
name|zmgr
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONEMGR_VALID
argument_list|(
name|zmgr
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DNS_ZONESTATE_XFERRUNNING
case|:
for|for
control|(
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|xfrin_in_progress
argument_list|)
init|;
name|zone
operator|!=
name|NULL
condition|;
name|zone
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|statelink
argument_list|)
control|)
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|DNS_ZONESTATE_XFERDEFERRED
case|:
for|for
control|(
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|waiting_for_xfrin
argument_list|)
init|;
name|zone
operator|!=
name|NULL
condition|;
name|zone
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|statelink
argument_list|)
control|)
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|DNS_ZONESTATE_SOAQUERY
case|:
for|for
control|(
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
init|;
name|zone
operator|!=
name|NULL
condition|;
name|zone
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|DNS_ZONE_FLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_REFRESH
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|DNS_ZONESTATE_ANY
case|:
for|for
control|(
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|)
init|;
name|zone
operator|!=
name|NULL
condition|;
name|zone
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|zone
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_view_t
modifier|*
name|view
init|=
name|zone
operator|->
name|view
decl_stmt|;
if|if
condition|(
name|view
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|view
operator|->
name|name
argument_list|,
literal|"_bind"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_checknames
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|isc_boolean_t
name|ok
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|fail
init|=
name|ISC_FALSE
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf2
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_WARNING
decl_stmt|;
name|dns_name_t
name|bad
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKNAMES
argument_list|)
operator|&&
name|rdata
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec3
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_CHECKNAMESFAIL
argument_list|)
operator|||
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
block|{
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
name|fail
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ok
operator|=
name|dns_rdata_checkowner
argument_list|(
name|name
argument_list|,
name|rdata
operator|->
name|rdclass
argument_list|,
name|rdata
operator|->
name|type
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdata
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/%s: %s"
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|dns_result_totext
argument_list|(
name|DNS_R_BADOWNERNAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
return|return
operator|(
name|DNS_R_BADOWNERNAME
operator|)
return|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|bad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ok
operator|=
name|dns_rdata_checknames
argument_list|(
name|rdata
argument_list|,
name|name
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|bad
argument_list|,
name|namebuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf2
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdata
operator|->
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|level
argument_list|,
literal|"%s/%s: %s: %s "
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|namebuf2
argument_list|,
name|dns_result_totext
argument_list|(
name|DNS_R_BADNAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
return|return
operator|(
name|DNS_R_BADNAME
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setcheckmx
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_checkmxfunc_t
name|checkmx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|checkmx
operator|=
name|checkmx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setchecksrv
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_checksrvfunc_t
name|checksrv
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|checksrv
operator|=
name|checksrv
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setcheckns
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_checknsfunc_t
name|checkns
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|checkns
operator|=
name|checkns
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setisself
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_isselffunc_t
name|isself
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|isself
operator|=
name|isself
expr_stmt|;
name|zone
operator|->
name|isselfarg
operator|=
name|arg
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setnotifydelay
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|delay
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|notifydelay
operator|=
name|delay
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_zone_getnotifydelay
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|notifydelay
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_signwithkey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_secalg_t
name|algorithm
parameter_list|,
name|isc_uint16_t
name|keyid
parameter_list|,
name|isc_boolean_t
name|delete
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"dns_zone_signwithkey(algorithm=%u, keyid=%u)"
argument_list|,
name|algorithm
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_signwithkey
argument_list|(
name|zone
argument_list|,
name|algorithm
argument_list|,
name|keyid
argument_list|,
name|delete
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|dns_zone_addnsec3chain
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdata_nsec3param_t
modifier|*
name|nsec3param
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
name|salt
index|[
literal|255
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|->
name|salt_length
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
operator|(
name|nsec3param
operator|->
name|salt_length
operator|*
literal|2U
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|salt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nsec3param
operator|->
name|salt_length
condition|;
name|i
operator|++
control|)
block|{
name|salt
index|[
name|j
operator|++
index|]
operator|=
name|hex
index|[
operator|(
name|nsec3param
operator|->
name|salt
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|salt
index|[
name|j
operator|++
index|]
operator|=
name|hex
index|[
name|nsec3param
operator|->
name|salt
index|[
name|i
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
name|salt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|salt
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"dns_zone_addnsec3chain(hash=%u, iterations=%u, salt=%s)"
argument_list|,
name|nsec3param
operator|->
name|hash
argument_list|,
name|nsec3param
operator|->
name|iterations
argument_list|,
name|salt
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|zone_addnsec3chain
argument_list|(
name|zone
argument_list|,
name|nsec3param
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setnodes
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|nodes
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|0
condition|)
name|nodes
operator|=
literal|1
expr_stmt|;
name|zone
operator|->
name|nodes
operator|=
name|nodes
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setsignatures
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|signatures
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We treat signatures as a signed value so explicitly 	 * limit its range here. 	 */
if|if
condition|(
name|signatures
operator|>
name|ISC_INT32_MAX
condition|)
name|signatures
operator|=
name|ISC_INT32_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|signatures
operator|==
literal|0
condition|)
name|signatures
operator|=
literal|1
expr_stmt|;
name|zone
operator|->
name|signatures
operator|=
name|signatures
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_zone_setprivatetype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|privatetype
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|dns_rdatatype_t
name|dns_zone_getprivatetype
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|privatetype
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_signwithkey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_secalg_t
name|algorithm
parameter_list|,
name|isc_uint16_t
name|keyid
parameter_list|,
name|isc_boolean_t
name|delete
parameter_list|)
block|{
name|dns_signing_t
modifier|*
name|signing
decl_stmt|;
name|dns_signing_t
modifier|*
name|current
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|signing
operator|=
name|isc_mem_get
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
sizeof|sizeof
expr|*
name|signing
argument_list|)
expr_stmt|;
if|if
condition|(
name|signing
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|signing
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|signing
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|signing
operator|->
name|dbiterator
operator|=
name|NULL
expr_stmt|;
name|signing
operator|->
name|algorithm
operator|=
name|algorithm
expr_stmt|;
name|signing
operator|->
name|keyid
operator|=
name|keyid
expr_stmt|;
name|signing
operator|->
name|delete
operator|=
name|delete
expr_stmt|;
name|signing
operator|->
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|signing
operator|->
name|db
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zone
operator|->
name|signing
argument_list|)
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|current
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|current
operator|->
name|db
operator|==
name|signing
operator|->
name|db
operator|&&
name|current
operator|->
name|algorithm
operator|==
name|signing
operator|->
name|algorithm
operator|&&
name|current
operator|->
name|keyid
operator|==
name|signing
operator|->
name|keyid
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|delete
operator|!=
name|signing
operator|->
name|delete
condition|)
name|current
operator|->
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
goto|goto
name|cleanup
goto|;
block|}
block|}
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|signing
operator|->
name|db
argument_list|,
literal|0
argument_list|,
operator|&
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_dbiterator_pause
argument_list|(
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|zone
operator|->
name|signing
argument_list|,
name|signing
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|signing
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|zone
operator|->
name|signingtime
argument_list|)
condition|)
block|{
name|zone
operator|->
name|signingtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|signing
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|signing
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|signing
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|signing
operator|->
name|dbiterator
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|signing
operator|->
name|dbiterator
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|signing
argument_list|,
sizeof|sizeof
expr|*
name|signing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|logmsg
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|isc_log_vwrite
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_keylist
parameter_list|(
name|dns_dnsseckeylist_t
modifier|*
name|list
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_dnsseckey_t
modifier|*
name|key
decl_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|list
argument_list|)
condition|)
block|{
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|list
argument_list|,
name|key
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_dnsseckey_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called once; *timep should be set to the current time. */
end_comment

begin_function
specifier|static
name|isc_result_t
name|next_keyevent
parameter_list|(
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_stdtime_t
modifier|*
name|timep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|,
name|then
init|=
literal|0
decl_stmt|,
name|event
decl_stmt|;
name|int
name|i
decl_stmt|;
name|now
operator|=
operator|*
name|timep
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|DST_MAX_TIMES
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
argument_list|,
name|i
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|event
operator|>
name|now
operator|&&
operator|(
name|then
operator|==
literal|0
operator|||
name|event
operator|<
name|then
operator|)
condition|)
name|then
operator|=
name|event
expr_stmt|;
block|}
if|if
condition|(
name|then
operator|!=
literal|0
condition|)
block|{
operator|*
name|timep
operator|=
name|then
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rr_exists
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|isc_boolean_t
modifier|*
name|flag
parameter_list|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
name|CHECK
argument_list|(
name|dns_db_findnsec3node
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|rdata
operator|->
name|type
argument_list|,
literal|0
argument_list|,
operator|(
name|isc_stdtime_t
operator|)
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
operator|*
name|flag
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|myrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|myrdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdata_compare
argument_list|(
operator|&
name|myrdata
argument_list|,
name|rdata
argument_list|)
condition|)
break|break;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|flag
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
operator|*
name|flag
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add records to signal the state of signing or of key removal.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|add_signing_records
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdatatype_t
name|privatetype
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|isc_boolean_t
name|sign_all
parameter_list|)
block|{
name|dns_difftuple_t
modifier|*
name|tuple
decl_stmt|,
modifier|*
name|newtuple
init|=
name|NULL
decl_stmt|;
name|dns_rdata_dnskey_t
name|dnskey
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_boolean_t
name|flag
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_uint16_t
name|keyid
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|dns_db_origin
argument_list|(
name|db
argument_list|)
decl_stmt|;
for|for
control|(
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|tuple
operator|!=
name|NULL
condition|;
name|tuple
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|tuple
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|!=
name|dns_rdatatype_dnskey
condition|)
continue|continue;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|tuple
operator|->
name|rdata
argument_list|,
operator|&
name|dnskey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dnskey
operator|.
name|flags
operator|&
operator|(
name|DNS_KEYFLAG_OWNERMASK
operator||
name|DNS_KEYTYPE_NOAUTH
operator|)
operator|)
operator|!=
name|DNS_KEYOWNER_ZONE
condition|)
continue|continue;
name|dns_rdata_toregion
argument_list|(
operator|&
name|tuple
operator|->
name|rdata
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|keyid
operator|=
name|dst_region_computeid
argument_list|(
operator|&
name|r
argument_list|,
name|dnskey
operator|.
name|algorithm
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|dnskey
operator|.
name|algorithm
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|keyid
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|keyid
operator|&
literal|0xff
operator|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|tuple
operator|->
name|op
operator|==
name|DNS_DIFFOP_ADD
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|rdata
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|rdata
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rdata
operator|.
name|type
operator|=
name|privatetype
expr_stmt|;
name|rdata
operator|.
name|rdclass
operator|=
name|tuple
operator|->
name|rdata
operator|.
name|rdclass
expr_stmt|;
if|if
condition|(
name|sign_all
operator|||
name|tuple
operator|->
name|op
operator|==
name|DNS_DIFFOP_DEL
condition|)
block|{
name|CHECK
argument_list|(
name|rr_exists
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|name
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|flag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
continue|continue;
name|CHECK
argument_list|(
name|dns_difftuple_create
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|newtuple
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|do_one_tuple
argument_list|(
operator|&
name|newtuple
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|newtuple
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Remove any record which says this operation has already 		 * completed. 		 */
name|buf
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|CHECK
argument_list|(
name|rr_exists
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|name
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|flag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|CHECK
argument_list|(
name|dns_difftuple_create
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|newtuple
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|do_one_tuple
argument_list|(
operator|&
name|newtuple
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|newtuple
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|sign_apex
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|zonediff_t
modifier|*
name|zonediff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|,
name|inception
decl_stmt|,
name|soaexpire
decl_stmt|;
name|isc_boolean_t
name|check_ksk
decl_stmt|,
name|keyset_kskonly
decl_stmt|;
name|dst_key_t
modifier|*
name|zone_keys
index|[
name|DNS_MAXZONEKEYS
index|]
decl_stmt|;
name|unsigned
name|int
name|nkeys
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
decl_stmt|;
name|result
operator|=
name|find_zone_keys
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|DNS_MAXZONEKEYS
argument_list|,
name|zone_keys
argument_list|,
operator|&
name|nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"sign_apex:find_zone_keys -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|inception
operator|=
name|now
operator|-
literal|3600
expr_stmt|;
comment|/* Allow for clock skew. */
name|soaexpire
operator|=
name|now
operator|+
name|dns_zone_getsigvalidityinterval
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|check_ksk
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_UPDATECHECKKSK
argument_list|)
expr_stmt|;
name|keyset_kskonly
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_DNSKEYKSKONLY
argument_list|)
expr_stmt|;
comment|/* 	 * See if update_sigs will update DNSKEY signature and if not 	 * cause them to sign so that so that newly activated keys 	 * are used. 	 */
for|for
control|(
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|tuple
operator|!=
name|NULL
condition|;
name|tuple
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|tuple
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|tuple
operator|->
name|name
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|tuple
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|del_sigs
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|zonediff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|now
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"sign_apex:del_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|add_sigs
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|zonediff
operator|->
name|diff
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|inception
argument_list|,
name|soaexpire
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"sign_apex:add_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|result
operator|=
name|update_sigs
argument_list|(
name|diff
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|zone_keys
argument_list|,
name|nkeys
argument_list|,
name|zone
argument_list|,
name|inception
argument_list|,
name|soaexpire
argument_list|,
name|now
argument_list|,
name|check_ksk
argument_list|,
name|keyset_kskonly
argument_list|,
name|zonediff
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"sign_apex:update_sigs -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|failure
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
name|dst_key_free
argument_list|(
operator|&
name|zone_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prevent the zone entering a inconsistent state where  * NSEC only DNSKEYs are present with NSEC3 chains.  * See update.c:check_dnssec()  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|dnskey_sane
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
decl_stmt|;
name|isc_boolean_t
name|nseconly
init|=
name|ISC_FALSE
decl_stmt|,
name|nsec3
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdatatype_t
name|privatetype
init|=
name|dns_zone_getprivatetype
argument_list|(
name|zone
argument_list|)
decl_stmt|;
comment|/* Scan the tuples for an NSEC-only DNSKEY */
for|for
control|(
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|tuple
operator|!=
name|NULL
condition|;
name|tuple
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|tuple
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_uint8_t
name|alg
decl_stmt|;
if|if
condition|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|!=
name|dns_rdatatype_dnskey
operator|||
name|tuple
operator|->
name|op
operator|!=
name|DNS_DIFFOP_ADD
condition|)
continue|continue;
name|alg
operator|=
name|tuple
operator|->
name|rdata
operator|.
name|data
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|alg
operator|==
name|DST_ALG_RSAMD5
operator|||
name|alg
operator|==
name|DST_ALG_RSASHA1
operator|||
name|alg
operator|==
name|DST_ALG_DSA
operator|||
name|alg
operator|==
name|DST_ALG_ECC
condition|)
block|{
name|nseconly
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check existing DB for NSEC-only DNSKEY */
if|if
condition|(
operator|!
name|nseconly
condition|)
block|{
name|result
operator|=
name|dns_nsec_nseconly
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|nseconly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Check existing DB for NSEC3 */
if|if
condition|(
operator|!
name|nsec3
condition|)
name|CHECK
argument_list|(
name|dns_nsec3_activex
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|ISC_FALSE
argument_list|,
name|privatetype
argument_list|,
operator|&
name|nsec3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Refuse to allow NSEC3 with NSEC-only keys */
if|if
condition|(
name|nseconly
operator|&&
name|nsec3
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"NSEC only DNSKEYs and NSEC3 chains not allowed"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|failure
label|:
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|clean_nsec3param
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_nsec3param_deletechains
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zone
argument_list|,
name|ISC_TRUE
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RRSIG rdataset and an algorithm, determine whether there  * are any signatures using that algorithm.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|signed_with_alg
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_secalg_t
name|alg
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|rdataset
operator|==
name|NULL
operator|||
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrsig
operator|.
name|algorithm
operator|==
name|alg
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_chains
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|isc_boolean_t
name|build_nsec3
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|origin
operator|=
name|dns_db_origin
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_private_chains
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|NULL
argument_list|,
operator|&
name|build_nsec3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_nsec3
condition|)
name|CHECK
argument_list|(
name|dns_nsec3_addnsec3sx
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|origin
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|ISC_FALSE
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|updatesecure
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|origin
argument_list|,
name|zone
operator|->
name|minimum
argument_list|,
name|ISC_TRUE
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_rekey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|soaset
decl_stmt|,
name|soasigs
decl_stmt|,
name|keyset
decl_stmt|,
name|keysigs
decl_stmt|;
name|dns_dnsseckeylist_t
name|dnskeys
decl_stmt|,
name|keys
decl_stmt|,
name|rmkeys
decl_stmt|;
name|dns_dnsseckey_t
modifier|*
name|key
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|,
name|_sig_diff
decl_stmt|;
name|zonediff_t
name|zonediff
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|,
name|newactive
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|newalg
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|fullsign
decl_stmt|;
name|dns_ttl_t
name|ttl
init|=
literal|3600
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_time_t
name|timenow
decl_stmt|;
name|isc_interval_t
name|ival
decl_stmt|;
name|char
name|timebuf
index|[
literal|80
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|dnskeys
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|keys
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rmkeys
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|soaset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|soasigs
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|keysigs
argument_list|)
expr_stmt|;
name|dir
operator|=
name|dns_zone_getkeydirectory
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|zone
operator|->
name|mctx
expr_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|zonediff_init
argument_list|(
operator|&
name|zonediff
argument_list|,
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_zone_getdb
argument_list|(
name|zone
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|now
operator|=
name|isc_time_seconds
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"reconfiguring zone keys"
argument_list|)
expr_stmt|;
comment|/* Get the SOA record's TTL */
name|CHECK
argument_list|(
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|soaset
argument_list|,
operator|&
name|soasigs
argument_list|)
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|soaset
operator|.
name|ttl
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|soaset
argument_list|)
expr_stmt|;
comment|/* Get the DNSKEY rdataset */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|keyset
argument_list|,
operator|&
name|keysigs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|ttl
operator|=
name|keyset
operator|.
name|ttl
expr_stmt|;
name|CHECK
argument_list|(
name|dns_dnssec_keylistfromrdataset
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dir
argument_list|,
name|mctx
argument_list|,
operator|&
name|keyset
argument_list|,
operator|&
name|keysigs
argument_list|,
operator|&
name|soasigs
argument_list|,
name|ISC_FALSE
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|dnskeys
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|failure
goto|;
comment|/* 	 * True when called from "rndc sign".  Indicates the zone should be 	 * fully signed now. 	 */
name|fullsign
operator|=
name|ISC_TF
argument_list|(
name|DNS_ZONEKEY_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEKEY_FULLSIGN
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_findmatchingkeys
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|dir
argument_list|,
name|mctx
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_boolean_t
name|check_ksk
decl_stmt|;
name|check_ksk
operator|=
name|DNS_ZONE_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEOPT_UPDATECHECKKSK
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_updatekeys
argument_list|(
operator|&
name|dnskeys
argument_list|,
operator|&
name|keys
argument_list|,
operator|&
name|rmkeys
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|ttl
argument_list|,
operator|&
name|diff
argument_list|,
name|ISC_TF
argument_list|(
operator|!
name|check_ksk
argument_list|)
argument_list|,
name|mctx
argument_list|,
name|logmsg
argument_list|)
expr_stmt|;
comment|/* Keys couldn't be updated for some reason; 		 * try again later. */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_rekey:"
literal|"couldn't update zone keys: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 		 * See if any pre-existing keys have newly become active; 		 * also, see if any new key is for a new algorithm, as in that 		 * event, we need to sign the zone fully.  (If there's a new 		 * key, but it's for an already-existing algorithm, then 		 * the zone signing can be handled incrementally.) 		 */
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dnskeys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|key
operator|->
name|first_sign
condition|)
continue|continue;
name|newactive
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|keysigs
argument_list|)
condition|)
block|{
name|newalg
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|signed_with_alg
argument_list|(
operator|&
name|keysigs
argument_list|,
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 				 * This isn't a new algorithm; clear 				 * first_sign so we won't sign the 				 * whole zone with this key later 				 */
name|key
operator|->
name|first_sign
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|newalg
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|newactive
operator|||
name|fullsign
operator|||
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|.
name|tuples
argument_list|)
operator|)
operator|&&
name|dnskey_sane
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|dns_diff_apply
argument_list|(
operator|&
name|diff
argument_list|,
name|db
argument_list|,
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|clean_nsec3param
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|add_signing_records
argument_list|(
name|db
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|ISC_TF
argument_list|(
name|newalg
operator|||
name|fullsign
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|add_chains
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|sign_apex
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|diff
argument_list|,
operator|&
name|zonediff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
name|zonediff
operator|.
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"zone_rekey"
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
name|dns_difftuple_t
modifier|*
name|tuple
decl_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_NEEDNOTIFY
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
name|DNS_DUMP_DELAY
argument_list|)
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|timenow
argument_list|)
expr_stmt|;
comment|/* Remove any signatures from removed keys.  */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|rmkeys
argument_list|)
condition|)
block|{
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rmkeys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
name|result
operator|=
name|zone_signwithkey
argument_list|(
name|zone
argument_list|,
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_signwithkey failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fullsign
condition|)
block|{
comment|/* 			 * "rndc sign" was called, so we now sign the zone 			 * with all active keys, whether they're new or not. 			 */
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dnskeys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|key
operator|->
name|force_sign
operator|&&
operator|!
name|key
operator|->
name|hint_sign
condition|)
continue|continue;
name|result
operator|=
name|zone_signwithkey
argument_list|(
name|zone
argument_list|,
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_signwithkey failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|newalg
condition|)
block|{
comment|/* 			 * We haven't been told to sign fully, but a new 			 * algorithm was added to the DNSKEY.  We sign 			 * the full zone, but only with newly active 			 * keys. 			 */
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dnskeys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|key
operator|->
name|first_sign
condition|)
continue|continue;
name|result
operator|=
name|zone_signwithkey
argument_list|(
name|zone
argument_list|,
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_signwithkey failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Clear fullsign flag, if it was set, so we don't do 		 * another full signing next time 		 */
name|zone
operator|->
name|keyopts
operator|&=
operator|~
name|DNS_ZONEKEY_FULLSIGN
expr_stmt|;
comment|/* 		 * Cause the zone to add/delete NSEC3 chains for the 		 * deferred NSEC3PARAM changes. 		 */
for|for
control|(
name|tuple
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|zonediff
operator|.
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|tuple
operator|!=
name|NULL
condition|;
name|tuple
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|tuple
argument_list|,
name|link
argument_list|)
control|)
block|{
name|unsigned
name|char
name|buf
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
index|]
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_nsec3param_t
name|nsec3param
decl_stmt|;
if|if
condition|(
name|tuple
operator|->
name|rdata
operator|.
name|type
operator|!=
name|zone
operator|->
name|privatetype
operator|||
name|tuple
operator|->
name|op
operator|!=
name|DNS_DIFFOP_ADD
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dns_nsec3param_fromprivate
argument_list|(
operator|&
name|tuple
operator|->
name|rdata
argument_list|,
operator|&
name|rdata
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
continue|continue;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3param
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|.
name|flags
operator|==
literal|0
condition|)
continue|continue;
name|result
operator|=
name|zone_addnsec3chain
argument_list|(
name|zone
argument_list|,
operator|&
name|nsec3param
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone_addnsec3chain failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Activate any NSEC3 chain updates that may have 		 * been scheduled before this rekey. 		 */
if|if
condition|(
name|fullsign
operator|||
name|newalg
condition|)
name|resume_addnsec3chain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 		 * Schedule the next resigning event 		 */
name|set_resigntime
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|isc_time_settoepoch
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
expr_stmt|;
comment|/* 	 * If we're doing key maintenance, set the key refresh timer to 	 * the next scheduled key event or to 'dnssec-loadkeys-interval' 	 * seconds in the future, whichever is sooner. 	 */
if|if
condition|(
name|DNS_ZONEKEY_OPTION
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEKEY_MAINTAIN
argument_list|)
condition|)
block|{
name|isc_time_t
name|timethen
decl_stmt|;
name|isc_stdtime_t
name|then
decl_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|timenow
argument_list|,
name|zone
operator|->
name|refreshkeyinterval
argument_list|,
operator|&
name|timethen
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshkeytime
operator|=
name|timethen
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dnskeys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
name|then
operator|=
name|now
expr_stmt|;
name|result
operator|=
name|next_keyevent
argument_list|(
name|key
operator|->
name|key
argument_list|,
operator|&
name|then
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|DNS_ZONE_TIME_ADD
argument_list|(
operator|&
name|timenow
argument_list|,
name|then
operator|-
name|now
argument_list|,
operator|&
name|timethen
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|timethen
argument_list|,
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zone
operator|->
name|refreshkeytime
operator|=
name|timethen
expr_stmt|;
block|}
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|isc_time_formattimestamp
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
name|timebuf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"next key event: %s"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|_sig_diff
argument_list|)
expr_stmt|;
name|clear_keylist
argument_list|(
operator|&
name|dnskeys
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|clear_keylist
argument_list|(
operator|&
name|keys
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|clear_keylist
argument_list|(
operator|&
name|rmkeys
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|keyset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|keysigs
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keysigs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|soasigs
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|soasigs
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return;
name|failure
label|:
comment|/* 	 * Something went wrong; try again in ten minutes or 	 * after a key refresh interval, whichever is shorter. 	 */
name|isc_interval_set
argument_list|(
operator|&
name|ival
argument_list|,
name|ISC_MIN
argument_list|(
name|zone
operator|->
name|refreshkeyinterval
argument_list|,
literal|600
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_time_nowplusinterval
argument_list|(
operator|&
name|zone
operator|->
name|refreshkeytime
argument_list|,
operator|&
name|ival
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_function
name|void
name|dns_zone_rekey
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|fullsign
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|type
operator|==
name|dns_zone_master
operator|&&
name|zone
operator|->
name|task
operator|!=
name|NULL
condition|)
block|{
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullsign
condition|)
name|zone
operator|->
name|keyopts
operator||=
name|DNS_ZONEKEY_FULLSIGN
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|zone
operator|->
name|refreshkeytime
operator|=
name|now
expr_stmt|;
name|zone_settimer
argument_list|(
name|zone
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_nscheck
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|unsigned
name|int
modifier|*
name|errors
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|errors
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|zone_count_ns_rr
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|NULL
argument_list|,
name|errors
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setadded
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|added
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|added
operator|=
name|added
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zone_getadded
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|added
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_dlzpostload
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|isc_time_t
name|loadtime
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_zone_t
modifier|*
name|secure
init|=
name|NULL
decl_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|loadtime
argument_list|)
expr_stmt|;
comment|/* 	 * Lock hierarchy: zmgr, zone, raw. 	 */
name|again
label|:
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|LOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inline_raw
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|secure
operator|=
name|zone
operator|->
name|secure
expr_stmt|;
name|TRYLOCK_ZONE
argument_list|(
name|result
argument_list|,
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|secure
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ISC_PLATFORM_USETHREADS
name|isc_thread_yield
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
block|}
name|result
operator|=
name|zone_postload
argument_list|(
name|zone
argument_list|,
name|db
argument_list|,
name|loadtime
argument_list|,
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_secure
argument_list|(
name|zone
argument_list|)
condition|)
name|UNLOCK_ZONE
argument_list|(
name|zone
operator|->
name|raw
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|secure
operator|!=
name|NULL
condition|)
name|UNLOCK_ZONE
argument_list|(
name|secure
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setrefreshkeyinterval
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint32_t
name|interval
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
comment|/* Maximum value: 24 hours (3600 minutes) */
if|if
condition|(
name|interval
operator|>
operator|(
literal|24
operator|*
literal|60
operator|)
condition|)
name|interval
operator|=
operator|(
literal|24
operator|*
literal|60
operator|)
expr_stmt|;
comment|/* Multiply by 60 for seconds */
name|zone
operator|->
name|refreshkeyinterval
operator|=
name|interval
operator|*
literal|60
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setrequestixfr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|flag
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|requestixfr
operator|=
name|flag
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_zone_getrequestixfr
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|requestixfr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setserialupdatemethod
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_updatemethod_t
name|method
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|updatemethod
operator|=
name|method
expr_stmt|;
block|}
end_function

begin_function
name|dns_updatemethod_t
name|dns_zone_getserialupdatemethod
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|updatemethod
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock hierarchy: zmgr, zone, raw.  */
end_comment

begin_function
name|isc_result_t
name|dns_zone_link
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_zone_t
modifier|*
name|raw
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_zonemgr_t
modifier|*
name|zmgr
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|zmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|loadtask
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|->
name|raw
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|raw
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|->
name|zmgr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|->
name|task
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|->
name|loadtask
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|->
name|secure
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Lock hierarchy: zmgr, zone, raw. 	 */
name|zmgr
operator|=
name|zone
operator|->
name|zmgr
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_create
argument_list|(
name|zmgr
operator|->
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zone
operator|->
name|task
argument_list|,
name|zone_timer
argument_list|,
name|raw
argument_list|,
operator|&
name|raw
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * The timer "holds" a iref. 	 */
name|raw
operator|->
name|irefs
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|raw
operator|->
name|irefs
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* dns_zone_attach(raw,&zone->raw); */
name|isc_refcount_increment
argument_list|(
operator|&
name|raw
operator|->
name|erefs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zone
operator|->
name|raw
operator|=
name|raw
expr_stmt|;
comment|/* dns_zone_iattach(zone,&raw->secure); */
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|raw
operator|->
name|secure
argument_list|)
expr_stmt|;
name|isc_task_attach
argument_list|(
name|zone
operator|->
name|task
argument_list|,
operator|&
name|raw
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_task_attach
argument_list|(
name|zone
operator|->
name|loadtask
argument_list|,
operator|&
name|raw
operator|->
name|loadtask
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|zmgr
operator|->
name|zones
argument_list|,
name|raw
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|raw
operator|->
name|zmgr
operator|=
name|zmgr
expr_stmt|;
name|zmgr
operator|->
name|refs
operator|++
expr_stmt|;
name|unlock
label|:
name|UNLOCK_ZONE
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|zmgr
operator|->
name|rwlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_getraw
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|raw
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|!=
name|NULL
operator|&&
operator|*
name|raw
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|raw
operator|!=
name|NULL
condition|)
name|dns_zone_attach
argument_list|(
name|zone
operator|->
name|raw
argument_list|,
name|raw
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|keydone
block|{
name|isc_event_t
name|event
decl_stmt|;
name|isc_boolean_t
name|all
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|5
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PENDINGFLAGS
value|(DNS_NSEC3FLAG_CREATE|DNS_NSEC3FLAG_INITIAL)
end_define

begin_function
specifier|static
name|void
name|keydone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|me
init|=
literal|"keydone"
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|oldver
init|=
name|NULL
decl_stmt|,
modifier|*
name|newver
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|struct
name|keydone
modifier|*
name|keydone
init|=
operator|(
expr|struct
name|keydone
operator|*
operator|)
name|event
decl_stmt|;
name|dns_update_log_t
name|log
init|=
block|{
name|update_log_cb
block|,
name|NULL
block|}
decl_stmt|;
name|isc_boolean_t
name|clear_pending
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|zone
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"keydone:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|newver
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|isc_boolean_t
name|found
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|keydone
operator|->
name|all
condition|)
block|{
if|if
condition|(
name|rdata
operator|.
name|length
operator|==
literal|5
operator|&&
name|rdata
operator|.
name|data
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|rdata
operator|.
name|data
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|rdata
operator|.
name|data
index|[
literal|4
index|]
operator|==
literal|1
condition|)
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdata
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|rdata
operator|.
name|data
index|[
literal|2
index|]
operator|&
name|PENDINGFLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
name|clear_pending
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rdata
operator|.
name|length
operator|==
literal|5
operator|&&
name|memcmp
argument_list|(
name|rdata
operator|.
name|data
argument_list|,
name|keydone
operator|->
name|data
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|.
name|tuples
argument_list|)
condition|)
block|{
comment|/* Write changes to journal file. */
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_update_signatures
argument_list|(
operator|&
name|log
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|oldver
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|sigvalidityinterval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clear_pending
condition|)
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
operator|&
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"keydone"
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_keydone
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|keystr
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_zone_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|struct
name|keydone
modifier|*
name|kd
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
argument_list|,
name|DNS_EVENT_KEYDONE
argument_list|,
name|keydone
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|keydone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|kd
operator|=
operator|(
expr|struct
name|keydone
operator|*
operator|)
name|e
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|keystr
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|kd
operator|->
name|all
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|char
modifier|*
name|algstr
decl_stmt|;
name|dns_keytag_t
name|keyid
decl_stmt|;
name|dns_secalg_t
name|alg
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|kd
operator|->
name|all
operator|=
name|ISC_FALSE
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|keystr
argument_list|,
literal|"%hd/"
argument_list|,
operator|&
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0U
condition|)
name|CHECK
argument_list|(
name|ISC_R_FAILURE
argument_list|)
expr_stmt|;
name|algstr
operator|=
name|strchr
argument_list|(
name|keystr
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|algstr
operator|!=
name|NULL
condition|)
name|algstr
operator|++
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|ISC_R_FAILURE
argument_list|)
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|algstr
argument_list|,
literal|"%hhd"
argument_list|,
operator|&
name|alg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0U
condition|)
block|{
name|DE_CONST
argument_list|(
name|algstr
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|algstr
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_secalg_fromtext
argument_list|(
operator|&
name|alg
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* construct a private-type rdata */
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|kd
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|kd
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|b
argument_list|,
name|alg
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|keyid
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|keyid
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setnsec3param
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|me
init|=
literal|"setnsec3param"
decl_stmt|;
name|isc_boolean_t
name|commit
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|oldver
init|=
name|NULL
decl_stmt|,
modifier|*
name|newver
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|prdataset
decl_stmt|,
name|nrdataset
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|struct
name|np3event
modifier|*
name|npe
init|=
operator|(
expr|struct
name|np3event
operator|*
operator|)
name|event
decl_stmt|;
name|nsec3param_t
modifier|*
name|np
decl_stmt|;
name|dns_update_log_t
name|log
init|=
block|{
name|update_log_cb
block|,
name|NULL
block|}
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
name|isc_boolean_t
name|nseconly
decl_stmt|;
name|isc_boolean_t
name|exists
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|zone
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|np
operator|=
operator|&
name|npe
operator|->
name|params
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|prdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|nrdataset
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|ZONEDB_LOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|db
operator|!=
name|NULL
condition|)
block|{
name|dns_db_attach
argument_list|(
name|zone
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_zone_log
argument_list|(
name|zone
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"setnsec3param:dns_db_newversion -> %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|ZONEDB_UNLOCK
argument_list|(
operator|&
name|zone
operator|->
name|dblock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
goto|goto
name|failure
goto|;
name|CHECK
argument_list|(
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Does a private-type record already exist for this chain? 	 */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|newver
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|prdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|prdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|prdataset
argument_list|)
control|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|prdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|length
operator|==
name|rdata
operator|.
name|length
operator|&&
name|memcmp
argument_list|(
name|rdata
operator|.
name|data
argument_list|,
name|np
operator|->
name|data
argument_list|,
name|np
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exists
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|prdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Does the chain already exist? 	 */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|newver
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
name|dns_rdatatype_none
argument_list|,
literal|0
argument_list|,
operator|&
name|nrdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|nrdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|nrdataset
argument_list|)
control|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|nrdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|length
operator|==
operator|(
name|rdata
operator|.
name|length
operator|+
literal|1
operator|)
operator|&&
name|memcmp
argument_list|(
name|rdata
operator|.
name|data
argument_list|,
name|np
operator|->
name|data
operator|+
literal|1
argument_list|,
name|np
operator|->
name|length
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exists
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|nrdataset
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * We need to remove any existing NSEC3 chains. 	 */
if|if
condition|(
operator|!
name|exists
operator|&&
name|np
operator|->
name|replace
operator|&&
operator|(
name|np
operator|->
name|length
operator|!=
literal|0
operator|||
name|np
operator|->
name|nsec
operator|)
condition|)
name|CHECK
argument_list|(
name|dns_nsec3param_deletechains
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
name|zone
argument_list|,
operator|!
name|np
operator|->
name|nsec
argument_list|,
operator|&
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exists
operator|&&
name|np
operator|->
name|length
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We're creating an NSEC3 chain. 		 * 		 * If the zone is not currently capable of supporting 		 * an NSEC3 chain, add the INITIAL flag, so these 		 * parameters can be used later when NSEC3 becomes 		 * available. 		 */
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|np
operator|->
name|data
index|[
literal|2
index|]
operator||=
name|DNS_NSEC3FLAG_CREATE
expr_stmt|;
name|result
operator|=
name|dns_nsec_nseconly
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|nseconly
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
operator|||
name|nseconly
condition|)
name|np
operator|->
name|data
index|[
literal|2
index|]
operator||=
name|DNS_NSEC3FLAG_INITIAL
expr_stmt|;
name|rdata
operator|.
name|length
operator|=
name|np
operator|->
name|length
expr_stmt|;
name|rdata
operator|.
name|data
operator|=
name|np
operator|->
name|data
expr_stmt|;
name|rdata
operator|.
name|type
operator|=
name|zone
operator|->
name|privatetype
expr_stmt|;
name|rdata
operator|.
name|rdclass
operator|=
name|zone
operator|->
name|rdclass
expr_stmt|;
name|CHECK
argument_list|(
name|update_one_rr
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
operator|&
name|zone
operator|->
name|origin
argument_list|,
literal|0
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|diff
operator|.
name|tuples
argument_list|)
condition|)
block|{
comment|/* Write changes to journal file. */
name|CHECK
argument_list|(
name|update_soa_serial
argument_list|(
name|db
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|mctx
argument_list|,
name|zone
operator|->
name|updatemethod
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_update_signatures
argument_list|(
operator|&
name|log
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|oldver
argument_list|,
name|newver
argument_list|,
operator|&
name|diff
argument_list|,
name|zone
operator|->
name|sigvalidityinterval
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|zone_journal
argument_list|(
name|zone
argument_list|,
operator|&
name|diff
argument_list|,
name|NULL
argument_list|,
literal|"setnsec3param"
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|=
name|ISC_TRUE
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|DNS_ZONE_SETFLAG
argument_list|(
name|zone
argument_list|,
name|DNS_ZONEFLG_LOADED
argument_list|)
expr_stmt|;
name|zone_needdump
argument_list|(
name|zone
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|prdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|prdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|nrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|oldver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|newver
argument_list|,
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
name|resume_addnsec3chain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_zone_idetach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_setnsec3param
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|isc_uint8_t
name|hash
parameter_list|,
name|isc_uint8_t
name|flags
parameter_list|,
name|isc_uint16_t
name|iter
parameter_list|,
name|isc_uint8_t
name|saltlen
parameter_list|,
name|unsigned
name|char
modifier|*
name|salt
parameter_list|,
name|isc_boolean_t
name|replace
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_rdata_nsec3param_t
name|param
decl_stmt|;
name|dns_rdata_t
name|nrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|prdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|unsigned
name|char
name|nbuf
index|[
name|DNS_NSEC3PARAM_BUFFERSIZE
index|]
decl_stmt|;
name|struct
name|np3event
modifier|*
name|npe
decl_stmt|;
name|nsec3param_t
modifier|*
name|np
decl_stmt|;
name|dns_zone_t
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_event_t
modifier|*
name|e
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|salt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|e
operator|=
name|isc_event_allocate
argument_list|(
name|zone
operator|->
name|mctx
argument_list|,
name|zone
argument_list|,
name|DNS_EVENT_SETNSEC3PARAM
argument_list|,
name|setnsec3param
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|np3event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|npe
operator|=
operator|(
expr|struct
name|np3event
operator|*
operator|)
name|e
expr_stmt|;
name|np
operator|=
operator|&
name|npe
operator|->
name|params
expr_stmt|;
name|np
operator|->
name|replace
operator|=
name|replace
expr_stmt|;
if|if
condition|(
name|hash
operator|==
literal|0
condition|)
block|{
name|np
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|nsec
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|param
operator|.
name|common
operator|.
name|rdclass
operator|=
name|zone
operator|->
name|rdclass
expr_stmt|;
name|param
operator|.
name|common
operator|.
name|rdtype
operator|=
name|dns_rdatatype_nsec3param
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|param
operator|.
name|common
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|param
operator|.
name|mctx
operator|=
name|NULL
expr_stmt|;
name|param
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|param
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|param
operator|.
name|iterations
operator|=
name|iter
expr_stmt|;
name|param
operator|.
name|salt_length
operator|=
name|saltlen
expr_stmt|;
name|param
operator|.
name|salt
operator|=
name|salt
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|nrdata
argument_list|,
name|zone
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
operator|&
name|param
argument_list|,
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|dns_nsec3param_toprivate
argument_list|(
operator|&
name|nrdata
argument_list|,
operator|&
name|prdata
argument_list|,
name|zone
operator|->
name|privatetype
argument_list|,
name|np
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|np
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|length
operator|=
name|prdata
operator|.
name|length
expr_stmt|;
block|}
name|zone_iattach
argument_list|(
name|zone
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|zone
operator|->
name|task
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|UNLOCK_ZONE
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_zone_setstatlevel
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_zonestat_level_t
name|level
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|statlevel
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
name|dns_zonestat_level_t
name|dns_zone_getstatlevel
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ZONE_VALID
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zone
operator|->
name|statlevel
operator|)
return|;
block|}
end_function

end_unit

