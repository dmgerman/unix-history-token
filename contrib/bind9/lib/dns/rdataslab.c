begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: rdataslab.c,v 1.29.2.2.2.6 2004/03/08 09:04:31 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_comment
comment|/* Required for HP/UX (and others?) */
end_comment

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataslab.h>
end_include

begin_comment
comment|/* Note: the "const void *" are just to make qsort happy. */
end_comment

begin_function
specifier|static
name|int
name|compare_rdata
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|dns_rdata_t
modifier|*
name|rdata1
init|=
name|p1
decl_stmt|;
specifier|const
name|dns_rdata_t
modifier|*
name|rdata2
init|=
name|p2
decl_stmt|;
return|return
operator|(
name|dns_rdata_compare
argument_list|(
name|rdata1
argument_list|,
name|rdata2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataslab_fromrdataset
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|)
block|{
name|dns_rdata_t
modifier|*
name|rdatas
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rawbuf
decl_stmt|;
name|unsigned
name|int
name|buflen
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|nitems
decl_stmt|;
name|unsigned
name|int
name|nalloc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|buflen
operator|=
name|reservelen
operator|+
literal|2
expr_stmt|;
name|nalloc
operator|=
name|dns_rdataset_count
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|nalloc
expr_stmt|;
if|if
condition|(
name|nitems
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|rdatas
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdatas
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * Save all of the rdata members into an array. 	 */
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_rdatas
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalloc
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|i
operator|++
control|)
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|free_rdatas
goto|;
if|if
condition|(
name|i
operator|!=
name|nalloc
condition|)
block|{
comment|/* 		 * Somehow we iterated over fewer rdatas than 		 * dns_rdataset_count() said there were! 		 */
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
name|qsort
argument_list|(
name|rdatas
argument_list|,
name|nalloc
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|,
name|compare_rdata
argument_list|)
expr_stmt|;
comment|/* 	 * Remove duplicates and compute the total storage required. 	 * 	 * If an rdata is not a duplicate, accumulate the storage size 	 * required for the rdata.  We do not store the class, type, etc, 	 * just the rdata, so our overhead is 2 bytes for the number of 	 * records, and 2 for each rdata length, and then the rdata itself. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nalloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|compare_rdata
argument_list|(
operator|&
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|nitems
operator|--
expr_stmt|;
block|}
else|else
name|buflen
operator|+=
operator|(
literal|2
operator|+
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|length
operator|)
expr_stmt|;
block|}
comment|/* 	 * Don't forget the last item! 	 */
name|buflen
operator|+=
operator|(
literal|2
operator|+
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|length
operator|)
expr_stmt|;
comment|/* 	 * Ensure that singleton types are actually singletons. 	 */
if|if
condition|(
name|nitems
operator|>
literal|1
operator|&&
name|dns_rdatatype_issingleton
argument_list|(
name|rdataset
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * We have a singleton type, but there's more than one 		 * RR in the rdataset. 		 */
name|result
operator|=
name|DNS_R_SINGLETON
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
comment|/* 	 * Allocate the memory, set up a buffer, start copying in 	 * data. 	 */
name|rawbuf
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawbuf
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
name|region
operator|->
name|base
operator|=
name|rawbuf
expr_stmt|;
name|region
operator|->
name|length
operator|=
name|buflen
expr_stmt|;
name|rawbuf
operator|+=
name|reservelen
expr_stmt|;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|nitems
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|nitems
operator|&
literal|0x00ff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdatas
index|[
name|i
index|]
operator|.
name|data
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|rdatas
index|[
name|i
index|]
operator|.
name|length
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|rdatas
index|[
name|i
index|]
operator|.
name|length
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|rawbuf
argument_list|,
name|rdatas
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|rdatas
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|rawbuf
operator|+=
name|rdatas
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|free_rdatas
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdatas
argument_list|,
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_disassociate
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_first
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
name|raw
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * The privateuint4 field is the number of rdata beyond the cursor 	 * position, so we decrement the total count by one before storing 	 * it. 	 */
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_next
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
name|count
operator|=
name|rdataset
operator|->
name|privateuint4
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|raw
operator|=
name|rdataset
operator|->
name|private5
expr_stmt|;
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_current
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private5
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
name|r
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|rdata
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_clone
parameter_list|(
name|dns_rdataset_t
modifier|*
name|source
parameter_list|,
name|dns_rdataset_t
modifier|*
name|target
parameter_list|)
block|{
operator|*
name|target
operator|=
operator|*
name|source
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|target
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rdataset_count
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dns_rdatasetmethods_t
name|rdataset_methods
init|=
block|{
name|rdataset_disassociate
block|,
name|rdataset_first
block|,
name|rdataset_next
block|,
name|rdataset_current
block|,
name|rdataset_clone
block|,
name|rdataset_count
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dns_rdataslab_tordataset
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|rdtype
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|slab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|rdataset
operator|->
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|rdataset
operator|->
name|type
operator|=
name|rdtype
expr_stmt|;
name|rdataset
operator|->
name|covers
operator|=
name|covers
expr_stmt|;
name|rdataset
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|rdataset
operator|->
name|private1
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|->
name|private2
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|->
name|private3
operator|=
name|slab
operator|+
name|reservelen
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|rdataset
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_rdataslab_size
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|current
decl_stmt|;
name|REQUIRE
argument_list|(
name|slab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|current
operator|=
name|slab
operator|+
name|reservelen
expr_stmt|;
name|count
operator|=
operator|*
name|current
operator|++
operator|*
literal|256
expr_stmt|;
name|count
operator|+=
operator|*
name|current
operator|++
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|length
operator|=
operator|*
name|current
operator|++
operator|*
literal|256
expr_stmt|;
name|length
operator|+=
operator|*
name|current
operator|++
expr_stmt|;
name|current
operator|+=
name|length
expr_stmt|;
block|}
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|current
operator|-
name|slab
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make the dns_rdata_t 'rdata' refer to the slab item  * beginning at '*current', which is part of a slab of type  * 'type' and class 'rdclass', and advance '*current' to  * point to the next item in the slab.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|rdata_from_slab
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|current
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|tcurrent
init|=
operator|*
name|current
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|region
operator|.
name|length
operator|=
operator|*
name|tcurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|region
operator|.
name|length
operator|+=
operator|*
name|tcurrent
operator|++
expr_stmt|;
name|region
operator|.
name|base
operator|=
name|tcurrent
expr_stmt|;
name|tcurrent
operator|+=
name|region
operator|.
name|length
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|rdata
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
operator|*
name|current
operator|=
name|tcurrent
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true iff 'slab' (slab data of type 'type' and class 'rdclass')  * contains an rdata identical to 'rdata'.  This does case insensitive  * comparisons per DNSSEC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|rdata_in_slab
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|current
decl_stmt|;
name|dns_rdata_t
name|trdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|current
operator|=
name|slab
operator|+
name|reservelen
expr_stmt|;
name|count
operator|=
operator|*
name|current
operator|++
operator|*
literal|256
expr_stmt|;
name|count
operator|+=
operator|*
name|current
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rdata_from_slab
argument_list|(
operator|&
name|current
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|trdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|trdata
argument_list|,
name|rdata
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|dns_rdata_reset
argument_list|(
operator|&
name|trdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataslab_merge
parameter_list|(
name|unsigned
name|char
modifier|*
name|oslab
parameter_list|,
name|unsigned
name|char
modifier|*
name|nslab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|tslabp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ocurrent
decl_stmt|,
modifier|*
name|ostart
decl_stmt|,
modifier|*
name|ncurrent
decl_stmt|,
modifier|*
name|tstart
decl_stmt|,
modifier|*
name|tcurrent
decl_stmt|;
name|unsigned
name|int
name|ocount
decl_stmt|,
name|ncount
decl_stmt|,
name|count
decl_stmt|,
name|olength
decl_stmt|,
name|tlength
decl_stmt|,
name|tcount
decl_stmt|,
name|length
decl_stmt|;
name|isc_region_t
name|nregion
decl_stmt|;
name|dns_rdata_t
name|ordata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|nrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_boolean_t
name|added_something
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|oadded
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nadded
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nncount
init|=
literal|0
decl_stmt|;
comment|/* 	 * XXX  Need parameter to allow "delete rdatasets in nslab" merge, 	 * or perhaps another merge routine for this purpose. 	 */
name|REQUIRE
argument_list|(
name|tslabp
operator|!=
name|NULL
operator|&&
operator|*
name|tslabp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|oslab
operator|!=
name|NULL
operator|&&
name|nslab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ocurrent
operator|=
name|oslab
operator|+
name|reservelen
expr_stmt|;
name|ocount
operator|=
operator|*
name|ocurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|ocount
operator|+=
operator|*
name|ocurrent
operator|++
expr_stmt|;
name|ostart
operator|=
name|ocurrent
expr_stmt|;
name|ncurrent
operator|=
name|nslab
operator|+
name|reservelen
expr_stmt|;
name|ncount
operator|=
operator|*
name|ncurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|ncount
operator|+=
operator|*
name|ncurrent
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|ocount
operator|>
literal|0
operator|&&
name|ncount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Yes, this is inefficient! 	 */
comment|/* 	 * Figure out the length of the old slab's data. 	 */
name|olength
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|ocount
condition|;
name|count
operator|++
control|)
block|{
name|length
operator|=
operator|*
name|ocurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|length
operator|+=
operator|*
name|ocurrent
operator|++
expr_stmt|;
name|olength
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
name|ocurrent
operator|+=
name|length
expr_stmt|;
block|}
comment|/* 	 * Start figuring out the target length and count. 	 */
name|tlength
operator|=
name|reservelen
operator|+
literal|2
operator|+
name|olength
expr_stmt|;
name|tcount
operator|=
name|ocount
expr_stmt|;
comment|/* 	 * Add in the length of rdata in the new slab that aren't in 	 * the old slab. 	 */
do|do
block|{
name|nregion
operator|.
name|length
operator|=
operator|*
name|ncurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|nregion
operator|.
name|length
operator|+=
operator|*
name|ncurrent
operator|++
expr_stmt|;
name|nregion
operator|.
name|base
operator|=
name|ncurrent
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|nrdata
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
operator|&
name|nrdata
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nregion
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdata_in_slab
argument_list|(
name|oslab
argument_list|,
name|reservelen
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
condition|)
block|{
comment|/* 			 * This rdata isn't in the old slab. 			 */
name|tlength
operator|+=
name|nregion
operator|.
name|length
operator|+
literal|2
expr_stmt|;
name|tcount
operator|++
expr_stmt|;
name|nncount
operator|++
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ncurrent
operator|+=
name|nregion
operator|.
name|length
expr_stmt|;
name|ncount
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|ncount
operator|>
literal|0
condition|)
do|;
name|ncount
operator|=
name|nncount
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|DNS_RDATASLAB_EXACT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tcount
operator|!=
name|ncount
operator|+
name|ocount
operator|)
condition|)
return|return
operator|(
name|DNS_R_NOTEXACT
operator|)
return|;
if|if
condition|(
operator|!
name|added_something
operator|&&
operator|(
name|flags
operator|&
name|DNS_RDATASLAB_FORCE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
comment|/* 	 * Ensure that singleton types are actually singletons. 	 */
if|if
condition|(
name|tcount
operator|>
literal|1
operator|&&
name|dns_rdatatype_issingleton
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * We have a singleton type, but there's more than one 		 * RR in the rdataset. 		 */
return|return
operator|(
name|DNS_R_SINGLETON
operator|)
return|;
block|}
comment|/* 	 * Copy the reserved area from the new slab. 	 */
name|tstart
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|tlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstart
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memcpy
argument_list|(
name|tstart
argument_list|,
name|nslab
argument_list|,
name|reservelen
argument_list|)
expr_stmt|;
name|tcurrent
operator|=
name|tstart
operator|+
name|reservelen
expr_stmt|;
comment|/* 	 * Write the new count. 	 */
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0x00ff
operator|)
expr_stmt|;
comment|/* 	 * Merge the two slabs. 	 */
name|ocurrent
operator|=
name|ostart
expr_stmt|;
name|INSIST
argument_list|(
name|ocount
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|ocurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|ordata
argument_list|)
expr_stmt|;
name|ncurrent
operator|=
name|nslab
operator|+
name|reservelen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ncount
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|nrdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|ncurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rdata_in_slab
argument_list|(
name|oslab
argument_list|,
name|reservelen
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
condition|)
do|;
block|}
while|while
condition|(
name|oadded
operator|<
name|ocount
operator|||
name|nadded
operator|<
name|ncount
condition|)
block|{
name|isc_boolean_t
name|fromold
decl_stmt|;
if|if
condition|(
name|oadded
operator|==
name|ocount
condition|)
name|fromold
operator|=
name|ISC_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|nadded
operator|==
name|ncount
condition|)
name|fromold
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|fromold
operator|=
name|ISC_TF
argument_list|(
name|compare_rdata
argument_list|(
operator|&
name|ordata
argument_list|,
operator|&
name|nrdata
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromold
condition|)
block|{
name|length
operator|=
name|ordata
operator|.
name|length
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|tcurrent
argument_list|,
name|ordata
operator|.
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tcurrent
operator|+=
name|length
expr_stmt|;
name|oadded
operator|++
expr_stmt|;
if|if
condition|(
name|oadded
operator|<
name|ocount
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|ordata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|ocurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|ordata
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|=
name|nrdata
operator|.
name|length
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|tcurrent
argument_list|,
name|nrdata
operator|.
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tcurrent
operator|+=
name|length
expr_stmt|;
name|nadded
operator|++
expr_stmt|;
if|if
condition|(
name|nadded
operator|<
name|ncount
condition|)
block|{
do|do
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|nrdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|ncurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rdata_in_slab
argument_list|(
name|oslab
argument_list|,
name|reservelen
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
condition|)
do|;
block|}
block|}
block|}
name|INSIST
argument_list|(
name|tcurrent
operator|==
name|tstart
operator|+
name|tlength
argument_list|)
expr_stmt|;
operator|*
name|tslabp
operator|=
name|tstart
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataslab_subtract
parameter_list|(
name|unsigned
name|char
modifier|*
name|mslab
parameter_list|,
name|unsigned
name|char
modifier|*
name|sslab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|tslabp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|mcurrent
decl_stmt|,
modifier|*
name|sstart
decl_stmt|,
modifier|*
name|scurrent
decl_stmt|,
modifier|*
name|tstart
decl_stmt|,
modifier|*
name|tcurrent
decl_stmt|;
name|unsigned
name|int
name|mcount
decl_stmt|,
name|scount
decl_stmt|,
name|rcount
decl_stmt|,
name|count
decl_stmt|,
name|tlength
decl_stmt|,
name|tcount
decl_stmt|;
name|dns_rdata_t
name|srdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|mrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|REQUIRE
argument_list|(
name|tslabp
operator|!=
name|NULL
operator|&&
operator|*
name|tslabp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mslab
operator|!=
name|NULL
operator|&&
name|sslab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mcurrent
operator|=
name|mslab
operator|+
name|reservelen
expr_stmt|;
name|mcount
operator|=
operator|*
name|mcurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|mcount
operator|+=
operator|*
name|mcurrent
operator|++
expr_stmt|;
name|scurrent
operator|=
name|sslab
operator|+
name|reservelen
expr_stmt|;
name|scount
operator|=
operator|*
name|scurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|scount
operator|+=
operator|*
name|scurrent
operator|++
expr_stmt|;
name|sstart
operator|=
name|scurrent
expr_stmt|;
name|INSIST
argument_list|(
name|mcount
operator|>
literal|0
operator|&&
name|scount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Yes, this is inefficient! 	 */
comment|/* 	 * Start figuring out the target length and count. 	 */
name|tlength
operator|=
name|reservelen
operator|+
literal|2
expr_stmt|;
name|tcount
operator|=
literal|0
expr_stmt|;
name|rcount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add in the length of rdata in the mslab that aren't in 	 * the sslab. 	 */
do|do
block|{
name|unsigned
name|char
modifier|*
name|mrdatabegin
init|=
name|mcurrent
decl_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|mcurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|mrdata
argument_list|)
expr_stmt|;
name|scurrent
operator|=
name|sstart
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|scount
condition|;
name|count
operator|++
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|srdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|scurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|srdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|mrdata
argument_list|,
operator|&
name|srdata
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
name|scount
condition|)
block|{
comment|/* 			 * This rdata isn't in the sslab, and thus isn't 			 * being subtracted. 			 */
name|tlength
operator|+=
name|mcurrent
operator|-
name|mrdatabegin
expr_stmt|;
name|tcount
operator|++
expr_stmt|;
block|}
else|else
name|rcount
operator|++
expr_stmt|;
name|mcount
operator|--
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|mrdata
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mcount
operator|>
literal|0
condition|)
do|;
comment|/* 	 * Check that all the records originally existed.  The numeric  	 * check only works as rdataslabs do not contain duplicates. 	 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|DNS_RDATASLAB_EXACT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rcount
operator|!=
name|scount
operator|)
condition|)
return|return
operator|(
name|DNS_R_NOTEXACT
operator|)
return|;
comment|/* 	 * Don't continue if the new rdataslab would be empty. 	 */
if|if
condition|(
name|tcount
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_NXRRSET
operator|)
return|;
comment|/* 	 * If nothing is going to change, we can stop. 	 */
if|if
condition|(
name|rcount
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
comment|/* 	 * Copy the reserved area from the mslab. 	 */
name|tstart
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|tlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstart
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memcpy
argument_list|(
name|tstart
argument_list|,
name|mslab
argument_list|,
name|reservelen
argument_list|)
expr_stmt|;
name|tcurrent
operator|=
name|tstart
operator|+
name|reservelen
expr_stmt|;
comment|/* 	 * Write the new count. 	 */
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0x00ff
operator|)
expr_stmt|;
comment|/* 	 * Copy the parts of mslab not in sslab. 	 */
name|mcurrent
operator|=
name|mslab
operator|+
name|reservelen
expr_stmt|;
name|mcount
operator|=
operator|*
name|mcurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|mcount
operator|+=
operator|*
name|mcurrent
operator|++
expr_stmt|;
do|do
block|{
name|unsigned
name|char
modifier|*
name|mrdatabegin
init|=
name|mcurrent
decl_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|mcurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|mrdata
argument_list|)
expr_stmt|;
name|scurrent
operator|=
name|sstart
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|scount
condition|;
name|count
operator|++
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|srdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|scurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|srdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|mrdata
argument_list|,
operator|&
name|srdata
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
name|scount
condition|)
block|{
comment|/* 			 * This rdata isn't in the sslab, and thus should be 			 * copied to the tslab. 			 */
name|unsigned
name|int
name|length
init|=
name|mcurrent
operator|-
name|mrdatabegin
decl_stmt|;
name|memcpy
argument_list|(
name|tcurrent
argument_list|,
name|mrdatabegin
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tcurrent
operator|+=
name|length
expr_stmt|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|mrdata
argument_list|)
expr_stmt|;
name|mcount
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|mcount
operator|>
literal|0
condition|)
do|;
name|INSIST
argument_list|(
name|tcurrent
operator|==
name|tstart
operator|+
name|tlength
argument_list|)
expr_stmt|;
operator|*
name|tslabp
operator|=
name|tstart
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_rdataslab_equal
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab1
parameter_list|,
name|unsigned
name|char
modifier|*
name|slab2
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|current1
decl_stmt|,
modifier|*
name|current2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|unsigned
name|int
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|current1
operator|=
name|slab1
operator|+
name|reservelen
expr_stmt|;
name|count1
operator|=
operator|*
name|current1
operator|++
operator|*
literal|256
expr_stmt|;
name|count1
operator|+=
operator|*
name|current1
operator|++
expr_stmt|;
name|current2
operator|=
name|slab2
operator|+
name|reservelen
expr_stmt|;
name|count2
operator|=
operator|*
name|current2
operator|++
operator|*
literal|256
expr_stmt|;
name|count2
operator|+=
operator|*
name|current2
operator|++
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
name|count2
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
while|while
condition|(
name|count1
operator|>
literal|0
condition|)
block|{
name|length1
operator|=
operator|*
name|current1
operator|++
operator|*
literal|256
expr_stmt|;
name|length1
operator|+=
operator|*
name|current1
operator|++
expr_stmt|;
name|length2
operator|=
operator|*
name|current2
operator|++
operator|*
literal|256
expr_stmt|;
name|length2
operator|+=
operator|*
name|current2
operator|++
expr_stmt|;
if|if
condition|(
name|length1
operator|!=
name|length2
operator|||
name|memcmp
argument_list|(
name|current1
argument_list|,
name|current2
argument_list|,
name|length1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|current1
operator|+=
name|length1
expr_stmt|;
name|current2
operator|+=
name|length1
expr_stmt|;
name|count1
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_rdataslab_equalx
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab1
parameter_list|,
name|unsigned
name|char
modifier|*
name|slab2
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|current1
decl_stmt|,
modifier|*
name|current2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|dns_rdata_t
name|rdata1
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|rdata2
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|current1
operator|=
name|slab1
operator|+
name|reservelen
expr_stmt|;
name|count1
operator|=
operator|*
name|current1
operator|++
operator|*
literal|256
expr_stmt|;
name|count1
operator|+=
operator|*
name|current1
operator|++
expr_stmt|;
name|current2
operator|=
name|slab2
operator|+
name|reservelen
expr_stmt|;
name|count2
operator|=
operator|*
name|current2
operator|++
operator|*
literal|256
expr_stmt|;
name|count2
operator|+=
operator|*
name|current2
operator|++
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
name|count2
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
while|while
condition|(
name|count1
operator|--
operator|>
literal|0
condition|)
block|{
name|rdata_from_slab
argument_list|(
operator|&
name|current1
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|rdata1
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|current2
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|rdata2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|rdata1
argument_list|,
operator|&
name|rdata2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata1
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

end_unit

