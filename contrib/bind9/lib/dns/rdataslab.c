begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2010  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: rdataslab.c,v 1.48.50.4 2010-02-25 10:56:41 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_comment
comment|/* Required for HP/UX (and others?) */
end_comment

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataslab.h>
end_include

begin_comment
comment|/*  * The rdataslab structure allows iteration to occur in both load order  * and DNSSEC order.  The structure is as follows:  *  *	header		(reservelen bytes)  *	record count	(2 bytes)  *	offset table	(4 x record count bytes in load order)  *	data records  *		data length	(2 bytes)  *		order		(2 bytes)  *		meta data	(1 byte for RRSIG's)  *		data		(data length bytes)  *  * If DNS_RDATASET_FIXED is defined to be zero (0) the format of a  * rdataslab is as follows:  *  *	header		(reservelen bytes)  *	record count	(2 bytes)  *	data records  *		data length	(2 bytes)  *		data		(data length bytes)  *  * Offsets are from the end of the header.  *  * Load order traversal is performed by walking the offset table to find  * the start of the record (DNS_RDATASET_FIXED = 1).  *  * DNSSEC order traversal is performed by walking the data records.  *  * The order is stored with record to allow for efficient reconstruction  * of the offset table following a merge or subtraction.  *  * The iterator methods here currently only support DNSSEC order iteration.  *  * The iterator methods in rbtdb support both load order and DNSSEC order  * iteration.  *  * WARNING:  *	rbtdb.c directly interacts with the slab's raw structures.  If the  *	structure changes then rbtdb.c also needs to be updated to reflect  *	the changes.  See the areas tagged with "RDATASLAB".  */
end_comment

begin_struct
struct|struct
name|xrdata
block|{
name|dns_rdata_t
name|rdata
decl_stmt|;
name|unsigned
name|int
name|order
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*% Note: the "const void *" are just to make qsort happy.  */
end_comment

begin_function
specifier|static
name|int
name|compare_rdata
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|xrdata
modifier|*
name|x1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|xrdata
modifier|*
name|x2
init|=
name|p2
decl_stmt|;
return|return
operator|(
name|dns_rdata_compare
argument_list|(
operator|&
name|x1
operator|->
name|rdata
argument_list|,
operator|&
name|x2
operator|->
name|rdata
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DNS_RDATASET_FIXED
end_if

begin_function
specifier|static
name|void
name|fillin_offsets
parameter_list|(
name|unsigned
name|char
modifier|*
name|offsetbase
parameter_list|,
name|unsigned
name|int
modifier|*
name|offsettable
parameter_list|,
name|unsigned
name|length
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offsettable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Fill in offset table. 		 */
name|raw
operator|=
operator|&
name|offsetbase
index|[
name|j
operator|*
literal|4
operator|+
literal|2
index|]
expr_stmt|;
operator|*
name|raw
operator|++
operator|=
operator|(
name|offsettable
index|[
name|i
index|]
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
operator|*
name|raw
operator|++
operator|=
operator|(
name|offsettable
index|[
name|i
index|]
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|raw
operator|++
operator|=
operator|(
name|offsettable
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|raw
operator|=
name|offsettable
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
comment|/* 		 * Fill in table index. 		 */
name|raw
operator|=
name|offsetbase
operator|+
name|offsettable
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
operator|*
name|raw
operator|++
operator|=
operator|(
name|j
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|raw
operator|=
name|j
operator|++
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|dns_rdataslab_fromrdataset
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|)
block|{
name|struct
name|xrdata
modifier|*
name|x
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rawbuf
decl_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|unsigned
name|char
modifier|*
name|offsetbase
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|buflen
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|nitems
decl_stmt|;
name|unsigned
name|int
name|nalloc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|unsigned
name|int
modifier|*
name|offsettable
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|length
decl_stmt|;
name|buflen
operator|=
name|reservelen
operator|+
literal|2
expr_stmt|;
name|nalloc
operator|=
name|dns_rdataset_count
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|nalloc
expr_stmt|;
if|if
condition|(
name|nitems
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
if|if
condition|(
name|nalloc
operator|>
literal|0xffff
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|x
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xrdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * Save all of the rdata members into an array. 	 */
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_rdatas
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalloc
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|i
operator|++
control|)
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|x
index|[
name|i
index|]
operator|.
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|x
index|[
name|i
index|]
operator|.
name|rdata
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|x
index|[
name|i
index|]
operator|.
name|order
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|free_rdatas
goto|;
if|if
condition|(
name|i
operator|!=
name|nalloc
condition|)
block|{
comment|/* 		 * Somehow we iterated over fewer rdatas than 		 * dns_rdataset_count() said there were! 		 */
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
comment|/* 	 * Put into DNSSEC order. 	 */
name|qsort
argument_list|(
name|x
argument_list|,
name|nalloc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xrdata
argument_list|)
argument_list|,
name|compare_rdata
argument_list|)
expr_stmt|;
comment|/* 	 * Remove duplicates and compute the total storage required. 	 * 	 * If an rdata is not a duplicate, accumulate the storage size 	 * required for the rdata.  We do not store the class, type, etc, 	 * just the rdata, so our overhead is 2 bytes for the number of 	 * records, and 8 for each rdata, (length(2), offset(4) and order(2)) 	 * and then the rdata itself. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nalloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|compare_rdata
argument_list|(
operator|&
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
argument_list|,
operator|&
name|x
index|[
name|i
index|]
operator|.
name|rdata
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
operator|.
name|length
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
comment|/* 			 * Preserve the least order so A, B, A -> A, B 			 * after duplicate removal. 			 */
if|if
condition|(
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|order
operator|<
name|x
index|[
name|i
index|]
operator|.
name|order
condition|)
name|x
index|[
name|i
index|]
operator|.
name|order
operator|=
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|order
expr_stmt|;
endif|#
directive|endif
name|nitems
operator|--
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|DNS_RDATASET_FIXED
name|buflen
operator|+=
operator|(
literal|8
operator|+
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
operator|.
name|length
operator|)
expr_stmt|;
else|#
directive|else
name|buflen
operator|+=
operator|(
literal|2
operator|+
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
operator|.
name|length
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Provide space to store the per RR meta data. 			 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|buflen
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Don't forget the last item! 	 */
if|#
directive|if
name|DNS_RDATASET_FIXED
name|buflen
operator|+=
operator|(
literal|8
operator|+
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
operator|.
name|length
operator|)
expr_stmt|;
else|#
directive|else
name|buflen
operator|+=
operator|(
literal|2
operator|+
name|x
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rdata
operator|.
name|length
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Provide space to store the per RR meta data. 	 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|buflen
operator|++
expr_stmt|;
comment|/* 	 * Ensure that singleton types are actually singletons. 	 */
if|if
condition|(
name|nitems
operator|>
literal|1
operator|&&
name|dns_rdatatype_issingleton
argument_list|(
name|rdataset
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * We have a singleton type, but there's more than one 		 * RR in the rdataset. 		 */
name|result
operator|=
name|DNS_R_SINGLETON
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
comment|/* 	 * Allocate the memory, set up a buffer, start copying in 	 * data. 	 */
name|rawbuf
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawbuf
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
comment|/* Allocate temporary offset table. */
name|offsettable
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|nalloc
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsettable
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rawbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|free_rdatas
goto|;
block|}
name|memset
argument_list|(
name|offsettable
argument_list|,
literal|0
argument_list|,
name|nalloc
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|region
operator|->
name|base
operator|=
name|rawbuf
expr_stmt|;
name|region
operator|->
name|length
operator|=
name|buflen
expr_stmt|;
name|rawbuf
operator|+=
name|reservelen
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsetbase
operator|=
name|rawbuf
expr_stmt|;
endif|#
directive|endif
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|nitems
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|nitems
operator|&
literal|0x00ff
operator|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
comment|/* Skip load order table.  Filled in later. */
name|rawbuf
operator|+=
name|nitems
operator|*
literal|4
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|.
name|rdata
operator|.
name|data
operator|==
name|NULL
condition|)
continue|continue;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsettable
index|[
name|x
index|[
name|i
index|]
operator|.
name|order
index|]
operator|=
name|rawbuf
operator|-
name|offsetbase
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
name|x
index|[
name|i
index|]
operator|.
name|rdata
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|length
operator|++
expr_stmt|;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|length
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|rawbuf
operator|++
operator|=
operator|(
name|length
operator|&
literal|0x00ff
operator|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|rawbuf
operator|+=
literal|2
expr_stmt|;
comment|/* filled in later */
endif|#
directive|endif
comment|/* 		 * Store the per RR meta data. 		 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
operator|*
name|rawbuf
operator|++
operator||=
operator|(
name|x
index|[
name|i
index|]
operator|.
name|rdata
operator|.
name|flags
operator|&
name|DNS_RDATA_OFFLINE
operator|)
condition|?
name|DNS_RDATASLAB_OFFLINE
else|:
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|rawbuf
argument_list|,
name|x
index|[
name|i
index|]
operator|.
name|rdata
operator|.
name|data
argument_list|,
name|x
index|[
name|i
index|]
operator|.
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|rawbuf
operator|+=
name|x
index|[
name|i
index|]
operator|.
name|rdata
operator|.
name|length
expr_stmt|;
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
name|fillin_offsets
argument_list|(
name|offsetbase
argument_list|,
name|offsettable
argument_list|,
name|nalloc
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|offsettable
argument_list|,
name|nalloc
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|free_rdatas
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|x
argument_list|,
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xrdata
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_disassociate
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_first
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|2
operator|+
operator|(
literal|4
operator|*
name|count
operator|)
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The privateuint4 field is the number of rdata beyond the cursor 	 * position, so we decrement the total count by one before storing 	 * it. 	 */
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_next
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
name|count
operator|=
name|rdataset
operator|->
name|privateuint4
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|raw
operator|=
name|rdataset
operator|->
name|private5
expr_stmt|;
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
name|length
operator|+
literal|4
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_current
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private5
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|4
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
if|if
condition|(
operator|*
name|raw
operator|&
name|DNS_RDATASLAB_OFFLINE
condition|)
name|flags
operator||=
name|DNS_RDATA_OFFLINE
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|raw
operator|++
expr_stmt|;
block|}
name|r
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|r
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|rdata
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_clone
parameter_list|(
name|dns_rdataset_t
modifier|*
name|source
parameter_list|,
name|dns_rdataset_t
modifier|*
name|target
parameter_list|)
block|{
operator|*
name|target
operator|=
operator|*
name|source
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|target
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rdataset_count
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dns_rdatasetmethods_t
name|rdataset_methods
init|=
block|{
name|rdataset_disassociate
block|,
name|rdataset_first
block|,
name|rdataset_next
block|,
name|rdataset_current
block|,
name|rdataset_clone
block|,
name|rdataset_count
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dns_rdataslab_tordataset
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|rdtype
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|slab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|rdataset
operator|->
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|rdataset
operator|->
name|type
operator|=
name|rdtype
expr_stmt|;
name|rdataset
operator|->
name|covers
operator|=
name|covers
expr_stmt|;
name|rdataset
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|rdataset
operator|->
name|private1
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|->
name|private2
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|->
name|private3
operator|=
name|slab
operator|+
name|reservelen
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|rdataset
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_rdataslab_size
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|current
decl_stmt|;
name|REQUIRE
argument_list|(
name|slab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|current
operator|=
name|slab
operator|+
name|reservelen
expr_stmt|;
name|count
operator|=
operator|*
name|current
operator|++
operator|*
literal|256
expr_stmt|;
name|count
operator|+=
operator|*
name|current
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|current
operator|+=
operator|(
literal|4
operator|*
name|count
operator|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|length
operator|=
operator|*
name|current
operator|++
operator|*
literal|256
expr_stmt|;
name|length
operator|+=
operator|*
name|current
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|current
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
else|#
directive|else
name|current
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|current
operator|-
name|slab
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make the dns_rdata_t 'rdata' refer to the slab item  * beginning at '*current', which is part of a slab of type  * 'type' and class 'rdclass', and advance '*current' to  * point to the next item in the slab.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|rdata_from_slab
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|current
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|tcurrent
init|=
operator|*
name|current
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|isc_boolean_t
name|offline
init|=
name|ISC_FALSE
decl_stmt|;
name|length
operator|=
operator|*
name|tcurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|length
operator|+=
operator|*
name|tcurrent
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|tcurrent
operator|&
name|DNS_RDATASLAB_OFFLINE
operator|)
operator|!=
literal|0
condition|)
name|offline
operator|=
name|ISC_TRUE
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|tcurrent
operator|++
expr_stmt|;
block|}
name|region
operator|.
name|length
operator|=
name|length
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|tcurrent
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
name|region
operator|.
name|base
operator|=
name|tcurrent
expr_stmt|;
name|tcurrent
operator|+=
name|region
operator|.
name|length
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|rdata
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|offline
condition|)
name|rdata
operator|->
name|flags
operator||=
name|DNS_RDATA_OFFLINE
expr_stmt|;
operator|*
name|current
operator|=
name|tcurrent
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true iff 'slab' (slab data of type 'type' and class 'rdclass')  * contains an rdata identical to 'rdata'.  This does case insensitive  * comparisons per DNSSEC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|rdata_in_slab
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|current
decl_stmt|;
name|dns_rdata_t
name|trdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|int
name|n
decl_stmt|;
name|current
operator|=
name|slab
operator|+
name|reservelen
expr_stmt|;
name|count
operator|=
operator|*
name|current
operator|++
operator|*
literal|256
expr_stmt|;
name|count
operator|+=
operator|*
name|current
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|current
operator|+=
operator|(
literal|4
operator|*
name|count
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rdata_from_slab
argument_list|(
operator|&
name|current
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|trdata
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_rdata_compare
argument_list|(
operator|&
name|trdata
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
comment|/* In DNSSEC order. */
break|break;
name|dns_rdata_reset
argument_list|(
operator|&
name|trdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataslab_merge
parameter_list|(
name|unsigned
name|char
modifier|*
name|oslab
parameter_list|,
name|unsigned
name|char
modifier|*
name|nslab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|tslabp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ocurrent
decl_stmt|,
modifier|*
name|ostart
decl_stmt|,
modifier|*
name|ncurrent
decl_stmt|,
modifier|*
name|tstart
decl_stmt|,
modifier|*
name|tcurrent
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|ocount
decl_stmt|,
name|ncount
decl_stmt|,
name|count
decl_stmt|,
name|olength
decl_stmt|,
name|tlength
decl_stmt|,
name|tcount
decl_stmt|,
name|length
decl_stmt|;
name|dns_rdata_t
name|ordata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|nrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_boolean_t
name|added_something
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|oadded
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nadded
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nncount
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|unsigned
name|int
name|oncount
decl_stmt|;
name|unsigned
name|int
name|norder
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|oorder
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|offsetbase
decl_stmt|;
name|unsigned
name|int
modifier|*
name|offsettable
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX  Need parameter to allow "delete rdatasets in nslab" merge, 	 * or perhaps another merge routine for this purpose. 	 */
name|REQUIRE
argument_list|(
name|tslabp
operator|!=
name|NULL
operator|&&
operator|*
name|tslabp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|oslab
operator|!=
name|NULL
operator|&&
name|nslab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ocurrent
operator|=
name|oslab
operator|+
name|reservelen
expr_stmt|;
name|ocount
operator|=
operator|*
name|ocurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|ocount
operator|+=
operator|*
name|ocurrent
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|ocurrent
operator|+=
operator|(
literal|4
operator|*
name|ocount
operator|)
expr_stmt|;
endif|#
directive|endif
name|ostart
operator|=
name|ocurrent
expr_stmt|;
name|ncurrent
operator|=
name|nslab
operator|+
name|reservelen
expr_stmt|;
name|ncount
operator|=
operator|*
name|ncurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|ncount
operator|+=
operator|*
name|ncurrent
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|ncurrent
operator|+=
operator|(
literal|4
operator|*
name|ncount
operator|)
expr_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|ocount
operator|>
literal|0
operator|&&
name|ncount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|oncount
operator|=
name|ncount
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Yes, this is inefficient! 	 */
comment|/* 	 * Figure out the length of the old slab's data. 	 */
name|olength
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|ocount
condition|;
name|count
operator|++
control|)
block|{
name|length
operator|=
operator|*
name|ocurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|length
operator|+=
operator|*
name|ocurrent
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|olength
operator|+=
name|length
operator|+
literal|8
expr_stmt|;
name|ocurrent
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
else|#
directive|else
name|olength
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
name|ocurrent
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Start figuring out the target length and count. 	 */
name|tlength
operator|=
name|reservelen
operator|+
literal|2
operator|+
name|olength
expr_stmt|;
name|tcount
operator|=
name|ocount
expr_stmt|;
comment|/* 	 * Add in the length of rdata in the new slab that aren't in 	 * the old slab. 	 */
do|do
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|nrdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|ncurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdata_in_slab
argument_list|(
name|oslab
argument_list|,
name|reservelen
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
condition|)
block|{
comment|/* 			 * This rdata isn't in the old slab. 			 */
if|#
directive|if
name|DNS_RDATASET_FIXED
name|tlength
operator|+=
name|nrdata
operator|.
name|length
operator|+
literal|8
expr_stmt|;
else|#
directive|else
name|tlength
operator|+=
name|nrdata
operator|.
name|length
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|tlength
operator|++
expr_stmt|;
name|tcount
operator|++
expr_stmt|;
name|nncount
operator|++
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ncount
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|ncount
operator|>
literal|0
condition|)
do|;
name|ncount
operator|=
name|nncount
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|DNS_RDATASLAB_EXACT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tcount
operator|!=
name|ncount
operator|+
name|ocount
operator|)
condition|)
return|return
operator|(
name|DNS_R_NOTEXACT
operator|)
return|;
if|if
condition|(
operator|!
name|added_something
operator|&&
operator|(
name|flags
operator|&
name|DNS_RDATASLAB_FORCE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
comment|/* 	 * Ensure that singleton types are actually singletons. 	 */
if|if
condition|(
name|tcount
operator|>
literal|1
operator|&&
name|dns_rdatatype_issingleton
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * We have a singleton type, but there's more than one 		 * RR in the rdataset. 		 */
return|return
operator|(
name|DNS_R_SINGLETON
operator|)
return|;
block|}
if|if
condition|(
name|tcount
operator|>
literal|0xffff
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
comment|/* 	 * Copy the reserved area from the new slab. 	 */
name|tstart
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|tlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstart
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memcpy
argument_list|(
name|tstart
argument_list|,
name|nslab
argument_list|,
name|reservelen
argument_list|)
expr_stmt|;
name|tcurrent
operator|=
name|tstart
operator|+
name|reservelen
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsetbase
operator|=
name|tcurrent
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Write the new count. 	 */
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0x00ff
operator|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
comment|/* 	 * Skip offset table. 	 */
name|tcurrent
operator|+=
operator|(
name|tcount
operator|*
literal|4
operator|)
expr_stmt|;
name|offsettable
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
operator|(
name|ocount
operator|+
name|oncount
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsettable
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|tstart
argument_list|,
name|tlength
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|offsettable
argument_list|,
literal|0
argument_list|,
operator|(
name|ocount
operator|+
name|oncount
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Merge the two slabs. 	 */
name|ocurrent
operator|=
name|ostart
expr_stmt|;
name|INSIST
argument_list|(
name|ocount
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|oorder
operator|=
name|ocurrent
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|ocurrent
index|[
literal|3
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|oorder
operator|<
name|ocount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdata_from_slab
argument_list|(
operator|&
name|ocurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|ordata
argument_list|)
expr_stmt|;
name|ncurrent
operator|=
name|nslab
operator|+
name|reservelen
operator|+
literal|2
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|ncurrent
operator|+=
operator|(
literal|4
operator|*
name|oncount
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ncount
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|nrdata
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|norder
operator|=
name|ncurrent
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|ncurrent
index|[
literal|3
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|norder
operator|<
name|oncount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdata_from_slab
argument_list|(
operator|&
name|ncurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rdata_in_slab
argument_list|(
name|oslab
argument_list|,
name|reservelen
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
condition|)
do|;
block|}
while|while
condition|(
name|oadded
operator|<
name|ocount
operator|||
name|nadded
operator|<
name|ncount
condition|)
block|{
name|isc_boolean_t
name|fromold
decl_stmt|;
if|if
condition|(
name|oadded
operator|==
name|ocount
condition|)
name|fromold
operator|=
name|ISC_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|nadded
operator|==
name|ncount
condition|)
name|fromold
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|fromold
operator|=
name|ISC_TF
argument_list|(
name|compare_rdata
argument_list|(
operator|&
name|ordata
argument_list|,
operator|&
name|nrdata
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromold
condition|)
block|{
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsettable
index|[
name|oorder
index|]
operator|=
name|tcurrent
operator|-
name|offsetbase
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
name|ordata
operator|.
name|length
expr_stmt|;
name|data
operator|=
name|ordata
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|data
operator|--
expr_stmt|;
block|}
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0x00ff
operator|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|tcurrent
operator|+=
literal|2
expr_stmt|;
comment|/* fill in later */
endif|#
directive|endif
name|memcpy
argument_list|(
name|tcurrent
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tcurrent
operator|+=
name|length
expr_stmt|;
name|oadded
operator|++
expr_stmt|;
if|if
condition|(
name|oadded
operator|<
name|ocount
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|ordata
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|oorder
operator|=
name|ocurrent
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|ocurrent
index|[
literal|3
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|oorder
operator|<
name|ocount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdata_from_slab
argument_list|(
operator|&
name|ocurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|ordata
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsettable
index|[
name|ocount
operator|+
name|norder
index|]
operator|=
name|tcurrent
operator|-
name|offsetbase
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
name|nrdata
operator|.
name|length
expr_stmt|;
name|data
operator|=
name|nrdata
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|data
operator|--
expr_stmt|;
block|}
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|length
operator|&
literal|0x00ff
operator|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|tcurrent
operator|+=
literal|2
expr_stmt|;
comment|/* fill in later */
endif|#
directive|endif
name|memcpy
argument_list|(
name|tcurrent
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tcurrent
operator|+=
name|length
expr_stmt|;
name|nadded
operator|++
expr_stmt|;
if|if
condition|(
name|nadded
operator|<
name|ncount
condition|)
block|{
do|do
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|nrdata
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|norder
operator|=
name|ncurrent
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|ncurrent
index|[
literal|3
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|norder
operator|<
name|oncount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdata_from_slab
argument_list|(
operator|&
name|ncurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rdata_in_slab
argument_list|(
name|oslab
argument_list|,
name|reservelen
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|nrdata
argument_list|)
condition|)
do|;
block|}
block|}
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
name|fillin_offsets
argument_list|(
name|offsetbase
argument_list|,
name|offsettable
argument_list|,
name|ocount
operator|+
name|oncount
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|offsettable
argument_list|,
operator|(
name|ocount
operator|+
name|oncount
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|tcurrent
operator|==
name|tstart
operator|+
name|tlength
argument_list|)
expr_stmt|;
operator|*
name|tslabp
operator|=
name|tstart
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataslab_subtract
parameter_list|(
name|unsigned
name|char
modifier|*
name|mslab
parameter_list|,
name|unsigned
name|char
modifier|*
name|sslab
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|tslabp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|mcurrent
decl_stmt|,
modifier|*
name|sstart
decl_stmt|,
modifier|*
name|scurrent
decl_stmt|,
modifier|*
name|tstart
decl_stmt|,
modifier|*
name|tcurrent
decl_stmt|;
name|unsigned
name|int
name|mcount
decl_stmt|,
name|scount
decl_stmt|,
name|rcount
decl_stmt|,
name|count
decl_stmt|,
name|tlength
decl_stmt|,
name|tcount
decl_stmt|,
name|i
decl_stmt|;
name|dns_rdata_t
name|srdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|mrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|unsigned
name|char
modifier|*
name|offsetbase
decl_stmt|;
name|unsigned
name|int
modifier|*
name|offsettable
decl_stmt|;
name|unsigned
name|int
name|order
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|tslabp
operator|!=
name|NULL
operator|&&
operator|*
name|tslabp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mslab
operator|!=
name|NULL
operator|&&
name|sslab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mcurrent
operator|=
name|mslab
operator|+
name|reservelen
expr_stmt|;
name|mcount
operator|=
operator|*
name|mcurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|mcount
operator|+=
operator|*
name|mcurrent
operator|++
expr_stmt|;
name|scurrent
operator|=
name|sslab
operator|+
name|reservelen
expr_stmt|;
name|scount
operator|=
operator|*
name|scurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|scount
operator|+=
operator|*
name|scurrent
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|mcount
operator|>
literal|0
operator|&&
name|scount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Yes, this is inefficient! 	 */
comment|/* 	 * Start figuring out the target length and count. 	 */
name|tlength
operator|=
name|reservelen
operator|+
literal|2
expr_stmt|;
name|tcount
operator|=
literal|0
expr_stmt|;
name|rcount
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|mcurrent
operator|+=
literal|4
operator|*
name|mcount
expr_stmt|;
name|scurrent
operator|+=
literal|4
operator|*
name|scount
expr_stmt|;
endif|#
directive|endif
name|sstart
operator|=
name|scurrent
expr_stmt|;
comment|/* 	 * Add in the length of rdata in the mslab that aren't in 	 * the sslab. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcount
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|mrdatabegin
init|=
name|mcurrent
decl_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|mcurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|mrdata
argument_list|)
expr_stmt|;
name|scurrent
operator|=
name|sstart
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|scount
condition|;
name|count
operator|++
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|srdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|scurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|srdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|mrdata
argument_list|,
operator|&
name|srdata
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
name|scount
condition|)
block|{
comment|/* 			 * This rdata isn't in the sslab, and thus isn't 			 * being subtracted. 			 */
name|tlength
operator|+=
name|mcurrent
operator|-
name|mrdatabegin
expr_stmt|;
name|tcount
operator|++
expr_stmt|;
block|}
else|else
name|rcount
operator|++
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|mrdata
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
name|tlength
operator|+=
operator|(
literal|4
operator|*
name|tcount
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check that all the records originally existed.  The numeric 	 * check only works as rdataslabs do not contain duplicates. 	 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|DNS_RDATASLAB_EXACT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rcount
operator|!=
name|scount
operator|)
condition|)
return|return
operator|(
name|DNS_R_NOTEXACT
operator|)
return|;
comment|/* 	 * Don't continue if the new rdataslab would be empty. 	 */
if|if
condition|(
name|tcount
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_NXRRSET
operator|)
return|;
comment|/* 	 * If nothing is going to change, we can stop. 	 */
if|if
condition|(
name|rcount
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
comment|/* 	 * Copy the reserved area from the mslab. 	 */
name|tstart
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|tlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstart
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memcpy
argument_list|(
name|tstart
argument_list|,
name|mslab
argument_list|,
name|reservelen
argument_list|)
expr_stmt|;
name|tcurrent
operator|=
name|tstart
operator|+
name|reservelen
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsetbase
operator|=
name|tcurrent
expr_stmt|;
name|offsettable
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|mcount
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsettable
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|tstart
argument_list|,
name|tlength
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|offsettable
argument_list|,
literal|0
argument_list|,
name|mcount
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Write the new count. 	 */
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|tcurrent
operator|++
operator|=
operator|(
name|tcount
operator|&
literal|0x00ff
operator|)
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|tcurrent
operator|+=
operator|(
literal|4
operator|*
name|tcount
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Copy the parts of mslab not in sslab. 	 */
name|mcurrent
operator|=
name|mslab
operator|+
name|reservelen
expr_stmt|;
name|mcount
operator|=
operator|*
name|mcurrent
operator|++
operator|*
literal|256
expr_stmt|;
name|mcount
operator|+=
operator|*
name|mcurrent
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|mcurrent
operator|+=
operator|(
literal|4
operator|*
name|mcount
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcount
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|mrdatabegin
init|=
name|mcurrent
decl_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|order
operator|=
name|mcurrent
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|mcurrent
index|[
literal|3
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|order
operator|<
name|mcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdata_from_slab
argument_list|(
operator|&
name|mcurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|mrdata
argument_list|)
expr_stmt|;
name|scurrent
operator|=
name|sstart
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|scount
condition|;
name|count
operator|++
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|srdata
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|scurrent
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|srdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|mrdata
argument_list|,
operator|&
name|srdata
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
name|scount
condition|)
block|{
comment|/* 			 * This rdata isn't in the sslab, and thus should be 			 * copied to the tslab. 			 */
name|unsigned
name|int
name|length
init|=
name|mcurrent
operator|-
name|mrdatabegin
decl_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|offsettable
index|[
name|order
index|]
operator|=
name|tcurrent
operator|-
name|offsetbase
expr_stmt|;
endif|#
directive|endif
name|memcpy
argument_list|(
name|tcurrent
argument_list|,
name|mrdatabegin
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tcurrent
operator|+=
name|length
expr_stmt|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|mrdata
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
name|fillin_offsets
argument_list|(
name|offsetbase
argument_list|,
name|offsettable
argument_list|,
name|mcount
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|offsettable
argument_list|,
name|mcount
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|tcurrent
operator|==
name|tstart
operator|+
name|tlength
argument_list|)
expr_stmt|;
operator|*
name|tslabp
operator|=
name|tstart
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_rdataslab_equal
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab1
parameter_list|,
name|unsigned
name|char
modifier|*
name|slab2
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|current1
decl_stmt|,
modifier|*
name|current2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|unsigned
name|int
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|current1
operator|=
name|slab1
operator|+
name|reservelen
expr_stmt|;
name|count1
operator|=
operator|*
name|current1
operator|++
operator|*
literal|256
expr_stmt|;
name|count1
operator|+=
operator|*
name|current1
operator|++
expr_stmt|;
name|current2
operator|=
name|slab2
operator|+
name|reservelen
expr_stmt|;
name|count2
operator|=
operator|*
name|current2
operator|++
operator|*
literal|256
expr_stmt|;
name|count2
operator|+=
operator|*
name|current2
operator|++
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
name|count2
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|current1
operator|+=
operator|(
literal|4
operator|*
name|count1
operator|)
expr_stmt|;
name|current2
operator|+=
operator|(
literal|4
operator|*
name|count2
operator|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count1
operator|>
literal|0
condition|)
block|{
name|length1
operator|=
operator|*
name|current1
operator|++
operator|*
literal|256
expr_stmt|;
name|length1
operator|+=
operator|*
name|current1
operator|++
expr_stmt|;
name|length2
operator|=
operator|*
name|current2
operator|++
operator|*
literal|256
expr_stmt|;
name|length2
operator|+=
operator|*
name|current2
operator|++
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|current1
operator|+=
literal|2
expr_stmt|;
name|current2
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|length1
operator|!=
name|length2
operator|||
name|memcmp
argument_list|(
name|current1
argument_list|,
name|current2
argument_list|,
name|length1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|current1
operator|+=
name|length1
expr_stmt|;
name|current2
operator|+=
name|length1
expr_stmt|;
name|count1
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_rdataslab_equalx
parameter_list|(
name|unsigned
name|char
modifier|*
name|slab1
parameter_list|,
name|unsigned
name|char
modifier|*
name|slab2
parameter_list|,
name|unsigned
name|int
name|reservelen
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|current1
decl_stmt|,
modifier|*
name|current2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|dns_rdata_t
name|rdata1
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_t
name|rdata2
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|current1
operator|=
name|slab1
operator|+
name|reservelen
expr_stmt|;
name|count1
operator|=
operator|*
name|current1
operator|++
operator|*
literal|256
expr_stmt|;
name|count1
operator|+=
operator|*
name|current1
operator|++
expr_stmt|;
name|current2
operator|=
name|slab2
operator|+
name|reservelen
expr_stmt|;
name|count2
operator|=
operator|*
name|current2
operator|++
operator|*
literal|256
expr_stmt|;
name|count2
operator|+=
operator|*
name|current2
operator|++
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
name|count2
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|current1
operator|+=
operator|(
literal|4
operator|*
name|count1
operator|)
expr_stmt|;
name|current2
operator|+=
operator|(
literal|4
operator|*
name|count2
operator|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count1
operator|--
operator|>
literal|0
condition|)
block|{
name|rdata_from_slab
argument_list|(
operator|&
name|current1
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|rdata1
argument_list|)
expr_stmt|;
name|rdata_from_slab
argument_list|(
operator|&
name|current2
argument_list|,
name|rdclass
argument_list|,
name|type
argument_list|,
operator|&
name|rdata2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|rdata1
argument_list|,
operator|&
name|rdata2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata1
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

end_unit

