begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2007, 2010, 2011  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1997-2001  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: heap.c,v 1.39.150.2 2011-03-03 23:47:09 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file  * Heap implementation of priority queues adapted from the following:  *  *	\li "Introduction to Algorithms," Cormen, Leiserson, and Rivest,  *	MIT Press / McGraw Hill, 1990, ISBN 0-262-03141-8, chapter 7.  *  *	\li "Algorithms," Second Edition, Sedgewick, Addison-Wesley, 1988,  *	ISBN 0-201-06673-4, chapter 11.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/heap.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_comment
comment|/* Required for memcpy. */
end_comment

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * Note: to make heap_parent and heap_left easy to compute, the first  * element of the heap array is not used; i.e. heap subscripts are 1-based,  * not 0-based.  The parent is index/2, and the left-child is index*2.  * The right child is index*2+1.  */
end_comment

begin_define
define|#
directive|define
name|heap_parent
parameter_list|(
name|i
parameter_list|)
value|((i)>> 1)
end_define

begin_define
define|#
directive|define
name|heap_left
parameter_list|(
name|i
parameter_list|)
value|((i)<< 1)
end_define

begin_comment
comment|/*@}*/
end_comment

begin_define
define|#
directive|define
name|SIZE_INCREMENT
value|1024
end_define

begin_define
define|#
directive|define
name|HEAP_MAGIC
value|ISC_MAGIC('H', 'E', 'A', 'P')
end_define

begin_define
define|#
directive|define
name|VALID_HEAP
parameter_list|(
name|h
parameter_list|)
value|ISC_MAGIC_VALID(h, HEAP_MAGIC)
end_define

begin_comment
comment|/*%  * When the heap is in a consistent state, the following invariant  * holds true: for every element i> 1, heap_parent(i) has a priority  * higher than or equal to that of i.  */
end_comment

begin_define
define|#
directive|define
name|HEAPCONDITION
parameter_list|(
name|i
parameter_list|)
value|((i) == 1 || \ 			  ! heap->compare(heap->array[(i)], \ 					  heap->array[heap_parent(i)]))
end_define

begin_comment
comment|/*% ISC heap structure. */
end_comment

begin_struct
struct|struct
name|isc_heap
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|size_increment
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
name|void
modifier|*
modifier|*
name|array
decl_stmt|;
name|isc_heapcompare_t
name|compare
decl_stmt|;
name|isc_heapindex_t
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|isc_result_t
name|isc_heap_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_heapcompare_t
name|compare
parameter_list|,
name|isc_heapindex_t
name|index
parameter_list|,
name|unsigned
name|int
name|size_increment
parameter_list|,
name|isc_heap_t
modifier|*
modifier|*
name|heapp
parameter_list|)
block|{
name|isc_heap_t
modifier|*
name|heap
decl_stmt|;
name|REQUIRE
argument_list|(
name|heapp
operator|!=
name|NULL
operator|&&
operator|*
name|heapp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|compare
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|heap
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|heap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|heap
operator|->
name|magic
operator|=
name|HEAP_MAGIC
expr_stmt|;
name|heap
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|heap
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|heap
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_increment
operator|==
literal|0
condition|)
name|heap
operator|->
name|size_increment
operator|=
name|SIZE_INCREMENT
expr_stmt|;
else|else
name|heap
operator|->
name|size_increment
operator|=
name|size_increment
expr_stmt|;
name|heap
operator|->
name|last
operator|=
literal|0
expr_stmt|;
name|heap
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
name|heap
operator|->
name|compare
operator|=
name|compare
expr_stmt|;
name|heap
operator|->
name|index
operator|=
name|index
expr_stmt|;
operator|*
name|heapp
operator|=
name|heap
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_heap_destroy
parameter_list|(
name|isc_heap_t
modifier|*
modifier|*
name|heapp
parameter_list|)
block|{
name|isc_heap_t
modifier|*
name|heap
decl_stmt|;
name|REQUIRE
argument_list|(
name|heapp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|heap
operator|=
operator|*
name|heapp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|array
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|heap
operator|->
name|mctx
argument_list|,
name|heap
operator|->
name|array
argument_list|,
name|heap
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|heap
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|heap
operator|->
name|mctx
argument_list|,
name|heap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|heap
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|heapp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|resize
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|new_array
decl_stmt|;
name|size_t
name|new_size
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|heap
operator|->
name|size
operator|+
name|heap
operator|->
name|size_increment
expr_stmt|;
name|new_array
operator|=
name|isc_mem_get
argument_list|(
name|heap
operator|->
name|mctx
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_array
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|heap
operator|->
name|array
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|new_array
argument_list|,
name|heap
operator|->
name|array
argument_list|,
name|heap
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|heap
operator|->
name|mctx
argument_list|,
name|heap
operator|->
name|array
argument_list|,
name|heap
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|heap
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
name|heap
operator|->
name|array
operator|=
name|new_array
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|float_up
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|,
name|void
modifier|*
name|elt
parameter_list|)
block|{
name|unsigned
name|int
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|heap_parent
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|>
literal|1
operator|&&
name|heap
operator|->
name|compare
argument_list|(
name|elt
argument_list|,
name|heap
operator|->
name|array
index|[
name|p
index|]
argument_list|)
condition|;
name|i
operator|=
name|p
operator|,
name|p
operator|=
name|heap_parent
argument_list|(
name|i
argument_list|)
control|)
block|{
name|heap
operator|->
name|array
index|[
name|i
index|]
operator|=
name|heap
operator|->
name|array
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|index
operator|!=
name|NULL
condition|)
call|(
name|heap
operator|->
name|index
call|)
argument_list|(
name|heap
operator|->
name|array
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|heap
operator|->
name|array
index|[
name|i
index|]
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|index
operator|!=
name|NULL
condition|)
call|(
name|heap
operator|->
name|index
call|)
argument_list|(
name|heap
operator|->
name|array
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|HEAPCONDITION
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sink_down
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|,
name|void
modifier|*
name|elt
parameter_list|)
block|{
name|unsigned
name|int
name|j
decl_stmt|,
name|size
decl_stmt|,
name|half_size
decl_stmt|;
name|size
operator|=
name|heap
operator|->
name|last
expr_stmt|;
name|half_size
operator|=
name|size
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|half_size
condition|)
block|{
comment|/* Find the smallest of the (at most) two children. */
name|j
operator|=
name|heap_left
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|size
operator|&&
name|heap
operator|->
name|compare
argument_list|(
name|heap
operator|->
name|array
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|heap
operator|->
name|array
index|[
name|j
index|]
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|compare
argument_list|(
name|elt
argument_list|,
name|heap
operator|->
name|array
index|[
name|j
index|]
argument_list|)
condition|)
break|break;
name|heap
operator|->
name|array
index|[
name|i
index|]
operator|=
name|heap
operator|->
name|array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|index
operator|!=
name|NULL
condition|)
call|(
name|heap
operator|->
name|index
call|)
argument_list|(
name|heap
operator|->
name|array
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
name|heap
operator|->
name|array
index|[
name|i
index|]
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|index
operator|!=
name|NULL
condition|)
call|(
name|heap
operator|->
name|index
call|)
argument_list|(
name|heap
operator|->
name|array
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|HEAPCONDITION
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_heap_insert
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|void
modifier|*
name|elt
parameter_list|)
block|{
name|unsigned
name|int
name|new_last
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|new_last
operator|=
name|heap
operator|->
name|last
operator|+
literal|1
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|new_last
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* overflow check */
if|if
condition|(
name|new_last
operator|>=
name|heap
operator|->
name|size
operator|&&
operator|!
name|resize
argument_list|(
name|heap
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|heap
operator|->
name|last
operator|=
name|new_last
expr_stmt|;
name|float_up
argument_list|(
name|heap
argument_list|,
name|new_last
argument_list|,
name|elt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_heap_delete
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|void
modifier|*
name|elt
decl_stmt|;
name|isc_boolean_t
name|less
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|index
operator|>=
literal|1
operator|&&
name|index
operator|<=
name|heap
operator|->
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|heap
operator|->
name|last
condition|)
block|{
name|heap
operator|->
name|array
index|[
name|heap
operator|->
name|last
index|]
operator|=
name|NULL
expr_stmt|;
name|heap
operator|->
name|last
operator|--
expr_stmt|;
block|}
else|else
block|{
name|elt
operator|=
name|heap
operator|->
name|array
index|[
name|heap
operator|->
name|last
index|]
expr_stmt|;
name|heap
operator|->
name|array
index|[
name|heap
operator|->
name|last
index|]
operator|=
name|NULL
expr_stmt|;
name|heap
operator|->
name|last
operator|--
expr_stmt|;
name|less
operator|=
name|heap
operator|->
name|compare
argument_list|(
name|elt
argument_list|,
name|heap
operator|->
name|array
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|heap
operator|->
name|array
index|[
name|index
index|]
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|less
condition|)
name|float_up
argument_list|(
name|heap
argument_list|,
name|index
argument_list|,
name|heap
operator|->
name|array
index|[
name|index
index|]
argument_list|)
expr_stmt|;
else|else
name|sink_down
argument_list|(
name|heap
argument_list|,
name|index
argument_list|,
name|heap
operator|->
name|array
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|isc_heap_increased
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|index
operator|>=
literal|1
operator|&&
name|index
operator|<=
name|heap
operator|->
name|last
argument_list|)
expr_stmt|;
name|float_up
argument_list|(
name|heap
argument_list|,
name|index
argument_list|,
name|heap
operator|->
name|array
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_heap_decreased
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|index
operator|>=
literal|1
operator|&&
name|index
operator|<=
name|heap
operator|->
name|last
argument_list|)
expr_stmt|;
name|sink_down
argument_list|(
name|heap
argument_list|,
name|index
argument_list|,
name|heap
operator|->
name|array
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc_heap_element
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|index
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<=
name|heap
operator|->
name|last
condition|)
return|return
operator|(
name|heap
operator|->
name|array
index|[
name|index
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_heap_foreach
parameter_list|(
name|isc_heap_t
modifier|*
name|heap
parameter_list|,
name|isc_heapaction_t
name|action
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_HEAP
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|heap
operator|->
name|last
condition|;
name|i
operator|++
control|)
call|(
name|action
call|)
argument_list|(
name|heap
operator|->
name|array
index|[
name|i
index|]
argument_list|,
name|uap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

