begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2001, 2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: time.c,v 1.34.2.6.2.4 2004/03/06 08:15:03 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* Required for struct timeval on some platforms. */
end_comment

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/strerror.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_define
define|#
directive|define
name|NS_PER_S
value|1000000000
end_define

begin_comment
comment|/* Nanoseconds per second. */
end_comment

begin_define
define|#
directive|define
name|NS_PER_US
value|1000
end_define

begin_comment
comment|/* Nanoseconds per microsecond. */
end_comment

begin_define
define|#
directive|define
name|US_PER_S
value|1000000
end_define

begin_comment
comment|/* Microseconds per second. */
end_comment

begin_comment
comment|/*  * All of the INSIST()s checks of nanoseconds< NS_PER_S are for  * consistency checking of the type. In lieu of magic numbers, it  * is the best we've got.  The check is only performed on functions which  * need an initialized type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_FIX_TV_USEC
end_ifndef

begin_define
define|#
directive|define
name|ISC_FIX_TV_USEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***  *** Intervals  ***/
end_comment

begin_decl_stmt
specifier|static
name|isc_interval_t
name|zero_interval
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_interval_t
modifier|*
name|isc_interval_zero
init|=
operator|&
name|zero_interval
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|ISC_FIX_TV_USEC
end_if

begin_function
specifier|static
specifier|inline
name|void
name|fix_tv_usec
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|isc_boolean_t
name|fixed
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
name|tv
operator|->
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|fixed
operator|=
name|ISC_TRUE
expr_stmt|;
do|do
block|{
name|tv
operator|->
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|+=
name|US_PER_S
expr_stmt|;
block|}
do|while
condition|(
name|tv
operator|->
name|tv_usec
operator|<
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|tv
operator|->
name|tv_usec
operator|>=
name|US_PER_S
condition|)
block|{
name|fixed
operator|=
name|ISC_TRUE
expr_stmt|;
do|do
block|{
name|tv
operator|->
name|tv_sec
operator|+=
literal|1
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|-=
name|US_PER_S
expr_stmt|;
block|}
do|while
condition|(
name|tv
operator|->
name|tv_usec
operator|>=
name|US_PER_S
condition|)
do|;
block|}
comment|/* 	 * Call syslog directly as was are called from the logging functions. 	 */
if|if
condition|(
name|fixed
condition|)
operator|(
name|void
operator|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday returned bad tv_usec: corrected"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|isc_interval_set
parameter_list|(
name|isc_interval_t
modifier|*
name|i
parameter_list|,
name|unsigned
name|int
name|seconds
parameter_list|,
name|unsigned
name|int
name|nanoseconds
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|i
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
name|i
operator|->
name|seconds
operator|=
name|seconds
expr_stmt|;
name|i
operator|->
name|nanoseconds
operator|=
name|nanoseconds
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|isc_interval_iszero
parameter_list|(
specifier|const
name|isc_interval_t
modifier|*
name|i
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|i
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|i
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|seconds
operator|==
literal|0
operator|&&
name|i
operator|->
name|nanoseconds
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  *** Absolute Times  ***/
end_comment

begin_decl_stmt
specifier|static
name|isc_time_t
name|epoch
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_time_t
modifier|*
name|isc_time_epoch
init|=
operator|&
name|epoch
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|isc_time_set
parameter_list|(
name|isc_time_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|int
name|seconds
parameter_list|,
name|unsigned
name|int
name|nanoseconds
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
name|t
operator|->
name|seconds
operator|=
name|seconds
expr_stmt|;
name|t
operator|->
name|nanoseconds
operator|=
name|nanoseconds
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_time_settoepoch
parameter_list|(
name|isc_time_t
modifier|*
name|t
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|->
name|seconds
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|nanoseconds
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|isc_time_isepoch
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|seconds
operator|==
literal|0
operator|&&
name|t
operator|->
name|nanoseconds
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_time_now
parameter_list|(
name|isc_time_t
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
comment|/* 	 * Does POSIX guarantee the signedness of tv_sec and tv_usec?  If not, 	 * then this test will generate warnings for platforms on which it is 	 * unsigned.  In any event, the chances of any of these problems 	 * happening are pretty much zero, but since the libisc library ensures 	 * certain things to be true ... 	 */
if|#
directive|if
name|ISC_FIX_TV_USEC
name|fix_tv_usec
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|>=
name|US_PER_S
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Ensure the tv_sec value fits in t->seconds. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|t
operator|->
name|seconds
argument_list|)
operator|&&
operator|(
operator|(
name|tv
operator|.
name|tv_sec
operator||
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|)
operator|^
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|)
operator|!=
literal|0U
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|t
operator|->
name|seconds
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|t
operator|->
name|nanoseconds
operator|=
name|tv
operator|.
name|tv_usec
operator|*
name|NS_PER_US
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_time_nowplusinterval
parameter_list|(
name|isc_time_t
modifier|*
name|t
parameter_list|,
specifier|const
name|isc_interval_t
modifier|*
name|i
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|i
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|i
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
comment|/* 	 * Does POSIX guarantee the signedness of tv_sec and tv_usec?  If not, 	 * then this test will generate warnings for platforms on which it is 	 * unsigned.  In any event, the chances of any of these problems 	 * happening are pretty much zero, but since the libisc library ensures 	 * certain things to be true ... 	 */
if|#
directive|if
name|ISC_FIX_TV_USEC
name|fix_tv_usec
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|>=
name|US_PER_S
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Ensure the resulting seconds value fits in the size of an 	 * unsigned int.  (It is written this way as a slight optimization; 	 * note that even if both values == INT_MAX, then when added 	 * and getting another 1 added below the result is UINT_MAX.) 	 */
if|if
condition|(
operator|(
name|tv
operator|.
name|tv_sec
operator|>
name|INT_MAX
operator|||
name|i
operator|->
name|seconds
operator|>
name|INT_MAX
operator|)
operator|&&
operator|(
operator|(
name|long
name|long
operator|)
name|tv
operator|.
name|tv_sec
operator|+
name|i
operator|->
name|seconds
operator|>
name|UINT_MAX
operator|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|t
operator|->
name|seconds
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|i
operator|->
name|seconds
expr_stmt|;
name|t
operator|->
name|nanoseconds
operator|=
name|tv
operator|.
name|tv_usec
operator|*
name|NS_PER_US
operator|+
name|i
operator|->
name|nanoseconds
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|nanoseconds
operator|>
name|NS_PER_S
condition|)
block|{
name|t
operator|->
name|seconds
operator|++
expr_stmt|;
name|t
operator|->
name|nanoseconds
operator|-=
name|NS_PER_S
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isc_time_compare
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t1
parameter_list|,
specifier|const
name|isc_time_t
modifier|*
name|t2
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t1
operator|!=
name|NULL
operator|&&
name|t2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t1
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
operator|&&
name|t2
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|seconds
operator|<
name|t2
operator|->
name|seconds
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|t1
operator|->
name|seconds
operator|>
name|t2
operator|->
name|seconds
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|t1
operator|->
name|nanoseconds
operator|<
name|t2
operator|->
name|nanoseconds
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|t1
operator|->
name|nanoseconds
operator|>
name|t2
operator|->
name|nanoseconds
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_time_add
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|,
specifier|const
name|isc_interval_t
modifier|*
name|i
parameter_list|,
name|isc_time_t
modifier|*
name|result
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
operator|&&
name|i
operator|!=
name|NULL
operator|&&
name|result
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
operator|&&
name|i
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure the resulting seconds value fits in the size of an 	 * unsigned int.  (It is written this way as a slight optimization; 	 * note that even if both values == INT_MAX, then when added 	 * and getting another 1 added below the result is UINT_MAX.) 	 */
if|if
condition|(
operator|(
name|t
operator|->
name|seconds
operator|>
name|INT_MAX
operator|||
name|i
operator|->
name|seconds
operator|>
name|INT_MAX
operator|)
operator|&&
operator|(
operator|(
name|long
name|long
operator|)
name|t
operator|->
name|seconds
operator|+
name|i
operator|->
name|seconds
operator|>
name|UINT_MAX
operator|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|result
operator|->
name|seconds
operator|=
name|t
operator|->
name|seconds
operator|+
name|i
operator|->
name|seconds
expr_stmt|;
name|result
operator|->
name|nanoseconds
operator|=
name|t
operator|->
name|nanoseconds
operator|+
name|i
operator|->
name|nanoseconds
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|nanoseconds
operator|>=
name|NS_PER_S
condition|)
block|{
name|result
operator|->
name|seconds
operator|++
expr_stmt|;
name|result
operator|->
name|nanoseconds
operator|-=
name|NS_PER_S
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_time_subtract
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|,
specifier|const
name|isc_interval_t
modifier|*
name|i
parameter_list|,
name|isc_time_t
modifier|*
name|result
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
operator|&&
name|i
operator|!=
name|NULL
operator|&&
name|result
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
operator|&&
name|i
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|t
operator|->
name|seconds
operator|<
name|i
operator|->
name|seconds
operator|||
operator|(
operator|(
name|unsigned
name|int
operator|)
name|t
operator|->
name|seconds
operator|==
name|i
operator|->
name|seconds
operator|&&
name|t
operator|->
name|nanoseconds
operator|<
name|i
operator|->
name|nanoseconds
operator|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|result
operator|->
name|seconds
operator|=
name|t
operator|->
name|seconds
operator|-
name|i
operator|->
name|seconds
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|nanoseconds
operator|>=
name|i
operator|->
name|nanoseconds
condition|)
name|result
operator|->
name|nanoseconds
operator|=
name|t
operator|->
name|nanoseconds
operator|-
name|i
operator|->
name|nanoseconds
expr_stmt|;
else|else
block|{
name|result
operator|->
name|nanoseconds
operator|=
name|NS_PER_S
operator|-
name|i
operator|->
name|nanoseconds
operator|+
name|t
operator|->
name|nanoseconds
expr_stmt|;
name|result
operator|->
name|seconds
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint64_t
name|isc_time_microdiff
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t1
parameter_list|,
specifier|const
name|isc_time_t
modifier|*
name|t2
parameter_list|)
block|{
name|isc_uint64_t
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|i3
decl_stmt|;
name|REQUIRE
argument_list|(
name|t1
operator|!=
name|NULL
operator|&&
name|t2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t1
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
operator|&&
name|t2
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|(
name|isc_uint64_t
operator|)
name|t1
operator|->
name|seconds
operator|*
name|NS_PER_S
operator|+
name|t1
operator|->
name|nanoseconds
expr_stmt|;
name|i2
operator|=
operator|(
name|isc_uint64_t
operator|)
name|t2
operator|->
name|seconds
operator|*
name|NS_PER_S
operator|+
name|t2
operator|->
name|nanoseconds
expr_stmt|;
if|if
condition|(
name|i1
operator|<=
name|i2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i3
operator|=
name|i1
operator|-
name|i2
expr_stmt|;
comment|/* 	 * Convert to microseconds. 	 */
name|i3
operator|=
operator|(
name|i1
operator|-
name|i2
operator|)
operator|/
name|NS_PER_US
expr_stmt|;
return|return
operator|(
name|i3
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|isc_time_seconds
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_uint32_t
operator|)
name|t
operator|->
name|seconds
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_time_secondsastimet
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|,
name|time_t
modifier|*
name|secondsp
parameter_list|)
block|{
name|isc_uint64_t
name|i
decl_stmt|;
name|time_t
name|seconds
decl_stmt|;
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the number of seconds represented by t->seconds 	 * can be represented by a time_t.  Since t->seconds is an unsigned 	 * int and since time_t is mostly opaque, this is trickier than 	 * it seems.  (This standardized opaqueness of time_t is *very* 	 * frustrating; time_t is not even limited to being an integral 	 * type.) 	 * 	 * The mission, then, is to avoid generating any kind of warning 	 * about "signed versus unsigned" while trying to determine if the 	 * the unsigned int t->seconds is out range for tv_sec, which is 	 * pretty much only true if time_t is a signed integer of the same 	 * size as the return value of isc_time_seconds. 	 * 	 * The use of the 64 bit integer ``i'' takes advantage of C's 	 * conversion rules to either zero fill or sign extend the widened 	 * type. 	 * 	 * Solaris 5.6 gives this warning about the left shift: 	 *	warning: integer overflow detected: op "<<" 	 * if the U(nsigned) qualifier is not on the 1. 	 */
name|seconds
operator|=
operator|(
name|time_t
operator|)
name|t
operator|->
name|seconds
expr_stmt|;
name|INSIST
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|==
sizeof|sizeof
argument_list|(
name|isc_uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|isc_uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|isc_uint32_t
argument_list|)
operator|&&
comment|/* Same size. */
operator|(
name|time_t
operator|)
literal|0.5
operator|!=
literal|0.5
operator|&&
comment|/* Not a floating point type. */
operator|(
name|i
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|)
operator|!=
literal|4294967295u
operator|&&
comment|/* Is signed. */
operator|(
name|seconds
operator|&
operator|(
literal|1U
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0U
condition|)
block|{
comment|/* Negative. */
comment|/* 		 * This UNUSED() is here to shut up the IRIX compiler: 		 *	variable "i" was set but never used 		 * when the value of i *was* used in the third test. 		 * (Let's hope the compiler got the actual test right.) 		 */
name|UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
operator|*
name|secondsp
operator|=
name|seconds
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|isc_time_nanoseconds
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|t
operator|->
name|nanoseconds
operator|<
name|NS_PER_S
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_uint32_t
operator|)
name|t
operator|->
name|nanoseconds
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_time_formattimestamp
parameter_list|(
specifier|const
name|isc_time_t
modifier|*
name|t
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|unsigned
name|int
name|flen
decl_stmt|;
name|REQUIRE
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|now
operator|=
operator|(
name|time_t
operator|)
name|t
operator|->
name|seconds
expr_stmt|;
name|flen
operator|=
name|strftime
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%d-%b-%Y %X"
argument_list|,
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|flen
operator|<
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|!=
literal|0
condition|)
name|snprintf
argument_list|(
name|buf
operator|+
name|flen
argument_list|,
name|len
operator|-
name|flen
argument_list|,
literal|".%03u"
argument_list|,
name|t
operator|->
name|nanoseconds
operator|/
literal|1000000
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"99-Bad-9999 99:99:99.999"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

