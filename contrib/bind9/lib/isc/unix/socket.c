begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: socket.c,v 1.207.2.19.2.26 2006/05/19 02:53:36 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/bufferlist.h>
end_include

begin_include
include|#
directive|include
file|<isc/condition.h>
end_include

begin_include
include|#
directive|include
file|<isc/formatcheck.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/socket.h>
end_include

begin_include
include|#
directive|include
file|<isc/strerror.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|"errno2result.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_include
include|#
directive|include
file|"socket_p.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_comment
comment|/*  * Some systems define the socket length argument as an int, some as size_t,  * some as socklen_t.  This is here so it can be easily changed if needed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_SOCKADDR_LEN_T
end_ifndef

begin_define
define|#
directive|define
name|ISC_SOCKADDR_LEN_T
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define what the possible "soft" errors can be.  These are non-fatal returns  * of various network related functions, like recv() and so on.  *  * For some reason, BSDI (and perhaps others) will sometimes return<0  * from recv() but will have errno==0.  This is broken, but we have to  * work around it here.  */
end_comment

begin_define
define|#
directive|define
name|SOFT_ERROR
parameter_list|(
name|e
parameter_list|)
value|((e) == EAGAIN || \ 			 (e) == EWOULDBLOCK || \ 			 (e) == EINTR || \ 			 (e) == 0)
end_define

begin_define
define|#
directive|define
name|DLVL
parameter_list|(
name|x
parameter_list|)
value|ISC_LOGCATEGORY_GENERAL, ISC_LOGMODULE_SOCKET, ISC_LOG_DEBUG(x)
end_define

begin_comment
comment|/*  * DLVL(90)  --  Function entry/exit and other tracing.  * DLVL(70)  --  Socket "correctness" -- including returning of events, etc.  * DLVL(60)  --  Socket data send/receive  * DLVL(50)  --  Event tracing, including receiving/sending completion events.  * DLVL(20)  --  Socket creation/destruction.  */
end_comment

begin_define
define|#
directive|define
name|TRACE_LEVEL
value|90
end_define

begin_define
define|#
directive|define
name|CORRECTNESS_LEVEL
value|70
end_define

begin_define
define|#
directive|define
name|IOEVENT_LEVEL
value|60
end_define

begin_define
define|#
directive|define
name|EVENT_LEVEL
value|50
end_define

begin_define
define|#
directive|define
name|CREATION_LEVEL
value|20
end_define

begin_define
define|#
directive|define
name|TRACE
value|DLVL(TRACE_LEVEL)
end_define

begin_define
define|#
directive|define
name|CORRECTNESS
value|DLVL(CORRECTNESS_LEVEL)
end_define

begin_define
define|#
directive|define
name|IOEVENT
value|DLVL(IOEVENT_LEVEL)
end_define

begin_define
define|#
directive|define
name|EVENT
value|DLVL(EVENT_LEVEL)
end_define

begin_define
define|#
directive|define
name|CREATION
value|DLVL(CREATION_LEVEL)
end_define

begin_typedef
typedef|typedef
name|isc_event_t
name|intev_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SOCKET_MAGIC
value|ISC_MAGIC('I', 'O', 'i', 'o')
end_define

begin_define
define|#
directive|define
name|VALID_SOCKET
parameter_list|(
name|t
parameter_list|)
value|ISC_MAGIC_VALID(t, SOCKET_MAGIC)
end_define

begin_comment
comment|/*  * IPv6 control information.  If the socket is an IPv6 socket we want  * to collect the destination address and interface so the client can  * set them on outgoing packets.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_CMSG
end_ifndef

begin_define
define|#
directive|define
name|USE_CMSG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * NetBSD and FreeBSD can timestamp packets.  XXXMLG Should we have  * a setsockopt() like interface to request timestamps, and if the OS  * doesn't do it for us, call gettimeofday() on every UDP receive?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_CMSG
end_ifndef

begin_define
define|#
directive|define
name|USE_CMSG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The number of times a send operation is repeated if the result is EINTR.  */
end_comment

begin_define
define|#
directive|define
name|NRETRIES
value|10
end_define

begin_struct
struct|struct
name|isc_socket
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_sockettype_t
name|type
decl_stmt|;
comment|/* Locked by socket lock. */
name|ISC_LINK
argument_list|(
argument|isc_socket_t
argument_list|)
name|link
expr_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|pf
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socketevent_t
argument_list|)
name|send_list
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socketevent_t
argument_list|)
name|recv_list
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socket_newconnev_t
argument_list|)
name|accept_list
expr_stmt|;
name|isc_socket_connev_t
modifier|*
name|connect_ev
decl_stmt|;
comment|/* 	 * Internal events.  Posted when a descriptor is readable or 	 * writable.  These are statically allocated and never freed. 	 * They will be set to non-purgable before use. 	 */
name|intev_t
name|readable_ev
decl_stmt|;
name|intev_t
name|writable_ev
decl_stmt|;
name|isc_sockaddr_t
name|address
decl_stmt|;
comment|/* remote address */
name|unsigned
name|int
name|pending_recv
range|:
literal|1
decl_stmt|,
name|pending_send
range|:
literal|1
decl_stmt|,
name|pending_accept
range|:
literal|1
decl_stmt|,
name|listener
range|:
literal|1
decl_stmt|,
comment|/* listener socket */
name|connected
range|:
literal|1
decl_stmt|,
name|connecting
range|:
literal|1
decl_stmt|,
comment|/* connect pending */
name|bound
range|:
literal|1
decl_stmt|;
comment|/* bound to local addr */
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
name|unsigned
name|char
name|overflow
decl_stmt|;
comment|/* used for MSG_TRUNC fake */
endif|#
directive|endif
name|char
modifier|*
name|recvcmsgbuf
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|recvcmsgbuflen
decl_stmt|;
name|char
modifier|*
name|sendcmsgbuf
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|sendcmsgbuflen
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SOCKET_MANAGER_MAGIC
value|ISC_MAGIC('I', 'O', 'm', 'g')
end_define

begin_define
define|#
directive|define
name|VALID_MANAGER
parameter_list|(
name|m
parameter_list|)
value|ISC_MAGIC_VALID(m, SOCKET_MANAGER_MAGIC)
end_define

begin_struct
struct|struct
name|isc_socketmgr
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by manager lock. */
name|ISC_LIST
argument_list|(
argument|isc_socket_t
argument_list|)
name|socklist
expr_stmt|;
name|fd_set
name|read_fds
decl_stmt|;
name|fd_set
name|write_fds
decl_stmt|;
name|isc_socket_t
modifier|*
name|fds
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
name|int
name|fdstate
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_thread_t
name|watcher
decl_stmt|;
name|isc_condition_t
name|shutdown_ok
decl_stmt|;
name|int
name|pipe_fds
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
name|unsigned
name|int
name|refs
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_decl_stmt
specifier|static
name|isc_socketmgr_t
modifier|*
name|socketmgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* this one must be zero */
end_comment

begin_define
define|#
directive|define
name|MANAGED
value|1
end_define

begin_define
define|#
directive|define
name|CLOSE_PENDING
value|2
end_define

begin_comment
comment|/*  * send() and recv() iovec counts  */
end_comment

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_SEND
value|(ISC_SOCKET_MAXSCATTERGATHER)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
end_ifdef

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_RECV
value|(ISC_SOCKET_MAXSCATTERGATHER + 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_RECV
value|(ISC_SOCKET_MAXSCATTERGATHER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|send_recvdone_event
parameter_list|(
name|isc_socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_senddone_event
parameter_list|(
name|isc_socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_socket
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|allocate_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
parameter_list|,
name|isc_sockettype_t
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_accept
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_connect
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_recv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_send
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_cmsg
parameter_list|(
name|isc_socket_t
modifier|*
parameter_list|,
name|struct
name|msghdr
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_msghdr_send
parameter_list|(
name|isc_socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
parameter_list|,
name|struct
name|msghdr
modifier|*
parameter_list|,
name|struct
name|iovec
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_msghdr_recv
parameter_list|(
name|isc_socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
parameter_list|,
name|struct
name|msghdr
modifier|*
parameter_list|,
name|struct
name|iovec
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SELECT_POKE_SHUTDOWN
value|(-1)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_NOTHING
value|(-2)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_READ
value|(-3)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_ACCEPT
value|(-3)
end_define

begin_comment
comment|/* Same as _READ */
end_comment

begin_define
define|#
directive|define
name|SELECT_POKE_WRITE
value|(-4)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_CONNECT
value|(-4)
end_define

begin_comment
comment|/* Same as _WRITE */
end_comment

begin_define
define|#
directive|define
name|SELECT_POKE_CLOSE
value|(-5)
end_define

begin_define
define|#
directive|define
name|SOCK_DEAD
parameter_list|(
name|s
parameter_list|)
value|((s)->references == 0)
end_define

begin_function_decl
specifier|static
name|void
name|manager_log
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|5
operator|,
function_decl|6
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|manager_log
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"sockmgr %p: %s"
argument_list|,
name|sockmgr
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|socket_log
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|9
operator|,
function_decl|10
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|socket_log
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|NULL
condition|)
block|{
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|message
argument_list|,
literal|"socket %p: %s"
argument_list|,
name|sock
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_sockaddr_format
argument_list|(
name|address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|message
argument_list|,
literal|"socket %p %s: %s"
argument_list|,
name|sock
argument_list|,
name|peerbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wakeup_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
comment|/* 	 * This is a wakeup on a socket.  If the socket is not in the 	 * process of being closed, start watching it for either reads 	 * or writes. 	 */
name|INSIST
argument_list|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
operator|(
name|int
operator|)
name|FD_SETSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|==
name|CLOSE_PENDING
condition|)
block|{
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|=
name|CLOSED
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|!=
name|MANAGED
condition|)
return|return;
name|sock
operator|=
name|manager
operator|->
name|fds
index|[
name|fd
index|]
expr_stmt|;
comment|/* 	 * Set requested bit. 	 */
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|FD_SET
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_WRITE
condition|)
name|FD_SET
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_comment
comment|/*  * Poke the select loop when there is something for us to do.  * The write is required (by POSIX) to complete.  That is, we  * will not get partial writes.  */
end_comment

begin_function
specifier|static
name|void
name|select_poke
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|int
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|msg
expr_stmt|;
do|do
block|{
name|cc
operator|=
name|write
argument_list|(
name|mgr
operator|->
name|pipe_fds
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENOSR
comment|/* 		 * Treat ENOSR as EAGAIN but loop slowly as it is 		 * unlikely to clear fast. 		 */
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOSR
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EAGAIN
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
name|cc
operator|<
literal|0
operator|&&
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
do|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_WRITEFAILED
argument_list|,
literal|"write() failed "
literal|"during watcher poke: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|cc
operator|==
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a message on the internal fd.  */
end_comment

begin_function
specifier|static
name|void
name|select_readmsg
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|,
name|int
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|cc
operator|=
name|read
argument_list|(
name|mgr
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
operator|*
name|msg
operator|=
name|SELECT_POKE_NOTHING
expr_stmt|;
operator|*
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Silence compiler. */
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
return|return;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_READFAILED
argument_list|,
literal|"read() failed "
literal|"during watcher poke: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|cc
operator|==
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fd
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|msg
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_comment
comment|/*  * Update the state of the socketmgr when something changes.  */
end_comment

begin_function
specifier|static
name|void
name|select_poke
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_SHUTDOWN
condition|)
return|return;
elseif|else
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|wakeup_socket
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_comment
comment|/*  * Make a fd non-blocking.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|make_nonblock
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
expr_stmt|;
else|#
directive|else
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator||=
name|PORT_NONBLOCK
expr_stmt|;
name|ret
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
literal|"ioctl(%d, FIONBIO,&on): %s"
argument_list|,
name|fd
argument_list|,
else|#
directive|else
literal|"fcntl(%d, F_SETFL, %d): %s"
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CMSG
end_ifdef

begin_comment
comment|/*  * Not all OSes support advanced CMSG macros: CMSG_LEN and CMSG_SPACE.  * In order to ensure as much portability as possible, we provide wrapper  * functions of these macros.  * Note that cmsg_space() could run slow on OSes that do not have  * CMSG_SPACE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ISC_SOCKADDR_LEN_T
name|cmsg_len
parameter_list|(
name|ISC_SOCKADDR_LEN_T
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMSG_LEN
return|return
operator|(
name|CMSG_LEN
argument_list|(
name|len
argument_list|)
operator|)
return|;
else|#
directive|else
name|ISC_SOCKADDR_LEN_T
name|hdrlen
decl_stmt|;
comment|/* 	 * Cast NULL so that any pointer arithmetic performed by CMSG_DATA 	 * is correct. 	 */
name|hdrlen
operator|=
operator|(
name|ISC_SOCKADDR_LEN_T
operator|)
name|CMSG_DATA
argument_list|(
operator|(
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdrlen
operator|+
name|len
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ISC_SOCKADDR_LEN_T
name|cmsg_space
parameter_list|(
name|ISC_SOCKADDR_LEN_T
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMSG_SPACE
return|return
operator|(
name|CMSG_SPACE
argument_list|(
name|len
argument_list|)
operator|)
return|;
else|#
directive|else
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsgp
decl_stmt|;
comment|/* 	 * XXX: The buffer length is an ad-hoc value, but should be enough 	 * in a practical sense. 	 */
name|char
name|dummybuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
operator|+
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|dummybuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|dummybuf
argument_list|)
expr_stmt|;
name|cmsgp
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|dummybuf
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_len
operator|=
name|cmsg_len
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|cmsgp
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|msg
argument_list|,
name|cmsgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmsgp
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|cmsgp
operator|-
operator|(
name|char
operator|*
operator|)
name|msg
operator|.
name|msg_control
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CMSG */
end_comment

begin_comment
comment|/*  * Process control messages received on a socket.  */
end_comment

begin_function
specifier|static
name|void
name|process_cmsg
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_CMSG
name|struct
name|cmsghdr
modifier|*
name|cmsgp
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
name|struct
name|in6_pktinfo
modifier|*
name|pktinfop
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
name|struct
name|timeval
modifier|*
name|timevalp
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * sock is used only when ISC_NET_BSD44MSGHDR and USE_CMSG are defined. 	 * msg and dev are used only when ISC_NET_BSD44MSGHDR is defined. 	 * They are all here, outside of the CPP tests, because it is 	 * more consistent with the usual ISC coding style. 	 */
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
ifdef|#
directive|ifdef
name|MSG_TRUNC
if|if
condition|(
operator|(
name|msg
operator|->
name|msg_flags
operator|&
name|MSG_TRUNC
operator|)
operator|==
name|MSG_TRUNC
condition|)
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_TRUNC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MSG_CTRUNC
if|if
condition|(
operator|(
name|msg
operator|->
name|msg_flags
operator|&
name|MSG_CTRUNC
operator|)
operator|==
name|MSG_CTRUNC
condition|)
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_CTRUNC
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE_CMSG
return|return;
else|#
directive|else
if|if
condition|(
name|msg
operator|->
name|msg_controllen
operator|==
literal|0U
operator|||
name|msg
operator|->
name|msg_control
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
name|timevalp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
name|pktinfop
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|cmsgp
operator|=
name|CMSG_FIRSTHDR
argument_list|(
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmsgp
operator|!=
name|NULL
condition|)
block|{
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PROCESSCMSG
argument_list|,
literal|"processing cmsg %p"
argument_list|,
name|cmsgp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
if|if
condition|(
name|cmsgp
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cmsgp
operator|->
name|cmsg_type
operator|==
name|IPV6_PKTINFO
condition|)
block|{
name|pktinfop
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|pktinfo
argument_list|,
name|pktinfop
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_PKTINFO
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_IFRECEIVED
argument_list|,
literal|"interface received on ifindex %u"
argument_list|,
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|pktinfop
operator|->
name|ipi6_addr
argument_list|)
condition|)
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_MULTICAST
expr_stmt|;
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
if|if
condition|(
name|cmsgp
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cmsgp
operator|->
name|cmsg_type
operator|==
name|SCM_TIMESTAMP
condition|)
block|{
name|timevalp
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
expr_stmt|;
name|dev
operator|->
name|timestamp
operator|.
name|seconds
operator|=
name|timevalp
operator|->
name|tv_sec
expr_stmt|;
name|dev
operator|->
name|timestamp
operator|.
name|nanoseconds
operator|=
name|timevalp
operator|->
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_TIMESTAMP
expr_stmt|;
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
name|next
label|:
name|cmsgp
operator|=
name|CMSG_NXTHDR
argument_list|(
name|msg
argument_list|,
name|cmsgp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CMSG */
endif|#
directive|endif
comment|/* ISC_NET_BSD44MSGHDR */
block|}
end_function

begin_comment
comment|/*  * Construct an iov array and attach it to the msghdr passed in.  This is  * the SEND constructor, which will use the used region of the buffer  * (if using a buffer list) or will use the internal region (if a single  * buffer I/O is requested).  *  * Nothing can be NULL, and the done event must list at least one buffer  * on the buffer linked list for this function to be meaningful.  *  * If write_countp != NULL, *write_countp will hold the number of bytes  * this transaction can send.  */
end_comment

begin_function
specifier|static
name|void
name|build_msghdr_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|size_t
modifier|*
name|write_countp
parameter_list|)
block|{
name|unsigned
name|int
name|iovcount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_region_t
name|used
decl_stmt|;
name|size_t
name|write_count
decl_stmt|;
name|size_t
name|skip_count
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
name|dev
operator|->
name|address
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|->
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
literal|0
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|write_count
operator|=
literal|0
expr_stmt|;
name|iovcount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Single buffer I/O?  Skip what we've done so far in this region. 	 */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|write_count
operator|=
name|dev
operator|->
name|region
operator|.
name|length
operator|-
name|dev
operator|->
name|n
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|dev
operator|->
name|region
operator|.
name|base
operator|+
name|dev
operator|->
name|n
operator|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|write_count
expr_stmt|;
name|iovcount
operator|=
literal|1
expr_stmt|;
goto|goto
name|config
goto|;
block|}
comment|/* 	 * Multibuffer I/O. 	 * Skip the data in the buffer list that we have already written. 	 */
name|skip_count
operator|=
name|dev
operator|->
name|n
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_count
operator|<
name|isc_buffer_usedlength
argument_list|(
name|buffer
argument_list|)
condition|)
break|break;
name|skip_count
operator|-=
name|isc_buffer_usedlength
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|iovcount
operator|<
name|MAXSCATTERGATHER_SEND
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|used
operator|.
name|base
operator|+
name|skip_count
operator|)
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_len
operator|=
name|used
operator|.
name|length
operator|-
name|skip_count
expr_stmt|;
name|write_count
operator|+=
operator|(
name|used
operator|.
name|length
operator|-
name|skip_count
operator|)
expr_stmt|;
name|skip_count
operator|=
literal|0
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|skip_count
operator|==
literal|0U
argument_list|)
expr_stmt|;
name|config
label|:
name|msg
operator|->
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|->
name|msg_iovlen
operator|=
name|iovcount
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
name|msg
operator|->
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|msg_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIN6PKTINFO
argument_list|)
if|if
condition|(
operator|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
operator|)
operator|&&
operator|(
operator|(
name|dev
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_PKTINFO
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|cmsghdr
modifier|*
name|cmsgp
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pktinfop
decl_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_SENDTODATA
argument_list|,
literal|"sendto pktinfo data, ifindex %u"
argument_list|,
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
argument_list|)
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|msg
operator|->
name|msg_controllen
operator|<=
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|msg
operator|->
name|msg_control
operator|=
operator|(
name|void
operator|*
operator|)
name|sock
operator|->
name|sendcmsgbuf
expr_stmt|;
name|cmsgp
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|sock
operator|->
name|sendcmsgbuf
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_len
operator|=
name|cmsg_len
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|pktinfop
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pktinfop
argument_list|,
operator|&
name|dev
operator|->
name|pktinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CMSG&& ISC_PLATFORM_HAVEIPV6 */
else|#
directive|else
comment|/* ISC_NET_BSD44MSGHDR */
name|msg
operator|->
name|msg_accrights
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_accrightslen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_NET_BSD44MSGHDR */
if|if
condition|(
name|write_countp
operator|!=
name|NULL
condition|)
operator|*
name|write_countp
operator|=
name|write_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an iov array and attach it to the msghdr passed in.  This is  * the RECV constructor, which will use the avialable region of the buffer  * (if using a buffer list) or will use the internal region (if a single  * buffer I/O is requested).  *  * Nothing can be NULL, and the done event must list at least one buffer  * on the buffer linked list for this function to be meaningful.  *  * If read_countp != NULL, *read_countp will hold the number of bytes  * this transaction can receive.  */
end_comment

begin_function
specifier|static
name|void
name|build_msghdr_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|size_t
modifier|*
name|read_countp
parameter_list|)
block|{
name|unsigned
name|int
name|iovcount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_region_t
name|available
decl_stmt|;
name|size_t
name|read_count
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msghdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|memset
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_RECVMSG
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESYSUNH
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_UNIX
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sunix
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sunix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
comment|/* If needed, steal one iovec for overflow detection. */
name|maxiov
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* TCP */
name|msg
operator|->
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|address
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|read_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Single buffer I/O?  Skip what we've done so far in this region. 	 */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|read_count
operator|=
name|dev
operator|->
name|region
operator|.
name|length
operator|-
name|dev
operator|->
name|n
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|dev
operator|->
name|region
operator|.
name|base
operator|+
name|dev
operator|->
name|n
operator|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|read_count
expr_stmt|;
name|iovcount
operator|=
literal|1
expr_stmt|;
goto|goto
name|config
goto|;
block|}
comment|/* 	 * Multibuffer I/O. 	 * Skip empty buffers. 	 */
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|iovcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|iovcount
operator|<
name|MAXSCATTERGATHER_RECV
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|available
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|available
operator|.
name|base
operator|)
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_len
operator|=
name|available
operator|.
name|length
expr_stmt|;
name|read_count
operator|+=
name|available
operator|.
name|length
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|config
label|:
comment|/* 	 * If needed, set up to receive that one extra byte.  Note that 	 * we know there is at least one iov left, since we stole it 	 * at the top of this function. 	 */
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|sock
operator|->
name|overflow
operator|)
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_len
operator|=
literal|1
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|msg
operator|->
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|->
name|msg_iovlen
operator|=
name|iovcount
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
name|msg
operator|->
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|msg_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|msg
operator|->
name|msg_control
operator|=
name|sock
operator|->
name|recvcmsgbuf
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
name|sock
operator|->
name|recvcmsgbuflen
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CMSG */
else|#
directive|else
comment|/* ISC_NET_BSD44MSGHDR */
name|msg
operator|->
name|msg_accrights
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_accrightslen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_NET_BSD44MSGHDR */
if|if
condition|(
name|read_countp
operator|!=
name|NULL
condition|)
operator|*
name|read_countp
operator|=
name|read_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_dev_address
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
name|dev
operator|->
name|address
operator|=
operator|*
name|address
expr_stmt|;
else|else
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|address
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
condition|)
block|{
name|INSIST
argument_list|(
name|address
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|address
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_socketevent_t
modifier|*
name|allocate_socketevent
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_eventtype_t
name|eventtype
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|ev
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
name|eventtype
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ev
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|ev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|ev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|ev
operator|->
name|region
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|ev
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dump_msg
parameter_list|(
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"MSGHDR %p\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tname %p, namelen %d\n"
argument_list|,
name|msg
operator|->
name|msg_name
argument_list|,
name|msg
operator|->
name|msg_namelen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tiov %p, iovlen %d\n"
argument_list|,
name|msg
operator|->
name|msg_iov
argument_list|,
name|msg
operator|->
name|msg_iovlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|msg
operator|->
name|msg_iovlen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t\t%d\tbase %p, len %d\n"
argument_list|,
name|i
argument_list|,
name|msg
operator|->
name|msg_iov
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|msg
operator|->
name|msg_iov
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
name|printf
argument_list|(
literal|"\tcontrol %p, controllen %d\n"
argument_list|,
name|msg
operator|->
name|msg_control
argument_list|,
name|msg
operator|->
name|msg_controllen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOIO_SUCCESS
value|0
end_define

begin_comment
comment|/* i/o ok, event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_SOFT
value|1
end_define

begin_comment
comment|/* i/o ok, soft error, no event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_HARD
value|2
end_define

begin_comment
comment|/* i/o error, event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_EOF
value|3
end_define

begin_comment
comment|/* EOF, no event sent */
end_comment

begin_function
specifier|static
name|int
name|doio_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|MAXSCATTERGATHER_RECV
index|]
decl_stmt|;
name|size_t
name|read_count
decl_stmt|;
name|size_t
name|actual_count
decl_stmt|;
name|struct
name|msghdr
name|msghdr
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|recv_errno
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|build_msghdr_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
operator|&
name|msghdr
argument_list|,
name|iov
argument_list|,
operator|&
name|read_count
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
name|dump_msg
argument_list|(
operator|&
name|msghdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc
operator|=
name|recvmsg
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|msghdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recv_errno
operator|=
name|errno
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
name|dump_msg
argument_list|(
operator|&
name|msghdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|recv_errno
argument_list|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|IOEVENT_LEVEL
argument_list|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|recv_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DOIORECV
argument_list|,
literal|"doio_recv: recvmsg(%d) %d bytes, err %d/%s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|cc
argument_list|,
name|recv_errno
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|SOFT_OR_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (recv_errno == _system) { \ 		if (sock->connected) { \ 			dev->result = _isc; \ 			return (DOIO_HARD); \ 		} \ 		return (DOIO_SOFT); \ 	}
define|#
directive|define
name|ALWAYS_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (recv_errno == _system) { \ 		dev->result = _isc; \ 		return (DOIO_HARD); \ 	}
name|SOFT_OR_HARD
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|SOFT_OR_HARD
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|SOFT_OR_HARD
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|SOFT_OR_HARD
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTDOWN
argument_list|)
expr_stmt|;
comment|/* HPUX 11.11 can return EADDRNOTAVAIL. */
name|SOFT_OR_HARD
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SOFT_OR_HARD
undef|#
directive|undef
name|ALWAYS_HARD
name|dev
operator|->
name|result
operator|=
name|isc__errno2result
argument_list|(
name|recv_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|DOIO_HARD
operator|)
return|;
block|}
comment|/* 	 * On TCP, zero length reads indicate EOF, while on 	 * UDP, zero length reads are perfectly valid, although 	 * strange. 	 */
if|if
condition|(
operator|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
operator|)
operator|&&
operator|(
name|cc
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|DOIO_EOF
operator|)
return|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|dev
operator|->
name|address
operator|.
name|length
operator|=
name|msghdr
operator|.
name|msg_namelen
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|IOEVENT_LEVEL
argument_list|)
condition|)
block|{
name|socket_log
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
operator|->
name|address
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ZEROPORT
argument_list|,
literal|"dropping source port zero packet"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
block|}
block|}
name|socket_log
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
operator|->
name|address
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PKTRECV
argument_list|,
literal|"packet received correctly"
argument_list|)
expr_stmt|;
comment|/* 	 * Overflow bit detection.  If we received MORE bytes than we should, 	 * this indicates an overflow situation.  Set the flag in the 	 * dev entry and adjust how much we read by one. 	 */
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
if|if
condition|(
operator|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
operator|)
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|cc
operator|>
name|read_count
operator|)
condition|)
block|{
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_TRUNC
expr_stmt|;
name|cc
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If there are control messages attached, run through them and pull 	 * out the interesting bits. 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|process_cmsg
argument_list|(
name|sock
argument_list|,
operator|&
name|msghdr
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * update the buffers (if any) and the i/o count 	 */
name|dev
operator|->
name|n
operator|+=
name|cc
expr_stmt|;
name|actual_count
operator|=
name|cc
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
operator|&&
name|actual_count
operator|>
literal|0U
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
operator|<=
name|actual_count
condition|)
block|{
name|actual_count
operator|-=
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
name|actual_count
argument_list|)
expr_stmt|;
name|actual_count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|actual_count
operator|==
literal|0U
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we read less than we expected, update counters, 	 * and let the upper layer poke the descriptor. 	 */
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|cc
operator|!=
name|read_count
operator|)
operator|&&
operator|(
name|dev
operator|->
name|n
operator|<
name|dev
operator|->
name|minimum
operator|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
comment|/* 	 * Full reads are posted, or partials if partials are ok. 	 */
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|DOIO_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *	DOIO_SUCCESS	The operation succeeded.  dev->result contains  *			ISC_R_SUCCESS.  *  *	DOIO_HARD	A hard or unexpected I/O error was encountered.  *			dev->result contains the appropriate error.  *  *	DOIO_SOFT	A soft I/O error was encountered.  No senddone  *			event was sent.  The operation should be retried.  *  *	No other return values are possible.  */
end_comment

begin_function
specifier|static
name|int
name|doio_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|MAXSCATTERGATHER_SEND
index|]
decl_stmt|;
name|size_t
name|write_count
decl_stmt|;
name|struct
name|msghdr
name|msghdr
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|int
name|attempts
init|=
literal|0
decl_stmt|;
name|int
name|send_errno
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|build_msghdr_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
operator|&
name|msghdr
argument_list|,
name|iov
argument_list|,
operator|&
name|write_count
argument_list|)
expr_stmt|;
name|resend
label|:
name|cc
operator|=
name|sendmsg
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|msghdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_errno
operator|=
name|errno
expr_stmt|;
comment|/* 	 * Check for error or block condition. 	 */
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|send_errno
operator|==
name|EINTR
operator|&&
operator|++
name|attempts
operator|<
name|NRETRIES
condition|)
goto|goto
name|resend
goto|;
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|send_errno
argument_list|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
define|#
directive|define
name|SOFT_OR_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (send_errno == _system) { \ 		if (sock->connected) { \ 			dev->result = _isc; \ 			return (DOIO_HARD); \ 		} \ 		return (DOIO_SOFT); \ 	}
define|#
directive|define
name|ALWAYS_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (send_errno == _system) { \ 		dev->result = _isc; \ 		return (DOIO_HARD); \ 	}
name|SOFT_OR_HARD
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHOSTDOWN
name|ALWAYS_HARD
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ALWAYS_HARD
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EPERM
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EPIPE
argument_list|,
name|ISC_R_NOTCONNECTED
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|ECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SOFT_OR_HARD
undef|#
directive|undef
name|ALWAYS_HARD
comment|/* 		 * The other error types depend on whether or not the 		 * socket is UDP or TCP.  If it is UDP, some errors 		 * that we expect to be fatal under TCP are merely 		 * annoying, and are really soft errors. 		 * 		 * However, these soft errors are still returned as 		 * a status. 		 */
name|isc_sockaddr_format
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|send_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_send: %s: %s"
argument_list|,
name|addrbuf
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|isc__errno2result
argument_list|(
name|send_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|DOIO_HARD
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_send: send() %s 0"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_RETURNED
argument_list|,
literal|"returned"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we write less than we expected, update counters, poke. 	 */
name|dev
operator|->
name|n
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|cc
operator|!=
name|write_count
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
comment|/* 	 * Exactly what we wanted to write.  We're done with this 	 * entry.  Post its completion event. 	 */
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|DOIO_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kill.  *  * Caller must ensure that the socket is not locked and no external  * references exist.  */
end_comment

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
init|=
operator|*
name|sockp
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
init|=
name|sock
operator|->
name|manager
decl_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DESTROYING
argument_list|,
literal|"destroying"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|connect_ev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|sock
operator|->
name|fd
operator|<
operator|(
name|int
operator|)
name|FD_SETSIZE
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * No one has this socket open, so the watcher doesn't have to be 	 * poked, and the socket doesn't have to be locked. 	 */
name|manager
operator|->
name|fds
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|CLOSE_PENDING
expr_stmt|;
name|select_poke
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_CLOSE
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* 	 * XXX should reset manager->maxfd here 	 */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_socket
argument_list|(
name|sockp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|allocate_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|cmsgbuflen
decl_stmt|;
name|sock
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|ret
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|references
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
name|sock
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sock
operator|->
name|recvcmsgbuf
operator|=
name|NULL
expr_stmt|;
name|sock
operator|->
name|sendcmsgbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * set up cmsg buffers 	 */
name|cmsgbuflen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIN6PKTINFO
argument_list|)
name|cmsgbuflen
operator|=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_TIMESTAMP
argument_list|)
name|cmsgbuflen
operator|+=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sock
operator|->
name|recvcmsgbuflen
operator|=
name|cmsgbuflen
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuflen
operator|!=
literal|0U
condition|)
block|{
name|sock
operator|->
name|recvcmsgbuf
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|cmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuf
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
block|}
name|cmsgbuflen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIN6PKTINFO
argument_list|)
name|cmsgbuflen
operator|=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sock
operator|->
name|sendcmsgbuflen
operator|=
name|cmsgbuflen
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuflen
operator|!=
literal|0U
condition|)
block|{
name|sock
operator|->
name|sendcmsgbuf
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|cmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuf
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* 	 * set up list of readers and writers to be initially empty 	 */
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|listener
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|0
expr_stmt|;
comment|/* 	 * initialize the lock 	 */
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Initialize readable and writable events 	 */
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|sock
operator|->
name|readable_ev
argument_list|,
sizeof|sizeof
argument_list|(
name|intev_t
argument_list|)
argument_list|,
name|ISC_EVENTATTR_NOPURGE
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKEVENT_INTR
argument_list|,
name|NULL
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|sock
operator|->
name|writable_ev
argument_list|,
sizeof|sizeof
argument_list|(
name|intev_t
argument_list|)
argument_list|,
name|ISC_EVENTATTR_NOPURGE
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKEVENT_INTW
argument_list|,
name|NULL
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sock
operator|->
name|magic
operator|=
name|SOCKET_MAGIC
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|error
label|:
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvcmsgbuf
argument_list|,
name|sock
operator|->
name|recvcmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|sendcmsgbuf
argument_list|,
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This event requires that the various lists be empty, that the reference  * count be 1, and that the magic number is valid.  The other socket bits,  * like the lock, must be initialized as well.  The fd associated must be  * marked as closed, by setting it to -1 on close, or this routine will  * also close the socket.  */
end_comment

begin_function
specifier|static
name|void
name|free_socket
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
init|=
operator|*
name|socketp
decl_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_recv
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_send
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_accept
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvcmsgbuf
argument_list|,
name|sock
operator|->
name|recvcmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|sendcmsgbuf
argument_list|,
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new 'type' socket managed by 'manager'.  Events  * will be posted to 'task' and when dispatched 'action' will be  * called with 'arg' as the arg value.  The new socket is returned  * in 'socketp'.  */
end_comment

begin_function
name|isc_result_t
name|isc_socket_create
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|pf
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|||
name|defined
argument_list|(
name|SO_BSDCOMPAT
argument_list|)
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
literal|"socket"
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|type
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|sock
operator|->
name|pf
operator|=
name|pf
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|isc_sockettype_udp
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|pf
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
break|break;
case|case
name|isc_sockettype_tcp
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|pf
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|sock
operator|->
name|fd
operator|<
literal|20
condition|)
block|{
name|int
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|new
operator|=
name|fcntl
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|new
expr_stmt|;
name|err
operator|=
literal|"isc_socket_create: fcntl"
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sock
operator|->
name|fd
operator|>=
operator|(
name|int
operator|)
name|FD_SETSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYFDS
argument_list|,
literal|"%s: too many open file descriptors"
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NORESOURCES
operator|)
return|;
block|}
if|if
condition|(
name|sock
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EMFILE
case|:
case|case
name|ENFILE
case|:
case|case
name|ENOBUFS
case|:
return|return
operator|(
name|ISC_R_NORESOURCES
operator|)
return|;
case|case
name|EPROTONOSUPPORT
case|:
case|case
name|EPFNOSUPPORT
case|:
case|case
name|EAFNOSUPPORT
case|:
comment|/* 		 * Linux 2.2 (and maybe others) return EINVAL instead of 		 * EAFNOSUPPORT. 		 */
case|case
name|EINVAL
case|:
return|return
operator|(
name|ISC_R_FAMILYNOSUPPORT
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s() %s: %s"
argument_list|,
name|err
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
if|if
condition|(
name|make_nonblock
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SO_BSDCOMPAT
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BSDCOMPAT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, SO_BSDCOMPAT) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
if|if
condition|(
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SO_TIMESTAMP
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TIMESTAMP
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOPROTOOPT
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, SO_TIMESTAMP) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
endif|#
directive|endif
comment|/* SO_TIMESTAMP */
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIPV6
argument_list|)
if|if
condition|(
name|pf
operator|==
name|AF_INET6
operator|&&
name|sock
operator|->
name|recvcmsgbuflen
operator|==
literal|0U
condition|)
block|{
comment|/* 			 * Warn explicitly because this anomaly can be hidden 			 * in usual operation (and unexpectedly appear later). 			 */
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"No buffer available to receive "
literal|"IPv6 destination"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
ifdef|#
directive|ifdef
name|IPV6_RECVPKTINFO
comment|/* 2292bis */
if|if
condition|(
operator|(
name|pf
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_RECVPKTINFO) "
literal|"%s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 2292 */
if|if
condition|(
operator|(
name|pf
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_PKTINFO) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPV6_RECVPKTINFO */
endif|#
directive|endif
comment|/* ISC_PLATFORM_HAVEIN6PKTINFO */
ifdef|#
directive|ifdef
name|IPV6_USE_MIN_MTU
comment|/*2292bis, not too common yet*/
comment|/* use minimum MTU */
if|if
condition|(
name|pf
operator|==
name|AF_INET6
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_USE_MIN_MTU
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* ISC_PLATFORM_HAVEIPV6 */
block|}
endif|#
directive|endif
comment|/* USE_CMSG */
name|sock
operator|->
name|references
operator|=
literal|1
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Note we don't have to lock the socket like we normally would because 	 * there are no external references to it yet. 	 */
name|manager
operator|->
name|fds
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|sock
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|MANAGED
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|<
name|sock
operator|->
name|fd
condition|)
name|manager
operator|->
name|maxfd
operator|=
name|sock
operator|->
name|fd
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_CREATED
argument_list|,
literal|"created"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach to a socket.  Caller must explicitly detach when it is done.  */
end_comment

begin_function
name|void
name|isc_socket_attach
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dereference a socket.  If this is the last reference to it, clean things  * up by destroying the socket.  */
end_comment

begin_function
name|void
name|isc_socket_detach
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_boolean_t
name|kill_socket
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|*
name|socketp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
name|kill_socket
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill_socket
condition|)
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * I/O is possible on a given socket.  Schedule an event to this task that  * will call an internal function to do the I/O.  This will charge the  * task with the I/O operation and let our select loop handler get back  * to doing something real as fast as possible.  *  * The socket and manager must be locked before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_recv
argument_list|)
expr_stmt|;
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return;
name|sock
operator|->
name|pending_recv
operator|=
literal|1
expr_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|readable_ev
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"dispatch_recv:  event %p -> task %p"
argument_list|,
name|ev
argument_list|,
name|ev
operator|->
name|ev_sender
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|iev
operator|->
name|ev_action
operator|=
name|internal_recv
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|ev
operator|->
name|ev_sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_send
argument_list|)
expr_stmt|;
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return;
name|sock
operator|->
name|pending_send
operator|=
literal|1
expr_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|writable_ev
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"dispatch_send:  event %p -> task %p"
argument_list|,
name|ev
argument_list|,
name|ev
operator|->
name|ev_sender
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|iev
operator|->
name|ev_action
operator|=
name|internal_send
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|ev
operator|->
name|ev_sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch an internal accept event.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|ev
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_accept
argument_list|)
expr_stmt|;
comment|/* 	 * Are there any done events left, or were they all canceled 	 * before the manager got the socket lock? 	 */
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return;
name|sock
operator|->
name|pending_accept
operator|=
literal|1
expr_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|readable_ev
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
comment|/* keep socket around for this internal event */
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|iev
operator|->
name|ev_action
operator|=
name|internal_accept
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|ev
operator|->
name|ev_sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_connect
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socket_connev_t
modifier|*
name|ev
decl_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|writable_ev
expr_stmt|;
name|ev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
name|INSIST
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX */
name|INSIST
argument_list|(
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
comment|/* keep socket around for this internal event */
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|iev
operator|->
name|ev_action
operator|=
name|internal_connect
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|ev
operator|->
name|ev_sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dequeue an item off the given socket's read queue, set the result code  * in the done event to the one provided, and send it to the task it was  * destined for.  *  * If the event to be sent is on a list, remove it before sending.  If  * asked to, send and detach from the socket as well.  *  * Caller must have the socket locked if the event is attached to the socket.  */
end_comment

begin_function
specifier|static
name|void
name|send_recvdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|task
operator|=
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|,
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|dev
operator|)
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_ATTACHED
operator|)
operator|==
name|ISC_SOCKEVENTATTR_ATTACHED
condition|)
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
else|else
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See comments for send_recvdone_event() above.  *  * Caller must have the socket locked if the event is attached to the socket.  */
end_comment

begin_function
specifier|static
name|void
name|send_senddone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|INSIST
argument_list|(
name|dev
operator|!=
name|NULL
operator|&&
operator|*
name|dev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|send_list
argument_list|,
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|dev
operator|)
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_ATTACHED
operator|)
operator|==
name|ISC_SOCKEVENTATTR_ATTACHED
condition|)
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
else|else
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call accept() on a socket, to get the new file descriptor.  The listen  * socket is used as a prototype to create a new isc_socket_t.  The new  * socket has one outstanding reference.  The task receiving the event  * will be detached from just after the event is delivered.  *  * On entry to this function, the event delivered is the internal  * readable event, and the first item on the accept_list should be  * the done event we want to send.  If the list is empty, this is a no-op,  * so just unlock and return.  */
end_comment

begin_function
specifier|static
name|void
name|internal_accept
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|addrlen
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
literal|"accept"
decl_stmt|;
name|UNUSED
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"internal_accept called, locked socket"
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_accept
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the first item off the accept list. 	 * If it is empty, unlock the socket and return. 	 */
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Try to accept the new connection.  If the accept fails with 	 * EAGAIN or EINTR, simply poke the watcher to watch this socket 	 * again.  Also ignore ECONNRESET, which has been reported to 	 * be spuriously returned on Linux 2.2.19 although it is not 	 * a documented error for accept().  ECONNABORTED has been 	 * reported for Solaris 8.  The rest are thrown in not because 	 * we have seen them but because they are ignored by other 	 * deamons such as BIND 8 and Apache. 	 */
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|newsocket
operator|->
name|address
operator|.
name|type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dev
operator|->
name|newsocket
operator|->
name|address
operator|.
name|type
operator|.
name|sa
argument_list|,
literal|0
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|fd
operator|=
name|accept
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|dev
operator|->
name|newsocket
operator|->
name|address
operator|.
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|addrlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
literal|20
condition|)
block|{
name|int
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|new
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|fd
operator|=
name|new
expr_stmt|;
name|err
operator|=
literal|"fcntl"
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
goto|goto
name|soft_error
goto|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOBUFS
case|:
case|case
name|ENFILE
case|:
case|case
name|ENOMEM
case|:
case|case
name|ECONNRESET
case|:
case|case
name|ECONNABORTED
case|:
case|case
name|EHOSTUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|ECONNREFUSED
case|:
ifdef|#
directive|ifdef
name|EPROTO
case|case
name|EPROTO
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENONET
case|case
name|ENONET
case|:
endif|#
directive|endif
goto|goto
name|soft_error
goto|;
default|default:
break|break;
block|}
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_accept: %s() %s: %s"
argument_list|,
name|err
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addrlen
operator|==
literal|0U
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_accept(): "
literal|"accept() failed to return "
literal|"remote address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|newsocket
operator|->
name|address
operator|.
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|sock
operator|->
name|pf
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_accept(): "
literal|"accept() returned peer address "
literal|"family %u (expected %u)"
argument_list|,
name|dev
operator|->
name|newsocket
operator|->
name|address
operator|.
name|type
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|sock
operator|->
name|pf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
block|}
elseif|else
if|if
condition|(
name|fd
operator|>=
operator|(
name|int
operator|)
name|FD_SETSIZE
condition|)
block|{
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYFDS
argument_list|,
literal|"%s: too many open file descriptors"
argument_list|,
literal|"accept"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
block|}
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|dev
operator|->
name|newsocket
operator|->
name|address
operator|.
name|length
operator|=
name|addrlen
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|->
name|pf
operator|=
name|sock
operator|->
name|pf
expr_stmt|;
block|}
comment|/* 	 * Pull off the done event. 	 */
name|ISC_LIST_UNLINK
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
comment|/* 	 * Poke watcher if there are more pending accepts. 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_ACCEPT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|make_nonblock
argument_list|(
name|fd
argument_list|)
operator|!=
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
comment|/* 	 * -1 means the new socket didn't happen. 	 */
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|dev
operator|->
name|newsocket
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Save away the remote address 		 */
name|dev
operator|->
name|address
operator|=
name|dev
operator|->
name|newsocket
operator|->
name|address
expr_stmt|;
name|manager
operator|->
name|fds
index|[
name|fd
index|]
operator|=
name|dev
operator|->
name|newsocket
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|=
name|MANAGED
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|<
name|fd
condition|)
name|manager
operator|->
name|maxfd
operator|=
name|fd
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
operator|->
name|newsocket
operator|->
name|address
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTEDCXN
argument_list|,
literal|"accepted connection, new socket %p"
argument_list|,
name|dev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|newsocket
operator|->
name|references
operator|--
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|dev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the done event details and send it off. 	 */
name|dev
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|soft_error
label|:
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_ACCEPT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_recv
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTR
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALRECV
argument_list|,
literal|"internal_recv: task %p got event %p"
argument_list|,
name|me
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_recv
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Try to do as much I/O as possible on this socket.  There are no 	 * limits here, currently. 	 */
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|doio_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
goto|goto
name|poke
goto|;
case|case
name|DOIO_EOF
case|:
comment|/* 			 * read of 0 means the remote end was closed. 			 * Run through the event queue and dispatch all 			 * the events with an EOF result code. 			 */
do|do
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_EOF
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
do|;
goto|goto
name|poke
goto|;
case|case
name|DOIO_SUCCESS
case|:
case|case
name|DOIO_HARD
case|:
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
block|}
name|poke
label|:
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_send
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTW
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what socket this is and lock it. 	 */
name|sock
operator|=
operator|(
name|isc_socket_t
operator|*
operator|)
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALSEND
argument_list|,
literal|"internal_send: task %p got event %p"
argument_list|,
name|me
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_send
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Try to do as much I/O as possible on this socket.  There are no 	 * limits here, currently. 	 */
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|doio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
goto|goto
name|poke
goto|;
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
block|}
name|poke
label|:
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_fds
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|maxfd
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_boolean_t
name|unlock_sock
decl_stmt|;
name|REQUIRE
argument_list|(
name|maxfd
operator|<=
operator|(
name|int
operator|)
name|FD_SETSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Process read/writes on other fds here.  Avoid locking 	 * and unlocking twice if both reads and writes are possible. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxfd
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|i
operator|==
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
operator|||
name|i
operator|==
name|manager
operator|->
name|pipe_fds
index|[
literal|1
index|]
condition|)
continue|continue;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|i
index|]
operator|==
name|CLOSE_PENDING
condition|)
block|{
name|manager
operator|->
name|fdstate
index|[
name|i
index|]
operator|=
name|CLOSED
expr_stmt|;
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sock
operator|=
name|manager
operator|->
name|fds
index|[
name|i
index|]
expr_stmt|;
name|unlock_sock
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
block|{
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
goto|goto
name|check_write
goto|;
block|}
name|unlock_sock
operator|=
name|ISC_TRUE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOCK_DEAD
argument_list|(
name|sock
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|listener
condition|)
name|dispatch_accept
argument_list|(
name|sock
argument_list|)
expr_stmt|;
else|else
name|dispatch_recv
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
block|}
name|check_write
label|:
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
name|writefds
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
block|{
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|unlock_sock
condition|)
block|{
name|unlock_sock
operator|=
name|ISC_TRUE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SOCK_DEAD
argument_list|(
name|sock
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|connecting
condition|)
name|dispatch_connect
argument_list|(
name|sock
argument_list|)
expr_stmt|;
else|else
name|dispatch_send
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlock_sock
condition|)
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_comment
comment|/*  * This is the thread that will loop forever, always in a select or poll  * call.  *  * When select returns something to do, track down what thread gets to do  * this I/O and post the event to it.  */
end_comment

begin_function
specifier|static
name|isc_threadresult_t
name|watcher
parameter_list|(
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
init|=
name|uap
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|int
name|ctlfd
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|fd_set
name|writefds
decl_stmt|;
name|int
name|msg
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
comment|/* 	 * Get the control fd here.  This will never change. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctlfd
operator|=
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
do|do
block|{
name|readfds
operator|=
name|manager
operator|->
name|read_fds
expr_stmt|;
name|writefds
operator|=
name|manager
operator|->
name|write_fds
expr_stmt|;
name|maxfd
operator|=
name|manager
operator|->
name|maxfd
operator|+
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cc
operator|=
name|select
argument_list|(
name|maxfd
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"select() %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|<
literal|0
condition|)
do|;
comment|/* 		 * Process reads on internal, control fd. 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|ctlfd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|select_readmsg
argument_list|(
name|manager
argument_list|,
operator|&
name|fd
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|manager_log
argument_list|(
name|manager
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_WATCHERMSG
argument_list|,
literal|"watcher got message %d"
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 				 * Nothing to read? 				 */
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_NOTHING
condition|)
break|break;
comment|/* 				 * Handle shutdown message.  We really should 				 * jump out of this loop right away, but 				 * it doesn't matter if we have to do a little 				 * more work first. 				 */
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_SHUTDOWN
condition|)
block|{
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
comment|/* 				 * This is a wakeup on a socket.  Look 				 * at the event queue for both read and write, 				 * and decide if we need to watch on it now 				 * or not. 				 */
name|wakeup_socket
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
name|process_fds
argument_list|(
name|manager
argument_list|,
name|maxfd
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
block|}
name|manager_log
argument_list|(
name|manager
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_EXITING
argument_list|,
literal|"watcher exiting"
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_threadresult_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_comment
comment|/*  * Create a new socket manager.  */
end_comment

begin_function
name|isc_result_t
name|isc_socketmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
operator|&&
operator|*
name|managerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|socketmgr
operator|!=
name|NULL
condition|)
block|{
name|socketmgr
operator|->
name|refs
operator|++
expr_stmt|;
operator|*
name|managerp
operator|=
name|socketmgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|manager
operator|->
name|magic
operator|=
name|SOCKET_MANAGER_MAGIC
expr_stmt|;
name|manager
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|manager
operator|->
name|fds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|manager
operator|->
name|fds
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|isc_condition_init
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_condition_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
comment|/* 	 * Create the special fds that will be used to wake up the 	 * select/poll loop when something internal needs to be done. 	 */
if|if
condition|(
name|pipe
argument_list|(
name|manager
operator|->
name|pipe_fds
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"pipe() %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|RUNTIME_CHECK
argument_list|(
name|make_nonblock
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|RUNTIME_CHECK(make_nonblock(manager->pipe_fds[1]) == ISC_R_SUCCESS);
endif|#
directive|endif
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* 	 * Set up initial state for the select loop 	 */
name|FD_ZERO
argument_list|(
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|FD_SET
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
operator|&
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
name|manager
operator|->
name|maxfd
operator|=
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|->
name|maxfd
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|memset
argument_list|(
name|manager
operator|->
name|fdstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|manager
operator|->
name|fdstate
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * Start up the select/poll thread. 	 */
if|if
condition|(
name|isc_thread_create
argument_list|(
name|watcher
argument_list|,
name|manager
argument_list|,
operator|&
name|manager
operator|->
name|watcher
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_create() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|socketmgr
operator|=
name|manager
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
operator|*
name|managerp
operator|=
name|manager
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_socketmgr_destroy
parameter_list|(
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|int
name|i
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 	 * Destroy a socket manager. 	 */
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
operator|*
name|managerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|manager
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|manager
operator|->
name|refs
operator|--
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * Wait for all sockets to be destroyed. 	 */
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
block|{
name|manager_log
argument_list|(
name|manager
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_SOCKETSREMAIN
argument_list|,
literal|"sockets exist"
argument_list|)
argument_list|)
expr_stmt|;
name|WAIT
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* 	 * Hope all sockets have been destroyed. 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
block|{
name|manager_log
argument_list|(
name|manager
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_SOCKETSREMAIN
argument_list|,
literal|"sockets exist"
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Here, poke our select/poll thread.  Do this by closing the write 	 * half of the pipe, which will send EOF to the read half. 	 * This is currently a no-op in the non-threaded case. 	 */
name|select_poke
argument_list|(
name|manager
argument_list|,
literal|0
argument_list|,
name|SELECT_POKE_SHUTDOWN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * Wait for thread to exit. 	 */
if|if
condition|(
name|isc_thread_join
argument_list|(
name|manager
operator|->
name|watcher
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_join() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* 	 * Clean up. 	 */
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|FD_SETSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|i
index|]
operator|==
name|CLOSE_PENDING
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|manager
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|socket_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|io_state
decl_stmt|;
name|isc_boolean_t
name|have_lock
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|task
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|io_state
operator|=
name|doio_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
name|io_state
operator|=
name|doio_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
name|io_state
operator|=
name|DOIO_SOFT
expr_stmt|;
block|}
switch|switch
condition|(
name|io_state
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
comment|/* 		 * We couldn't read all or part of the request right now, so 		 * queue it. 		 * 		 * Attach to socket and to task 		 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_ATTACHED
expr_stmt|;
if|if
condition|(
operator|!
name|have_lock
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 		 * Enqueue the request.  If the socket was previously not being 		 * watched, poke the watcher to start paying attention to it. 		 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"socket_recv: event %p -> task %p"
argument_list|,
name|dev
argument_list|,
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_INPROGRESS
expr_stmt|;
break|break;
case|case
name|DOIO_EOF
case|:
name|dev
operator|->
name|result
operator|=
name|ISC_R_EOF
expr_stmt|;
comment|/* fallthrough */
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|have_lock
condition|)
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_recvv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|unsigned
name|int
name|iocount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|iocount
operator|=
name|isc_bufferlist_availablecount
argument_list|(
name|buflist
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iocount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
comment|/* 	 * UDP sockets are always partial read 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|dev
operator|->
name|minimum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|dev
operator|->
name|minimum
operator|=
name|iocount
expr_stmt|;
else|else
name|dev
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
block|}
comment|/* 	 * Move each buffer from the passed in list to our internal one. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
operator|*
name|buflist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|socket_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
return|return
operator|(
name|isc_socket_recv2
argument_list|(
name|sock
argument_list|,
name|region
argument_list|,
name|minimum
argument_list|,
name|task
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_recv2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|event
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|event
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|event
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|event
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* 	 * UDP sockets are always partial read. 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|event
operator|->
name|minimum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|event
operator|->
name|minimum
operator|=
name|region
operator|->
name|length
expr_stmt|;
else|else
name|event
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
block|}
return|return
operator|(
name|socket_recv
argument_list|(
name|sock
argument_list|,
name|event
argument_list|,
name|task
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|socket_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|io_state
decl_stmt|;
name|isc_boolean_t
name|have_lock
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|task
expr_stmt|;
name|set_dev_address
argument_list|(
name|address
argument_list|,
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktinfo
operator|!=
name|NULL
condition|)
block|{
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_PKTINFO
expr_stmt|;
name|dev
operator|->
name|pktinfo
operator|=
operator|*
name|pktinfo
expr_stmt|;
if|if
condition|(
operator|!
name|isc_sockaddr_issitelocal
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
operator|&&
operator|!
name|isc_sockaddr_islinklocal
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
condition|)
block|{
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PKTINFOPROVIDED
argument_list|,
literal|"pktinfo structure provided, ifindex %u "
literal|"(set to 0)"
argument_list|,
name|pktinfo
operator|->
name|ipi6_ifindex
argument_list|)
expr_stmt|;
comment|/* 			 * Set the pktinfo index to 0 here, to let the 			 * kernel decide what interface it should send on. 			 */
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|io_state
operator|=
name|doio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
name|io_state
operator|=
name|doio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
name|io_state
operator|=
name|DOIO_SOFT
expr_stmt|;
block|}
switch|switch
condition|(
name|io_state
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
comment|/* 		 * We couldn't send all or part of the request right now, so 		 * queue it unless ISC_SOCKFLAG_NORETRY is set. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|==
literal|0
condition|)
block|{
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_ATTACHED
expr_stmt|;
if|if
condition|(
operator|!
name|have_lock
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 			 * Enqueue the request.  If the socket was previously 			 * not being watched, poke the watcher to start 			 * paying attention to it. 			 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|send_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"socket_send: event %p -> task %p"
argument_list|,
name|dev
argument_list|,
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_INPROGRESS
expr_stmt|;
break|break;
block|}
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|have_lock
condition|)
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * REQUIRE() checking is performed in isc_socket_sendto(). 	 */
return|return
operator|(
name|isc_socket_sendto
argument_list|(
name|sock
argument_list|,
name|region
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_sendto
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|region
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|dev
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
return|return
operator|(
name|socket_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_sendv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|isc_socket_sendtov
argument_list|(
name|sock
argument_list|,
name|buflist
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_sendtov
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|unsigned
name|int
name|iocount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|iocount
operator|=
name|isc_bufferlist_usedcount
argument_list|(
name|buflist
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iocount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
comment|/* 	 * Move each buffer from the passed in list to our internal one. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
operator|*
name|buflist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|socket_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_sendto2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|REQUIRE
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|ISC_SOCKFLAG_IMMEDIATE
operator||
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|!=
literal|0
condition|)
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|event
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|event
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|event
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|socket_send
argument_list|(
name|sock
argument_list|,
name|event
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_bind
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pf
operator|!=
name|sockaddr
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAMILYMISMATCH
operator|)
return|;
block|}
comment|/* 	 * Only set SO_REUSEADDR when we want a specific port. 	 */
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
name|sockaddr
argument_list|)
operator|!=
operator|(
name|in_port_t
operator|)
literal|0
operator|&&
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d) %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|sockaddr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|sockaddr
operator|->
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
case|case
name|EADDRNOTAVAIL
case|:
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
case|case
name|EADDRINUSE
case|:
return|return
operator|(
name|ISC_R_ADDRINUSE
operator|)
return|;
case|case
name|EINVAL
case|:
return|return
operator|(
name|ISC_R_BOUND
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bind: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
name|socket_log
argument_list|(
name|sock
argument_list|,
name|sockaddr
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_BOUND
argument_list|,
literal|"bound"
argument_list|)
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_filter
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
specifier|const
name|char
modifier|*
name|filter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_ACCEPTFILTER
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|struct
name|accept_filter_arg
name|afa
decl_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|filter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_ACCEPTFILTER
name|bzero
argument_list|(
operator|&
name|afa
argument_list|,
sizeof|sizeof
argument_list|(
name|afa
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|afa
operator|.
name|af_name
argument_list|,
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|afa
operator|.
name|af_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ACCEPTFILTER
argument_list|,
operator|&
name|afa
argument_list|,
sizeof|sizeof
argument_list|(
name|afa
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FILTER
argument_list|,
literal|"setsockopt(SO_ACCEPTFILTER): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Set up to listen on a given socket.  We do this by creating an internal  * event that will be dispatched when the socket has read activity.  The  * watcher will send the internal event to the task when there is a new  * connection.  *  * Unlike in read, we don't preallocate a done event here.  Every time there  * is a new connection we'll have to allocate a new one anyway, so we might  * as well keep things simple rather than having to track them.  */
end_comment

begin_function
name|isc_result_t
name|isc_socket_listen
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|unsigned
name|int
name|backlog
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlog
operator|==
literal|0
condition|)
name|backlog
operator|=
name|SOMAXCONN
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|(
name|int
operator|)
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"listen: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|sock
operator|->
name|listener
operator|=
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This should try to do agressive accept() XXXMLG  */
end_comment

begin_function
name|isc_result_t
name|isc_socket_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_socket_t
modifier|*
name|nsock
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|isc_boolean_t
name|do_poke
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
comment|/* 	 * Sender field is overloaded here with the task we will be sending 	 * this event to.  Just before the actual event is delivered the 	 * actual ev_sender will be touched up to be the socket. 	 */
name|dev
operator|=
operator|(
name|isc_socket_newconnev_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
name|ISC_SOCKEVENT_NEWCONN
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ret
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|type
argument_list|,
operator|&
name|nsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Attach to socket and to task. 	 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|nsock
operator|->
name|references
operator|++
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|ntask
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|=
name|nsock
expr_stmt|;
comment|/* 	 * Poke watcher here.  We still have the socket locked, so there 	 * is no race condition.  We will keep the lock for such a short 	 * bit of time waking it up now or later won't matter all that much. 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
name|do_poke
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_poke
condition|)
name|select_poke
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_ACCEPT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_connect
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_ismulticast
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_MULTICAST
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|dev
operator|=
operator|(
name|isc_socket_connev_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
name|ISC_SOCKEVENT_CONNECT
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
comment|/* 	 * Try to do the connect right away, as there can be only one 	 * outstanding, and it might happen to complete. 	 */
name|sock
operator|->
name|address
operator|=
operator|*
name|addr
expr_stmt|;
name|cc
operator|=
name|connect
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|addr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
operator|||
name|errno
operator|==
name|EINPROGRESS
condition|)
goto|goto
name|queue
goto|;
switch|switch
condition|(
name|errno
condition|)
block|{
define|#
directive|define
name|ERROR_MATCH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|case a: dev->result = b; goto err_exit;
name|ERROR_MATCH
argument_list|(
name|EACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHOSTDOWN
name|ERROR_MATCH
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ERROR_MATCH
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPERM
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPIPE
argument_list|,
name|ISC_R_NOTCONNECTED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERROR_MATCH
block|}
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%d/%s"
argument_list|,
name|errno
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
name|err_exit
label|:
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * If connect completed, fire off the done event. 	 */
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|sock
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|queue
label|:
comment|/* 	 * Attach to task. 	 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|ntask
expr_stmt|;
comment|/* 	 * Poke watcher here.  We still have the socket locked, so there 	 * is no race condition.  We will keep the lock for such a short 	 * bit of time waking it up now or later won't matter all that much. 	 */
if|if
condition|(
name|sock
operator|->
name|connect_ev
operator|==
name|NULL
condition|)
name|select_poke
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_CONNECT
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|dev
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a socket with a pending connect() finishes.  */
end_comment

begin_function
specifier|static
name|void
name|internal_connect
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|optlen
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTW
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * When the internal event was sent the reference count was bumped 	 * to keep the socket around for us.  Decrement the count here. 	 */
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Has this event been canceled? 	 */
name|dev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get any possible error status here. 	 */
name|optlen
operator|=
sizeof|sizeof
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|optlen
argument_list|)
operator|<
literal|0
condition|)
name|cc
operator|=
name|errno
expr_stmt|;
else|else
name|errno
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the error is EAGAIN, just re-select on this 		 * fd and pretend nothing strange happened. 		 */
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
operator|||
name|errno
operator|==
name|EINPROGRESS
condition|)
block|{
name|sock
operator|->
name|connecting
operator|=
literal|1
expr_stmt|;
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_CONNECT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Translate other errors into ISC_R_* flavors. 		 */
switch|switch
condition|(
name|errno
condition|)
block|{
define|#
directive|define
name|ERROR_MATCH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|case a: dev->result = b; break;
name|ERROR_MATCH
argument_list|(
name|EACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHOSTDOWN
name|ERROR_MATCH
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ERROR_MATCH
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPERM
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPIPE
argument_list|,
name|ISC_R_NOTCONNECTED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ETIMEDOUT
argument_list|,
name|ISC_R_TIMEDOUT
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERROR_MATCH
default|default:
name|dev
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|sock
operator|->
name|address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_connect: connect(%s) %s"
argument_list|,
name|peerbuf
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
block|}
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_getpeername
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
block|{
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addressp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
block|{
operator|*
name|addressp
operator|=
name|sock
operator|->
name|address
expr_stmt|;
name|ret
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ISC_R_NOTCONNECTED
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_getsockname
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
block|{
name|ISC_SOCKADDR_LEN_T
name|len
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addressp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sock
operator|->
name|bound
condition|)
block|{
name|ret
operator|=
name|ISC_R_NOTBOUND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|addressp
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addressp
operator|->
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"getsockname: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|addressp
operator|->
name|length
operator|=
operator|(
name|unsigned
name|int
operator|)
name|len
expr_stmt|;
name|out
label|:
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run through the list of events on this socket, and cancel the ones  * queued for task "task" of type "how".  "how" is a bitmask.  */
end_comment

begin_function
name|void
name|isc_socket_cancel
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|how
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Quick exit if there is nothing to do.  Don't even bother locking 	 * in this case. 	 */
if|if
condition|(
name|how
operator|==
literal|0
condition|)
return|return;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * All of these do the same thing, more or less. 	 * Each will: 	 *	o If the internal event is marked as "posted" try to 	 *	  remove it from the task's queue.  If this fails, mark it 	 *	  as canceled instead, and let the task clean it up later. 	 *	o For each I/O request for that task of that type, post 	 *	  its done event with status of "ISC_R_CANCELED". 	 *	o Reset any state needed. 	 */
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_RECV
operator|)
operator|==
name|ISC_SOCKCANCEL_RECV
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_SEND
operator|)
operator|==
name|ISC_SOCKCANCEL_SEND
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_ACCEPT
operator|)
operator|==
name|ISC_SOCKCANCEL_ACCEPT
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|->
name|references
operator|--
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|dev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|current_task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* 	 * Connecting is not a list. 	 */
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_CONNECT
operator|)
operator|==
name|ISC_SOCKCANCEL_CONNECT
operator|)
operator|&&
name|sock
operator|->
name|connect_ev
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|current_task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_sockettype_t
name|isc_socket_gettype
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sock
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|isc_socket_isbound
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|isc_boolean_t
name|val
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|sock
operator|->
name|bound
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_socket_ipv6only
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_boolean_t
name|yes
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
name|int
name|onoff
init|=
name|yes
condition|?
literal|1
else|:
literal|0
decl_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|yes
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
argument_list|(
name|onoff
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_function
name|void
name|isc__socketmgr_getfdsets
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|,
name|int
modifier|*
name|maxfd
parameter_list|)
block|{
if|if
condition|(
name|socketmgr
operator|==
name|NULL
condition|)
operator|*
name|maxfd
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|readset
operator|=
name|socketmgr
operator|->
name|read_fds
expr_stmt|;
operator|*
name|writeset
operator|=
name|socketmgr
operator|->
name|write_fds
expr_stmt|;
operator|*
name|maxfd
operator|=
name|socketmgr
operator|->
name|maxfd
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_result_t
name|isc__socketmgr_dispatch
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|,
name|int
name|maxfd
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
init|=
name|socketmgr
decl_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
name|process_fds
argument_list|(
name|manager
argument_list|,
name|maxfd
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

end_unit

