begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: ifiter_ioctl.c,v 1.19.2.5.2.17 2005/10/14 02:13:07 marka Exp $ */
end_comment

begin_comment
comment|/*  * Obtain the list of network interfaces using the SIOCGLIFCONF ioctl.  * See netintro(4).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIF_LADDRCONF
end_ifdef

begin_define
define|#
directive|define
name|lifc_len
value|iflc_len
end_define

begin_define
define|#
directive|define
name|lifc_buf
value|iflc_buf
end_define

begin_define
define|#
directive|define
name|lifc_req
value|iflc_req
end_define

begin_define
define|#
directive|define
name|LIFCONF
value|if_laddrconf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISC_HAVE_LIFC_FAMILY
value|1
end_define

begin_define
define|#
directive|define
name|ISC_HAVE_LIFC_FLAGS
value|1
end_define

begin_define
define|#
directive|define
name|LIFCONF
value|lifconf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIF_LADDRREQ
end_ifdef

begin_define
define|#
directive|define
name|lifr_addr
value|iflr_addr
end_define

begin_define
define|#
directive|define
name|lifr_name
value|iflr_name
end_define

begin_define
define|#
directive|define
name|lifr_dstaddr
value|iflr_dstaddr
end_define

begin_define
define|#
directive|define
name|lifr_flags
value|iflr_flags
end_define

begin_define
define|#
directive|define
name|ss_family
value|sa_family
end_define

begin_define
define|#
directive|define
name|LIFREQ
value|if_laddrreq
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIFREQ
value|lifreq
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IFITER_MAGIC
value|ISC_MAGIC('I', 'F', 'I', 'T')
end_define

begin_define
define|#
directive|define
name|VALID_IFITER
parameter_list|(
name|t
parameter_list|)
value|ISC_MAGIC_VALID(t, IFITER_MAGIC)
end_define

begin_define
define|#
directive|define
name|ISC_IF_INET6_SZ
define|\
value|sizeof("00000000000000000000000000000001 01 80 10 80 XXXXXXloXXXXXXXX\n")
end_define

begin_struct
struct|struct
name|isc_interfaceiter
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
comment|/* Magic number. */
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|socket
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for sysctl data. */
name|unsigned
name|int
name|bufsize
decl_stmt|;
comment|/* Bytes allocated. */
name|unsigned
name|int
name|pos
decl_stmt|;
comment|/* Current offset in 						   SIOCGIFCONF data */
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
name|int
name|socket6
decl_stmt|;
name|struct
name|LIFCONF
name|lifc
decl_stmt|;
name|void
modifier|*
name|buf6
decl_stmt|;
comment|/* Buffer for sysctl data. */
name|unsigned
name|int
name|bufsize6
decl_stmt|;
comment|/* Bytes allocated. */
name|unsigned
name|int
name|pos6
decl_stmt|;
comment|/* Current offset in 						   SIOCGLIFCONF data */
name|isc_result_t
name|result6
decl_stmt|;
comment|/* Last result code. */
name|isc_boolean_t
name|first6
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
name|int
name|clua_context
decl_stmt|;
comment|/* Cluster alias context */
name|isc_boolean_t
name|clua_done
decl_stmt|;
name|struct
name|sockaddr
name|clua_sa
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux
name|FILE
modifier|*
name|proc
decl_stmt|;
name|char
name|entry
index|[
name|ISC_IF_INET6_SZ
index|]
decl_stmt|;
name|isc_result_t
name|valid
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
endif|#
directive|endif
name|isc_interface_t
name|current
decl_stmt|;
comment|/* Current interface data. */
name|isc_result_t
name|result
decl_stmt|;
comment|/* Last result code. */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
end_ifdef

begin_include
include|#
directive|include
file|<clua/clua.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Size of buffer for SIOCGLIFCONF, in bytes.  We assume no sane system  * will have more than a megabyte of interface configuration data.  */
end_comment

begin_define
define|#
directive|define
name|IFCONF_BUFSIZE_INITIAL
value|4096
end_define

begin_define
define|#
directive|define
name|IFCONF_BUFSIZE_MAX
value|1048576
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__linux
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IF_NAMESIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|IFNAMSIZ
end_ifdef

begin_define
define|#
directive|define
name|IF_NAMESIZE
value|IFNAMSIZ
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IF_NAMESIZE
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|getbuf4
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|iter
operator|->
name|bufsize
operator|=
name|IFCONF_BUFSIZE_INITIAL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|iter
operator|->
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
operator|&
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
argument_list|)
argument_list|)
expr_stmt|;
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
operator|=
name|iter
operator|->
name|bufsize
expr_stmt|;
name|iter
operator|->
name|ifc
operator|.
name|ifc_buf
operator|=
name|iter
operator|->
name|buf
expr_stmt|;
comment|/* 		 * Ignore the HP/UX warning about "interger overflow during 		 * conversion".  It comes from its own macro definition, 		 * and is really hard to shut up. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|iter
operator|->
name|socket
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|iter
operator|->
name|ifc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETIFCONFIG
argument_list|,
literal|"get interface "
literal|"configuration: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
goto|goto
name|unexpected
goto|;
block|}
comment|/* 			 * EINVAL.  Retry with a bigger buffer. 			 */
block|}
else|else
block|{
comment|/* 			 * The ioctl succeeded. 			 * Some OS's just return what will fit rather 			 * than set EINVAL if the buffer is too small 			 * to fit all the interfaces in.  If 			 * ifc.lifc_len is too near to the end of the 			 * buffer we will grow it just in case and 			 * retry. 			 */
if|if
condition|(
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
operator|<
name|iter
operator|->
name|bufsize
condition|)
break|break;
block|}
if|if
condition|(
name|iter
operator|->
name|bufsize
operator|>=
name|IFCONF_BUFSIZE_MAX
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_BUFFERMAX
argument_list|,
literal|"get interface "
literal|"configuration: "
literal|"maximum buffer "
literal|"size exceeded"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|unexpected
goto|;
block|}
name|isc_mem_put
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|buf
argument_list|,
name|iter
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|iter
operator|->
name|bufsize
operator|*=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|unexpected
label|:
name|isc_mem_put
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|buf
argument_list|,
name|iter
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|iter
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
end_if

begin_function
specifier|static
name|isc_result_t
name|getbuf6
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|iter
operator|->
name|bufsize6
operator|=
name|IFCONF_BUFSIZE_INITIAL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|iter
operator|->
name|buf6
operator|=
name|isc_mem_get
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|bufsize6
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|buf6
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
operator|&
name|iter
operator|->
name|lifc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|lifc
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_HAVE_LIFC_FAMILY
name|iter
operator|->
name|lifc
operator|.
name|lifc_family
operator|=
name|AF_INET6
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_HAVE_LIFC_FLAGS
name|iter
operator|->
name|lifc
operator|.
name|lifc_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|iter
operator|->
name|lifc
operator|.
name|lifc_len
operator|=
name|iter
operator|->
name|bufsize6
expr_stmt|;
name|iter
operator|->
name|lifc
operator|.
name|lifc_buf
operator|=
name|iter
operator|->
name|buf6
expr_stmt|;
comment|/* 		 * Ignore the HP/UX warning about "interger overflow during 		 * conversion".  It comes from its own macro definition, 		 * and is really hard to shut up. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|iter
operator|->
name|socket6
argument_list|,
name|SIOCGLIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|iter
operator|->
name|lifc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|__hpux
comment|/* 			 * IPv6 interface scanning is not available on all 			 * kernels w/ IPv6 sockets. 			 */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_INTERFACE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETIFCONFIG
argument_list|,
literal|"get interface "
literal|"configuration: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETIFCONFIG
argument_list|,
literal|"get interface "
literal|"configuration: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 			 * EINVAL.  Retry with a bigger buffer. 			 */
block|}
else|else
block|{
comment|/* 			 * The ioctl succeeded. 			 * Some OS's just return what will fit rather 			 * than set EINVAL if the buffer is too small 			 * to fit all the interfaces in.  If 			 * ifc.ifc_len is too near to the end of the 			 * buffer we will grow it just in case and 			 * retry. 			 */
if|if
condition|(
name|iter
operator|->
name|lifc
operator|.
name|lifc_len
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|LIFREQ
argument_list|)
operator|<
name|iter
operator|->
name|bufsize6
condition|)
break|break;
block|}
if|if
condition|(
name|iter
operator|->
name|bufsize6
operator|>=
name|IFCONF_BUFSIZE_MAX
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_BUFFERMAX
argument_list|,
literal|"get interface "
literal|"configuration: "
literal|"maximum buffer "
literal|"size exceeded"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_mem_put
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|buf6
argument_list|,
name|iter
operator|->
name|bufsize6
argument_list|)
expr_stmt|;
name|iter
operator|->
name|bufsize6
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|iter
operator|->
name|lifc
operator|.
name|lifc_len
operator|!=
literal|0
condition|)
name|iter
operator|->
name|mode
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_mem_put
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|buf6
argument_list|,
name|iter
operator|->
name|bufsize6
argument_list|)
expr_stmt|;
name|iter
operator|->
name|buf6
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|isc_interfaceiter_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_interfaceiter_t
modifier|*
modifier|*
name|iterp
parameter_list|)
block|{
name|isc_interfaceiter_t
modifier|*
name|iter
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iterp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|*
name|iterp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|iter
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|iter
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|iter
operator|->
name|mode
operator|=
literal|4
expr_stmt|;
name|iter
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|iter
operator|->
name|pos
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
name|iter
operator|->
name|buf6
operator|=
name|NULL
expr_stmt|;
name|iter
operator|->
name|pos6
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|iter
operator|->
name|result6
operator|=
name|ISC_R_NOMORE
expr_stmt|;
name|iter
operator|->
name|socket6
operator|=
operator|-
literal|1
expr_stmt|;
name|iter
operator|->
name|first6
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get the interface configuration, allocating more memory if 	 * necessary. 	 */
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
name|result
operator|=
name|isc_net_probeipv6
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Create an unbound datagram socket to do the SIOCGLIFCONF 		 * ioctl on.  HP/UX requires an AF_INET6 socket for 		 * SIOCGLIFCONF to get IPv6 addresses. 		 */
if|if
condition|(
operator|(
name|iter
operator|->
name|socket6
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_MAKESCANSOCKET
argument_list|,
literal|"making interface "
literal|"scan socket: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|socket6_failure
goto|;
block|}
name|result
operator|=
name|iter
operator|->
name|result6
operator|=
name|getbuf6
argument_list|(
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTIMPLEMENTED
operator|&&
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|ioctl6_failure
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|iter
operator|->
name|socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_MAKESCANSOCKET
argument_list|,
literal|"making interface "
literal|"scan socket: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|socket_failure
goto|;
block|}
name|result
operator|=
name|getbuf4
argument_list|(
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|ioctl_failure
goto|;
comment|/* 	 * A newly created iterator has an undefined position 	 * until isc_interfaceiter_first() is called. 	 */
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
name|iter
operator|->
name|clua_context
operator|=
operator|-
literal|1
expr_stmt|;
name|iter
operator|->
name|clua_done
operator|=
name|ISC_TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux
name|iter
operator|->
name|proc
operator|=
name|fopen
argument_list|(
literal|"/proc/net/if_inet6"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|iter
operator|->
name|valid
operator|=
name|ISC_R_FAILURE
expr_stmt|;
name|iter
operator|->
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
name|iter
operator|->
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
name|iter
operator|->
name|magic
operator|=
name|IFITER_MAGIC
expr_stmt|;
operator|*
name|iterp
operator|=
name|iter
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|ioctl_failure
label|:
if|if
condition|(
name|iter
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|iter
operator|->
name|buf
argument_list|,
name|iter
operator|->
name|bufsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|iter
operator|->
name|socket
argument_list|)
expr_stmt|;
name|socket_failure
label|:
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
if|if
condition|(
name|iter
operator|->
name|buf6
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|iter
operator|->
name|buf6
argument_list|,
name|iter
operator|->
name|bufsize6
argument_list|)
expr_stmt|;
name|ioctl6_failure
label|:
if|if
condition|(
name|iter
operator|->
name|socket6
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|iter
operator|->
name|socket6
argument_list|)
expr_stmt|;
name|socket6_failure
label|:
endif|#
directive|endif
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|iter
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iter
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
end_ifdef

begin_function
specifier|static
name|void
name|get_inaddr
parameter_list|(
name|isc_netaddr_t
modifier|*
name|dst
parameter_list|,
name|struct
name|in_addr
modifier|*
name|src
parameter_list|)
block|{
name|dst
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dst
operator|->
name|type
operator|.
name|in
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|internal_current_clusteralias
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|clua_info
name|ci
decl_stmt|;
if|if
condition|(
name|clua_getaliasinfo
argument_list|(
operator|&
name|iter
operator|->
name|clua_sa
argument_list|,
operator|&
name|ci
argument_list|)
operator|!=
name|CLUA_SUCCESS
condition|)
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
name|memset
argument_list|(
operator|&
name|iter
operator|->
name|current
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|iter
operator|->
name|current
operator|.
name|af
operator|=
name|iter
operator|->
name|clua_sa
operator|.
name|sa_family
expr_stmt|;
name|memset
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
literal|"clua%d"
argument_list|,
name|ci
operator|.
name|aliasid
argument_list|)
expr_stmt|;
name|iter
operator|->
name|current
operator|.
name|flags
operator|=
name|INTERFACE_F_UP
expr_stmt|;
name|get_inaddr
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|,
operator|&
name|ci
operator|.
name|addr
argument_list|)
expr_stmt|;
name|get_inaddr
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|netmask
argument_list|,
operator|&
name|ci
operator|.
name|netmask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__linux
end_ifdef

begin_function
specifier|static
name|isc_result_t
name|linux_if_inet6_next
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
if|if
condition|(
name|iter
operator|->
name|proc
operator|!=
name|NULL
operator|&&
name|fgets
argument_list|(
name|iter
operator|->
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|entry
argument_list|)
argument_list|,
name|iter
operator|->
name|proc
argument_list|)
operator|!=
name|NULL
condition|)
name|iter
operator|->
name|valid
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
else|else
name|iter
operator|->
name|valid
operator|=
name|ISC_R_NOMORE
expr_stmt|;
return|return
operator|(
name|iter
operator|->
name|valid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_if_inet6_first
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
if|if
condition|(
name|iter
operator|->
name|proc
operator|!=
name|NULL
condition|)
block|{
name|rewind
argument_list|(
name|iter
operator|->
name|proc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|linux_if_inet6_next
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
else|else
name|iter
operator|->
name|valid
operator|=
name|ISC_R_NOMORE
expr_stmt|;
name|iter
operator|->
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|linux_if_inet6_current
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
name|char
name|address
index|[
literal|33
index|]
decl_stmt|;
name|char
name|name
index|[
name|IF_NAMESIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|in6_addr
name|addr6
decl_stmt|;
name|int
name|ifindex
decl_stmt|,
name|prefix
decl_stmt|,
name|flag3
decl_stmt|,
name|flag4
decl_stmt|;
name|int
name|res
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|iter
operator|->
name|valid
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|iter
operator|->
name|valid
operator|)
return|;
if|if
condition|(
name|iter
operator|->
name|proc
operator|==
name|NULL
condition|)
block|{
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_INTERFACE
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"/proc/net/if_inet6:iter->proc == NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|res
operator|=
name|sscanf
argument_list|(
name|iter
operator|->
name|entry
argument_list|,
literal|"%32[a-f0-9] %x %x %x %x %16s\n"
argument_list|,
name|address
argument_list|,
operator|&
name|ifindex
argument_list|,
operator|&
name|prefix
argument_list|,
operator|&
name|flag3
argument_list|,
operator|&
name|flag4
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|6
condition|)
block|{
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_INTERFACE
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"/proc/net/if_inet6:sscanf() -> %d (expected 6)"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|address
argument_list|)
operator|!=
literal|32
condition|)
block|{
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_INTERFACE
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"/proc/net/if_inet6:strlen(%s) != 32"
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|byte
operator|=
operator|(
operator|(
name|index
argument_list|(
name|hex
argument_list|,
name|address
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
operator|-
name|hex
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|index
argument_list|(
name|hex
argument_list|,
name|address
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|-
name|hex
operator|)
expr_stmt|;
name|addr6
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|byte
expr_stmt|;
block|}
name|iter
operator|->
name|current
operator|.
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|iter
operator|->
name|current
operator|.
name|flags
operator|=
name|INTERFACE_F_UP
expr_stmt|;
name|isc_netaddr_fromin6
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|,
operator|&
name|addr6
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_netaddr_islinklocal
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|)
condition|)
block|{
name|isc_netaddr_setzone
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|,
operator|(
name|isc_uint32_t
operator|)
name|ifindex
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prefix
operator|>
literal|8
condition|)
block|{
name|addr6
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|prefix
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|addr6
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
operator|(
literal|0xff
operator|<<
operator|(
literal|8
operator|-
name|prefix
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|prefix
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|isc_netaddr_fromin6
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|netmask
argument_list|,
operator|&
name|addr6
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get information about the current interface to iter->current.  * If successful, return ISC_R_SUCCESS.  * If the interface has an unsupported address family, or if  * some operation on it fails, return ISC_R_IGNORE to make  * the higher-level iterator code ignore it.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|internal_current4
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|ifreq
modifier|*
name|ifrp
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|;
name|int
name|family
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIF_LADDRREQ
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
name|struct
name|lifreq
name|lifreq
decl_stmt|;
else|#
directive|else
name|char
name|sabuf
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|,
name|prefixlen
decl_stmt|;
ifdef|#
directive|ifdef
name|__linux
name|isc_result_t
name|result
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|VALID_IFITER
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iter
operator|->
name|pos
operator|<
operator|(
name|unsigned
name|int
operator|)
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux
name|result
operator|=
name|linux_if_inet6_current
argument_list|(
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|iter
operator|->
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
endif|#
directive|endif
name|ifrp
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|iter
operator|->
name|ifc
operator|.
name|ifc_req
operator|+
name|iter
operator|->
name|pos
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifreq
argument_list|,
name|ifrp
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|family
operator|=
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_family
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIPV6
argument_list|)
if|if
condition|(
name|family
operator|!=
name|AF_INET
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
else|#
directive|else
if|if
condition|(
name|family
operator|!=
name|AF_INET
condition|)
endif|#
directive|endif
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
name|memset
argument_list|(
operator|&
name|iter
operator|->
name|current
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|iter
operator|->
name|current
operator|.
name|af
operator|=
name|family
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|ifreq
operator|.
name|ifr_name
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|get_addr
argument_list|(
name|family
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifrp
operator|->
name|ifr_addr
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
comment|/* 	 * If the interface does not have a address ignore it. 	 */
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|iter
operator|->
name|current
operator|.
name|address
operator|.
name|type
operator|.
name|in
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
operator|.
name|type
operator|.
name|in6
argument_list|,
operator|&
name|in6addr_any
argument_list|,
sizeof|sizeof
argument_list|(
name|in6addr_any
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
break|break;
block|}
comment|/* 	 * Get interface flags. 	 */
name|iter
operator|->
name|current
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Ignore the HP/UX warning about "interger overflow during 	 * conversion.  It comes from its own macro definition, 	 * and is really hard to shut up. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|iter
operator|->
name|socket
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: getting interface flags: %s"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
name|iter
operator|->
name|current
operator|.
name|flags
operator||=
name|INTERFACE_F_UP
expr_stmt|;
ifdef|#
directive|ifdef
name|IFF_POINTOPOINT
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|!=
literal|0
condition|)
name|iter
operator|->
name|current
operator|.
name|flags
operator||=
name|INTERFACE_F_POINTTOPOINT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
name|iter
operator|->
name|current
operator|.
name|flags
operator||=
name|INTERFACE_F_LOOPBACK
expr_stmt|;
if|if
condition|(
name|family
operator|==
name|AF_INET
condition|)
goto|goto
name|inet
goto|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIF_LADDRREQ
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
name|memset
argument_list|(
operator|&
name|lifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lifreq
operator|.
name|lifr_name
argument_list|,
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
operator|.
name|lifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lifreq
operator|.
name|lifr_addr
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|address
operator|.
name|type
operator|.
name|in6
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|address
operator|.
name|type
operator|.
name|in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|iter
operator|->
name|socket
argument_list|,
name|SIOCGLIFADDR
argument_list|,
operator|&
name|lifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: getting interface address: %s"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
name|prefixlen
operator|=
name|lifreq
operator|.
name|lifr_addrlen
expr_stmt|;
else|#
directive|else
name|isc_netaddr_format
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|,
name|sabuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sabuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_INTERFACE
argument_list|,
name|ISC_LOG_INFO
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETIFCONFIG
argument_list|,
literal|"prefix length for %s is unknown "
literal|"(assume 128)"
argument_list|)
argument_list|,
name|sabuf
argument_list|)
expr_stmt|;
name|prefixlen
operator|=
literal|128
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Netmask already zeroed. 	 */
name|iter
operator|->
name|current
operator|.
name|netmask
operator|.
name|family
operator|=
name|family
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prefixlen
operator|>
literal|8
condition|)
block|{
name|bits
operator|=
literal|0
expr_stmt|;
name|prefixlen
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|bits
operator|=
literal|8
operator|-
name|prefixlen
expr_stmt|;
name|prefixlen
operator|=
literal|0
expr_stmt|;
block|}
name|iter
operator|->
name|current
operator|.
name|netmask
operator|.
name|type
operator|.
name|in6
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
operator|(
operator|~
literal|0
operator|<<
name|bits
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|inet
label|:
if|if
condition|(
name|family
operator|!=
name|AF_INET
condition|)
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
ifdef|#
directive|ifdef
name|IFF_POINTOPOINT
comment|/* 	 * If the interface is point-to-point, get the destination address. 	 */
if|if
condition|(
operator|(
name|iter
operator|->
name|current
operator|.
name|flags
operator|&
name|INTERFACE_F_POINTTOPOINT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Ignore the HP/UX warning about "interger overflow during 		 * conversion.  It comes from its own macro definition, 		 * and is really hard to shut up. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|iter
operator|->
name|socket
argument_list|,
name|SIOCGIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETDESTADDR
argument_list|,
literal|"%s: getting "
literal|"destination address: %s"
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
name|get_addr
argument_list|(
name|family
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|dstaddress
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_dstaddr
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Get the network mask. 	 */
name|memset
argument_list|(
operator|&
name|ifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifreq
argument_list|,
name|ifrp
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore the HP/UX warning about "interger overflow during 	 * conversion.  It comes from its own macro definition, 	 * and is really hard to shut up. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|iter
operator|->
name|socket
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETNETMASK
argument_list|,
literal|"%s: getting netmask: %s"
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
name|get_addr
argument_list|(
name|family
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|netmask
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
end_if

begin_function
specifier|static
name|isc_result_t
name|internal_current6
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|LIFREQ
modifier|*
name|ifrp
decl_stmt|;
name|struct
name|LIFREQ
name|lifreq
decl_stmt|;
name|int
name|family
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_IFITER
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|result6
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|iter
operator|->
name|result6
operator|)
return|;
name|REQUIRE
argument_list|(
name|iter
operator|->
name|pos6
operator|<
operator|(
name|unsigned
name|int
operator|)
name|iter
operator|->
name|lifc
operator|.
name|lifc_len
argument_list|)
expr_stmt|;
name|ifrp
operator|=
operator|(
expr|struct
name|LIFREQ
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|iter
operator|->
name|lifc
operator|.
name|lifc_req
operator|+
name|iter
operator|->
name|pos6
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lifreq
argument_list|,
name|ifrp
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
argument_list|)
argument_list|)
expr_stmt|;
name|family
operator|=
name|lifreq
operator|.
name|lifr_addr
operator|.
name|ss_family
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIPV6
if|if
condition|(
name|family
operator|!=
name|AF_INET
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
else|#
directive|else
if|if
condition|(
name|family
operator|!=
name|AF_INET
condition|)
endif|#
directive|endif
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
name|memset
argument_list|(
operator|&
name|iter
operator|->
name|current
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|iter
operator|->
name|current
operator|.
name|af
operator|=
name|family
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|lifreq
operator|.
name|lifr_name
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|iter
operator|->
name|current
operator|.
name|name
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
operator|.
name|lifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|get_addr
argument_list|(
name|family
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|address
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|lifreq
operator|.
name|lifr_addr
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|)
expr_stmt|;
comment|/* 	 * If the interface does not have a address ignore it. 	 */
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|iter
operator|->
name|current
operator|.
name|address
operator|.
name|type
operator|.
name|in
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|iter
operator|->
name|current
operator|.
name|address
operator|.
name|type
operator|.
name|in6
argument_list|,
operator|&
name|in6addr_any
argument_list|,
sizeof|sizeof
argument_list|(
name|in6addr_any
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
break|break;
block|}
comment|/* 	 * Get interface flags. 	 */
name|iter
operator|->
name|current
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
name|fd
operator|=
name|iter
operator|->
name|socket6
expr_stmt|;
else|else
name|fd
operator|=
name|iter
operator|->
name|socket
expr_stmt|;
comment|/* 	 * Ignore the HP/UX warning about "interger overflow during 	 * conversion.  It comes from its own macro definition, 	 * and is really hard to shut up. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGLIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: getting interface flags: %s"
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lifreq
operator|.
name|lifr_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
name|iter
operator|->
name|current
operator|.
name|flags
operator||=
name|INTERFACE_F_UP
expr_stmt|;
ifdef|#
directive|ifdef
name|IFF_POINTOPOINT
if|if
condition|(
operator|(
name|lifreq
operator|.
name|lifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|!=
literal|0
condition|)
name|iter
operator|->
name|current
operator|.
name|flags
operator||=
name|INTERFACE_F_POINTTOPOINT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|lifreq
operator|.
name|lifr_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
name|iter
operator|->
name|current
operator|.
name|flags
operator||=
name|INTERFACE_F_LOOPBACK
expr_stmt|;
ifdef|#
directive|ifdef
name|IFF_POINTOPOINT
comment|/* 	 * If the interface is point-to-point, get the destination address. 	 */
if|if
condition|(
operator|(
name|iter
operator|->
name|current
operator|.
name|flags
operator|&
name|INTERFACE_F_POINTTOPOINT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Ignore the HP/UX warning about "interger overflow during 		 * conversion.  It comes from its own macro definition, 		 * and is really hard to shut up. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGLIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETDESTADDR
argument_list|,
literal|"%s: getting "
literal|"destination address: %s"
argument_list|)
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
name|get_addr
argument_list|(
name|family
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|dstaddress
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|lifreq
operator|.
name|lifr_dstaddr
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Get the network mask.  Netmask already zeroed. 	 */
name|memset
argument_list|(
operator|&
name|lifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lifreq
argument_list|,
name|ifrp
argument_list|,
sizeof|sizeof
argument_list|(
name|lifreq
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lifr_addrlen
comment|/* 	 * Special case: if the system provides lifr_addrlen member, the 	 * netmask of an IPv6 address can be derived from the length, since 	 * an IPv6 address always has a contiguous mask. 	 */
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
block|{
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
name|iter
operator|->
name|current
operator|.
name|netmask
operator|.
name|family
operator|=
name|family
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lifreq
operator|.
name|lifr_addrlen
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|bits
operator|=
name|lifreq
operator|.
name|lifr_addrlen
operator|-
name|i
expr_stmt|;
name|bits
operator|=
operator|(
name|bits
operator|<
literal|8
operator|)
condition|?
operator|(
literal|8
operator|-
name|bits
operator|)
else|:
literal|0
expr_stmt|;
name|iter
operator|->
name|current
operator|.
name|netmask
operator|.
name|type
operator|.
name|in6
operator|.
name|s6_addr
index|[
name|i
operator|/
literal|8
index|]
operator|=
operator|(
operator|~
literal|0
operator|<<
name|bits
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Ignore the HP/UX warning about "interger overflow during 	 * conversion.  It comes from its own macro definition, 	 * and is really hard to shut up. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGLIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_IFITERIOCTL
argument_list|,
name|ISC_MSG_GETNETMASK
argument_list|,
literal|"%s: getting netmask: %s"
argument_list|)
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_IGNORE
operator|)
return|;
block|}
name|get_addr
argument_list|(
name|family
argument_list|,
operator|&
name|iter
operator|->
name|current
operator|.
name|netmask
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|lifreq
operator|.
name|lifr_addr
argument_list|,
name|lifreq
operator|.
name|lifr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|internal_current
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
if|if
condition|(
name|iter
operator|->
name|mode
operator|==
literal|6
condition|)
block|{
name|iter
operator|->
name|result6
operator|=
name|internal_current6
argument_list|(
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|result6
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|iter
operator|->
name|result6
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
if|if
condition|(
operator|!
name|iter
operator|->
name|clua_done
condition|)
return|return
operator|(
name|internal_current_clusteralias
argument_list|(
name|iter
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|internal_current4
argument_list|(
name|iter
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Step the iterator to the next interface.  Unlike  * isc_interfaceiter_next(), this may leave the iterator  * positioned on an interface that will ultimately  * be ignored.  Return ISC_R_NOMORE if there are no more  * interfaces, otherwise ISC_R_SUCCESS.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|internal_next4
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESALEN
name|struct
name|ifreq
modifier|*
name|ifrp
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|iter
operator|->
name|pos
operator|<
operator|(
name|unsigned
name|int
operator|)
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux
if|if
condition|(
name|linux_if_inet6_next
argument_list|(
name|iter
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
operator|!
name|iter
operator|->
name|first
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESALEN
name|ifrp
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|iter
operator|->
name|ifc
operator|.
name|ifc_req
operator|+
name|iter
operator|->
name|pos
operator|)
expr_stmt|;
if|if
condition|(
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|iter
operator|->
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
operator|+
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_len
expr_stmt|;
else|else
endif|#
directive|endif
name|iter
operator|->
name|pos
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|pos
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|iter
operator|->
name|ifc
operator|.
name|ifc_len
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
end_if

begin_function
specifier|static
name|isc_result_t
name|internal_next6
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESALEN
name|struct
name|LIFREQ
modifier|*
name|ifrp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iter
operator|->
name|result6
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|iter
operator|->
name|result6
operator|!=
name|ISC_R_IGNORE
condition|)
return|return
operator|(
name|iter
operator|->
name|result6
operator|)
return|;
name|REQUIRE
argument_list|(
name|iter
operator|->
name|pos6
operator|<
operator|(
name|unsigned
name|int
operator|)
name|iter
operator|->
name|lifc
operator|.
name|lifc_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESALEN
name|ifrp
operator|=
operator|(
expr|struct
name|LIFREQ
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|iter
operator|->
name|lifc
operator|.
name|lifc_req
operator|+
name|iter
operator|->
name|pos6
operator|)
expr_stmt|;
if|if
condition|(
name|ifrp
operator|->
name|lifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|iter
operator|->
name|pos6
operator|+=
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|lifr_name
argument_list|)
operator|+
name|ifrp
operator|->
name|lifr_addr
operator|.
name|sa_len
expr_stmt|;
else|else
endif|#
directive|endif
name|iter
operator|->
name|pos6
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|LIFREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|pos6
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|iter
operator|->
name|lifc
operator|.
name|lifc_len
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|internal_next
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
name|int
name|clua_result
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
if|if
condition|(
name|iter
operator|->
name|mode
operator|==
literal|6
condition|)
block|{
name|iter
operator|->
name|result6
operator|=
name|internal_next6
argument_list|(
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|result6
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|iter
operator|->
name|result6
operator|)
return|;
if|if
condition|(
name|iter
operator|->
name|first6
condition|)
block|{
name|iter
operator|->
name|first6
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
if|if
condition|(
operator|!
name|iter
operator|->
name|clua_done
condition|)
block|{
name|clua_result
operator|=
name|clua_getaliasaddress
argument_list|(
operator|&
name|iter
operator|->
name|clua_sa
argument_list|,
operator|&
name|iter
operator|->
name|clua_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|clua_result
operator|!=
name|CLUA_SUCCESS
condition|)
name|iter
operator|->
name|clua_done
operator|=
name|ISC_TRUE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|internal_next4
argument_list|(
name|iter
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_destroy
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|iter
operator|->
name|socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
if|if
condition|(
name|iter
operator|->
name|socket6
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|iter
operator|->
name|socket6
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|buf6
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|iter
operator|->
name|mctx
argument_list|,
name|iter
operator|->
name|buf6
argument_list|,
name|iter
operator|->
name|bufsize6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux
if|if
condition|(
name|iter
operator|->
name|proc
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|iter
operator|->
name|proc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|internal_first
parameter_list|(
name|isc_interfaceiter_t
modifier|*
name|iter
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
name|int
name|clua_result
decl_stmt|;
endif|#
directive|endif
name|iter
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFADDR
argument_list|)
name|iter
operator|->
name|pos6
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iter
operator|->
name|result6
operator|==
name|ISC_R_NOMORE
condition|)
name|iter
operator|->
name|result6
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|iter
operator|->
name|first6
operator|=
name|ISC_TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TRUCLUSTER
name|iter
operator|->
name|clua_context
operator|=
literal|0
expr_stmt|;
name|clua_result
operator|=
name|clua_getaliasaddress
argument_list|(
operator|&
name|iter
operator|->
name|clua_sa
argument_list|,
operator|&
name|iter
operator|->
name|clua_context
argument_list|)
expr_stmt|;
name|iter
operator|->
name|clua_done
operator|=
name|ISC_TF
argument_list|(
name|clua_result
operator|!=
name|CLUA_SUCCESS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux
name|linux_if_inet6_first
argument_list|(
name|iter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

