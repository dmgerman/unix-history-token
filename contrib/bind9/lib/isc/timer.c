begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2008  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: timer.c,v 1.64.12.20 2008/08/22 05:59:24 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/condition.h>
end_include

begin_include
include|#
directive|include
file|<isc/heap.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_include
include|#
directive|include
file|"timer_p.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_TIMER_TRACE
end_ifdef

begin_define
define|#
directive|define
name|XTRACE
parameter_list|(
name|s
parameter_list|)
value|fprintf(stderr, "%s\n", (s))
end_define

begin_define
define|#
directive|define
name|XTRACEID
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|fprintf(stderr, "%s %p\n", (s), (t))
end_define

begin_define
define|#
directive|define
name|XTRACETIME
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
value|fprintf(stderr, "%s %u.%09u\n", (s), \ 					       (d).seconds, (d).nanoseconds)
end_define

begin_define
define|#
directive|define
name|XTRACETIME2
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|fprintf(stderr, "%s %u.%09u %u.%09u\n", (s), \ 					       (d).seconds, (d).nanoseconds, (n).seconds, (n).nanoseconds)
end_define

begin_define
define|#
directive|define
name|XTRACETIMER
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|)
value|fprintf(stderr, "%s %p %u.%09u\n", (s), (t), \ 					       (d).seconds, (d).nanoseconds)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XTRACE
parameter_list|(
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XTRACEID
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XTRACETIME
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XTRACETIME2
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XTRACETIMER
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_TIMER_TRACE */
end_comment

begin_define
define|#
directive|define
name|TIMER_MAGIC
value|ISC_MAGIC('T', 'I', 'M', 'R')
end_define

begin_define
define|#
directive|define
name|VALID_TIMER
parameter_list|(
name|t
parameter_list|)
value|ISC_MAGIC_VALID(t, TIMER_MAGIC)
end_define

begin_struct
struct|struct
name|isc_timer
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by timer lock. */
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_time_t
name|idle
decl_stmt|;
comment|/* Locked by manager lock. */
name|isc_timertype_t
name|type
decl_stmt|;
name|isc_time_t
name|expires
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_taskaction_t
name|action
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|isc_time_t
name|due
decl_stmt|;
name|LINK
argument_list|(
argument|isc_timer_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TIMER_MANAGER_MAGIC
value|ISC_MAGIC('T', 'I', 'M', 'M')
end_define

begin_define
define|#
directive|define
name|VALID_MANAGER
parameter_list|(
name|m
parameter_list|)
value|ISC_MAGIC_VALID(m, TIMER_MANAGER_MAGIC)
end_define

begin_struct
struct|struct
name|isc_timermgr
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by manager lock. */
name|isc_boolean_t
name|done
decl_stmt|;
name|LIST
argument_list|(
argument|isc_timer_t
argument_list|)
name|timers
expr_stmt|;
name|unsigned
name|int
name|nscheduled
decl_stmt|;
name|isc_time_t
name|due
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_condition_t
name|wakeup
decl_stmt|;
name|isc_thread_t
name|thread
decl_stmt|;
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
name|unsigned
name|int
name|refs
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|isc_heap_t
modifier|*
name|heap
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_comment
comment|/*  * If threads are not in use, there can be only one.  */
end_comment

begin_decl_stmt
specifier|static
name|isc_timermgr_t
modifier|*
name|timermgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|schedule
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|,
name|isc_boolean_t
name|signal_ok
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_time_t
name|due
decl_stmt|;
name|int
name|cmp
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_boolean_t
name|timedwait
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Note: the caller must ensure locking. 	 */
name|REQUIRE
argument_list|(
name|timer
operator|->
name|type
operator|!=
name|isc_timertype_inactive
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|UNUSED
argument_list|(
name|signal_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|=
name|timer
operator|->
name|manager
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * If the manager was timed wait, we may need to signal the 	 * manager to force a wakeup. 	 */
name|timedwait
operator|=
name|ISC_TF
argument_list|(
name|manager
operator|->
name|nscheduled
operator|>
literal|0
operator|&&
name|isc_time_seconds
argument_list|(
operator|&
name|manager
operator|->
name|due
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Compute the new due time. 	 */
if|if
condition|(
name|timer
operator|->
name|type
operator|!=
name|isc_timertype_once
condition|)
block|{
name|result
operator|=
name|isc_time_add
argument_list|(
name|now
argument_list|,
operator|&
name|timer
operator|->
name|interval
argument_list|,
operator|&
name|due
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|timer
operator|->
name|type
operator|==
name|isc_timertype_limited
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|timer
operator|->
name|expires
argument_list|,
operator|&
name|due
argument_list|)
operator|<
literal|0
condition|)
name|due
operator|=
name|timer
operator|->
name|expires
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|timer
operator|->
name|idle
argument_list|)
condition|)
name|due
operator|=
name|timer
operator|->
name|expires
expr_stmt|;
elseif|else
if|if
condition|(
name|isc_time_isepoch
argument_list|(
operator|&
name|timer
operator|->
name|expires
argument_list|)
condition|)
name|due
operator|=
name|timer
operator|->
name|idle
expr_stmt|;
elseif|else
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|timer
operator|->
name|idle
argument_list|,
operator|&
name|timer
operator|->
name|expires
argument_list|)
operator|<
literal|0
condition|)
name|due
operator|=
name|timer
operator|->
name|idle
expr_stmt|;
else|else
name|due
operator|=
name|timer
operator|->
name|expires
expr_stmt|;
block|}
comment|/* 	 * Schedule the timer. 	 */
if|if
condition|(
name|timer
operator|->
name|index
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Already scheduled. 		 */
name|cmp
operator|=
name|isc_time_compare
argument_list|(
operator|&
name|due
argument_list|,
operator|&
name|timer
operator|->
name|due
argument_list|)
expr_stmt|;
name|timer
operator|->
name|due
operator|=
name|due
expr_stmt|;
switch|switch
condition|(
name|cmp
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|isc_heap_increased
argument_list|(
name|manager
operator|->
name|heap
argument_list|,
name|timer
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|isc_heap_decreased
argument_list|(
name|manager
operator|->
name|heap
argument_list|,
name|timer
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Nothing to do. */
break|break;
block|}
block|}
else|else
block|{
name|timer
operator|->
name|due
operator|=
name|due
expr_stmt|;
name|result
operator|=
name|isc_heap_insert
argument_list|(
name|manager
operator|->
name|heap
argument_list|,
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|manager
operator|->
name|nscheduled
operator|++
expr_stmt|;
block|}
name|XTRACETIMER
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_SCHEDULE
argument_list|,
literal|"schedule"
argument_list|)
argument_list|,
name|timer
argument_list|,
name|due
argument_list|)
expr_stmt|;
comment|/* 	 * If this timer is at the head of the queue, we need to ensure 	 * that we won't miss it if it has a more recent due time than 	 * the current "next" timer.  We do this either by waking up the 	 * run thread, or explicitly setting the value in the manager. 	 */
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * This is a temporary (probably) hack to fix a bug on tru64 5.1 	 * and 5.1a.  Sometimes, pthread_cond_timedwait() doesn't actually 	 * return when the time expires, so here, we check to see if 	 * we're 15 seconds or more behind, and if we are, we signal 	 * the dispatcher.  This isn't such a bad idea as a general purpose 	 * watchdog, so perhaps we should just leave it in here. 	 */
if|if
condition|(
name|signal_ok
operator|&&
name|timedwait
condition|)
block|{
name|isc_interval_t
name|fifteen
decl_stmt|;
name|isc_time_t
name|then
decl_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|fifteen
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_time_add
argument_list|(
operator|&
name|manager
operator|->
name|due
argument_list|,
operator|&
name|fifteen
argument_list|,
operator|&
name|then
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|then
argument_list|,
name|now
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
name|signal_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_TIMER
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"*** POKED TIMER ***"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timer
operator|->
name|index
operator|==
literal|1
operator|&&
name|signal_ok
condition|)
block|{
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_SIGNALSCHED
argument_list|,
literal|"signal (schedule)"
argument_list|)
argument_list|)
expr_stmt|;
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
if|if
condition|(
name|timer
operator|->
name|index
operator|==
literal|1
operator|&&
name|isc_time_compare
argument_list|(
operator|&
name|timer
operator|->
name|due
argument_list|,
operator|&
name|manager
operator|->
name|due
argument_list|)
operator|<
literal|0
condition|)
name|manager
operator|->
name|due
operator|=
name|timer
operator|->
name|due
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|deschedule
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|)
block|{
name|isc_boolean_t
name|need_wakeup
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|manager
decl_stmt|;
comment|/* 	 * The caller must ensure locking. 	 */
name|manager
operator|=
name|timer
operator|->
name|manager
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|index
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|timer
operator|->
name|index
operator|==
literal|1
condition|)
name|need_wakeup
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_heap_delete
argument_list|(
name|manager
operator|->
name|heap
argument_list|,
name|timer
operator|->
name|index
argument_list|)
expr_stmt|;
name|timer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|manager
operator|->
name|nscheduled
operator|>
literal|0
argument_list|)
expr_stmt|;
name|manager
operator|->
name|nscheduled
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|need_wakeup
condition|)
block|{
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_SIGNALDESCHED
argument_list|,
literal|"signal (deschedule)"
argument_list|)
argument_list|)
expr_stmt|;
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|)
block|{
name|isc_timermgr_t
modifier|*
name|manager
init|=
name|timer
operator|->
name|manager
decl_stmt|;
comment|/* 	 * The caller must ensure it is safe to destroy the timer. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_task_purgerange
argument_list|(
name|timer
operator|->
name|task
argument_list|,
name|timer
argument_list|,
name|ISC_TIMEREVENT_FIRSTEVENT
argument_list|,
name|ISC_TIMEREVENT_LASTEVENT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|deschedule
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|manager
operator|->
name|timers
argument_list|,
name|timer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|timer
operator|->
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
name|timer
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_timer_create
parameter_list|(
name|isc_timermgr_t
modifier|*
name|manager
parameter_list|,
name|isc_timertype_t
name|type
parameter_list|,
name|isc_time_t
modifier|*
name|expires
parameter_list|,
name|isc_interval_t
modifier|*
name|interval
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_timer_t
modifier|*
modifier|*
name|timerp
parameter_list|)
block|{
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
comment|/* 	 * Create a new 'type' timer managed by 'manager'.  The timers 	 * parameters are specified by 'expires' and 'interval'.  Events 	 * will be posted to 'task' and when dispatched 'action' will be 	 * called with 'arg' as the arg value.  The new timer is returned 	 * in 'timerp'. 	 */
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|expires
operator|==
name|NULL
condition|)
name|expires
operator|=
name|isc_time_epoch
expr_stmt|;
if|if
condition|(
name|interval
operator|==
name|NULL
condition|)
name|interval
operator|=
name|isc_interval_zero
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|==
name|isc_timertype_inactive
operator|||
operator|!
operator|(
name|isc_time_isepoch
argument_list|(
name|expires
argument_list|)
operator|&&
name|isc_interval_iszero
argument_list|(
name|interval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|timerp
operator|!=
name|NULL
operator|&&
operator|*
name|timerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|isc_timertype_limited
operator|||
operator|!
operator|(
name|isc_time_isepoch
argument_list|(
name|expires
argument_list|)
operator|||
name|isc_interval_iszero
argument_list|(
name|interval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get current time. 	 */
if|if
condition|(
name|type
operator|!=
name|isc_timertype_inactive
condition|)
block|{
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't have to do this, but it keeps the compiler from 		 * complaining about "now" possibly being used without being 		 * set, even though it will never actually happen. 		 */
name|isc_time_settoepoch
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|timer
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|timer
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
name|timer
operator|->
name|references
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|isc_timertype_once
operator|&&
operator|!
name|isc_interval_iszero
argument_list|(
name|interval
argument_list|)
condition|)
block|{
name|result
operator|=
name|isc_time_add
argument_list|(
operator|&
name|now
argument_list|,
name|interval
argument_list|,
operator|&
name|timer
operator|->
name|idle
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
else|else
name|isc_time_settoepoch
argument_list|(
operator|&
name|timer
operator|->
name|idle
argument_list|)
expr_stmt|;
name|timer
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|timer
operator|->
name|expires
operator|=
operator|*
name|expires
expr_stmt|;
name|timer
operator|->
name|interval
operator|=
operator|*
name|interval
expr_stmt|;
name|timer
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|timer
operator|->
name|task
argument_list|)
expr_stmt|;
name|timer
operator|->
name|action
operator|=
name|action
expr_stmt|;
comment|/* 	 * Removing the const attribute from "arg" is the best of two 	 * evils here.  If the timer->arg member is made const, then 	 * it affects a great many recipients of the timer event 	 * which did not pass in an "arg" that was truly const. 	 * Changing isc_timer_create() to not have "arg" prototyped as const, 	 * though, can cause compilers warnings for calls that *do* 	 * have a truly const arg.  The caller will have to carefully 	 * keep track of whether arg started as a true const. 	 */
name|DE_CONST
argument_list|(
name|arg
argument_list|,
name|timer
operator|->
name|arg
argument_list|)
expr_stmt|;
name|timer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_task_detach
argument_list|(
operator|&
name|timer
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|timer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|timer
operator|->
name|magic
operator|=
name|TIMER_MAGIC
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Note we don't have to lock the timer like we normally would because 	 * there are no external references to it yet. 	 */
if|if
condition|(
name|type
operator|!=
name|isc_timertype_inactive
condition|)
name|result
operator|=
name|schedule
argument_list|(
name|timer
argument_list|,
operator|&
name|now
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|APPEND
argument_list|(
name|manager
operator|->
name|timers
argument_list|,
name|timer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|timer
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|timer
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|timerp
operator|=
name|timer
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_timer_reset
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|,
name|isc_timertype_t
name|type
parameter_list|,
name|isc_time_t
modifier|*
name|expires
parameter_list|,
name|isc_interval_t
modifier|*
name|interval
parameter_list|,
name|isc_boolean_t
name|purge
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Change the timer's type, expires, and interval values to the given 	 * values.  If 'purge' is ISC_TRUE, any pending events from this timer 	 * are purged from its task's event queue. 	 */
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|=
name|timer
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expires
operator|==
name|NULL
condition|)
name|expires
operator|=
name|isc_time_epoch
expr_stmt|;
if|if
condition|(
name|interval
operator|==
name|NULL
condition|)
name|interval
operator|=
name|isc_interval_zero
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|==
name|isc_timertype_inactive
operator|||
operator|!
operator|(
name|isc_time_isepoch
argument_list|(
name|expires
argument_list|)
operator|&&
name|isc_interval_iszero
argument_list|(
name|interval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|isc_timertype_limited
operator|||
operator|!
operator|(
name|isc_time_isepoch
argument_list|(
name|expires
argument_list|)
operator|||
name|isc_interval_iszero
argument_list|(
name|interval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get current time. 	 */
if|if
condition|(
name|type
operator|!=
name|isc_timertype_inactive
condition|)
block|{
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't have to do this, but it keeps the compiler from 		 * complaining about "now" possibly being used without being 		 * set, even though it will never actually happen. 		 */
name|isc_time_settoepoch
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|manager
operator|=
name|timer
operator|->
name|manager
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge
condition|)
operator|(
name|void
operator|)
name|isc_task_purgerange
argument_list|(
name|timer
operator|->
name|task
argument_list|,
name|timer
argument_list|,
name|ISC_TIMEREVENT_FIRSTEVENT
argument_list|,
name|ISC_TIMEREVENT_LASTEVENT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timer
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|timer
operator|->
name|expires
operator|=
operator|*
name|expires
expr_stmt|;
name|timer
operator|->
name|interval
operator|=
operator|*
name|interval
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|isc_timertype_once
operator|&&
operator|!
name|isc_interval_iszero
argument_list|(
name|interval
argument_list|)
condition|)
block|{
name|result
operator|=
name|isc_time_add
argument_list|(
operator|&
name|now
argument_list|,
name|interval
argument_list|,
operator|&
name|timer
operator|->
name|idle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_time_settoepoch
argument_list|(
operator|&
name|timer
operator|->
name|idle
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|isc_timertype_inactive
condition|)
block|{
name|deschedule
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
name|result
operator|=
name|schedule
argument_list|(
name|timer
argument_list|,
operator|&
name|now
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_timertype_t
name|isc_timer_gettype
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|)
block|{
name|isc_timertype_t
name|t
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
name|t
operator|=
name|timer
operator|->
name|type
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_timer_touch
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
comment|/* 	 * Set the last-touched time of 'timer' to the current time. 	 */
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * We'd like to 	 * 	 *	REQUIRE(timer->type == isc_timertype_once); 	 * 	 * but we cannot without locking the manager lock too, which we 	 * don't want to do. 	 */
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_time_add
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|timer
operator|->
name|interval
argument_list|,
operator|&
name|timer
operator|->
name|idle
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_timer_attach
parameter_list|(
name|isc_timer_t
modifier|*
name|timer
parameter_list|,
name|isc_timer_t
modifier|*
modifier|*
name|timerp
parameter_list|)
block|{
comment|/* 	 * Attach *timerp to timer. 	 */
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|timerp
operator|!=
name|NULL
operator|&&
operator|*
name|timerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
name|timer
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|timerp
operator|=
name|timer
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_timer_detach
parameter_list|(
name|isc_timer_t
modifier|*
modifier|*
name|timerp
parameter_list|)
block|{
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|isc_boolean_t
name|free_timer
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * Detach *timerp from its timer. 	 */
name|REQUIRE
argument_list|(
name|timerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|timer
operator|=
operator|*
name|timerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|timer
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|timer
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|references
operator|==
literal|0
condition|)
name|free_timer
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_timer
condition|)
name|destroy
argument_list|(
name|timer
argument_list|)
expr_stmt|;
operator|*
name|timerp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch
parameter_list|(
name|isc_timermgr_t
modifier|*
name|manager
parameter_list|,
name|isc_time_t
modifier|*
name|now
parameter_list|)
block|{
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|,
name|post_event
decl_stmt|,
name|need_schedule
decl_stmt|;
name|isc_timerevent_t
modifier|*
name|event
decl_stmt|;
name|isc_eventtype_t
name|type
init|=
literal|0
decl_stmt|;
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|idle
decl_stmt|;
comment|/* 	 * The caller must be holding the manager lock. 	 */
while|while
condition|(
name|manager
operator|->
name|nscheduled
operator|>
literal|0
operator|&&
operator|!
name|done
condition|)
block|{
name|timer
operator|=
name|isc_heap_element
argument_list|(
name|manager
operator|->
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|timer
operator|->
name|type
operator|!=
name|isc_timertype_inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
name|now
argument_list|,
operator|&
name|timer
operator|->
name|due
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|timer
operator|->
name|type
operator|==
name|isc_timertype_ticker
condition|)
block|{
name|type
operator|=
name|ISC_TIMEREVENT_TICK
expr_stmt|;
name|post_event
operator|=
name|ISC_TRUE
expr_stmt|;
name|need_schedule
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timer
operator|->
name|type
operator|==
name|isc_timertype_limited
condition|)
block|{
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|isc_time_compare
argument_list|(
name|now
argument_list|,
operator|&
name|timer
operator|->
name|expires
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|ISC_TIMEREVENT_LIFE
expr_stmt|;
name|post_event
operator|=
name|ISC_TRUE
expr_stmt|;
name|need_schedule
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ISC_TIMEREVENT_TICK
expr_stmt|;
name|post_event
operator|=
name|ISC_TRUE
expr_stmt|;
name|need_schedule
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|timer
operator|->
name|expires
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
name|now
argument_list|,
operator|&
name|timer
operator|->
name|expires
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|ISC_TIMEREVENT_LIFE
expr_stmt|;
name|post_event
operator|=
name|ISC_TRUE
expr_stmt|;
name|need_schedule
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|idle
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_time_isepoch
argument_list|(
operator|&
name|timer
operator|->
name|idle
argument_list|)
operator|&&
name|isc_time_compare
argument_list|(
name|now
argument_list|,
operator|&
name|timer
operator|->
name|idle
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|idle
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|timer
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle
condition|)
block|{
name|type
operator|=
name|ISC_TIMEREVENT_IDLE
expr_stmt|;
name|post_event
operator|=
name|ISC_TRUE
expr_stmt|;
name|need_schedule
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Idle timer has been touched; 					 * reschedule. 					 */
name|XTRACEID
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_IDLERESCHED
argument_list|,
literal|"idle reschedule"
argument_list|)
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|post_event
operator|=
name|ISC_FALSE
expr_stmt|;
name|need_schedule
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|post_event
condition|)
block|{
name|XTRACEID
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_POSTING
argument_list|,
literal|"posting"
argument_list|)
argument_list|,
name|timer
argument_list|)
expr_stmt|;
comment|/* 				 * XXX We could preallocate this event. 				 */
name|event
operator|=
operator|(
name|isc_timerevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|timer
argument_list|,
name|type
argument_list|,
name|timer
operator|->
name|action
argument_list|,
name|timer
operator|->
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|event
operator|->
name|due
operator|=
name|timer
operator|->
name|due
expr_stmt|;
name|isc_task_send
argument_list|(
name|timer
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_EVENTNOTALLOC
argument_list|,
literal|"couldn't "
literal|"allocate event"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|timer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|isc_heap_delete
argument_list|(
name|manager
operator|->
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|manager
operator|->
name|nscheduled
operator|--
expr_stmt|;
if|if
condition|(
name|need_schedule
condition|)
block|{
name|result
operator|=
name|schedule
argument_list|(
name|timer
argument_list|,
name|now
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_SCHEDFAIL
argument_list|,
literal|"couldn't "
literal|"schedule timer: %u"
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|manager
operator|->
name|due
operator|=
name|timer
operator|->
name|due
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_function
specifier|static
name|isc_threadresult_t
ifdef|#
directive|ifdef
name|_WIN32
comment|/* XXXDCL */
name|WINAPI
endif|#
directive|endif
name|run
parameter_list|(
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|isc_timermgr_t
modifier|*
name|manager
init|=
name|uap
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|manager
operator|->
name|done
condition|)
block|{
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|XTRACETIME
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_RUNNING
argument_list|,
literal|"running"
argument_list|)
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|dispatch
argument_list|(
name|manager
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|nscheduled
operator|>
literal|0
condition|)
block|{
name|XTRACETIME2
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_WAITUNTIL
argument_list|,
literal|"waituntil"
argument_list|)
argument_list|,
name|manager
operator|->
name|due
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|result
operator|=
name|WAITUNTIL
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|,
operator|&
name|manager
operator|->
name|due
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_TIMEDOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XTRACETIME
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_WAIT
argument_list|,
literal|"wait"
argument_list|)
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|WAIT
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_WAKEUP
argument_list|,
literal|"wakeup"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_threadresult_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|sooner
parameter_list|(
name|void
modifier|*
name|v1
parameter_list|,
name|void
modifier|*
name|v2
parameter_list|)
block|{
name|isc_timer_t
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|t1
operator|=
name|v1
expr_stmt|;
name|t2
operator|=
name|v2
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|t1
operator|->
name|due
argument_list|,
operator|&
name|t2
operator|->
name|due
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_index
parameter_list|(
name|void
modifier|*
name|what
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|isc_timer_t
modifier|*
name|timer
decl_stmt|;
name|timer
operator|=
name|what
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_TIMER
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|timer
operator|->
name|index
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_timermgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_timermgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_timermgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Create a timer manager. 	 */
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
operator|&&
operator|*
name|managerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|timermgr
operator|!=
name|NULL
condition|)
block|{
name|timermgr
operator|->
name|refs
operator|++
expr_stmt|;
operator|*
name|managerp
operator|=
name|timermgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|manager
operator|->
name|magic
operator|=
name|TIMER_MANAGER_MAGIC
expr_stmt|;
name|manager
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|INIT_LIST
argument_list|(
name|manager
operator|->
name|timers
argument_list|)
expr_stmt|;
name|manager
operator|->
name|nscheduled
operator|=
literal|0
expr_stmt|;
name|isc_time_settoepoch
argument_list|(
operator|&
name|manager
operator|->
name|due
argument_list|)
expr_stmt|;
name|manager
operator|->
name|heap
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_heap_create
argument_list|(
name|mctx
argument_list|,
name|sooner
argument_list|,
name|set_index
argument_list|,
literal|0
argument_list|,
operator|&
name|manager
operator|->
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_heap_destroy
argument_list|(
operator|&
name|manager
operator|->
name|heap
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|isc_condition_init
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_detach
argument_list|(
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_heap_destroy
argument_list|(
operator|&
name|manager
operator|->
name|heap
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_condition_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
if|if
condition|(
name|isc_thread_create
argument_list|(
name|run
argument_list|,
name|manager
argument_list|,
operator|&
name|manager
operator|->
name|thread
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_detach
argument_list|(
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_heap_destroy
argument_list|(
operator|&
name|manager
operator|->
name|heap
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_create() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
else|#
directive|else
comment|/* ISC_PLATFORM_USETHREADS */
name|manager
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
name|timermgr
operator|=
name|manager
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
operator|*
name|managerp
operator|=
name|manager
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_timermgr_poke
parameter_list|(
name|isc_timermgr_t
modifier|*
name|manager
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|manager
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|isc_timermgr_destroy
parameter_list|(
name|isc_timermgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_timermgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 	 * Destroy a timer manager. 	 */
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
operator|*
name|managerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|manager
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|manager
operator|->
name|refs
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|isc__timermgr_dispatch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|REQUIRE
argument_list|(
name|EMPTY
argument_list|(
name|manager
operator|->
name|timers
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|XTRACE
argument_list|(
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_TIMER
argument_list|,
name|ISC_MSG_SIGNALDESTROY
argument_list|,
literal|"signal (destroy)"
argument_list|)
argument_list|)
expr_stmt|;
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
comment|/* 	 * Wait for thread to exit. 	 */
if|if
condition|(
name|isc_thread_join
argument_list|(
name|manager
operator|->
name|thread
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_join() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
comment|/* 	 * Clean up. 	 */
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|wakeup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_PLATFORM_USETHREADS */
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_heap_destroy
argument_list|(
operator|&
name|manager
operator|->
name|heap
argument_list|)
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|manager
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
end_ifndef

begin_function
name|isc_result_t
name|isc__timermgr_nextevent
parameter_list|(
name|isc_time_t
modifier|*
name|when
parameter_list|)
block|{
if|if
condition|(
name|timermgr
operator|==
name|NULL
operator|||
name|timermgr
operator|->
name|nscheduled
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
operator|*
name|when
operator|=
name|timermgr
operator|->
name|due
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__timermgr_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_time_t
name|now
decl_stmt|;
if|if
condition|(
name|timermgr
operator|==
name|NULL
condition|)
return|return;
name|TIME_NOW
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|dispatch
argument_list|(
name|timermgr
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

end_unit

