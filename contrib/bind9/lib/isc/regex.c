begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013-2015  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/regex.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_if
if|#
directive|if
name|VALREGEX_REPORT_REASON
end_if

begin_define
define|#
directive|define
name|FAIL
parameter_list|(
name|x
parameter_list|)
value|do { reason = (x); goto error; } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FAIL
parameter_list|(
name|x
parameter_list|)
value|goto error
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Validate the regular expression 'C' locale.  */
end_comment

begin_function
name|int
name|isc_regex_validate
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|)
block|{
enum|enum
block|{
name|none
block|,
name|parse_bracket
block|,
name|parse_bound
block|,
name|parse_ce
block|,
name|parse_ec
block|,
name|parse_cc
block|}
name|state
init|=
name|none
enum|;
comment|/* Well known character classes. */
specifier|const
name|char
modifier|*
name|cc
index|[]
init|=
block|{
literal|":alnum:"
block|,
literal|":digit:"
block|,
literal|":punct:"
block|,
literal|":alpha:"
block|,
literal|":graph:"
block|,
literal|":space:"
block|,
literal|":blank:"
block|,
literal|":lower:"
block|,
literal|":upper:"
block|,
literal|":cntrl:"
block|,
literal|":print:"
block|,
literal|":xdigit:"
block|}
decl_stmt|;
name|isc_boolean_t
name|seen_comma
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|seen_high
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|seen_char
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|seen_ec
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|seen_ce
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|have_atom
init|=
name|ISC_FALSE
decl_stmt|;
name|int
name|group
init|=
literal|0
decl_stmt|;
name|int
name|range
init|=
literal|0
decl_stmt|;
name|int
name|sub
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|empty_ok
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|neg
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|was_multiple
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|low
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|high
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ccname
init|=
name|NULL
decl_stmt|;
name|int
name|range_start
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|VALREGEX_REPORT_REASON
specifier|const
name|char
modifier|*
name|reason
init|=
literal|""
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
operator|*
name|c
operator|==
literal|0
condition|)
name|FAIL
argument_list|(
literal|"empty string"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|NULL
operator|&&
operator|*
name|c
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|none
case|:
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* make literal */
operator|++
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|(
operator|*
name|c
operator|-
literal|'0'
operator|)
operator|>
name|sub
condition|)
name|FAIL
argument_list|(
literal|"bad back reference"
argument_list|)
expr_stmt|;
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|FAIL
argument_list|(
literal|"escaped end-of-string"
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|literal
goto|;
block|}
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* bracket start */
operator|++
name|c
expr_stmt|;
name|neg
operator|=
name|ISC_FALSE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_FALSE
expr_stmt|;
name|seen_char
operator|=
name|ISC_FALSE
expr_stmt|;
name|state
operator|=
name|parse_bracket
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* bound start */
switch|switch
condition|(
name|c
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|!
name|have_atom
condition|)
name|FAIL
argument_list|(
literal|"no atom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_multiple
condition|)
name|FAIL
argument_list|(
literal|"was multiple"
argument_list|)
expr_stmt|;
name|seen_comma
operator|=
name|ISC_FALSE
expr_stmt|;
name|seen_high
operator|=
name|ISC_FALSE
expr_stmt|;
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|parse_bound
expr_stmt|;
break|break;
default|default:
goto|goto
name|literal
goto|;
block|}
operator|++
name|c
expr_stmt|;
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
goto|goto
name|literal
goto|;
case|case
literal|'('
case|:
comment|/* group start */
name|have_atom
operator|=
name|ISC_FALSE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_FALSE
expr_stmt|;
name|empty_ok
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|group
expr_stmt|;
operator|++
name|sub
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|')'
case|:
comment|/* group end */
if|if
condition|(
name|group
operator|&&
operator|!
name|have_atom
operator|&&
operator|!
name|empty_ok
condition|)
name|FAIL
argument_list|(
literal|"empty alternative"
argument_list|)
expr_stmt|;
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|group
operator|!=
literal|0
condition|)
operator|--
name|group
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* alternative seperator */
if|if
condition|(
operator|!
name|have_atom
condition|)
name|FAIL
argument_list|(
literal|"no atom"
argument_list|)
expr_stmt|;
name|have_atom
operator|=
name|ISC_FALSE
expr_stmt|;
name|empty_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_FALSE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|was_multiple
condition|)
name|FAIL
argument_list|(
literal|"was multiple"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_atom
condition|)
name|FAIL
argument_list|(
literal|"no atom"
argument_list|)
expr_stmt|;
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
default|default:
name|literal
label|:
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|was_multiple
operator|=
name|ISC_FALSE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|parse_bound
case|:
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|!
name|seen_comma
condition|)
block|{
name|low
operator|=
name|low
operator|*
literal|10
operator|+
operator|*
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|low
operator|>
literal|255
condition|)
name|FAIL
argument_list|(
literal|"lower bound too big"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seen_high
operator|=
name|ISC_TRUE
expr_stmt|;
name|high
operator|=
name|high
operator|*
literal|10
operator|+
operator|*
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|high
operator|>
literal|255
condition|)
name|FAIL
argument_list|(
literal|"upper bound too big"
argument_list|)
expr_stmt|;
block|}
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|seen_comma
condition|)
name|FAIL
argument_list|(
literal|"multiple commas"
argument_list|)
expr_stmt|;
name|seen_comma
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
default|default:
case|case
literal|'{'
case|:
name|FAIL
argument_list|(
literal|"non digit/comma"
argument_list|)
expr_stmt|;
case|case
literal|'}'
case|:
if|if
condition|(
name|seen_high
operator|&&
name|low
operator|>
name|high
condition|)
name|FAIL
argument_list|(
literal|"bad parse bound"
argument_list|)
expr_stmt|;
name|seen_comma
operator|=
name|ISC_FALSE
expr_stmt|;
name|state
operator|=
name|none
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|parse_bracket
case|:
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'^'
case|:
if|if
condition|(
name|seen_char
operator|||
name|neg
condition|)
goto|goto
name|inside
goto|;
name|neg
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|range
operator|==
literal|2
condition|)
goto|goto
name|inside
goto|;
if|if
condition|(
operator|!
name|seen_char
condition|)
goto|goto
name|inside
goto|;
if|if
condition|(
name|range
operator|==
literal|1
condition|)
name|FAIL
argument_list|(
literal|"bad range"
argument_list|)
expr_stmt|;
name|range
operator|=
literal|2
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
case|case
literal|'['
case|:
operator|++
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* collating element */
if|if
condition|(
name|range
operator|!=
literal|0
condition|)
operator|--
name|range
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|state
operator|=
name|parse_ce
expr_stmt|;
name|seen_ce
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* equivalence class */
if|if
condition|(
name|range
operator|==
literal|2
condition|)
name|FAIL
argument_list|(
literal|"equivalence class in range"
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|state
operator|=
name|parse_ec
expr_stmt|;
name|seen_ec
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* character class */
if|if
condition|(
name|range
operator|==
literal|2
condition|)
name|FAIL
argument_list|(
literal|"character class in range"
argument_list|)
expr_stmt|;
name|ccname
operator|=
name|c
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|state
operator|=
name|parse_cc
expr_stmt|;
break|break;
block|}
name|seen_char
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
operator|!
name|c
index|[
literal|1
index|]
operator|&&
operator|!
name|seen_char
condition|)
name|FAIL
argument_list|(
literal|"unfinished brace"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seen_char
condition|)
goto|goto
name|inside
goto|;
operator|++
name|c
expr_stmt|;
name|range
operator|=
literal|0
expr_stmt|;
name|have_atom
operator|=
name|ISC_TRUE
expr_stmt|;
name|state
operator|=
name|none
expr_stmt|;
break|break;
default|default:
name|inside
label|:
name|seen_char
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|range
operator|==
literal|2
operator|&&
operator|(
operator|*
name|c
operator|&
literal|0xff
operator|)
operator|<
name|range_start
condition|)
name|FAIL
argument_list|(
literal|"out of order range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|!=
literal|0
condition|)
operator|--
name|range
expr_stmt|;
name|range_start
operator|=
operator|*
name|c
operator|&
literal|0xff
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
empty_stmt|;
break|break;
case|case
name|parse_ce
case|:
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'.'
case|:
operator|++
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
operator|!
name|seen_ce
condition|)
name|FAIL
argument_list|(
literal|"empty ce"
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|state
operator|=
name|parse_bracket
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|seen_ce
condition|)
name|range_start
operator|=
literal|256
expr_stmt|;
else|else
name|range_start
operator|=
literal|'.'
expr_stmt|;
name|seen_ce
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|seen_ce
condition|)
name|range_start
operator|=
literal|256
expr_stmt|;
else|else
name|range_start
operator|=
operator|*
name|c
expr_stmt|;
name|seen_ce
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|parse_ec
case|:
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'='
case|:
operator|++
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
operator|!
name|seen_ec
condition|)
name|FAIL
argument_list|(
literal|"no ec"
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|state
operator|=
name|parse_bracket
expr_stmt|;
break|break;
default|default:
name|seen_ec
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|seen_ec
operator|=
name|ISC_TRUE
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|parse_cc
case|:
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|':'
case|:
operator|++
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|']'
case|:
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|found
init|=
name|ISC_FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|cc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|cc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|c
operator|-
name|ccname
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|cc
index|[
name|i
index|]
argument_list|,
name|ccname
argument_list|,
name|len
argument_list|)
condition|)
continue|continue;
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|FAIL
argument_list|(
literal|"unknown cc"
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|state
operator|=
name|parse_bracket
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
break|break;
default|default:
operator|++
name|c
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|group
operator|!=
literal|0
condition|)
name|FAIL
argument_list|(
literal|"group open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|none
condition|)
name|FAIL
argument_list|(
literal|"incomplete"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_atom
condition|)
name|FAIL
argument_list|(
literal|"no atom"
argument_list|)
expr_stmt|;
return|return
operator|(
name|sub
operator|)
return|;
name|error
label|:
if|#
directive|if
name|VALREGEX_REPORT_REASON
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

