begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2007, 2009, 2011  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: log.c,v 1.94.332.7 2011-03-12 04:57:28 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file  * \author  Principal Authors: DCL */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* dev_t FreeBSD 2.1 */
end_comment

begin_include
include|#
directive|include
file|<isc/dir.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/stat.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_define
define|#
directive|define
name|LCTX_MAGIC
value|ISC_MAGIC('L', 'c', 't', 'x')
end_define

begin_define
define|#
directive|define
name|VALID_CONTEXT
parameter_list|(
name|lctx
parameter_list|)
value|ISC_MAGIC_VALID(lctx, LCTX_MAGIC)
end_define

begin_define
define|#
directive|define
name|LCFG_MAGIC
value|ISC_MAGIC('L', 'c', 'f', 'g')
end_define

begin_define
define|#
directive|define
name|VALID_CONFIG
parameter_list|(
name|lcfg
parameter_list|)
value|ISC_MAGIC_VALID(lcfg, LCFG_MAGIC)
end_define

begin_comment
comment|/*  * XXXDCL make dynamic?  */
end_comment

begin_define
define|#
directive|define
name|LOG_BUFFER_SIZE
value|(8 * 1024)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|PATH_MAX
value|1024
end_define

begin_comment
comment|/* AIX and others don't define this. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!  * This is the structure that holds each named channel.  A simple linked  * list chains all of the channels together, so an individual channel is  * found by doing strcmp()s with the names down the list.  Their should  * be no performance penalty from this as it is expected that the number  * of named channels will be no more than a dozen or so, and name lookups  * from the head of the list are only done when isc_log_usechannel() is  * called, which should also be very infrequent.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|isc_logchannel
name|isc_logchannel_t
typedef|;
end_typedef

begin_struct
struct|struct
name|isc_logchannel
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|int
name|level
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_logdestination_t
name|destination
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|isc_logchannel_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*!  * The logchannellist structure associates categories and modules with  * channels.  First the appropriate channellist is found based on the  * category, and then each structure in the linked list is checked for  * a matching module.  It is expected that the number of channels  * associated with any given category will be very short, no more than  * three or four in the more unusual cases.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|isc_logchannellist
name|isc_logchannellist_t
typedef|;
end_typedef

begin_struct
struct|struct
name|isc_logchannellist
block|{
specifier|const
name|isc_logmodule_t
modifier|*
name|module
decl_stmt|;
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|isc_logchannellist_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*!  * This structure is used to remember messages for pruning via  * isc_log_[v]write1().  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|isc_logmessage
name|isc_logmessage_t
typedef|;
end_typedef

begin_struct
struct|struct
name|isc_logmessage
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|isc_time_t
name|time
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|isc_logmessage_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*!  * The isc_logconfig structure is used to store the configurable information  * about where messages are actually supposed to be sent -- the information  * that could changed based on some configuration file, as opposed to the  * the category/module specification of isc_log_[v]write[1] that is compiled  * into a program, or the debug_level which is dynamic state information.  */
end_comment

begin_struct
struct|struct
name|isc_logconfig
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_log_t
modifier|*
name|lctx
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_logchannel_t
argument_list|)
name|channels
expr_stmt|;
name|ISC_LIST
argument_list|(
name|isc_logchannellist_t
argument_list|)
operator|*
name|channellists
expr_stmt|;
name|unsigned
name|int
name|channellist_count
decl_stmt|;
name|unsigned
name|int
name|duplicate_interval
decl_stmt|;
name|int
name|highest_level
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|isc_boolean_t
name|dynamic
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*!  * This isc_log structure provides the context for the isc_log functions.  * The log context locks itself in isc_log_doit, the internal backend to  * isc_log_write.  The locking is necessary both to provide exclusive access  * to the buffer into which the message is formatted and to guard against  * competing threads trying to write to the same syslog resource.  (On  * some systems, such as BSD/OS, stdio is thread safe but syslog is not.)  * Unfortunately, the lock cannot guard against a _different_ logging  * context in the same program competing for syslog's attention.  Thus  * There Can Be Only One, but this is not enforced.  * XXXDCL enforce it?  *  * Note that the category and module information is not locked.  * This is because in the usual case, only one isc_log_t is ever created  * in a program, and the category/module registration happens only once.  * XXXDCL it might be wise to add more locking overall.  */
end_comment

begin_struct
struct|struct
name|isc_log
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_logcategory_t
modifier|*
name|categories
decl_stmt|;
name|unsigned
name|int
name|category_count
decl_stmt|;
name|isc_logmodule_t
modifier|*
name|modules
decl_stmt|;
name|unsigned
name|int
name|module_count
decl_stmt|;
name|int
name|debug_level
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by isc_log lock. */
name|isc_logconfig_t
modifier|*
name|logconfig
decl_stmt|;
name|char
name|buffer
index|[
name|LOG_BUFFER_SIZE
index|]
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_logmessage_t
argument_list|)
name|messages
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*!  * Used when ISC_LOG_PRINTLEVEL is enabled for a channel.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|log_level_strings
index|[]
init|=
block|{
literal|"debug"
block|,
literal|"info"
block|,
literal|"notice"
block|,
literal|"warning"
block|,
literal|"error"
block|,
literal|"critical"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!  * Used to convert ISC_LOG_* priorities into syslog priorities.  * XXXDCL This will need modification for NT.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|syslog_map
index|[]
init|=
block|{
name|LOG_DEBUG
block|,
name|LOG_INFO
block|,
name|LOG_NOTICE
block|,
name|LOG_WARNING
block|,
name|LOG_ERR
block|,
name|LOG_CRIT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!  * When adding new categories, a corresponding ISC_LOGCATEGORY_foo  * definition needs to be added to<isc/log.h>.  *  * The default category is provided so that the internal default can  * be overridden.  Since the default is always looked up as the first  * channellist in the log context, it must come first in isc_categories[].  */
end_comment

begin_decl_stmt
name|LIBISC_EXTERNAL_DATA
name|isc_logcategory_t
name|isc_categories
index|[]
init|=
block|{
block|{
literal|"default"
block|,
literal|0
block|}
block|,
comment|/* "default" must come first. */
block|{
literal|"general"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!  * See above comment for categories on LIBISC_EXTERNAL_DATA, and apply it to modules.  */
end_comment

begin_decl_stmt
name|LIBISC_EXTERNAL_DATA
name|isc_logmodule_t
name|isc_modules
index|[]
init|=
block|{
block|{
literal|"socket"
block|,
literal|0
block|}
block|,
block|{
literal|"time"
block|,
literal|0
block|}
block|,
block|{
literal|"interface"
block|,
literal|0
block|}
block|,
block|{
literal|"timer"
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!  * This essentially constant structure must be filled in at run time,  * because its channel member is pointed to a channel that is created  * dynamically with isc_log_createchannel.  */
end_comment

begin_decl_stmt
specifier|static
name|isc_logchannellist_t
name|default_channel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!  * libisc logs to this context.  */
end_comment

begin_decl_stmt
name|LIBISC_EXTERNAL_DATA
name|isc_log_t
modifier|*
name|isc_lctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!  * Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|assignchannel
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|,
name|unsigned
name|int
name|category_id
parameter_list|,
specifier|const
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|sync_channellist
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|greatest_version
parameter_list|(
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|,
name|int
modifier|*
name|greatest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|roll_log
parameter_list|(
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isc_log_doit
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_boolean_t
name|write_once
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|9
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*!  * Convenience macros.  */
end_comment

begin_define
define|#
directive|define
name|FACILITY
parameter_list|(
name|channel
parameter_list|)
value|(channel->destination.facility)
end_define

begin_define
define|#
directive|define
name|FILE_NAME
parameter_list|(
name|channel
parameter_list|)
value|(channel->destination.file.name)
end_define

begin_define
define|#
directive|define
name|FILE_STREAM
parameter_list|(
name|channel
parameter_list|)
value|(channel->destination.file.stream)
end_define

begin_define
define|#
directive|define
name|FILE_VERSIONS
parameter_list|(
name|channel
parameter_list|)
value|(channel->destination.file.versions)
end_define

begin_define
define|#
directive|define
name|FILE_MAXSIZE
parameter_list|(
name|channel
parameter_list|)
value|(channel->destination.file.maximum_size)
end_define

begin_define
define|#
directive|define
name|FILE_MAXREACHED
parameter_list|(
name|channel
parameter_list|)
value|(channel->destination.file.maximum_reached)
end_define

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/****  **** Public interfaces.  ****/
end_comment

begin_comment
comment|/*  * Establish a new logging context, with default channels.  */
end_comment

begin_function
name|isc_result_t
name|isc_log_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_log_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_logconfig_t
modifier|*
modifier|*
name|lcfgp
parameter_list|)
block|{
name|isc_log_t
modifier|*
name|lctx
decl_stmt|;
name|isc_logconfig_t
modifier|*
name|lcfg
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|lctxp
operator|!=
name|NULL
operator|&&
operator|*
name|lctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|lcfgp
operator|==
name|NULL
operator|||
operator|*
name|lcfgp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|!=
name|NULL
condition|)
block|{
name|lctx
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|lctx
operator|->
name|categories
operator|=
name|NULL
expr_stmt|;
name|lctx
operator|->
name|category_count
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|modules
operator|=
name|NULL
expr_stmt|;
name|lctx
operator|->
name|module_count
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|debug_level
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|lctx
operator|->
name|messages
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 		 * Normally setting the magic number is the last step done 		 * in a creation function, but a valid log context is needed 		 * by isc_log_registercategories and isc_logconfig_create. 		 * If either fails, the lctx is destroyed and not returned 		 * to the caller. 		 */
name|lctx
operator|->
name|magic
operator|=
name|LCTX_MAGIC
expr_stmt|;
name|isc_log_registercategories
argument_list|(
name|lctx
argument_list|,
name|isc_categories
argument_list|)
expr_stmt|;
name|isc_log_registermodules
argument_list|(
name|lctx
argument_list|,
name|isc_modules
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_logconfig_create
argument_list|(
name|lctx
argument_list|,
operator|&
name|lcfg
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|sync_channellist
argument_list|(
name|lcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|lctx
operator|->
name|logconfig
operator|=
name|lcfg
expr_stmt|;
operator|*
name|lctxp
operator|=
name|lctx
expr_stmt|;
if|if
condition|(
name|lcfgp
operator|!=
name|NULL
condition|)
operator|*
name|lcfgp
operator|=
name|lcfg
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lcfg
operator|!=
name|NULL
condition|)
name|isc_logconfig_destroy
argument_list|(
operator|&
name|lcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|!=
name|NULL
condition|)
name|isc_log_destroy
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_logconfig_create
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logconfig_t
modifier|*
modifier|*
name|lcfgp
parameter_list|)
block|{
name|isc_logconfig_t
modifier|*
name|lcfg
decl_stmt|;
name|isc_logdestination_t
name|destination
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_INFO
decl_stmt|;
name|REQUIRE
argument_list|(
name|lcfgp
operator|!=
name|NULL
operator|&&
operator|*
name|lcfgp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|lcfg
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcfg
operator|!=
name|NULL
condition|)
block|{
name|lcfg
operator|->
name|lctx
operator|=
name|lctx
expr_stmt|;
name|lcfg
operator|->
name|channellists
operator|=
name|NULL
expr_stmt|;
name|lcfg
operator|->
name|channellist_count
operator|=
literal|0
expr_stmt|;
name|lcfg
operator|->
name|duplicate_interval
operator|=
literal|0
expr_stmt|;
name|lcfg
operator|->
name|highest_level
operator|=
name|level
expr_stmt|;
name|lcfg
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|lcfg
operator|->
name|dynamic
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|lcfg
operator|->
name|channels
argument_list|)
expr_stmt|;
comment|/* 		 * Normally the magic number is the last thing set in the 		 * structure, but isc_log_createchannel() needs a valid 		 * config.  If the channel creation fails, the lcfg is not 		 * returned to the caller. 		 */
name|lcfg
operator|->
name|magic
operator|=
name|LCFG_MAGIC
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
comment|/* 	 * Create the default channels: 	 *   	default_syslog, default_stderr, default_debug and null. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|destination
operator|.
name|facility
operator|=
name|LOG_DAEMON
expr_stmt|;
name|result
operator|=
name|isc_log_createchannel
argument_list|(
name|lcfg
argument_list|,
literal|"default_syslog"
argument_list|,
name|ISC_LOG_TOSYSLOG
argument_list|,
name|level
argument_list|,
operator|&
name|destination
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|destination
operator|.
name|file
operator|.
name|stream
operator|=
name|stderr
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|versions
operator|=
name|ISC_LOG_ROLLNEVER
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|maximum_size
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|isc_log_createchannel
argument_list|(
name|lcfg
argument_list|,
literal|"default_stderr"
argument_list|,
name|ISC_LOG_TOFILEDESC
argument_list|,
name|level
argument_list|,
operator|&
name|destination
argument_list|,
name|ISC_LOG_PRINTTIME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Set the default category's channel to default_stderr, 		 * which is at the head of the channels list because it was 		 * just created. 		 */
name|default_channel
operator|.
name|channel
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channels
argument_list|)
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|stream
operator|=
name|stderr
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|versions
operator|=
name|ISC_LOG_ROLLNEVER
expr_stmt|;
name|destination
operator|.
name|file
operator|.
name|maximum_size
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|isc_log_createchannel
argument_list|(
name|lcfg
argument_list|,
literal|"default_debug"
argument_list|,
name|ISC_LOG_TOFILEDESC
argument_list|,
name|ISC_LOG_DYNAMIC
argument_list|,
operator|&
name|destination
argument_list|,
name|ISC_LOG_PRINTTIME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|isc_log_createchannel
argument_list|(
name|lcfg
argument_list|,
literal|"null"
argument_list|,
name|ISC_LOG_TONULL
argument_list|,
name|ISC_LOG_DYNAMIC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|*
name|lcfgp
operator|=
name|lcfg
expr_stmt|;
elseif|else
if|if
condition|(
name|lcfg
operator|!=
name|NULL
condition|)
name|isc_logconfig_destroy
argument_list|(
operator|&
name|lcfg
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_logconfig_t
modifier|*
name|isc_logconfig_get
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|lctx
operator|->
name|logconfig
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|->
name|logconfig
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_logconfig_use
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|)
block|{
name|isc_logconfig_t
modifier|*
name|old_cfg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|lcfg
operator|->
name|lctx
operator|==
name|lctx
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that lcfg->channellist_count == lctx->category_count. 	 * They won't be equal if isc_log_usechannel has not been called 	 * since any call to isc_log_registercategories. 	 */
name|result
operator|=
name|sync_channellist
argument_list|(
name|lcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|old_cfg
operator|=
name|lctx
operator|->
name|logconfig
expr_stmt|;
name|lctx
operator|->
name|logconfig
operator|=
name|lcfg
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_logconfig_destroy
argument_list|(
operator|&
name|old_cfg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_log_destroy
parameter_list|(
name|isc_log_t
modifier|*
modifier|*
name|lctxp
parameter_list|)
block|{
name|isc_log_t
modifier|*
name|lctx
decl_stmt|;
name|isc_logconfig_t
modifier|*
name|lcfg
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_logmessage_t
modifier|*
name|message
decl_stmt|;
name|REQUIRE
argument_list|(
name|lctxp
operator|!=
name|NULL
operator|&&
name|VALID_CONTEXT
argument_list|(
operator|*
name|lctxp
argument_list|)
argument_list|)
expr_stmt|;
name|lctx
operator|=
operator|*
name|lctxp
expr_stmt|;
name|mctx
operator|=
name|lctx
operator|->
name|mctx
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|logconfig
operator|!=
name|NULL
condition|)
block|{
name|lcfg
operator|=
name|lctx
operator|->
name|logconfig
expr_stmt|;
name|lctx
operator|->
name|logconfig
operator|=
name|NULL
expr_stmt|;
name|isc_logconfig_destroy
argument_list|(
operator|&
name|lcfg
argument_list|)
expr_stmt|;
block|}
name|DESTROYLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|message
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lctx
operator|->
name|messages
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|lctx
operator|->
name|messages
argument_list|,
name|message
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|message
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|message
argument_list|)
operator|+
name|strlen
argument_list|(
name|message
operator|->
name|text
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|lctx
operator|->
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lctx
operator|->
name|debug_level
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|categories
operator|=
name|NULL
expr_stmt|;
name|lctx
operator|->
name|category_count
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|modules
operator|=
name|NULL
expr_stmt|;
name|lctx
operator|->
name|module_count
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|lctx
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_logconfig_destroy
parameter_list|(
name|isc_logconfig_t
modifier|*
modifier|*
name|lcfgp
parameter_list|)
block|{
name|isc_logconfig_t
modifier|*
name|lcfg
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|isc_logchannellist_t
modifier|*
name|item
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|lcfgp
operator|!=
name|NULL
operator|&&
name|VALID_CONFIG
argument_list|(
operator|*
name|lcfgp
argument_list|)
argument_list|)
expr_stmt|;
name|lcfg
operator|=
operator|*
name|lcfgp
expr_stmt|;
comment|/* 	 * This function cannot be called with a logconfig that is in 	 * use by a log context. 	 */
name|REQUIRE
argument_list|(
name|lcfg
operator|->
name|lctx
operator|!=
name|NULL
operator|&&
name|lcfg
operator|->
name|lctx
operator|->
name|logconfig
operator|!=
name|lcfg
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|lcfg
operator|->
name|lctx
operator|->
name|mctx
expr_stmt|;
while|while
condition|(
operator|(
name|channel
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channels
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|lcfg
operator|->
name|channels
argument_list|,
name|channel
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|ISC_LOG_TOFILE
condition|)
block|{
comment|/* 			 * The filename for the channel may have ultimately 			 * started its life in user-land as a const string, 			 * but in isc_log_createchannel it gets copied 			 * into writable memory and is not longer truly const. 			 */
name|DE_CONST
argument_list|(
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|channel
operator|->
name|name
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|channel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lcfg
operator|->
name|channellist_count
condition|;
name|i
operator|++
control|)
while|while
condition|(
operator|(
name|item
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channellists
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|lcfg
operator|->
name|channellists
index|[
name|i
index|]
argument_list|,
name|item
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lcfg
operator|->
name|channellist_count
operator|>
literal|0
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lcfg
operator|->
name|channellists
argument_list|,
name|lcfg
operator|->
name|channellist_count
operator|*
sizeof|sizeof
argument_list|(
name|ISC_LIST
argument_list|(
name|isc_logchannellist_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lcfg
operator|->
name|dynamic
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|lcfg
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|lcfg
operator|->
name|lctx
operator|->
name|mctx
argument_list|,
name|lcfg
operator|->
name|tag
argument_list|)
expr_stmt|;
name|lcfg
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|lcfg
operator|->
name|highest_level
operator|=
literal|0
expr_stmt|;
name|lcfg
operator|->
name|duplicate_interval
operator|=
literal|0
expr_stmt|;
name|lcfg
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lcfg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lcfgp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_registercategories
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
name|categories
index|[]
parameter_list|)
block|{
name|isc_logcategory_t
modifier|*
name|catp
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|categories
operator|!=
name|NULL
operator|&&
name|categories
index|[
literal|0
index|]
operator|.
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXXDCL This somewhat sleazy situation of using the last pointer 	 * in one category array to point to the next array exists because 	 * this registration function returns void and I didn't want to have 	 * change everything that used it by making it return an isc_result_t. 	 * It would need to do that if it had to allocate memory to store 	 * pointers to each array passed in. 	 */
if|if
condition|(
name|lctx
operator|->
name|categories
operator|==
name|NULL
condition|)
name|lctx
operator|->
name|categories
operator|=
name|categories
expr_stmt|;
else|else
block|{
comment|/* 		 * Adjust the last (NULL) pointer of the already registered 		 * categories to point to the incoming array. 		 */
for|for
control|(
name|catp
operator|=
name|lctx
operator|->
name|categories
init|;
name|catp
operator|->
name|name
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|catp
operator|->
name|id
operator|==
name|UINT_MAX
condition|)
comment|/* 				 * The name pointer points to the next array. 				 * Ick. 				 */
name|DE_CONST
argument_list|(
name|catp
operator|->
name|name
argument_list|,
name|catp
argument_list|)
expr_stmt|;
else|else
name|catp
operator|++
expr_stmt|;
name|catp
operator|->
name|name
operator|=
operator|(
name|void
operator|*
operator|)
name|categories
expr_stmt|;
name|catp
operator|->
name|id
operator|=
name|UINT_MAX
expr_stmt|;
block|}
comment|/* 	 * Update the id number of the category with its new global id. 	 */
for|for
control|(
name|catp
operator|=
name|categories
init|;
name|catp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|catp
operator|++
control|)
name|catp
operator|->
name|id
operator|=
name|lctx
operator|->
name|category_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|isc_logcategory_t
modifier|*
name|isc_log_categorybyname
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|isc_logcategory_t
modifier|*
name|catp
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|catp
operator|=
name|lctx
operator|->
name|categories
init|;
name|catp
operator|->
name|name
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|catp
operator|->
name|id
operator|==
name|UINT_MAX
condition|)
comment|/* 			 * catp is neither modified nor returned to the 			 * caller, so removing its const qualifier is ok. 			 */
name|DE_CONST
argument_list|(
name|catp
operator|->
name|name
argument_list|,
name|catp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|catp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|catp
operator|)
return|;
name|catp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_log_registermodules
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logmodule_t
name|modules
index|[]
parameter_list|)
block|{
name|isc_logmodule_t
modifier|*
name|modp
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|modules
operator|!=
name|NULL
operator|&&
name|modules
index|[
literal|0
index|]
operator|.
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXXDCL This somewhat sleazy situation of using the last pointer 	 * in one category array to point to the next array exists because 	 * this registration function returns void and I didn't want to have 	 * change everything that used it by making it return an isc_result_t. 	 * It would need to do that if it had to allocate memory to store 	 * pointers to each array passed in. 	 */
if|if
condition|(
name|lctx
operator|->
name|modules
operator|==
name|NULL
condition|)
name|lctx
operator|->
name|modules
operator|=
name|modules
expr_stmt|;
else|else
block|{
comment|/* 		 * Adjust the last (NULL) pointer of the already registered 		 * modules to point to the incoming array. 		 */
for|for
control|(
name|modp
operator|=
name|lctx
operator|->
name|modules
init|;
name|modp
operator|->
name|name
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|modp
operator|->
name|id
operator|==
name|UINT_MAX
condition|)
comment|/* 				 * The name pointer points to the next array. 				 * Ick. 				 */
name|DE_CONST
argument_list|(
name|modp
operator|->
name|name
argument_list|,
name|modp
argument_list|)
expr_stmt|;
else|else
name|modp
operator|++
expr_stmt|;
name|modp
operator|->
name|name
operator|=
operator|(
name|void
operator|*
operator|)
name|modules
expr_stmt|;
name|modp
operator|->
name|id
operator|=
name|UINT_MAX
expr_stmt|;
block|}
comment|/* 	 * Update the id number of the module with its new global id. 	 */
for|for
control|(
name|modp
operator|=
name|modules
init|;
name|modp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|modp
operator|++
control|)
name|modp
operator|->
name|id
operator|=
name|lctx
operator|->
name|module_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|isc_logmodule_t
modifier|*
name|isc_log_modulebyname
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|isc_logmodule_t
modifier|*
name|modp
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|modp
operator|=
name|lctx
operator|->
name|modules
init|;
name|modp
operator|->
name|name
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|modp
operator|->
name|id
operator|==
name|UINT_MAX
condition|)
comment|/* 			 * modp is neither modified nor returned to the 			 * caller, so removing its const qualifier is ok. 			 */
name|DE_CONST
argument_list|(
name|modp
operator|->
name|name
argument_list|,
name|modp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|modp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|modp
operator|)
return|;
name|modp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_log_createchannel
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|isc_logdestination_t
modifier|*
name|destination
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|==
name|ISC_LOG_TOSYSLOG
operator|||
name|type
operator|==
name|ISC_LOG_TOFILE
operator|||
name|type
operator|==
name|ISC_LOG_TOFILEDESC
operator|||
name|type
operator|==
name|ISC_LOG_TONULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|destination
operator|!=
name|NULL
operator|||
name|type
operator|==
name|ISC_LOG_TONULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|level
operator|>=
name|ISC_LOG_CRITICAL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|unsigned
name|int
operator|)
operator|~
operator|(
name|ISC_LOG_PRINTALL
operator||
name|ISC_LOG_DEBUGONLY
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXDCL find duplicate names? */
name|mctx
operator|=
name|lcfg
operator|->
name|lctx
operator|->
name|mctx
expr_stmt|;
name|channel
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|channel
operator|->
name|name
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|channel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|channel
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|channel
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|channel
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|channel
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ISC_LOG_TOSYSLOG
case|:
name|FACILITY
argument_list|(
name|channel
argument_list|)
operator|=
name|destination
operator|->
name|facility
expr_stmt|;
break|break;
case|case
name|ISC_LOG_TOFILE
case|:
comment|/* 		 * The file name is copied because greatest_version wants 		 * to scribble on it, so it needs to be definitely in 		 * writable memory. 		 */
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|destination
operator|->
name|file
operator|.
name|name
argument_list|)
expr_stmt|;
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|=
name|destination
operator|->
name|file
operator|.
name|versions
expr_stmt|;
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
operator|=
name|destination
operator|->
name|file
operator|.
name|maximum_size
expr_stmt|;
name|FILE_MAXREACHED
argument_list|(
name|channel
argument_list|)
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|ISC_LOG_TOFILEDESC
case|:
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|=
name|destination
operator|->
name|file
operator|.
name|stream
expr_stmt|;
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|=
name|ISC_LOG_ROLLNEVER
expr_stmt|;
break|break;
case|case
name|ISC_LOG_TONULL
case|:
comment|/* Nothing. */
break|break;
default|default:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|channel
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|channel
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|channel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|channel
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|ISC_LIST_PREPEND
argument_list|(
name|lcfg
operator|->
name|channels
argument_list|,
name|channel
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * If default_stderr was redefined, make the default category 	 * point to the new default_stderr. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"default_stderr"
argument_list|)
operator|==
literal|0
condition|)
name|default_channel
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_log_usechannel
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
specifier|const
name|isc_logmodule_t
modifier|*
name|module
parameter_list|)
block|{
name|isc_log_t
modifier|*
name|lctx
decl_stmt|;
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|lcfg
operator|->
name|lctx
expr_stmt|;
name|REQUIRE
argument_list|(
name|category
operator|==
name|NULL
operator|||
name|category
operator|->
name|id
operator|<
name|lctx
operator|->
name|category_count
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|module
operator|==
name|NULL
operator|||
name|module
operator|->
name|id
operator|<
name|lctx
operator|->
name|module_count
argument_list|)
expr_stmt|;
for|for
control|(
name|channel
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channels
argument_list|)
init|;
name|channel
operator|!=
name|NULL
condition|;
name|channel
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|channel
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|channel
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
name|category
operator|!=
name|NULL
condition|)
name|result
operator|=
name|assignchannel
argument_list|(
name|lcfg
argument_list|,
name|category
operator|->
name|id
argument_list|,
name|module
argument_list|,
name|channel
argument_list|)
expr_stmt|;
else|else
comment|/* 		 * Assign to all categories.  Note that this includes 		 * the default channel. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lctx
operator|->
name|category_count
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|assignchannel
argument_list|(
name|lcfg
argument_list|,
name|i
argument_list|,
name|module
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_log_write
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_vwrite
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_write1
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_vwrite1
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_iwrite
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_FALSE
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|msg
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_ivwrite
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_FALSE
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|msg
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_iwrite1
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_TRUE
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|msg
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_ivwrite1
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
comment|/* 	 * Contract checking is done in isc_log_doit(). 	 */
name|isc_log_doit
argument_list|(
name|lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|ISC_TRUE
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|msg
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_setcontext
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|)
block|{
name|isc_lctx
operator|=
name|lctx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_setdebuglevel
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|unsigned
name|int
name|level
parameter_list|)
block|{
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|debug_level
operator|=
name|level
expr_stmt|;
comment|/* 	 * Close ISC_LOG_DEBUGONLY channels if level is zero. 	 */
if|if
condition|(
name|lctx
operator|->
name|debug_level
operator|==
literal|0
condition|)
for|for
control|(
name|channel
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lctx
operator|->
name|logconfig
operator|->
name|channels
argument_list|)
init|;
name|channel
operator|!=
name|NULL
condition|;
name|channel
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|channel
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|ISC_LOG_TOFILE
operator|&&
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_DEBUGONLY
operator|)
operator|!=
literal|0
operator|&&
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_log_getdebuglevel
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|->
name|debug_level
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_log_setduplicateinterval
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|,
name|unsigned
name|int
name|interval
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
name|lcfg
operator|->
name|duplicate_interval
operator|=
name|interval
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_log_getduplicateinterval
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lcfg
operator|->
name|duplicate_interval
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_log_settag
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|&&
operator|*
name|tag
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|lcfg
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|lcfg
operator|->
name|lctx
operator|->
name|mctx
argument_list|,
name|lcfg
operator|->
name|tag
argument_list|)
expr_stmt|;
name|lcfg
operator|->
name|tag
operator|=
name|isc_mem_strdup
argument_list|(
name|lcfg
operator|->
name|lctx
operator|->
name|mctx
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcfg
operator|->
name|tag
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|lcfg
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|lcfg
operator|->
name|lctx
operator|->
name|mctx
argument_list|,
name|lcfg
operator|->
name|tag
argument_list|)
expr_stmt|;
name|lcfg
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|isc_log_gettag
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lcfg
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXXDCL NT  -- This interface will assuredly be changing. */
end_comment

begin_function
name|void
name|isc_log_opensyslog
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|options
parameter_list|,
name|int
name|facility
parameter_list|)
block|{
operator|(
name|void
operator|)
name|openlog
argument_list|(
name|tag
argument_list|,
name|options
argument_list|,
name|facility
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_log_closefilelogs
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|)
block|{
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|channel
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lctx
operator|->
name|logconfig
operator|->
name|channels
argument_list|)
init|;
name|channel
operator|!=
name|NULL
condition|;
name|channel
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|channel
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|ISC_LOG_TOFILE
operator|&&
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****  **** Internal functions  ****/
end_comment

begin_function
specifier|static
name|isc_result_t
name|assignchannel
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|,
name|unsigned
name|int
name|category_id
parameter_list|,
specifier|const
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|)
block|{
name|isc_logchannellist_t
modifier|*
name|new_item
decl_stmt|;
name|isc_log_t
modifier|*
name|lctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|lcfg
operator|->
name|lctx
expr_stmt|;
name|REQUIRE
argument_list|(
name|category_id
operator|<
name|lctx
operator|->
name|category_count
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|module
operator|==
name|NULL
operator|||
name|module
operator|->
name|id
operator|<
name|lctx
operator|->
name|module_count
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|channel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure lcfg->channellist_count == lctx->category_count. 	 */
name|result
operator|=
name|sync_channellist
argument_list|(
name|lcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|new_item
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_item
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|new_item
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|new_item
operator|->
name|module
operator|=
name|module
expr_stmt|;
name|ISC_LIST_INITANDPREPEND
argument_list|(
name|lcfg
operator|->
name|channellists
index|[
name|category_id
index|]
argument_list|,
name|new_item
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Remember the highest logging level set by any channel in the 	 * logging config, so isc_log_doit() can quickly return if the 	 * message is too high to be logged by any channel. 	 */
if|if
condition|(
name|channel
operator|->
name|type
operator|!=
name|ISC_LOG_TONULL
condition|)
block|{
if|if
condition|(
name|lcfg
operator|->
name|highest_level
operator|<
name|channel
operator|->
name|level
condition|)
name|lcfg
operator|->
name|highest_level
operator|=
name|channel
operator|->
name|level
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|level
operator|==
name|ISC_LOG_DYNAMIC
condition|)
name|lcfg
operator|->
name|dynamic
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This would ideally be part of isc_log_registercategories(), except then  * that function would have to return isc_result_t instead of void.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|sync_channellist
parameter_list|(
name|isc_logconfig_t
modifier|*
name|lcfg
parameter_list|)
block|{
name|unsigned
name|int
name|bytes
decl_stmt|;
name|isc_log_t
modifier|*
name|lctx
decl_stmt|;
name|void
modifier|*
name|lists
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONFIG
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|lcfg
operator|->
name|lctx
expr_stmt|;
name|REQUIRE
argument_list|(
name|lctx
operator|->
name|category_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|category_count
operator|==
name|lcfg
operator|->
name|channellist_count
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|bytes
operator|=
name|lctx
operator|->
name|category_count
operator|*
sizeof|sizeof
argument_list|(
name|ISC_LIST
argument_list|(
name|isc_logchannellist_t
argument_list|)
argument_list|)
expr_stmt|;
name|lists
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lists
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|lists
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcfg
operator|->
name|channellist_count
operator|!=
literal|0
condition|)
block|{
name|bytes
operator|=
name|lcfg
operator|->
name|channellist_count
operator|*
sizeof|sizeof
argument_list|(
name|ISC_LIST
argument_list|(
name|isc_logchannellist_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lists
argument_list|,
name|lcfg
operator|->
name|channellists
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|lcfg
operator|->
name|channellists
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|lcfg
operator|->
name|channellists
operator|=
name|lists
expr_stmt|;
name|lcfg
operator|->
name|channellist_count
operator|=
name|lctx
operator|->
name|category_count
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|greatest_version
parameter_list|(
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|,
name|int
modifier|*
name|greatestp
parameter_list|)
block|{
comment|/* XXXDCL HIGHLY NT */
name|char
modifier|*
name|basename
decl_stmt|,
modifier|*
name|digit_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
name|int
name|version
decl_stmt|,
name|greatest
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|basenamelen
decl_stmt|;
name|isc_dir_t
name|dir
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|sep
init|=
literal|'/'
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|char
modifier|*
name|basename2
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|channel
operator|->
name|type
operator|==
name|ISC_LOG_TOFILE
argument_list|)
expr_stmt|;
comment|/* 	 * It is safe to DE_CONST the file.name because it was copied 	 * with isc_mem_strdup in isc_log_createchannel. 	 */
name|basename
operator|=
name|strrchr
argument_list|(
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|basename2
operator|=
name|strrchr
argument_list|(
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|basename
operator|!=
name|NULL
operator|&&
name|basename2
operator|!=
name|NULL
operator|&&
name|basename2
operator|>
name|basename
operator|)
operator|||
operator|(
name|basename
operator|==
name|NULL
operator|&&
name|basename2
operator|!=
name|NULL
operator|)
condition|)
block|{
name|basename
operator|=
name|basename2
expr_stmt|;
name|sep
operator|=
literal|'\\'
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|basename
operator|!=
name|NULL
condition|)
block|{
operator|*
name|basename
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|dirname
operator|=
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DE_CONST
argument_list|(
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|dirname
operator|=
literal|"."
expr_stmt|;
block|}
name|basenamelen
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|isc_dir_init
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_dir_open
argument_list|(
operator|&
name|dir
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the file separator if it was taken out. 	 */
if|if
condition|(
name|basename
operator|!=
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
condition|)
operator|*
operator|(
name|basename
operator|-
literal|1
operator|)
operator|=
name|sep
expr_stmt|;
comment|/* 	 * Return if the directory open failed. 	 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
while|while
condition|(
name|isc_dir_read
argument_list|(
operator|&
name|dir
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|entry
operator|.
name|length
operator|>
name|basenamelen
operator|&&
name|strncmp
argument_list|(
name|dir
operator|.
name|entry
operator|.
name|name
argument_list|,
name|basename
argument_list|,
name|basenamelen
argument_list|)
operator|==
literal|0
operator|&&
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|basenamelen
index|]
operator|==
literal|'.'
condition|)
block|{
name|version
operator|=
name|strtol
argument_list|(
operator|&
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|basenamelen
operator|+
literal|1
index|]
argument_list|,
operator|&
name|digit_end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|digit_end
operator|==
literal|'\0'
operator|&&
name|version
operator|>
name|greatest
condition|)
name|greatest
operator|=
name|version
expr_stmt|;
block|}
block|}
name|isc_dir_close
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
operator|*
name|greatestp
operator|=
operator|++
name|greatest
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|roll_log
parameter_list|(
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|greatest
decl_stmt|;
name|char
name|current
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|new
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Do nothing (not even excess version trimming) if ISC_LOG_ROLLNEVER 	 * is specified.  Apparently complete external control over the log 	 * files is desired. 	 */
if|if
condition|(
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|==
name|ISC_LOG_ROLLNEVER
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|path
operator|=
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
expr_stmt|;
comment|/* 	 * Set greatest_version to the greatest existing version 	 * (not the maximum requested version).  This is 1 based even 	 * though the file names are 0 based, so an oldest log of log.1 	 * is a greatest_version of 2. 	 */
name|result
operator|=
name|greatest_version
argument_list|(
name|channel
argument_list|,
operator|&
name|greatest
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Now greatest should be set to the highest version number desired. 	 * Since the highest number is one less than FILE_VERSIONS(channel) 	 * when not doing infinite log rolling, greatest will need to be 	 * decremented when it is equal to -- or greater than -- 	 * FILE_VERSIONS(channel).  When greatest is less than 	 * FILE_VERSIONS(channel), it is already suitable for use as 	 * the maximum version number. 	 */
if|if
condition|(
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|==
name|ISC_LOG_ROLLINFINITE
operator|||
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|>
name|greatest
condition|)
empty_stmt|;
comment|/* Do nothing. */
else|else
comment|/* 		 * When greatest is>= FILE_VERSIONS(channel), it needs to 		 * be reduced until it is FILE_VERSIONS(channel) - 1. 		 * Remove any excess logs on the way to that value. 		 */
while|while
condition|(
operator|--
name|greatest
operator|>=
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
condition|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|current
argument_list|,
sizeof|sizeof
argument_list|(
name|current
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|path
argument_list|,
name|greatest
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|current
argument_list|)
operator|||
name|n
operator|<
literal|0
condition|)
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
else|else
name|result
operator|=
name|isc_file_remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_FILENOTFOUND
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to remove log file '%s.%d': %s"
argument_list|,
name|path
argument_list|,
name|greatest
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|greatest
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|current
argument_list|,
sizeof|sizeof
argument_list|(
name|current
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|path
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|current
argument_list|)
operator|||
name|n
operator|<
literal|0
condition|)
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|path
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|new
argument_list|)
operator|||
name|n
operator|<
literal|0
condition|)
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|isc_file_rename
argument_list|(
name|current
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_FILENOTFOUND
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to rename log file '%s.%d' to "
literal|"'%s.%d': %s"
argument_list|,
name|path
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|path
argument_list|,
name|i
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|,
literal|"%s.0"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|new
argument_list|)
operator|||
name|n
operator|<
literal|0
condition|)
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
else|else
name|result
operator|=
name|isc_file_rename
argument_list|(
name|path
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_FILENOTFOUND
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to rename log file '%s' to '%s.0': %s"
argument_list|,
name|path
argument_list|,
name|path
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|isc_file_remove
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_FILENOTFOUND
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to remove log file '%s': %s"
argument_list|,
name|path
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|isc_log_open
parameter_list|(
name|isc_logchannel_t
modifier|*
name|channel
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|isc_boolean_t
name|regular_file
decl_stmt|;
name|isc_boolean_t
name|roll
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|REQUIRE
argument_list|(
name|channel
operator|->
name|type
operator|==
name|ISC_LOG_TOFILE
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|path
operator|=
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|path
operator|!=
name|NULL
operator|&&
operator|*
name|path
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* 	 * Determine type of file; only regular files will be 	 * version renamed, and only if the base file exists 	 * and either has no size limit or has reached its size limit. 	 */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|regular_file
operator|=
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
expr_stmt|;
comment|/* XXXDCL if not regular_file complain? */
if|if
condition|(
operator|(
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
operator|==
literal|0
operator|&&
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|!=
name|ISC_LOG_ROLLNEVER
operator|)
operator|||
operator|(
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
operator|>
literal|0
operator|&&
name|statbuf
operator|.
name|st_size
operator|>=
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
operator|)
condition|)
name|roll
operator|=
name|regular_file
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|regular_file
operator|=
name|ISC_TRUE
expr_stmt|;
name|POST
argument_list|(
name|regular_file
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_INVALIDFILE
expr_stmt|;
comment|/* 	 * Version control. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|roll
condition|)
block|{
if|if
condition|(
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|==
name|ISC_LOG_ROLLNEVER
condition|)
return|return
operator|(
name|ISC_R_MAXSIZE
operator|)
return|;
name|result
operator|=
name|roll_log
argument_list|(
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_OPENERR
operator|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"isc_log_open: roll_log '%s' "
literal|"failed: %s"
argument_list|,
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|channel
operator|->
name|flags
operator||=
name|ISC_LOG_OPENERR
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|path
argument_list|,
literal|"a"
argument_list|,
operator|&
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|isc_log_wouldlog
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|int
name|level
parameter_list|)
block|{
comment|/* 	 * Try to avoid locking the mutex for messages which can't 	 * possibly be logged to any channels -- primarily debugging 	 * messages that the debug level is not high enough to print. 	 * 	 * If the level is (mathematically) less than or equal to the 	 * highest_level, or if there is a dynamic channel and the level is 	 * less than or equal to the debug level, the main loop must be 	 * entered to see if the message should really be output. 	 * 	 * NOTE: this is UNLOCKED access to the logconfig.  However, 	 * the worst thing that can happen is that a bad decision is made 	 * about returning without logging, and that's not a big concern, 	 * because that's a risk anyway if the logconfig is being 	 * dynamically changed. 	 */
if|if
condition|(
name|lctx
operator|==
name|NULL
operator|||
name|lctx
operator|->
name|logconfig
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|level
operator|<=
name|lctx
operator|->
name|logconfig
operator|->
name|highest_level
operator|||
operator|(
name|lctx
operator|->
name|logconfig
operator|->
name|dynamic
operator|&&
name|level
operator|<=
name|lctx
operator|->
name|debug_level
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isc_log_doit
parameter_list|(
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_boolean_t
name|write_once
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|int
name|syslog_level
decl_stmt|;
name|char
name|time_string
index|[
literal|64
index|]
decl_stmt|;
name|char
name|level_string
index|[
literal|24
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|iformat
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|isc_boolean_t
name|matched
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|printtime
decl_stmt|,
name|printtag
decl_stmt|;
name|isc_boolean_t
name|printcategory
decl_stmt|,
name|printmodule
decl_stmt|,
name|printlevel
decl_stmt|;
name|isc_logconfig_t
modifier|*
name|lcfg
decl_stmt|;
name|isc_logchannel_t
modifier|*
name|channel
decl_stmt|;
name|isc_logchannellist_t
modifier|*
name|category_channels
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|lctx
operator|==
name|NULL
operator|||
name|VALID_CONTEXT
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|category
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|module
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|level
operator|!=
name|ISC_LOG_DYNAMIC
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|format
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Programs can use libraries that use this logging code without 	 * wanting to do any logging, thus the log context is allowed to 	 * be non-existent. 	 */
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return;
name|REQUIRE
argument_list|(
name|category
operator|->
name|id
operator|<
name|lctx
operator|->
name|category_count
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|module
operator|->
name|id
operator|<
name|lctx
operator|->
name|module_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
if|if
condition|(
name|msgcat
operator|!=
name|NULL
condition|)
name|iformat
operator|=
name|isc_msgcat_get
argument_list|(
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|msg
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|else
name|iformat
operator|=
name|format
expr_stmt|;
name|time_string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|level_string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lcfg
operator|=
name|lctx
operator|->
name|logconfig
expr_stmt|;
name|category_channels
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channellists
index|[
name|category
operator|->
name|id
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * XXXDCL add duplicate filtering? (To not write multiple times to 	 * the same source via various channels). 	 */
do|do
block|{
comment|/* 		 * If the channel list end was reached and a match was made, 		 * everything is finished. 		 */
if|if
condition|(
name|category_channels
operator|==
name|NULL
operator|&&
name|matched
condition|)
break|break;
if|if
condition|(
name|category_channels
operator|==
name|NULL
operator|&&
operator|!
name|matched
operator|&&
name|category_channels
operator|!=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channellists
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* 			 * No category/module pair was explicitly configured. 			 * Try the category named "default". 			 */
name|category_channels
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lcfg
operator|->
name|channellists
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|category_channels
operator|==
name|NULL
operator|&&
operator|!
name|matched
condition|)
comment|/* 			 * No matching module was explicitly configured 			 * for the category named "default".  Use the internal 			 * default channel. 			 */
name|category_channels
operator|=
operator|&
name|default_channel
expr_stmt|;
if|if
condition|(
name|category_channels
operator|->
name|module
operator|!=
name|NULL
operator|&&
name|category_channels
operator|->
name|module
operator|!=
name|module
condition|)
block|{
name|category_channels
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|category_channels
argument_list|,
name|link
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|matched
operator|=
name|ISC_TRUE
expr_stmt|;
name|channel
operator|=
name|category_channels
operator|->
name|channel
expr_stmt|;
name|category_channels
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|category_channels
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_DEBUGONLY
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|lctx
operator|->
name|debug_level
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|channel
operator|->
name|level
operator|==
name|ISC_LOG_DYNAMIC
condition|)
block|{
if|if
condition|(
name|lctx
operator|->
name|debug_level
operator|<
name|level
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|channel
operator|->
name|level
operator|<
name|level
condition|)
continue|continue;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTTIME
operator|)
operator|!=
literal|0
operator|&&
name|time_string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|isc_time_t
name|isctime
decl_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|isctime
argument_list|)
expr_stmt|;
name|isc_time_formattimestamp
argument_list|(
operator|&
name|isctime
argument_list|,
name|time_string
argument_list|,
sizeof|sizeof
argument_list|(
name|time_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTLEVEL
operator|)
operator|!=
literal|0
operator|&&
name|level_string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|level
operator|<
name|ISC_LOG_CRITICAL
condition|)
name|snprintf
argument_list|(
name|level_string
argument_list|,
sizeof|sizeof
argument_list|(
name|level_string
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_LOG
argument_list|,
name|ISC_MSG_LEVEL
argument_list|,
literal|"level %d: "
argument_list|)
argument_list|,
name|level
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|>
name|ISC_LOG_DYNAMIC
condition|)
name|snprintf
argument_list|(
name|level_string
argument_list|,
sizeof|sizeof
argument_list|(
name|level_string
argument_list|)
argument_list|,
literal|"%s %d: "
argument_list|,
name|log_level_strings
index|[
literal|0
index|]
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|level_string
argument_list|,
sizeof|sizeof
argument_list|(
name|level_string
argument_list|)
argument_list|,
literal|"%s: "
argument_list|,
name|log_level_strings
index|[
operator|-
name|level
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Only format the message once. 		 */
if|if
condition|(
name|lctx
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|lctx
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|lctx
operator|->
name|buffer
argument_list|)
argument_list|,
name|iformat
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 			 * Check for duplicates. 			 */
if|if
condition|(
name|write_once
condition|)
block|{
name|isc_logmessage_t
modifier|*
name|message
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|isc_time_t
name|oldest
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
name|lcfg
operator|->
name|duplicate_interval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * 'oldest' is the age of the oldest messages 				 * which fall within the duplicate_interval 				 * range. 				 */
name|TIME_NOW
argument_list|(
operator|&
name|oldest
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_time_subtract
argument_list|(
operator|&
name|oldest
argument_list|,
operator|&
name|interval
argument_list|,
operator|&
name|oldest
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
comment|/* 					 * Can't effectively do the checking 					 * without having a valid time. 					 */
name|message
operator|=
name|NULL
expr_stmt|;
else|else
name|message
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lctx
operator|->
name|messages
argument_list|)
expr_stmt|;
while|while
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isc_time_compare
argument_list|(
operator|&
name|message
operator|->
name|time
argument_list|,
operator|&
name|oldest
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 						 * This message is older 						 * than the duplicate_interval, 						 * so it should be dropped from 						 * the history. 						 * 						 * Setting the interval to be 						 * to be longer will obviously 						 * not cause the expired 						 * message to spring back into 						 * existence. 						 */
name|new
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|message
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|lctx
operator|->
name|messages
argument_list|,
name|message
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|message
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|message
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|message
operator|->
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|=
name|new
expr_stmt|;
continue|continue;
block|}
comment|/* 					 * This message is in the duplicate 					 * filtering interval ... 					 */
if|if
condition|(
name|strcmp
argument_list|(
name|lctx
operator|->
name|buffer
argument_list|,
name|message
operator|->
name|text
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * ... and it is a duplicate. 						 * Unlock the mutex and 						 * get the hell out of Dodge. 						 */
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|message
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|message
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * It wasn't in the duplicate interval, 				 * so add it to the message list. 				 */
name|new
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_logmessage_t
argument_list|)
operator|+
name|strlen
argument_list|(
name|lctx
operator|->
name|buffer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Put the text immediately after 					 * the struct.  The strcpy is safe. 					 */
name|new
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|new
operator|+
literal|1
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|text
argument_list|,
name|lctx
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|new
operator|->
name|time
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|lctx
operator|->
name|messages
argument_list|,
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printtime
operator|=
name|ISC_TF
argument_list|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTTIME
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printtag
operator|=
name|ISC_TF
argument_list|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTTAG
operator|)
operator|!=
literal|0
operator|&&
name|lcfg
operator|->
name|tag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|printcategory
operator|=
name|ISC_TF
argument_list|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTCATEGORY
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printmodule
operator|=
name|ISC_TF
argument_list|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTMODULE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printlevel
operator|=
name|ISC_TF
argument_list|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_PRINTLEVEL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|channel
operator|->
name|type
condition|)
block|{
case|case
name|ISC_LOG_TOFILE
case|:
if|if
condition|(
name|FILE_MAXREACHED
argument_list|(
name|channel
argument_list|)
condition|)
block|{
comment|/* 				 * If the file can be rolled, OR 				 * If the file no longer exists, OR 				 * If the file is less than the maximum size, 				 *    (such as if it had been renamed and 				 *     a new one touched, or it was truncated 				 *     in place) 				 * ... then close it to trigger reopening. 				 */
if|if
condition|(
name|FILE_VERSIONS
argument_list|(
name|channel
argument_list|)
operator|!=
name|ISC_LOG_ROLLNEVER
operator|||
operator|(
name|stat
argument_list|(
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
operator|)
operator|||
name|statbuf
operator|.
name|st_size
operator|<
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|FILE_MAXREACHED
argument_list|(
name|channel
argument_list|)
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
comment|/* 					 * Eh, skip it. 					 */
break|break;
block|}
if|if
condition|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_log_open
argument_list|(
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_MAXSIZE
operator|&&
operator|(
name|channel
operator|->
name|flags
operator|&
name|ISC_LOG_OPENERR
operator|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"isc_log_open '%s' failed: %s"
argument_list|,
name|FILE_NAME
argument_list|(
name|channel
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|channel
operator|->
name|flags
operator||=
name|ISC_LOG_OPENERR
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|channel
operator|->
name|flags
operator|&=
operator|~
name|ISC_LOG_OPENERR
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|ISC_LOG_TOFILEDESC
case|:
name|fprintf
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|,
literal|"%s%s%s%s%s%s%s%s%s%s\n"
argument_list|,
name|printtime
condition|?
name|time_string
else|:
literal|""
argument_list|,
name|printtime
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|printtag
condition|?
name|lcfg
operator|->
name|tag
else|:
literal|""
argument_list|,
name|printtag
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|printcategory
condition|?
name|category
operator|->
name|name
else|:
literal|""
argument_list|,
name|printcategory
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|printmodule
condition|?
operator|(
name|module
operator|!=
name|NULL
condition|?
name|module
operator|->
name|name
else|:
literal|"no_module"
operator|)
else|:
literal|""
argument_list|,
name|printmodule
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|printlevel
condition|?
name|level_string
else|:
literal|""
argument_list|,
name|lctx
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If the file now exceeds its maximum size 			 * threshold, note it so that it will not be logged 			 * to any more. 			 */
if|if
condition|(
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
operator|>
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|channel
operator|->
name|type
operator|==
name|ISC_LOG_TOFILE
argument_list|)
expr_stmt|;
comment|/* XXXDCL NT fstat/fileno */
comment|/* XXXDCL complain if fstat fails? */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|FILE_STREAM
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|&&
name|statbuf
operator|.
name|st_size
operator|>
name|FILE_MAXSIZE
argument_list|(
name|channel
argument_list|)
condition|)
name|FILE_MAXREACHED
argument_list|(
name|channel
argument_list|)
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|ISC_LOG_TOSYSLOG
case|:
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|syslog_level
operator|=
name|LOG_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
name|ISC_LOG_CRITICAL
condition|)
name|syslog_level
operator|=
name|LOG_CRIT
expr_stmt|;
else|else
name|syslog_level
operator|=
name|syslog_map
index|[
operator|-
name|level
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|syslog
argument_list|(
name|FACILITY
argument_list|(
name|channel
argument_list|)
operator||
name|syslog_level
argument_list|,
literal|"%s%s%s%s%s%s%s%s%s%s"
argument_list|,
name|printtime
condition|?
name|time_string
else|:
literal|""
argument_list|,
name|printtime
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|printtag
condition|?
name|lcfg
operator|->
name|tag
else|:
literal|""
argument_list|,
name|printtag
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|printcategory
condition|?
name|category
operator|->
name|name
else|:
literal|""
argument_list|,
name|printcategory
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|printmodule
condition|?
operator|(
name|module
operator|!=
name|NULL
condition|?
name|module
operator|->
name|name
else|:
literal|"no_module"
operator|)
else|:
literal|""
argument_list|,
name|printmodule
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|printlevel
condition|?
name|level_string
else|:
literal|""
argument_list|,
name|lctx
operator|->
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISC_LOG_TONULL
case|:
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

