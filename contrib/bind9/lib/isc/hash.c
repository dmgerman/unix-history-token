begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: hash.c,v 1.6.18.5 2006-01-04 00:37:23 marka Exp $ */
end_comment

begin_comment
comment|/*! \file  * Some portion of this code was derived from universal hash function  * libraries of Rice University.  \section license UH Universal Hashing Library  Copyright ((c)) 2002, Rice University All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following     disclaimer in the documentation and/or other materials provided     with the distribution.      * Neither the name of Rice University (RICE) nor the names of its     contributors may be used to endorse or promote products derived     from this software without specific prior written permission.   This software is provided by RICE and the contributors on an "as is" basis, without any representations or warranties of any kind, express or implied including, but not limited to, representations or warranties of non-infringement, merchantability or fitness for a particular purpose. In no event shall RICE or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/hash.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/refcount.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_define
define|#
directive|define
name|HASH_MAGIC
value|ISC_MAGIC('H', 'a', 's', 'h')
end_define

begin_define
define|#
directive|define
name|VALID_HASH
parameter_list|(
name|h
parameter_list|)
value|ISC_MAGIC_VALID((h), HASH_MAGIC)
end_define

begin_comment
comment|/*%  * A large 32-bit prime number that specifies the range of the hash output.  */
end_comment

begin_define
define|#
directive|define
name|PRIME32
value|0xFFFFFFFB
end_define

begin_comment
comment|/* 2^32 -  5 */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * Types of random seed and hash accumulator.  Perhaps they can be system  * dependent.  */
end_comment

begin_typedef
typedef|typedef
name|isc_uint32_t
name|hash_accum_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|isc_uint16_t
name|hash_random_t
typedef|;
end_typedef

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*% isc hash structure */
end_comment

begin_struct
struct|struct
name|isc_hash
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_boolean_t
name|initialized
decl_stmt|;
name|isc_refcount_t
name|refcnt
decl_stmt|;
name|isc_entropy_t
modifier|*
name|entropy
decl_stmt|;
comment|/*%< entropy source */
name|unsigned
name|int
name|limit
decl_stmt|;
comment|/*%< upper limit of key length */
name|size_t
name|vectorlen
decl_stmt|;
comment|/*%< size of the vector below */
name|hash_random_t
modifier|*
name|rndvector
decl_stmt|;
comment|/*%< random vector for universal hashing */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|isc_mutex_t
name|createlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_once_t
name|once
init|=
name|ISC_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_hash_t
modifier|*
name|hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|maptolower
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1f
block|,
literal|0x20
block|,
literal|0x21
block|,
literal|0x22
block|,
literal|0x23
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x2d
block|,
literal|0x2e
block|,
literal|0x2f
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x3a
block|,
literal|0x3b
block|,
literal|0x3c
block|,
literal|0x3d
block|,
literal|0x3e
block|,
literal|0x3f
block|,
literal|0x40
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x6e
block|,
literal|0x6f
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x5b
block|,
literal|0x5c
block|,
literal|0x5d
block|,
literal|0x5e
block|,
literal|0x5f
block|,
literal|0x60
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x6e
block|,
literal|0x6f
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x7b
block|,
literal|0x7c
block|,
literal|0x7d
block|,
literal|0x7e
block|,
literal|0x7f
block|,
literal|0x80
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x8a
block|,
literal|0x8b
block|,
literal|0x8c
block|,
literal|0x8d
block|,
literal|0x8e
block|,
literal|0x8f
block|,
literal|0x90
block|,
literal|0x91
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0x9b
block|,
literal|0x9c
block|,
literal|0x9d
block|,
literal|0x9e
block|,
literal|0x9f
block|,
literal|0xa0
block|,
literal|0xa1
block|,
literal|0xa2
block|,
literal|0xa3
block|,
literal|0xa4
block|,
literal|0xa5
block|,
literal|0xa6
block|,
literal|0xa7
block|,
literal|0xa8
block|,
literal|0xa9
block|,
literal|0xaa
block|,
literal|0xab
block|,
literal|0xac
block|,
literal|0xad
block|,
literal|0xae
block|,
literal|0xaf
block|,
literal|0xb0
block|,
literal|0xb1
block|,
literal|0xb2
block|,
literal|0xb3
block|,
literal|0xb4
block|,
literal|0xb5
block|,
literal|0xb6
block|,
literal|0xb7
block|,
literal|0xb8
block|,
literal|0xb9
block|,
literal|0xba
block|,
literal|0xbb
block|,
literal|0xbc
block|,
literal|0xbd
block|,
literal|0xbe
block|,
literal|0xbf
block|,
literal|0xc0
block|,
literal|0xc1
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xcb
block|,
literal|0xcc
block|,
literal|0xcd
block|,
literal|0xce
block|,
literal|0xcf
block|,
literal|0xd0
block|,
literal|0xd1
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xdb
block|,
literal|0xdc
block|,
literal|0xdd
block|,
literal|0xde
block|,
literal|0xdf
block|,
literal|0xe0
block|,
literal|0xe1
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0xea
block|,
literal|0xeb
block|,
literal|0xec
block|,
literal|0xed
block|,
literal|0xee
block|,
literal|0xef
block|,
literal|0xf0
block|,
literal|0xf1
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0xfa
block|,
literal|0xfb
block|,
literal|0xfc
block|,
literal|0xfd
block|,
literal|0xfe
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|isc_hash_ctxcreate
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_entropy_t
modifier|*
name|entropy
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|,
name|isc_hash_t
modifier|*
modifier|*
name|hctxp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_hash_t
modifier|*
name|hctx
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
name|hash_random_t
modifier|*
name|rv
decl_stmt|;
name|hash_accum_t
name|overflow_limit
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|hctxp
operator|!=
name|NULL
operator|&&
operator|*
name|hctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Overflow check.  Since our implementation only does a modulo 	 * operation at the last stage of hash calculation, the accumulator 	 * must not overflow. 	 */
name|overflow_limit
operator|=
literal|1
operator|<<
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|hash_accum_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|hash_random_t
argument_list|)
operator|)
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|overflow_limit
operator|<
operator|(
name|limit
operator|+
literal|1
operator|)
operator|*
literal|0xff
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|hctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_hash_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|vlen
operator|=
sizeof|sizeof
argument_list|(
name|hash_random_t
argument_list|)
operator|*
operator|(
name|limit
operator|+
literal|1
operator|)
expr_stmt|;
name|rv
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
comment|/* 	 * We need a lock. 	 */
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|errout
goto|;
comment|/* 	 * From here down, no failures will/can occur. 	 */
name|hctx
operator|->
name|magic
operator|=
name|HASH_MAGIC
expr_stmt|;
name|hctx
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|hctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|hctx
operator|->
name|initialized
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|hctx
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_lock
goto|;
name|hctx
operator|->
name|entropy
operator|=
name|NULL
expr_stmt|;
name|hctx
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|hctx
operator|->
name|vectorlen
operator|=
name|vlen
expr_stmt|;
name|hctx
operator|->
name|rndvector
operator|=
name|rv
expr_stmt|;
if|if
condition|(
name|entropy
operator|!=
name|NULL
condition|)
name|isc_entropy_attach
argument_list|(
name|entropy
argument_list|,
operator|&
name|hctx
operator|->
name|entropy
argument_list|)
expr_stmt|;
operator|*
name|hctxp
operator|=
name|hctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|errout
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|hctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_hash_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rv
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_mutex_init
argument_list|(
operator|&
name|createlock
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_hash_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_entropy_t
modifier|*
name|entropy
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|hash
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|initialize_lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|createlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
name|result
operator|=
name|isc_hash_ctxcreate
argument_list|(
name|mctx
argument_list|,
name|entropy
argument_list|,
name|limit
argument_list|,
operator|&
name|hash
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|createlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_hash_ctxinit
parameter_list|(
name|isc_hash_t
modifier|*
name|hctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hctx
operator|->
name|initialized
operator|==
name|ISC_TRUE
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hctx
operator|->
name|entropy
condition|)
block|{
name|result
operator|=
name|isc_entropy_getdata
argument_list|(
name|hctx
operator|->
name|entropy
argument_list|,
name|hctx
operator|->
name|rndvector
argument_list|,
name|hctx
operator|->
name|vectorlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_uint32_t
name|pr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|copylen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hctx
operator|->
name|rndvector
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hctx
operator|->
name|vectorlen
condition|;
name|i
operator|+=
name|copylen
operator|,
name|p
operator|+=
name|copylen
control|)
block|{
name|isc_random_get
argument_list|(
operator|&
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
operator|<=
name|hctx
operator|->
name|vectorlen
condition|)
name|copylen
operator|=
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
expr_stmt|;
else|else
name|copylen
operator|=
name|hctx
operator|->
name|vectorlen
operator|-
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|pr
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|p
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hctx
operator|->
name|rndvector
operator|+
name|hctx
operator|->
name|vectorlen
argument_list|)
expr_stmt|;
block|}
name|hctx
operator|->
name|initialized
operator|=
name|ISC_TRUE
expr_stmt|;
name|out
label|:
name|UNLOCK
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_hash_init
parameter_list|()
block|{
name|INSIST
argument_list|(
name|hash
operator|!=
name|NULL
operator|&&
name|VALID_HASH
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|isc_hash_ctxinit
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_hash_ctxattach
parameter_list|(
name|isc_hash_t
modifier|*
name|hctx
parameter_list|,
name|isc_hash_t
modifier|*
modifier|*
name|hctxp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_HASH
argument_list|(
name|hctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|hctxp
operator|!=
name|NULL
operator|&&
operator|*
name|hctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|hctx
operator|->
name|refcnt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|hctxp
operator|=
name|hctx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc_hash_t
modifier|*
modifier|*
name|hctxp
parameter_list|)
block|{
name|isc_hash_t
modifier|*
name|hctx
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|hctxp
operator|!=
name|NULL
operator|&&
operator|*
name|hctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hctx
operator|=
operator|*
name|hctxp
expr_stmt|;
operator|*
name|hctxp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|hctx
operator|->
name|refcnt
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|hctx
operator|->
name|mctx
expr_stmt|;
if|if
condition|(
name|hctx
operator|->
name|entropy
operator|!=
name|NULL
condition|)
name|isc_entropy_detach
argument_list|(
operator|&
name|hctx
operator|->
name|entropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|hctx
operator|->
name|rndvector
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|hctx
operator|->
name|rndvector
argument_list|,
name|hctx
operator|->
name|vectorlen
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|hctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_hash_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|hctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_hash_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_hash_ctxdetach
parameter_list|(
name|isc_hash_t
modifier|*
modifier|*
name|hctxp
parameter_list|)
block|{
name|isc_hash_t
modifier|*
name|hctx
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|hctxp
operator|!=
name|NULL
operator|&&
name|VALID_HASH
argument_list|(
operator|*
name|hctxp
argument_list|)
argument_list|)
expr_stmt|;
name|hctx
operator|=
operator|*
name|hctxp
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|hctx
operator|->
name|refcnt
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
name|destroy
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
operator|*
name|hctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_hash_destroy
parameter_list|()
block|{
name|unsigned
name|int
name|refs
decl_stmt|;
name|INSIST
argument_list|(
name|hash
operator|!=
name|NULL
operator|&&
name|VALID_HASH
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|hash
operator|->
name|refcnt
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|hash_calc
parameter_list|(
name|isc_hash_t
modifier|*
name|hctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
name|hash_accum_t
name|partial_sum
init|=
literal|0
decl_stmt|;
name|hash_random_t
modifier|*
name|p
init|=
name|hctx
operator|->
name|rndvector
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Make it sure that the hash context is initialized. */
if|if
condition|(
name|hctx
operator|->
name|initialized
operator|==
name|ISC_FALSE
condition|)
name|isc_hash_ctxinit
argument_list|(
name|hctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_sensitive
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keylen
condition|;
name|i
operator|++
control|)
name|partial_sum
operator|+=
name|key
index|[
name|i
index|]
operator|*
operator|(
name|hash_accum_t
operator|)
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keylen
condition|;
name|i
operator|++
control|)
name|partial_sum
operator|+=
name|maptolower
index|[
name|key
index|[
name|i
index|]
index|]
operator|*
operator|(
name|hash_accum_t
operator|)
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
name|partial_sum
operator|+=
name|p
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|partial_sum
operator|%
name|PRIME32
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_hash_ctxcalc
parameter_list|(
name|isc_hash_t
modifier|*
name|hctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|hctx
operator|!=
name|NULL
operator|&&
name|VALID_HASH
argument_list|(
name|hctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|keylen
operator|<=
name|hctx
operator|->
name|limit
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash_calc
argument_list|(
name|hctx
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|case_sensitive
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_hash_calc
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
name|INSIST
argument_list|(
name|hash
operator|!=
name|NULL
operator|&&
name|VALID_HASH
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|keylen
operator|<=
name|hash
operator|->
name|limit
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash_calc
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|case_sensitive
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

