begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: stats.c,v 1.3 2009-01-27 23:47:54 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/atomic.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_define
define|#
directive|define
name|ISC_STATS_MAGIC
value|ISC_MAGIC('S', 't', 'a', 't')
end_define

begin_define
define|#
directive|define
name|ISC_STATS_VALID
parameter_list|(
name|x
parameter_list|)
value|ISC_MAGIC_VALID(x, ISC_STATS_MAGIC)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_STATS_USEMULTIFIELDS
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_RWLOCK_USEATOMIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEXADD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEXADDQ
argument_list|)
end_if

begin_define
define|#
directive|define
name|ISC_STATS_USEMULTIFIELDS
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISC_STATS_USEMULTIFIELDS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_STATS_USEMULTIFIELDS */
end_comment

begin_if
if|#
directive|if
name|ISC_STATS_USEMULTIFIELDS
end_if

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_uint32_t
name|hi
decl_stmt|;
name|isc_uint32_t
name|lo
decl_stmt|;
block|}
name|isc_stat_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|isc_uint64_t
name|isc_stat_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|isc_stats
block|{
comment|/*% Unlocked */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|ncounters
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
comment|/* locked by lock */
comment|/*% 	 * Locked by counterlock or unlocked if efficient rwlock is not 	 * available. 	 */
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_t
name|counterlock
decl_stmt|;
endif|#
directive|endif
name|isc_stat_t
modifier|*
name|counters
decl_stmt|;
comment|/*% 	 * We don't want to lock the counters while we are dumping, so we first 	 * copy the current counter values into a local array.  This buffer 	 * will be used as the copy destination.  It's allocated on creation 	 * of the stats structure so that the dump operation won't fail due 	 * to memory allocation failure. 	 * XXX: this approach is weird for non-threaded build because the 	 * additional memory and the copy overhead could be avoided.  We prefer 	 * simplicity here, however, under the assumption that this function 	 * should be only rarely called. 	 */
name|isc_uint64_t
modifier|*
name|copiedcounters
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|isc_result_t
name|create_stats
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|int
name|ncounters
parameter_list|,
name|isc_stats_t
modifier|*
modifier|*
name|statsp
parameter_list|)
block|{
name|isc_stats_t
modifier|*
name|stats
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|statsp
operator|!=
name|NULL
operator|&&
operator|*
name|statsp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|stats
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|clean_stats
goto|;
name|stats
operator|->
name|counters
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
operator|*
name|ncounters
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|->
name|counters
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|clean_mutex
goto|;
block|}
name|stats
operator|->
name|copiedcounters
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_uint64_t
argument_list|)
operator|*
name|ncounters
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|->
name|copiedcounters
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|clean_counters
goto|;
block|}
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|clean_copiedcounters
goto|;
endif|#
directive|endif
name|stats
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|stats
operator|->
name|counters
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
operator|*
name|ncounters
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|stats
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ncounters
operator|=
name|ncounters
expr_stmt|;
name|stats
operator|->
name|magic
operator|=
name|ISC_STATS_MAGIC
expr_stmt|;
operator|*
name|statsp
operator|=
name|stats
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|clean_counters
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stats
operator|->
name|counters
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
operator|*
name|ncounters
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|clean_copiedcounters
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stats
operator|->
name|copiedcounters
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
operator|*
name|ncounters
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clean_mutex
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
name|clean_stats
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_stats_attach
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|isc_stats_t
modifier|*
modifier|*
name|statsp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ISC_STATS_VALID
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|statsp
operator|!=
name|NULL
operator|&&
operator|*
name|statsp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
name|stats
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|statsp
operator|=
name|stats
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_stats_detach
parameter_list|(
name|isc_stats_t
modifier|*
modifier|*
name|statsp
parameter_list|)
block|{
name|isc_stats_t
modifier|*
name|stats
decl_stmt|;
name|REQUIRE
argument_list|(
name|statsp
operator|!=
name|NULL
operator|&&
name|ISC_STATS_VALID
argument_list|(
operator|*
name|statsp
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|*
name|statsp
expr_stmt|;
operator|*
name|statsp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
name|stats
operator|->
name|references
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|isc_mem_put
argument_list|(
name|stats
operator|->
name|mctx
argument_list|,
name|stats
operator|->
name|copiedcounters
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
operator|*
name|stats
operator|->
name|ncounters
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|stats
operator|->
name|mctx
argument_list|,
name|stats
operator|->
name|counters
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
operator|*
name|stats
operator|->
name|ncounters
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|stats
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_destroy
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isc_mem_putanddetach
argument_list|(
operator|&
name|stats
operator|->
name|mctx
argument_list|,
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|isc_stats_ncounters
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ISC_STATS_VALID
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|stats
operator|->
name|ncounters
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|incrementcounter
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|int
name|counter
parameter_list|)
block|{
name|isc_int32_t
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
comment|/* 	 * We use a "read" lock to prevent other threads from reading the 	 * counter while we "writing" a counter field.  The write access itself 	 * is protected by the atomic operation. 	 */
name|isc_rwlock_lock
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ISC_STATS_USEMULTIFIELDS
name|prev
operator|=
name|isc_atomic_xadd
argument_list|(
operator|(
name|isc_int32_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|counters
index|[
name|counter
index|]
operator|.
name|lo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If the lower 32-bit field overflows, increment the higher field. 	 * Note that it's *theoretically* possible that the lower field 	 * overlaps again before the higher field is incremented.  It doesn't 	 * matter, however, because we don't read the value until 	 * isc_stats_copy() is called where the whole process is protected 	 * by the write (exclusive) lock. 	 */
if|if
condition|(
name|prev
operator|==
operator|(
name|isc_int32_t
operator|)
literal|0xffffffff
condition|)
name|isc_atomic_xadd
argument_list|(
operator|(
name|isc_int32_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|counters
index|[
name|counter
index|]
operator|.
name|hi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEXADDQ
argument_list|)
name|UNUSED
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|isc_atomic_xaddq
argument_list|(
operator|(
name|isc_int64_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|counters
index|[
name|counter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|stats
operator|->
name|counters
index|[
name|counter
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_unlock
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|decrementcounter
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|int
name|counter
parameter_list|)
block|{
name|isc_int32_t
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_lock
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ISC_STATS_USEMULTIFIELDS
name|prev
operator|=
name|isc_atomic_xadd
argument_list|(
operator|(
name|isc_int32_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|counters
index|[
name|counter
index|]
operator|.
name|lo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|isc_atomic_xadd
argument_list|(
operator|(
name|isc_int32_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|counters
index|[
name|counter
index|]
operator|.
name|hi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEXADDQ
argument_list|)
name|UNUSED
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|isc_atomic_xaddq
argument_list|(
operator|(
name|isc_int64_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|counters
index|[
name|counter
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|stats
operator|->
name|counters
index|[
name|counter
index|]
operator|--
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_unlock
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|copy_counters
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
comment|/* 	 * We use a "write" lock before "reading" the statistics counters as 	 * an exclusive lock. 	 */
name|isc_rwlock_lock
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ISC_STATS_USEMULTIFIELDS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stats
operator|->
name|ncounters
condition|;
name|i
operator|++
control|)
block|{
name|stats
operator|->
name|copiedcounters
index|[
name|i
index|]
operator|=
call|(
name|isc_uint64_t
call|)
argument_list|(
name|stats
operator|->
name|counters
index|[
name|i
index|]
operator|.
name|hi
argument_list|)
operator|<<
literal|32
operator||
name|stats
operator|->
name|counters
index|[
name|i
index|]
operator|.
name|lo
expr_stmt|;
block|}
else|#
directive|else
name|UNUSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stats
operator|->
name|copiedcounters
argument_list|,
name|stats
operator|->
name|counters
argument_list|,
name|stats
operator|->
name|ncounters
operator|*
sizeof|sizeof
argument_list|(
name|isc_stat_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
name|isc_rwlock_unlock
argument_list|(
operator|&
name|stats
operator|->
name|counterlock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|isc_stats_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_stats_t
modifier|*
modifier|*
name|statsp
parameter_list|,
name|int
name|ncounters
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|statsp
operator|!=
name|NULL
operator|&&
operator|*
name|statsp
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|create_stats
argument_list|(
name|mctx
argument_list|,
name|ncounters
argument_list|,
name|statsp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_stats_increment
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ISC_STATS_VALID
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|counter
operator|<
name|stats
operator|->
name|ncounters
argument_list|)
expr_stmt|;
name|incrementcounter
argument_list|(
name|stats
argument_list|,
operator|(
name|int
operator|)
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_stats_decrement
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ISC_STATS_VALID
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|counter
operator|<
name|stats
operator|->
name|ncounters
argument_list|)
expr_stmt|;
name|decrementcounter
argument_list|(
name|stats
argument_list|,
operator|(
name|int
operator|)
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_stats_dump
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|isc_stats_dumper_t
name|dump_fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|ISC_STATS_VALID
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|copy_counters
argument_list|(
name|stats
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stats
operator|->
name|ncounters
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|ISC_STATSDUMP_VERBOSE
operator|)
operator|==
literal|0
operator|&&
name|stats
operator|->
name|copiedcounters
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|dump_fn
argument_list|(
operator|(
name|isc_statscounter_t
operator|)
name|i
argument_list|,
name|stats
operator|->
name|copiedcounters
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

