begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2010, 2012-2014  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1997-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/ondestroy.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isc/xml.h>
end_include

begin_define
define|#
directive|define
name|MCTXLOCK
parameter_list|(
name|m
parameter_list|,
name|l
parameter_list|)
value|if (((m)->flags& ISC_MEMFLAG_NOLOCK) == 0) LOCK(l)
end_define

begin_define
define|#
directive|define
name|MCTXUNLOCK
parameter_list|(
name|m
parameter_list|,
name|l
parameter_list|)
value|if (((m)->flags& ISC_MEMFLAG_NOLOCK) == 0) UNLOCK(l)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_MEM_DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|ISC_MEM_DEBUGGING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|LIBISC_EXTERNAL_DATA
name|unsigned
name|int
name|isc_mem_debugging
init|=
name|ISC_MEM_DEBUGGING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Constants.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MAX_SIZE
value|1100
end_define

begin_define
define|#
directive|define
name|DEF_MEM_TARGET
value|4096
end_define

begin_define
define|#
directive|define
name|ALIGNMENT_SIZE
value|8U
end_define

begin_comment
comment|/*%< must be a power of 2 */
end_comment

begin_define
define|#
directive|define
name|NUM_BASIC_BLOCKS
value|64
end_define

begin_comment
comment|/*%< must be> 1 */
end_comment

begin_define
define|#
directive|define
name|TABLE_INCREMENT
value|1024
end_define

begin_define
define|#
directive|define
name|DEBUGLIST_COUNT
value|1024
end_define

begin_comment
comment|/*  * Types.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|isc__mem
name|isc__mem_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|isc__mempool
name|isc__mempool_t
typedef|;
end_typedef

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_typedef
typedef|typedef
name|struct
name|debuglink
name|debuglink_t
typedef|;
end_typedef

begin_struct
struct|struct
name|debuglink
block|{
name|ISC_LINK
argument_list|(
argument|debuglink_t
argument_list|)
name|link
expr_stmt|;
specifier|const
name|void
modifier|*
name|ptr
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
name|size_t
name|size
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
name|unsigned
name|int
name|line
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FLARG_PASS
value|, file, line
end_define

begin_define
define|#
directive|define
name|FLARG
value|, const char *file, unsigned int line
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FLARG_PASS
end_define

begin_define
define|#
directive|define
name|FLARG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|element
name|element
typedef|;
end_typedef

begin_struct
struct|struct
name|element
block|{
name|element
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/*! 	 * This structure must be ALIGNMENT_SIZE bytes. 	 */
union|union
block|{
name|size_t
name|size
decl_stmt|;
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
name|char
name|bytes
index|[
name|ALIGNMENT_SIZE
index|]
decl_stmt|;
block|}
name|u
union|;
block|}
name|size_info
typedef|;
end_typedef

begin_struct
struct|struct
name|stats
block|{
name|unsigned
name|long
name|gets
decl_stmt|;
name|unsigned
name|long
name|totalgets
decl_stmt|;
name|unsigned
name|long
name|blocks
decl_stmt|;
name|unsigned
name|long
name|freefrags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MEM_MAGIC
value|ISC_MAGIC('M', 'e', 'm', 'C')
end_define

begin_define
define|#
directive|define
name|VALID_CONTEXT
parameter_list|(
name|c
parameter_list|)
value|ISC_MAGIC_VALID(c, MEM_MAGIC)
end_define

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|debuglink_t
argument_list|)
name|debuglist_t
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of all active memory contexts. */
end_comment

begin_expr_stmt
specifier|static
name|ISC_LIST
argument_list|(
argument|isc__mem_t
argument_list|)
name|contexts
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|isc_once_t
name|once
init|=
name|ISC_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_mutex_t
name|lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Total size of lost memory due to a bug of external library.  * Locked by the global lock.  */
end_comment

begin_decl_stmt
specifier|static
name|isc_uint64_t
name|totallost
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|isc__mem
block|{
name|isc_mem_t
name|common
decl_stmt|;
name|isc_ondestroy_t
name|ondestroy
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_memalloc_t
name|memalloc
decl_stmt|;
name|isc_memfree_t
name|memfree
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|size_t
name|max_size
decl_stmt|;
name|isc_boolean_t
name|checkfree
decl_stmt|;
name|struct
name|stats
modifier|*
name|stats
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
name|size_t
name|quota
decl_stmt|;
name|size_t
name|total
decl_stmt|;
name|size_t
name|inuse
decl_stmt|;
name|size_t
name|maxinuse
decl_stmt|;
name|size_t
name|hi_water
decl_stmt|;
name|size_t
name|lo_water
decl_stmt|;
name|isc_boolean_t
name|hi_called
decl_stmt|;
name|isc_boolean_t
name|is_overmem
decl_stmt|;
name|isc_mem_water_t
name|water
decl_stmt|;
name|void
modifier|*
name|water_arg
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc__mempool_t
argument_list|)
name|pools
expr_stmt|;
name|unsigned
name|int
name|poolcnt
decl_stmt|;
comment|/*  ISC_MEMFLAG_INTERNAL */
name|size_t
name|mem_target
decl_stmt|;
name|element
modifier|*
modifier|*
name|freelists
decl_stmt|;
name|element
modifier|*
name|basic_blocks
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|basic_table
decl_stmt|;
name|unsigned
name|int
name|basic_table_count
decl_stmt|;
name|unsigned
name|int
name|basic_table_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lowest
decl_stmt|;
name|unsigned
name|char
modifier|*
name|highest
decl_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|debuglist_t
modifier|*
name|debuglist
decl_stmt|;
name|unsigned
name|int
name|debuglistcnt
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|memalloc_failures
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|isc__mem_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MEMPOOL_MAGIC
value|ISC_MAGIC('M', 'E', 'M', 'p')
end_define

begin_define
define|#
directive|define
name|VALID_MEMPOOL
parameter_list|(
name|c
parameter_list|)
value|ISC_MAGIC_VALID(c, MEMPOOL_MAGIC)
end_define

begin_struct
struct|struct
name|isc__mempool
block|{
comment|/* always unlocked */
name|isc_mempool_t
name|common
decl_stmt|;
comment|/*%< common header of mempool's */
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
comment|/*%< optional lock */
name|isc__mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/*%< our memory context */
comment|/*%< locked via the memory context's lock */
name|ISC_LINK
argument_list|(
argument|isc__mempool_t
argument_list|)
name|link
expr_stmt|;
comment|/*%< next pool in this mem context */
comment|/*%< optionally locked from here down */
name|element
modifier|*
name|items
decl_stmt|;
comment|/*%< low water item list */
name|size_t
name|size
decl_stmt|;
comment|/*%< size of each item on this pool */
name|unsigned
name|int
name|maxalloc
decl_stmt|;
comment|/*%< max number of items allowed */
name|unsigned
name|int
name|allocated
decl_stmt|;
comment|/*%< # of items currently given out */
name|unsigned
name|int
name|freecount
decl_stmt|;
comment|/*%< # of items on reserved list */
name|unsigned
name|int
name|freemax
decl_stmt|;
comment|/*%< # of items allowed on free list */
name|unsigned
name|int
name|fillcount
decl_stmt|;
comment|/*%< # of items to fetch on each fill */
comment|/*%< Stats only. */
name|unsigned
name|int
name|gets
decl_stmt|;
comment|/*%< # of requests to this pool */
comment|/*%< Debugging only. */
if|#
directive|if
name|ISC_MEMPOOL_NAMES
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/*%< printed name in stats reports */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Private Inline-able.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|ISC_MEM_TRACKLINES
end_if

begin_define
define|#
directive|define
name|ADD_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DELETE_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
end_define

begin_define
define|#
directive|define
name|ISC_MEMFUNC_SCOPE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ADD_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
define|\
value|do { \ 		if ((isc_mem_debugging& (ISC_MEM_DEBUGTRACE | \ 					  ISC_MEM_DEBUGRECORD)) != 0&& \ 		     b != NULL) \ 			 add_trace_entry(a, b, c, d, e); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|DELETE_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|delete_trace_entry(a, b, c, d, e)
end_define

begin_function_decl
specifier|static
name|void
name|print_active
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%  * The following can be either static or public, depending on build environment.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_define
define|#
directive|define
name|ISC_MEMFUNC_SCOPE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISC_MEMFUNC_SCOPE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_createx
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_memalloc_t
name|memalloc
parameter_list|,
name|isc_memfree_t
name|memfree
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_createx2
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_memalloc_t
name|memalloc
parameter_list|,
name|isc_memfree_t
name|memfree
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_create
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_create2
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_attach
parameter_list|(
name|isc_mem_t
modifier|*
name|source
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_detach
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mem_putanddetach
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_destroy
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_ondestroy
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mem_get
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mem_put
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_stats
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mem_allocate
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mem_reallocate
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mem_free
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|char
modifier|*
name|isc___mem_strdup
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|s
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setdestroycheck
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|isc_boolean_t
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setquota
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|quota
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|size_t
name|isc__mem_getquota
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|size_t
name|isc__mem_inuse
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_boolean_t
name|isc__mem_isovermem
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setwater
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|isc_mem_water_t
name|water
parameter_list|,
name|void
modifier|*
name|water_arg
parameter_list|,
name|size_t
name|hiwater
parameter_list|,
name|size_t
name|lowater
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_waterack
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setname
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
specifier|const
name|char
modifier|*
name|isc__mem_getname
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc__mem_gettag
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mempool_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|size_t
name|size
parameter_list|,
name|isc_mempool_t
modifier|*
modifier|*
name|mpctxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setname
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_destroy
parameter_list|(
name|isc_mempool_t
modifier|*
modifier|*
name|mpctxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_associatelock
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|isc_mutex_t
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mempool_get
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mempool_put
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|void
modifier|*
name|mem
name|FLARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setfreemax
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getfreemax
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getfreecount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setmaxalloc
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getmaxalloc
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getallocated
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setfillcount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getfillcount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_printactive
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_printallactive
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_checkdestroyed
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mem_references
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_MEM_TRACKLINES */
end_comment

begin_struct
specifier|static
struct|struct
name|isc__memmethods
block|{
name|isc_memmethods_t
name|methods
decl_stmt|;
comment|/*% 	 * The following are defined just for avoiding unused static functions. 	 */
ifndef|#
directive|ifndef
name|BIND9
name|void
modifier|*
name|createx
decl_stmt|,
modifier|*
name|create
decl_stmt|,
modifier|*
name|create2
decl_stmt|,
modifier|*
name|ondestroy
decl_stmt|,
modifier|*
name|stats
decl_stmt|,
modifier|*
name|setquota
decl_stmt|,
modifier|*
name|getquota
decl_stmt|,
modifier|*
name|setname
decl_stmt|,
modifier|*
name|getname
decl_stmt|,
modifier|*
name|gettag
decl_stmt|;
endif|#
directive|endif
block|}
name|memmethods
init|=
block|{
block|{
name|isc__mem_attach
block|,
name|isc__mem_detach
block|,
name|isc__mem_destroy
block|,
name|isc___mem_get
block|,
name|isc___mem_put
block|,
name|isc___mem_putanddetach
block|,
name|isc___mem_allocate
block|,
name|isc___mem_reallocate
block|,
name|isc___mem_strdup
block|,
name|isc___mem_free
block|,
name|isc__mem_setdestroycheck
block|,
name|isc__mem_setwater
block|,
name|isc__mem_waterack
block|,
name|isc__mem_inuse
block|,
name|isc__mem_isovermem
block|,
name|isc__mempool_create
block|}
ifndef|#
directive|ifndef
name|BIND9
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_createx
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_create
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_create2
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_ondestroy
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_stats
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_setquota
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_getquota
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_setname
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_getname
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mem_gettag
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|isc__mempoolmethods
block|{
name|isc_mempoolmethods_t
name|methods
decl_stmt|;
comment|/*% 	 * The following are defined just for avoiding unused static functions. 	 */
ifndef|#
directive|ifndef
name|BIND9
name|void
modifier|*
name|getfreemax
decl_stmt|,
modifier|*
name|getfreecount
decl_stmt|,
modifier|*
name|getmaxalloc
decl_stmt|,
modifier|*
name|getfillcount
decl_stmt|;
endif|#
directive|endif
block|}
name|mempoolmethods
init|=
block|{
block|{
name|isc__mempool_destroy
block|,
name|isc___mempool_get
block|,
name|isc___mempool_put
block|,
name|isc__mempool_getallocated
block|,
name|isc__mempool_setmaxalloc
block|,
name|isc__mempool_setfreemax
block|,
name|isc__mempool_setname
block|,
name|isc__mempool_associatelock
block|,
name|isc__mempool_setfillcount
block|}
ifndef|#
directive|ifndef
name|BIND9
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mempool_getfreemax
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mempool_getfreecount
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mempool_getmaxalloc
block|,
operator|(
name|void
operator|*
operator|)
name|isc__mempool_getfillcount
endif|#
directive|endif
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_comment
comment|/*!  * mctx must be locked.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_trace_entry
parameter_list|(
name|isc__mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|mysize
init|=
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGTRACE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_ADDTRACE
argument_list|,
literal|"add %p size %u "
literal|"file %s line %u mctx %p\n"
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|debuglist
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|mysize
operator|>
name|mctx
operator|->
name|max_size
condition|)
name|mysize
operator|=
name|mctx
operator|->
name|max_size
expr_stmt|;
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|mysize
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|dl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|count
operator|==
name|DEBUGLIST_COUNT
condition|)
goto|goto
name|next
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEBUGLIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|=
name|ptr
expr_stmt|;
name|dl
operator|->
name|size
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|dl
operator|->
name|file
index|[
name|i
index|]
operator|=
name|file
expr_stmt|;
name|dl
operator|->
name|line
index|[
name|i
index|]
operator|=
name|line
expr_stmt|;
name|dl
operator|->
name|count
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|next
label|:
name|dl
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|dl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|debuglink_t
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|DEBUGLIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|size
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|file
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|line
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dl
operator|->
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
expr_stmt|;
name|dl
operator|->
name|size
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
name|dl
operator|->
name|file
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
name|dl
operator|->
name|line
index|[
literal|0
index|]
operator|=
name|line
expr_stmt|;
name|dl
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|mysize
index|]
argument_list|,
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|debuglistcnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|delete_trace_entry
parameter_list|(
name|isc__mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGTRACE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_DELTRACE
argument_list|,
literal|"del %p size %u "
literal|"file %s line %u mctx %p\n"
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|debuglist
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|size
operator|>
name|mctx
operator|->
name|max_size
condition|)
name|size
operator|=
name|mctx
operator|->
name|max_size
expr_stmt|;
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|size
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|dl
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEBUGLIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|==
name|ptr
condition|)
block|{
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|size
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|file
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|line
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|dl
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dl
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|size
index|]
argument_list|,
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|dl
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we get here, we didn't find the item on the list.  We're 	 * screwed. 	 */
name|INSIST
argument_list|(
name|dl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_MEM_TRACKLINES */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|rmsize
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * round down to ALIGNMENT_SIZE 	 */
return|return
operator|(
name|size
operator|&
operator|(
operator|~
operator|(
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|quantize
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
comment|/*! 	 * Round up the result in order to get a size big 	 * enough to satisfy the request and be aligned on ALIGNMENT_SIZE 	 * byte boundaries. 	 */
if|if
condition|(
name|size
operator|==
literal|0U
condition|)
return|return
operator|(
name|ALIGNMENT_SIZE
operator|)
return|;
return|return
operator|(
operator|(
name|size
operator|+
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|&
operator|(
operator|~
operator|(
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|more_basic_blocks
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|table_size
decl_stmt|;
name|size_t
name|increment
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Require: we hold the context lock. */
comment|/* 	 * Did we hit the quota for this context? 	 */
name|increment
operator|=
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|quota
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|total
operator|+
name|increment
operator|>
name|ctx
operator|->
name|quota
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|basic_table_count
operator|<=
name|ctx
operator|->
name|basic_table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|basic_table_count
operator|==
name|ctx
operator|->
name|basic_table_size
condition|)
block|{
name|table_size
operator|=
name|ctx
operator|->
name|basic_table_size
operator|+
name|TABLE_INCREMENT
expr_stmt|;
name|table
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|table_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|basic_table_size
operator|!=
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|table
argument_list|,
name|ctx
operator|->
name|basic_table
argument_list|,
name|ctx
operator|->
name|basic_table_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|basic_table
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|basic_table
operator|=
name|table
expr_stmt|;
name|ctx
operator|->
name|basic_table_size
operator|=
name|table_size
expr_stmt|;
block|}
name|new
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|ctx
operator|->
name|total
operator|+=
name|increment
expr_stmt|;
name|ctx
operator|->
name|basic_table
index|[
name|ctx
operator|->
name|basic_table_count
index|]
operator|=
name|new
expr_stmt|;
name|ctx
operator|->
name|basic_table_count
operator|++
expr_stmt|;
name|curr
operator|=
name|new
expr_stmt|;
name|next
operator|=
name|curr
operator|+
name|ctx
operator|->
name|mem_target
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|NUM_BASIC_BLOCKS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
operator|(
name|element
operator|*
operator|)
name|next
expr_stmt|;
name|curr
operator|=
name|next
expr_stmt|;
name|next
operator|+=
name|ctx
operator|->
name|mem_target
expr_stmt|;
block|}
comment|/* 	 * curr is now pointing at the last block in the 	 * array. 	 */
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
name|new
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|<
name|ctx
operator|->
name|lowest
operator|||
name|ctx
operator|->
name|lowest
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|lowest
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|ctx
operator|->
name|highest
condition|)
name|ctx
operator|->
name|highest
operator|=
name|last
expr_stmt|;
name|ctx
operator|->
name|basic_blocks
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|more_frags
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|new_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|frags
decl_stmt|;
name|size_t
name|total_size
decl_stmt|;
name|void
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/*! 	 * Try to get more fragments by chopping up a basic block. 	 */
if|if
condition|(
name|ctx
operator|->
name|basic_blocks
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|more_basic_blocks
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* 			 * We can't get more memory from the OS, or we've 			 * hit the quota for this context. 			 */
comment|/* 			 * XXXRTH  "At quota" notification here. 			 */
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
name|total_size
operator|=
name|ctx
operator|->
name|mem_target
expr_stmt|;
name|new
operator|=
name|ctx
operator|->
name|basic_blocks
expr_stmt|;
name|ctx
operator|->
name|basic_blocks
operator|=
name|ctx
operator|->
name|basic_blocks
operator|->
name|next
expr_stmt|;
name|frags
operator|=
call|(
name|int
call|)
argument_list|(
name|total_size
operator|/
name|new_size
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|blocks
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|freefrags
operator|+=
name|frags
expr_stmt|;
comment|/* 	 * Set up a linked-list of blocks of size 	 * "new_size". 	 */
name|curr
operator|=
name|new
expr_stmt|;
name|next
operator|=
name|curr
operator|+
name|new_size
expr_stmt|;
name|total_size
operator|-=
name|new_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|frags
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
operator|(
name|element
operator|*
operator|)
name|next
expr_stmt|;
name|curr
operator|=
name|next
expr_stmt|;
name|next
operator|+=
name|new_size
expr_stmt|;
name|total_size
operator|-=
name|new_size
expr_stmt|;
block|}
comment|/* 	 * Add the remaining fragment of the basic block to a free list. 	 */
name|total_size
operator|=
name|rmsize
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_size
operator|>
literal|0U
condition|)
block|{
operator|(
operator|(
name|element
operator|*
operator|)
name|next
operator|)
operator|->
name|next
operator|=
name|ctx
operator|->
name|freelists
index|[
name|total_size
index|]
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|total_size
index|]
operator|=
operator|(
name|element
operator|*
operator|)
name|next
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|total_size
index|]
operator|.
name|freefrags
operator|++
expr_stmt|;
block|}
comment|/* 	 * curr is now pointing at the last block in the 	 * array. 	 */
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mem_getunlocked
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|new_size
init|=
name|quantize
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|ctx
operator|->
name|max_size
operator|||
name|new_size
operator|>=
name|ctx
operator|->
name|max_size
condition|)
block|{
comment|/* 		 * memget() was called on something beyond our upper limit. 		 */
if|if
condition|(
name|ctx
operator|->
name|quota
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|total
operator|+
name|size
operator|>
name|ctx
operator|->
name|quota
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ret
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ctx
operator|->
name|total
operator|+=
name|size
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|+=
name|size
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
comment|/* 		 * If we don't set new_size to size, then the 		 * ISC_MEM_FILL code might write over bytes we 		 * don't own. 		 */
name|new_size
operator|=
name|size
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * If there are no blocks in the free list for this size, get a chunk 	 * of memory and then break it up into "new_size"-sized blocks, adding 	 * them to the free list. 	 */
if|if
condition|(
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|==
name|NULL
operator|&&
operator|!
name|more_frags
argument_list|(
name|ctx
argument_list|,
name|new_size
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * The free list uses the "rounded-up" size "new_size". 	 */
name|ret
operator|=
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|=
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|->
name|next
expr_stmt|;
comment|/* 	 * The stats[] uses the _actual_ "size" requested by the 	 * caller, with the caveat (in the code above) that "size">= the 	 * max. size (max_size) ends up getting recorded as a call to 	 * max_size. 	 */
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|freefrags
operator|--
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|+=
name|new_size
expr_stmt|;
name|done
label|:
if|#
directive|if
name|ISC_MEM_FILL
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xbe
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "beef". */
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ISC_MEM_FILL
operator|&&
name|ISC_MEM_CHECKOVERRUN
end_if

begin_function
specifier|static
specifier|inline
name|void
name|check_overrun
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|new_size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mem
expr_stmt|;
name|cp
operator|+=
name|size
expr_stmt|;
while|while
condition|(
name|size
operator|<
name|new_size
condition|)
block|{
name|INSIST
argument_list|(
operator|*
name|cp
operator|==
literal|0xbe
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|mem_putunlocked
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|new_size
init|=
name|quantize
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|ctx
operator|->
name|max_size
operator|||
name|new_size
operator|>=
name|ctx
operator|->
name|max_size
condition|)
block|{
comment|/* 		 * memput() called on something beyond our upper limit. 		 */
if|#
directive|if
name|ISC_MEM_FILL
name|memset
argument_list|(
name|mem
argument_list|,
literal|0xde
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "dead". */
endif|#
directive|endif
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|!=
literal|0U
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|size
operator|<=
name|ctx
operator|->
name|total
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|-=
name|size
expr_stmt|;
name|ctx
operator|->
name|total
operator|-=
name|size
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|ISC_MEM_FILL
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
name|check_overrun
argument_list|(
name|mem
argument_list|,
name|size
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|mem
argument_list|,
literal|0xde
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "dead". */
endif|#
directive|endif
comment|/* 	 * The free list uses the "rounded-up" size "new_size". 	 */
operator|(
operator|(
name|element
operator|*
operator|)
name|mem
operator|)
operator|->
name|next
operator|=
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|=
operator|(
name|element
operator|*
operator|)
name|mem
expr_stmt|;
comment|/* 	 * The stats[] uses the _actual_ "size" requested by the 	 * caller, with the caveat (in the code above) that "size">= the 	 * max. size (max_size) ends up getting recorded as a call to 	 * max_size. 	 */
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|!=
literal|0U
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|freefrags
operator|++
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|-=
name|new_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*!  * Perform a malloc, doing memory filling and overrun detection as necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mem_get
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
name|size
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
if|#
directive|if
name|ISC_MEM_FILL
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xbe
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "beef". */
else|#
directive|else
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|ret
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|0xbe
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*!  * Perform a free, doing memory filling and overrun detection as necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mem_put
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
name|INSIST
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mem
operator|)
index|[
name|size
index|]
operator|==
literal|0xbe
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ISC_MEM_FILL
name|memset
argument_list|(
name|mem
argument_list|,
literal|0xde
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "dead". */
else|#
directive|else
name|UNUSED
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*!  * Update internal counters after a memory get.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mem_getstats
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|ctx
operator|->
name|total
operator|+=
name|size
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ctx
operator|->
name|max_size
condition|)
block|{
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*!  * Update internal counters after a memory put.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mem_putstats
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|inuse
operator|>=
name|size
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ctx
operator|->
name|max_size
condition|)
block|{
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Private.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|default_memalloc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0U
condition|)
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_memfree
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_action
parameter_list|(
name|void
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_mutex_init
argument_list|(
operator|&
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|contexts
argument_list|)
expr_stmt|;
name|totallost
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public.  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_createx
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_memalloc_t
name|memalloc
parameter_list|,
name|isc_memfree_t
name|memfree
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
return|return
operator|(
name|isc__mem_createx2
argument_list|(
name|init_max_size
argument_list|,
name|target_size
argument_list|,
name|memalloc
argument_list|,
name|memfree
argument_list|,
name|arg
argument_list|,
name|ctxp
argument_list|,
name|ISC_MEMFLAG_DEFAULT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_createx2
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_memalloc_t
name|memalloc
parameter_list|,
name|isc_memfree_t
name|memfree
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
operator|&&
operator|*
name|ctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|memalloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|memfree
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|ALIGNMENT_SIZE
operator|&
operator|(
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|initialize_action
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|ctx
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_MEMFLAG_NOLOCK
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
if|if
condition|(
name|init_max_size
operator|==
literal|0U
condition|)
name|ctx
operator|->
name|max_size
operator|=
name|DEF_MAX_SIZE
expr_stmt|;
else|else
name|ctx
operator|->
name|max_size
operator|=
name|init_max_size
expr_stmt|;
name|ctx
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ctx
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|quota
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|maxinuse
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|hi_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|lo_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
name|ctx
operator|->
name|is_overmem
operator|=
name|ISC_FALSE
expr_stmt|;
name|ctx
operator|->
name|water
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|water_arg
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|common
operator|.
name|impmagic
operator|=
name|MEM_MAGIC
expr_stmt|;
name|ctx
operator|->
name|common
operator|.
name|magic
operator|=
name|ISCAPI_MCTX_MAGIC
expr_stmt|;
name|ctx
operator|->
name|common
operator|.
name|methods
operator|=
operator|(
name|isc_memmethods_t
operator|*
operator|)
operator|&
name|memmethods
expr_stmt|;
name|isc_ondestroy_init
argument_list|(
operator|&
name|ctx
operator|->
name|ondestroy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|memalloc
operator|=
name|memalloc
expr_stmt|;
name|ctx
operator|->
name|memfree
operator|=
name|memfree
expr_stmt|;
name|ctx
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|ctx
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|checkfree
operator|=
name|ISC_TRUE
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|ctx
operator|->
name|debuglist
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|debuglistcnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ISC_LIST_INIT
argument_list|(
name|ctx
operator|->
name|pools
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|poolcnt
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|freelists
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|basic_blocks
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|basic_table
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|basic_table_count
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|basic_table_size
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|lowest
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|highest
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|stats
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|stats
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|ctx
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|target_size
operator|==
literal|0U
condition|)
name|ctx
operator|->
name|mem_target
operator|=
name|DEF_MEM_TARGET
expr_stmt|;
else|else
name|ctx
operator|->
name|mem_target
operator|=
name|target_size
expr_stmt|;
name|ctx
operator|->
name|freelists
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
operator|->
name|max_size
operator|*
sizeof|sizeof
argument_list|(
name|element
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|freelists
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|ctx
operator|->
name|freelists
argument_list|,
literal|0
argument_list|,
name|ctx
operator|->
name|max_size
operator|*
sizeof|sizeof
argument_list|(
name|element
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGRECORD
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|ctx
operator|->
name|debuglist
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|debuglist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctx
operator|->
name|memalloc_failures
operator|=
literal|0
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|contexts
argument_list|,
name|ctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
operator|*
name|ctxp
operator|=
operator|(
name|isc_mem_t
operator|*
operator|)
name|ctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|error
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|stats
operator|!=
name|NULL
condition|)
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
operator|->
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|freelists
operator|!=
name|NULL
condition|)
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
operator|->
name|freelists
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|debuglist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_TRACKLINES */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_NOLOCK
operator|)
operator|==
literal|0
condition|)
name|DESTROYLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_create
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
return|return
operator|(
name|isc__mem_createx2
argument_list|(
name|init_max_size
argument_list|,
name|target_size
argument_list|,
name|default_memalloc
argument_list|,
name|default_memfree
argument_list|,
name|NULL
argument_list|,
name|ctxp
argument_list|,
name|ISC_MEMFLAG_DEFAULT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_create2
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|isc__mem_createx2
argument_list|(
name|init_max_size
argument_list|,
name|target_size
argument_list|,
name|default_memalloc
argument_list|,
name|default_memfree
argument_list|,
name|NULL
argument_list|,
name|ctxp
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_ondestroy_t
name|ondest
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|contexts
argument_list|,
name|ctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|totallost
operator|+=
name|ctx
operator|->
name|inuse
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ctx
operator|->
name|pools
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|checkfree
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
condition|)
name|print_active
argument_list|(
name|ctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
init|;
name|dl
operator|!=
name|NULL
condition|;
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|,
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
block|}
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|debuglist
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|INSIST
argument_list|(
name|ctx
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|checkfree
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|stats
index|[
name|i
index|]
operator|.
name|gets
operator|!=
literal|0U
condition|)
name|print_active
argument_list|(
name|ctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|i
index|]
operator|.
name|gets
operator|==
literal|0U
argument_list|)
expr_stmt|;
block|}
block|}
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|basic_table_count
condition|;
name|i
operator|++
control|)
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|basic_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|freelists
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|basic_table
operator|!=
name|NULL
condition|)
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|basic_table
argument_list|)
expr_stmt|;
block|}
name|ondest
operator|=
name|ctx
operator|->
name|ondestroy
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_NOLOCK
operator|)
operator|==
literal|0
condition|)
name|DESTROYLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|isc_ondestroy_notify
argument_list|(
operator|&
name|ondest
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_attach
parameter_list|(
name|isc_mem_t
modifier|*
name|source0
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|source
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|source0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|source
argument_list|,
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|source
argument_list|,
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
operator|(
name|isc_mem_t
operator|*
operator|)
name|source
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_detach
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
name|isc_boolean_t
name|want_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|(
name|isc__mem_t
operator|*
operator|)
operator|*
name|ctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|references
operator|==
literal|0
condition|)
name|want_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_destroy
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|*
name|ctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * isc_mem_putanddetach() is the equivalent of:  *  * mctx = NULL;  * isc_mem_attach(ptr->mctx,&mctx);  * isc_mem_detach(&ptr->mctx);  * isc_mem_put(mctx, ptr, sizeof(*ptr);  * isc_mem_detach(&mctx);  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mem_putanddetach
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
name|isc_boolean_t
name|want_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|size_info
modifier|*
name|si
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|(
name|isc__mem_t
operator|*
operator|)
operator|*
name|ctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Must be before mem_putunlocked() as ctxp is usually within 	 * [ptr..ptr+size). 	 */
operator|*
name|ctxp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
operator|(
name|ISC_MEM_DEBUGSIZE
operator||
name|ISC_MEM_DEBUGCTX
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGSIZE
operator|)
operator|!=
literal|0
condition|)
block|{
name|si
operator|=
operator|&
operator|(
operator|(
operator|(
name|size_info
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|oldsize
operator|=
name|si
operator|->
name|u
operator|.
name|size
operator|-
name|ALIGNMENT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGCTX
operator|)
operator|!=
literal|0
condition|)
name|oldsize
operator|-=
name|ALIGNMENT_SIZE
expr_stmt|;
name|INSIST
argument_list|(
name|oldsize
operator|==
name|size
argument_list|)
expr_stmt|;
block|}
name|isc__mem_free
argument_list|(
argument|(isc_mem_t *)ctx
argument_list|,
argument|ptr FLARG_PASS
argument_list|)
empty_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|references
operator|==
literal|0
condition|)
name|want_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_destroy
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem_put
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|DELETE_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|references
operator|==
literal|0
condition|)
name|want_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_destroy
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_destroy
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
comment|/* 	 * This routine provides legacy support for callers who use mctxs 	 * without attaching/detaching. 	 */
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|(
name|isc__mem_t
operator|*
operator|)
operator|*
name|ctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|references
operator|!=
literal|1
condition|)
name|print_active
argument_list|(
name|ctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|references
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|*
name|ctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mem_ondestroy
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|event
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|isc_result_t
name|res
decl_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|isc_ondestroy_register
argument_list|(
operator|&
name|ctx
operator|->
name|ondestroy
argument_list|,
name|task
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mem_get
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|isc_boolean_t
name|call_water
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
operator|(
name|ISC_MEM_DEBUGSIZE
operator||
name|ISC_MEM_DEBUGCTX
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|isc__mem_allocate
argument_list|(
argument|ctx0
argument_list|,
argument|size FLARG_PASS
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem_getunlocked
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|mem_get
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|mem_getstats
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|ADD_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
operator|&&
operator|!
name|ctx
operator|->
name|is_overmem
condition|)
block|{
name|ctx
operator|->
name|is_overmem
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
operator|!
name|ctx
operator|->
name|hi_called
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
condition|)
block|{
name|call_water
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|maxinuse
condition|)
block|{
name|ctx
operator|->
name|maxinuse
operator|=
name|ctx
operator|->
name|inuse
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
operator|&&
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGUSAGE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maxinuse = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ctx
operator|->
name|inuse
argument_list|)
expr_stmt|;
block|}
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_water
condition|)
call|(
name|ctx
operator|->
name|water
call|)
argument_list|(
name|ctx
operator|->
name|water_arg
argument_list|,
name|ISC_MEM_HIWATER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mem_put
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|isc_boolean_t
name|call_water
init|=
name|ISC_FALSE
decl_stmt|;
name|size_info
modifier|*
name|si
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
operator|(
name|ISC_MEM_DEBUGSIZE
operator||
name|ISC_MEM_DEBUGCTX
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGSIZE
operator|)
operator|!=
literal|0
condition|)
block|{
name|si
operator|=
operator|&
operator|(
operator|(
operator|(
name|size_info
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|oldsize
operator|=
name|si
operator|->
name|u
operator|.
name|size
operator|-
name|ALIGNMENT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGCTX
operator|)
operator|!=
literal|0
condition|)
name|oldsize
operator|-=
name|ALIGNMENT_SIZE
expr_stmt|;
name|INSIST
argument_list|(
name|oldsize
operator|==
name|size
argument_list|)
expr_stmt|;
block|}
name|isc__mem_free
argument_list|(
argument|(isc_mem_t *)ctx
argument_list|,
argument|ptr FLARG_PASS
argument_list|)
empty_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem_put
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|DELETE_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * The check against ctx->lo_water == 0 is for the condition 	 * when the context was pushed over hi_water but then had 	 * isc_mem_setwater() called with 0 for hi_water and lo_water. 	 */
if|if
condition|(
name|ctx
operator|->
name|is_overmem
operator|&&
operator|(
name|ctx
operator|->
name|inuse
operator|<
name|ctx
operator|->
name|lo_water
operator|||
name|ctx
operator|->
name|lo_water
operator|==
literal|0U
operator|)
condition|)
block|{
name|ctx
operator|->
name|is_overmem
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|hi_called
operator|&&
operator|(
name|ctx
operator|->
name|inuse
operator|<
name|ctx
operator|->
name|lo_water
operator|||
name|ctx
operator|->
name|lo_water
operator|==
literal|0U
operator|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|water
operator|!=
name|NULL
condition|)
name|call_water
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_water
condition|)
call|(
name|ctx
operator|->
name|water
call|)
argument_list|(
name|ctx
operator|->
name|water_arg
argument_list|,
name|ISC_MEM_LOWATER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_waterack
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|ISC_MEM_LOWATER
condition|)
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|==
name|ISC_MEM_HIWATER
condition|)
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_TRUE
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_function
specifier|static
name|void
name|print_active
parameter_list|(
name|isc__mem_t
modifier|*
name|mctx
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
if|if
condition|(
name|mctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|isc_boolean_t
name|found
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_DUMPALLOC
argument_list|,
literal|"Dump of all outstanding "
literal|"memory allocations:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
name|format
operator|=
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_PTRFILELINE
argument_list|,
literal|"\tptr %p size %u file %s line %u\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|!=
name|NULL
condition|)
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
while|while
condition|(
name|dl
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DEBUGLIST_COUNT
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dl
operator|->
name|ptr
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
name|format
argument_list|,
name|dl
operator|->
name|ptr
index|[
name|j
index|]
argument_list|,
name|dl
operator|->
name|size
index|[
name|j
index|]
argument_list|,
name|dl
operator|->
name|file
index|[
name|j
index|]
argument_list|,
name|dl
operator|->
name|line
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|dl
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_NONE
argument_list|,
literal|"\tNone.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print the stats[] on the stream "out" with suitable formatting.  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_stats
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|const
name|struct
name|stats
modifier|*
name|s
decl_stmt|;
specifier|const
name|isc__mempool_t
modifier|*
name|pool
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ctx
operator|->
name|stats
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|totalgets
operator|==
literal|0U
operator|&&
name|s
operator|->
name|gets
operator|==
literal|0U
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%5lu: %11lu gets, %11lu rem"
argument_list|,
operator|(
name|i
operator|==
name|ctx
operator|->
name|max_size
operator|)
condition|?
literal|">="
else|:
literal|"  "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|,
name|s
operator|->
name|totalgets
argument_list|,
name|s
operator|->
name|gets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|->
name|blocks
operator|!=
literal|0U
operator|||
name|s
operator|->
name|freefrags
operator|!=
literal|0U
operator|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" (%lu bl, %lu ff)"
argument_list|,
name|s
operator|->
name|blocks
argument_list|,
name|s
operator|->
name|freefrags
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that since a pool can be locked now, these stats might be 	 * somewhat off if the pool is in active use at the time the stats 	 * are dumped.  The link fields are protected by the isc_mem_t's 	 * lock, however, so walking this list and extracting integers from 	 * stats fields is always safe. 	 */
name|pool
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ctx
operator|->
name|pools
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLSTATS
argument_list|,
literal|"[Pool statistics]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%15s %10s %10s %10s %10s %10s %10s %10s %1s\n"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLNAME
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLSIZE
argument_list|,
literal|"size"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLMAXALLOC
argument_list|,
literal|"maxalloc"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLALLOCATED
argument_list|,
literal|"allocated"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLFREECOUNT
argument_list|,
literal|"freecount"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLFREEMAX
argument_list|,
literal|"freemax"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLFILLCOUNT
argument_list|,
literal|"fillcount"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLGETS
argument_list|,
literal|"gets"
argument_list|)
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%15s %10lu %10u %10u %10u %10u %10u %10u %s\n"
argument_list|,
if|#
directive|if
name|ISC_MEMPOOL_NAMES
name|pool
operator|->
name|name
argument_list|,
else|#
directive|else
literal|"(not tracked)"
argument_list|,
endif|#
directive|endif
operator|(
name|unsigned
name|long
operator|)
name|pool
operator|->
name|size
argument_list|,
name|pool
operator|->
name|maxalloc
argument_list|,
name|pool
operator|->
name|allocated
argument_list|,
name|pool
operator|->
name|freecount
argument_list|,
name|pool
operator|->
name|freemax
argument_list|,
name|pool
operator|->
name|fillcount
argument_list|,
name|pool
operator|->
name|gets
argument_list|,
operator|(
name|pool
operator|->
name|lock
operator|==
name|NULL
condition|?
literal|"N"
else|:
literal|"Y"
operator|)
argument_list|)
expr_stmt|;
name|pool
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|pool
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|print_active
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replacements for malloc() and free() -- they implicitly remember the  * size of the object allocated (with some additional overhead).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|isc__mem_allocateunlocked
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|size_info
modifier|*
name|si
decl_stmt|;
name|size
operator|+=
name|ALIGNMENT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGCTX
operator|)
operator|!=
literal|0
condition|)
name|size
operator|+=
name|ALIGNMENT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
name|si
operator|=
name|mem_getunlocked
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|si
operator|=
name|mem_get
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGCTX
operator|)
operator|!=
literal|0
condition|)
block|{
name|si
operator|->
name|u
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|si
operator|++
expr_stmt|;
block|}
name|si
operator|->
name|u
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
operator|(
operator|&
name|si
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mem_allocate
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|size_info
modifier|*
name|si
decl_stmt|;
name|isc_boolean_t
name|call_water
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|si
operator|=
name|isc__mem_allocateunlocked
argument_list|(
operator|(
name|isc_mem_t
operator|*
operator|)
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|si
operator|=
name|isc__mem_allocateunlocked
argument_list|(
operator|(
name|isc_mem_t
operator|*
operator|)
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
name|mem_getstats
argument_list|(
name|ctx
argument_list|,
name|si
index|[
operator|-
literal|1
index|]
operator|.
name|u
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|ADD_TRACE
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|si
index|[
operator|-
literal|1
index|]
operator|.
name|u
operator|.
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
operator|&&
operator|!
name|ctx
operator|->
name|is_overmem
condition|)
block|{
name|ctx
operator|->
name|is_overmem
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
operator|!
name|ctx
operator|->
name|hi_called
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
condition|)
block|{
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_TRUE
expr_stmt|;
name|call_water
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|maxinuse
condition|)
block|{
name|ctx
operator|->
name|maxinuse
operator|=
name|ctx
operator|->
name|inuse
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
operator|&&
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGUSAGE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maxinuse = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ctx
operator|->
name|inuse
argument_list|)
expr_stmt|;
block|}
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_water
condition|)
call|(
name|ctx
operator|->
name|water
call|)
argument_list|(
name|ctx
operator|->
name|water_arg
argument_list|,
name|ISC_MEM_HIWATER
argument_list|)
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mem_reallocate
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|void
modifier|*
name|new_ptr
init|=
name|NULL
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|,
name|copysize
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This function emulates the realloc(3) standard library function: 	 * - if size> 0, allocate new memory; and if ptr is non NULL, copy 	 *   as much of the old contents to the new buffer and free the old one. 	 *   Note that when allocation fails the original pointer is intact; 	 *   the caller must free it. 	 * - if size is 0 and ptr is non NULL, simply free the given ptr. 	 * - this function returns: 	 *     pointer to the newly allocated memory, or 	 *     NULL if allocation fails or doesn't happen. 	 */
if|if
condition|(
name|size
operator|>
literal|0U
condition|)
block|{
name|new_ptr
operator|=
name|isc__mem_allocate
argument_list|(
argument|ctx0
argument_list|,
argument|size FLARG_PASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ptr
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|oldsize
operator|=
operator|(
operator|(
operator|(
name|size_info
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
literal|1
index|]
operator|)
operator|.
name|u
operator|.
name|size
expr_stmt|;
name|INSIST
argument_list|(
name|oldsize
operator|>=
name|ALIGNMENT_SIZE
argument_list|)
expr_stmt|;
name|oldsize
operator|-=
name|ALIGNMENT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGCTX
operator|)
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|oldsize
operator|>=
name|ALIGNMENT_SIZE
argument_list|)
expr_stmt|;
name|oldsize
operator|-=
name|ALIGNMENT_SIZE
expr_stmt|;
block|}
name|copysize
operator|=
operator|(
name|oldsize
operator|>
name|size
operator|)
condition|?
name|size
else|:
name|oldsize
expr_stmt|;
name|memmove
argument_list|(
name|new_ptr
argument_list|,
name|ptr
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|isc__mem_free
argument_list|(
argument|ctx0
argument_list|,
argument|ptr FLARG_PASS
argument_list|)
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|isc__mem_free
argument_list|(
argument|ctx0
argument_list|,
argument|ptr FLARG_PASS
argument_list|)
empty_stmt|;
return|return
operator|(
name|new_ptr
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mem_free
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|void
modifier|*
name|ptr
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|size_info
modifier|*
name|si
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|isc_boolean_t
name|call_water
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGCTX
operator|)
operator|!=
literal|0
condition|)
block|{
name|si
operator|=
operator|&
operator|(
operator|(
operator|(
name|size_info
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|si
operator|->
name|u
operator|.
name|ctx
operator|==
name|ctx
argument_list|)
expr_stmt|;
name|size
operator|=
name|si
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|si
operator|=
operator|&
operator|(
operator|(
operator|(
name|size_info
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|size
operator|=
name|si
operator|->
name|u
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem_put
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|DELETE_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * The check against ctx->lo_water == 0 is for the condition 	 * when the context was pushed over hi_water but then had 	 * isc_mem_setwater() called with 0 for hi_water and lo_water. 	 */
if|if
condition|(
name|ctx
operator|->
name|is_overmem
operator|&&
operator|(
name|ctx
operator|->
name|inuse
operator|<
name|ctx
operator|->
name|lo_water
operator|||
name|ctx
operator|->
name|lo_water
operator|==
literal|0U
operator|)
condition|)
block|{
name|ctx
operator|->
name|is_overmem
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|hi_called
operator|&&
operator|(
name|ctx
operator|->
name|inuse
operator|<
name|ctx
operator|->
name|lo_water
operator|||
name|ctx
operator|->
name|lo_water
operator|==
literal|0U
operator|)
condition|)
block|{
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|water
operator|!=
name|NULL
condition|)
name|call_water
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_water
condition|)
call|(
name|ctx
operator|->
name|water
call|)
argument_list|(
name|ctx
operator|->
name|water_arg
argument_list|,
name|ISC_MEM_LOWATER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Other useful things.  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|char
modifier|*
name|isc___mem_strdup
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx0
parameter_list|,
specifier|const
name|char
modifier|*
name|s
name|FLARG
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|mctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|mctx0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|ns
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ns
operator|=
name|isc___mem_allocate
argument_list|(
operator|(
name|isc_mem_t
operator|*
operator|)
name|mctx
argument_list|,
name|len
operator|+
literal|1
name|FLARG_PASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|ns
argument_list|,
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ns
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setdestroycheck
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|isc_boolean_t
name|flag
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|checkfree
operator|=
name|flag
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quotas  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setquota
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|size_t
name|quota
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|quota
operator|=
name|quota
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|size_t
name|isc__mem_getquota
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|size_t
name|quota
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|quota
operator|=
name|ctx
operator|->
name|quota
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|quota
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|size_t
name|isc__mem_inuse
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|size_t
name|inuse
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inuse
operator|=
name|ctx
operator|->
name|inuse
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|inuse
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setwater
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|isc_mem_water_t
name|water
parameter_list|,
name|void
modifier|*
name|water_arg
parameter_list|,
name|size_t
name|hiwater
parameter_list|,
name|size_t
name|lowater
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|isc_boolean_t
name|callwater
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_mem_water_t
name|oldwater
decl_stmt|;
name|void
modifier|*
name|oldwater_arg
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|hiwater
operator|>=
name|lowater
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|oldwater
operator|=
name|ctx
operator|->
name|water
expr_stmt|;
name|oldwater_arg
operator|=
name|ctx
operator|->
name|water_arg
expr_stmt|;
if|if
condition|(
name|water
operator|==
name|NULL
condition|)
block|{
name|callwater
operator|=
name|ctx
operator|->
name|hi_called
expr_stmt|;
name|ctx
operator|->
name|water
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|water_arg
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|hi_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|lo_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|->
name|hi_called
operator|&&
operator|(
name|ctx
operator|->
name|water
operator|!=
name|water
operator|||
name|ctx
operator|->
name|water_arg
operator|!=
name|water_arg
operator|||
name|ctx
operator|->
name|inuse
operator|<
name|lowater
operator|||
name|lowater
operator|==
literal|0U
operator|)
condition|)
name|callwater
operator|=
name|ISC_TRUE
expr_stmt|;
name|ctx
operator|->
name|water
operator|=
name|water
expr_stmt|;
name|ctx
operator|->
name|water_arg
operator|=
name|water_arg
expr_stmt|;
name|ctx
operator|->
name|hi_water
operator|=
name|hiwater
expr_stmt|;
name|ctx
operator|->
name|lo_water
operator|=
name|lowater
expr_stmt|;
block|}
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|callwater
operator|&&
name|oldwater
operator|!=
name|NULL
condition|)
call|(
name|oldwater
call|)
argument_list|(
name|oldwater_arg
argument_list|,
name|ISC_MEM_LOWATER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_boolean_t
name|isc__mem_isovermem
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We don't bother to lock the context because 100% accuracy isn't 	 * necessary (and even if we locked the context the returned value 	 * could be different from the actual state when it's used anyway) 	 */
return|return
operator|(
name|ctx
operator|->
name|is_overmem
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_setname
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
specifier|const
name|char
modifier|*
name|isc__mem_getname
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctx
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc__mem_gettag
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctx
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Memory pool stuff  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|isc_result_t
name|isc__mempool_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx0
parameter_list|,
name|size_t
name|size
parameter_list|,
name|isc_mempool_t
modifier|*
modifier|*
name|mpctxp
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|mctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|mctx0
decl_stmt|;
name|isc__mempool_t
modifier|*
name|mpctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|size
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mpctxp
operator|!=
name|NULL
operator|&&
operator|*
name|mpctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for this pool, initialize values, and if all works 	 * well, attach to the memory context. 	 */
name|mpctx
operator|=
name|isc_mem_get
argument_list|(
operator|(
name|isc_mem_t
operator|*
operator|)
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc__mempool_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|mpctx
operator|->
name|common
operator|.
name|methods
operator|=
operator|(
name|isc_mempoolmethods_t
operator|*
operator|)
operator|&
name|mempoolmethods
expr_stmt|;
name|mpctx
operator|->
name|common
operator|.
name|impmagic
operator|=
name|MEMPOOL_MAGIC
expr_stmt|;
name|mpctx
operator|->
name|common
operator|.
name|magic
operator|=
name|ISCAPI_MPOOL_MAGIC
expr_stmt|;
name|mpctx
operator|->
name|lock
operator|=
name|NULL
expr_stmt|;
name|mpctx
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|mpctx
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|mpctx
operator|->
name|maxalloc
operator|=
name|UINT_MAX
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|=
literal|0
expr_stmt|;
name|mpctx
operator|->
name|freemax
operator|=
literal|1
expr_stmt|;
name|mpctx
operator|->
name|fillcount
operator|=
literal|1
expr_stmt|;
name|mpctx
operator|->
name|gets
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|ISC_MEMPOOL_NAMES
name|mpctx
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|mpctx
operator|->
name|items
operator|=
name|NULL
expr_stmt|;
operator|*
name|mpctxp
operator|=
operator|(
name|isc_mempool_t
operator|*
operator|)
name|mpctx
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|mctx
operator|->
name|pools
argument_list|,
name|mpctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|poolcnt
operator|++
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setname
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEMPOOL_NAMES
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mpctx
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mpctx
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|mpctx
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|mpctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_destroy
parameter_list|(
name|isc_mempool_t
modifier|*
modifier|*
name|mpctxp
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
decl_stmt|;
name|isc__mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
name|element
modifier|*
name|item
decl_stmt|;
name|REQUIRE
argument_list|(
name|mpctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mpctx
operator|=
operator|(
name|isc__mempool_t
operator|*
operator|)
operator|*
name|mpctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEMPOOL_NAMES
if|if
condition|(
name|mpctx
operator|->
name|allocated
operator|>
literal|0
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc__mempool_destroy(): mempool %s "
literal|"leaked memory"
argument_list|,
name|mpctx
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|mpctx
operator|->
name|allocated
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|mpctx
operator|->
name|mctx
expr_stmt|;
name|lock
operator|=
name|mpctx
operator|->
name|lock
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Return any items on the free list 	 */
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|mpctx
operator|->
name|items
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|mpctx
operator|->
name|freecount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|--
expr_stmt|;
name|item
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
name|mpctx
operator|->
name|items
operator|=
name|item
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|mctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|mem_putunlocked
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem_put
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remove our linked list entry from the memory context. 	 */
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|mctx
operator|->
name|pools
argument_list|,
name|mpctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|poolcnt
operator|--
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|mpctx
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
operator|(
name|isc_mem_t
operator|*
operator|)
name|mpctx
operator|->
name|mctx
argument_list|,
name|mpctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc__mempool_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
operator|*
name|mpctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_associatelock
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|,
name|isc_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mpctx
operator|->
name|lock
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|lock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
modifier|*
name|isc___mempool_get
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
name|FLARG
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|element
modifier|*
name|item
decl_stmt|;
name|isc__mem_t
modifier|*
name|mctx
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|mpctx
operator|->
name|mctx
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Don't let the caller go over quota 	 */
if|if
condition|(
name|mpctx
operator|->
name|allocated
operator|>=
name|mpctx
operator|->
name|maxalloc
condition|)
block|{
name|item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * if we have a free list item, return the first here 	 */
name|item
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|mpctx
operator|->
name|items
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|INSIST
argument_list|(
name|mpctx
operator|->
name|freecount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|--
expr_stmt|;
name|mpctx
operator|->
name|gets
operator|++
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We need to dip into the well.  Lock the memory context here and 	 * fill up our free list. 	 */
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mpctx
operator|->
name|fillcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|item
operator|=
name|mem_getunlocked
argument_list|(
name|mctx
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|mem_get
argument_list|(
name|mctx
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
name|mem_getstats
argument_list|(
name|mctx
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
break|break;
name|item
operator|->
name|next
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
name|mpctx
operator|->
name|items
operator|=
name|item
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|++
expr_stmt|;
block|}
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't get any items, return NULL. 	 */
name|item
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|mpctx
operator|->
name|items
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|--
expr_stmt|;
name|mpctx
operator|->
name|gets
operator|++
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|++
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ADD_TRACE
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISC_MEM_TRACKLINES */
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc___mempool_put
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|,
name|void
modifier|*
name|mem
name|FLARG
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|isc__mem_t
modifier|*
name|mctx
decl_stmt|;
name|element
modifier|*
name|item
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mem
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|mpctx
operator|->
name|mctx
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|mpctx
operator|->
name|allocated
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|--
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DELETE_TRACE
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_TRACKLINES */
comment|/* 	 * If our free list is full, return this to the mctx directly. 	 */
if|if
condition|(
name|mpctx
operator|->
name|freecount
operator|>=
name|mpctx
operator|->
name|freemax
condition|)
block|{
if|if
condition|(
operator|(
name|mctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem_put
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|mctx
argument_list|,
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, attach it to our free list and bump the counter. 	 */
name|mpctx
operator|->
name|freecount
operator|++
expr_stmt|;
name|item
operator|=
operator|(
name|element
operator|*
operator|)
name|mem
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
name|mpctx
operator|->
name|items
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quotas  */
end_comment

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setfreemax
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|freemax
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getfreemax
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|unsigned
name|int
name|freemax
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|freemax
operator|=
name|mpctx
operator|->
name|freemax
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|freemax
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getfreecount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|unsigned
name|int
name|freecount
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|freecount
operator|=
name|mpctx
operator|->
name|freecount
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|freecount
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setmaxalloc
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|limit
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|maxalloc
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getmaxalloc
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|unsigned
name|int
name|maxalloc
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|maxalloc
operator|=
name|mpctx
operator|->
name|maxalloc
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxalloc
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getallocated
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|unsigned
name|int
name|allocated
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|allocated
operator|=
name|mpctx
operator|->
name|allocated
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|allocated
operator|)
return|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mempool_setfillcount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|limit
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|fillcount
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc__mempool_getfillcount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx0
parameter_list|)
block|{
name|isc__mempool_t
modifier|*
name|mpctx
init|=
operator|(
name|isc__mempool_t
operator|*
operator|)
name|mpctx0
decl_stmt|;
name|unsigned
name|int
name|fillcount
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fillcount
operator|=
name|mpctx
operator|->
name|fillcount
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|fillcount
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MEMIMPREGISTER
end_ifdef

begin_function
name|isc_result_t
name|isc__mem_register
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|isc_mem_register
argument_list|(
name|isc__mem_create2
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_printactive
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|file
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|print_active
argument_list|(
name|ctx
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|ctx0
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_printallactive
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
operator|!
name|ISC_MEM_TRACKLINES
name|UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|initialize_action
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|contexts
argument_list|)
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ctx
argument_list|,
name|link
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"context: %p\n"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|print_active
argument_list|(
name|ctx
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|void
name|isc__mem_checkdestroyed
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
operator|!
name|ISC_MEM_TRACKLINES
name|UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|initialize_action
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|contexts
argument_list|)
condition|)
block|{
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
for|for
control|(
name|ctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|contexts
argument_list|)
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ctx
argument_list|,
name|link
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"context: %p\n"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|print_active
argument_list|(
name|ctx
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_MEMFUNC_SCOPE
name|unsigned
name|int
name|isc_mem_references
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx0
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
init|=
operator|(
name|isc__mem_t
operator|*
operator|)
name|ctx0
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|references
operator|=
name|ctx
operator|->
name|references
expr_stmt|;
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|references
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBXML2
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|summarystat
block|{
name|isc_uint64_t
name|total
decl_stmt|;
name|isc_uint64_t
name|inuse
decl_stmt|;
name|isc_uint64_t
name|blocksize
decl_stmt|;
name|isc_uint64_t
name|contextsize
decl_stmt|;
block|}
name|summarystat_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRY0
parameter_list|(
name|a
parameter_list|)
value|do { xmlrc = (a); if (xmlrc< 0) goto error; } while(0)
end_define

begin_function
specifier|static
name|int
name|renderctx
parameter_list|(
name|isc__mem_t
modifier|*
name|ctx
parameter_list|,
name|summarystat_t
modifier|*
name|summary
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|)
block|{
name|int
name|xmlrc
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|MCTXLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"context"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"id"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%p"
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* id */
if|if
condition|(
name|ctx
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%s"
argument_list|,
name|ctx
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* name */
block|}
name|summary
operator|->
name|contextsize
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
operator|+
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stats
argument_list|)
operator|+
name|ctx
operator|->
name|max_size
operator|*
sizeof|sizeof
argument_list|(
name|element
operator|*
argument_list|)
operator|+
name|ctx
operator|->
name|basic_table_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
block|{
name|summary
operator|->
name|contextsize
operator|+=
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|debuglist_t
argument_list|)
operator|+
name|ctx
operator|->
name|debuglistcnt
operator|*
sizeof|sizeof
argument_list|(
name|debuglink_t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"references"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%d"
argument_list|,
name|ctx
operator|->
name|references
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* references */
name|summary
operator|->
name|total
operator|+=
name|ctx
operator|->
name|total
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"total"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
operator|(
name|isc_uint64_t
operator|)
name|ctx
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* total */
name|summary
operator|->
name|inuse
operator|+=
name|ctx
operator|->
name|inuse
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"inuse"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
operator|(
name|isc_uint64_t
operator|)
name|ctx
operator|->
name|inuse
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* inuse */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"maxinuse"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
operator|(
name|isc_uint64_t
operator|)
name|ctx
operator|->
name|maxinuse
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* maxinuse */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"blocksize"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|ISC_MEMFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|summary
operator|->
name|blocksize
operator|+=
name|ctx
operator|->
name|basic_table_count
operator|*
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
operator|(
name|isc_uint64_t
operator|)
name|ctx
operator|->
name|basic_table_count
operator|*
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%s"
argument_list|,
literal|"-"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* blocksize */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"pools"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%u"
argument_list|,
name|ctx
operator|->
name|poolcnt
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pools */
name|summary
operator|->
name|contextsize
operator|+=
name|ctx
operator|->
name|poolcnt
operator|*
sizeof|sizeof
argument_list|(
name|isc_mempool_t
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"hiwater"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
operator|(
name|isc_uint64_t
operator|)
name|ctx
operator|->
name|hi_water
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hiwater */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"lowater"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
operator|(
name|isc_uint64_t
operator|)
name|ctx
operator|->
name|lo_water
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lowater */
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* context */
name|error
label|:
name|MCTXUNLOCK
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|xmlrc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isc_mem_renderxml
parameter_list|(
name|xmlTextWriterPtr
name|writer
parameter_list|)
block|{
name|isc__mem_t
modifier|*
name|ctx
decl_stmt|;
name|summarystat_t
name|summary
decl_stmt|;
name|isc_uint64_t
name|lost
decl_stmt|;
name|int
name|xmlrc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|summary
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|summary
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"contexts"
argument_list|)
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|initialize_action
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
name|lost
operator|=
name|totallost
expr_stmt|;
for|for
control|(
name|ctx
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|contexts
argument_list|)
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ctx
argument_list|,
name|link
argument_list|)
control|)
block|{
name|xmlrc
operator|=
name|renderctx
argument_list|(
name|ctx
argument_list|,
operator|&
name|summary
argument_list|,
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmlrc
operator|<
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* contexts */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"summary"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"TotalUse"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
name|summary
operator|.
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TotalUse */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"InUse"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
name|summary
operator|.
name|inuse
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* InUse */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"BlockSize"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
name|summary
operator|.
name|blocksize
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* BlockSize */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"ContextSize"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
name|summary
operator|.
name|contextsize
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ContextSize */
name|TRY0
argument_list|(
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"Lost"
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
name|lost
argument_list|)
argument_list|)
expr_stmt|;
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Lost */
name|TRY0
argument_list|(
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* summary */
name|error
label|:
return|return
operator|(
name|xmlrc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBXML2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

end_unit

