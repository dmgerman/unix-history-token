begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1997-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: mem.c,v 1.98.2.7.2.7 2005/03/17 03:58:32 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/ondestroy.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_MEM_DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|ISC_MEM_DEBUGGING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|LIBISC_EXTERNAL_DATA
name|unsigned
name|int
name|isc_mem_debugging
init|=
name|ISC_MEM_DEBUGGING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Define ISC_MEM_USE_INTERNAL_MALLOC=1 to use the internal malloc()  * implementation in preference to the system one.  The internal malloc()  * is very space-efficient, and quite fast on uniprocessor systems.  It  * performs poorly on multiprocessor machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_MEM_USE_INTERNAL_MALLOC
end_ifndef

begin_define
define|#
directive|define
name|ISC_MEM_USE_INTERNAL_MALLOC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Constants.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MAX_SIZE
value|1100
end_define

begin_define
define|#
directive|define
name|DEF_MEM_TARGET
value|4096
end_define

begin_define
define|#
directive|define
name|ALIGNMENT_SIZE
value|8
end_define

begin_comment
comment|/* must be a power of 2 */
end_comment

begin_define
define|#
directive|define
name|NUM_BASIC_BLOCKS
value|64
end_define

begin_comment
comment|/* must be> 1 */
end_comment

begin_define
define|#
directive|define
name|TABLE_INCREMENT
value|1024
end_define

begin_define
define|#
directive|define
name|DEBUGLIST_COUNT
value|1024
end_define

begin_comment
comment|/*  * Types.  */
end_comment

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_typedef
typedef|typedef
name|struct
name|debuglink
name|debuglink_t
typedef|;
end_typedef

begin_struct
struct|struct
name|debuglink
block|{
name|ISC_LINK
argument_list|(
argument|debuglink_t
argument_list|)
name|link
expr_stmt|;
specifier|const
name|void
modifier|*
name|ptr
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
name|unsigned
name|int
name|size
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
name|unsigned
name|int
name|line
index|[
name|DEBUGLIST_COUNT
index|]
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FLARG_PASS
value|, file, line
end_define

begin_define
define|#
directive|define
name|FLARG
value|, const char *file, int line
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FLARG_PASS
end_define

begin_define
define|#
directive|define
name|FLARG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|element
name|element
typedef|;
end_typedef

begin_struct
struct|struct
name|element
block|{
name|element
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* 	 * This structure must be ALIGNMENT_SIZE bytes. 	 */
union|union
block|{
name|size_t
name|size
decl_stmt|;
name|char
name|bytes
index|[
name|ALIGNMENT_SIZE
index|]
decl_stmt|;
block|}
name|u
union|;
block|}
name|size_info
typedef|;
end_typedef

begin_struct
struct|struct
name|stats
block|{
name|unsigned
name|long
name|gets
decl_stmt|;
name|unsigned
name|long
name|totalgets
decl_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|unsigned
name|long
name|blocks
decl_stmt|;
name|unsigned
name|long
name|freefrags
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MEM_MAGIC
value|ISC_MAGIC('M', 'e', 'm', 'C')
end_define

begin_define
define|#
directive|define
name|VALID_CONTEXT
parameter_list|(
name|c
parameter_list|)
value|ISC_MAGIC_VALID(c, MEM_MAGIC)
end_define

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|debuglink_t
argument_list|)
name|debuglist_t
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|isc_mem
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_ondestroy_t
name|ondestroy
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_memalloc_t
name|memalloc
decl_stmt|;
name|isc_memfree_t
name|memfree
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|size_t
name|max_size
decl_stmt|;
name|isc_boolean_t
name|checkfree
decl_stmt|;
name|struct
name|stats
modifier|*
name|stats
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|size_t
name|quota
decl_stmt|;
name|size_t
name|total
decl_stmt|;
name|size_t
name|inuse
decl_stmt|;
name|size_t
name|maxinuse
decl_stmt|;
name|size_t
name|hi_water
decl_stmt|;
name|size_t
name|lo_water
decl_stmt|;
name|isc_boolean_t
name|hi_called
decl_stmt|;
name|isc_mem_water_t
name|water
decl_stmt|;
name|void
modifier|*
name|water_arg
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_mempool_t
argument_list|)
name|pools
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|size_t
name|mem_target
decl_stmt|;
name|element
modifier|*
modifier|*
name|freelists
decl_stmt|;
name|element
modifier|*
name|basic_blocks
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|basic_table
decl_stmt|;
name|unsigned
name|int
name|basic_table_count
decl_stmt|;
name|unsigned
name|int
name|basic_table_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lowest
decl_stmt|;
name|unsigned
name|char
modifier|*
name|highest
decl_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|debuglist_t
modifier|*
name|debuglist
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|memalloc_failures
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MEMPOOL_MAGIC
value|ISC_MAGIC('M', 'E', 'M', 'p')
end_define

begin_define
define|#
directive|define
name|VALID_MEMPOOL
parameter_list|(
name|c
parameter_list|)
value|ISC_MAGIC_VALID(c, MEMPOOL_MAGIC)
end_define

begin_struct
struct|struct
name|isc_mempool
block|{
comment|/* always unlocked */
name|unsigned
name|int
name|magic
decl_stmt|;
comment|/* magic number */
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
comment|/* optional lock */
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* our memory context */
comment|/* locked via the memory context's lock */
name|ISC_LINK
argument_list|(
argument|isc_mempool_t
argument_list|)
name|link
expr_stmt|;
comment|/* next pool in this mem context */
comment|/* optionally locked from here down */
name|element
modifier|*
name|items
decl_stmt|;
comment|/* low water item list */
name|size_t
name|size
decl_stmt|;
comment|/* size of each item on this pool */
name|unsigned
name|int
name|maxalloc
decl_stmt|;
comment|/* max number of items allowed */
name|unsigned
name|int
name|allocated
decl_stmt|;
comment|/* # of items currently given out */
name|unsigned
name|int
name|freecount
decl_stmt|;
comment|/* # of items on reserved list */
name|unsigned
name|int
name|freemax
decl_stmt|;
comment|/* # of items allowed on free list */
name|unsigned
name|int
name|fillcount
decl_stmt|;
comment|/* # of items to fetch on each fill */
comment|/* Stats only. */
name|unsigned
name|int
name|gets
decl_stmt|;
comment|/* # of requests to this pool */
comment|/* Debugging only. */
if|#
directive|if
name|ISC_MEMPOOL_NAMES
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* printed name in stats reports */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Private Inline-able.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|ISC_MEM_TRACKLINES
end_if

begin_define
define|#
directive|define
name|ADD_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DELETE_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ADD_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
define|\
value|do { \ 		if ((isc_mem_debugging& (ISC_MEM_DEBUGTRACE | \ 					  ISC_MEM_DEBUGRECORD)) != 0&& \ 		     b != NULL) \ 		         add_trace_entry(a, b, c, d, e); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|DELETE_TRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|delete_trace_entry(a, b, c, d, e)
end_define

begin_function_decl
specifier|static
name|void
name|print_active
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * mctx must be locked.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_trace_entry
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|int
name|size
name|FLARG
parameter_list|)
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGTRACE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_ADDTRACE
argument_list|,
literal|"add %p size %u "
literal|"file %s line %u mctx %p\n"
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|debuglist
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|size
operator|>
name|mctx
operator|->
name|max_size
condition|)
name|size
operator|=
name|mctx
operator|->
name|max_size
expr_stmt|;
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|size
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|dl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|count
operator|==
name|DEBUGLIST_COUNT
condition|)
goto|goto
name|next
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEBUGLIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|=
name|ptr
expr_stmt|;
name|dl
operator|->
name|size
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|dl
operator|->
name|file
index|[
name|i
index|]
operator|=
name|file
expr_stmt|;
name|dl
operator|->
name|line
index|[
name|i
index|]
operator|=
name|line
expr_stmt|;
name|dl
operator|->
name|count
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|next
label|:
name|dl
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|dl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|debuglink_t
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|DEBUGLIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|size
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|file
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|line
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dl
operator|->
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
expr_stmt|;
name|dl
operator|->
name|size
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
name|dl
operator|->
name|file
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
name|dl
operator|->
name|line
index|[
literal|0
index|]
operator|=
name|line
expr_stmt|;
name|dl
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|size
index|]
argument_list|,
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|delete_trace_entry
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGTRACE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_DELTRACE
argument_list|,
literal|"del %p size %u "
literal|"file %s line %u mctx %p\n"
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|debuglist
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|size
operator|>
name|mctx
operator|->
name|max_size
condition|)
name|size
operator|=
name|mctx
operator|->
name|max_size
expr_stmt|;
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|size
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|dl
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEBUGLIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|==
name|ptr
condition|)
block|{
name|dl
operator|->
name|ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|size
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|file
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dl
operator|->
name|line
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|dl
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dl
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|size
index|]
argument_list|,
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|dl
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we get here, we didn't find the item on the list.  We're 	 * screwed. 	 */
name|INSIST
argument_list|(
name|dl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_MEM_TRACKLINES */
end_comment

begin_if
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
end_if

begin_function
specifier|static
specifier|inline
name|size_t
name|rmsize
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
comment|/*  	 * round down to ALIGNMENT_SIZE 	 */
return|return
operator|(
name|size
operator|&
operator|(
operator|~
operator|(
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|quantize
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * Round up the result in order to get a size big 	 * enough to satisfy the request and be aligned on ALIGNMENT_SIZE 	 * byte boundaries. 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|ALIGNMENT_SIZE
operator|)
return|;
return|return
operator|(
operator|(
name|size
operator|+
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|&
operator|(
operator|~
operator|(
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|more_basic_blocks
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|table_size
decl_stmt|;
name|size_t
name|increment
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Require: we hold the context lock. */
comment|/* 	 * Did we hit the quota for this context? 	 */
name|increment
operator|=
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|quota
operator|!=
literal|0
operator|&&
name|ctx
operator|->
name|total
operator|+
name|increment
operator|>
name|ctx
operator|->
name|quota
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|basic_table_count
operator|<=
name|ctx
operator|->
name|basic_table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|basic_table_count
operator|==
name|ctx
operator|->
name|basic_table_size
condition|)
block|{
name|table_size
operator|=
name|ctx
operator|->
name|basic_table_size
operator|+
name|TABLE_INCREMENT
expr_stmt|;
name|table
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|table_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|basic_table_size
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|table
argument_list|,
name|ctx
operator|->
name|basic_table
argument_list|,
name|ctx
operator|->
name|basic_table_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|basic_table
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|basic_table
operator|=
name|table
expr_stmt|;
name|ctx
operator|->
name|basic_table_size
operator|=
name|table_size
expr_stmt|;
block|}
name|new
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|ctx
operator|->
name|total
operator|+=
name|increment
expr_stmt|;
name|ctx
operator|->
name|basic_table
index|[
name|ctx
operator|->
name|basic_table_count
index|]
operator|=
name|new
expr_stmt|;
name|ctx
operator|->
name|basic_table_count
operator|++
expr_stmt|;
name|curr
operator|=
name|new
expr_stmt|;
name|next
operator|=
name|curr
operator|+
name|ctx
operator|->
name|mem_target
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|NUM_BASIC_BLOCKS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
operator|(
name|element
operator|*
operator|)
name|next
expr_stmt|;
name|curr
operator|=
name|next
expr_stmt|;
name|next
operator|+=
name|ctx
operator|->
name|mem_target
expr_stmt|;
block|}
comment|/* 	 * curr is now pointing at the last block in the 	 * array. 	 */
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
name|new
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|NUM_BASIC_BLOCKS
operator|*
name|ctx
operator|->
name|mem_target
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|<
name|ctx
operator|->
name|lowest
operator|||
name|ctx
operator|->
name|lowest
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|lowest
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|ctx
operator|->
name|highest
condition|)
name|ctx
operator|->
name|highest
operator|=
name|last
expr_stmt|;
name|ctx
operator|->
name|basic_blocks
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|more_frags
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|new_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|frags
decl_stmt|;
name|size_t
name|total_size
decl_stmt|;
name|void
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* 	 * Try to get more fragments by chopping up a basic block. 	 */
if|if
condition|(
name|ctx
operator|->
name|basic_blocks
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|more_basic_blocks
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* 			 * We can't get more memory from the OS, or we've 			 * hit the quota for this context. 			 */
comment|/* 			 * XXXRTH  "At quota" notification here. 			 */
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
name|total_size
operator|=
name|ctx
operator|->
name|mem_target
expr_stmt|;
name|new
operator|=
name|ctx
operator|->
name|basic_blocks
expr_stmt|;
name|ctx
operator|->
name|basic_blocks
operator|=
name|ctx
operator|->
name|basic_blocks
operator|->
name|next
expr_stmt|;
name|frags
operator|=
name|total_size
operator|/
name|new_size
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|blocks
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|freefrags
operator|+=
name|frags
expr_stmt|;
comment|/* 	 * Set up a linked-list of blocks of size 	 * "new_size". 	 */
name|curr
operator|=
name|new
expr_stmt|;
name|next
operator|=
name|curr
operator|+
name|new_size
expr_stmt|;
name|total_size
operator|-=
name|new_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|frags
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
operator|(
name|element
operator|*
operator|)
name|next
expr_stmt|;
name|curr
operator|=
name|next
expr_stmt|;
name|next
operator|+=
name|new_size
expr_stmt|;
name|total_size
operator|-=
name|new_size
expr_stmt|;
block|}
comment|/* 	 * Add the remaining fragment of the basic block to a free list. 	 */
name|total_size
operator|=
name|rmsize
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_size
operator|>
literal|0
condition|)
block|{
operator|(
operator|(
name|element
operator|*
operator|)
name|next
operator|)
operator|->
name|next
operator|=
name|ctx
operator|->
name|freelists
index|[
name|total_size
index|]
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|total_size
index|]
operator|=
operator|(
name|element
operator|*
operator|)
name|next
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|total_size
index|]
operator|.
name|freefrags
operator|++
expr_stmt|;
block|}
comment|/* 	 * curr is now pointing at the last block in the 	 * array. 	 */
operator|(
operator|(
name|element
operator|*
operator|)
name|curr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mem_getunlocked
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|new_size
init|=
name|quantize
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|ctx
operator|->
name|max_size
operator|||
name|new_size
operator|>=
name|ctx
operator|->
name|max_size
condition|)
block|{
comment|/* 		 * memget() was called on something beyond our upper limit. 		 */
if|if
condition|(
name|ctx
operator|->
name|quota
operator|!=
literal|0
operator|&&
name|ctx
operator|->
name|total
operator|+
name|size
operator|>
name|ctx
operator|->
name|quota
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ret
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ctx
operator|->
name|total
operator|+=
name|size
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|+=
name|size
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
comment|/* 		 * If we don't set new_size to size, then the 		 * ISC_MEM_FILL code might write over bytes we 		 * don't own. 		 */
name|new_size
operator|=
name|size
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * If there are no blocks in the free list for this size, get a chunk 	 * of memory and then break it up into "new_size"-sized blocks, adding 	 * them to the free list. 	 */
if|if
condition|(
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|==
name|NULL
operator|&&
operator|!
name|more_frags
argument_list|(
name|ctx
argument_list|,
name|new_size
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * The free list uses the "rounded-up" size "new_size". 	 */
name|ret
operator|=
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|=
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|->
name|next
expr_stmt|;
comment|/* 	 * The stats[] uses the _actual_ "size" requested by the 	 * caller, with the caveat (in the code above) that "size">= the 	 * max. size (max_size) ends up getting recorded as a call to 	 * max_size. 	 */
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|freefrags
operator|--
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|+=
name|new_size
expr_stmt|;
name|done
label|:
if|#
directive|if
name|ISC_MEM_FILL
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xbe
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "beef". */
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ISC_MEM_FILL
operator|&&
name|ISC_MEM_CHECKOVERRUN
end_if

begin_function
specifier|static
specifier|inline
name|void
name|check_overrun
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|new_size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mem
expr_stmt|;
name|cp
operator|+=
name|size
expr_stmt|;
while|while
condition|(
name|size
operator|<
name|new_size
condition|)
block|{
name|INSIST
argument_list|(
operator|*
name|cp
operator|==
literal|0xbe
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|mem_putunlocked
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|new_size
init|=
name|quantize
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|ctx
operator|->
name|max_size
operator|||
name|new_size
operator|>=
name|ctx
operator|->
name|max_size
condition|)
block|{
comment|/* 		 * memput() called on something beyond our upper limit. 		 */
if|#
directive|if
name|ISC_MEM_FILL
name|memset
argument_list|(
name|mem
argument_list|,
literal|0xde
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "dead". */
endif|#
directive|endif
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|size
operator|<=
name|ctx
operator|->
name|total
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|-=
name|size
expr_stmt|;
name|ctx
operator|->
name|total
operator|-=
name|size
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|ISC_MEM_FILL
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
name|check_overrun
argument_list|(
name|mem
argument_list|,
name|size
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|mem
argument_list|,
literal|0xde
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "dead". */
endif|#
directive|endif
comment|/* 	 * The free list uses the "rounded-up" size "new_size". 	 */
operator|(
operator|(
name|element
operator|*
operator|)
name|mem
operator|)
operator|->
name|next
operator|=
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
expr_stmt|;
name|ctx
operator|->
name|freelists
index|[
name|new_size
index|]
operator|=
operator|(
name|element
operator|*
operator|)
name|mem
expr_stmt|;
comment|/* 	 * The stats[] uses the _actual_ "size" requested by the 	 * caller, with the caveat (in the code above) that "size">= the 	 * max. size (max_size) ends up getting recorded as a call to 	 * max_size. 	 */
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|new_size
index|]
operator|.
name|freefrags
operator|++
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|-=
name|new_size
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
end_comment

begin_comment
comment|/*  * Perform a malloc, doing memory filling and overrun detection as necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mem_get
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
name|size
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
call|(
name|ctx
operator|->
name|memalloc
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|memalloc_failures
operator|++
expr_stmt|;
if|#
directive|if
name|ISC_MEM_FILL
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xbe
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "beef". */
else|#
directive|else
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|ret
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|0xbe
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a free, doing memory filling and overrun detection as necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mem_put
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|ISC_MEM_CHECKOVERRUN
name|INSIST
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mem
operator|)
index|[
name|size
index|]
operator|==
literal|0xbe
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ISC_MEM_FILL
name|memset
argument_list|(
name|mem
argument_list|,
literal|0xde
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mnemonic for "dead". */
else|#
directive|else
name|UNUSED
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update internal counters after a memory get.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mem_getstats
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|ctx
operator|->
name|total
operator|+=
name|size
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ctx
operator|->
name|max_size
condition|)
block|{
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|++
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|totalgets
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update internal counters after a memory put.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mem_putstats
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|inuse
operator|>=
name|size
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ctx
operator|->
name|max_size
condition|)
block|{
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|ctx
operator|->
name|max_size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stats
index|[
name|size
index|]
operator|.
name|gets
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
end_comment

begin_comment
comment|/*  * Private.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|default_memalloc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0U
condition|)
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_memfree
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public.  */
end_comment

begin_function
name|isc_result_t
name|isc_mem_createx
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_memalloc_t
name|memalloc
parameter_list|,
name|isc_memfree_t
name|memfree
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|ctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
operator|&&
operator|*
name|ctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|memalloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|memfree
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|ALIGNMENT_SIZE
operator|&
operator|(
name|ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|ISC_MEM_USE_INTERNAL_MALLOC
name|UNUSED
argument_list|(
name|target_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
if|if
condition|(
name|init_max_size
operator|==
literal|0U
condition|)
name|ctx
operator|->
name|max_size
operator|=
name|DEF_MAX_SIZE
expr_stmt|;
else|else
name|ctx
operator|->
name|max_size
operator|=
name|init_max_size
expr_stmt|;
name|ctx
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|quota
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|maxinuse
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|hi_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|lo_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
name|ctx
operator|->
name|water
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|water_arg
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|magic
operator|=
name|MEM_MAGIC
expr_stmt|;
name|isc_ondestroy_init
argument_list|(
operator|&
name|ctx
operator|->
name|ondestroy
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|memalloc
operator|=
name|memalloc
expr_stmt|;
name|ctx
operator|->
name|memfree
operator|=
name|memfree
expr_stmt|;
name|ctx
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|ctx
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|checkfree
operator|=
name|ISC_TRUE
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|ctx
operator|->
name|debuglist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ISC_LIST_INIT
argument_list|(
name|ctx
operator|->
name|pools
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|ctx
operator|->
name|freelists
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|ctx
operator|->
name|stats
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|stats
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|ctx
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
if|if
condition|(
name|target_size
operator|==
literal|0
condition|)
name|ctx
operator|->
name|mem_target
operator|=
name|DEF_MEM_TARGET
expr_stmt|;
else|else
name|ctx
operator|->
name|mem_target
operator|=
name|target_size
expr_stmt|;
name|ctx
operator|->
name|freelists
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
operator|->
name|max_size
operator|*
sizeof|sizeof
argument_list|(
name|element
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|freelists
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|ctx
operator|->
name|freelists
argument_list|,
literal|0
argument_list|,
name|ctx
operator|->
name|max_size
operator|*
sizeof|sizeof
argument_list|(
name|element
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|basic_blocks
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|basic_table
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|basic_table_count
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|basic_table_size
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|lowest
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|highest
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGRECORD
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|ctx
operator|->
name|debuglist
operator|=
call|(
name|memalloc
call|)
argument_list|(
name|arg
argument_list|,
operator|(
name|ctx
operator|->
name|max_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|debuglist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctx
operator|->
name|memalloc_failures
operator|=
literal|0
expr_stmt|;
operator|*
name|ctxp
operator|=
name|ctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|error
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|stats
operator|!=
name|NULL
condition|)
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
operator|->
name|stats
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
if|if
condition|(
name|ctx
operator|->
name|freelists
operator|!=
name|NULL
condition|)
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
operator|->
name|freelists
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|debuglist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_TRACKLINES */
name|DESTROYLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
name|memfree
call|)
argument_list|(
name|arg
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_mem_create
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
return|return
operator|(
name|isc_mem_createx
argument_list|(
name|init_max_size
argument_list|,
name|target_size
argument_list|,
name|default_memalloc
argument_list|,
name|default_memfree
argument_list|,
name|NULL
argument_list|,
name|ctxp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_ondestroy_t
name|ondest
decl_stmt|;
name|ctx
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ctx
operator|->
name|pools
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|checkfree
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
condition|)
name|print_active
argument_list|(
name|ctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
init|;
name|dl
operator|!=
name|NULL
condition|;
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|ctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|,
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
block|}
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|debuglist
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|INSIST
argument_list|(
name|ctx
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|checkfree
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|stats
index|[
name|i
index|]
operator|.
name|gets
operator|!=
literal|0U
condition|)
name|print_active
argument_list|(
name|ctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|ctx
operator|->
name|stats
index|[
name|i
index|]
operator|.
name|gets
operator|==
literal|0U
argument_list|)
expr_stmt|;
block|}
block|}
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|stats
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|basic_table_count
condition|;
name|i
operator|++
control|)
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|basic_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|freelists
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
operator|->
name|basic_table
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|ondest
operator|=
name|ctx
operator|->
name|ondestroy
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
name|ctx
operator|->
name|memfree
call|)
argument_list|(
name|ctx
operator|->
name|arg
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|isc_ondestroy_notify
argument_list|(
operator|&
name|ondest
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_mem_attach
parameter_list|(
name|isc_mem_t
modifier|*
name|source
parameter_list|,
name|isc_mem_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_mem_detach
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|ctx
decl_stmt|;
name|isc_boolean_t
name|want_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|*
name|ctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|references
operator|==
literal|0
condition|)
name|want_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_destroy
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|*
name|ctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * isc_mem_putanddetach() is the equivalent of:  *  * mctx = NULL;  * isc_mem_attach(ptr->mctx,&mctx);  * isc_mem_detach(&ptr->mctx);  * isc_mem_put(mctx, ptr, sizeof(*ptr);  * isc_mem_detach(&mctx);  */
end_comment

begin_function
name|void
name|isc__mem_putanddetach
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|ctx
decl_stmt|;
name|isc_boolean_t
name|want_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|*
name|ctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Must be before mem_putunlocked() as ctxp is usually within 	 * [ptr..ptr+size). 	 */
operator|*
name|ctxp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|mem_put
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|DELETE_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|references
operator|==
literal|0
condition|)
name|want_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_destroy
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_mem_destroy
parameter_list|(
name|isc_mem_t
modifier|*
modifier|*
name|ctxp
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|ctx
decl_stmt|;
comment|/* 	 * This routine provides legacy support for callers who use mctxs 	 * without attaching/detaching. 	 */
name|REQUIRE
argument_list|(
name|ctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|*
name|ctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|ctx
operator|->
name|references
operator|!=
literal|1
condition|)
name|print_active
argument_list|(
name|ctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|references
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|references
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
operator|*
name|ctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_mem_ondestroy
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|res
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|isc_ondestroy_register
argument_list|(
operator|&
name|ctx
operator|->
name|ondestroy
argument_list|,
name|task
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc__mem_get
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|isc_boolean_t
name|call_water
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem_getunlocked
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|ptr
operator|=
name|mem_get
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|mem_getstats
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|ADD_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
operator|!
name|ctx
operator|->
name|hi_called
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
condition|)
block|{
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_TRUE
expr_stmt|;
name|call_water
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|maxinuse
condition|)
block|{
name|ctx
operator|->
name|maxinuse
operator|=
name|ctx
operator|->
name|inuse
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|hi_water
operator|!=
literal|0U
operator|&&
name|ctx
operator|->
name|inuse
operator|>
name|ctx
operator|->
name|hi_water
operator|&&
operator|(
name|isc_mem_debugging
operator|&
name|ISC_MEM_DEBUGUSAGE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maxinuse = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ctx
operator|->
name|inuse
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_water
condition|)
call|(
name|ctx
operator|->
name|water
call|)
argument_list|(
name|ctx
operator|->
name|water_arg
argument_list|,
name|ISC_MEM_HIWATER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__mem_put
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|isc_boolean_t
name|call_water
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|mem_put
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|DELETE_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * The check against ctx->lo_water == 0 is for the condition 	 * when the context was pushed over hi_water but then had 	 * isc_mem_setwater() called with 0 for hi_water and lo_water. 	 */
if|if
condition|(
name|ctx
operator|->
name|hi_called
operator|&&
operator|(
name|ctx
operator|->
name|inuse
operator|<
name|ctx
operator|->
name|lo_water
operator|||
name|ctx
operator|->
name|lo_water
operator|==
literal|0U
operator|)
condition|)
block|{
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|water
operator|!=
name|NULL
condition|)
name|call_water
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_water
condition|)
call|(
name|ctx
operator|->
name|water
call|)
argument_list|(
name|ctx
operator|->
name|water_arg
argument_list|,
name|ISC_MEM_LOWATER
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|ISC_MEM_TRACKLINES
end_if

begin_function
specifier|static
name|void
name|print_active
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
if|if
condition|(
name|mctx
operator|->
name|debuglist
operator|!=
name|NULL
condition|)
block|{
name|debuglink_t
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|isc_boolean_t
name|found
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_DUMPALLOC
argument_list|,
literal|"Dump of all outstanding "
literal|"memory allocations:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|ISC_FALSE
expr_stmt|;
name|format
operator|=
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_PTRFILELINE
argument_list|,
literal|"\tptr %p size %u file %s line %u\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
name|dl
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mctx
operator|->
name|debuglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|!=
name|NULL
condition|)
name|found
operator|=
name|ISC_TRUE
expr_stmt|;
while|while
condition|(
name|dl
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DEBUGLIST_COUNT
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dl
operator|->
name|ptr
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
name|format
argument_list|,
name|dl
operator|->
name|ptr
index|[
name|j
index|]
argument_list|,
name|dl
operator|->
name|size
index|[
name|j
index|]
argument_list|,
name|dl
operator|->
name|file
index|[
name|j
index|]
argument_list|,
name|dl
operator|->
name|line
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|dl
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dl
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_NONE
argument_list|,
literal|"\tNone.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print the stats[] on the stream "out" with suitable formatting.  */
end_comment

begin_function
name|void
name|isc_mem_stats
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|struct
name|stats
modifier|*
name|s
decl_stmt|;
specifier|const
name|isc_mempool_t
modifier|*
name|pool
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ctx
operator|->
name|max_size
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ctx
operator|->
name|stats
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|totalgets
operator|==
literal|0U
operator|&&
name|s
operator|->
name|gets
operator|==
literal|0U
condition|)
continue|continue;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%5lu: %11lu gets, %11lu rem"
argument_list|,
operator|(
name|i
operator|==
name|ctx
operator|->
name|max_size
operator|)
condition|?
literal|">="
else|:
literal|"  "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|,
name|s
operator|->
name|totalgets
argument_list|,
name|s
operator|->
name|gets
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
if|if
condition|(
name|s
operator|->
name|blocks
operator|!=
literal|0
operator|||
name|s
operator|->
name|freefrags
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" (%lu bl, %lu ff)"
argument_list|,
name|s
operator|->
name|blocks
argument_list|,
name|s
operator|->
name|freefrags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that since a pool can be locked now, these stats might be 	 * somewhat off if the pool is in active use at the time the stats 	 * are dumped.  The link fields are protected by the isc_mem_t's 	 * lock, however, so walking this list and extracting integers from 	 * stats fields is always safe. 	 */
name|pool
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ctx
operator|->
name|pools
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLSTATS
argument_list|,
literal|"[Pool statistics]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%15s %10s %10s %10s %10s %10s %10s %10s %1s\n"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLNAME
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLSIZE
argument_list|,
literal|"size"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLMAXALLOC
argument_list|,
literal|"maxalloc"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLALLOCATED
argument_list|,
literal|"allocated"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLFREECOUNT
argument_list|,
literal|"freecount"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLFREEMAX
argument_list|,
literal|"freemax"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLFILLCOUNT
argument_list|,
literal|"fillcount"
argument_list|)
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_MEM
argument_list|,
name|ISC_MSG_POOLGETS
argument_list|,
literal|"gets"
argument_list|)
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%15s %10lu %10u %10u %10u %10u %10u %10u %s\n"
argument_list|,
name|pool
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pool
operator|->
name|size
argument_list|,
name|pool
operator|->
name|maxalloc
argument_list|,
name|pool
operator|->
name|allocated
argument_list|,
name|pool
operator|->
name|freecount
argument_list|,
name|pool
operator|->
name|freemax
argument_list|,
name|pool
operator|->
name|fillcount
argument_list|,
name|pool
operator|->
name|gets
argument_list|,
operator|(
name|pool
operator|->
name|lock
operator|==
name|NULL
condition|?
literal|"N"
else|:
literal|"Y"
operator|)
argument_list|)
expr_stmt|;
name|pool
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|pool
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|print_active
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replacements for malloc() and free() -- they implicitly remember the  * size of the object allocated (with some additional overhead).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|isc__mem_allocateunlocked
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_info
modifier|*
name|si
decl_stmt|;
name|size
operator|+=
name|ALIGNMENT_SIZE
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|si
operator|=
name|mem_getunlocked
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|si
operator|=
name|mem_get
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|if
condition|(
name|si
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|si
operator|->
name|u
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
operator|(
operator|&
name|si
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc__mem_allocate
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
name|FLARG
parameter_list|)
block|{
name|size_info
modifier|*
name|si
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|si
operator|=
name|isc__mem_allocateunlocked
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|si
operator|=
name|isc__mem_allocateunlocked
argument_list|(
name|ctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
name|mem_getstats
argument_list|(
name|ctx
argument_list|,
name|si
index|[
operator|-
literal|1
index|]
operator|.
name|u
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|ADD_TRACE
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|si
index|[
operator|-
literal|1
index|]
operator|.
name|u
operator|.
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__mem_free
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ptr
name|FLARG
parameter_list|)
block|{
name|size_info
modifier|*
name|si
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|si
operator|=
operator|&
operator|(
operator|(
operator|(
name|size_info
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|size
operator|=
name|si
operator|->
name|u
operator|.
name|size
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|mem_put
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|ctx
argument_list|,
name|si
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|DELETE_TRACE
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Other useful things.  */
end_comment

begin_function
name|char
modifier|*
name|isc__mem_strdup
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|s
name|FLARG
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|ns
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ns
operator|=
name|isc__mem_allocate
argument_list|(
name|mctx
argument_list|,
name|len
operator|+
literal|1
name|FLARG_PASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|ns
argument_list|,
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ns
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_mem_setdestroycheck
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|isc_boolean_t
name|flag
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|checkfree
operator|=
name|flag
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quotas  */
end_comment

begin_function
name|void
name|isc_mem_setquota
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|size_t
name|quota
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|quota
operator|=
name|quota
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|isc_mem_getquota
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
block|{
name|size_t
name|quota
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|quota
operator|=
name|ctx
operator|->
name|quota
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|quota
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|isc_mem_inuse
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|)
block|{
name|size_t
name|inuse
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inuse
operator|=
name|ctx
operator|->
name|inuse
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|inuse
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_mem_setwater
parameter_list|(
name|isc_mem_t
modifier|*
name|ctx
parameter_list|,
name|isc_mem_water_t
name|water
parameter_list|,
name|void
modifier|*
name|water_arg
parameter_list|,
name|size_t
name|hiwater
parameter_list|,
name|size_t
name|lowater
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|hiwater
operator|>=
name|lowater
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|water
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|water
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|water_arg
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|hi_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|lo_water
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|water
operator|=
name|water
expr_stmt|;
name|ctx
operator|->
name|water_arg
operator|=
name|water_arg
expr_stmt|;
name|ctx
operator|->
name|hi_water
operator|=
name|hiwater
expr_stmt|;
name|ctx
operator|->
name|lo_water
operator|=
name|lowater
expr_stmt|;
name|ctx
operator|->
name|hi_called
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Memory pool stuff  */
end_comment

begin_function
name|isc_result_t
name|isc_mempool_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|size_t
name|size
parameter_list|,
name|isc_mempool_t
modifier|*
modifier|*
name|mpctxp
parameter_list|)
block|{
name|isc_mempool_t
modifier|*
name|mpctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CONTEXT
argument_list|(
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|size
operator|>
literal|0U
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mpctxp
operator|!=
name|NULL
operator|&&
operator|*
name|mpctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for this pool, initialize values, and if all works 	 * well, attach to the memory context. 	 */
name|mpctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_mempool_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|mpctx
operator|->
name|magic
operator|=
name|MEMPOOL_MAGIC
expr_stmt|;
name|mpctx
operator|->
name|lock
operator|=
name|NULL
expr_stmt|;
name|mpctx
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|mpctx
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|mpctx
operator|->
name|maxalloc
operator|=
name|UINT_MAX
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|=
literal|0
expr_stmt|;
name|mpctx
operator|->
name|freemax
operator|=
literal|1
expr_stmt|;
name|mpctx
operator|->
name|fillcount
operator|=
literal|1
expr_stmt|;
name|mpctx
operator|->
name|gets
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|ISC_MEMPOOL_NAMES
name|mpctx
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|mpctx
operator|->
name|items
operator|=
name|NULL
expr_stmt|;
operator|*
name|mpctxp
operator|=
name|mpctx
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|mctx
operator|->
name|pools
argument_list|,
name|mpctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_mempool_setname
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEMPOOL_NAMES
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mpctx
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mpctx
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|mpctx
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|mpctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|isc_mempool_destroy
parameter_list|(
name|isc_mempool_t
modifier|*
modifier|*
name|mpctxp
parameter_list|)
block|{
name|isc_mempool_t
modifier|*
name|mpctx
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
name|element
modifier|*
name|item
decl_stmt|;
name|REQUIRE
argument_list|(
name|mpctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mpctx
operator|=
operator|*
name|mpctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEMPOOL_NAMES
if|if
condition|(
name|mpctx
operator|->
name|allocated
operator|>
literal|0
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mempool_destroy(): mempool %s "
literal|"leaked memory"
argument_list|,
name|mpctx
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|mpctx
operator|->
name|allocated
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|mpctx
operator|->
name|mctx
expr_stmt|;
name|lock
operator|=
name|mpctx
operator|->
name|lock
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Return any items on the free list 	 */
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|mpctx
operator|->
name|items
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|mpctx
operator|->
name|freecount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|--
expr_stmt|;
name|item
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
name|mpctx
operator|->
name|items
operator|=
name|item
operator|->
name|next
expr_stmt|;
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|mem_putunlocked
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|mem_put
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
block|}
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remove our linked list entry from the memory context. 	 */
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|mctx
operator|->
name|pools
argument_list|,
name|mpctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mpctx
operator|->
name|mctx
argument_list|,
name|mpctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_mempool_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
operator|*
name|mpctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_mempool_associatelock
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|isc_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mpctx
operator|->
name|lock
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|lock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc__mempool_get
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
name|FLARG
parameter_list|)
block|{
name|element
modifier|*
name|item
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|mpctx
operator|->
name|mctx
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Don't let the caller go over quota 	 */
if|if
condition|(
name|mpctx
operator|->
name|allocated
operator|>=
name|mpctx
operator|->
name|maxalloc
condition|)
block|{
name|item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * if we have a free list item, return the first here 	 */
name|item
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|mpctx
operator|->
name|items
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|INSIST
argument_list|(
name|mpctx
operator|->
name|freecount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|--
expr_stmt|;
name|mpctx
operator|->
name|gets
operator|++
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We need to dip into the well.  Lock the memory context here and 	 * fill up our free list. 	 */
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mpctx
operator|->
name|fillcount
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|item
operator|=
name|mem_getunlocked
argument_list|(
name|mctx
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|item
operator|=
name|mem_get
argument_list|(
name|mctx
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
name|mem_getstats
argument_list|(
name|mctx
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
break|break;
name|item
operator|->
name|next
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
name|mpctx
operator|->
name|items
operator|=
name|item
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|++
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't get any items, return NULL. 	 */
name|item
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|mpctx
operator|->
name|items
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|mpctx
operator|->
name|freecount
operator|--
expr_stmt|;
name|mpctx
operator|->
name|gets
operator|++
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|++
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ADD_TRACE
argument_list|(
name|mctx
argument_list|,
name|item
argument_list|,
name|mpctx
operator|->
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISC_MEM_TRACKLINES */
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__mempool_put
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|void
modifier|*
name|mem
name|FLARG
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|element
modifier|*
name|item
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mem
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|mpctx
operator|->
name|mctx
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|mpctx
operator|->
name|allocated
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|allocated
operator|--
expr_stmt|;
if|#
directive|if
name|ISC_MEM_TRACKLINES
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DELETE_TRACE
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_TRACKLINES */
comment|/* 	 * If our free list is full, return this to the mctx directly. 	 */
if|if
condition|(
name|mpctx
operator|->
name|freecount
operator|>=
name|mpctx
operator|->
name|freemax
condition|)
block|{
if|#
directive|if
name|ISC_MEM_USE_INTERNAL_MALLOC
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putunlocked
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
name|mem_put
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mem_putstats
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|mpctx
operator|->
name|size
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mctx
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_MEM_USE_INTERNAL_MALLOC */
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, attach it to our free list and bump the counter. 	 */
name|mpctx
operator|->
name|freecount
operator|++
expr_stmt|;
name|item
operator|=
operator|(
name|element
operator|*
operator|)
name|mem
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|mpctx
operator|->
name|items
expr_stmt|;
name|mpctx
operator|->
name|items
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quotas  */
end_comment

begin_function
name|void
name|isc_mempool_setfreemax
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|freemax
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_mempool_getfreemax
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
block|{
name|unsigned
name|int
name|freemax
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|freemax
operator|=
name|mpctx
operator|->
name|freemax
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|freemax
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_mempool_getfreecount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
block|{
name|unsigned
name|int
name|freecount
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|freecount
operator|=
name|mpctx
operator|->
name|freecount
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|freecount
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_mempool_setmaxalloc
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|limit
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|maxalloc
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_mempool_getmaxalloc
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
block|{
name|unsigned
name|int
name|maxalloc
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|maxalloc
operator|=
name|mpctx
operator|->
name|maxalloc
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxalloc
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_mempool_getallocated
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
block|{
name|unsigned
name|int
name|allocated
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|allocated
operator|=
name|mpctx
operator|->
name|allocated
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|allocated
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_mempool_setfillcount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|limit
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mpctx
operator|->
name|fillcount
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_mempool_getfillcount
parameter_list|(
name|isc_mempool_t
modifier|*
name|mpctx
parameter_list|)
block|{
name|unsigned
name|int
name|fillcount
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MEMPOOL
argument_list|(
name|mpctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fillcount
operator|=
name|mpctx
operator|->
name|fillcount
expr_stmt|;
if|if
condition|(
name|mpctx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|mpctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|fillcount
operator|)
return|;
block|}
end_function

end_unit

