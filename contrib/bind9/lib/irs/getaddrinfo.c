begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2009  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: getaddrinfo.c,v 1.3 2009/09/02 23:48:02 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_comment
comment|/**  *    getaddrinfo() is used to get a list of IP addresses and port  *    numbers for host hostname and service servname as defined in RFC3493.  *    hostname and servname are pointers to null-terminated strings  *    or NULL. hostname is either a host name or a numeric host address  *    string: a dotted decimal IPv4 address or an IPv6 address. servname is  *    either a decimal port number or a service name as listed in  *    /etc/services.  *  *    If the operating system does not provide a struct addrinfo, the  *    following structure is used:  *  * \code  * struct  addrinfo {  *         int             ai_flags;       // AI_PASSIVE, AI_CANONNAME  *         int             ai_family;      // PF_xxx  *         int             ai_socktype;    // SOCK_xxx  *         int             ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6  *         size_t          ai_addrlen;     // length of ai_addr  *         char            *ai_canonname;  // canonical name for hostname  *         struct sockaddr *ai_addr;       // binary address  *         struct addrinfo *ai_next;       // next structure in linked list  * };  * \endcode  *  *  *    hints is an optional pointer to a struct addrinfo. This structure can  *    be used to provide hints concerning the type of socket that the caller  *    supports or wishes to use. The caller can supply the following  *    structure elements in *hints:  *  *<ul>  *<li>ai_family:  *           The protocol family that should be used. When ai_family is set  *           to PF_UNSPEC, it means the caller will accept any protocol  *           family supported by the operating system.</li>  *  *<li>ai_socktype:  *           denotes the type of socket -- SOCK_STREAM, SOCK_DGRAM or  *           SOCK_RAW -- that is wanted. When ai_socktype is zero the caller  *           will accept any socket type.</li>  *  *<li>ai_protocol:  *           indicates which transport protocol is wanted: IPPROTO_UDP or  *           IPPROTO_TCP. If ai_protocol is zero the caller will accept any  *           protocol.</li>  *  *<li>ai_flags:  *           Flag bits. If the AI_CANONNAME bit is set, a successful call to  *           getaddrinfo() will return a null-terminated string  *           containing the canonical name of the specified hostname in  *           ai_canonname of the first addrinfo structure returned. Setting  *           the AI_PASSIVE bit indicates that the returned socket address  *           structure is intended for used in a call to bind(2). In this  *           case, if the hostname argument is a NULL pointer, then the IP  *           address portion of the socket address structure will be set to  *           INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6  *           address.<br /><br />  *  *           When ai_flags does not set the AI_PASSIVE bit, the returned  *           socket address structure will be ready for use in a call to  *           connect(2) for a connection-oriented protocol or connect(2),  *           sendto(2), or sendmsg(2) if a connectionless protocol was  *           chosen. The IP address portion of the socket address structure  *           will be set to the loopback address if hostname is a NULL  *           pointer and AI_PASSIVE is not set in ai_flags.<br /><br />  *  *           If ai_flags is set to AI_NUMERICHOST it indicates that hostname  *           should be treated as a numeric string defining an IPv4 or IPv6  *           address and no name resolution should be attempted.  *</li></ul>  *  *    All other elements of the struct addrinfo passed via hints must be  *    zero.  *  *    A hints of NULL is treated as if the caller provided a struct addrinfo  *    initialized to zero with ai_familyset to PF_UNSPEC.  *  *    After a successful call to getaddrinfo(), *res is a pointer to a  *    linked list of one or more addrinfo structures. Each struct addrinfo  *    in this list cn be processed by following the ai_next pointer, until a  *    NULL pointer is encountered. The three members ai_family, ai_socktype,  *    and ai_protocol in each returned addrinfo structure contain the  *    corresponding arguments for a call to socket(2). For each addrinfo  *    structure in the list, the ai_addr member points to a filled-in socket  *    address structure of length ai_addrlen.  *  *    All of the information returned by getaddrinfo() is dynamically  *    allocated: the addrinfo structures, and the socket address structures  *    and canonical host name strings pointed to by the addrinfostructures.  *    Memory allocated for the dynamically allocated structures created by a  *    successful call to getaddrinfo() is released by freeaddrinfo().  *    ai is a pointer to a struct addrinfo created by a call to getaddrinfo().  *  * \section irsreturn RETURN VALUES  *  *    getaddrinfo() returns zero on success or one of the error codes  *    listed in gai_strerror() if an error occurs. If both hostname and  *    servname are NULL getaddrinfo() returns #EAI_NONAME.  *  * \section irssee SEE ALSO  *  *    getaddrinfo(), freeaddrinfo(),  *    gai_strerror(), RFC3493, getservbyname(3), connect(2),  *    sendto(2), sendmsg(2), socket(2).  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<isc/app.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/lib.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/sockaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/client.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<irs/context.h>
end_include

begin_include
include|#
directive|include
file|<irs/netdb.h>
end_include

begin_include
include|#
directive|include
file|<irs/resconf.h>
end_include

begin_define
define|#
directive|define
name|SA
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr *)(addr))
end_define

begin_define
define|#
directive|define
name|SIN
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr_in *)(addr))
end_define

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr_in6 *)(addr))
end_define

begin_define
define|#
directive|define
name|SLOCAL
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr_un *)(addr))
end_define

begin_comment
comment|/*! \struct addrinfo  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_concat
argument_list|(
expr|struct
name|addrinfo
operator|*
name|ai1
argument_list|,
expr|struct
name|addrinfo
operator|*
name|ai2
argument_list|)
decl_stmt|,
modifier|*
name|ai_reverse
argument_list|(
expr|struct
name|addrinfo
operator|*
name|oai
argument_list|)
decl_stmt|,
modifier|*
name|ai_clone
argument_list|(
expr|struct
name|addrinfo
operator|*
name|oai
argument_list|,
name|int
name|family
argument_list|)
decl_stmt|,
modifier|*
name|ai_alloc
argument_list|(
name|int
name|family
argument_list|,
name|int
name|addrlen
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AF_LOCAL
end_ifdef

begin_function_decl
specifier|static
name|int
name|get_local
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|socktype
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|resolve_name
parameter_list|(
name|int
name|family
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_ipv4
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_ipv6
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_order
parameter_list|(
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FOUND_IPV4
value|0x1
end_define

begin_define
define|#
directive|define
name|FOUND_IPV6
value|0x2
end_define

begin_define
define|#
directive|define
name|FOUND_MAX
value|2
end_define

begin_define
define|#
directive|define
name|ISC_AI_MASK
value|(AI_PASSIVE|AI_CANONNAME|AI_NUMERICHOST)
end_define

begin_comment
comment|/*%  * Get a list of IP addresses and port numbers for host hostname and  * service servname.  */
end_comment

begin_function
name|int
name|getaddrinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|int
name|family
decl_stmt|,
name|socktype
decl_stmt|,
name|flags
decl_stmt|,
name|protocol
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|,
modifier|*
name|ai_list
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|net_order
index|[
name|FOUND_MAX
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
name|proto
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hints
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
operator|(
name|ISC_AI_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAI_BADFLAGS
operator|)
return|;
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|EAI_SYSTEM
operator|)
return|;
block|}
name|family
operator|=
name|hints
operator|->
name|ai_family
expr_stmt|;
name|socktype
operator|=
name|hints
operator|->
name|ai_socktype
expr_stmt|;
name|protocol
operator|=
name|hints
operator|->
name|ai_protocol
expr_stmt|;
name|flags
operator|=
name|hints
operator|->
name|ai_flags
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
switch|switch
condition|(
name|hints
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
switch|switch
condition|(
name|hints
operator|->
name|ai_socktype
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|SOCK_RAW
case|:
break|break;
default|default:
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|AF_LOCAL
case|case
name|AF_LOCAL
case|:
switch|switch
condition|(
name|hints
operator|->
name|ai_socktype
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|SOCK_STREAM
case|:
break|break;
case|case
name|SOCK_DGRAM
case|:
break|break;
default|default:
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EAI_FAMILY
operator|)
return|;
block|}
block|}
else|else
block|{
name|protocol
operator|=
literal|0
expr_stmt|;
name|family
operator|=
literal|0
expr_stmt|;
name|socktype
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AF_LOCAL
comment|/*! 	 * First, deal with AF_LOCAL.  If the family was not set, 	 * then assume AF_LOCAL if the first character of the 	 * hostname/servname is '/'. 	 */
if|if
condition|(
name|hostname
operator|!=
name|NULL
operator|&&
operator|(
name|family
operator|==
name|AF_LOCAL
operator|||
operator|(
name|family
operator|==
literal|0
operator|&&
operator|*
name|hostname
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
operator|(
name|get_local
argument_list|(
name|hostname
argument_list|,
name|socktype
argument_list|,
name|res
argument_list|)
operator|)
return|;
if|if
condition|(
name|servname
operator|!=
name|NULL
operator|&&
operator|(
name|family
operator|==
name|AF_LOCAL
operator|||
operator|(
name|family
operator|==
literal|0
operator|&&
operator|*
name|servname
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
operator|(
name|get_local
argument_list|(
name|servname
argument_list|,
name|socktype
argument_list|,
name|res
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Ok, only AF_INET and AF_INET6 left. 	 */
name|ai_list
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * First, look up the service name (port) if it was 	 * requested.  If the socket type wasn't specified, then 	 * try and figure it out. 	 */
if|if
condition|(
name|servname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|port
operator|=
name|strtol
argument_list|(
name|servname
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|socktype
operator|==
literal|0
condition|)
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
operator|(
name|EAI_SERVICE
operator|)
return|;
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_SERVICE
operator|)
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
if|if
condition|(
name|socktype
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|s_proto
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
name|socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|s_proto
argument_list|,
literal|"udp"
argument_list|)
operator|==
literal|0
condition|)
name|socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
block|}
block|}
block|}
else|else
name|port
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Next, deal with just a service name, and no hostname. 	 * (we verified that one of them was non-null up above). 	 */
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|AI_PASSIVE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|family
operator|==
name|AF_INET
operator|||
name|family
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|ai_alloc
argument_list|(
name|AF_INET
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|protocol
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|ai_list
expr_stmt|;
name|ai_list
operator|=
name|ai
expr_stmt|;
block|}
if|if
condition|(
name|family
operator|==
name|AF_INET6
operator|||
name|family
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|ai_alloc
argument_list|(
name|AF_INET6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
block|}
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|protocol
expr_stmt|;
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|ai_list
expr_stmt|;
name|ai_list
operator|=
name|ai
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ai_list
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the family isn't specified or AI_NUMERICHOST specified, check 	 * first to see if it is a numeric address. 	 * Though the gethostbyname2() routine will recognize numeric addresses, 	 * it will only recognize the format that it is being called for.  Thus, 	 * a numeric AF_INET address will be treated by the AF_INET6 call as 	 * a domain name, and vice versa.  Checking for both numerics here 	 * avoids that. 	 */
if|if
condition|(
name|hostname
operator|!=
name|NULL
operator|&&
operator|(
name|family
operator|==
literal|0
operator|||
operator|(
name|flags
operator|&
name|AI_NUMERICHOST
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|abuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|int
name|addrsize
decl_stmt|,
name|addroff
decl_stmt|;
ifdef|#
directive|ifdef
name|IRS_HAVE_SIN6_SCOPE_ID
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
name|ntmp
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|isc_uint32_t
name|scopeid
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IRS_HAVE_SIN6_SCOPE_ID
comment|/* 		 * Scope identifier portion. 		 */
name|ntmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|ntmp
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|ntmp
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ntmp
index|[
sizeof|sizeof
argument_list|(
name|ntmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|ntmp
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Vendors may want to support non-numeric 			 * scopeid around here. 			 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|scopeid
operator|=
operator|(
name|isc_uint32_t
operator|)
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|ep
operator|!=
name|NULL
operator|&&
name|ep
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|ntmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scopeid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|scopeid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|hostname
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|abuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* 				 * Convert to a V4 mapped address. 				 */
name|struct
name|in6_addr
modifier|*
name|a6
init|=
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|abuf
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|12
index|]
argument_list|,
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|10
index|]
argument_list|,
literal|0xff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|inet6_addr
goto|;
block|}
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|addroff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|SIN
argument_list|(
literal|0
argument_list|)
operator|->
name|sin_addr
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|family
operator|=
name|AF_INET
expr_stmt|;
goto|goto
name|common
goto|;
ifdef|#
directive|ifdef
name|IRS_HAVE_SIN6_SCOPE_ID
block|}
elseif|else
if|if
condition|(
name|ntmp
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ntmp
argument_list|,
name|abuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|family
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|addroff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|SIN6
argument_list|(
literal|0
argument_list|)
operator|->
name|sin6_addr
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|family
operator|=
name|AF_INET6
expr_stmt|;
goto|goto
name|common
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|hostname
argument_list|,
name|abuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|family
operator|!=
literal|0
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
name|inet6_addr
label|:
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|addroff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|SIN6
argument_list|(
literal|0
argument_list|)
operator|->
name|sin6_addr
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|common
label|:
name|ai
operator|=
name|ai_alloc
argument_list|(
name|family
argument_list|,
operator|(
operator|(
name|family
operator|==
name|AF_INET6
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
name|ai_list
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|+
name|addroff
argument_list|,
name|abuf
argument_list|,
name|addrsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IRS_HAVE_SIN6_SCOPE_ID
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|strdup
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* XXX raise error? */
name|ai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|AI_NUMERICHOST
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
block|}
block|}
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|AI_PASSIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|set_order
argument_list|(
name|family
argument_list|,
name|net_order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOUND_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|net_order
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|err
operator|=
operator|(
name|net_order
index|[
name|i
index|]
operator|)
operator|(
name|hostname
operator|,
name|flags
operator|,
operator|&
name|ai_list
operator|,
name|socktype
operator|,
name|port
operator|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ai_list
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|err
operator|=
name|resolve_name
argument_list|(
name|family
argument_list|,
name|hostname
argument_list|,
name|flags
argument_list|,
operator|&
name|ai_list
argument_list|,
name|socktype
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai_list
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|EAI_NONAME
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|done
label|:
name|ai_list
operator|=
name|ai_reverse
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|ai_list
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|gai_restrans
block|{
name|dns_clientrestrans_t
modifier|*
name|xid
decl_stmt|;
name|isc_boolean_t
name|is_inprogress
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|addrinfo
name|ai_sentinel
decl_stmt|;
name|struct
name|gai_resstate
modifier|*
name|resstate
decl_stmt|;
block|}
name|gai_restrans_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|gai_resstate
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|struct
name|gai_statehead
modifier|*
name|head
decl_stmt|;
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|dns_name_t
modifier|*
name|qname
decl_stmt|;
name|gai_restrans_t
modifier|*
name|trans4
decl_stmt|;
name|gai_restrans_t
modifier|*
name|trans6
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct gai_resstate
argument_list|)
name|link
expr_stmt|;
block|}
name|gai_resstate_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|gai_statehead
block|{
name|int
name|ai_family
decl_stmt|;
name|int
name|ai_flags
decl_stmt|;
name|int
name|ai_socktype
decl_stmt|;
name|int
name|ai_port
decl_stmt|;
name|isc_appctx_t
modifier|*
name|actx
decl_stmt|;
name|dns_client_t
modifier|*
name|dnsclient
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|struct gai_resstate
argument_list|)
name|resstates
expr_stmt|;
name|unsigned
name|int
name|activestates
decl_stmt|;
block|}
name|gai_statehead_t
typedef|;
end_typedef

begin_function
specifier|static
name|isc_result_t
name|make_resstate
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|gai_statehead_t
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|gai_resstate_t
modifier|*
modifier|*
name|statep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|gai_resstate_t
modifier|*
name|state
decl_stmt|;
name|dns_fixedname_t
name|fixeddomain
decl_stmt|;
name|dns_name_t
modifier|*
name|qdomain
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_boolean_t
name|need_v4
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|need_v6
init|=
name|ISC_FALSE
decl_stmt|;
name|state
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* Construct base domain name */
name|namelen
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|domain
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixeddomain
argument_list|)
expr_stmt|;
name|qdomain
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixeddomain
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|qdomain
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* Construct query name */
name|namelen
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|hostname
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|state
operator|->
name|fixedname
argument_list|)
expr_stmt|;
name|state
operator|->
name|qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|state
operator|->
name|fixedname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|state
operator|->
name|qname
argument_list|,
operator|&
name|b
argument_list|,
name|qdomain
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|head
operator|->
name|ai_family
operator|==
name|AF_UNSPEC
operator|||
name|head
operator|->
name|ai_family
operator|==
name|AF_INET
condition|)
name|need_v4
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|ai_family
operator|==
name|AF_UNSPEC
operator|||
name|head
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
name|need_v6
operator|=
name|ISC_TRUE
expr_stmt|;
name|state
operator|->
name|trans6
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|trans4
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|need_v4
condition|)
block|{
name|state
operator|->
name|trans4
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|gai_restrans_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|trans4
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|state
operator|->
name|trans4
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|trans4
operator|->
name|xid
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|trans4
operator|->
name|resstate
operator|=
name|state
expr_stmt|;
name|state
operator|->
name|trans4
operator|->
name|is_inprogress
operator|=
name|ISC_TRUE
expr_stmt|;
name|state
operator|->
name|trans4
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|need_v6
condition|)
block|{
name|state
operator|->
name|trans6
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|gai_restrans_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|trans6
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|trans4
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|state
operator|->
name|trans4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
operator|->
name|trans4
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|state
operator|->
name|trans6
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|trans6
operator|->
name|xid
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|trans6
operator|->
name|resstate
operator|=
name|state
expr_stmt|;
name|state
operator|->
name|trans6
operator|->
name|is_inprogress
operator|=
name|ISC_TRUE
expr_stmt|;
name|state
operator|->
name|trans6
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
block|}
name|state
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|state
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|state
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|statep
operator|=
name|state
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|make_resstates
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|gai_statehead_t
modifier|*
name|head
parameter_list|,
name|irs_resconf_t
modifier|*
name|resconf
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|irs_resconf_searchlist_t
modifier|*
name|searchlist
decl_stmt|;
name|irs_resconf_search_t
modifier|*
name|searchent
decl_stmt|;
name|gai_resstate_t
modifier|*
name|resstate
decl_stmt|,
modifier|*
name|resstate0
decl_stmt|;
name|resstate0
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|make_resstate
argument_list|(
name|mctx
argument_list|,
name|head
argument_list|,
name|hostname
argument_list|,
literal|"."
argument_list|,
operator|&
name|resstate0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|searchlist
operator|=
name|irs_resconf_getsearchlist
argument_list|(
name|resconf
argument_list|)
expr_stmt|;
for|for
control|(
name|searchent
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|searchlist
argument_list|)
init|;
name|searchent
operator|!=
name|NULL
condition|;
name|searchent
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|searchent
argument_list|,
name|link
argument_list|)
control|)
block|{
name|resstate
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|make_resstate
argument_list|(
name|mctx
argument_list|,
name|head
argument_list|,
name|hostname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|searchent
operator|->
name|domain
argument_list|,
operator|&
name|resstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|ISC_LIST_APPEND
argument_list|(
name|head
operator|->
name|resstates
argument_list|,
name|resstate
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|head
operator|->
name|activestates
operator|++
expr_stmt|;
block|}
comment|/* 	 * Insert the original hostname either at the head or the tail of the 	 * state list, depending on the number of labels contained in the 	 * original name and the 'ndots' configuration parameter. 	 */
if|if
condition|(
name|dns_name_countlabels
argument_list|(
name|resstate0
operator|->
name|qname
argument_list|)
operator|>
name|irs_resconf_getndots
argument_list|(
name|resconf
argument_list|)
operator|+
literal|1
condition|)
block|{
name|ISC_LIST_PREPEND
argument_list|(
name|head
operator|->
name|resstates
argument_list|,
name|resstate0
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|ISC_LIST_APPEND
argument_list|(
name|head
operator|->
name|resstates
argument_list|,
name|resstate0
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|head
operator|->
name|activestates
operator|++
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|resstate
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|head
operator|->
name|resstates
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|head
operator|->
name|resstates
argument_list|,
name|resstate
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|resstate
operator|->
name|trans4
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|resstate
operator|->
name|trans4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resstate
operator|->
name|trans4
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resstate
operator|->
name|trans6
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|resstate
operator|->
name|trans6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resstate
operator|->
name|trans6
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|resstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resstate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_answer
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|family
decl_stmt|;
name|gai_restrans_t
modifier|*
name|trans
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|gai_resstate_t
modifier|*
name|resstate
decl_stmt|;
name|dns_clientresevent_t
modifier|*
name|rev
init|=
operator|(
name|dns_clientresevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|dns_rdatatype_t
name|qtype
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|REQUIRE
argument_list|(
name|trans
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|resstate
operator|=
name|trans
operator|->
name|resstate
expr_stmt|;
name|REQUIRE
argument_list|(
name|resstate
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans
operator|==
name|resstate
operator|->
name|trans4
condition|)
block|{
name|family
operator|=
name|AF_INET
expr_stmt|;
name|qtype
operator|=
name|dns_rdatatype_a
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|trans
operator|==
name|resstate
operator|->
name|trans6
argument_list|)
expr_stmt|;
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|qtype
operator|=
name|dns_rdatatype_aaaa
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|trans
operator|->
name|is_inprogress
argument_list|)
expr_stmt|;
name|trans
operator|->
name|is_inprogress
operator|=
name|ISC_FALSE
expr_stmt|;
switch|switch
condition|(
name|rev
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|DNS_R_NCACHENXDOMAIN
case|:
comment|/* treat this as a fatal error? */
case|case
name|DNS_R_NCACHENXRRSET
case|:
break|break;
default|default:
switch|switch
condition|(
name|rev
operator|->
name|vresult
condition|)
block|{
case|case
name|DNS_R_SIGINVALID
case|:
case|case
name|DNS_R_SIGEXPIRED
case|:
case|case
name|DNS_R_SIGFUTURE
case|:
case|case
name|DNS_R_KEYUNAUTHORIZED
case|:
case|case
name|DNS_R_MUSTBESECURE
case|:
case|case
name|DNS_R_COVERINGNSEC
case|:
case|case
name|DNS_R_NOTAUTHORITATIVE
case|:
case|case
name|DNS_R_NOVALIDKEY
case|:
case|case
name|DNS_R_NOVALIDDS
case|:
case|case
name|DNS_R_NOVALIDSIG
case|:
name|error
operator|=
name|EAI_INSECUREDATA
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* Parse the response and construct the addrinfo chain */
for|for
control|(
name|name
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rev
operator|->
name|answerlist
argument_list|)
init|;
name|name
operator|!=
name|NULL
condition|;
name|name
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|name
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|char
name|t
index|[
literal|1024
index|]
decl_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|!=
name|qtype
condition|)
continue|continue;
if|if
condition|(
operator|(
name|resstate
operator|->
name|head
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_totext
argument_list|(
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|isc_buffer_putuint8
argument_list|(
operator|&
name|b
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
name|dns_rdata_in_a_t
name|rdata_a
decl_stmt|;
name|dns_rdata_in_aaaa_t
name|rdata_aaaa
decl_stmt|;
name|ai
operator|=
name|ai_alloc
argument_list|(
name|family
argument_list|,
operator|(
operator|(
name|family
operator|==
name|AF_INET6
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ai
operator|->
name|ai_socktype
operator|=
name|resstate
operator|->
name|head
operator|->
name|ai_socktype
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|trans
operator|->
name|ai_sentinel
operator|.
name|ai_next
expr_stmt|;
name|trans
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|=
name|ai
expr_stmt|;
comment|/* 				 * Set AF-specific parameters 				 * (IPv4/v6 address/port) 				 */
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rdata_a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|resstate
operator|->
name|head
operator|->
name|ai_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_addr
argument_list|,
operator|&
name|rdata_a
operator|.
name|in_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|rdata_a
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rdata_aaaa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_port
operator|=
name|resstate
operator|->
name|head
operator|->
name|ai_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|rdata_aaaa
operator|.
name|in6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|rdata_aaaa
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|resstate
operator|->
name|head
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|strdup
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
block|}
block|}
name|done
label|:
name|dns_client_freeresanswer
argument_list|(
name|resstate
operator|->
name|head
operator|->
name|dnsclient
argument_list|,
operator|&
name|rev
operator|->
name|answerlist
argument_list|)
expr_stmt|;
name|dns_client_destroyrestrans
argument_list|(
operator|&
name|trans
operator|->
name|xid
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
comment|/* Make sure that error == 0 iff we have a non-empty list */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|trans
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|trans
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|!=
name|NULL
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|trans
operator|->
name|ai_sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
name|trans
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|trans
operator|->
name|error
operator|=
name|error
expr_stmt|;
comment|/* Check whether we are done */
if|if
condition|(
operator|(
name|resstate
operator|->
name|trans4
operator|==
name|NULL
operator|||
operator|!
name|resstate
operator|->
name|trans4
operator|->
name|is_inprogress
operator|)
operator|&&
operator|(
name|resstate
operator|->
name|trans6
operator|==
name|NULL
operator|||
operator|!
name|resstate
operator|->
name|trans6
operator|->
name|is_inprogress
operator|)
condition|)
block|{
comment|/* 		 * We're done for this state.  If there is no other outstanding 		 * state, we can exit. 		 */
name|resstate
operator|->
name|head
operator|->
name|activestates
operator|--
expr_stmt|;
if|if
condition|(
name|resstate
operator|->
name|head
operator|->
name|activestates
operator|==
literal|0
condition|)
block|{
name|isc_app_ctxsuspend
argument_list|(
name|resstate
operator|->
name|head
operator|->
name|actx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * There are outstanding states, but if we are at the head 		 * of the state list (i.e., at the highest search priority) 		 * and have any answer, we can stop now by canceling the 		 * others. 		 */
if|if
condition|(
name|resstate
operator|==
name|ISC_LIST_HEAD
argument_list|(
name|resstate
operator|->
name|head
operator|->
name|resstates
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|resstate
operator|->
name|trans4
operator|!=
name|NULL
operator|&&
name|resstate
operator|->
name|trans4
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|resstate
operator|->
name|trans6
operator|!=
name|NULL
operator|&&
name|resstate
operator|->
name|trans6
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|!=
name|NULL
operator|)
condition|)
block|{
name|gai_resstate_t
modifier|*
name|rest
decl_stmt|;
for|for
control|(
name|rest
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|resstate
argument_list|,
name|link
argument_list|)
init|;
name|rest
operator|!=
name|NULL
condition|;
name|rest
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rest
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|rest
operator|->
name|trans4
operator|!=
name|NULL
operator|&&
name|rest
operator|->
name|trans4
operator|->
name|xid
operator|!=
name|NULL
condition|)
name|dns_client_cancelresolve
argument_list|(
name|rest
operator|->
name|trans4
operator|->
name|xid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
operator|->
name|trans6
operator|!=
name|NULL
operator|&&
name|rest
operator|->
name|trans6
operator|->
name|xid
operator|!=
name|NULL
condition|)
name|dns_client_cancelresolve
argument_list|(
name|rest
operator|->
name|trans6
operator|->
name|xid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * This search fails, so we move to the tail 				 * of the list so that the next entry will 				 * have the highest priority. 				 */
name|ISC_LIST_UNLINK
argument_list|(
name|resstate
operator|->
name|head
operator|->
name|resstates
argument_list|,
name|resstate
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|resstate
operator|->
name|head
operator|->
name|resstates
argument_list|,
name|resstate
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|resolve_name
parameter_list|(
name|int
name|family
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|irs_context_t
modifier|*
name|irsctx
decl_stmt|;
name|irs_resconf_t
modifier|*
name|conf
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_appctx_t
modifier|*
name|actx
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|int
name|terror
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dns_client_t
modifier|*
name|client
decl_stmt|;
name|gai_resstate_t
modifier|*
name|resstate
decl_stmt|;
name|gai_statehead_t
name|head
decl_stmt|;
name|isc_boolean_t
name|all_fail
init|=
name|ISC_TRUE
decl_stmt|;
comment|/* get IRS context and the associated parameters */
name|irsctx
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|irs_context_get
argument_list|(
operator|&
name|irsctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|EAI_FAIL
operator|)
return|;
name|actx
operator|=
name|irs_context_getappctx
argument_list|(
name|irsctx
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|irs_context_getmctx
argument_list|(
name|irsctx
argument_list|)
expr_stmt|;
name|task
operator|=
name|irs_context_gettask
argument_list|(
name|irsctx
argument_list|)
expr_stmt|;
name|conf
operator|=
name|irs_context_getresconf
argument_list|(
name|irsctx
argument_list|)
expr_stmt|;
name|client
operator|=
name|irs_context_getdnsclient
argument_list|(
name|irsctx
argument_list|)
expr_stmt|;
comment|/* construct resolution states */
name|head
operator|.
name|activestates
operator|=
literal|0
expr_stmt|;
name|head
operator|.
name|ai_family
operator|=
name|family
expr_stmt|;
name|head
operator|.
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|head
operator|.
name|ai_flags
operator|=
name|flags
expr_stmt|;
name|head
operator|.
name|ai_port
operator|=
name|port
expr_stmt|;
name|head
operator|.
name|actx
operator|=
name|actx
expr_stmt|;
name|head
operator|.
name|dnsclient
operator|=
name|client
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|head
operator|.
name|resstates
argument_list|)
expr_stmt|;
name|result
operator|=
name|make_resstates
argument_list|(
name|mctx
argument_list|,
name|hostname
argument_list|,
operator|&
name|head
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|EAI_FAIL
operator|)
return|;
for|for
control|(
name|resstate
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|head
operator|.
name|resstates
argument_list|)
init|;
name|resstate
operator|!=
name|NULL
condition|;
name|resstate
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|resstate
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|resstate
operator|->
name|trans4
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_client_startresolve
argument_list|(
name|client
argument_list|,
name|resstate
operator|->
name|qname
argument_list|,
name|dns_rdataclass_in
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
name|task
argument_list|,
name|process_answer
argument_list|,
name|resstate
operator|->
name|trans4
argument_list|,
operator|&
name|resstate
operator|->
name|trans4
operator|->
name|xid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|resstate
operator|->
name|trans4
operator|->
name|is_inprogress
operator|=
name|ISC_TRUE
expr_stmt|;
name|all_fail
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
name|resstate
operator|->
name|trans4
operator|->
name|is_inprogress
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|resstate
operator|->
name|trans6
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_client_startresolve
argument_list|(
name|client
argument_list|,
name|resstate
operator|->
name|qname
argument_list|,
name|dns_rdataclass_in
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
name|task
argument_list|,
name|process_answer
argument_list|,
name|resstate
operator|->
name|trans6
argument_list|,
operator|&
name|resstate
operator|->
name|trans6
operator|->
name|xid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|resstate
operator|->
name|trans6
operator|->
name|is_inprogress
operator|=
name|ISC_TRUE
expr_stmt|;
name|all_fail
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
name|resstate
operator|->
name|trans6
operator|->
name|is_inprogress
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|all_fail
condition|)
block|{
comment|/* Start all the events */
name|isc_app_ctxrun
argument_list|(
name|actx
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
comment|/* Cleanup */
while|while
condition|(
operator|(
name|resstate
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|head
operator|.
name|resstates
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|terror4
init|=
literal|0
decl_stmt|,
name|terror6
init|=
literal|0
decl_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|head
operator|.
name|resstates
argument_list|,
name|resstate
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|aip
operator|==
name|NULL
condition|)
block|{
name|struct
name|addrinfo
modifier|*
name|sentinel4
init|=
name|NULL
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|sentinel6
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|resstate
operator|->
name|trans4
operator|!=
name|NULL
condition|)
block|{
name|sentinel4
operator|=
name|resstate
operator|->
name|trans4
operator|->
name|ai_sentinel
operator|.
name|ai_next
expr_stmt|;
name|resstate
operator|->
name|trans4
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|resstate
operator|->
name|trans6
operator|!=
name|NULL
condition|)
block|{
name|sentinel6
operator|=
name|resstate
operator|->
name|trans6
operator|->
name|ai_sentinel
operator|.
name|ai_next
expr_stmt|;
name|resstate
operator|->
name|trans6
operator|->
name|ai_sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|aip
operator|=
name|ai_concat
argument_list|(
name|sentinel4
argument_list|,
name|sentinel6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resstate
operator|->
name|trans4
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|resstate
operator|->
name|trans4
operator|->
name|xid
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|terror4
operator|=
name|resstate
operator|->
name|trans4
operator|->
name|error
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|resstate
operator|->
name|trans4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resstate
operator|->
name|trans4
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resstate
operator|->
name|trans6
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|resstate
operator|->
name|trans6
operator|->
name|xid
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|terror6
operator|=
name|resstate
operator|->
name|trans6
operator|->
name|error
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|resstate
operator|->
name|trans6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resstate
operator|->
name|trans6
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the entire lookup fails, we need to choose an appropriate 		 * error code from individual codes.  We'll try to provide as 		 * specific a code as possible.  In general, we are going to 		 * find an error code other than EAI_NONAME (which is too 		 * generic and may actually not be problematic in some cases). 		 * EAI_NONAME will be set below if no better code is found. 		 */
if|if
condition|(
name|terror
operator|==
literal|0
operator|||
name|terror
operator|==
name|EAI_NONAME
condition|)
block|{
if|if
condition|(
name|terror4
operator|!=
literal|0
operator|&&
name|terror4
operator|!=
name|EAI_NONAME
condition|)
name|terror
operator|=
name|terror4
expr_stmt|;
elseif|else
if|if
condition|(
name|terror6
operator|!=
literal|0
operator|&&
name|terror6
operator|!=
name|EAI_NONAME
condition|)
name|terror
operator|=
name|terror6
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|resstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resstate
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|aip
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|terror
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/*  XXX: enabled for finding leaks.  should be cleaned up later. */
name|isc_app_ctxfinish
argument_list|(
name|actx
argument_list|)
expr_stmt|;
name|irs_context_destroy
argument_list|(
operator|&
name|irsctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|irs_strsep
parameter_list|(
name|char
modifier|*
modifier|*
name|stringp
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|string
init|=
operator|*
name|stringp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|char
name|sc
decl_stmt|,
name|dc
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|s
operator|=
name|string
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|sc
operator|=
operator|*
name|s
expr_stmt|;
for|for
control|(
name|d
operator|=
name|delim
init|;
operator|(
name|dc
operator|=
operator|*
name|d
operator|)
operator|!=
literal|'\0'
condition|;
name|d
operator|++
control|)
if|if
condition|(
name|sc
operator|==
name|dc
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|stringp
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
block|}
operator|*
name|stringp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_order
parameter_list|(
name|int
name|family
parameter_list|,
name|int
function_decl|(
modifier|*
modifier|*
name|net_order
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|char
modifier|*
name|order
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|int
name|found
decl_stmt|;
if|if
condition|(
name|family
condition|)
block|{
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|*
name|net_order
operator|++
operator|=
name|add_ipv4
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
operator|*
name|net_order
operator|++
operator|=
name|add_ipv6
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|order
operator|=
name|getenv
argument_list|(
literal|"NET_ORDER"
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|order
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We ignore any unknown names. 			 */
name|tok
operator|=
name|irs_strsep
argument_list|(
operator|&
name|order
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|tok
argument_list|,
literal|"inet6"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV6
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv6
expr_stmt|;
name|found
operator||=
name|FOUND_IPV6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tok
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|tok
argument_list|,
literal|"inet4"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV4
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv4
expr_stmt|;
name|found
operator||=
name|FOUND_IPV4
expr_stmt|;
block|}
block|}
comment|/* 		 * Add in anything that we didn't find. 		 */
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV4
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv4
expr_stmt|;
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV6
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv6
expr_stmt|;
block|}
operator|*
name|net_order
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|v4_loop
index|[
literal|4
index|]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_ipv4
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|UNUSED
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ai
operator|=
name|ai_clone
argument_list|(
operator|*
name|aip
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
comment|/* don't use ai_clone() */
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|freeaddrinfo
argument_list|(
operator|*
name|aip
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
block|}
operator|*
name|aip
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_addr
argument_list|,
name|v4_loop
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|v6_loop
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_ipv6
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|UNUSED
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ai
operator|=
name|ai_clone
argument_list|(
operator|*
name|aip
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
comment|/* don't use ai_clone() */
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|freeaddrinfo
argument_list|(
operator|*
name|aip
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
block|}
operator|*
name|aip
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|v6_loop
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*% Free address info. */
end_comment

begin_function
name|void
name|freeaddrinfo
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai_next
decl_stmt|;
while|while
condition|(
name|ai
operator|!=
name|NULL
condition|)
block|{
name|ai_next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_addr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|ai_next
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AF_LOCAL
end_ifdef

begin_function
specifier|static
name|int
name|get_local
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|socktype
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|slocal
decl_stmt|;
if|if
condition|(
name|socktype
operator|==
literal|0
condition|)
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
name|ai
operator|=
name|ai_alloc
argument_list|(
name|AF_LOCAL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slocal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
name|slocal
operator|=
name|SLOCAL
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|slocal
operator|->
name|sun_path
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|slocal
operator|->
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
comment|/* 	 * ai->ai_flags, ai->ai_protocol, ai->ai_canonname, 	 * and ai->ai_next were initialized to zero. 	 */
operator|*
name|res
operator|=
name|ai
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!  * Allocate an addrinfo structure, and a sockaddr structure  * of the specificed length.  We initialize:  *	ai_addrlen  *	ai_family  *	ai_addr  *	ai_addr->sa_family  *	ai_addr->sa_len	(IRS_PLATFORM_HAVESALEN)  * and everything else is initialized to zero.  */
end_comment

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_alloc
parameter_list|(
name|int
name|family
parameter_list|,
name|int
name|addrlen
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ai
operator|->
name|ai_addr
operator|=
name|SA
argument_list|(
name|calloc
argument_list|(
literal|1
argument_list|,
name|addrlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ai
operator|->
name|ai_addrlen
operator|=
name|addrlen
expr_stmt|;
name|ai
operator|->
name|ai_family
operator|=
name|family
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|family
expr_stmt|;
ifdef|#
directive|ifdef
name|IRS_PLATFORM_HAVESALEN
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|addrlen
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_clone
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|oai
parameter_list|,
name|int
name|family
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
name|ai_alloc
argument_list|(
name|family
argument_list|,
operator|(
operator|(
name|family
operator|==
name|AF_INET6
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|oai
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|oai
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|oai
operator|==
name|NULL
condition|)
return|return
operator|(
name|ai
operator|)
return|;
name|ai
operator|->
name|ai_flags
operator|=
name|oai
operator|->
name|ai_flags
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|oai
operator|->
name|ai_socktype
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|oai
operator|->
name|ai_protocol
expr_stmt|;
name|ai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|oai
expr_stmt|;
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_reverse
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|oai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|nai
decl_stmt|,
modifier|*
name|tai
decl_stmt|;
name|nai
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|oai
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Grab one off the old list. 		 */
name|tai
operator|=
name|oai
expr_stmt|;
name|oai
operator|=
name|oai
operator|->
name|ai_next
expr_stmt|;
comment|/* 		 * Put it on the front of the new list. 		 */
name|tai
operator|->
name|ai_next
operator|=
name|nai
expr_stmt|;
name|nai
operator|=
name|tai
expr_stmt|;
block|}
return|return
operator|(
name|nai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_concat
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai1
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|ai2
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai_tmp
decl_stmt|;
if|if
condition|(
name|ai1
operator|==
name|NULL
condition|)
return|return
operator|(
name|ai2
operator|)
return|;
elseif|else
if|if
condition|(
name|ai2
operator|==
name|NULL
condition|)
return|return
operator|(
name|ai1
operator|)
return|;
for|for
control|(
name|ai_tmp
operator|=
name|ai1
init|;
name|ai_tmp
operator|!=
name|NULL
operator|&&
name|ai_tmp
operator|->
name|ai_next
operator|!=
name|NULL
condition|;
name|ai_tmp
operator|=
name|ai_tmp
operator|->
name|ai_next
control|)
empty_stmt|;
name|ai_tmp
operator|->
name|ai_next
operator|=
name|ai2
expr_stmt|;
return|return
operator|(
name|ai1
operator|)
return|;
block|}
end_function

end_unit

