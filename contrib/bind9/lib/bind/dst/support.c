begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /proj/cvs/prod/bind9/lib/bind/dst/support.c,v 1.2.2.1 2001/11/02 22:25:29 gson Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Portions Copyright (c) 1995-1998 by Trusted Information Systems, Inc.  *  * Permission to use, copy modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND TRUSTED INFORMATION SYSTEMS  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL  * TRUSTED INFORMATION SYSTEMS BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  * WITH THE USE OR PERFORMANCE OF THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"dst_internal.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_comment
comment|/*  * dst_s_verify_str()  *     Validate that the input string(*str) is at the head of the input  *     buffer(**buf).  If so, move the buffer head pointer (*buf) to  *     the first byte of data following the string(*str).  * Parameters  *     buf     Input buffer.  *     str     Input string.  * Return  *	0       *str is not the head of **buff  *	1       *str is the head of **buff, *buf is is advanced to  *	the tail of **buf.  */
end_comment

begin_function
name|int
name|dst_s_verify_str
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|b
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
condition|)
comment|/* error checks */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
operator|*
name|str
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|b
operator|=
name|strlen
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
comment|/* get length of strings */
name|s
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|b
operator|||
name|strncmp
argument_list|(
operator|*
name|buf
argument_list|,
name|str
argument_list|,
name|s
argument_list|)
condition|)
comment|/* check if same */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not a match */
operator|(
operator|*
name|buf
operator|)
operator|+=
name|s
expr_stmt|;
comment|/* advance pointer */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_s_calculate_bits  *     Given a binary number represented in a u_char[], determine  *     the number of significant bits used.  * Parameters  *     str       An input character string containing a binary number.  *     max_bits The maximum possible significant bits.  * Return  *     N       The number of significant bits in str.  */
end_comment

begin_function
name|int
name|dst_s_calculate_bits
parameter_list|(
specifier|const
name|u_char
modifier|*
name|str
parameter_list|,
specifier|const
name|int
name|max_bits
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|u_char
name|i
decl_stmt|,
name|j
init|=
literal|0x80
decl_stmt|;
name|int
name|bits
decl_stmt|;
for|for
control|(
name|bits
operator|=
name|max_bits
init|;
operator|*
name|p
operator|==
literal|0x00
operator|&&
name|bits
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|bits
operator|-=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|p
init|;
operator|(
name|i
operator|&
name|j
operator|)
operator|!=
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
name|bits
operator|--
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * calculates a checksum used in dst for an id.  * takes an array of bytes and a length.  * returns a 16  bit checksum.  */
end_comment

begin_function
name|u_int16_t
name|dst_s_id_calc
parameter_list|(
specifier|const
name|u_char
modifier|*
name|key
parameter_list|,
specifier|const
name|int
name|keysize
parameter_list|)
block|{
name|u_int32_t
name|ac
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|kp
init|=
name|key
decl_stmt|;
name|int
name|size
init|=
name|keysize
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|||
operator|(
name|keysize
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|size
operator|>
literal|1
condition|;
name|size
operator|-=
literal|2
operator|,
name|kp
operator|+=
literal|2
control|)
name|ac
operator|+=
operator|(
operator|(
operator|*
name|kp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|kp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|ac
operator|+=
operator|(
operator|(
operator|*
name|kp
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ac
operator|+=
operator|(
name|ac
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
operator|(
name|ac
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * dst_s_dns_key_id() Function to calculate DNSSEC footprint from KEY record  *   rdata  * Input:  *	dns_key_rdata: the raw data in wire format   *      rdata_len: the size of the input data   * Output:  *      the key footprint/id calculated from the key data   */
end_comment

begin_function
name|u_int16_t
name|dst_s_dns_key_id
parameter_list|(
specifier|const
name|u_char
modifier|*
name|dns_key_rdata
parameter_list|,
specifier|const
name|int
name|rdata_len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dns_key_rdata
condition|)
return|return
literal|0
return|;
comment|/* compute id */
if|if
condition|(
name|dns_key_rdata
index|[
literal|3
index|]
operator|==
name|KEY_RSA
condition|)
comment|/* Algorithm RSA */
return|return
name|dst_s_get_int16
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
operator|&
name|dns_key_rdata
index|[
name|rdata_len
operator|-
literal|3
index|]
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dns_key_rdata
index|[
literal|3
index|]
operator|==
name|KEY_HMAC_MD5
condition|)
comment|/* compatibility */
return|return
literal|0
return|;
else|else
comment|/* compute a checksum on the key part of the key rr */
return|return
name|dst_s_id_calc
argument_list|(
name|dns_key_rdata
argument_list|,
name|rdata_len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_s_get_int16  *     This routine extracts a 16 bit integer from a two byte character  *     string.  The character string is assumed to be in network byte  *     order and may be unaligned.  The number returned is in host order.  * Parameter  *     buf     A two byte character string.  * Return  *     The converted integer value.  */
end_comment

begin_function
name|u_int16_t
name|dst_s_get_int16
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|register
name|u_int16_t
name|a
init|=
literal|0
decl_stmt|;
name|a
operator|=
operator|(
call|(
name|u_int16_t
call|)
argument_list|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
argument_list|)
operator|)
operator||
operator|(
call|(
name|u_int16_t
call|)
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_s_get_int32  *     This routine extracts a 32 bit integer from a four byte character  *     string.  The character string is assumed to be in network byte  *     order and may be unaligned.  The number returned is in host order.  * Parameter  *     buf     A four byte character string.  * Return  *     The converted integer value.  */
end_comment

begin_function
name|u_int32_t
name|dst_s_get_int32
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|register
name|u_int32_t
name|a
init|=
literal|0
decl_stmt|;
name|a
operator|=
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|24
argument_list|)
operator|)
operator||
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
argument_list|)
operator|)
operator||
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
argument_list|)
operator|)
operator||
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|buf
index|[
literal|3
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_s_put_int16  *     Take a 16 bit integer and store the value in a two byte  *     character string.  The integer is assumed to be in network  *     order and the string is returned in host order.  *  * Parameters  *     buf     Storage for a two byte character string.  *     val     16 bit integer.  */
end_comment

begin_function
name|void
name|dst_s_put_int16
parameter_list|(
name|u_int8_t
modifier|*
name|buf
parameter_list|,
specifier|const
name|u_int16_t
name|val
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dst_s_put_int32  *     Take a 32 bit integer and store the value in a four byte  *     character string.  The integer is assumed to be in network  *     order and the string is returned in host order.  *  * Parameters  *     buf     Storage for a four byte character string.  *     val     32 bit integer.  */
end_comment

begin_function
name|void
name|dst_s_put_int32
parameter_list|(
name|u_int8_t
modifier|*
name|buf
parameter_list|,
specifier|const
name|u_int32_t
name|val
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|val
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  dst_s_filename_length  *  *	This function returns the number of bytes needed to hold the  *	filename for a key file.  '/', '\' and ':' are not allowed.  *	form:  K<keyname>+<alg>+<id>.<suffix>  *  *	Returns 0 if the filename would contain either '\', '/' or ':'  */
end_comment

begin_function
name|size_t
name|dst_s_filename_length
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'\\'
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|suffix
argument_list|,
literal|'\\'
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|suffix
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|suffix
argument_list|,
literal|':'
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|6
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_s_build_filename ()  *	Builds a key filename from the key name, it's id, and a  *	suffix.  '\', '/' and ':' are not allowed. fA filename is of the  *	form:  K<keyname><id>.<suffix>  *	form: K<keyname>+<alg>+<id>.<suffix>  *  *	Returns -1 if the conversion fails:  *	  if the filename would be too long for space allotted  *	  if the filename would contain a '\', '/' or ':'  *	Returns 0 on success  */
end_comment

begin_function
name|int
name|dst_s_build_filename
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int16_t
name|id
parameter_list|,
name|int
name|alg
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|size_t
name|filename_length
parameter_list|)
block|{
name|u_int32_t
name|my_id
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memset
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|filename_length
operator|<
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
operator|+
literal|6
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|my_id
operator|=
name|id
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"K%s+%03d+%05d.%s"
argument_list|,
name|name
argument_list|,
name|alg
argument_list|,
name|my_id
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|':'
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_s_fopen ()  *     Open a file in the dst_path directory.  If perm is specified, the  *     file is checked for existence first, and not opened if it exists.  *  Parameters  *     filename  File to open  *     mode       Mode to open the file (passed directly to fopen)  *     perm       File permission, if creating a new file.  *  Returns  *     NULL       Failure  *     NON-NULL  (FILE *) of opened file.  */
end_comment

begin_function
name|FILE
modifier|*
name|dst_s_fopen
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|,
name|int
name|perm
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|pathname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|size_t
name|plen
init|=
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|dst_path
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|plen
operator|-=
name|strlen
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
else|else
name|pathname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|strlen
argument_list|(
name|filename
argument_list|)
condition|)
name|strncpy
argument_list|(
operator|&
name|pathname
index|[
name|PATH_MAX
operator|-
name|plen
index|]
argument_list|,
name|filename
argument_list|,
name|plen
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|fp
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|perm
condition|)
name|chmod
argument_list|(
name|pathname
argument_list|,
name|perm
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dst_s_dump
parameter_list|(
specifier|const
name|int
name|mode
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
specifier|const
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LONG_TEST
specifier|static
name|u_char
name|scratch
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
name|b64_ntop
argument_list|(
name|data
argument_list|,
name|scratch
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %x %d %s\n"
argument_list|,
name|msg
argument_list|,
name|mode
argument_list|,
name|n
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s,%x %d\n"
argument_list|,
name|msg
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

end_unit

