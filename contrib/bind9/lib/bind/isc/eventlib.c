begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1995-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* eventlib.c - implement glue for the eventlib  * vix 09sep95 [initial]  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: eventlib.c,v 1.2.2.1.4.6 2006/03/10 00:17:21 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|"fd_setsize.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS2
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLARIS2 */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|"eventlib_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_decl_stmt
name|int
name|__evOptMonoTime
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_POLL
end_ifdef

begin_define
define|#
directive|define
name|pselect
value|Pselect
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_POLL */
end_comment

begin_comment
comment|/* Forward. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_PSELECT
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_POLL
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|pselect
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|,
specifier|const
name|sigset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|__evOptMonoTime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Public. */
end_comment

begin_function
name|int
name|evCreate
parameter_list|(
name|evContext
modifier|*
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
decl_stmt|;
comment|/* Make sure the memory heap is initialized. */
if|if
condition|(
name|meminit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|OKNEW
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Global. */
name|ctx
operator|->
name|cur
operator|=
name|NULL
expr_stmt|;
comment|/* Debugging. */
name|ctx
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
comment|/* Connections. */
name|ctx
operator|->
name|conns
operator|=
name|NULL
expr_stmt|;
name|INIT_LIST
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
expr_stmt|;
comment|/* Files. */
ifdef|#
directive|ifdef
name|USE_POLL
name|ctx
operator|->
name|pollfds
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|maxnfds
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|firstfd
operator|=
literal|0
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|rdLast
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|rdNext
argument_list|,
name|EV_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|wrLast
argument_list|,
name|EV_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|wrNext
argument_list|,
name|EV_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|exLast
argument_list|,
name|EV_EXCEPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|exNext
argument_list|,
name|EV_EXCEPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emulMaskInit
argument_list|(
name|ctx
argument_list|,
name|nonblockBefore
argument_list|,
name|EV_WASNONBLOCKING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_POLL */
name|ctx
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|rdNext
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|wrNext
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|exNext
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|nonblockBefore
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdMax
operator|=
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|fdNext
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|=
literal|0
expr_stmt|;
comment|/* Invalidate {rd,wr,ex}Last. */
ifndef|#
directive|ifndef
name|USE_POLL
name|ctx
operator|->
name|highestFD
operator|=
name|FD_SETSIZE
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
name|ctx
operator|->
name|fdTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ctx
operator|->
name|fdTable
argument_list|)
expr_stmt|;
else|#
directive|else
name|ctx
operator|->
name|highestFD
operator|=
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdTable
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastFdCount
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Streams. */
name|ctx
operator|->
name|streams
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|strDone
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|strLast
operator|=
name|NULL
expr_stmt|;
comment|/* Timers. */
name|ctx
operator|->
name|lastEventTime
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastSelectTime
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|->
name|timers
operator|=
name|evCreateTimers
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|timers
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Waits. */
name|ctx
operator|->
name|waitLists
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|waitDone
operator|.
name|prev
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|opaqueCtx
operator|->
name|opaque
operator|=
name|ctx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evSetDebug
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|int
name|level
parameter_list|,
name|FILE
modifier|*
name|output
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|ctx
operator|->
name|debug
operator|=
name|level
expr_stmt|;
name|ctx
operator|->
name|output
operator|=
name|output
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evDestroy
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|int
name|revs
init|=
literal|424242
decl_stmt|;
comment|/* Doug Adams. */
name|evWaitList
modifier|*
name|this_wl
decl_stmt|,
modifier|*
name|next_wl
decl_stmt|;
name|evWait
modifier|*
name|this_wait
decl_stmt|,
modifier|*
name|next_wait
decl_stmt|;
comment|/* Connections. */
while|while
condition|(
name|revs
operator|--
operator|>
literal|0
operator|&&
name|ctx
operator|->
name|conns
operator|!=
name|NULL
condition|)
block|{
name|evConnID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ctx
operator|->
name|conns
expr_stmt|;
operator|(
name|void
operator|)
name|evCancelConn
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|revs
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Streams. */
while|while
condition|(
name|revs
operator|--
operator|>
literal|0
operator|&&
name|ctx
operator|->
name|streams
operator|!=
name|NULL
condition|)
block|{
name|evStreamID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ctx
operator|->
name|streams
expr_stmt|;
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* Files. */
while|while
condition|(
name|revs
operator|--
operator|>
literal|0
operator|&&
name|ctx
operator|->
name|files
operator|!=
name|NULL
condition|)
block|{
name|evFileID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ctx
operator|->
name|files
expr_stmt|;
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|revs
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Timers. */
name|evDestroyTimers
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Waits. */
for|for
control|(
name|this_wl
operator|=
name|ctx
operator|->
name|waitLists
init|;
name|revs
operator|--
operator|>
literal|0
operator|&&
name|this_wl
operator|!=
name|NULL
condition|;
name|this_wl
operator|=
name|next_wl
control|)
block|{
name|next_wl
operator|=
name|this_wl
operator|->
name|next
expr_stmt|;
for|for
control|(
name|this_wait
operator|=
name|this_wl
operator|->
name|first
init|;
name|revs
operator|--
operator|>
literal|0
operator|&&
name|this_wait
operator|!=
name|NULL
condition|;
name|this_wait
operator|=
name|next_wait
control|)
block|{
name|next_wait
operator|=
name|this_wait
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|this_wait
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|this_wl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|this_wait
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|first
init|;
name|revs
operator|--
operator|>
literal|0
operator|&&
name|this_wait
operator|!=
name|NULL
condition|;
name|this_wait
operator|=
name|next_wait
control|)
block|{
name|next_wait
operator|=
name|this_wait
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|this_wait
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evGetNext
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evEvent
modifier|*
name|opaqueEv
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|struct
name|timespec
name|nextTime
decl_stmt|;
name|evTimer
modifier|*
name|nextTimer
decl_stmt|;
name|evEvent_p
modifier|*
name|new
decl_stmt|;
name|int
name|x
decl_stmt|,
name|pselect_errno
decl_stmt|,
name|timerPast
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|struct
name|timespec
name|interval
decl_stmt|;
endif|#
directive|endif
comment|/* Ensure that exactly one of EV_POLL or EV_WAIT was specified. */
name|x
operator|=
operator|(
operator|(
name|options
operator|&
name|EV_POLL
operator|)
operator|!=
literal|0
operator|)
operator|+
operator|(
operator|(
name|options
operator|&
name|EV_WAIT
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|1
condition|)
name|EV_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* Get the time of day.  We'll do this again after select() blocks. */
name|ctx
operator|->
name|lastEventTime
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
name|again
label|:
comment|/* Finished accept()'s do not require a select(). */
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Accept
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|accept
operator|.
name|this
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|,
name|HEAD
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Stream IO does not require a select(). */
if|if
condition|(
name|ctx
operator|->
name|strDone
operator|!=
name|NULL
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Stream
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|stream
operator|.
name|this
operator|=
name|ctx
operator|->
name|strDone
expr_stmt|;
name|ctx
operator|->
name|strDone
operator|=
name|ctx
operator|->
name|strDone
operator|->
name|nextDone
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|strDone
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|strLast
operator|=
name|NULL
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Waits do not require a select(). */
if|if
condition|(
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Wait
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|wait
operator|.
name|this
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|first
expr_stmt|;
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|waitDone
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get the status and content of the next timer. */
if|if
condition|(
operator|(
name|nextTimer
operator|=
name|heap_element
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nextTime
operator|=
name|nextTimer
operator|->
name|due
expr_stmt|;
name|timerPast
operator|=
operator|(
name|evCmpTime
argument_list|(
name|nextTime
argument_list|,
name|ctx
operator|->
name|lastEventTime
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
block|}
else|else
name|timerPast
operator|=
literal|0
expr_stmt|;
comment|/* Make gcc happy. */
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|9
argument_list|,
literal|"evGetNext: fdCount %d\n"
argument_list|,
name|ctx
operator|->
name|fdCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|fdCount
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|struct
name|timespec
name|NoTime
init|=
block|{
literal|0
block|,
literal|0L
block|}
decl_stmt|;
enum|enum
block|{
name|JustPoll
block|,
name|Block
block|,
name|Timer
block|}
name|m
enum|;
name|struct
name|timespec
name|t
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
comment|/* Are there any events at all? */
if|if
condition|(
operator|(
name|options
operator|&
name|EV_WAIT
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|nextTimer
operator|&&
name|ctx
operator|->
name|fdMax
operator|==
operator|-
literal|1
condition|)
name|EV_ERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* Figure out what select()'s timeout parameter should be. */
if|if
condition|(
operator|(
name|options
operator|&
name|EV_POLL
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|JustPoll
expr_stmt|;
name|t
operator|=
name|NoTime
expr_stmt|;
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextTimer
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|Block
expr_stmt|;
comment|/* ``t'' unused. */
name|tp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timerPast
condition|)
block|{
name|m
operator|=
name|JustPoll
expr_stmt|;
name|t
operator|=
name|NoTime
expr_stmt|;
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|Timer
expr_stmt|;
comment|/* ``t'' filled in later. */
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|0
condition|)
block|{
name|interval
operator|=
name|evSubTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|ctx
operator|->
name|lastSelectTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|.
name|tv_sec
operator|>
literal|0
operator|||
name|interval
operator|.
name|tv_nsec
operator|>
literal|0
condition|)
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"time between pselect() %u.%09u count %d\n"
argument_list|,
name|interval
operator|.
name|tv_sec
argument_list|,
name|interval
operator|.
name|tv_nsec
argument_list|,
name|ctx
operator|->
name|lastFdCount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
do|do
block|{
ifndef|#
directive|ifndef
name|USE_POLL
comment|/* XXX need to copy only the bits we are using. */
name|ctx
operator|->
name|rdLast
operator|=
name|ctx
operator|->
name|rdNext
expr_stmt|;
name|ctx
operator|->
name|wrLast
operator|=
name|ctx
operator|->
name|wrNext
expr_stmt|;
name|ctx
operator|->
name|exLast
operator|=
name|ctx
operator|->
name|exNext
expr_stmt|;
else|#
directive|else
comment|/* 			 * The pollfd structure uses separate fields for 			 * the input and output events (corresponding to 			 * the ??Next and ??Last fd sets), so there's no 			 * need to copy one to the other. 			 */
endif|#
directive|endif
comment|/* USE_POLL */
if|if
condition|(
name|m
operator|==
name|Timer
condition|)
block|{
name|INSIST
argument_list|(
name|tp
operator|==
operator|&
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|evSubTime
argument_list|(
name|nextTime
argument_list|,
name|ctx
operator|->
name|lastEventTime
argument_list|)
expr_stmt|;
block|}
comment|/* XXX should predict system's earliness and adjust. */
name|x
operator|=
name|pselect
argument_list|(
name|ctx
operator|->
name|fdMax
operator|+
literal|1
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pselect_errno
operator|=
name|errno
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_POLL
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"select() returns %d (err: %s)\n"
argument_list|,
name|x
argument_list|,
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"none"
argument_list|)
expr_stmt|;
else|#
directive|else
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"poll() returns %d (err: %s)\n"
argument_list|,
name|x
argument_list|,
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_POLL */
comment|/* Anything but a poll can change the time. */
if|if
condition|(
name|m
operator|!=
name|JustPoll
condition|)
name|ctx
operator|->
name|lastEventTime
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
comment|/* Select() likes to finish about 10ms early. */
block|}
do|while
condition|(
name|x
operator|==
literal|0
operator|&&
name|m
operator|==
name|Timer
operator|&&
name|evCmpTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|nextTime
argument_list|)
operator|<
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastSelectTime
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|pselect_errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|EV_NULL
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|again
goto|;
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Null
expr_stmt|;
comment|/* No data. */
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pselect_errno
operator|==
name|EBADF
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|ctx
operator|->
name|fdMax
condition|;
name|x
operator|++
control|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|x
argument_list|,
operator|&
name|ctx
operator|->
name|rdNext
argument_list|)
operator|==
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|x
argument_list|,
operator|&
name|ctx
operator|->
name|wrNext
argument_list|)
operator|==
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|x
argument_list|,
operator|&
name|ctx
operator|->
name|exNext
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fstat
argument_list|(
name|x
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EBADF
condition|)
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"EBADF: %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
name|EV_ERR
argument_list|(
name|pselect_errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
operator|(
name|nextTimer
operator|==
name|NULL
operator|||
operator|!
name|timerPast
operator|)
operator|&&
operator|(
name|options
operator|&
name|EV_POLL
operator|)
condition|)
name|EV_ERR
argument_list|(
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastFdCount
operator|=
name|x
expr_stmt|;
endif|#
directive|endif
block|}
name|INSIST
argument_list|(
name|nextTimer
operator|||
name|ctx
operator|->
name|fdCount
argument_list|)
expr_stmt|;
comment|/* Timers go first since we'd like them to be accurate. */
if|if
condition|(
name|nextTimer
operator|&&
operator|!
name|timerPast
condition|)
block|{
comment|/* Has anything happened since we blocked? */
name|timerPast
operator|=
operator|(
name|evCmpTime
argument_list|(
name|nextTime
argument_list|,
name|ctx
operator|->
name|lastEventTime
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nextTimer
operator|&&
name|timerPast
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Timer
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|timer
operator|.
name|this
operator|=
name|nextTimer
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No timers, so there should be a ready file descriptor. */
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ctx
operator|->
name|fdCount
operator|>
literal|0
condition|)
block|{
name|evFile
modifier|*
name|fid
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|eventmask
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|fdNext
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|++
name|x
operator|==
literal|2
condition|)
block|{
comment|/* 				 * Hitting the end twice means that the last 				 * select() found some FD's which have since 				 * been deselected. 				 * 				 * On some systems, the count returned by 				 * selects is the total number of bits in 				 * all masks that are set, and on others it's 				 * the number of fd's that have some bit set, 				 * and on others, it's just broken.  We  				 * always assume that it's the number of 				 * bits set in all masks, because that's what 				 * the man page says it should do, and 				 * the worst that can happen is we do an 				 * extra select(). 				 */
name|ctx
operator|->
name|fdCount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ctx
operator|->
name|fdNext
operator|=
name|ctx
operator|->
name|files
expr_stmt|;
block|}
name|fid
operator|=
name|ctx
operator|->
name|fdNext
expr_stmt|;
name|ctx
operator|->
name|fdNext
operator|=
name|fid
operator|->
name|next
expr_stmt|;
name|fd
operator|=
name|fid
operator|->
name|fd
expr_stmt|;
name|eventmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
condition|)
name|eventmask
operator||=
name|EV_READ
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
condition|)
name|eventmask
operator||=
name|EV_WRITE
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
condition|)
name|eventmask
operator||=
name|EV_EXCEPT
expr_stmt|;
name|eventmask
operator|&=
name|fid
operator|->
name|eventmask
expr_stmt|;
if|if
condition|(
name|eventmask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|eventmask
operator|&
name|EV_READ
operator|)
operator|!=
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|EV_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|EV_EXCEPT
operator|)
operator|!=
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|File
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|file
operator|.
name|this
operator|=
name|fid
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|file
operator|.
name|eventmask
operator|=
name|eventmask
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|fdCount
operator|<
literal|0
condition|)
block|{
comment|/* 		 * select()'s count is off on a number of systems, and 		 * can result in fdCount< 0. 		 */
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"fdCount< 0 (%d)\n"
argument_list|,
name|ctx
operator|->
name|fdCount
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We get here if the caller deselect()'s an FD. Gag me with a goto. */
goto|goto
name|again
goto|;
block|}
end_function

begin_function
name|int
name|evDispatch
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evEvent
name|opaqueEv
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evEvent_p
modifier|*
name|ev
init|=
name|opaqueEv
operator|.
name|opaque
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|void
modifier|*
name|func
decl_stmt|;
name|struct
name|timespec
name|start_time
decl_stmt|;
name|struct
name|timespec
name|interval
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|0
condition|)
name|start_time
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|->
name|cur
operator|=
name|ev
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|type
condition|)
block|{
case|case
name|Accept
case|:
block|{
name|evAccept
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|accept
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Accept: fd %d -> %d, func %p, uap %p\n"
argument_list|,
name|this
operator|->
name|conn
operator|->
name|fd
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|conn
operator|->
name|func
argument_list|,
name|this
operator|->
name|conn
operator|->
name|uap
argument_list|)
expr_stmt|;
name|errno
operator|=
name|this
operator|->
name|ioErrno
expr_stmt|;
call|(
name|this
operator|->
name|conn
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|conn
operator|->
name|uap
argument_list|,
name|this
operator|->
name|fd
argument_list|,
operator|&
name|this
operator|->
name|la
argument_list|,
name|this
operator|->
name|lalen
argument_list|,
operator|&
name|this
operator|->
name|ra
argument_list|,
name|this
operator|->
name|ralen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|conn
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|File
case|:
block|{
name|evFile
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|file
operator|.
name|this
decl_stmt|;
name|int
name|eventmask
init|=
name|ev
operator|->
name|u
operator|.
name|file
operator|.
name|eventmask
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.File: fd %d, mask 0x%x, func %p, uap %p\n"
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|eventmask
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|eventmask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Stream
case|:
block|{
name|evStream
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|stream
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Stream: fd %d, func %p, uap %p\n"
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
name|errno
operator|=
name|this
operator|->
name|ioErrno
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|ioDone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Timer
case|:
block|{
name|evTimer
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|timer
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Timer: func %p, uap %p\n"
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|due
argument_list|,
name|this
operator|->
name|inter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Wait
case|:
block|{
name|evWait
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|wait
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Wait: tag %p, func %p, uap %p\n"
argument_list|,
name|this
operator|->
name|tag
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|tag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Null
case|:
block|{
comment|/* No work. */
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|0
condition|)
block|{
name|interval
operator|=
name|evSubTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
comment|/*  		 * Complain if it took longer than 50 milliseconds. 		 * 		 * We call getuid() to make an easy to find mark in a kernel 		 * trace. 		 */
if|if
condition|(
name|interval
operator|.
name|tv_sec
operator|>
literal|0
operator|||
name|interval
operator|.
name|tv_nsec
operator|>
literal|50000000
condition|)
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"dispatch interval %u.%09u uid %d type %d func %p\n"
argument_list|,
name|interval
operator|.
name|tv_sec
argument_list|,
name|interval
operator|.
name|tv_nsec
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|ev
operator|->
name|type
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctx
operator|->
name|cur
operator|=
name|NULL
expr_stmt|;
name|evDrop
argument_list|(
name|opaqueCtx
argument_list|,
name|opaqueEv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evDrop
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evEvent
name|opaqueEv
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evEvent_p
modifier|*
name|ev
init|=
name|opaqueEv
operator|.
name|opaque
decl_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|type
condition|)
block|{
case|case
name|Accept
case|:
block|{
name|FREE
argument_list|(
name|ev
operator|->
name|u
operator|.
name|accept
operator|.
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|File
case|:
block|{
comment|/* No work. */
break|break;
block|}
case|case
name|Stream
case|:
block|{
name|evStreamID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ev
operator|->
name|u
operator|.
name|stream
operator|.
name|this
expr_stmt|;
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Timer
case|:
block|{
name|evTimer
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|timer
operator|.
name|this
decl_stmt|;
name|evTimerID
name|opaque
decl_stmt|;
comment|/* Check to see whether the user func cleared the timer. */
if|if
condition|(
name|heap_element
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|this
operator|->
name|index
argument_list|)
operator|!=
name|this
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Timer: timer rm'd?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Timer is still there.  Delete it if it has expired, 		 * otherwise set it according to its next interval. 		 */
if|if
condition|(
name|this
operator|->
name|inter
operator|.
name|tv_sec
operator|==
operator|(
name|time_t
operator|)
literal|0
operator|&&
name|this
operator|->
name|inter
operator|.
name|tv_nsec
operator|==
literal|0L
condition|)
block|{
name|opaque
operator|.
name|opaque
operator|=
name|this
expr_stmt|;
operator|(
name|void
operator|)
name|evClearTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opaque
operator|.
name|opaque
operator|=
name|this
expr_stmt|;
operator|(
name|void
operator|)
name|evResetTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|opaque
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|evAddTime
argument_list|(
operator|(
name|this
operator|->
name|mode
operator|&
name|EV_TMR_RATE
operator|)
condition|?
name|this
operator|->
name|due
else|:
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|this
operator|->
name|inter
argument_list|)
argument_list|,
name|this
operator|->
name|inter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Wait
case|:
block|{
name|FREE
argument_list|(
name|ev
operator|->
name|u
operator|.
name|wait
operator|.
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Null
case|:
block|{
comment|/* No work. */
break|break;
block|}
default|default:
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evMainLoop
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evEvent
name|event
decl_stmt|;
name|int
name|x
decl_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
name|evGetNext
argument_list|(
name|opaqueCtx
argument_list|,
operator|&
name|event
argument_list|,
name|EV_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|x
operator|=
name|evDispatch
argument_list|(
name|opaqueCtx
argument_list|,
name|event
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evHighestFD
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
return|return
operator|(
name|ctx
operator|->
name|highestFD
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evPrintf
parameter_list|(
specifier|const
name|evContext_p
modifier|*
name|ctx
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|output
operator|!=
name|NULL
operator|&&
name|ctx
operator|->
name|debug
operator|>=
name|level
condition|)
block|{
name|vfprintf
argument_list|(
name|ctx
operator|->
name|output
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ctx
operator|->
name|output
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evSetOption
parameter_list|(
name|evContext
modifier|*
name|opaqueCtx
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/* evContext_p *ctx = opaqueCtx->opaque; */
name|UNUSED
argument_list|(
name|opaqueCtx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CLOCK_MONOTONIC
name|UNUSED
argument_list|(
name|option
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLOCK_MONOTONIC
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"monotime"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opaqueCtx
operator|!=
name|NULL
condition|)
name|errno
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
operator|||
name|value
operator|==
literal|1
condition|)
block|{
name|__evOptMonoTime
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evGetOption
parameter_list|(
name|evContext
modifier|*
name|opaqueCtx
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
comment|/* evContext_p *ctx = opaqueCtx->opaque; */
name|UNUSED
argument_list|(
name|opaqueCtx
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CLOCK_MONOTONIC
name|UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|option
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLOCK_MONOTONIC
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"monotime"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opaqueCtx
operator|!=
name|NULL
condition|)
name|errno
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|value
operator|=
name|__evOptMonoTime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_PSELECT
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_POLL
argument_list|)
end_if

begin_comment
comment|/* XXX needs to move to the porting library. */
end_comment

begin_function
specifier|static
name|int
name|pselect
parameter_list|(
name|int
name|nfds
parameter_list|,
name|void
modifier|*
name|rfds
parameter_list|,
name|void
modifier|*
name|wfds
parameter_list|,
name|void
modifier|*
name|efds
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|sigset_t
name|sigs
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_POLL
name|int
name|polltimeout
init|=
name|INFTIM
decl_stmt|;
name|evContext_p
modifier|*
name|ctx
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|nfds_t
name|pnfds
decl_stmt|;
name|UNUSED
argument_list|(
name|nfds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_POLL */
if|if
condition|(
name|tsp
condition|)
block|{
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
name|tv
operator|=
name|evTimeVal
argument_list|(
operator|*
name|tsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_POLL
name|polltimeout
operator|=
literal|1000
operator|*
name|tv
operator|.
name|tv_sec
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
comment|/* USE_POLL */
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sigmask
condition|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|sigmask
argument_list|,
operator|&
name|sigs
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_POLL
name|n
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
name|rfds
argument_list|,
name|wfds
argument_list|,
name|efds
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * rfds, wfds, and efds should all be from the same evContext_p, 	 * so any of them will do. If they're all NULL, the caller is 	 * presumably calling us to block. 	 */
if|if
condition|(
name|rfds
operator|!=
name|NULL
condition|)
name|ctx
operator|=
operator|(
operator|(
name|__evEmulMask
operator|*
operator|)
name|rfds
operator|)
operator|->
name|ctx
expr_stmt|;
elseif|else
if|if
condition|(
name|wfds
operator|!=
name|NULL
condition|)
name|ctx
operator|=
operator|(
operator|(
name|__evEmulMask
operator|*
operator|)
name|wfds
operator|)
operator|->
name|ctx
expr_stmt|;
elseif|else
if|if
condition|(
name|efds
operator|!=
name|NULL
condition|)
name|ctx
operator|=
operator|(
operator|(
name|__evEmulMask
operator|*
operator|)
name|efds
operator|)
operator|->
name|ctx
expr_stmt|;
else|else
name|ctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
operator|&&
name|ctx
operator|->
name|fdMax
operator|!=
operator|-
literal|1
condition|)
block|{
name|fds
operator|=
operator|&
operator|(
name|ctx
operator|->
name|pollfds
index|[
name|ctx
operator|->
name|firstfd
index|]
operator|)
expr_stmt|;
name|pnfds
operator|=
name|ctx
operator|->
name|fdMax
operator|-
name|ctx
operator|->
name|firstfd
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fds
operator|=
name|NULL
expr_stmt|;
name|pnfds
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
name|poll
argument_list|(
name|fds
argument_list|,
name|pnfds
argument_list|,
name|polltimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|e
decl_stmt|;
name|INSIST
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
operator|,
name|i
operator|=
name|ctx
operator|->
name|firstfd
init|;
name|i
operator|<=
name|ctx
operator|->
name|fdMax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|pollfds
index|[
name|i
index|]
operator|.
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
condition|)
name|e
operator|++
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
condition|)
name|e
operator|++
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
condition|)
name|e
operator|++
expr_stmt|;
block|}
name|n
operator|=
name|e
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_POLL */
if|if
condition|(
name|sigmask
condition|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsp
condition|)
operator|*
name|tsp
operator|=
name|evTimeSpec
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_POLL
end_ifdef

begin_function
name|int
name|evPollfdRealloc
parameter_list|(
name|evContext_p
modifier|*
name|ctx
parameter_list|,
name|int
name|pollfd_chunk_size
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|maxnfds
decl_stmt|;
name|void
modifier|*
name|pollfds
decl_stmt|,
modifier|*
name|fdTable
decl_stmt|;
if|if
condition|(
name|fd
operator|<
name|ctx
operator|->
name|maxnfds
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Don't allow ridiculously small values for pollfd_chunk_size */
if|if
condition|(
name|pollfd_chunk_size
operator|<
literal|20
condition|)
name|pollfd_chunk_size
operator|=
literal|20
expr_stmt|;
name|maxnfds
operator|=
operator|(
literal|1
operator|+
operator|(
name|fd
operator|/
name|pollfd_chunk_size
operator|)
operator|)
operator|*
name|pollfd_chunk_size
expr_stmt|;
name|pollfds
operator|=
name|realloc
argument_list|(
name|ctx
operator|->
name|pollfds
argument_list|,
name|maxnfds
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|pollfds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pollfds
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|pollfds
operator|=
name|pollfds
expr_stmt|;
name|fdTable
operator|=
name|realloc
argument_list|(
name|ctx
operator|->
name|fdTable
argument_list|,
name|maxnfds
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|fdTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdTable
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|fdTable
operator|=
name|fdTable
expr_stmt|;
if|if
condition|(
name|pollfds
operator|==
name|NULL
operator|||
name|fdTable
operator|==
name|NULL
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|2
argument_list|,
literal|"pollfd() realloc (%ld) failed\n"
argument_list|,
operator|(
name|long
operator|)
name|maxnfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|ctx
operator|->
name|maxnfds
init|;
name|i
operator|<
name|maxnfds
condition|;
name|i
operator|++
control|)
block|{
name|ctx
operator|->
name|pollfds
index|[
name|i
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|pollfds
index|[
name|i
index|]
operator|.
name|events
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|fdTable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ctx
operator|->
name|maxnfds
operator|=
name|maxnfds
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the appropriate 'events' or 'revents' field in the pollfds array */
end_comment

begin_function
name|short
modifier|*
name|__fd_eventfield
parameter_list|(
name|int
name|fd
parameter_list|,
name|__evEmulMask
modifier|*
name|maskp
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
operator|(
name|evContext_p
operator|*
operator|)
name|maskp
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|maskp
operator|->
name|result
operator|||
name|maskp
operator|->
name|type
operator|==
name|EV_WASNONBLOCKING
condition|)
return|return
operator|(
operator|&
operator|(
name|ctx
operator|->
name|pollfds
index|[
name|fd
index|]
operator|.
name|events
operator|)
operator|)
return|;
else|else
return|return
operator|(
operator|&
operator|(
name|ctx
operator|->
name|pollfds
index|[
name|fd
index|]
operator|.
name|revents
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translate to poll(2) event */
end_comment

begin_function
name|short
name|__poll_event
parameter_list|(
name|__evEmulMask
modifier|*
name|maskp
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|maskp
operator|)
operator|->
name|type
condition|)
block|{
case|case
name|EV_READ
case|:
return|return
operator|(
name|POLLRDNORM
operator|)
return|;
case|case
name|EV_WRITE
case|:
return|return
operator|(
name|POLLWRNORM
operator|)
return|;
case|case
name|EV_EXCEPT
case|:
return|return
operator|(
name|POLLRDBAND
operator||
name|POLLPRI
operator||
name|POLLWRBAND
operator|)
return|;
case|case
name|EV_WASNONBLOCKING
case|:
return|return
operator|(
name|POLLHUP
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear the events corresponding to the specified mask. If this leaves  * the events mask empty (apart from the POLLHUP bit), set the fd field  * to -1 so that poll(2) will ignore this fd.  */
end_comment

begin_function
name|void
name|__fd_clr
parameter_list|(
name|int
name|fd
parameter_list|,
name|__evEmulMask
modifier|*
name|maskp
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|maskp
operator|->
name|ctx
decl_stmt|;
operator|*
name|__fd_eventfield
argument_list|(
name|fd
argument_list|,
name|maskp
argument_list|)
operator|&=
operator|~
name|__poll_event
argument_list|(
name|maskp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|pollfds
index|[
name|fd
index|]
operator|.
name|events
operator|&
operator|~
name|POLLHUP
operator|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|pollfds
index|[
name|fd
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|ctx
operator|->
name|fdMax
condition|)
while|while
condition|(
name|ctx
operator|->
name|fdMax
operator|>
name|ctx
operator|->
name|firstfd
operator|&&
name|ctx
operator|->
name|pollfds
index|[
name|ctx
operator|->
name|fdMax
index|]
operator|.
name|fd
operator|<
literal|0
condition|)
name|ctx
operator|->
name|fdMax
operator|--
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|ctx
operator|->
name|firstfd
condition|)
while|while
condition|(
name|ctx
operator|->
name|firstfd
operator|<=
name|ctx
operator|->
name|fdMax
operator|&&
name|ctx
operator|->
name|pollfds
index|[
name|ctx
operator|->
name|firstfd
index|]
operator|.
name|fd
operator|<
literal|0
condition|)
name|ctx
operator|->
name|firstfd
operator|++
expr_stmt|;
comment|/* 		 * Do we have a empty set of descriptors? 		 */
if|if
condition|(
name|ctx
operator|->
name|firstfd
operator|>
name|ctx
operator|->
name|fdMax
condition|)
block|{
name|ctx
operator|->
name|fdMax
operator|=
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|firstfd
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set the events bit(s) corresponding to the specified mask. If the events  * field has any other bits than POLLHUP set, also set the fd field so that  * poll(2) will watch this fd.  */
end_comment

begin_function
name|void
name|__fd_set
parameter_list|(
name|int
name|fd
parameter_list|,
name|__evEmulMask
modifier|*
name|maskp
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|maskp
operator|->
name|ctx
decl_stmt|;
operator|*
name|__fd_eventfield
argument_list|(
name|fd
argument_list|,
name|maskp
argument_list|)
operator||=
name|__poll_event
argument_list|(
name|maskp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|pollfds
index|[
name|fd
index|]
operator|.
name|events
operator|&
operator|~
name|POLLHUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctx
operator|->
name|pollfds
index|[
name|fd
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|fd
operator|<
name|ctx
operator|->
name|firstfd
operator|||
name|ctx
operator|->
name|fdMax
operator|==
operator|-
literal|1
condition|)
name|ctx
operator|->
name|firstfd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|ctx
operator|->
name|fdMax
condition|)
name|ctx
operator|->
name|fdMax
operator|=
name|fd
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_POLL */
end_comment

begin_comment
comment|/*! \file */
end_comment

end_unit

