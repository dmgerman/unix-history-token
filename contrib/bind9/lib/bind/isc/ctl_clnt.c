begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ctl_clnt.c,v 1.7.18.3 2008-02-18 04:04:06 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1998,1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* Extern. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MEMORY_H
end_ifdef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|<isc/ctl.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"ctl_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_comment
comment|/* Constants. */
end_comment

begin_comment
comment|/* Macros. */
end_comment

begin_define
define|#
directive|define
name|donefunc_p
parameter_list|(
name|ctx
parameter_list|)
value|((ctx).donefunc != NULL)
end_define

begin_define
define|#
directive|define
name|arpacode_p
parameter_list|(
name|line
parameter_list|)
value|(isdigit((unsigned char)(line[0]))&& \ 			  isdigit((unsigned char)(line[1]))&& \ 			  isdigit((unsigned char)(line[2])))
end_define

begin_define
define|#
directive|define
name|arpacont_p
parameter_list|(
name|line
parameter_list|)
value|(line[3] == '-')
end_define

begin_define
define|#
directive|define
name|arpadone_p
parameter_list|(
name|line
parameter_list|)
value|(line[3] == ' ' || line[3] == '\t' || \ 			  line[3] == '\r' || line[3] == '\0')
end_define

begin_comment
comment|/* Types. */
end_comment

begin_enum
enum|enum
name|state
block|{
name|initializing
init|=
literal|0
block|,
name|connecting
block|,
name|connected
block|,
name|destroyed
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ctl_tran
block|{
name|LINK
argument_list|(
argument|struct ctl_tran
argument_list|)
name|link
expr_stmt|;
name|LINK
argument_list|(
argument|struct ctl_tran
argument_list|)
name|wlink
expr_stmt|;
name|struct
name|ctl_cctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ctl_buf
name|outbuf
decl_stmt|;
name|ctl_clntdone
name|donefunc
decl_stmt|;
name|void
modifier|*
name|uap
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctl_cctx
block|{
name|enum
name|state
name|state
decl_stmt|;
name|evContext
name|ev
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|ctl_logfunc
name|logger
decl_stmt|;
name|ctl_clntdone
name|donefunc
decl_stmt|;
name|void
modifier|*
name|uap
decl_stmt|;
name|evConnID
name|coID
decl_stmt|;
name|evTimerID
name|tiID
decl_stmt|;
name|evFileID
name|rdID
decl_stmt|;
name|evStreamID
name|wrID
decl_stmt|;
name|struct
name|ctl_buf
name|inbuf
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|LIST
argument_list|(
argument|struct ctl_tran
argument_list|)
name|tran
expr_stmt|;
name|LIST
argument_list|(
argument|struct ctl_tran
argument_list|)
name|wtran
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|struct
name|ctl_tran
modifier|*
name|new_tran
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|,
name|ctl_clntdone
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_write
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|new_state
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|,
name|enum
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|conn_done
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_done
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_read
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_read
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readable
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_timer
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_timer
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|touch_timer
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timer
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timespec
parameter_list|,
name|struct
name|timespec
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMCHR
end_ifndef

begin_function
specifier|static
name|void
modifier|*
name|memchr
parameter_list|(
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|b
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|unsigned
name|char
operator|)
name|c
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Private data. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|state_names
index|[]
init|=
block|{
literal|"initializing"
block|,
literal|"connecting"
block|,
literal|"connected"
block|,
literal|"destroyed"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Public. */
end_comment

begin_comment
comment|/*%  * void  * ctl_client()  *	create, condition, and connect to a listener on the control port.  */
end_comment

begin_function
name|struct
name|ctl_cctx
modifier|*
name|ctl_client
parameter_list|(
name|evContext
name|lev
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|cap
parameter_list|,
name|size_t
name|cap_len
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sap
parameter_list|,
name|size_t
name|sap_len
parameter_list|,
name|ctl_clntdone
name|donefunc
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|u_int
name|timeout
parameter_list|,
name|ctl_logfunc
name|logger
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_client"
decl_stmt|;
specifier|static
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|struct
name|ctl_cctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|captmp
decl_stmt|;
if|if
condition|(
name|logger
operator|==
name|NULL
condition|)
name|logger
operator|=
name|ctl_logger
expr_stmt|;
name|ctx
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: getmem: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
name|ctx
operator|->
name|state
operator|=
name|initializing
expr_stmt|;
name|ctx
operator|->
name|ev
operator|=
name|lev
expr_stmt|;
name|ctx
operator|->
name|logger
operator|=
name|logger
expr_stmt|;
name|ctx
operator|->
name|timeout
operator|=
name|evConsTime
argument_list|(
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|donefunc
operator|=
name|donefunc
expr_stmt|;
name|ctx
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|ctx
operator|->
name|coID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|rdID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|buffer_init
argument_list|(
name|ctx
operator|->
name|inbuf
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
name|ctx
operator|->
name|tran
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
name|ctx
operator|->
name|wtran
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|sock
operator|=
name|socket
argument_list|(
name|sap
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|sock
operator|>
name|evHighestFD
argument_list|(
name|ctx
operator|->
name|ev
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOTSOCK
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|sock
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: socket: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
if|if
condition|(
name|cap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|ctx
operator|->
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: setsockopt(REUSEADDR): %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DE_CONST
argument_list|(
name|cap
argument_list|,
name|captmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|ctx
operator|->
name|sock
argument_list|,
name|captmp
argument_list|,
name|cap_len
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: bind: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
block|}
if|if
condition|(
name|evConnect
argument_list|(
name|lev
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|sap
argument_list|,
name|sap_len
argument_list|,
name|conn_done
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|coID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evConnect(fd %d): %s"
argument_list|,
name|me
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fatal
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|sock
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_state
argument_list|(
name|ctx
argument_list|,
name|connecting
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * void  * ctl_endclient(ctx)  *	close a client and release all of its resources.  */
end_comment

begin_function
name|void
name|ctl_endclient
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|state
operator|!=
name|destroyed
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * int  * ctl_command(ctx, cmd, len, donefunc, uap)  *	Queue a transaction, which will begin with sending cmd  *	and complete by calling donefunc with the answer.  */
end_comment

begin_function
name|int
name|ctl_command
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|size_t
name|len
parameter_list|,
name|ctl_clntdone
name|donefunc
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|ctl_tran
modifier|*
name|tran
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|state
condition|)
block|{
case|case
name|destroyed
case|:
name|errno
operator|=
name|ENOTCONN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|connecting
case|:
case|case
name|connected
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
operator|(
name|size_t
operator|)
name|MAX_LINELEN
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tran
operator|=
name|new_tran
argument_list|(
name|ctx
argument_list|,
name|donefunc
argument_list|,
name|uap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tran
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ctl_bufget
argument_list|(
operator|&
name|tran
operator|->
name|outbuf
argument_list|,
name|ctx
operator|->
name|logger
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|tran
operator|->
name|outbuf
operator|.
name|text
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tran
operator|->
name|outbuf
operator|.
name|used
operator|=
name|len
expr_stmt|;
for|for
control|(
name|pc
operator|=
name|tran
operator|->
name|outbuf
operator|.
name|text
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|tran
operator|->
name|outbuf
operator|.
name|used
condition|;
name|pc
operator|++
operator|,
name|n
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pc
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pc
argument_list|)
condition|)
operator|*
name|pc
operator|=
literal|'\040'
expr_stmt|;
name|start_write
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Private. */
end_comment

begin_function
specifier|static
name|struct
name|ctl_tran
modifier|*
name|new_tran
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|,
name|ctl_clntdone
name|donefunc
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|struct
name|ctl_tran
modifier|*
name|new
init|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|buffer_init
argument_list|(
name|new
operator|->
name|outbuf
argument_list|)
expr_stmt|;
name|new
operator|->
name|donefunc
operator|=
name|donefunc
expr_stmt|;
name|new
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|INIT_LINK
argument_list|(
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INIT_LINK
argument_list|(
name|new
argument_list|,
name|wlink
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|ctx
operator|->
name|tran
argument_list|,
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|APPEND
argument_list|(
name|ctx
operator|->
name|wtran
argument_list|,
name|new
argument_list|,
name|wlink
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_write
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::start_write"
decl_stmt|;
name|struct
name|ctl_tran
modifier|*
name|tran
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|iovp
init|=
name|iov
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|state
operator|==
name|connecting
operator|||
name|ctx
operator|->
name|state
operator|==
name|connected
argument_list|)
expr_stmt|;
comment|/* If there is a write in progress, don't try to write more yet. */
if|if
condition|(
name|ctx
operator|->
name|wrID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
return|return;
comment|/* If there are no trans, make sure timer is off, and we're done. */
if|if
condition|(
name|EMPTY
argument_list|(
name|ctx
operator|->
name|wtran
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
name|stop_timer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Pull it off the head of the write queue. */
name|tran
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|wtran
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|ctx
operator|->
name|wtran
argument_list|,
name|tran
argument_list|,
name|wlink
argument_list|)
expr_stmt|;
comment|/* Since there are some trans, make sure timer is successfully "on". */
if|if
condition|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
name|touch_timer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
name|start_timer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|destroyed
condition|)
return|return;
comment|/* Marshall a newline-terminated message and clock it out. */
operator|*
name|iovp
operator|++
operator|=
name|evConsIovec
argument_list|(
name|tran
operator|->
name|outbuf
operator|.
name|text
argument_list|,
name|tran
operator|->
name|outbuf
operator|.
name|used
argument_list|)
expr_stmt|;
name|DE_CONST
argument_list|(
literal|"\r\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|iovp
operator|++
operator|=
name|evConsIovec
argument_list|(
name|tmp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|evWrite
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
name|iov
argument_list|,
name|iovp
operator|-
name|iov
argument_list|,
name|write_done
argument_list|,
name|tran
argument_list|,
operator|&
name|ctx
operator|->
name|wrID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evWrite: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evTimeRW
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|wrID
argument_list|,
name|ctx
operator|->
name|tiID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evTimeRW: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|,
name|int
name|notify
parameter_list|)
block|{
name|struct
name|ctl_tran
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|ctx
operator|->
name|state
condition|)
block|{
case|case
name|connecting
case|:
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|wrID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EMPTY
argument_list|(
name|ctx
operator|->
name|tran
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * This test is nec'y since destroy() can be called from 		 * start_read() while the state is still "connecting". 		 */
if|if
condition|(
name|ctx
operator|->
name|coID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evCancelConn
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|coID
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|coID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|connected
case|:
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|coID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|wrID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|wrID
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|rdID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
name|stop_read
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|destroyed
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|allocated_p
argument_list|(
name|ctx
operator|->
name|inbuf
argument_list|)
condition|)
name|ctl_bufput
argument_list|(
operator|&
name|ctx
operator|->
name|inbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|this
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|tran
argument_list|)
init|;
name|this
operator|!=
name|NULL
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_p
argument_list|(
name|this
operator|->
name|outbuf
argument_list|)
condition|)
name|ctl_bufput
argument_list|(
operator|&
name|this
operator|->
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|&&
name|this
operator|->
name|donefunc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|this
operator|->
name|donefunc
call|)
argument_list|(
name|ctx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|this
argument_list|,
sizeof|sizeof
expr|*
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
name|stop_timer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|new_state
argument_list|(
name|ctx
argument_list|,
name|destroyed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|state
operator|!=
name|destroyed
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_state
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|,
name|enum
name|state
name|new_state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::new_state"
decl_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: %s -> %s"
argument_list|,
name|me
argument_list|,
name|state_names
index|[
name|ctx
operator|->
name|state
index|]
argument_list|,
name|state_names
index|[
name|new_state
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|conn_done
parameter_list|(
name|evContext
name|ev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|la
parameter_list|,
name|int
name|lalen
parameter_list|,
specifier|const
name|void
modifier|*
name|ra
parameter_list|,
name|int
name|ralen
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::conn_done"
decl_stmt|;
name|struct
name|ctl_cctx
modifier|*
name|ctx
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_tran
modifier|*
name|tran
decl_stmt|;
name|UNUSED
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|lalen
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ra
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ralen
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|coID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evConnect: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_state
argument_list|(
name|ctx
argument_list|,
name|connected
argument_list|)
expr_stmt|;
name|tran
operator|=
name|new_tran
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|donefunc
argument_list|,
name|ctx
operator|->
name|uap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tran
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: new_tran failed: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_read
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|destroyed
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: start_read failed: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_done
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|struct
name|ctl_tran
modifier|*
name|tran
init|=
operator|(
expr|struct
name|ctl_tran
operator|*
operator|)
name|uap
decl_stmt|;
name|struct
name|ctl_cctx
modifier|*
name|ctx
init|=
name|tran
operator|->
name|ctx
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
name|touch_timer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctl_bufput
argument_list|(
operator|&
name|tran
operator|->
name|outbuf
argument_list|)
expr_stmt|;
name|start_write
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
name|destroy
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|start_read
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_read
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::start_read"
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|state
operator|==
name|connecting
operator|||
name|ctx
operator|->
name|state
operator|==
name|connected
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|rdID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSelectFD
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
name|EV_READ
argument_list|,
name|readable
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|rdID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evSelect(fd %d): %s"
argument_list|,
name|me
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_read
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|coID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|rdID
operator|.
name|opaque
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|rdID
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rdID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readable
parameter_list|(
name|evContext
name|ev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::readable"
decl_stmt|;
name|struct
name|ctl_cctx
modifier|*
name|ctx
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_tran
modifier|*
name|tran
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
name|char
modifier|*
name|eos
decl_stmt|;
name|UNUSED
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|evmask
operator|==
name|EV_READ
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|state
operator|==
name|connected
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|EMPTY
argument_list|(
name|ctx
operator|->
name|tran
argument_list|)
argument_list|)
expr_stmt|;
name|tran
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|tran
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allocated_p
argument_list|(
name|ctx
operator|->
name|inbuf
argument_list|)
operator|&&
name|ctl_bufget
argument_list|(
operator|&
name|ctx
operator|->
name|inbuf
argument_list|,
name|ctx
operator|->
name|logger
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: can't get an input buffer"
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|read
argument_list|(
name|ctx
operator|->
name|sock
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|text
operator|+
name|ctx
operator|->
name|inbuf
operator|.
name|used
argument_list|,
name|MAX_LINELEN
operator|-
name|ctx
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: read: %s"
argument_list|,
name|me
argument_list|,
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
literal|"Unexpected EOF"
else|:
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
name|touch_timer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inbuf
operator|.
name|used
operator|+=
name|n
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: read %d, used %d"
argument_list|,
name|me
argument_list|,
name|n
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
name|again
label|:
name|eos
operator|=
name|memchr
argument_list|(
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|,
literal|'\n'
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|eos
operator|!=
name|NULL
operator|&&
name|eos
operator|!=
name|ctx
operator|->
name|inbuf
operator|.
name|text
operator|&&
name|eos
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|eos
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|arpacode_p
argument_list|(
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|)
condition|)
block|{
comment|/* XXX Doesn't FTP do this sometimes? Is it legal? */
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: no arpa code (%s)"
argument_list|,
name|me
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arpadone_p
argument_list|(
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|)
condition|)
name|done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arpacont_p
argument_list|(
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|)
condition|)
name|done
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* XXX Doesn't FTP do this sometimes? Is it legal? */
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: no arpa flag (%s)"
argument_list|,
name|me
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|tran
operator|->
name|donefunc
call|)
argument_list|(
name|ctx
argument_list|,
name|tran
operator|->
name|uap
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|,
operator|(
name|done
condition|?
literal|0
else|:
name|CTL_MORE
operator|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inbuf
operator|.
name|used
operator|-=
operator|(
operator|(
name|eos
operator|-
name|ctx
operator|->
name|inbuf
operator|.
name|text
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|inbuf
operator|.
name|used
operator|==
literal|0U
condition|)
name|ctl_bufput
argument_list|(
operator|&
name|ctx
operator|->
name|inbuf
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|,
name|eos
operator|+
literal|1
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|UNLINK
argument_list|(
name|ctx
operator|->
name|tran
argument_list|,
name|tran
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|tran
argument_list|,
sizeof|sizeof
expr|*
name|tran
argument_list|)
expr_stmt|;
name|stop_read
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|start_write
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|allocated_p
argument_list|(
name|ctx
operator|->
name|inbuf
argument_list|)
condition|)
goto|goto
name|again
goto|;
return|return;
block|}
if|if
condition|(
name|ctx
operator|->
name|inbuf
operator|.
name|used
operator|==
operator|(
name|size_t
operator|)
name|MAX_LINELEN
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: line too long (%-10s...)"
argument_list|,
name|me
argument_list|,
name|ctx
operator|->
name|inbuf
operator|.
name|text
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Timer related stuff. */
end_comment

begin_function
specifier|static
name|void
name|start_timer
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::start_timer"
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSetIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|timer
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|timeout
argument_list|,
operator|&
name|ctx
operator|->
name|tiID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evSetIdleTimer: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_timer
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::stop_timer"
decl_stmt|;
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|evClearIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|tiID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evClearIdleTimer: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|touch_timer
parameter_list|(
name|struct
name|ctl_cctx
modifier|*
name|ctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|evTouchIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|tiID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer
parameter_list|(
name|evContext
name|ev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|itv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"isc/ctl_clnt::timer"
decl_stmt|;
name|struct
name|ctl_cctx
modifier|*
name|ctx
init|=
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|due
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|itv
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: timeout after %u seconds while %s"
argument_list|,
name|me
argument_list|,
name|ctx
operator|->
name|timeout
operator|.
name|tv_sec
argument_list|,
name|state_names
index|[
name|ctx
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*! \file */
end_comment

end_unit

