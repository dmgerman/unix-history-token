begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: getaddrinfo.c,v 1.14 2001/01/06 09:41:15 jinmei Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Issues to be discussed:  * - Thread safe-ness must be checked.  * - Return values.  There are nonstandard return values defined and used  *   in the source code.  This is because RFC2553 is silent about which error  *   code must be returned for which situation.  * - IPv4 classful (shortened) form.  RFC2553 is silent about it.  XNET 5.2  *   says to use inet_aton() to convert IPv4 numeric to binary (allows  *   classful form as a result).  *   current code - disallow classful form for IPv4 (due to use of inet_pton).  * - freeaddrinfo(NULL).  RFC2553 is silent about it.  XNET 5.2 says it is  *   invalid.  *   current code - SEGV on freeaddrinfo(NULL)  * Note:  * - We use getipnodebyname() just for thread-safeness.  There's no intent  *   to let it do PF_UNSPEC (actually we never pass PF_UNSPEC to  *   getipnodebyname().  * - The code filters out AFs that are not supported by the kernel,  *   when globbing NULL hostname (to loopback, or wildcard).  Is it the right  *   thing to do?  What is the relationship with post-RFC2553 AI_ADDRCONFIG  *   in ai_flags?  * - (post-2553) semantics of AI_ADDRCONFIG itself is too vague.  *   (1) what should we do against numeric hostname (2) what should we do  *   against NULL hostname (3) what is AI_ADDRCONFIG itself.  AF not ready?  *   non-loopback address configured?  global address configured?  * - To avoid search order issue, we have a big amount of code duplicate  *   from gethnamaddr.c and some other places.  The issues that there's no  *   lower layer function to lookup "IPv4 or IPv6" record.  Calling  *   gethostbyname2 from getaddrinfo will end up in wrong search order, as  *   follows:  *	- The code makes use of following calls when asked to resolver with  *	  ai_family  = PF_UNSPEC:  *		getipnodebyname(host, AF_INET6);  *		getipnodebyname(host, AF_INET);  *	  This will result in the following queries if the node is configure to  *	  prefer /etc/hosts than DNS:  *		lookup /etc/hosts for IPv6 address  *		lookup DNS for IPv6 address  *		lookup /etc/hosts for IPv4 address  *		lookup DNS for IPv4 address  *	  which may not meet people's requirement.  *	  The right thing to happen is to have underlying layer which does  *	  PF_UNSPEC lookup (lookup both) and return chain of addrinfos.  *	  This would result in a bit of code duplicate with _dns_ghbyname() and  *	  friends.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<irs.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"irs_data.h"
end_include

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_loopback
index|[]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_loopback
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|afd
block|{
name|int
name|a_af
decl_stmt|;
name|int
name|a_addrlen
decl_stmt|;
name|int
name|a_socklen
decl_stmt|;
name|int
name|a_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_addrany
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_loopback
decl_stmt|;
name|int
name|a_scoped
decl_stmt|;
block|}
name|afdl
index|[]
init|=
block|{
block|{
name|PF_INET6
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
block|,
name|in6_addrany
block|,
name|in6_loopback
block|,
literal|1
block|}
block|,
block|{
name|PF_INET
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
block|,
name|in_addrany
block|,
name|in_loopback
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|explore
block|{
name|int
name|e_af
decl_stmt|;
name|int
name|e_socktype
decl_stmt|;
name|int
name|e_protocol
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_protostr
decl_stmt|;
name|int
name|e_wild
decl_stmt|;
define|#
directive|define
name|WILD_AF
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x01)
define|#
directive|define
name|WILD_SOCKTYPE
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x02)
define|#
directive|define
name|WILD_PROTOCOL
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x04)
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|explore
name|explore
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ PF_LOCAL, 0, ANY, ANY, NULL, 0x01 },
endif|#
directive|endif
block|{
name|PF_INET6
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PTON_MAX
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|str_isnumber
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_fqdn
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_copy
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_null
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_numeric
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_numeric_scope
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_canonname
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
expr|struct
name|afd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|copy_ai
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_portmatch
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_port
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addrconfig
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_str2scopeid
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|,
name|u_int32_t
operator|*
name|scopeidp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|net_data
modifier|*
name|init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|addrinfo
modifier|*
name|hostent2addrinfo
name|__P
argument_list|(
operator|(
expr|struct
name|hostent
operator|*
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|addrinfo
modifier|*
name|addr2addrinfo
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static const char *ai_errlist[] = { 	"Success", 	"Address family for hostname not supported",
comment|/* EAI_ADDRFAMILY */
end_comment

begin_comment
unit|"Temporary failure in name resolution",
comment|/* EAI_AGAIN      */
end_comment

begin_comment
unit|"Invalid value for ai_flags",
comment|/* EAI_BADFLAGS   */
end_comment

begin_comment
unit|"Non-recoverable failure in name resolution",
comment|/* EAI_FAIL       */
end_comment

begin_comment
unit|"ai_family not supported",
comment|/* EAI_FAMILY     */
end_comment

begin_comment
unit|"Memory allocation failure",
comment|/* EAI_MEMORY     */
end_comment

begin_comment
unit|"No address associated with hostname",
comment|/* EAI_NODATA     */
end_comment

begin_comment
unit|"hostname nor servname provided, or not known",
comment|/* EAI_NONAME     */
end_comment

begin_comment
unit|"servname not supported for ai_socktype",
comment|/* EAI_SERVICE    */
end_comment

begin_comment
unit|"ai_socktype not supported",
comment|/* EAI_SOCKTYPE   */
end_comment

begin_comment
unit|"System error returned in errno",
comment|/* EAI_SYSTEM     */
end_comment

begin_comment
unit|"Invalid value for hints",
comment|/* EAI_BADHINTS	  */
end_comment

begin_comment
unit|"Resolved protocol is unknown",
comment|/* EAI_PROTOCOL   */
end_comment

begin_comment
unit|"Unknown error",
comment|/* EAI_MAX        */
end_comment

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX macros that make external reference is BAD. */
end_comment

begin_define
define|#
directive|define
name|GET_AI
parameter_list|(
name|ai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error, and label free */
value|\ 	(ai) = get_ai(pai, (afd), (addr)); \ 	if ((ai) == NULL) { \ 		error = EAI_MEMORY; \ 		goto free; \ 	} \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_PORT
parameter_list|(
name|ai
parameter_list|,
name|serv
parameter_list|)
define|\
value|do { \
comment|/* external reference: error and label free */
value|\ 	error = get_port((ai), (serv), 0); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_CANONNAME
parameter_list|(
name|ai
parameter_list|,
name|str
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error and label free */
value|\ 	error = get_canonname(pai, (ai), (str)); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SOLARIS2
end_ifndef

begin_define
define|#
directive|define
name|SETERROR
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \
comment|/* external reference: error, and label bad */
value|\ 	error = (err); \ 	goto bad; \
comment|/*NOTREACHED*/
value|\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SETERROR
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \
comment|/* external reference: error, and label bad */
value|\ 	error = (err); \ 	if (error == error) \ 		goto bad; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MATCH_FAMILY
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
end_define

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == ANY || (y) == ANY)))
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* bind8 has its own version */
end_comment

begin_endif
unit|char * gai_strerror(ecode) 	int ecode; { 	if (ecode< 0 || ecode> EAI_MAX) 		ecode = EAI_MAX; 	return ai_errlist[ecode]; }
endif|#
directive|endif
end_endif

begin_function
name|void
name|freeaddrinfo
parameter_list|(
name|ai
parameter_list|)
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
comment|/* no need to free(ai->ai_addr) */
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|ai
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_isnumber
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NO
return|;
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
name|ep
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
return|return
name|YES
return|;
else|else
return|return
name|NO
return|;
block|}
end_function

begin_function
name|int
name|getaddrinfo
parameter_list|(
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|hints
parameter_list|,
name|res
parameter_list|)
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|,
decl|*
name|servname
decl_stmt|;
end_function

begin_decl_stmt
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|,
name|ai0
decl_stmt|,
modifier|*
name|afai
init|=
name|NULL
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|explore
modifier|*
name|ex
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|pai
operator|=
operator|&
name|ai
expr_stmt|;
name|pai
operator|->
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|pai
operator|->
name|ai_socktype
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_protocol
operator|=
name|ANY
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|_SOCKLEN_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sparcv9
argument_list|)
comment|/* 	 * clear _ai_pad to preserve binary 	 * compatibility with previously compiled 64-bit 	 * applications in a pre-SUSv3 environment by 	 * guaranteeing the upper 32-bits are empty. 	 */
name|pai
operator|->
name|_ai_pad
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pai
operator|->
name|ai_addrlen
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_addr
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
name|EAI_NONAME
return|;
if|if
condition|(
name|hints
condition|)
block|{
comment|/* error check for hints */
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
name|SETERROR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
comment|/* xxx */
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
name|AI_MASK
condition|)
name|SETERROR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hints
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_UNSPEC
case|:
case|case
name|PF_INET
case|:
case|case
name|PF_INET6
case|:
break|break;
default|default:
name|SETERROR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pai
argument_list|,
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pai
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|_SOCKLEN_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sparcv9
argument_list|)
comment|/* 		 * We need to clear _ai_pad to preserve binary 		 * compatibility.  See prior comment. 		 */
name|pai
operator|->
name|_ai_pad
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * if both socktype/protocol are specified, check if they 		 * are meaningful combination. 		 */
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|!=
name|ANY
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ANY
condition|)
block|{
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|ex
operator|->
name|e_af
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_socktype
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_protocol
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ex
operator|->
name|e_socktype
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ex
operator|->
name|e_protocol
condition|)
block|{
name|SETERROR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * post-2553: AI_ALL and AI_V4MAPPED are effective only against 	 * AF_INET6 query.  They needs to be ignored if specified in other 	 * occassions. 	 */
switch|switch
condition|(
name|pai
operator|->
name|ai_flags
operator|&
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
condition|)
block|{
case|case
name|AI_V4MAPPED
case|:
case|case
name|AI_ALL
operator||
name|AI_V4MAPPED
case|:
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
name|pai
operator|->
name|ai_flags
operator|&=
operator|~
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
expr_stmt|;
break|break;
case|case
name|AI_ALL
case|:
if|#
directive|if
literal|1
comment|/* illegal */
name|SETERROR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_flags
operator|&=
operator|~
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* 	 * check for special cases.  (1) numeric servname is disallowed if 	 * socktype/protocol are left unspecified. (2) servname is disallowed 	 * for raw and other inet{,6} sockets. 	 */
if|if
condition|(
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|PF_INET6
operator|||
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET6
argument_list|,
literal|1
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* backup *pai */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
ifdef|#
directive|ifdef
name|PF_INET6
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
endif|#
directive|endif
block|}
name|error
operator|=
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|SETERROR
argument_list|(
name|error
argument_list|)
expr_stmt|;
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
block|}
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* NULL hostname, or numeric hostname */
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
comment|/* 		 * if the servname does not match socktype/protocol, ignore it. 		 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * filter out AFs that are not supported by the kernel 			 * XXX errno? 			 */
if|if
condition|(
operator|!
name|addrconfig
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
condition|)
continue|continue;
name|error
operator|=
name|explore_null
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|explore_numeric_scope
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * If numreic representation of AF1 can be interpreted as FQDN 	 * representation of AF2, we need to think again about the code below. 	 */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
goto|goto
name|good
goto|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_NUMERICHOST
condition|)
name|SETERROR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|SETERROR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
comment|/* 	 * hostname as alphabetical name. 	 * We'll make sure that 	 * - if returning addrinfo list is empty, return non-zero error 	 *   value (already known one or EAI_NONAME). 	 * - otherwise,  	 *   + if we haven't had any errors, return 0 (i.e. success). 	 *   + if we've had an error, free the list and return the error. 	 * without any assumption on the behavior of explore_fqdn(). 	 */
comment|/* first, try to query DNS for all possible address families. */
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
name|error
operator|=
name|explore_fqdn
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|afai
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|afai
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|afai
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|afai
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
comment|/* we've had no errors. */
goto|goto
name|free
goto|;
block|}
comment|/* 	 * we would like to prefer AF_INET6 than AF_INET, so we'll make an 	 * outer loop by AFs. 	 */
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
comment|/* 		 * If AI_ADDRCONFIG is specified, check if we are 		 * expected to return the address family or not. 		 */
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_ADDRCONFIG
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|addrconfig
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
comment|/* 		 * if the servname does not match socktype/protocol, ignore it. 		 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|explore_copy
argument_list|(
name|pai
argument_list|,
name|afai
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|afai
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|afai
argument_list|)
expr_stmt|;
comment|/* afai must not be NULL at this point. */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
block|{
name|good
label|:
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * All the process succeeded, but we've had an empty list.  		 * This can happen if the given hints do not match our 		 * candidates. 		 */
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
block|}
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FQDN hostname, DNS lookup  */
end_comment

begin_function
specifier|static
name|int
name|explore_fqdn
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|result
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|net_data
modifier|*
name|net_data
init|=
name|init
argument_list|()
decl_stmt|;
name|struct
name|irs_ho
modifier|*
name|ho
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|tmp
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|INSIST
argument_list|(
name|res
operator|!=
name|NULL
operator|&&
operator|*
name|res
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|net_data
operator|||
operator|!
operator|(
name|ho
operator|=
name|net_data
operator|->
name|ho
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
comment|/* XXX (notyet) */
block|if (net_data->ho_stayopen&& net_data->ho_last&& 	    net_data->ho_last->h_addrtype == af) { 		if (ns_samename(name, net_data->ho_last->h_name) == 1) 			return (net_data->ho_last); 		for (hap = net_data->ho_last->h_aliases; hap&& *hap; hap++) 			if (ns_samename(name, *hap) == 1) 				return (net_data->ho_last); 	}
endif|#
directive|endif
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|&&
operator|(
name|cp
operator|=
name|res_hostalias
argument_list|(
name|net_data
operator|->
name|res
argument_list|,
name|hostname
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|)
condition|)
name|hostname
operator|=
name|cp
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|ho
operator|->
name|addrinfo
call|)
argument_list|(
name|ho
argument_list|,
name|hostname
argument_list|,
name|pai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|net_data
operator|->
name|ho_stayopen
condition|)
block|{
call|(
modifier|*
name|ho
operator|->
name|minimize
call|)
argument_list|(
name|ho
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|int
name|e
init|=
name|h_errno
decl_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|NETDB_INTERNAL
case|:
name|error
operator|=
name|EAI_SYSTEM
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|error
operator|=
name|EAI_AGAIN
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
break|break;
case|case
name|HOST_NOT_FOUND
case|:
case|case
name|NO_DATA
case|:
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
break|break;
default|default:
case|case
name|NETDB_SUCCESS
case|:
comment|/* should be impossible... */
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
break|break;
block|}
goto|goto
name|free
goto|;
block|}
for|for
control|(
name|cur
operator|=
name|result
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
name|GET_PORT
argument_list|(
name|cur
argument_list|,
name|servname
argument_list|)
expr_stmt|;
comment|/* XXX: redundant lookups... */
comment|/* canonname should already be filled. */
block|}
operator|*
name|res
operator|=
name|result
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|free
label|:
if|if
condition|(
name|result
condition|)
name|freeaddrinfo
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|explore_copy
parameter_list|(
name|pai
parameter_list|,
name|src0
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
comment|/* seed */
specifier|const
name|struct
name|addrinfo
modifier|*
name|src0
decl_stmt|;
comment|/* source */
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|src
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
for|for
control|(
name|src
operator|=
name|src0
init|;
name|src
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|src
operator|->
name|ai_family
operator|!=
name|pai
operator|->
name|ai_family
condition|)
continue|continue;
name|cur
operator|->
name|ai_next
operator|=
name|copy_ai
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur
operator|->
name|ai_next
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|cur
operator|->
name|ai_next
operator|->
name|ai_socktype
operator|=
name|pai
operator|->
name|ai_socktype
expr_stmt|;
name|cur
operator|->
name|ai_next
operator|->
name|ai_protocol
operator|=
name|pai
operator|->
name|ai_protocol
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * hostname == NULL.  * passive socket -> anyaddr (0.0.0.0 or ::)  * non-passive socket -> localhost (127.0.0.1 or ::1)  */
end_comment

begin_function
specifier|static
name|int
name|explore_null
parameter_list|(
name|pai
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_PASSIVE
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_addrany
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "anyaddr"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_loopback
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "localhost"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pton
index|[
name|PTON_MAX
index|]
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|afd
operator|->
name|a_af
condition|)
block|{
if|#
directive|if
literal|0
comment|/*X/Open spec*/
block|case AF_INET: 		if (inet_aton(hostname, (struct in_addr *)pton) == 1) { 			if (pai->ai_family == afd->a_af || 			    pai->ai_family == PF_UNSPEC
comment|/*?*/
block|) { 				GET_AI(cur->ai_next, afd, pton); 				GET_PORT(cur->ai_next, servname); 				while (cur->ai_next) 					cur = cur->ai_next; 			} else 				SETERROR(EAI_FAMILY);
comment|/*xxx*/
block|} 		break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|inet_pton
argument_list|(
name|afd
operator|->
name|a_af
argument_list|,
name|hostname
argument_list|,
name|pton
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|afd
operator|->
name|a_af
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
comment|/*?*/
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|pton
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
else|else
name|SETERROR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
comment|/*xxx*/
block|}
break|break;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname with scope  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SCOPE_DELIMITER
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
else|#
directive|else
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|hostname2
init|=
name|NULL
decl_stmt|,
modifier|*
name|scope
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|afd
operator|->
name|a_scoped
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
name|SCOPE_DELIMITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
comment|/* 	 * Handle special case of<scoped_address><delimiter><scope id> 	 */
name|hostname2
operator|=
name|strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname2
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
comment|/* terminate at the delimiter */
name|hostname2
index|[
name|cp
operator|-
name|hostname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|hostname2
expr_stmt|;
name|scope
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|addr
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|scopeid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|res
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|cur
operator|->
name|ai_addr
expr_stmt|;
if|if
condition|(
operator|!
name|ip6_str2scopeid
argument_list|(
name|scope
argument_list|,
name|sin6
argument_list|,
operator|&
name|scopeid
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
comment|/* XXX: is return OK? */
block|}
ifdef|#
directive|ifdef
name|HAVE_SIN6_SCOPE_ID
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|get_canonname
parameter_list|(
name|pai
parameter_list|,
name|ai
parameter_list|,
name|str
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
name|strcpy
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
name|pai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
operator|(
name|afd
operator|->
name|a_socklen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_socklen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
endif|#
directive|endif
name|ai
operator|->
name|ai_addrlen
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|ai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_comment
comment|/* XXX need to malloc() the same way we do from other functions! */
end_comment

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|copy_ai
parameter_list|(
name|pai
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|+
name|pai
operator|->
name|ai_addrlen
expr_stmt|;
if|if
condition|(
operator|(
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|ai
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|pai
operator|->
name|ai_addr
argument_list|,
name|pai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_canonname
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|pai
operator|->
name|ai_canonname
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ai
operator|->
name|ai_canonname
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|,
name|pai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
comment|/* (checked) */
block|}
else|else
block|{
comment|/* just to make sure */
name|ai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
block|}
name|ai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_portmatch
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|)
block|{
comment|/* get_port does not touch first argument. when matchonly == 1. */
comment|/* LINTED const cast */
return|return
name|get_port
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|)
name|ai
argument_list|,
name|servname
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_port
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|int
name|matchonly
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|allownumeric
decl_stmt|;
if|if
condition|(
name|servname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_RAW
case|:
return|return
name|EAI_SERVICE
return|;
case|case
name|SOCK_DGRAM
case|:
case|case
name|SOCK_STREAM
case|:
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ANY
case|:
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|allownumeric
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
name|EAI_SOCKTYPE
return|;
block|}
if|if
condition|(
name|str_isnumber
argument_list|(
name|servname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allownumeric
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|atoi
argument_list|(
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matchonly
condition|)
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|af
parameter_list|)
name|int
name|af
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|PF_UNSPEC
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
if|if
condition|(
name|afd
operator|->
name|a_af
operator|==
name|af
condition|)
return|return
name|afd
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * post-2553: AI_ADDRCONFIG check.  if we use getipnodeby* as backend, backend  * will take care of it.  * the semantics of AI_ADDRCONFIG is not defined well.  we are not sure  * if the code is right or not.  */
end_comment

begin_function
specifier|static
name|int
name|addrconfig
parameter_list|(
name|af
parameter_list|)
name|int
name|af
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
comment|/* XXX errno */
name|s
operator|=
name|socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EMFILE
condition|)
return|return
literal|0
return|;
block|}
else|else
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* convert a string to a scope identifier. XXX: IPv6 specific */
end_comment

begin_function
specifier|static
name|int
name|ip6_str2scopeid
parameter_list|(
name|char
modifier|*
name|scope
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|sin6
parameter_list|,
name|u_int32_t
modifier|*
name|scopeidp
parameter_list|)
block|{
name|u_int32_t
name|scopeid
decl_stmt|;
name|u_long
name|lscopeid
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|a6
init|=
operator|&
name|sin6
operator|->
name|sin6_addr
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* empty scopeid portion is invalid */
if|if
condition|(
operator|*
name|scope
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|USE_IFNAMELINKID
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
name|a6
argument_list|)
condition|)
block|{
comment|/* 		 * Using interface names as link indices can be allowed 		 * only when we can assume a one-to-one mappings between 		 * links and interfaces.  See comments in getnameinfo.c. 		 */
name|scopeid
operator|=
name|if_nametoindex
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|scopeid
operator|==
literal|0
condition|)
goto|goto
name|trynumeric
goto|;
operator|*
name|scopeidp
operator|=
name|scopeid
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* still unclear about literal, allow numeric only - placeholder */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
if|if
condition|(
name|IN6_IS_ADDR_MC_ORGLOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
else|else
goto|goto
name|trynumeric
goto|;
comment|/* global */
comment|/* try to convert to a numeric id as a last resort */
name|trynumeric
label|:
name|errno
operator|=
literal|0
expr_stmt|;
name|lscopeid
operator|=
name|strtoul
argument_list|(
name|scope
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|scopeid
operator|=
name|lscopeid
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
name|ep
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
operator|&&
name|scopeid
operator|==
name|lscopeid
condition|)
block|{
operator|*
name|scopeidp
operator|=
name|scopeid
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|addrinfo
modifier|*
name|hostent2addrinfo
parameter_list|(
name|hp
parameter_list|,
name|pai
parameter_list|)
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|af
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|aplist
init|=
name|NULL
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|af
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|AF_UNSPEC
operator|&&
name|af
operator|!=
name|pai
operator|->
name|ai_family
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|aplist
operator|=
name|hp
operator|->
name|h_addr_list
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ap
operator|=
name|aplist
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
comment|/* the trick seems too much */
block|af = hp->h_addr_list; 		if (af == AF_INET6&& 		    IN6_IS_ADDR_V4MAPPED((struct in6_addr *)ap)) { 			af = AF_INET; 			ap = ap + sizeof(struct in6_addr) 				- sizeof(struct in_addr); 		} 		afd = find_afd(af); 		if (afd == NULL) 			continue;
endif|#
directive|endif
comment|/* 0 */
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* GET_PORT(cur->ai_next, servname); */
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * RFC2553 says that ai_canonname will be set only for 			 * the first element.  we do it for all the elements, 			 * just for convenience. 			 */
name|GET_CANONNAME
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cur
operator|->
name|ai_next
condition|)
comment|/* no need to loop, actually. */
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
continue|continue;
name|free
label|:
if|if
condition|(
name|cur
operator|->
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|cur
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
comment|/* continue, without tht pointer CUR advanced. */
block|}
return|return
operator|(
name|sentinel
operator|.
name|ai_next
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|addrinfo
modifier|*
name|addr2addrinfo
parameter_list|(
name|pai
parameter_list|,
name|cp
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|get_ai
argument_list|(
name|pai
argument_list|,
name|afd
argument_list|,
name|cp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|net_data
modifier|*
name|init
parameter_list|()
block|{
name|struct
name|net_data
modifier|*
name|net_data
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|net_data
operator|=
name|net_data_init
argument_list|(
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|net_data
operator|->
name|ho
condition|)
block|{
name|net_data
operator|->
name|ho
operator|=
call|(
modifier|*
name|net_data
operator|->
name|irs
operator|->
name|ho_map
call|)
argument_list|(
name|net_data
operator|->
name|irs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|net_data
operator|->
name|ho
operator|||
operator|!
name|net_data
operator|->
name|res
condition|)
block|{
name|error
label|:
name|errno
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|net_data
operator|&&
name|net_data
operator|->
name|res
condition|)
name|RES_SET_H_ERRNO
argument_list|(
name|net_data
operator|->
name|res
argument_list|,
name|NETDB_INTERNAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
call|(
modifier|*
name|net_data
operator|->
name|ho
operator|->
name|res_set
call|)
argument_list|(
name|net_data
operator|->
name|ho
argument_list|,
name|net_data
operator|->
name|res
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|net_data
operator|)
return|;
block|}
end_function

end_unit

