begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2001-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: check.c,v 1.37.6.39 2007/12/14 01:28:26 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/parseint.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/sockaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/symtab.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/secalg.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/cfg.h>
end_include

begin_include
include|#
directive|include
file|<bind9/check.h>
end_include

begin_function
specifier|static
name|void
name|freekey
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|,
name|isc_symvalue_t
name|value
parameter_list|,
name|void
modifier|*
name|userarg
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|userarg
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_orderent
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|ent
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_textregion_t
name|r
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|rdclass
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid class '%s'"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdatatype_fromtext
argument_list|(
operator|&
name|rdtype
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid type '%s'"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"order"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
operator|||
name|strcasecmp
argument_list|(
literal|"order"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|ent
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: keyword 'order' missing"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"ordering"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|ent
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: missing ordering"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"fixed"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"rrset-order: order 'fixed' not fully implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
comment|/* strcasecmp(cfg_obj_asstring(obj), "fixed") != 0&& */
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"random"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"cyclic"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid order '%s'"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_order
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"rrset-order"
argument_list|,
operator|&
name|obj
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|tresult
operator|=
name|check_orderent
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_dual_stack
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|alternates
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|value
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"dual-stack-servers"
argument_list|,
operator|&
name|alternates
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternates
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|alternates
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isuint32
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|val
init|=
name|cfg_obj_asuint32
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
name|ISC_UINT16_MAX
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"port '%u' out of range"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|alternates
argument_list|,
literal|"addresses"
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|value
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_issockaddr
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|value
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|buffer
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|value
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isuint32
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|val
init|=
name|cfg_obj_asuint32
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
name|ISC_UINT16_MAX
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"port '%u' out of range"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_forward
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|forward
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|forwarders
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"forward"
argument_list|,
operator|&
name|forward
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"forwarders"
argument_list|,
operator|&
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
operator|!=
name|NULL
operator|&&
name|forwarders
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|forward
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"no matching 'forwarders' statement"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|disabled_algorithms
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|disabled
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|disabled
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|disabled
argument_list|,
literal|"algorithms"
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|dns_secalg_t
name|alg
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_secalg_fromtext
argument_list|(
operator|&
name|alg
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_uint8_t
name|ui
decl_stmt|;
name|result
operator|=
name|isc_parse_uint8
argument_list|(
operator|&
name|ui
argument_list|,
name|r
operator|.
name|base
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"invalid algorithm"
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|nameexist
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
name|key
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|obj
expr_stmt|;
name|result
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_EXISTS
condition|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|symvalue
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|file
operator|=
name|cfg_obj_file
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|line
operator|=
name|cfg_obj_line
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|fmt
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|mustbesecure
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|secure
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|secure
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|nameexist
argument_list|(
name|secure
argument_list|,
name|namebuf
argument_list|,
literal|1
argument_list|,
name|symtab
argument_list|,
literal|"dnssec-must-be-secure '%s': already "
literal|"exists previous definition: %s:%u"
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|scale
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
block|}
name|intervaltable
typedef|;
end_typedef

begin_function
specifier|static
name|isc_result_t
name|check_options
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
specifier|static
name|intervaltable
name|intervals
index|[]
init|=
block|{
block|{
literal|"cleaning-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"heartbeat-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"interface-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-idle-in"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-idle-out"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-time-in"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-time-out"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"sig-validity-interval"
block|,
literal|86400
block|,
literal|10
operator|*
literal|366
block|}
block|,
comment|/* 10 years */
block|{
literal|"statistics-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|}
decl_stmt|;
comment|/* 	 * Check that fields specified in units of time other than seconds 	 * have reasonable values. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|intervals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|intervals
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|isc_uint32_t
name|val
decl_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
continue|continue;
name|val
operator|=
name|cfg_obj_asuint32
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|intervals
index|[
name|i
index|]
operator|.
name|max
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s '%u' is out of range (0..%u)"
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|max
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
operator|(
name|ISC_UINT32_MAX
operator|/
name|intervals
index|[
name|i
index|]
operator|.
name|scale
operator|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s '%d' is out of range"
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"preferred-glue"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"a"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"aaaa"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"preferred-glue unexpected value '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"root-delegation-only"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|cfg_obj_isvoid
argument_list|(
name|obj
argument_list|)
condition|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|exclude
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|exclude
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|exclude
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Set supported DNSSEC algorithms. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"disable-algorithms"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|disabled_algorithms
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
comment|/* 	 * Check the DLV zone name. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"dnssec-lookaside"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|freekey
argument_list|,
name|mctx
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dlv
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|dlv
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|obj
argument_list|,
literal|"domain"
argument_list|)
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|dlv
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|dlv
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|nameexist
argument_list|(
name|obj
argument_list|,
name|dlv
argument_list|,
literal|1
argument_list|,
name|symtab
argument_list|,
literal|"dnssec-lookaside '%s': "
literal|"already exists previous "
literal|"definition: %s:%u"
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
comment|/* 			 * XXXMPA to be removed when multiple lookaside 			 * namespaces are supported. 			 */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|dns_rootname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dnssec-lookaside '%s': "
literal|"non-root not yet supported"
argument_list|,
name|dlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|dlv
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|obj
argument_list|,
literal|"trust-anchor"
argument_list|)
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|dlv
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|dlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check dnssec-must-be-secure. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"dnssec-must-be-secure"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|freekey
argument_list|,
name|mctx
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|mustbesecure
argument_list|(
name|obj
argument_list|,
name|symtab
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|get_masters_def
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|cctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|masters
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
name|result
operator|=
name|cfg_map_get
argument_list|(
name|cctx
argument_list|,
literal|"masters"
argument_list|,
operator|&
name|masters
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|elt
operator|=
name|cfg_list_first
argument_list|(
name|masters
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|listname
decl_stmt|;
name|list
operator|=
name|cfg_listelt_value
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|listname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|list
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|listname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ret
operator|=
name|list
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|validate_masters
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_uint32_t
modifier|*
name|countp
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_uint32_t
name|count
init|=
literal|0
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|stackcount
init|=
literal|0
decl_stmt|,
name|pushed
init|=
literal|0
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|list
decl_stmt|;
name|REQUIRE
argument_list|(
name|countp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|newlist
label|:
name|list
operator|=
name|cfg_tuple_get
argument_list|(
name|obj
argument_list|,
literal|"addresses"
argument_list|)
expr_stmt|;
name|element
operator|=
name|cfg_list_first
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|resume
label|:
for|for
control|(
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|listname
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|addr
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|key
decl_stmt|;
name|addr
operator|=
name|cfg_tuple_get
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
literal|"masterselement"
argument_list|)
expr_stmt|;
name|key
operator|=
name|cfg_tuple_get
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
literal|"key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_issockaddr
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|cfg_obj_isvoid
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unexpected token '%s'"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|listname
operator|=
name|cfg_obj_asstring
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|addr
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|listname
argument_list|,
literal|1
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
continue|continue;
name|tresult
operator|=
name|get_masters_def
argument_list|(
name|config
argument_list|,
name|listname
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|addr
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unable to find masters list '%s'"
argument_list|,
name|listname
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Grow stack? */
if|if
condition|(
name|stackcount
operator|==
name|pushed
condition|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|isc_uint32_t
name|newlen
init|=
name|stackcount
operator|+
literal|16
decl_stmt|;
name|size_t
name|newsize
decl_stmt|,
name|oldsize
decl_stmt|;
name|newsize
operator|=
name|newlen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|stackcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
expr_stmt|;
name|new
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|stackcount
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|new
argument_list|,
name|stack
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stack
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|new
expr_stmt|;
name|stackcount
operator|=
name|newlen
expr_stmt|;
block|}
name|stack
index|[
name|pushed
operator|++
index|]
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
goto|goto
name|newlist
goto|;
block|}
if|if
condition|(
name|pushed
operator|!=
literal|0
condition|)
block|{
name|element
operator|=
name|stack
index|[
operator|--
name|pushed
index|]
expr_stmt|;
goto|goto
name|resume
goto|;
block|}
name|cleanup
label|:
if|if
condition|(
name|stack
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stack
argument_list|,
name|stackcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MASTERZONE
value|1
end_define

begin_define
define|#
directive|define
name|SLAVEZONE
value|2
end_define

begin_define
define|#
directive|define
name|STUBZONE
value|4
end_define

begin_define
define|#
directive|define
name|HINTZONE
value|8
end_define

begin_define
define|#
directive|define
name|FORWARDZONE
value|16
end_define

begin_define
define|#
directive|define
name|DELEGATIONZONE
value|32
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|allowed
decl_stmt|;
block|}
name|optionstable
typedef|;
end_typedef

begin_function
specifier|static
name|isc_result_t
name|check_zoneconf
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|zconfig
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|dns_rdataclass_t
name|defclass
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|typestr
decl_stmt|;
name|unsigned
name|int
name|ztype
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|zoptions
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rdataclass_t
name|zclass
decl_stmt|;
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
specifier|static
name|optionstable
name|options
index|[]
init|=
block|{
block|{
literal|"allow-query"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"allow-notify"
block|,
name|SLAVEZONE
block|}
block|,
block|{
literal|"allow-transfer"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"also-notify"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"dialup"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"delegation-only"
block|,
name|HINTZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"forward"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|FORWARDZONE
block|}
block|,
block|{
literal|"forwarders"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|FORWARDZONE
block|}
block|,
block|{
literal|"maintain-ixfr-base"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"max-ixfr-log-size"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify-source"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify-source-v6"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"transfer-source"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"transfer-source-v6"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-transfer-time-in"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-transfer-time-out"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"max-transfer-idle-in"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-transfer-idle-out"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"max-retry-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"min-retry-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-refresh-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"min-refresh-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"sig-validity-interval"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"zone-statistics"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"allow-update"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"allow-update-forwarding"
block|,
name|SLAVEZONE
block|}
block|,
block|{
literal|"file"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|HINTZONE
block|}
block|,
block|{
literal|"ixfr-base"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"ixfr-tmp-file"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"masters"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"pubkey"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"update-policy"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"database"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"key-directory"
block|,
name|MASTERZONE
block|}
block|, 	}
decl_stmt|;
specifier|static
name|optionstable
name|dialups
index|[]
init|=
block|{
block|{
literal|"notify"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify-passive"
block|,
name|SLAVEZONE
block|}
block|,
block|{
literal|"refresh"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"passive"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|, 	}
decl_stmt|;
name|zname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|zoptions
operator|=
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"options"
argument_list|)
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"type"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zconfig
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': type not present"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|typestr
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"master"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|MASTERZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"slave"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|SLAVEZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"stub"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|STUBZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"forward"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|FORWARDZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"hint"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|HINTZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"delegation-only"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|DELEGATIONZONE
expr_stmt|;
else|else
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': invalid type %s"
argument_list|,
name|zname
argument_list|,
name|typestr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|zclass
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': invalid class %s"
argument_list|,
name|zname
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|zclass
operator|!=
name|defclass
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': class '%s' does not "
literal|"match view/default class"
argument_list|,
name|zname
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
block|}
comment|/* 	 * Look for an already existing zone. 	 * We need to make this cannonical as isc_symtab_define() 	 * deals with strings. 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|zname
argument_list|,
name|strlen
argument_list|(
name|zname
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|zname
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zconfig
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': is not a valid name"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|nameexist
argument_list|(
name|zconfig
argument_list|,
name|namebuf
argument_list|,
name|ztype
operator|==
name|HINTZONE
condition|?
literal|1
else|:
literal|2
argument_list|,
name|symtab
argument_list|,
literal|"zone '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
comment|/* 	 * Look for inappropriate options for the given zone type. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|options
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|options
index|[
name|i
index|]
operator|.
name|allowed
operator|&
name|ztype
operator|)
operator|==
literal|0
operator|&&
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|obj
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"allow-update"
argument_list|)
operator|!=
literal|0
operator|||
name|ztype
operator|!=
name|SLAVEZONE
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"option '%s' is not allowed "
literal|"in '%s' zone '%s'"
argument_list|,
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|typestr
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"option '%s' is not allowed "
literal|"in '%s' zone '%s'"
argument_list|,
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|typestr
argument_list|,
name|zname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Slave& stub zones must have a "masters" field. 	 */
if|if
condition|(
name|ztype
operator|==
name|SLAVEZONE
operator|||
name|ztype
operator|==
name|STUBZONE
condition|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"masters"
argument_list|,
operator|&
name|obj
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': missing 'masters' entry"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|isc_uint32_t
name|count
decl_stmt|;
name|tresult
operator|=
name|validate_masters
argument_list|(
name|obj
argument_list|,
name|config
argument_list|,
operator|&
name|count
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|count
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': empty 'masters' entry"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Master zones can't have both "allow-update" and "update-policy". 	 */
if|if
condition|(
name|ztype
operator|==
name|MASTERZONE
condition|)
block|{
name|isc_result_t
name|res1
decl_stmt|,
name|res2
decl_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|res1
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"allow-update"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|res2
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"update-policy"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|==
name|ISC_R_SUCCESS
operator|&&
name|res2
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': 'allow-update' is ignored "
literal|"when 'update-policy' is present"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
comment|/* 	 * Check the excessively complicated "dialup" option. 	 */
if|if
condition|(
name|ztype
operator|==
name|MASTERZONE
operator|||
name|ztype
operator|==
name|SLAVEZONE
operator|||
name|ztype
operator|==
name|STUBZONE
condition|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|dialup
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"dialup"
argument_list|,
operator|&
name|dialup
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialup
operator|!=
name|NULL
operator|&&
name|cfg_obj_isstring
argument_list|(
name|dialup
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|cfg_obj_asstring
argument_list|(
name|dialup
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dialups
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dialups
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|dialups
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|str
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dialups
index|[
name|i
index|]
operator|.
name|allowed
operator|&
name|ztype
operator|)
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dialup type '%s' is not "
literal|"allowed in '%s' "
literal|"zone '%s'"
argument_list|,
name|str
argument_list|,
name|typestr
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|dialups
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dialups
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"invalid dialup type '%s' in zone "
literal|"'%s'"
argument_list|,
name|str
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check that forwarding is reasonable. 	 */
if|if
condition|(
name|check_forward
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
comment|/* 	 * Check various options. 	 */
name|tresult
operator|=
name|check_options
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
comment|/* 	 * If the zone type is rbt/rbt64 then master/hint zones 	 * require file clauses. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"database"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_NOTFOUND
operator|||
operator|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|(
name|strcmp
argument_list|(
literal|"rbt"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"rbt64"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"file"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
operator|(
name|ztype
operator|==
name|MASTERZONE
operator|||
name|ztype
operator|==
name|HINTZONE
operator|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zconfig
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': missing 'file' entry"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|bind9_check_key
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|key
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|algobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|secretobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyname
init|=
name|cfg_obj_asstring
argument_list|(
name|cfg_map_getname
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|key
argument_list|,
literal|"algorithm"
argument_list|,
operator|&
name|algobj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|key
argument_list|,
literal|"secret"
argument_list|,
operator|&
name|secretobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|secretobj
operator|==
name|NULL
operator|||
name|algobj
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s' must have both 'secret' and "
literal|"'algorithm' defined"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_keylist
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|keys
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|keys
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|key
init|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyname
init|=
name|cfg_obj_asstring
argument_list|(
name|cfg_map_getname
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|key
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|keyname
argument_list|,
literal|1
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|keyname
argument_list|,
literal|1
argument_list|,
operator|&
name|symvalue
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|file
operator|=
name|cfg_obj_file
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|line
operator|=
name|cfg_obj_line
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|keyname
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|tresult
operator|)
return|;
name|tresult
operator|=
name|bind9_check_key
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|tresult
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_servers
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|servers
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|e1
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|e2
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|v1
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|v2
decl_stmt|;
specifier|const
name|isc_sockaddr_t
modifier|*
name|s1
decl_stmt|;
specifier|const
name|isc_sockaddr_t
modifier|*
name|s2
decl_stmt|;
name|isc_netaddr_t
name|na
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|ts
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|xfr
decl_stmt|;
name|isc_buffer_t
name|target
decl_stmt|;
for|for
control|(
name|e1
operator|=
name|cfg_list_first
argument_list|(
name|servers
argument_list|)
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|cfg_list_next
argument_list|(
name|e1
argument_list|)
control|)
block|{
name|v1
operator|=
name|cfg_listelt_value
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|s1
operator|=
name|cfg_obj_assockaddr
argument_list|(
name|cfg_map_getname
argument_list|(
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
name|s1
argument_list|)
operator|==
name|AF_INET
condition|)
name|xfr
operator|=
literal|"transfer-source-v6"
expr_stmt|;
else|else
name|xfr
operator|=
literal|"transfer-source"
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|v1
argument_list|,
name|xfr
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
name|NULL
condition|)
block|{
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_netaddr_totext
argument_list|(
operator|&
name|na
argument_list|,
operator|&
name|target
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|target
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|v1
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"server '%s': %s not valid"
argument_list|,
name|buf
argument_list|,
name|xfr
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|e2
operator|=
name|e1
expr_stmt|;
while|while
condition|(
operator|(
name|e2
operator|=
name|cfg_list_next
argument_list|(
name|e2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|v2
operator|=
name|cfg_listelt_value
argument_list|(
name|e2
argument_list|)
expr_stmt|;
name|s2
operator|=
name|cfg_obj_assockaddr
argument_list|(
name|cfg_map_getname
argument_list|(
name|v2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_eqaddr
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|cfg_obj_file
argument_list|(
name|v1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
name|cfg_obj_line
argument_list|(
name|v1
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_netaddr_totext
argument_list|(
operator|&
name|na
argument_list|,
operator|&
name|target
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|target
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|v2
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"server '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|buf
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_viewconf
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|vconfig
parameter_list|,
name|dns_rdataclass_t
name|vclass
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|servers
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|zones
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|keys
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
comment|/* 	 * Check that all zone statements are syntactically correct and 	 * there are no duplicate zones. 	 */
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|freekey
argument_list|,
name|mctx
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|vconfig
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|vconfig
argument_list|,
literal|"zone"
argument_list|,
operator|&
name|zones
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"zone"
argument_list|,
operator|&
name|zones
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|zones
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|zone
init|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
decl_stmt|;
name|tresult
operator|=
name|check_zoneconf
argument_list|(
name|zone
argument_list|,
name|config
argument_list|,
name|symtab
argument_list|,
name|vclass
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
comment|/* 	 * Check that all key statements are syntactically correct and 	 * there are no duplicate keys. 	 */
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"key"
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|check_keylist
argument_list|(
name|keys
argument_list|,
name|symtab
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|tresult
operator|)
return|;
block|}
if|if
condition|(
name|vconfig
operator|!=
name|NULL
condition|)
block|{
name|keys
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|vconfig
argument_list|,
literal|"key"
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|check_keylist
argument_list|(
name|keys
argument_list|,
name|symtab
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|tresult
operator|)
return|;
block|}
block|}
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
comment|/* 	 * Check that forwarding is reasonable. 	 */
if|if
condition|(
name|vconfig
operator|==
name|NULL
condition|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
if|if
condition|(
name|check_forward
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_forward
argument_list|(
name|vconfig
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
comment|/* 	 * Check that dual-stack-servers is reasonable. 	 */
if|if
condition|(
name|vconfig
operator|==
name|NULL
condition|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
if|if
condition|(
name|check_dual_stack
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_dual_stack
argument_list|(
name|vconfig
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
comment|/* 	 * Check that rrset-order is reasonable. 	 */
if|if
condition|(
name|vconfig
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|check_order
argument_list|(
name|vconfig
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|vconfig
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|vconfig
argument_list|,
literal|"server"
argument_list|,
operator|&
name|servers
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|!=
name|NULL
operator|&&
name|check_servers
argument_list|(
name|servers
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|vconfig
operator|!=
name|NULL
condition|)
name|tresult
operator|=
name|check_options
argument_list|(
name|vconfig
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
else|else
name|tresult
operator|=
name|check_options
argument_list|(
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|bind9_check_namedconf
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|servers
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|views
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|acls
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|kals
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|velement
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|builtin
index|[]
init|=
block|{
literal|"localhost"
block|,
literal|"localnets"
block|,
literal|"any"
block|,
literal|"none"
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|check_options
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"server"
argument_list|,
operator|&
name|servers
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|!=
name|NULL
operator|&&
name|check_servers
argument_list|(
name|servers
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|check_order
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"view"
argument_list|,
operator|&
name|views
argument_list|)
expr_stmt|;
if|if
condition|(
name|views
operator|!=
name|NULL
operator|&&
name|options
operator|!=
name|NULL
condition|)
if|if
condition|(
name|check_dual_stack
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|views
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|check_viewconf
argument_list|(
name|config
argument_list|,
name|NULL
argument_list|,
name|dns_rdataclass_in
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|zones
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"zone"
argument_list|,
operator|&
name|zones
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
operator|!=
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zones
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"when using 'view' statements, "
literal|"all zones must be in views"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
for|for
control|(
name|velement
operator|=
name|cfg_list_first
argument_list|(
name|views
argument_list|)
init|;
name|velement
operator|!=
name|NULL
condition|;
name|velement
operator|=
name|cfg_list_next
argument_list|(
name|velement
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|view
init|=
name|cfg_listelt_value
argument_list|(
name|velement
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|vname
init|=
name|cfg_tuple_get
argument_list|(
name|view
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|voptions
init|=
name|cfg_tuple_get
argument_list|(
name|view
argument_list|,
literal|"options"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|vclassobj
init|=
name|cfg_tuple_get
argument_list|(
name|view
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
name|dns_rdataclass_t
name|vclass
init|=
name|dns_rdataclass_in
decl_stmt|;
name|isc_result_t
name|tresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|cfg_obj_asstring
argument_list|(
name|vname
argument_list|)
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|vclassobj
argument_list|)
condition|)
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|vclassobj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|vclass
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|cfg_obj_log
argument_list|(
name|vclassobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"view '%s': invalid class %s"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|vname
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|symvalue
operator|.
name|as_cpointer
operator|=
name|view
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|vclass
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|vclass
argument_list|,
operator|&
name|symvalue
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|file
operator|=
name|cfg_obj_file
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|line
operator|=
name|cfg_obj_line
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|view
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"view '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|tresult
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"_bind"
argument_list|)
operator|==
literal|0
operator|&&
name|vclass
operator|==
name|dns_rdataclass_ch
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"_default"
argument_list|)
operator|==
literal|0
operator|&&
name|vclass
operator|==
name|dns_rdataclass_in
operator|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|view
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine builtin view "
literal|"'%s'"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
name|tresult
operator|=
name|check_viewconf
argument_list|(
name|config
argument_list|,
name|voptions
argument_list|,
name|vclass
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|views
operator|!=
name|NULL
operator|&&
name|options
operator|!=
name|NULL
condition|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"cache-file"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"'cache-file' cannot be a global "
literal|"option if views are present"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"acl"
argument_list|,
operator|&
name|acls
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt2
decl_stmt|;
specifier|const
name|char
modifier|*
name|aclname
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|cfg_list_first
argument_list|(
name|acls
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl
init|=
name|cfg_listelt_value
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|aclname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|builtin
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtin
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|aclname
argument_list|,
name|builtin
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|acl
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine "
literal|"builtin acl '%s'"
argument_list|,
name|aclname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
break|break;
block|}
for|for
control|(
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
init|;
name|elt2
operator|!=
name|NULL
condition|;
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt2
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl2
init|=
name|cfg_listelt_value
argument_list|(
name|elt2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl2
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|aclname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|cfg_obj_file
argument_list|(
name|acl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
name|cfg_obj_line
argument_list|(
name|acl
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|acl2
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine "
literal|"acl '%s' previous "
literal|"definition: %s:%u"
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
block|}
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"kal"
argument_list|,
operator|&
name|kals
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt2
decl_stmt|;
specifier|const
name|char
modifier|*
name|aclname
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|cfg_list_first
argument_list|(
name|kals
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl
init|=
name|cfg_listelt_value
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|aclname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
init|;
name|elt2
operator|!=
name|NULL
condition|;
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt2
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl2
init|=
name|cfg_listelt_value
argument_list|(
name|elt2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl2
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|aclname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|cfg_obj_file
argument_list|(
name|acl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
name|cfg_obj_line
argument_list|(
name|acl
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|acl2
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine "
literal|"kal '%s' previous "
literal|"definition: %s:%u"
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

