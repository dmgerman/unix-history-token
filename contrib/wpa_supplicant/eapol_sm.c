begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / EAPOL state machines  * Copyright (c) 2004-2005, Jouni Malinen<jkmaline@cc.hut.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eapol_sm.h"
end_include

begin_include
include|#
directive|include
file|"eap.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"l2_packet.h"
end_include

begin_include
include|#
directive|include
file|"wpa.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_include
include|#
directive|include
file|"rc4.h"
end_include

begin_comment
comment|/* IEEE 802.1X-2004 - Supplicant - EAPOL state machines */
end_comment

begin_comment
comment|/**  * struct eapol_sm - Internal data for EAPOL state machines  */
end_comment

begin_struct
struct|struct
name|eapol_sm
block|{
comment|/* Timers */
name|unsigned
name|int
name|authWhile
decl_stmt|;
name|unsigned
name|int
name|heldWhile
decl_stmt|;
name|unsigned
name|int
name|startWhen
decl_stmt|;
name|unsigned
name|int
name|idleWhile
decl_stmt|;
comment|/* for EAP state machine */
comment|/* Global variables */
name|Boolean
name|eapFail
decl_stmt|;
name|Boolean
name|eapolEap
decl_stmt|;
name|Boolean
name|eapSuccess
decl_stmt|;
name|Boolean
name|initialize
decl_stmt|;
name|Boolean
name|keyDone
decl_stmt|;
name|Boolean
name|keyRun
decl_stmt|;
name|PortControl
name|portControl
decl_stmt|;
name|Boolean
name|portEnabled
decl_stmt|;
name|PortStatus
name|suppPortStatus
decl_stmt|;
comment|/* dot1xSuppControlledPortStatus */
name|Boolean
name|portValid
decl_stmt|;
name|Boolean
name|suppAbort
decl_stmt|;
name|Boolean
name|suppFail
decl_stmt|;
name|Boolean
name|suppStart
decl_stmt|;
name|Boolean
name|suppSuccess
decl_stmt|;
name|Boolean
name|suppTimeout
decl_stmt|;
comment|/* Supplicant PAE state machine */
enum|enum
block|{
name|SUPP_PAE_UNKNOWN
init|=
literal|0
block|,
name|SUPP_PAE_DISCONNECTED
init|=
literal|1
block|,
name|SUPP_PAE_LOGOFF
init|=
literal|2
block|,
name|SUPP_PAE_CONNECTING
init|=
literal|3
block|,
name|SUPP_PAE_AUTHENTICATING
init|=
literal|4
block|,
name|SUPP_PAE_AUTHENTICATED
init|=
literal|5
block|,
comment|/* unused(6) */
name|SUPP_PAE_HELD
init|=
literal|7
block|,
name|SUPP_PAE_RESTART
init|=
literal|8
block|,
name|SUPP_PAE_S_FORCE_AUTH
init|=
literal|9
block|,
name|SUPP_PAE_S_FORCE_UNAUTH
init|=
literal|10
block|}
name|SUPP_PAE_state
enum|;
comment|/* dot1xSuppPaeState */
comment|/* Variables */
name|Boolean
name|userLogoff
decl_stmt|;
name|Boolean
name|logoffSent
decl_stmt|;
name|unsigned
name|int
name|startCount
decl_stmt|;
name|Boolean
name|eapRestart
decl_stmt|;
name|PortControl
name|sPortMode
decl_stmt|;
comment|/* Constants */
name|unsigned
name|int
name|heldPeriod
decl_stmt|;
comment|/* dot1xSuppHeldPeriod */
name|unsigned
name|int
name|startPeriod
decl_stmt|;
comment|/* dot1xSuppStartPeriod */
name|unsigned
name|int
name|maxStart
decl_stmt|;
comment|/* dot1xSuppMaxStart */
comment|/* Key Receive state machine */
enum|enum
block|{
name|KEY_RX_UNKNOWN
init|=
literal|0
block|,
name|KEY_RX_NO_KEY_RECEIVE
block|,
name|KEY_RX_KEY_RECEIVE
block|}
name|KEY_RX_state
enum|;
comment|/* Variables */
name|Boolean
name|rxKey
decl_stmt|;
comment|/* Supplicant Backend state machine */
enum|enum
block|{
name|SUPP_BE_UNKNOWN
init|=
literal|0
block|,
name|SUPP_BE_INITIALIZE
init|=
literal|1
block|,
name|SUPP_BE_IDLE
init|=
literal|2
block|,
name|SUPP_BE_REQUEST
init|=
literal|3
block|,
name|SUPP_BE_RECEIVE
init|=
literal|4
block|,
name|SUPP_BE_RESPONSE
init|=
literal|5
block|,
name|SUPP_BE_FAIL
init|=
literal|6
block|,
name|SUPP_BE_TIMEOUT
init|=
literal|7
block|,
name|SUPP_BE_SUCCESS
init|=
literal|8
block|}
name|SUPP_BE_state
enum|;
comment|/* dot1xSuppBackendPaeState */
comment|/* Variables */
name|Boolean
name|eapNoResp
decl_stmt|;
name|Boolean
name|eapReq
decl_stmt|;
name|Boolean
name|eapResp
decl_stmt|;
comment|/* Constants */
name|unsigned
name|int
name|authPeriod
decl_stmt|;
comment|/* dot1xSuppAuthPeriod */
comment|/* Statistics */
name|unsigned
name|int
name|dot1xSuppEapolFramesRx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapolFramesTx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapolStartFramesTx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapolLogoffFramesTx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapolRespFramesTx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapolReqIdFramesRx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapolReqFramesRx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppInvalidEapolFramesRx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppEapLengthErrorFramesRx
decl_stmt|;
name|unsigned
name|int
name|dot1xSuppLastEapolFrameVersion
decl_stmt|;
name|unsigned
name|char
name|dot1xSuppLastEapolFrameSource
index|[
literal|6
index|]
decl_stmt|;
comment|/* Miscellaneous variables (not defined in IEEE 802.1X-2004) */
name|Boolean
name|changed
decl_stmt|;
name|struct
name|eap_sm
modifier|*
name|eap
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|config
decl_stmt|;
name|Boolean
name|initial_req
decl_stmt|;
name|u8
modifier|*
name|last_rx_key
decl_stmt|;
name|size_t
name|last_rx_key_len
decl_stmt|;
name|u8
modifier|*
name|eapReqData
decl_stmt|;
comment|/* for EAP */
name|size_t
name|eapReqDataLen
decl_stmt|;
comment|/* for EAP */
name|Boolean
name|altAccept
decl_stmt|;
comment|/* for EAP */
name|Boolean
name|altReject
decl_stmt|;
comment|/* for EAP */
name|Boolean
name|replay_counter_valid
decl_stmt|;
name|u8
name|last_replay_counter
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|eapol_config
name|conf
decl_stmt|;
name|struct
name|eapol_ctx
modifier|*
name|ctx
decl_stmt|;
enum|enum
block|{
name|EAPOL_CB_IN_PROGRESS
init|=
literal|0
block|,
name|EAPOL_CB_SUCCESS
block|,
name|EAPOL_CB_FAILURE
block|}
name|cb_status
enum|;
name|Boolean
name|cached_pmk
decl_stmt|;
name|Boolean
name|unicast_key_received
decl_stmt|,
name|broadcast_key_received
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IEEE8021X_REPLAY_COUNTER_LEN
value|8
end_define

begin_define
define|#
directive|define
name|IEEE8021X_KEY_SIGN_LEN
value|16
end_define

begin_define
define|#
directive|define
name|IEEE8021X_KEY_IV_LEN
value|16
end_define

begin_define
define|#
directive|define
name|IEEE8021X_KEY_INDEX_FLAG
value|0x80
end_define

begin_define
define|#
directive|define
name|IEEE8021X_KEY_INDEX_MASK
value|0x03
end_define

begin_struct
struct|struct
name|ieee802_1x_eapol_key
block|{
name|u8
name|type
decl_stmt|;
comment|/* Note: key_length is unaligned */
name|u8
name|key_length
index|[
literal|2
index|]
decl_stmt|;
comment|/* does not repeat within the life of the keying material used to 	 * encrypt the Key field; 64-bit NTP timestamp MAY be used here */
name|u8
name|replay_counter
index|[
name|IEEE8021X_REPLAY_COUNTER_LEN
index|]
decl_stmt|;
name|u8
name|key_iv
index|[
name|IEEE8021X_KEY_IV_LEN
index|]
decl_stmt|;
comment|/* cryptographically random number */
name|u8
name|key_index
decl_stmt|;
comment|/* key flag in the most significant bit: 		       * 0 = broadcast (default key), 		       * 1 = unicast (key mapping key); key index is in the 		       * 7 least significant bits */
comment|/* HMAC-MD5 message integrity check computed with MS-MPPE-Send-Key as 	 * the key */
name|u8
name|key_signature
index|[
name|IEEE8021X_KEY_SIGN_LEN
index|]
decl_stmt|;
comment|/* followed by key: if packet body length = 44 + key length, then the 	 * key field (of key_length bytes) contains the key in encrypted form; 	 * if packet body length = 44, key field is absent and key_length 	 * represents the number of least significant octets from 	 * MS-MPPE-Send-Key attribute to be used as the keying material; 	 * RC4 key used in encryption = Key-IV + MS-MPPE-Recv-Key */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|eapol_sm_txLogoff
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_txStart
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_processKey
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_getSuppRsp
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_txSuppRsp
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_abortSupp
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_abort_cached
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eapol_sm_step_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Definitions for clarifying state machine implementation */
end_comment

begin_define
define|#
directive|define
name|SM_STATE
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|static void sm_ ## machine ## _ ## state ## _Enter(struct eapol_sm *sm, \ 	int global)
end_define

begin_define
define|#
directive|define
name|SM_ENTRY
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|if (!global || sm->machine ## _state != machine ## _ ## state) { \ 	sm->changed = TRUE; \ 	wpa_printf(MSG_DEBUG, "EAPOL: " #machine " entering state " #state); \ } \ sm->machine ## _state = machine ## _ ## state;
end_define

begin_define
define|#
directive|define
name|SM_ENTER
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 0)
end_define

begin_define
define|#
directive|define
name|SM_ENTER_GLOBAL
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 1)
end_define

begin_define
define|#
directive|define
name|SM_STEP
parameter_list|(
name|machine
parameter_list|)
define|\
value|static void sm_ ## machine ## _Step(struct eapol_sm *sm)
end_define

begin_define
define|#
directive|define
name|SM_STEP_RUN
parameter_list|(
name|machine
parameter_list|)
value|sm_ ## machine ## _Step(sm)
end_define

begin_comment
comment|/* Port Timers state machine - implemented as a function that will be called  * once a second as a registered event loop timeout */
end_comment

begin_function
specifier|static
name|void
name|eapol_port_timers_tick
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|timeout_ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|authWhile
operator|>
literal|0
condition|)
block|{
name|sm
operator|->
name|authWhile
operator|--
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|authWhile
operator|==
literal|0
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: authWhile --> 0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|heldWhile
operator|>
literal|0
condition|)
block|{
name|sm
operator|->
name|heldWhile
operator|--
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|heldWhile
operator|==
literal|0
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: heldWhile --> 0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|startWhen
operator|>
literal|0
condition|)
block|{
name|sm
operator|->
name|startWhen
operator|--
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|startWhen
operator|==
literal|0
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: startWhen --> 0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|idleWhile
operator|>
literal|0
condition|)
block|{
name|sm
operator|->
name|idleWhile
operator|--
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|idleWhile
operator|==
literal|0
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: idleWhile --> 0"
argument_list|)
expr_stmt|;
block|}
name|eloop_register_timeout
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|eapol_port_timers_tick
argument_list|,
name|eloop_ctx
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|LOGOFF
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|LOGOFF
argument_list|)
expr_stmt|;
name|eapol_sm_txLogoff
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|logoffSent
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Unauthorized
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|DISCONNECTED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|DISCONNECTED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sPortMode
operator|=
name|Auto
expr_stmt|;
name|sm
operator|->
name|startCount
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|logoffSent
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Unauthorized
expr_stmt|;
name|sm
operator|->
name|suppAbort
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|unicast_key_received
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|broadcast_key_received
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|CONNECTING
argument_list|)
end_macro

begin_block
block|{
name|int
name|send_start
init|=
name|sm
operator|->
name|SUPP_PAE_state
operator|==
name|SUPP_PAE_CONNECTING
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_start
condition|)
block|{
name|sm
operator|->
name|startWhen
operator|=
name|sm
operator|->
name|startPeriod
expr_stmt|;
name|sm
operator|->
name|startCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Do not send EAPOL-Start immediately since in most cases, 		 * Authenticator is going to start authentication immediately 		 * after association and an extra EAPOL-Start is just going to 		 * delay authentication. Use a short timeout to send the first 		 * EAPOL-Start if Authenticator does not start authentication. 		 */
name|sm
operator|->
name|startWhen
operator|=
literal|3
expr_stmt|;
block|}
name|sm
operator|->
name|eapolEap
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|send_start
condition|)
name|eapol_sm_txStart
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|AUTHENTICATING
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|AUTHENTICATING
argument_list|)
expr_stmt|;
name|sm
operator|->
name|startCount
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|suppSuccess
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|suppFail
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|suppTimeout
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|keyRun
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|keyDone
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|suppStart
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|HELD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|HELD
argument_list|)
expr_stmt|;
name|sm
operator|->
name|heldWhile
operator|=
name|sm
operator|->
name|heldPeriod
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Unauthorized
expr_stmt|;
name|sm
operator|->
name|cb_status
operator|=
name|EAPOL_CB_FAILURE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|AUTHENTICATED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|AUTHENTICATED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Authorized
expr_stmt|;
name|sm
operator|->
name|cb_status
operator|=
name|EAPOL_CB_SUCCESS
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|RESTART
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|RESTART
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRestart
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|S_FORCE_AUTH
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|S_FORCE_AUTH
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Authorized
expr_stmt|;
name|sm
operator|->
name|sPortMode
operator|=
name|ForceAuthorized
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_PAE
argument_list|,
argument|S_FORCE_UNAUTH
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_PAE
argument_list|,
name|S_FORCE_UNAUTH
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Unauthorized
expr_stmt|;
name|sm
operator|->
name|sPortMode
operator|=
name|ForceUnauthorized
expr_stmt|;
name|eapol_sm_txLogoff
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STEP
argument_list|(
argument|SUPP_PAE
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|sm
operator|->
name|userLogoff
operator|&&
operator|!
name|sm
operator|->
name|logoffSent
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|initialize
operator|||
operator|!
name|sm
operator|->
name|portEnabled
operator|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|SUPP_PAE
argument_list|,
name|LOGOFF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|sm
operator|->
name|portControl
operator|==
name|Auto
operator|)
operator|&&
operator|(
name|sm
operator|->
name|sPortMode
operator|!=
name|sm
operator|->
name|portControl
operator|)
operator|)
operator|||
name|sm
operator|->
name|initialize
operator|||
operator|!
name|sm
operator|->
name|portEnabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|SUPP_PAE
argument_list|,
name|DISCONNECTED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sm
operator|->
name|portControl
operator|==
name|ForceAuthorized
operator|)
operator|&&
operator|(
name|sm
operator|->
name|sPortMode
operator|!=
name|sm
operator|->
name|portControl
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|initialize
operator|||
operator|!
name|sm
operator|->
name|portEnabled
operator|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|SUPP_PAE
argument_list|,
name|S_FORCE_AUTH
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sm
operator|->
name|portControl
operator|==
name|ForceUnauthorized
operator|)
operator|&&
operator|(
name|sm
operator|->
name|sPortMode
operator|!=
name|sm
operator|->
name|portControl
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|initialize
operator|||
operator|!
name|sm
operator|->
name|portEnabled
operator|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|SUPP_PAE
argument_list|,
name|S_FORCE_UNAUTH
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|sm
operator|->
name|SUPP_PAE_state
condition|)
block|{
case|case
name|SUPP_PAE_UNKNOWN
case|:
break|break;
case|case
name|SUPP_PAE_LOGOFF
case|:
if|if
condition|(
operator|!
name|sm
operator|->
name|userLogoff
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|DISCONNECTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_DISCONNECTED
case|:
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_CONNECTING
case|:
if|if
condition|(
name|sm
operator|->
name|startWhen
operator|==
literal|0
operator|&&
name|sm
operator|->
name|startCount
operator|<
name|sm
operator|->
name|maxStart
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|startWhen
operator|==
literal|0
operator|&&
name|sm
operator|->
name|startCount
operator|>=
name|sm
operator|->
name|maxStart
operator|&&
name|sm
operator|->
name|portValid
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|AUTHENTICATED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapSuccess
operator|||
name|sm
operator|->
name|eapFail
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|AUTHENTICATING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapolEap
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|RESTART
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|startWhen
operator|==
literal|0
operator|&&
name|sm
operator|->
name|startCount
operator|>=
name|sm
operator|->
name|maxStart
operator|&&
operator|!
name|sm
operator|->
name|portValid
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|HELD
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_AUTHENTICATING
case|:
if|if
condition|(
name|sm
operator|->
name|eapSuccess
operator|&&
operator|!
name|sm
operator|->
name|portValid
operator|&&
name|sm
operator|->
name|conf
operator|.
name|accept_802_1x_keys
operator|&&
name|sm
operator|->
name|conf
operator|.
name|required_keys
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: IEEE 802.1X for "
literal|"plaintext connection; no EAPOL-Key frames "
literal|"required"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|portValid
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|eapol_done_cb
condition|)
name|sm
operator|->
name|ctx
operator|->
name|eapol_done_cb
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|eapSuccess
operator|&&
name|sm
operator|->
name|portValid
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|AUTHENTICATED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapFail
operator|||
operator|(
name|sm
operator|->
name|keyDone
operator|&&
operator|!
name|sm
operator|->
name|portValid
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|HELD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|suppTimeout
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_HELD
case|:
if|if
condition|(
name|sm
operator|->
name|heldWhile
operator|==
literal|0
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|CONNECTING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapolEap
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|RESTART
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_AUTHENTICATED
case|:
if|if
condition|(
name|sm
operator|->
name|eapolEap
operator|&&
name|sm
operator|->
name|portValid
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|RESTART
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sm
operator|->
name|portValid
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|DISCONNECTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_RESTART
case|:
if|if
condition|(
operator|!
name|sm
operator|->
name|eapRestart
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_PAE
argument_list|,
name|AUTHENTICATING
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_PAE_S_FORCE_AUTH
case|:
break|break;
case|case
name|SUPP_PAE_S_FORCE_UNAUTH
case|:
break|break;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|KEY_RX
argument_list|,
argument|NO_KEY_RECEIVE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|KEY_RX
argument_list|,
name|NO_KEY_RECEIVE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|KEY_RX
argument_list|,
argument|KEY_RECEIVE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|KEY_RX
argument_list|,
name|KEY_RECEIVE
argument_list|)
expr_stmt|;
name|eapol_sm_processKey
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxKey
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STEP
argument_list|(
argument|KEY_RX
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|sm
operator|->
name|initialize
operator|||
operator|!
name|sm
operator|->
name|portEnabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|KEY_RX
argument_list|,
name|NO_KEY_RECEIVE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sm
operator|->
name|KEY_RX_state
condition|)
block|{
case|case
name|KEY_RX_UNKNOWN
case|:
break|break;
case|case
name|KEY_RX_NO_KEY_RECEIVE
case|:
if|if
condition|(
name|sm
operator|->
name|rxKey
condition|)
name|SM_ENTER
argument_list|(
name|KEY_RX
argument_list|,
name|KEY_RECEIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_RX_KEY_RECEIVE
case|:
if|if
condition|(
name|sm
operator|->
name|rxKey
condition|)
name|SM_ENTER
argument_list|(
name|KEY_RX
argument_list|,
name|KEY_RECEIVE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|REQUEST
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|REQUEST
argument_list|)
expr_stmt|;
name|sm
operator|->
name|authWhile
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|eapReq
operator|=
name|TRUE
expr_stmt|;
name|eapol_sm_getSuppRsp
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|RESPONSE
argument_list|)
expr_stmt|;
name|eapol_sm_txSuppRsp
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapResp
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|sm
operator|->
name|keyRun
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|suppSuccess
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eap_key_available
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
condition|)
block|{
comment|/* New key received - clear IEEE 802.1X EAPOL-Key replay 		 * counter */
name|sm
operator|->
name|replay_counter_valid
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|FAIL
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppFail
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|TIMEOUT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppTimeout
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppStart
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|initial_req
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
name|eapol_sm_abortSupp
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|suppAbort
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|SUPP_BE
argument_list|,
argument|RECEIVE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|SUPP_BE
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|authWhile
operator|=
name|sm
operator|->
name|authPeriod
expr_stmt|;
name|sm
operator|->
name|eapolEap
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eapNoResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|initial_req
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STEP
argument_list|(
argument|SUPP_BE
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|sm
operator|->
name|initialize
operator|||
name|sm
operator|->
name|suppAbort
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|SUPP_BE
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|sm
operator|->
name|SUPP_BE_state
condition|)
block|{
case|case
name|SUPP_BE_UNKNOWN
case|:
break|break;
case|case
name|SUPP_BE_REQUEST
case|:
if|if
condition|(
name|sm
operator|->
name|eapResp
operator|&&
name|sm
operator|->
name|eapNoResp
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: SUPP_BE REQUEST: both "
literal|"eapResp and eapNoResp set?!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|eapResp
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|RESPONSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapNoResp
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_RESPONSE
case|:
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_SUCCESS
case|:
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_FAIL
case|:
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_TIMEOUT
case|:
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_IDLE
case|:
if|if
condition|(
name|sm
operator|->
name|eapFail
operator|&&
name|sm
operator|->
name|suppStart
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapolEap
operator|&&
name|sm
operator|->
name|suppStart
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|REQUEST
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapSuccess
operator|&&
name|sm
operator|->
name|suppStart
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_INITIALIZE
case|:
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPP_BE_RECEIVE
case|:
if|if
condition|(
name|sm
operator|->
name|eapolEap
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|REQUEST
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapFail
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|authWhile
operator|==
literal|0
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eapSuccess
condition|)
name|SM_ENTER
argument_list|(
name|SUPP_BE
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|eapol_sm_txLogoff
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: txLogoff"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ctx
operator|->
name|eapol_send
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|eapol_send_ctx
argument_list|,
name|IEEE802_1X_TYPE_EAPOL_LOGOFF
argument_list|,
operator|(
name|u8
operator|*
operator|)
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sm
operator|->
name|dot1xSuppEapolLogoffFramesTx
operator|++
expr_stmt|;
name|sm
operator|->
name|dot1xSuppEapolFramesTx
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_txStart
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: txStart"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ctx
operator|->
name|eapol_send
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|eapol_send_ctx
argument_list|,
name|IEEE802_1X_TYPE_EAPOL_START
argument_list|,
operator|(
name|u8
operator|*
operator|)
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sm
operator|->
name|dot1xSuppEapolStartFramesTx
operator|++
expr_stmt|;
name|sm
operator|->
name|dot1xSuppEapolFramesTx
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IEEE8021X_ENCR_KEY_LEN
value|32
end_define

begin_define
define|#
directive|define
name|IEEE8021X_SIGN_KEY_LEN
value|32
end_define

begin_struct
struct|struct
name|eap_key_data
block|{
name|u8
name|encr_key
index|[
name|IEEE8021X_ENCR_KEY_LEN
index|]
decl_stmt|;
name|u8
name|sign_key
index|[
name|IEEE8021X_SIGN_KEY_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|eapol_sm_processKey
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|ieee802_1x_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ieee802_1x_eapol_key
modifier|*
name|key
decl_stmt|;
name|struct
name|eap_key_data
name|keydata
decl_stmt|;
name|u8
name|orig_key_sign
index|[
name|IEEE8021X_KEY_SIGN_LEN
index|]
decl_stmt|,
name|datakey
index|[
literal|32
index|]
decl_stmt|;
name|u8
name|ekey
index|[
name|IEEE8021X_KEY_IV_LEN
operator|+
name|IEEE8021X_ENCR_KEY_LEN
index|]
decl_stmt|;
name|int
name|key_len
decl_stmt|,
name|res
decl_stmt|,
name|sign_key_len
decl_stmt|,
name|encr_key_len
decl_stmt|;
name|u16
name|rx_key_length
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: processKey"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|last_rx_key
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|sm
operator|->
name|conf
operator|.
name|accept_802_1x_keys
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAPOL: Received IEEE 802.1X EAPOL-Key"
literal|" even though this was not accepted - "
literal|"ignoring this packet"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|ieee802_1x_hdr
operator|*
operator|)
name|sm
operator|->
name|last_rx_key
expr_stmt|;
name|key
operator|=
operator|(
expr|struct
name|ieee802_1x_eapol_key
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|>
name|sm
operator|->
name|last_rx_key_len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAPOL: Too short EAPOL-Key frame"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rx_key_length
operator|=
name|WPA_GET_BE16
argument_list|(
name|key
operator|->
name|key_length
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: RX IEEE 802.1X ver=%d type=%d len=%d "
literal|"EAPOL-Key: type=%d key_length=%d key_index=0x%x"
argument_list|,
name|hdr
operator|->
name|version
argument_list|,
name|hdr
operator|->
name|type
argument_list|,
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|key
operator|->
name|type
argument_list|,
name|rx_key_length
argument_list|,
name|key
operator|->
name|key_index
argument_list|)
expr_stmt|;
name|eapol_sm_notify_lower_layer_success
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sign_key_len
operator|=
name|IEEE8021X_SIGN_KEY_LEN
expr_stmt|;
name|encr_key_len
operator|=
name|IEEE8021X_ENCR_KEY_LEN
expr_stmt|;
name|res
operator|=
name|eapol_sm_get_key
argument_list|(
name|sm
argument_list|,
operator|(
name|u8
operator|*
operator|)
operator|&
name|keydata
argument_list|,
sizeof|sizeof
argument_list|(
name|keydata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Could not get master key for "
literal|"decrypting EAPOL-Key keys"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|res
operator|==
literal|16
condition|)
block|{
comment|/* LEAP derives only 16 bytes of keying material. */
name|res
operator|=
name|eapol_sm_get_key
argument_list|(
name|sm
argument_list|,
operator|(
name|u8
operator|*
operator|)
operator|&
name|keydata
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Could not get LEAP "
literal|"master key for decrypting EAPOL-Key keys"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sign_key_len
operator|=
literal|16
expr_stmt|;
name|encr_key_len
operator|=
literal|16
expr_stmt|;
name|memcpy
argument_list|(
name|keydata
operator|.
name|sign_key
argument_list|,
name|keydata
operator|.
name|encr_key
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Could not get enough master key "
literal|"data for decrypting EAPOL-Key keys (res=%d)"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The key replay_counter must increase when same master key */
if|if
condition|(
name|sm
operator|->
name|replay_counter_valid
operator|&&
name|memcmp
argument_list|(
name|sm
operator|->
name|last_replay_counter
argument_list|,
name|key
operator|->
name|replay_counter
argument_list|,
name|IEEE8021X_REPLAY_COUNTER_LEN
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAPOL: EAPOL-Key replay counter did "
literal|"not increase - ignoring key"
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: last replay counter"
argument_list|,
name|sm
operator|->
name|last_replay_counter
argument_list|,
name|IEEE8021X_REPLAY_COUNTER_LEN
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: received replay counter"
argument_list|,
name|key
operator|->
name|replay_counter
argument_list|,
name|IEEE8021X_REPLAY_COUNTER_LEN
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Verify key signature (HMAC-MD5) */
name|memcpy
argument_list|(
name|orig_key_sign
argument_list|,
name|key
operator|->
name|key_signature
argument_list|,
name|IEEE8021X_KEY_SIGN_LEN
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
operator|->
name|key_signature
argument_list|,
literal|0
argument_list|,
name|IEEE8021X_KEY_SIGN_LEN
argument_list|)
expr_stmt|;
name|hmac_md5
argument_list|(
name|keydata
operator|.
name|sign_key
argument_list|,
name|sign_key_len
argument_list|,
name|sm
operator|->
name|last_rx_key
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|key
operator|->
name|key_signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|orig_key_sign
argument_list|,
name|key
operator|->
name|key_signature
argument_list|,
name|IEEE8021X_KEY_SIGN_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Invalid key signature in "
literal|"EAPOL-Key packet"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|key
operator|->
name|key_signature
argument_list|,
name|orig_key_sign
argument_list|,
name|IEEE8021X_KEY_SIGN_LEN
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: EAPOL-Key key signature verified"
argument_list|)
expr_stmt|;
name|key_len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_len
operator|>
literal|32
operator|||
name|rx_key_length
operator|>
literal|32
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAPOL: Too long key data length %d"
argument_list|,
name|key_len
condition|?
name|key_len
else|:
name|rx_key_length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key_len
operator|==
name|rx_key_length
condition|)
block|{
name|memcpy
argument_list|(
name|ekey
argument_list|,
name|key
operator|->
name|key_iv
argument_list|,
name|IEEE8021X_KEY_IV_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ekey
operator|+
name|IEEE8021X_KEY_IV_LEN
argument_list|,
name|keydata
operator|.
name|encr_key
argument_list|,
name|encr_key_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|datakey
argument_list|,
name|key
operator|+
literal|1
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|rc4
argument_list|(
name|datakey
argument_list|,
name|key_len
argument_list|,
name|ekey
argument_list|,
name|IEEE8021X_KEY_IV_LEN
operator|+
name|encr_key_len
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Decrypted(RC4) key"
argument_list|,
name|datakey
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key_len
operator|==
literal|0
condition|)
block|{
comment|/* 		 * IEEE 802.1X-2004 specifies that least significant Key Length 		 * octets from MS-MPPE-Send-Key are used as the key if the key 		 * data is not present. This seems to be meaning the beginning 		 * of the MS-MPPE-Send-Key. In addition, MS-MPPE-Send-Key in 		 * Supplicant corresponds to MS-MPPE-Recv-Key in Authenticator. 		 * Anyway, taking the beginning of the keying material from EAP 		 * seems to interoperate with Authenticators. 		 */
name|key_len
operator|=
name|rx_key_length
expr_stmt|;
name|memcpy
argument_list|(
name|datakey
argument_list|,
name|keydata
operator|.
name|encr_key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: using part of EAP keying "
literal|"material data encryption key"
argument_list|,
name|datakey
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Invalid key data length %d "
literal|"(key_length=%d)"
argument_list|,
name|key_len
argument_list|,
name|rx_key_length
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|replay_counter_valid
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
name|sm
operator|->
name|last_replay_counter
argument_list|,
name|key
operator|->
name|replay_counter
argument_list|,
name|IEEE8021X_REPLAY_COUNTER_LEN
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Setting dynamic WEP key: %s keyidx %d "
literal|"len %d"
argument_list|,
name|key
operator|->
name|key_index
operator|&
name|IEEE8021X_KEY_INDEX_FLAG
condition|?
literal|"unicast"
else|:
literal|"broadcast"
argument_list|,
name|key
operator|->
name|key_index
operator|&
name|IEEE8021X_KEY_INDEX_MASK
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|set_wep_key
operator|&&
name|sm
operator|->
name|ctx
operator|->
name|set_wep_key
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|key
operator|->
name|key_index
operator|&
name|IEEE8021X_KEY_INDEX_FLAG
argument_list|,
name|key
operator|->
name|key_index
operator|&
name|IEEE8021X_KEY_INDEX_MASK
argument_list|,
name|datakey
argument_list|,
name|key_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAPOL: Failed to set WEP key to the "
literal|" driver."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|->
name|key_index
operator|&
name|IEEE8021X_KEY_INDEX_FLAG
condition|)
name|sm
operator|->
name|unicast_key_received
operator|=
name|TRUE
expr_stmt|;
else|else
name|sm
operator|->
name|broadcast_key_received
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|sm
operator|->
name|unicast_key_received
operator|||
operator|!
operator|(
name|sm
operator|->
name|conf
operator|.
name|required_keys
operator|&
name|EAPOL_REQUIRE_KEY_UNICAST
operator|)
operator|)
operator|&&
operator|(
name|sm
operator|->
name|broadcast_key_received
operator|||
operator|!
operator|(
name|sm
operator|->
name|conf
operator|.
name|required_keys
operator|&
name|EAPOL_REQUIRE_KEY_BROADCAST
operator|)
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: all required EAPOL-Key "
literal|"frames received"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|portValid
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|eapol_done_cb
condition|)
name|sm
operator|->
name|ctx
operator|->
name|eapol_done_cb
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_getSuppRsp
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: getSuppRsp"
argument_list|)
expr_stmt|;
comment|/* EAP layer processing; no special code is needed, since Supplicant 	 * Backend state machine is waiting for eapNoResp or eapResp to be set 	 * and these are only set in the EAP state machine when the processing 	 * has finished. */
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_txSuppRsp
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|u8
modifier|*
name|resp
decl_stmt|;
name|size_t
name|resp_len
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: txSuppRsp"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|eap_get_eapRespData
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
operator|&
name|resp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAPOL: txSuppRsp - EAP response data "
literal|"not available"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Send EAP-Packet from the EAP layer to the Authenticator */
name|sm
operator|->
name|ctx
operator|->
name|eapol_send
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|eapol_send_ctx
argument_list|,
name|IEEE802_1X_TYPE_EAP_PACKET
argument_list|,
name|resp
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
comment|/* eapRespData is not used anymore, so free it here */
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|initial_req
condition|)
name|sm
operator|->
name|dot1xSuppEapolReqIdFramesRx
operator|++
expr_stmt|;
else|else
name|sm
operator|->
name|dot1xSuppEapolReqFramesRx
operator|++
expr_stmt|;
name|sm
operator|->
name|dot1xSuppEapolRespFramesTx
operator|++
expr_stmt|;
name|sm
operator|->
name|dot1xSuppEapolFramesTx
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_abortSupp
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
comment|/* release system resources that may have been allocated for the 	 * authentication session */
name|free
argument_list|(
name|sm
operator|->
name|last_rx_key
argument_list|)
expr_stmt|;
name|sm
operator|->
name|last_rx_key
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|NULL
expr_stmt|;
name|eap_sm_abort
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_step_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|eapol_sm_step
argument_list|(
name|timeout_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_step - EAPOL state machine step function  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * This function is called to notify the state machine about changed external  * variables. It will step through the EAPOL state machines in loop to process  * all triggered state changes.  */
end_comment

begin_function
name|void
name|eapol_sm_step
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* In theory, it should be ok to run this in loop until !changed. 	 * However, it is better to use a limit on number of iterations to 	 * allow events (e.g., SIGTERM) to stop the program cleanly if the 	 * state machine were to generate a busy loop. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|SUPP_PAE
argument_list|)
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|KEY_RX
argument_list|)
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|SUPP_BE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_sm_step
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
condition|)
name|sm
operator|->
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
block|{
comment|/* restart EAPOL state machine step from timeout call in order 		 * to allow other events to be processed. */
name|eloop_cancel_timeout
argument_list|(
name|eapol_sm_step_timeout
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|eapol_sm_step_timeout
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|cb
operator|&&
name|sm
operator|->
name|cb_status
operator|!=
name|EAPOL_CB_IN_PROGRESS
condition|)
block|{
name|int
name|success
init|=
name|sm
operator|->
name|cb_status
operator|==
name|EAPOL_CB_SUCCESS
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|sm
operator|->
name|cb_status
operator|=
name|EAPOL_CB_IN_PROGRESS
expr_stmt|;
name|sm
operator|->
name|ctx
operator|->
name|cb
argument_list|(
name|sm
argument_list|,
name|success
argument_list|,
name|sm
operator|->
name|ctx
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eapol_supp_pae_state
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SUPP_PAE_LOGOFF
case|:
return|return
literal|"LOGOFF"
return|;
case|case
name|SUPP_PAE_DISCONNECTED
case|:
return|return
literal|"DISCONNECTED"
return|;
case|case
name|SUPP_PAE_CONNECTING
case|:
return|return
literal|"CONNECTING"
return|;
case|case
name|SUPP_PAE_AUTHENTICATING
case|:
return|return
literal|"AUTHENTICATING"
return|;
case|case
name|SUPP_PAE_HELD
case|:
return|return
literal|"HELD"
return|;
case|case
name|SUPP_PAE_AUTHENTICATED
case|:
return|return
literal|"AUTHENTICATED"
return|;
case|case
name|SUPP_PAE_RESTART
case|:
return|return
literal|"RESTART"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eapol_supp_be_state
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SUPP_BE_REQUEST
case|:
return|return
literal|"REQUEST"
return|;
case|case
name|SUPP_BE_RESPONSE
case|:
return|return
literal|"RESPONSE"
return|;
case|case
name|SUPP_BE_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|SUPP_BE_FAIL
case|:
return|return
literal|"FAIL"
return|;
case|case
name|SUPP_BE_TIMEOUT
case|:
return|return
literal|"TIMEOUT"
return|;
case|case
name|SUPP_BE_IDLE
case|:
return|return
literal|"IDLE"
return|;
case|case
name|SUPP_BE_INITIALIZE
case|:
return|return
literal|"INITIALIZE"
return|;
case|case
name|SUPP_BE_RECEIVE
case|:
return|return
literal|"RECEIVE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eapol_port_status
parameter_list|(
name|PortStatus
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|==
name|Authorized
condition|)
return|return
literal|"Authorized"
return|;
else|else
return|return
literal|"Unauthorized"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eapol_port_control
parameter_list|(
name|PortControl
name|ctrl
parameter_list|)
block|{
switch|switch
condition|(
name|ctrl
condition|)
block|{
case|case
name|Auto
case|:
return|return
literal|"Auto"
return|;
case|case
name|ForceUnauthorized
case|:
return|return
literal|"ForceUnauthorized"
return|;
case|case
name|ForceAuthorized
case|:
return|return
literal|"ForceAuthorized"
return|;
default|default:
return|return
literal|"Unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * eapol_sm_configure - Set EAPOL variables  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @heldPeriod: dot1xSuppHeldPeriod  * @authPeriod: dot1xSuppAuthPeriod  * @startPeriod: dot1xSuppStartPeriod  * @maxStart: dot1xSuppMaxStart  *  * Set configurable EAPOL state machine variables. Each variable can be set to  * the given value or ignored if set to -1 (to set only some of the variables).  */
end_comment

begin_function
name|void
name|eapol_sm_configure
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|int
name|heldPeriod
parameter_list|,
name|int
name|authPeriod
parameter_list|,
name|int
name|startPeriod
parameter_list|,
name|int
name|maxStart
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|heldPeriod
operator|>=
literal|0
condition|)
name|sm
operator|->
name|heldPeriod
operator|=
name|heldPeriod
expr_stmt|;
if|if
condition|(
name|authPeriod
operator|>=
literal|0
condition|)
name|sm
operator|->
name|authPeriod
operator|=
name|authPeriod
expr_stmt|;
if|if
condition|(
name|startPeriod
operator|>=
literal|0
condition|)
name|sm
operator|->
name|startPeriod
operator|=
name|startPeriod
expr_stmt|;
if|if
condition|(
name|maxStart
operator|>=
literal|0
condition|)
name|sm
operator|->
name|maxStart
operator|=
name|maxStart
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_get_status - Get EAPOL state machine status  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @buf: Buffer for status information  * @buflen: Maximum buffer length  * @verbose: Whether to include verbose status information  * Returns: Number of bytes written to buf.  *  * Query EAPOL state machine for status information. This function fills in a  * text area with current status information from the EAPOL state machine. If  * the buffer (buf) is not large enough, status information will be truncated  * to fit the buffer.  */
end_comment

begin_function
name|int
name|eapol_sm_get_status
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"Supplicant PAE state=%s\n"
literal|"suppPortStatus=%s\n"
argument_list|,
name|eapol_supp_pae_state
argument_list|(
name|sm
operator|->
name|SUPP_PAE_state
argument_list|)
argument_list|,
name|eapol_port_status
argument_list|(
name|sm
operator|->
name|suppPortStatus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"heldPeriod=%u\n"
literal|"authPeriod=%u\n"
literal|"startPeriod=%u\n"
literal|"maxStart=%u\n"
literal|"portControl=%s\n"
literal|"Supplicant Backend state=%s\n"
argument_list|,
name|sm
operator|->
name|heldPeriod
argument_list|,
name|sm
operator|->
name|authPeriod
argument_list|,
name|sm
operator|->
name|startPeriod
argument_list|,
name|sm
operator|->
name|maxStart
argument_list|,
name|eapol_port_control
argument_list|(
name|sm
operator|->
name|portControl
argument_list|)
argument_list|,
name|eapol_supp_be_state
argument_list|(
name|sm
operator|->
name|SUPP_BE_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
name|eap_sm_get_status
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_get_mib - Get EAPOL state machine MIBs  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @buf: Buffer for MIB information  * @buflen: Maximum buffer length  * Returns: Number of bytes written to buf.  *  * Query EAPOL state machine for MIB information. This function fills in a  * text area with current MIB information from the EAPOL state machine. If  * the buffer (buf) is not large enough, MIB information will be truncated to  * fit the buffer.  */
end_comment

begin_function
name|int
name|eapol_sm_get_mib
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"dot1xSuppPaeState=%d\n"
literal|"dot1xSuppHeldPeriod=%u\n"
literal|"dot1xSuppAuthPeriod=%u\n"
literal|"dot1xSuppStartPeriod=%u\n"
literal|"dot1xSuppMaxStart=%u\n"
literal|"dot1xSuppSuppControlledPortStatus=%s\n"
literal|"dot1xSuppBackendPaeState=%d\n"
literal|"dot1xSuppEapolFramesRx=%u\n"
literal|"dot1xSuppEapolFramesTx=%u\n"
literal|"dot1xSuppEapolStartFramesTx=%u\n"
literal|"dot1xSuppEapolLogoffFramesTx=%u\n"
literal|"dot1xSuppEapolRespFramesTx=%u\n"
literal|"dot1xSuppEapolReqIdFramesRx=%u\n"
literal|"dot1xSuppEapolReqFramesRx=%u\n"
literal|"dot1xSuppInvalidEapolFramesRx=%u\n"
literal|"dot1xSuppEapLengthErrorFramesRx=%u\n"
literal|"dot1xSuppLastEapolFrameVersion=%u\n"
literal|"dot1xSuppLastEapolFrameSource="
name|MACSTR
literal|"\n"
argument_list|,
name|sm
operator|->
name|SUPP_PAE_state
argument_list|,
name|sm
operator|->
name|heldPeriod
argument_list|,
name|sm
operator|->
name|authPeriod
argument_list|,
name|sm
operator|->
name|startPeriod
argument_list|,
name|sm
operator|->
name|maxStart
argument_list|,
name|sm
operator|->
name|suppPortStatus
operator|==
name|Authorized
condition|?
literal|"Authorized"
else|:
literal|"Unauthorized"
argument_list|,
name|sm
operator|->
name|SUPP_BE_state
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolFramesRx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolFramesTx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolStartFramesTx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolLogoffFramesTx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolRespFramesTx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolReqIdFramesRx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapolReqFramesRx
argument_list|,
name|sm
operator|->
name|dot1xSuppInvalidEapolFramesRx
argument_list|,
name|sm
operator|->
name|dot1xSuppEapLengthErrorFramesRx
argument_list|,
name|sm
operator|->
name|dot1xSuppLastEapolFrameVersion
argument_list|,
name|MAC2STR
argument_list|(
name|sm
operator|->
name|dot1xSuppLastEapolFrameSource
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_rx_eapol - Process received EAPOL frames  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @src: Source MAC address of the EAPOL packet  * @buf: Pointer to the beginning of the EAPOL data (EAPOL header)  * @len: Length of the EAPOL frame  * Returns: 1 = EAPOL frame processed, 0 = not for EAPOL state machine,  * -1 failure  */
end_comment

begin_function
name|int
name|eapol_sm_rx_eapol
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|ieee802_1x_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|struct
name|ieee802_1x_eapol_key
modifier|*
name|key
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|data_len
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|sm
operator|->
name|dot1xSuppEapolFramesRx
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|sm
operator|->
name|dot1xSuppInvalidEapolFramesRx
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|ieee802_1x_hdr
operator|*
operator|)
name|buf
expr_stmt|;
name|sm
operator|->
name|dot1xSuppLastEapolFrameVersion
operator|=
name|hdr
operator|->
name|version
expr_stmt|;
name|memcpy
argument_list|(
name|sm
operator|->
name|dot1xSuppLastEapolFrameSource
argument_list|,
name|src
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|version
operator|<
name|EAPOL_VERSION
condition|)
block|{
comment|/* TODO: backwards compatibility */
block|}
name|plen
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|sm
operator|->
name|dot1xSuppEapLengthErrorFramesRx
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|data_len
operator|=
name|plen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|type
condition|)
block|{
case|case
name|IEEE802_1X_TYPE_EAP_PACKET
case|:
if|if
condition|(
name|sm
operator|->
name|cached_pmk
condition|)
block|{
comment|/* Trying to use PMKSA caching, but Authenticator did 			 * not seem to have a matching entry. Need to restart 			 * EAPOL state machines. 			 */
name|eapol_sm_abort_cached
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqDataLen
operator|=
name|plen
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|malloc
argument_list|(
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapReqData
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Received EAP-Packet "
literal|"frame"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|,
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
argument_list|,
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapolEap
operator|=
name|TRUE
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE802_1X_TYPE_EAPOL_KEY
case|:
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Too short EAPOL-Key "
literal|"frame received"
argument_list|)
expr_stmt|;
break|break;
block|}
name|key
operator|=
operator|(
specifier|const
expr|struct
name|ieee802_1x_eapol_key
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|type
operator|==
name|EAPOL_KEY_TYPE_WPA
operator|||
name|key
operator|->
name|type
operator|==
name|EAPOL_KEY_TYPE_RSN
condition|)
block|{
comment|/* WPA Supplicant takes care of this frame. */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Ignoring WPA EAPOL-Key "
literal|"frame in EAPOL state machines"
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|key
operator|->
name|type
operator|!=
name|EAPOL_KEY_TYPE_RC4
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Ignored unknown "
literal|"EAPOL-Key type %d"
argument_list|,
name|key
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|sm
operator|->
name|last_rx_key
argument_list|)
expr_stmt|;
name|sm
operator|->
name|last_rx_key
operator|=
name|malloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|last_rx_key
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Received EAPOL-Key "
literal|"frame"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sm
operator|->
name|last_rx_key
argument_list|,
name|buf
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|sm
operator|->
name|last_rx_key_len
operator|=
name|data_len
expr_stmt|;
name|sm
operator|->
name|rxKey
operator|=
name|TRUE
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: Received unknown EAPOL type %d"
argument_list|,
name|hdr
operator|->
name|type
argument_list|)
expr_stmt|;
name|sm
operator|->
name|dot1xSuppInvalidEapolFramesRx
operator|++
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_tx_eapol_key - Notification about transmitted EAPOL packet  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * Notify EAPOL station machine about transmitted EAPOL packet from an external  * component, e.g., WPA. This will update the statistics.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_tx_eapol_key
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|sm
operator|->
name|dot1xSuppEapolFramesTx
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_portEnabled - Notification about portEnabled change  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @enabled: New portEnabled value  *  * Notify EAPOL station machine about new portEnabled value.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_portEnabled
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|Boolean
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: External notification - "
literal|"portEnabled=%d"
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|sm
operator|->
name|portEnabled
operator|=
name|enabled
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_portValid - Notification about portValid change  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @valid: New portValid value  *  * Notify EAPOL station machine about new portValid value.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_portValid
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|Boolean
name|valid
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: External notification - "
literal|"portValid=%d"
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|sm
operator|->
name|portValid
operator|=
name|valid
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_eap_success - Notification of external EAP success trigger  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @success: %TRUE = set success, %FALSE = clear success  *  * Notify EAPOL station machine that external event has forced EAP state to  * success (success = %TRUE). This can be cleared by setting success = %FALSE.  *  * This function is called to update EAP state when WPA-PSK key handshake has  * been completed successfully since WPA-PSK does not use EAP state machine.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_eap_success
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|Boolean
name|success
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: External notification - "
literal|"EAP success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapSuccess
operator|=
name|success
expr_stmt|;
name|sm
operator|->
name|altAccept
operator|=
name|success
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|eap_notify_success
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_eap_fail - Notification of external EAP failure trigger  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @fail: %TRUE = set failure, %FALSE = clear failure  *  * Notify EAPOL station machine that external event has forced EAP state to  * failure (fail = %TRUE). This can be cleared by setting fail = %FALSE.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_eap_fail
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|Boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: External notification - "
literal|"EAP fail=%d"
argument_list|,
name|fail
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapFail
operator|=
name|fail
expr_stmt|;
name|sm
operator|->
name|altReject
operator|=
name|fail
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_config - Notification of EAPOL configuration change  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @config: Pointer to current network configuration  * @conf: Pointer to EAPOL configuration data  *  * Notify EAPOL station machine that configuration has changed. config will be  * stored as a backpointer to network configuration. This can be %NULL to clear  * the stored pointed. conf will be copied to local EAPOL/EAP configuration  * data. If conf is %NULL, this part of the configuration change will be  * skipped.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_config
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
specifier|const
name|struct
name|eapol_config
modifier|*
name|conf
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|sm
operator|->
name|config
operator|=
name|config
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
condition|)
return|return;
name|sm
operator|->
name|conf
operator|.
name|accept_802_1x_keys
operator|=
name|conf
operator|->
name|accept_802_1x_keys
expr_stmt|;
name|sm
operator|->
name|conf
operator|.
name|required_keys
operator|=
name|conf
operator|->
name|required_keys
expr_stmt|;
name|sm
operator|->
name|conf
operator|.
name|fast_reauth
operator|=
name|conf
operator|->
name|fast_reauth
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap
condition|)
block|{
name|eap_set_fast_reauth
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
name|conf
operator|->
name|fast_reauth
argument_list|)
expr_stmt|;
name|eap_set_workaround
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
name|conf
operator|->
name|workaround
argument_list|)
expr_stmt|;
name|eap_set_force_disabled
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
name|conf
operator|->
name|eap_disabled
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eapol_sm_get_key - Get master session key (MSK) from EAP  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @key: Pointer for key buffer  * @len: Number of bytes to copy to key  * Returns: 0 on success (len of key available), maximum available key len  * (>0) if key is available but it is shorter than len, or -1 on failure.  *  * Fetch EAP keying material (MSK, eapKeyData) from EAP state machine. The key  * is available only after a successful authentication.  */
end_comment

begin_function
name|int
name|eapol_sm_get_key
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|eap_key
decl_stmt|;
name|size_t
name|eap_len
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
operator|!
name|eap_key_available
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|eap_key
operator|=
name|eap_get_eapKeyData
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
operator|&
name|eap_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_key
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|len
operator|>
name|eap_len
condition|)
return|return
name|eap_len
return|;
name|memcpy
argument_list|(
name|key
argument_list|,
name|eap_key
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_logoff - Notification of logon/logoff commands  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @logoff: Whether command was logoff  *  * Notify EAPOL state machines that user requested logon/logoff.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_logoff
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|Boolean
name|logoff
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
block|{
name|sm
operator|->
name|userLogoff
operator|=
name|logoff
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_pmkid_attempt - Notification of successful PMKSA caching  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * Notify EAPOL state machines that PMKSA caching was successful. This is used  * to move EAPOL and EAP state machines into authenticated/successful state.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_cached
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|sm
operator|->
name|SUPP_PAE_state
operator|=
name|SUPP_PAE_AUTHENTICATED
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Authorized
expr_stmt|;
name|eap_notify_success
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_pmkid_attempt - Notification of PMKSA caching  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @attempt: Whether PMKSA caching is tried  *  * Notify EAPOL state machines whether PMKSA caching is used.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_pmkid_attempt
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|int
name|attempt
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|attempt
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: Trying to use cached PMKSA"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|cached_pmk
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: Do not try to use cached PMKSA"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|cached_pmk
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_abort_cached
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: Authenticator did not accept PMKID, "
literal|"doing full EAP authentication"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|sm
operator|->
name|cached_pmk
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|SUPP_PAE_state
operator|=
name|SUPP_PAE_CONNECTING
expr_stmt|;
name|sm
operator|->
name|suppPortStatus
operator|=
name|Unauthorized
expr_stmt|;
name|sm
operator|->
name|eapRestart
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_register_scard_ctx - Notification of smart card context  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @ctx: Context data for smart card operations  *  * Notify EAPOL state machines of context data for smart card operations. This  * context data will be used as a parameter for scard_*() functions.  */
end_comment

begin_function
name|void
name|eapol_sm_register_scard_ctx
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
block|{
name|sm
operator|->
name|ctx
operator|->
name|scard_ctx
operator|=
name|ctx
expr_stmt|;
name|eap_register_scard_ctx
argument_list|(
name|sm
operator|->
name|eap
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_portControl - Notification of portControl changes  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  * @portControl: New value for portControl variable  *  * Notify EAPOL state machines that portControl variable has changed.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_portControl
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|,
name|PortControl
name|portControl
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: External notification - "
literal|"portControl=%s"
argument_list|,
name|eapol_port_control
argument_list|(
name|portControl
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|portControl
operator|=
name|portControl
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_ctrl_attached - Notification of attached monitor  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * Notify EAPOL state machines that a monitor was attached to the control  * interface to trigger re-sending of pending requests for user input.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_ctrl_attached
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eap_sm_notify_ctrl_attached
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_ctrl_response - Notification of received user input  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * Notify EAPOL state machines that a control response, i.e., user  * input, was received in order to trigger retrying of a pending EAP request.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_ctrl_response
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|eapReqData
operator|&&
operator|!
name|sm
operator|->
name|eapReq
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAPOL: received control response (user "
literal|"input) notification - retrying pending EAP "
literal|"Request"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapolEap
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|eapReq
operator|=
name|TRUE
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eapol_sm_request_reauth - Request reauthentication  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * This function can be used to request EAPOL reauthentication, e.g., when the  * current PMKSA entry is nearing expiration.  */
end_comment

begin_function
name|void
name|eapol_sm_request_reauth
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|SUPP_PAE_state
operator|!=
name|SUPP_PAE_AUTHENTICATED
condition|)
return|return;
name|eapol_sm_txStart
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_notify_lower_layer_success - Notification of lower layer success  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * Notify EAPOL (and EAP) state machines that a lower layer has detected a  * successful authentication. This is used to recover from dropped EAP-Success  * messages.  */
end_comment

begin_function
name|void
name|eapol_sm_notify_lower_layer_success
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eap_notify_lower_layer_success
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpa_ssid
modifier|*
name|eapol_sm_get_config
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
return|return
name|sm
condition|?
name|sm
operator|->
name|config
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eapol_sm_get_eapReqData
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapReqData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|sm
operator|->
name|eapReqDataLen
expr_stmt|;
return|return
name|sm
operator|->
name|eapReqData
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eapol_sm_get_bool
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|eapol_bool_var
name|variable
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|variable
condition|)
block|{
case|case
name|EAPOL_eapSuccess
case|:
return|return
name|sm
operator|->
name|eapSuccess
return|;
case|case
name|EAPOL_eapRestart
case|:
return|return
name|sm
operator|->
name|eapRestart
return|;
case|case
name|EAPOL_eapFail
case|:
return|return
name|sm
operator|->
name|eapFail
return|;
case|case
name|EAPOL_eapResp
case|:
return|return
name|sm
operator|->
name|eapResp
return|;
case|case
name|EAPOL_eapNoResp
case|:
return|return
name|sm
operator|->
name|eapNoResp
return|;
case|case
name|EAPOL_eapReq
case|:
return|return
name|sm
operator|->
name|eapReq
return|;
case|case
name|EAPOL_portEnabled
case|:
return|return
name|sm
operator|->
name|portEnabled
return|;
case|case
name|EAPOL_altAccept
case|:
return|return
name|sm
operator|->
name|altAccept
return|;
case|case
name|EAPOL_altReject
case|:
return|return
name|sm
operator|->
name|altReject
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_set_bool
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|eapol_bool_var
name|variable
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|variable
condition|)
block|{
case|case
name|EAPOL_eapSuccess
case|:
name|sm
operator|->
name|eapSuccess
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_eapRestart
case|:
name|sm
operator|->
name|eapRestart
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_eapFail
case|:
name|sm
operator|->
name|eapFail
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_eapResp
case|:
name|sm
operator|->
name|eapResp
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_eapNoResp
case|:
name|sm
operator|->
name|eapNoResp
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_eapReq
case|:
name|sm
operator|->
name|eapReq
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_portEnabled
case|:
name|sm
operator|->
name|portEnabled
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_altAccept
case|:
name|sm
operator|->
name|altAccept
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|EAPOL_altReject
case|:
name|sm
operator|->
name|altReject
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|eapol_sm_get_int
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|eapol_int_var
name|variable
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|variable
condition|)
block|{
case|case
name|EAPOL_idleWhile
case|:
return|return
name|sm
operator|->
name|idleWhile
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_set_int
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|eapol_int_var
name|variable
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|variable
condition|)
block|{
case|case
name|EAPOL_idleWhile
case|:
name|sm
operator|->
name|idleWhile
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_sm_set_config_blob
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|struct
name|wpa_config_blob
modifier|*
name|blob
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|&&
name|sm
operator|->
name|ctx
operator|&&
name|sm
operator|->
name|ctx
operator|->
name|set_config_blob
condition|)
name|sm
operator|->
name|ctx
operator|->
name|set_config_blob
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|wpa_config_blob
modifier|*
name|eapol_sm_get_config_blob
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|sm
operator|&&
name|sm
operator|->
name|ctx
operator|&&
name|sm
operator|->
name|ctx
operator|->
name|get_config_blob
condition|)
return|return
name|sm
operator|->
name|ctx
operator|->
name|get_config_blob
argument_list|(
name|sm
operator|->
name|ctx
operator|->
name|ctx
argument_list|,
name|name
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|eapol_callbacks
name|eapol_cb
init|=
block|{
operator|.
name|get_config
operator|=
name|eapol_sm_get_config
block|,
operator|.
name|get_bool
operator|=
name|eapol_sm_get_bool
block|,
operator|.
name|set_bool
operator|=
name|eapol_sm_set_bool
block|,
operator|.
name|get_int
operator|=
name|eapol_sm_get_int
block|,
operator|.
name|set_int
operator|=
name|eapol_sm_set_int
block|,
operator|.
name|get_eapReqData
operator|=
name|eapol_sm_get_eapReqData
block|,
operator|.
name|set_config_blob
operator|=
name|eapol_sm_set_config_blob
block|,
operator|.
name|get_config_blob
operator|=
name|eapol_sm_get_config_blob
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * eapol_sm_init - Initialize EAPOL state machine  * @ctx: Pointer to EAPOL context data; this needs to be an allocated buffer  * and EAPOL state machine will free it in eapol_sm_deinit()  * Returns: Pointer to the allocated EAPOL state machine or %NULL on failure  *  * Allocate and initialize an EAPOL state machine.  */
end_comment

begin_function
name|struct
name|eapol_sm
modifier|*
name|eapol_sm_init
parameter_list|(
name|struct
name|eapol_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|eapol_sm
modifier|*
name|sm
decl_stmt|;
name|struct
name|eap_config
name|conf
decl_stmt|;
name|sm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|sm
operator|->
name|portControl
operator|=
name|Auto
expr_stmt|;
comment|/* Supplicant PAE state machine */
name|sm
operator|->
name|heldPeriod
operator|=
literal|60
expr_stmt|;
name|sm
operator|->
name|startPeriod
operator|=
literal|30
expr_stmt|;
name|sm
operator|->
name|maxStart
operator|=
literal|3
expr_stmt|;
comment|/* Supplicant Backend state machine */
name|sm
operator|->
name|authPeriod
operator|=
literal|30
expr_stmt|;
name|memset
argument_list|(
operator|&
name|conf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|opensc_engine_path
operator|=
name|ctx
operator|->
name|opensc_engine_path
expr_stmt|;
name|conf
operator|.
name|pkcs11_engine_path
operator|=
name|ctx
operator|->
name|pkcs11_engine_path
expr_stmt|;
name|conf
operator|.
name|pkcs11_module_path
operator|=
name|ctx
operator|->
name|pkcs11_module_path
expr_stmt|;
name|sm
operator|->
name|eap
operator|=
name|eap_sm_init
argument_list|(
name|sm
argument_list|,
operator|&
name|eapol_cb
argument_list|,
name|sm
operator|->
name|ctx
operator|->
name|msg_ctx
argument_list|,
operator|&
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize EAPOL state machines */
name|sm
operator|->
name|initialize
operator|=
name|TRUE
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|initialize
operator|=
name|FALSE
expr_stmt|;
name|eapol_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|eapol_port_timers_tick
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
return|return
name|sm
return|;
block|}
end_function

begin_comment
comment|/**  * eapol_sm_deinit - Deinitialize EAPOL state machine  * @sm: Pointer to EAPOL state machine allocated with eapol_sm_init()  *  * Deinitialize and free EAPOL state machine.  */
end_comment

begin_function
name|void
name|eapol_sm_deinit
parameter_list|(
name|struct
name|eapol_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eloop_cancel_timeout
argument_list|(
name|eapol_sm_step_timeout
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|eapol_port_timers_tick
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|eap_sm_deinit
argument_list|(
name|sm
operator|->
name|eap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|last_rx_key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

