begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / EAP state machines  * Copyright (c) 2004-2005, Jouni Malinen<jkmaline@cc.hut.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"config_ssid.h"
end_include

begin_include
include|#
directive|include
file|"tls.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_define
define|#
directive|define
name|EAP_MAX_AUTH_ROUNDS
value|50
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_MD5
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_md5
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TLS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_tls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_MSCHAPv2
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_mschapv2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_PEAP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_peap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TTLS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_ttls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_GTC
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_gtc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_OTP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_otp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_SIM
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_sim
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_LEAP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_leap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_PSK
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_psk
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_AKA
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_aka
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_FAST
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_fast
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_methods
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|EAP_MD5
operator|&
name|eap_method_md5
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_TLS
operator|&
name|eap_method_tls
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_MSCHAPv2
operator|&
name|eap_method_mschapv2
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_PEAP
operator|&
name|eap_method_peap
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_TTLS
operator|&
name|eap_method_ttls
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_GTC
operator|&
name|eap_method_gtc
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_OTP
operator|&
name|eap_method_otp
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_SIM
operator|&
name|eap_method_sim
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_LEAP
operator|&
name|eap_method_leap
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_PSK
operator|&
name|eap_method_psk
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_AKA
operator|&
name|eap_method_aka
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAP_FAST
operator|&
name|eap_method_fast
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_EAP_METHODS
value|(sizeof(eap_methods) / sizeof(eap_methods[0]))
end_define

begin_function
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_sm_get_eap_methods
parameter_list|(
name|int
name|method
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|==
name|method
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|int
name|decision
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Definitions for clarifying state machine implementation */
end_comment

begin_define
define|#
directive|define
name|SM_STATE
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|static void sm_ ## machine ## _ ## state ## _Enter(struct eap_sm *sm, \ 	int global)
end_define

begin_define
define|#
directive|define
name|SM_ENTRY
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|if (!global || sm->machine ## _state != machine ## _ ## state) { \ 	sm->changed = TRUE; \ 	wpa_printf(MSG_DEBUG, "EAP: " #machine " entering state " #state); \ } \ sm->machine ## _state = machine ## _ ## state;
end_define

begin_define
define|#
directive|define
name|SM_ENTER
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 0)
end_define

begin_define
define|#
directive|define
name|SM_ENTER_GLOBAL
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 1)
end_define

begin_define
define|#
directive|define
name|SM_STEP
parameter_list|(
name|machine
parameter_list|)
define|\
value|static void sm_ ## machine ## _Step(struct eap_sm *sm)
end_define

begin_define
define|#
directive|define
name|SM_STEP_RUN
parameter_list|(
name|machine
parameter_list|)
value|sm_ ## machine ## _Step(sm)
end_define

begin_function
specifier|static
name|Boolean
name|eapol_get_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|eapol_get_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eapol_get_eapReqData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eapReqData
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_deinit_prev_method
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: deinitialize previously used EAP method "
literal|"(%d, %s) at %s"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|,
name|txt
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: maintaining EAP method data for "
literal|"fast reauthentication"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"INITIALIZE"
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|FALSE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* new session - make sure this does not match with 			  * the first EAP-Packet */
comment|/* draft-ietf-eap-statemachine-02.pdf does not reset eapResp and 	 * eapNoResp here. However, this seemed to be able to trigger cases 	 * where both were set and if EAPOL state machine uses eapNoResp first, 	 * it may end up not sending a real reply correctly. This occurred 	 * when the workaround in FAIL state set eapNoResp = TRUE.. Maybe that 	 * workaround needs to be fixed to do something else(?) */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISABLED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED
argument_list|)
end_macro

begin_block
block|{
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
comment|/* parse rxReq, rxSuccess, rxFailure, reqId, reqMethod */
name|eap_sm_parseEapReq
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|GET_METHOD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_sm_allowMethod
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|)
condition|)
block|{
name|int
name|reinit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|method
operator|==
name|sm
operator|->
name|reqMethod
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using previous method data"
literal|" for fast re-authentication"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"GET_METHOD"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|selectedMethod
operator|=
name|sm
operator|->
name|reqMethod
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
name|sm
operator|->
name|m
operator|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|selectedMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: initialize selected EAP "
literal|"method (%d, %s)"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Failed to "
literal|"initialize EAP method %d"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|methodState
operator|=
name|METHOD_INIT
expr_stmt|;
return|return;
block|}
block|}
block|}
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNak
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD
argument_list|)
end_macro

begin_block
block|{
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|struct
name|eap_method_ret
name|ret
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP::METHOD - method not selected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
comment|/* Get ignore, methodState, decision, allowNotifications, and 	 * eapRespData. */
name|memset
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|ignore
operator|=
name|sm
operator|->
name|ignore
expr_stmt|;
name|ret
operator|.
name|methodState
operator|=
name|sm
operator|->
name|methodState
expr_stmt|;
name|ret
operator|.
name|decision
operator|=
name|sm
operator|->
name|decision
expr_stmt|;
name|ret
operator|.
name|allowNotifications
operator|=
name|sm
operator|->
name|allowNotifications
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|sm
operator|->
name|m
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|ret
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: method process -> ignore=%s "
literal|"methodState=%s decision=%s"
argument_list|,
name|ret
operator|.
name|ignore
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|ret
operator|.
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|ret
operator|.
name|decision
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ignore
operator|=
name|ret
operator|.
name|ignore
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
return|return;
name|sm
operator|->
name|methodState
operator|=
name|ret
operator|.
name|methodState
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|ret
operator|.
name|decision
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|ret
operator|.
name|allowNotifications
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
operator|&&
name|sm
operator|->
name|m
operator|->
name|getKey
operator|&&
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|sm
operator|->
name|m
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
name|memcpy
argument_list|(
name|sm
operator|->
name|last_md5
argument_list|,
name|sm
operator|->
name|req_md5
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
name|sm
operator|->
name|reqId
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|malloc
argument_list|(
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
block|{
name|memcpy
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastRespDataLen
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
block|}
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|sm
operator|->
name|lastRespData
operator|=
name|NULL
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDENTITY
argument_list|)
end_macro

begin_block
block|{
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|eap_sm_processIdentity
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildIdentity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|NOTIFICATION
argument_list|)
end_macro

begin_block
block|{
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|eap_sm_processNotify
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNotify
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
block|{
name|sm
operator|->
name|eapRespData
operator|=
name|malloc
argument_list|(
name|sm
operator|->
name|lastRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
name|memcpy
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|lastRespData
argument_list|,
name|sm
operator|->
name|lastRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
name|sm
operator|->
name|lastRespDataLen
expr_stmt|;
block|}
block|}
else|else
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* draft-ietf-eap-statemachine-02.pdf does not clear eapReq here, but 	 * this seems to be required to avoid processing the same request 	 * twice when state machine is initialized. */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* draft-ietf-eap-statemachine-02.pdf does not set eapNoResp here, but 	 * this seems to be required to get EAPOL Supplicant backend state 	 * machine into SUCCESS state. In addition, either eapResp or eapNoResp 	 * is required to be set after processing the received EAP frame. */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* draft-ietf-eap-statemachine-02.pdf does not clear eapReq here, but 	 * this seems to be required to avoid processing the same request 	 * twice when state machine is initialized. */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* draft-ietf-eap-statemachine-02.pdf does not set eapNoResp here. 	 * However, either eapResp or eapNoResp is required to be set after 	 * processing the received EAP frame. */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|eap_success_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|reqId
parameter_list|,
name|int
name|lastId
parameter_list|)
block|{
comment|/* 	 * At least Microsoft IAS and Meetinghouse Aegis seem to be sending 	 * EAP-Success/Failure with lastId + 1 even though RFC 3748 and 	 * draft-ietf-eap-statemachine-05.pdf require that reqId == lastId. 	 * In addition, it looks like Ringmaster v2.1.2.0 would be using 	 * lastId + 2 in EAP-Success. 	 * 	 * Accept this kind of Id if EAP workarounds are enabled. These are 	 * unauthenticated plaintext messages, so this should have minimal 	 * security implications (bit easier to fake EAP-Success/Failure). 	 */
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
operator|(
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|||
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|2
operator|)
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Workaround for unexpected "
literal|"identifier field in EAP Success: "
literal|"reqId=%d lastId=%d (these are supposed to be "
literal|"same)"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Success Id mismatch - reqId=%d "
literal|"lastId=%d"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|SM_STEP
argument_list|(
argument|EAP
argument_list|)
end_macro

begin_block
block|{
name|int
name|duplicate
decl_stmt|;
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|)
operator|&&
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|>
name|EAP_MAX_AUTH_ROUNDS
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|==
name|EAP_MAX_AUTH_ROUNDS
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: more than %d "
literal|"authentication rounds - abort"
argument_list|,
name|EAP_MAX_AUTH_ROUNDS
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|sm
operator|->
name|EAP_state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISABLED
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_UNCOND_SUCC
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altReject
argument_list|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
name|sm
operator|->
name|leap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_PEAP
operator|&&
name|sm
operator|->
name|peap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED
case|:
name|duplicate
operator|=
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|duplicate
operator|&&
name|memcmp
argument_list|(
name|sm
operator|->
name|req_md5
argument_list|,
name|sm
operator|->
name|last_md5
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* draft-ietf-eap-statemachine-05.txt uses 			 * (reqId == lastId) as the only verification for 			 * duplicate EAP requests. However, this misses cases 			 * where the AS is incorrectly using the same id again; 			 * and unfortunately, such implementations exist. Use 			 * MD5 hash as an extra verification for the packets 			 * being duplicate to workaround these issues. */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: AS used the same Id again,"
literal|" but EAP packets were not identical"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: workaround - assume this "
literal|"is not a duplicate packet"
argument_list|)
expr_stmt|;
name|duplicate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|rxSuccess
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
operator|(
operator|(
name|sm
operator|->
name|rxFailure
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|sm
operator|->
name|rxSuccess
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|)
operator|)
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
name|duplicate
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_NOTIFICATION
operator|&&
name|sm
operator|->
name|allowNotifications
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_IDENTITY
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_NOTIFICATION
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|sm
operator|->
name|selectedMethod
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
operator|(
name|sm
operator|->
name|rxSuccess
operator|||
name|sm
operator|->
name|rxResp
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_GET_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|sm
operator|->
name|reqMethod
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_RESPONSE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISCARD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDENTITY
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_NOTIFICATION
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SUCCESS
case|:
break|break;
case|case
name|EAP_FAILURE
case|:
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|method
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|==
name|method
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Nak (requested type %d not "
literal|"allowed)"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
operator|+
name|NUM_EAP_METHODS
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_NAK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|++
operator|=
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|pos
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: allowed methods"
argument_list|,
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
operator|)
operator|+
literal|1
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
decl_stmt|;
name|u8
modifier|*
name|pos
init|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|pos
operator|++
expr_stmt|;
comment|/* TODO: could save displayable message so that it can be shown to the 	 * user in case of interaction is required */
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Identity data"
argument_list|,
name|pos
argument_list|,
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u8
modifier|*
name|eap_sm_buildIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
name|encrypted
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
specifier|const
name|u8
modifier|*
name|identity
decl_stmt|;
name|size_t
name|identity_len
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: configuration "
literal|"was not available"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_identity
operator|&&
operator|(
name|identity
operator|=
name|sm
operator|->
name|m
operator|->
name|get_identity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|identity_len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using method re-auth "
literal|"identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|encrypted
operator|&&
name|config
operator|->
name|anonymous_identity
condition|)
block|{
name|identity
operator|=
name|config
operator|->
name|anonymous_identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|anonymous_identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using anonymous identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using real identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: identity "
literal|"configuration was not available"
argument_list|)
expr_stmt|;
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
operator|+
name|identity_len
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_IDENTITY
expr_stmt|;
name|memcpy
argument_list|(
name|pos
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
decl_stmt|;
name|u8
modifier|*
name|pos
init|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|pos
operator|++
expr_stmt|;
comment|/* TODO: log the Notification Request and make it available for UI */
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Notification data"
argument_list|,
name|pos
argument_list|,
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Generating EAP-Response Notification"
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|=
name|EAP_TYPE_NOTIFICATION
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
name|MD5_CTX
name|context
decl_stmt|;
name|sm
operator|->
name|rxReq
operator|=
name|sm
operator|->
name|rxSuccess
operator|=
name|sm
operator|->
name|rxFailure
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|reqId
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return;
name|hdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
expr_stmt|;
name|plen
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated EAP-Packet "
literal|"(len=%lu plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|reqId
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
block|{
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|req
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|sm
operator|->
name|req_md5
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hdr
operator|->
name|code
condition|)
block|{
case|case
name|EAP_CODE_REQUEST
case|:
name|sm
operator|->
name|rxReq
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
name|sm
operator|->
name|reqMethod
operator|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Request method=%d "
literal|"id=%d"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_RESPONSE
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
condition|)
block|{
name|sm
operator|->
name|rxResp
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
name|sm
operator|->
name|reqMethod
operator|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Response for "
literal|"LEAP method=%d id=%d"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Response"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_SUCCESS
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Success"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxSuccess
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|EAP_CODE_FAILURE
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Failure"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxFailure
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Packet with unknown "
literal|"code %d"
argument_list|,
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|eap_sm
modifier|*
name|eap_sm_init
parameter_list|(
name|void
modifier|*
name|eapol_ctx
parameter_list|,
name|struct
name|eapol_callbacks
modifier|*
name|eapol_cb
parameter_list|,
name|void
modifier|*
name|msg_ctx
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
decl_stmt|;
name|sm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapol_ctx
operator|=
name|eapol_ctx
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|=
name|eapol_cb
expr_stmt|;
name|sm
operator|->
name|msg_ctx
operator|=
name|msg_ctx
expr_stmt|;
name|sm
operator|->
name|ClientTimeout
operator|=
literal|60
expr_stmt|;
name|sm
operator|->
name|ssl_ctx
operator|=
name|tls_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ssl_ctx
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"SSL: Failed to initialize TLS "
literal|"context."
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|sm
return|;
block|}
end_function

begin_function
name|void
name|eap_sm_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"EAP deinit"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|tls_deinit
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eap_sm_step
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|EAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
name|res
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sm
operator|->
name|changed
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|eap_sm_abort
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
comment|/* release system resources that may have been allocated for the 	 * authentication session */
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
return|return
literal|"INITIALIZE"
return|;
case|case
name|EAP_DISABLED
case|:
return|return
literal|"DISABLED"
return|;
case|case
name|EAP_IDLE
case|:
return|return
literal|"IDLE"
return|;
case|case
name|EAP_RECEIVED
case|:
return|return
literal|"RECEIVED"
return|;
case|case
name|EAP_GET_METHOD
case|:
return|return
literal|"GET_METHOD"
return|;
case|case
name|EAP_METHOD
case|:
return|return
literal|"METHOD"
return|;
case|case
name|EAP_SEND_RESPONSE
case|:
return|return
literal|"SEND_RESPONSE"
return|;
case|case
name|EAP_DISCARD
case|:
return|return
literal|"DISCARD"
return|;
case|case
name|EAP_IDENTITY
case|:
return|return
literal|"IDENTITY"
return|;
case|case
name|EAP_NOTIFICATION
case|:
return|return
literal|"NOTIFICATION"
return|;
case|case
name|EAP_RETRANSMIT
case|:
return|return
literal|"RETRANSMIT"
return|;
case|case
name|EAP_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|EAP_FAILURE
case|:
return|return
literal|"FAILURE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|METHOD_NONE
case|:
return|return
literal|"NONE"
return|;
case|case
name|METHOD_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|METHOD_CONT
case|:
return|return
literal|"CONT"
return|;
case|case
name|METHOD_MAY_CONT
case|:
return|return
literal|"MAY_CONT"
return|;
case|case
name|METHOD_DONE
case|:
return|return
literal|"DONE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|int
name|decision
parameter_list|)
block|{
switch|switch
condition|(
name|decision
condition|)
block|{
case|case
name|DECISION_FAIL
case|:
return|return
literal|"FAIL"
return|;
case|case
name|DECISION_COND_SUCC
case|:
return|return
literal|"COND_SUCC"
return|;
case|case
name|DECISION_UNCOND_SUCC
case|:
return|return
literal|"UNCOND_SUCC"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
name|int
name|eap_sm_get_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"EAP state=%s\n"
argument_list|,
name|eap_sm_state_txt
argument_list|(
name|sm
operator|->
name|EAP_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|name
operator|=
name|sm
operator|->
name|m
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|eap_method
modifier|*
name|m
init|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|selectedMethod
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|name
operator|=
name|m
operator|->
name|name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"selectedMethod=%d (EAP-%s)\n"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_status
condition|)
block|{
name|len
operator|+=
name|sm
operator|->
name|m
operator|->
name|get_status
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"reqMethod=%d\n"
literal|"methodState=%s\n"
literal|"decision=%s\n"
literal|"ClientTimeout=%d\n"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|sm
operator|->
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|sm
operator|->
name|decision
argument_list|)
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|TYPE_IDENTITY
block|,
name|TYPE_PASSWORD
block|,
name|TYPE_OTP
block|}
name|eap_ctrl_req_type
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|eap_sm_request
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
name|eap_ctrl_req_type
name|type
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
operator|||
name|sm
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_IDENTITY
case|:
name|field
operator|=
literal|"IDENTITY"
expr_stmt|;
name|txt
operator|=
literal|"Identity"
expr_stmt|;
name|config
operator|->
name|pending_req_identity
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_PASSWORD
case|:
name|field
operator|=
literal|"PASSWORD"
expr_stmt|;
name|txt
operator|=
literal|"Password"
expr_stmt|;
name|config
operator|->
name|pending_req_password
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_OTP
case|:
name|field
operator|=
literal|"OTP"
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|tmp
operator|=
name|malloc
argument_list|(
name|msglen
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|txt
operator|=
name|tmp
expr_stmt|;
name|free
argument_list|(
name|config
operator|->
name|pending_req_otp
argument_list|)
expr_stmt|;
name|config
operator|->
name|pending_req_otp
operator|=
name|tmp
expr_stmt|;
name|config
operator|->
name|pending_req_otp_len
operator|=
name|msglen
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config
operator|->
name|pending_req_otp
operator|==
name|NULL
condition|)
return|return;
name|txt
operator|=
name|config
operator|->
name|pending_req_otp
expr_stmt|;
block|}
break|break;
default|default:
return|return;
block|}
name|buflen
operator|=
literal|100
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
operator|+
name|config
operator|->
name|ssid_len
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"CTRL-REQ-%s-%d:%s needed for SSID "
argument_list|,
name|field
argument_list|,
name|config
operator|->
name|id
argument_list|,
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|ssid
operator|&&
name|buflen
operator|>
name|len
operator|+
name|config
operator|->
name|ssid_len
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|config
operator|->
name|ssid
argument_list|,
name|config
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|config
operator|->
name|ssid_len
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eap_sm_request_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_IDENTITY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eap_sm_request_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eap_sm_request_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msg_len
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|TYPE_OTP
argument_list|,
name|msg
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eap_sm_notify_ctrl_attached
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
comment|/* Re-send any pending requests for user data since a new control 	 * interface was added. This handles cases where the EAP authentication 	 * starts immediately after system startup when the user interface is 	 * not yet running. */
if|if
condition|(
name|config
operator|->
name|pending_req_identity
condition|)
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_password
condition|)
name|eap_sm_request_password
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_otp
condition|)
name|eap_sm_request_otp
argument_list|(
name|sm
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u8
name|eap_get_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
return|;
block|}
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_allowed_phase2_type
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
name|type
operator|!=
name|EAP_TYPE_PEAP
operator|&&
name|type
operator|!=
name|EAP_TYPE_TTLS
operator|&&
name|type
operator|!=
name|EAP_TYPE_FAST
return|;
block|}
end_function

begin_function
name|u8
name|eap_get_phase2_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u8
name|type
init|=
name|eap_get_type
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_function
name|u8
modifier|*
name|eap_get_phase2_types
parameter_list|(
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|u8
modifier|*
name|buf
decl_stmt|,
name|method
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|NUM_EAP_METHODS
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
name|method
operator|=
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
expr_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|method
argument_list|)
condition|)
block|{
if|if
condition|(
name|method
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
name|config
operator|->
name|private_key2
operator|==
name|NULL
condition|)
continue|continue;
name|buf
index|[
operator|*
name|count
index|]
operator|=
name|method
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|eap_set_fast_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|sm
operator|->
name|fast_reauth
operator|=
name|enabled
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eap_set_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|unsigned
name|int
name|workaround
parameter_list|)
block|{
name|sm
operator|->
name|workaround
operator|=
name|workaround
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|wpa_ssid
modifier|*
name|eap_get_config
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|eap_key_available
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
condition|?
name|sm
operator|->
name|eapKeyAvailable
else|:
literal|0
return|;
block|}
end_function

begin_function
name|void
name|eap_notify_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
block|{
name|sm
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|sm
operator|->
name|EAP_state
operator|=
name|EAP_SUCCESS
expr_stmt|;
block|}
block|}
end_function

begin_function
name|u8
modifier|*
name|eap_get_eapKeyData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapKeyData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|sm
operator|->
name|eapKeyDataLen
expr_stmt|;
return|return
name|sm
operator|->
name|eapKeyData
return|;
block|}
end_function

begin_function
name|u8
modifier|*
name|eap_get_eapRespData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|u8
modifier|*
name|resp
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapRespData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|resp
operator|=
name|sm
operator|->
name|eapRespData
expr_stmt|;
operator|*
name|len
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
literal|0
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_function
name|void
name|eap_register_scard_ctx
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|sm
operator|->
name|scard_ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function

end_unit

