begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * EAP peer state machines (RFC 4137)  * Copyright (c) 2004-2006, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  *  * This file implements the Peer State Machine as defined in RFC 4137. The used  * states and state transitions match mostly with the RFC. However, there are  * couple of additional transitions for working around small issues noticed  * during testing. These exceptions are explained in comments within the  * functions in this file. The method functions, m.func(), are similar to the  * ones used in RFC 4137, but some small changes have used here to optimize  * operations and to add functionality needed for fast re-authentication  * (session resumption).  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"config_ssid.h"
end_include

begin_include
include|#
directive|include
file|"tls.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_include
include|#
directive|include
file|"pcsc_funcs.h"
end_include

begin_include
include|#
directive|include
file|"wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"state_machine.h"
end_include

begin_define
define|#
directive|define
name|STATE_MACHINE_DATA
value|struct eap_sm
end_define

begin_define
define|#
directive|define
name|STATE_MACHINE_DEBUG_PREFIX
value|"EAP"
end_define

begin_define
define|#
directive|define
name|EAP_MAX_AUTH_ROUNDS
value|50
end_define

begin_function_decl
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|vendor
parameter_list|,
name|EapType
name|method
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|EapMethodState
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|EapDecision
name|decision
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_function
specifier|static
name|Boolean
name|eapol_get_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|eapol_get_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eapol_get_eapReqData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eapReqData
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_deinit_prev_method
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: deinitialize previously used EAP method "
literal|"(%d, %s) at %s"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|,
name|txt
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This state initializes state machine variables when the machine is  * activated (portEnabled = TRUE). This is also used when re-starting  * authentication (eapRestart == TRUE).  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: maintaining EAP method data for "
literal|"fast reauthentication"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"INITIALIZE"
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|FALSE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* new session - make sure this does not match with 			  * the first EAP-Packet */
comment|/* 	 * RFC 4137 does not reset eapResp and eapNoResp here. However, this 	 * seemed to be able to trigger cases where both were set and if EAPOL 	 * state machine uses eapNoResp first, it may end up not sending a real 	 * reply correctly. This occurred when the workaround in FAIL state set 	 * eapNoResp = TRUE.. Maybe that workaround needs to be fixed to do 	 * something else(?) 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is reached whenever service from the lower layer is interrupted  * or unavailable (portEnabled == FALSE). Immediate transition to INITIALIZE  * occurs when the port becomes enabled.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISABLED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The state machine spends most of its time here, waiting for something to  * happen. This state is entered unconditionally from INITIALIZE, DISCARD, and  * SEND_RESPONSE states.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered when an EAP packet is received (eapReq == TRUE) to  * parse the packet header.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
comment|/* parse rxReq, rxSuccess, rxFailure, reqId, reqMethod */
name|eap_sm_parseEapReq
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered when a request for a new type comes in. Either the  * correct method is started, or a Nak response is built.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|GET_METHOD
argument_list|)
end_macro

begin_block
block|{
name|int
name|reinit
decl_stmt|;
name|EapType
name|method
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
name|method
operator|=
name|sm
operator|->
name|reqVendorMethod
expr_stmt|;
else|else
name|method
operator|=
name|sm
operator|->
name|reqMethod
expr_stmt|;
if|if
condition|(
operator|!
name|eap_sm_allowMethod
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: vendor %u method %u not allowed"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
goto|goto
name|nak
goto|;
block|}
comment|/* 	 * RFC 4137 does not define specific operation for fast 	 * re-authentication (session resumption). The design here is to allow 	 * the previously used method data to be maintained for 	 * re-authentication if the method support session resumption. 	 * Otherwise, the previously used method data is freed and a new method 	 * is allocated here. 	 */
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|vendor
operator|==
name|sm
operator|->
name|reqVendor
operator|&&
name|sm
operator|->
name|m
operator|->
name|method
operator|==
name|method
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Using previous method data"
literal|" for fast re-authentication"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"GET_METHOD"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
block|}
name|sm
operator|->
name|selectedMethod
operator|=
name|sm
operator|->
name|reqMethod
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
name|sm
operator|->
name|m
operator|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|m
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Could not find selected method: "
literal|"vendor %d method %d"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
goto|goto
name|nak
goto|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Initialize selected EAP method: "
literal|"vendor %u method %u (%s)"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"EAP: Failed to initialize EAP method: vendor %u "
literal|"method %u (%s)"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
operator|(
name|config
operator|->
name|pending_req_pin
operator|||
name|config
operator|->
name|pending_req_passphrase
operator|)
condition|)
block|{
comment|/* 			 * Return without generating Nak in order to allow 			 * entering of PIN code or passphrase to retry the 			 * current EAP packet. 			 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Pending PIN/passphrase "
literal|"request - skip Nak"
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|nak
goto|;
block|}
name|sm
operator|->
name|methodState
operator|=
name|METHOD_INIT
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_METHOD
literal|"EAP vendor %u method %u (%s) selected"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
name|nak
label|:
name|os_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNak
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The method processing happens here. The request from the authenticator is  * processed, and an appropriate response packet is built.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD
argument_list|)
end_macro

begin_block
block|{
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|struct
name|eap_method_ret
name|ret
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP::METHOD - method not selected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
comment|/* 	 * Get ignore, methodState, decision, allowNotifications, and 	 * eapRespData. RFC 4137 uses three separate method procedure (check, 	 * process, and buildResp) in this state. These have been combined into 	 * a single function call to m->process() in order to optimize EAP 	 * method implementation interface a bit. These procedures are only 	 * used from within this METHOD state, so there is no need to keep 	 * these as separate C functions. 	 * 	 * The RFC 4137 procedures return values as follows: 	 * ignore = m.check(eapReqData) 	 * (methodState, decision, allowNotifications) = m.process(eapReqData) 	 * eapRespData = m.buildResp(reqId) 	 */
name|os_memset
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|ignore
operator|=
name|sm
operator|->
name|ignore
expr_stmt|;
name|ret
operator|.
name|methodState
operator|=
name|sm
operator|->
name|methodState
expr_stmt|;
name|ret
operator|.
name|decision
operator|=
name|sm
operator|->
name|decision
expr_stmt|;
name|ret
operator|.
name|allowNotifications
operator|=
name|sm
operator|->
name|allowNotifications
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|sm
operator|->
name|m
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|ret
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: method process -> ignore=%s "
literal|"methodState=%s decision=%s"
argument_list|,
name|ret
operator|.
name|ignore
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|ret
operator|.
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|ret
operator|.
name|decision
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ignore
operator|=
name|ret
operator|.
name|ignore
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
return|return;
name|sm
operator|->
name|methodState
operator|=
name|ret
operator|.
name|methodState
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|ret
operator|.
name|decision
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|ret
operator|.
name|allowNotifications
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
operator|&&
name|sm
operator|->
name|m
operator|->
name|getKey
operator|&&
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|os_free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|sm
operator|->
name|m
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This state signals the lower layer that a response packet is ready to be  * sent.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
name|os_memcpy
argument_list|(
name|sm
operator|->
name|last_md5
argument_list|,
name|sm
operator|->
name|req_md5
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
name|sm
operator|->
name|reqId
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|os_malloc
argument_list|(
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
block|{
name|os_memcpy
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastRespDataLen
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
block|}
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|sm
operator|->
name|lastRespData
operator|=
name|NULL
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state signals the lower layer that the request was discarded, and no  * response packet will be sent at this time.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handles requests for Identity method and builds a response.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDENTITY
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|eap_sm_processIdentity
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildIdentity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handles requests for Notification method and builds a response.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|NOTIFICATION
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|u8
modifier|*
name|eapReqData
decl_stmt|;
name|size_t
name|eapReqDataLen
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|,
operator|&
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|eap_sm_processNotify
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNotify
argument_list|(
name|sm
operator|->
name|reqId
argument_list|,
operator|&
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state retransmits the previous response packet.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
block|{
name|sm
operator|->
name|eapRespData
operator|=
name|os_malloc
argument_list|(
name|sm
operator|->
name|lastRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
name|os_memcpy
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|lastRespData
argument_list|,
name|sm
operator|->
name|lastRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
name|sm
operator|->
name|lastRespDataLen
expr_stmt|;
block|}
block|}
else|else
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered in case of a successful completion of authentication  * and state machine waits here until port is disabled or EAP authentication is  * restarted.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not clear eapReq here, but this seems to be required 	 * to avoid processing the same request twice when state machine is 	 * initialized. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not set eapNoResp here, but this seems to be required 	 * to get EAPOL Supplicant backend state machine into SUCCESS state. In 	 * addition, either eapResp or eapNoResp is required to be set after 	 * processing the received EAP frame. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP authentication completed successfully"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered in case of a failure and state machine waits here  * until port is disabled or EAP authentication is restarted.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not clear eapReq here, but this seems to be required 	 * to avoid processing the same request twice when state machine is 	 * initialized. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not set eapNoResp here. However, either eapResp or 	 * eapNoResp is required to be set after processing the received EAP 	 * frame. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_FAILURE
literal|"EAP authentication failed"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|eap_success_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|reqId
parameter_list|,
name|int
name|lastId
parameter_list|)
block|{
comment|/* 	 * At least Microsoft IAS and Meetinghouse Aegis seem to be sending 	 * EAP-Success/Failure with lastId + 1 even though RFC 3748 and 	 * RFC 4137 require that reqId == lastId. In addition, it looks like 	 * Ringmaster v2.1.2.0 would be using lastId + 2 in EAP-Success. 	 * 	 * Accept this kind of Id if EAP workarounds are enabled. These are 	 * unauthenticated plaintext messages, so this should have minimal 	 * security implications (bit easier to fake EAP-Success/Failure). 	 */
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
operator|(
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|||
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|2
operator|)
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Workaround for unexpected "
literal|"identifier field in EAP Success: "
literal|"reqId=%d lastId=%d (these are supposed to be "
literal|"same)"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Success Id mismatch - reqId=%d "
literal|"lastId=%d"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * RFC 4137 - Appendix A.1: EAP Peer State Machine - State transitions  */
end_comment

begin_macro
name|SM_STEP
argument_list|(
argument|EAP
argument_list|)
end_macro

begin_block
block|{
name|int
name|duplicate
decl_stmt|;
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|)
operator|&&
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
operator|||
name|sm
operator|->
name|force_disabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|>
name|EAP_MAX_AUTH_ROUNDS
condition|)
block|{
comment|/* RFC 4137 does not place any limit on number of EAP messages 		 * in an authentication session. However, some error cases have 		 * ended up in a state were EAP messages were sent between the 		 * peer and server in a loop (e.g., TLS ACK frame in both 		 * direction). Since this is quite undesired outcome, limit the 		 * total number of EAP round-trips and abort authentication if 		 * this limit is exceeded. 		 */
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|==
name|EAP_MAX_AUTH_ROUNDS
operator|+
literal|1
condition|)
block|{
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"EAP: more than %d "
literal|"authentication rounds - abort"
argument_list|,
name|EAP_MAX_AUTH_ROUNDS
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|sm
operator|->
name|EAP_state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISABLED
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
operator|&&
operator|!
name|sm
operator|->
name|force_disabled
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE
case|:
comment|/* 		 * The first three transitions are from RFC 4137. The last two 		 * are local additions to handle special cases with LEAP and 		 * PEAP server not sending EAP-Success in some cases. 		 */
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_UNCOND_SUCC
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altReject
argument_list|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
name|sm
operator|->
name|leap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_PEAP
operator|&&
name|sm
operator|->
name|peap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED
case|:
name|duplicate
operator|=
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|)
operator|&&
name|sm
operator|->
name|rxReq
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|duplicate
operator|&&
name|os_memcmp
argument_list|(
name|sm
operator|->
name|req_md5
argument_list|,
name|sm
operator|->
name|last_md5
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * RFC 4137 uses (reqId == lastId) as the only 			 * verification for duplicate EAP requests. However, 			 * this misses cases where the AS is incorrectly using 			 * the same id again; and unfortunately, such 			 * implementations exist. Use MD5 hash as an extra 			 * verification for the packets being duplicate to 			 * workaround these issues. 			 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: AS used the same Id again,"
literal|" but EAP packets were not identical"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: workaround - assume this "
literal|"is not a duplicate packet"
argument_list|)
expr_stmt|;
name|duplicate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Two special cases below for LEAP are local additions to work 		 * around odd LEAP behavior (EAP-Success in the middle of 		 * authentication and then swapped roles). Other transitions 		 * are based on RFC 4137. 		 */
if|if
condition|(
name|sm
operator|->
name|rxSuccess
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
operator|(
operator|(
name|sm
operator|->
name|rxFailure
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|sm
operator|->
name|rxSuccess
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|&&
operator|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_LEAP
operator|||
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_MAY_CONT
operator|)
operator|)
operator|)
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
name|duplicate
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_NOTIFICATION
operator|&&
name|sm
operator|->
name|allowNotifications
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_IDENTITY
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_NOTIFICATION
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|sm
operator|->
name|selectedMethod
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
operator|(
name|sm
operator|->
name|rxSuccess
operator|||
name|sm
operator|->
name|rxResp
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_GET_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|sm
operator|->
name|reqMethod
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_RESPONSE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISCARD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDENTITY
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_NOTIFICATION
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SUCCESS
case|:
break|break;
case|case
name|EAP_FAILURE
case|:
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|vendor
parameter_list|,
name|EapType
name|method
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|vendor
argument_list|,
name|method
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: configuration does not allow: "
literal|"vendor %u method %u"
argument_list|,
name|vendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|eap_sm_get_eap_methods
argument_list|(
name|vendor
argument_list|,
name|method
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: not included in build: "
literal|"vendor %u method %u"
argument_list|,
name|vendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_build_expanded_nak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|struct
name|eap_method
modifier|*
name|methods
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|m
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building expanded EAP-Nak"
argument_list|)
expr_stmt|;
comment|/* RFC 3748 - 5.3.2: Expanded Nak */
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|8
expr_stmt|;
name|resp
operator|=
name|os_malloc
argument_list|(
operator|*
name|len
operator|+
literal|8
operator|*
operator|(
name|count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_EXPANDED
expr_stmt|;
name|WPA_PUT_BE24
argument_list|(
name|pos
argument_list|,
name|EAP_VENDOR_IETF
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|pos
argument_list|,
name|EAP_TYPE_NAK
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|m
operator|=
name|methods
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sm
operator|->
name|reqVendor
operator|==
name|m
operator|->
name|vendor
operator|&&
name|sm
operator|->
name|reqVendorMethod
operator|==
name|m
operator|->
name|method
condition|)
continue|continue;
comment|/* do not allow the current method again */
if|if
condition|(
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|m
operator|->
name|vendor
argument_list|,
name|m
operator|->
name|method
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: allowed type: "
literal|"vendor=%u method=%u"
argument_list|,
name|m
operator|->
name|vendor
argument_list|,
name|m
operator|->
name|method
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_EXPANDED
expr_stmt|;
name|WPA_PUT_BE24
argument_list|(
name|pos
argument_list|,
name|m
operator|->
name|vendor
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|pos
argument_list|,
name|m
operator|->
name|method
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|+=
literal|8
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: no more allowed methods"
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_EXPANDED
expr_stmt|;
name|WPA_PUT_BE24
argument_list|(
name|pos
argument_list|,
name|EAP_VENDOR_IETF
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|pos
argument_list|,
name|EAP_TYPE_NONE
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|+=
literal|8
expr_stmt|;
block|}
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|,
name|expanded_found
init|=
literal|0
decl_stmt|;
name|size_t
name|count
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|methods
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Nak (requested type %u "
literal|"vendor=%u method=%u not allowed)"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|sm
operator|->
name|reqVendorMethod
argument_list|)
expr_stmt|;
name|methods
operator|=
name|eap_peer_get_methods
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
return|return
name|eap_sm_build_expanded_nak
argument_list|(
name|sm
argument_list|,
name|id
argument_list|,
name|len
argument_list|,
name|methods
argument_list|,
name|count
argument_list|)
return|;
comment|/* RFC 3748 - 5.3.1: Legacy Nak */
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|resp
operator|=
name|os_malloc
argument_list|(
operator|*
name|len
operator|+
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_NAK
expr_stmt|;
for|for
control|(
name|m
operator|=
name|methods
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|m
operator|->
name|method
operator|==
name|sm
operator|->
name|reqMethod
condition|)
continue|continue;
comment|/* do not allow the current method again */
if|if
condition|(
name|wpa_config_allowed_eap_method
argument_list|(
name|config
argument_list|,
name|m
operator|->
name|vendor
argument_list|,
name|m
operator|->
name|method
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|vendor
operator|!=
name|EAP_VENDOR_IETF
condition|)
block|{
if|if
condition|(
name|expanded_found
condition|)
continue|continue;
name|expanded_found
operator|=
literal|1
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_EXPANDED
expr_stmt|;
block|}
else|else
operator|*
name|pos
operator|++
operator|=
name|m
operator|->
name|method
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|pos
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: allowed methods"
argument_list|,
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
operator|)
operator|+
literal|1
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
init|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|pos
operator|++
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_STARTED
literal|"EAP authentication started"
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 3748 - 5.1: Identity 	 * Data field may contain a displayable message in UTF-8. If this 	 * includes NUL-character, only the data before that should be 	 * displayed. Some EAP implementasitons may piggy-back additional 	 * options after the NUL. 	 */
comment|/* TODO: could save displayable message so that it can be shown to the 	 * user in case of interaction is required */
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Identity data"
argument_list|,
name|pos
argument_list|,
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PCSC_FUNCS
end_ifdef

begin_function
specifier|static
name|int
name|eap_sm_imsi_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|int
name|aka
init|=
literal|0
decl_stmt|;
name|char
name|imsi
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|imsi_len
decl_stmt|;
name|struct
name|eap_method_type
modifier|*
name|m
init|=
name|ssid
operator|->
name|eap_methods
decl_stmt|;
name|int
name|i
decl_stmt|;
name|imsi_len
operator|=
sizeof|sizeof
argument_list|(
name|imsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|scard_get_imsi
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|,
name|imsi
argument_list|,
operator|&
name|imsi_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to get IMSI from SIM"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"IMSI"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m
operator|&&
operator|(
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|m
index|[
name|i
index|]
operator|.
name|method
operator|!=
name|EAP_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|m
index|[
name|i
index|]
operator|.
name|method
operator|==
name|EAP_TYPE_AKA
condition|)
block|{
name|aka
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|os_free
argument_list|(
name|ssid
operator|->
name|identity
argument_list|)
expr_stmt|;
name|ssid
operator|->
name|identity
operator|=
name|os_malloc
argument_list|(
literal|1
operator|+
name|imsi_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to allocate buffer for "
literal|"IMSI-based identity"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ssid
operator|->
name|identity
index|[
literal|0
index|]
operator|=
name|aka
condition|?
literal|'0'
else|:
literal|'1'
expr_stmt|;
name|os_memcpy
argument_list|(
name|ssid
operator|->
name|identity
operator|+
literal|1
argument_list|,
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
name|ssid
operator|->
name|identity_len
operator|=
literal|1
operator|+
name|imsi_len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCSC_FUNCS */
end_comment

begin_function
specifier|static
name|int
name|eap_sm_get_scard_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCSC_FUNCS
if|if
condition|(
name|scard_set_pin
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|,
name|ssid
operator|->
name|pin
argument_list|)
condition|)
block|{
comment|/* 		 * Make sure the same PIN is not tried again in order to avoid 		 * blocking SIM. 		 */
name|os_free
argument_list|(
name|ssid
operator|->
name|pin
argument_list|)
expr_stmt|;
name|ssid
operator|->
name|pin
operator|=
name|NULL
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"PIN validation failed"
argument_list|)
expr_stmt|;
name|eap_sm_request_pin
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|eap_sm_imsi_identity
argument_list|(
name|sm
argument_list|,
name|ssid
argument_list|)
return|;
else|#
directive|else
comment|/* PCSC_FUNCS */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* PCSC_FUNCS */
block|}
end_function

begin_comment
comment|/**  * eap_sm_buildIdentity - Build EAP-Identity/Response for the current network  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @id: EAP identifier for the packet  * @len: Pointer to a variable that will be set to the length of the response  * @encrypted: Whether the packet is for encrypted tunnel (EAP phase 2)  * Returns: Pointer to the allocated EAP-Identity/Response packet or %NULL on  * failure  *  * This function allocates and builds an EAP-Identity/Response packet for the  * current network. The caller is responsible for freeing the returned data.  */
end_comment

begin_function
name|u8
modifier|*
name|eap_sm_buildIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
name|encrypted
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
specifier|const
name|u8
modifier|*
name|identity
decl_stmt|;
name|size_t
name|identity_len
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: configuration "
literal|"was not available"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_identity
operator|&&
operator|(
name|identity
operator|=
name|sm
operator|->
name|m
operator|->
name|get_identity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|identity_len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using method re-auth "
literal|"identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|encrypted
operator|&&
name|config
operator|->
name|anonymous_identity
condition|)
block|{
name|identity
operator|=
name|config
operator|->
name|anonymous_identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|anonymous_identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using anonymous identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using real identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: identity "
literal|"configuration was not available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pcsc
condition|)
block|{
if|if
condition|(
name|eap_sm_get_scard_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"permanent identity from "
literal|"IMSI"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
operator|+
name|identity_len
expr_stmt|;
name|resp
operator|=
name|os_malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_IDENTITY
expr_stmt|;
name|os_memcpy
argument_list|(
name|pos
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|msg_len
decl_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
name|msg_len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_len
operator|<
literal|5
condition|)
return|return;
name|msg_len
operator|-=
literal|5
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Notification data"
argument_list|,
name|pos
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
name|msg
operator|=
name|os_malloc
argument_list|(
name|msg_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_len
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|isprint
argument_list|(
name|pos
index|[
name|i
index|]
argument_list|)
condition|?
operator|(
name|char
operator|)
name|pos
index|[
name|i
index|]
else|:
literal|'_'
expr_stmt|;
name|msg
index|[
name|msg_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"%s%s"
argument_list|,
name|WPA_EVENT_EAP_NOTIFICATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Generating EAP-Response Notification"
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|resp
operator|=
name|os_malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|=
name|EAP_TYPE_NOTIFICATION
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|req
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|sm
operator|->
name|rxReq
operator|=
name|sm
operator|->
name|rxResp
operator|=
name|sm
operator|->
name|rxSuccess
operator|=
name|sm
operator|->
name|rxFailure
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|reqId
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|reqVendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|sm
operator|->
name|reqVendorMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return;
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|req
expr_stmt|;
name|plen
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated EAP-Packet "
literal|"(len=%lu plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|reqId
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
block|{
name|md5_vector
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|*
operator|)
operator|&
name|req
argument_list|,
operator|&
name|plen
argument_list|,
name|sm
operator|->
name|req_md5
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hdr
operator|->
name|code
condition|)
block|{
case|case
name|EAP_CODE_REQUEST
case|:
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short EAP-Request - "
literal|"no Type field"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|rxReq
operator|=
name|TRUE
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
block|{
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|8
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated "
literal|"expanded EAP-Packet (plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|reqVendor
operator|=
name|WPA_GET_BE24
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|sm
operator|->
name|reqVendorMethod
operator|=
name|WPA_GET_BE32
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Request id=%d "
literal|"method=%u vendor=%u vendorMethod=%u"
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|sm
operator|->
name|reqVendorMethod
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_RESPONSE
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
condition|)
block|{
comment|/* 			 * LEAP differs from RFC 4137 by using reversed roles 			 * for mutual authentication and because of this, we 			 * need to accept EAP-Response frames if LEAP is used. 			 */
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short "
literal|"EAP-Response - no Type field"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|rxResp
operator|=
name|TRUE
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
operator|*
name|pos
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Response for "
literal|"LEAP method=%d id=%d"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Response"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_SUCCESS
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Success"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxSuccess
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|EAP_CODE_FAILURE
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Failure"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxFailure
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Packet with unknown "
literal|"code %d"
argument_list|,
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_sm_init - Allocate and initialize EAP state machine  * @eapol_ctx: Context data to be used with eapol_cb calls  * @eapol_cb: Pointer to EAPOL callback functions  * @msg_ctx: Context data for wpa_msg() calls  * @conf: EAP configuration  * Returns: Pointer to the allocated EAP state machine or %NULL on failure  *  * This function allocates and initializes an EAP state machine. In addition,  * this initializes TLS library for the new EAP state machine. eapol_cb pointer  * will be in use until eap_sm_deinit() is used to deinitialize this EAP state  * machine. Consequently, the caller must make sure that this data structure  * remains alive while the EAP state machine is active.  */
end_comment

begin_function
name|struct
name|eap_sm
modifier|*
name|eap_sm_init
parameter_list|(
name|void
modifier|*
name|eapol_ctx
parameter_list|,
name|struct
name|eapol_callbacks
modifier|*
name|eapol_cb
parameter_list|,
name|void
modifier|*
name|msg_ctx
parameter_list|,
name|struct
name|eap_config
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
decl_stmt|;
name|struct
name|tls_config
name|tlsconf
decl_stmt|;
name|sm
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sm
operator|->
name|eapol_ctx
operator|=
name|eapol_ctx
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|=
name|eapol_cb
expr_stmt|;
name|sm
operator|->
name|msg_ctx
operator|=
name|msg_ctx
expr_stmt|;
name|sm
operator|->
name|ClientTimeout
operator|=
literal|60
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|tlsconf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tlsconf
argument_list|)
argument_list|)
expr_stmt|;
name|tlsconf
operator|.
name|opensc_engine_path
operator|=
name|conf
operator|->
name|opensc_engine_path
expr_stmt|;
name|tlsconf
operator|.
name|pkcs11_engine_path
operator|=
name|conf
operator|->
name|pkcs11_engine_path
expr_stmt|;
name|tlsconf
operator|.
name|pkcs11_module_path
operator|=
name|conf
operator|->
name|pkcs11_module_path
expr_stmt|;
name|sm
operator|->
name|ssl_ctx
operator|=
name|tls_init
argument_list|(
operator|&
name|tlsconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ssl_ctx
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"SSL: Failed to initialize TLS "
literal|"context."
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|sm
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_deinit - Deinitialize and free an EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * This function deinitializes EAP state machine and frees all allocated  * resources.  */
end_comment

begin_function
name|void
name|eap_sm_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"EAP deinit"
argument_list|)
expr_stmt|;
name|eap_sm_abort
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|tls_deinit
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_step - Step EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * Returns: 1 if EAP state was changed or 0 if not  *  * This function advances EAP state machine to a new state to match with the  * current variables. This should be called whenever variables used by the EAP  * state machine have changed.  */
end_comment

begin_function
name|int
name|eap_sm_step
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|EAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
name|res
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sm
operator|->
name|changed
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_abort - Abort EAP authentication  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * Release system resources that have been allocated for the authentication  * session without fully deinitializing the EAP state machine.  */
end_comment

begin_function
name|void
name|eap_sm_abort
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|os_free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
comment|/* This is not clearly specified in the EAP statemachines draft, but 	 * it seems necessary to make sure that some of the EAPOL variables get 	 * cleared for the next authentication. */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
return|return
literal|"INITIALIZE"
return|;
case|case
name|EAP_DISABLED
case|:
return|return
literal|"DISABLED"
return|;
case|case
name|EAP_IDLE
case|:
return|return
literal|"IDLE"
return|;
case|case
name|EAP_RECEIVED
case|:
return|return
literal|"RECEIVED"
return|;
case|case
name|EAP_GET_METHOD
case|:
return|return
literal|"GET_METHOD"
return|;
case|case
name|EAP_METHOD
case|:
return|return
literal|"METHOD"
return|;
case|case
name|EAP_SEND_RESPONSE
case|:
return|return
literal|"SEND_RESPONSE"
return|;
case|case
name|EAP_DISCARD
case|:
return|return
literal|"DISCARD"
return|;
case|case
name|EAP_IDENTITY
case|:
return|return
literal|"IDENTITY"
return|;
case|case
name|EAP_NOTIFICATION
case|:
return|return
literal|"NOTIFICATION"
return|;
case|case
name|EAP_RETRANSMIT
case|:
return|return
literal|"RETRANSMIT"
return|;
case|case
name|EAP_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|EAP_FAILURE
case|:
return|return
literal|"FAILURE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|EapMethodState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|METHOD_NONE
case|:
return|return
literal|"NONE"
return|;
case|case
name|METHOD_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|METHOD_CONT
case|:
return|return
literal|"CONT"
return|;
case|case
name|METHOD_MAY_CONT
case|:
return|return
literal|"MAY_CONT"
return|;
case|case
name|METHOD_DONE
case|:
return|return
literal|"DONE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|EapDecision
name|decision
parameter_list|)
block|{
switch|switch
condition|(
name|decision
condition|)
block|{
case|case
name|DECISION_FAIL
case|:
return|return
literal|"FAIL"
return|;
case|case
name|DECISION_COND_SUCC
case|:
return|return
literal|"COND_SUCC"
return|;
case|case
name|DECISION_UNCOND_SUCC
case|:
return|return
literal|"UNCOND_SUCC"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE
end_ifdef

begin_comment
comment|/**  * eap_sm_get_status - Get EAP state machine status  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @buf: Buffer for status information  * @buflen: Maximum buffer length  * @verbose: Whether to include verbose status information  * Returns: Number of bytes written to buf.  *  * Query EAP state machine for status information. This function fills in a  * text area with current status information from the EAPOL state machine. If  * the buffer (buf) is not large enough, status information will be truncated  * to fit the buffer.  */
end_comment

begin_function
name|int
name|eap_sm_get_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|os_snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"EAP state=%s\n"
argument_list|,
name|eap_sm_state_txt
argument_list|(
name|sm
operator|->
name|EAP_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|len
operator|>=
name|buflen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|name
operator|=
name|sm
operator|->
name|m
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|eap_method
modifier|*
name|m
init|=
name|eap_sm_get_eap_methods
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|name
operator|=
name|m
operator|->
name|name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|ret
operator|=
name|os_snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"selectedMethod=%d (EAP-%s)\n"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|ret
operator|>=
name|buflen
operator|-
name|len
condition|)
return|return
name|len
return|;
name|len
operator|+=
name|ret
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_status
condition|)
block|{
name|len
operator|+=
name|sm
operator|->
name|m
operator|->
name|get_status
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|ret
operator|=
name|os_snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"reqMethod=%d\n"
literal|"methodState=%s\n"
literal|"decision=%s\n"
literal|"ClientTimeout=%d\n"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|sm
operator|->
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|sm
operator|->
name|decision
argument_list|)
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|ret
operator|>=
name|buflen
operator|-
name|len
condition|)
return|return
name|len
return|;
name|len
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
end_if

begin_typedef
typedef|typedef
enum|enum
block|{
name|TYPE_IDENTITY
block|,
name|TYPE_PASSWORD
block|,
name|TYPE_OTP
block|,
name|TYPE_PIN
block|,
name|TYPE_NEW_PASSWORD
block|,
name|TYPE_PASSPHRASE
block|}
name|eap_ctrl_req_type
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|eap_sm_request
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|eap_ctrl_req_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|config
operator|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_IDENTITY
case|:
name|field
operator|=
literal|"IDENTITY"
expr_stmt|;
name|txt
operator|=
literal|"Identity"
expr_stmt|;
name|config
operator|->
name|pending_req_identity
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_PASSWORD
case|:
name|field
operator|=
literal|"PASSWORD"
expr_stmt|;
name|txt
operator|=
literal|"Password"
expr_stmt|;
name|config
operator|->
name|pending_req_password
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_NEW_PASSWORD
case|:
name|field
operator|=
literal|"NEW_PASSWORD"
expr_stmt|;
name|txt
operator|=
literal|"New Password"
expr_stmt|;
name|config
operator|->
name|pending_req_new_password
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_PIN
case|:
name|field
operator|=
literal|"PIN"
expr_stmt|;
name|txt
operator|=
literal|"PIN"
expr_stmt|;
name|config
operator|->
name|pending_req_pin
operator|++
expr_stmt|;
break|break;
case|case
name|TYPE_OTP
case|:
name|field
operator|=
literal|"OTP"
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|tmp
operator|=
name|os_malloc
argument_list|(
name|msglen
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
name|os_memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|txt
operator|=
name|tmp
expr_stmt|;
name|os_free
argument_list|(
name|config
operator|->
name|pending_req_otp
argument_list|)
expr_stmt|;
name|config
operator|->
name|pending_req_otp
operator|=
name|tmp
expr_stmt|;
name|config
operator|->
name|pending_req_otp_len
operator|=
name|msglen
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config
operator|->
name|pending_req_otp
operator|==
name|NULL
condition|)
return|return;
name|txt
operator|=
name|config
operator|->
name|pending_req_otp
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_PASSPHRASE
case|:
name|field
operator|=
literal|"PASSPHRASE"
expr_stmt|;
name|txt
operator|=
literal|"Private key passphrase"
expr_stmt|;
name|config
operator|->
name|pending_req_passphrase
operator|++
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|buflen
operator|=
literal|100
operator|+
name|os_strlen
argument_list|(
name|txt
argument_list|)
operator|+
name|config
operator|->
name|ssid_len
expr_stmt|;
name|buf
operator|=
name|os_malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|os_snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|WPA_CTRL_REQ
literal|"%s-%d:%s needed for SSID "
argument_list|,
name|field
argument_list|,
name|config
operator|->
name|id
argument_list|,
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|len
operator|>=
name|buflen
condition|)
block|{
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|config
operator|->
name|ssid
operator|&&
name|buflen
operator|>
name|len
operator|+
name|config
operator|->
name|ssid_len
condition|)
block|{
name|os_memcpy
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|config
operator|->
name|ssid
argument_list|,
name|config
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|config
operator|->
name|ssid_len
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_define
define|#
directive|define
name|eap_sm_request
parameter_list|(
name|sm
parameter_list|,
name|type
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_comment
comment|/**  * eap_sm_request_identity - Request identity from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * EAP methods can call this function to request identity information for the  * current network. This is normally called when the identity is not included  * in the network configuration. The request will be sent to monitor programs  * through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|TYPE_IDENTITY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_password - Request password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * EAP methods can call this function to request password information for the  * current network. This is normally called when the password is not included  * in the network configuration. The request will be sent to monitor programs  * through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|TYPE_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_new_password - Request new password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * EAP methods can call this function to request new password information for  * the current network. This is normally called when the EAP method indicates  * that the current password has expired and password change is required. The  * request will be sent to monitor programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_new_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|TYPE_NEW_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_pin - Request SIM or smart card PIN from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * EAP methods can call this function to request SIM or smart card PIN  * information for the current network. This is normally called when the PIN is  * not included in the network configuration. The request will be sent to  * monitor programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_pin
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|TYPE_PIN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_otp - Request one time password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @msg: Message to be displayed to the user when asking for OTP  * @msg_len: Length of the user displayable message  *  * EAP methods can call this function to request open time password (OTP) for  * the current network. The request will be sent to monitor programs through  * the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msg_len
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|TYPE_OTP
argument_list|,
name|msg
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_passphrase - Request passphrase from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * EAP methods can call this function to request passphrase for a private key  * for the current network. This is normally called when the passphrase is not  * included in the network configuration. The request will be sent to monitor  * programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_passphrase
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|TYPE_PASSPHRASE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_notify_ctrl_attached - Notification of attached monitor  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * Notify EAP state machines that a monitor was attached to the control  * interface to trigger re-sending of pending requests for user input.  */
end_comment

begin_function
name|void
name|eap_sm_notify_ctrl_attached
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
comment|/* Re-send any pending requests for user data since a new control 	 * interface was added. This handles cases where the EAP authentication 	 * starts immediately after system startup when the user interface is 	 * not yet running. */
if|if
condition|(
name|config
operator|->
name|pending_req_identity
condition|)
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_password
condition|)
name|eap_sm_request_password
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_new_password
condition|)
name|eap_sm_request_new_password
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_otp
condition|)
name|eap_sm_request_otp
argument_list|(
name|sm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_pin
condition|)
name|eap_sm_request_pin
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_passphrase
condition|)
name|eap_sm_request_passphrase
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_allowed_phase2_type
parameter_list|(
name|int
name|vendor
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|vendor
operator|!=
name|EAP_VENDOR_IETF
condition|)
return|return
literal|0
return|;
return|return
name|type
operator|!=
name|EAP_TYPE_PEAP
operator|&&
name|type
operator|!=
name|EAP_TYPE_TTLS
operator|&&
name|type
operator|!=
name|EAP_TYPE_FAST
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_phase2_type - Get EAP type for the given EAP phase 2 method name  * @name: EAP method name, e.g., MD5  * @vendor: Buffer for returning EAP Vendor-Id  * Returns: EAP method type or %EAP_TYPE_NONE if not found  *  * This function maps EAP type names into EAP type numbers that are allowed for  * Phase 2, i.e., for tunneled authentication. Phase 2 is used, e.g., with  * EAP-PEAP, EAP-TTLS, and EAP-FAST.  */
end_comment

begin_function
name|u32
name|eap_get_phase2_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
name|u8
name|type
init|=
name|eap_get_type
argument_list|(
name|name
argument_list|,
operator|&
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|v
argument_list|,
name|type
argument_list|)
condition|)
block|{
operator|*
name|vendor
operator|=
name|v
expr_stmt|;
return|return
name|type
return|;
block|}
operator|*
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_phase2_types - Get list of allowed EAP phase 2 types  * @config: Pointer to a network configuration  * @count: Pointer to a variable to be filled with number of returned EAP types  * Returns: Pointer to allocated type list or %NULL on failure  *  * This function generates an array of allowed EAP phase 2 (tunneled) types for  * the given network configuration.  */
end_comment

begin_function
name|struct
name|eap_method_type
modifier|*
name|eap_get_phase2_types
parameter_list|(
name|struct
name|wpa_ssid
modifier|*
name|config
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|eap_method_type
modifier|*
name|buf
decl_stmt|;
name|u32
name|method
decl_stmt|;
name|int
name|vendor
decl_stmt|;
name|size_t
name|mcount
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|methods
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|methods
operator|=
name|eap_peer_get_methods
argument_list|(
operator|&
name|mcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|os_malloc
argument_list|(
name|mcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eap_method_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|m
operator|=
name|methods
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|vendor
operator|=
name|m
operator|->
name|vendor
expr_stmt|;
name|method
operator|=
name|m
operator|->
name|method
expr_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|vendor
argument_list|,
name|method
argument_list|)
condition|)
block|{
if|if
condition|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|method
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
name|config
operator|->
name|private_key2
operator|==
name|NULL
condition|)
continue|continue;
name|buf
index|[
operator|*
name|count
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
name|buf
index|[
operator|*
name|count
index|]
operator|.
name|method
operator|=
name|method
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/**  * eap_set_fast_reauth - Update fast_reauth setting  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @enabled: 1 = Fast reauthentication is enabled, 0 = Disabled  */
end_comment

begin_function
name|void
name|eap_set_fast_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|sm
operator|->
name|fast_reauth
operator|=
name|enabled
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_set_workaround - Update EAP workarounds setting  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @workaround: 1 = Enable EAP workarounds, 0 = Disable EAP workarounds  */
end_comment

begin_function
name|void
name|eap_set_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|unsigned
name|int
name|workaround
parameter_list|)
block|{
name|sm
operator|->
name|workaround
operator|=
name|workaround
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config - Get current network configuration  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * Returns: Pointer to the current network configuration or %NULL if not found  *  * EAP peer methods should avoid using this function if they can use other  * access functions, like eap_get_config_identity() and  * eap_get_config_password(), that do not require direct access to  * struct wpa_ssid.  */
end_comment

begin_function
name|struct
name|wpa_ssid
modifier|*
name|eap_get_config
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_password - Get identity from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Buffer for the length of the identity  * Returns: Pointer to the identity or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
return|return
name|config
operator|->
name|identity
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_password - Get password from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Buffer for the length of the password  * Returns: Pointer to the password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|password_len
expr_stmt|;
return|return
name|config
operator|->
name|password
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_new_password - Get new password from network configuration  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Buffer for the length of the new password  * Returns: Pointer to the new password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_new_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|new_password_len
expr_stmt|;
return|return
name|config
operator|->
name|new_password
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_otp - Get one-time password from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Buffer for the length of the one-time password  * Returns: Pointer to the one-time password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|otp_len
expr_stmt|;
return|return
name|config
operator|->
name|otp
return|;
block|}
end_function

begin_comment
comment|/**  * eap_clear_config_otp - Clear used one-time password  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * This function clears a used one-time password (OTP) from the current network  * configuration. This should be called when the OTP has been used and is not  * needed anymore.  */
end_comment

begin_function
name|void
name|eap_clear_config_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
name|os_memset
argument_list|(
name|config
operator|->
name|otp
argument_list|,
literal|0
argument_list|,
name|config
operator|->
name|otp_len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|config
operator|->
name|otp
argument_list|)
expr_stmt|;
name|config
operator|->
name|otp
operator|=
name|NULL
expr_stmt|;
name|config
operator|->
name|otp_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_key_available - Get key availability (eapKeyAvailable variable)  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * Returns: 1 if EAP keying material is available, 0 if not  */
end_comment

begin_function
name|int
name|eap_key_available
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
condition|?
name|sm
operator|->
name|eapKeyAvailable
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eap_notify_success - Notify EAP state machine about external success trigger  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * This function is called when external event, e.g., successful completion of  * WPA-PSK key handshake, is indicating that EAP state machine should move to  * success state. This is mainly used with security modes that do not use EAP  * state machine (e.g., WPA-PSK).  */
end_comment

begin_function
name|void
name|eap_notify_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
block|{
name|sm
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|sm
operator|->
name|EAP_state
operator|=
name|EAP_SUCCESS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_notify_lower_layer_success - Notification of lower layer success  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * Notify EAP state machines that a lower layer has detected a successful  * authentication. This is used to recover from dropped EAP-Success messages.  */
end_comment

begin_function
name|void
name|eap_notify_lower_layer_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|)
operator|||
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|||
operator|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_MAY_CONT
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
operator|)
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP authentication completed successfully (based on lower "
literal|"layer success)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapKeyData - Get master session key (MSK) from EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Pointer to variable that will be set to number of bytes in the key  * Returns: Pointer to the EAP keying data or %NULL on failure  *  * Fetch EAP keying material (MSK, eapKeyData) from the EAP state machine. The  * key is available only after a successful authentication. EAP state machine  * continues to manage the key data and the caller must not change or free the  * returned data.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_eapKeyData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapKeyData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|sm
operator|->
name|eapKeyDataLen
expr_stmt|;
return|return
name|sm
operator|->
name|eapKeyData
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapKeyData - Get EAP response data  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @len: Pointer to variable that will be set to the length of the response  * Returns: Pointer to the EAP response (eapRespData) or %NULL on failure  *  * Fetch EAP response (eapRespData) from the EAP state machine. This data is  * available when EAP state machine has processed an incoming EAP request. The  * EAP state machine does not maintain a reference to the response after this  * function is called and the caller is responsible for freeing the data.  */
end_comment

begin_function
name|u8
modifier|*
name|eap_get_eapRespData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|u8
modifier|*
name|resp
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapRespData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|resp
operator|=
name|sm
operator|->
name|eapRespData
expr_stmt|;
operator|*
name|len
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
literal|0
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_register_scard_ctx - Notification of smart card context  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @ctx: Context data for smart card operations  *  * Notify EAP state machines of context data for smart card operations. This  * context data will be used as a parameter for scard_*() functions.  */
end_comment

begin_function
name|void
name|eap_register_scard_ctx
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|sm
operator|->
name|scard_ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_hdr_validate - Validate EAP header  * @vendor: Expected EAP Vendor-Id (0 = IETF)  * @eap_type: Expected EAP type number  * @msg: EAP frame (starting with EAP header)  * @msglen: Length of msg  * @plen: Pointer to variable to contain the returned payload length  * Returns: Pointer to EAP payload (after type field), or %NULL on failure  *  * This is a helper function for EAP method implementations. This is usually  * called in the beginning of struct eap_method::process() function to verify  * that the received EAP request packet has a valid header. This function is  * able to process both legacy and expanded EAP headers and in most cases, the  * caller can just use the returned payload pointer (into *plen) for processing  * the payload regardless of whether the packet used the expanded EAP header or  * not.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_hdr_validate
parameter_list|(
name|int
name|vendor
parameter_list|,
name|EapType
name|eap_type
parameter_list|,
specifier|const
name|u8
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Too short EAP frame"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
operator|||
name|len
operator|>
name|msglen
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid EAP length"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
name|EAP_TYPE_EXPANDED
condition|)
block|{
name|int
name|exp_vendor
decl_stmt|;
name|u32
name|exp_type
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|8
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid expanded EAP "
literal|"length"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pos
operator|++
expr_stmt|;
name|exp_vendor
operator|=
name|WPA_GET_BE24
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|exp_type
operator|=
name|WPA_GET_BE32
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|exp_vendor
operator|!=
name|vendor
operator|||
name|exp_type
operator|!=
operator|(
name|u32
operator|)
name|eap_type
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid expanded frame "
literal|"type"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
literal|8
expr_stmt|;
return|return
name|pos
return|;
block|}
else|else
block|{
if|if
condition|(
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
operator|*
name|pos
operator|!=
name|eap_type
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid frame type"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|pos
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_set_config_blob - Set or add a named configuration blob  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @blob: New value for the blob  *  * Adds a new configuration blob or replaces the current value of an existing  * blob.  */
end_comment

begin_function
name|void
name|eap_set_config_blob
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_config_blob
modifier|*
name|blob
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_config_blob
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|blob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_blob - Get a named configuration blob  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @name: Name of the blob  * Returns: Pointer to blob data or %NULL if not found  */
end_comment

begin_function
specifier|const
name|struct
name|wpa_config_blob
modifier|*
name|eap_get_config_blob
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config_blob
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * eap_set_force_disabled - Set force_disabled flag  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  * @disabled: 1 = EAP disabled, 0 = EAP enabled  *  * This function is used to force EAP state machine to be disabled when it is  * not in use (e.g., with WPA-PSK or plaintext connections).  */
end_comment

begin_function
name|void
name|eap_set_force_disabled
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|disabled
parameter_list|)
block|{
name|sm
operator|->
name|force_disabled
operator|=
name|disabled
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_msg_alloc - Allocate a buffer for an EAP message  * @vendor: Vendor-Id (0 = IETF)  * @type: EAP type  * @len: Buffer for returning message length  * @payload_len: Payload length in bytes (data after Type)  * @code: Message Code (EAP_CODE_*)  * @identifier: Identifier  * @payload: Pointer to payload pointer that will be set to point to the  * beginning of the payload or %NULL if payload pointer is not needed  * Returns: Pointer to the allocated message buffer or %NULL on error  *  * This function can be used to allocate a buffer for an EAP message and fill  * in the EAP header. This function is automatically using expanded EAP header  * if the selected Vendor-Id is not IETF. In other words, most EAP methods do  * not need to separately select which header type to use when using this  * function to allocate the message buffers.  */
end_comment

begin_function
name|struct
name|eap_hdr
modifier|*
name|eap_msg_alloc
parameter_list|(
name|int
name|vendor
parameter_list|,
name|EapType
name|type
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|size_t
name|payload_len
parameter_list|,
name|u8
name|code
parameter_list|,
name|u8
name|identifier
parameter_list|,
name|u8
modifier|*
modifier|*
name|payload
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
operator|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
condition|?
literal|1
else|:
literal|8
operator|)
operator|+
name|payload_len
expr_stmt|;
name|hdr
operator|=
name|os_malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
condition|)
block|{
name|hdr
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|hdr
operator|->
name|identifier
operator|=
name|identifier
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
condition|)
block|{
operator|*
name|pos
operator|++
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_EXPANDED
expr_stmt|;
name|WPA_PUT_BE24
argument_list|(
name|pos
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|pos
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|payload
condition|)
operator|*
name|payload
operator|=
name|pos
expr_stmt|;
block|}
return|return
name|hdr
return|;
block|}
end_function

begin_comment
comment|/**  * eap_notify_pending - Notify that EAP method is ready to re-process a request  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  *  * An EAP method can perform a pending operation (e.g., to get a response from  * an external process). Once the response is available, this function can be  * used to request EAPOL state machine to retry delivering the previously  * received (and still unanswered) EAP request to EAP state machine.  */
end_comment

begin_function
name|void
name|eap_notify_pending
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|notify_pending
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_invalidate_cached_session - Mark cached session data invalid  * @sm: Pointer to EAP state machine allocated with eap_sm_init()  */
end_comment

begin_function
name|void
name|eap_invalidate_cached_session
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"invalidate"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

