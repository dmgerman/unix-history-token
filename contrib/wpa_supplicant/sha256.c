begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SHA-256 hash implementation and interface functions  * Copyright (c) 2003-2006, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"sha256.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_comment
comment|/**  * hmac_sha256_vector - HMAC-SHA256 over data vector (RFC 2104)  * @key: Key for HMAC operations  * @key_len: Length of the key in bytes  * @num_elem: Number of elements in the data vector  * @addr: Pointers to the data areas  * @len: Lengths of the data blocks  * @mac: Buffer for the hash (32 bytes)  */
end_comment

begin_function
name|void
name|hmac_sha256_vector
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
name|size_t
name|num_elem
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
index|[]
parameter_list|,
specifier|const
name|size_t
modifier|*
name|len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
name|unsigned
name|char
name|k_pad
index|[
literal|64
index|]
decl_stmt|;
comment|/* padding - key XORd with ipad/opad */
name|unsigned
name|char
name|tk
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|_addr
index|[
literal|6
index|]
decl_stmt|;
name|size_t
name|_len
index|[
literal|6
index|]
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|num_elem
operator|>
literal|5
condition|)
block|{
comment|/* 		 * Fixed limit on the number of fragments to avoid having to 		 * allocate memory (which could fail). 		 */
return|return;
block|}
comment|/* if key is longer than 64 bytes reset it to key = SHA256(key) */
if|if
condition|(
name|key_len
operator|>
literal|64
condition|)
block|{
name|sha256_vector
argument_list|(
literal|1
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|key_len
argument_list|,
name|tk
argument_list|)
expr_stmt|;
name|key
operator|=
name|tk
expr_stmt|;
name|key_len
operator|=
literal|32
expr_stmt|;
block|}
comment|/* the HMAC_SHA256 transform looks like: 	 * 	 * SHA256(K XOR opad, SHA256(K XOR ipad, text)) 	 * 	 * where K is an n byte key 	 * ipad is the byte 0x36 repeated 64 times 	 * opad is the byte 0x5c repeated 64 times 	 * and text is the data being protected */
comment|/* start out by storing key in ipad */
name|memset
argument_list|(
name|k_pad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|k_pad
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|k_pad
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* XOR key with ipad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|k_pad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
comment|/* perform inner SHA256 */
name|_addr
index|[
literal|0
index|]
operator|=
name|k_pad
expr_stmt|;
name|_len
index|[
literal|0
index|]
operator|=
literal|64
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elem
condition|;
name|i
operator|++
control|)
block|{
name|_addr
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|addr
index|[
name|i
index|]
expr_stmt|;
name|_len
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|len
index|[
name|i
index|]
expr_stmt|;
block|}
name|sha256_vector
argument_list|(
literal|1
operator|+
name|num_elem
argument_list|,
name|_addr
argument_list|,
name|_len
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|k_pad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|k_pad
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|k_pad
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* XOR key with opad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|k_pad
index|[
name|i
index|]
operator|^=
literal|0x5c
expr_stmt|;
comment|/* perform outer SHA256 */
name|_addr
index|[
literal|0
index|]
operator|=
name|k_pad
expr_stmt|;
name|_len
index|[
literal|0
index|]
operator|=
literal|64
expr_stmt|;
name|_addr
index|[
literal|1
index|]
operator|=
name|mac
expr_stmt|;
name|_len
index|[
literal|1
index|]
operator|=
name|SHA256_MAC_LEN
expr_stmt|;
name|sha256_vector
argument_list|(
literal|2
argument_list|,
name|_addr
argument_list|,
name|_len
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * hmac_sha256 - HMAC-SHA256 over data buffer (RFC 2104)  * @key: Key for HMAC operations  * @key_len: Length of the key in bytes  * @data: Pointers to the data area  * @data_len: Length of the data area  * @mac: Buffer for the hash (20 bytes)  */
end_comment

begin_function
name|void
name|hmac_sha256
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
name|hmac_sha256_vector
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|data_len
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * sha256_prf - SHA256-based Pseudo-Random Function (IEEE 802.11r, 8.5A.3)  * @key: Key for PRF  * @key_len: Length of the key in bytes  * @label: A unique label for each purpose of the PRF  * @data: Extra data to bind into the key  * @data_len: Length of the data  * @buf: Buffer for the generated pseudo-random key  * @buf_len: Number of bytes of key to generate  *  * This function is used to derive new, cryptographically separate keys from a  * given key.  */
end_comment

begin_function
name|void
name|sha256_prf
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|buf_len
parameter_list|)
block|{
name|u16
name|counter
init|=
literal|0
decl_stmt|;
name|size_t
name|pos
decl_stmt|,
name|plen
decl_stmt|;
name|u8
name|hash
index|[
name|SHA256_MAC_LEN
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|addr
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|len
index|[
literal|3
index|]
decl_stmt|;
name|u8
name|counter_le
index|[
literal|2
index|]
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
name|counter_le
expr_stmt|;
name|len
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|u8
operator|*
operator|)
name|label
expr_stmt|;
name|len
index|[
literal|1
index|]
operator|=
name|strlen
argument_list|(
name|label
argument_list|)
operator|+
literal|1
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
name|data
expr_stmt|;
name|len
index|[
literal|2
index|]
operator|=
name|data_len
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|buf_len
condition|)
block|{
name|plen
operator|=
name|buf_len
operator|-
name|pos
expr_stmt|;
name|WPA_PUT_LE16
argument_list|(
name|counter_le
argument_list|,
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>=
name|SHA256_MAC_LEN
condition|)
block|{
name|hmac_sha256_vector
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
literal|3
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
operator|&
name|buf
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|SHA256_MAC_LEN
expr_stmt|;
block|}
else|else
block|{
name|hmac_sha256_vector
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
literal|3
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
name|pos
index|]
argument_list|,
name|hash
argument_list|,
name|plen
argument_list|)
expr_stmt|;
break|break;
block|}
name|counter
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNAL_SHA256
end_ifdef

begin_struct
struct|struct
name|sha256_state
block|{
name|u64
name|length
decl_stmt|;
name|u32
name|state
index|[
literal|8
index|]
decl_stmt|,
name|curlen
decl_stmt|;
name|u8
name|buf
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|sha256_init
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sha256_process
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|long
name|inlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sha256_done
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * sha256_vector - SHA256 hash for data vector  * @num_elem: Number of elements in the data vector  * @addr: Pointers to the data areas  * @len: Lengths of the data blocks  * @mac: Buffer for the hash  */
end_comment

begin_function
name|void
name|sha256_vector
parameter_list|(
name|size_t
name|num_elem
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
index|[]
parameter_list|,
specifier|const
name|size_t
modifier|*
name|len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|sha256_state
name|ctx
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|sha256_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elem
condition|;
name|i
operator|++
control|)
name|sha256_process
argument_list|(
operator|&
name|ctx
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|,
name|len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sha256_done
argument_list|(
operator|&
name|ctx
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===== start - public domain SHA256 implementation ===== */
end_comment

begin_comment
comment|/* This is based on SHA256 implementation in LibTomCrypt that was released into  * public domain by Tom St Denis. */
end_comment

begin_comment
comment|/* the K array */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|K
index|[
literal|64
index|]
init|=
block|{
literal|0x428a2f98UL
block|,
literal|0x71374491UL
block|,
literal|0xb5c0fbcfUL
block|,
literal|0xe9b5dba5UL
block|,
literal|0x3956c25bUL
block|,
literal|0x59f111f1UL
block|,
literal|0x923f82a4UL
block|,
literal|0xab1c5ed5UL
block|,
literal|0xd807aa98UL
block|,
literal|0x12835b01UL
block|,
literal|0x243185beUL
block|,
literal|0x550c7dc3UL
block|,
literal|0x72be5d74UL
block|,
literal|0x80deb1feUL
block|,
literal|0x9bdc06a7UL
block|,
literal|0xc19bf174UL
block|,
literal|0xe49b69c1UL
block|,
literal|0xefbe4786UL
block|,
literal|0x0fc19dc6UL
block|,
literal|0x240ca1ccUL
block|,
literal|0x2de92c6fUL
block|,
literal|0x4a7484aaUL
block|,
literal|0x5cb0a9dcUL
block|,
literal|0x76f988daUL
block|,
literal|0x983e5152UL
block|,
literal|0xa831c66dUL
block|,
literal|0xb00327c8UL
block|,
literal|0xbf597fc7UL
block|,
literal|0xc6e00bf3UL
block|,
literal|0xd5a79147UL
block|,
literal|0x06ca6351UL
block|,
literal|0x14292967UL
block|,
literal|0x27b70a85UL
block|,
literal|0x2e1b2138UL
block|,
literal|0x4d2c6dfcUL
block|,
literal|0x53380d13UL
block|,
literal|0x650a7354UL
block|,
literal|0x766a0abbUL
block|,
literal|0x81c2c92eUL
block|,
literal|0x92722c85UL
block|,
literal|0xa2bfe8a1UL
block|,
literal|0xa81a664bUL
block|,
literal|0xc24b8b70UL
block|,
literal|0xc76c51a3UL
block|,
literal|0xd192e819UL
block|,
literal|0xd6990624UL
block|,
literal|0xf40e3585UL
block|,
literal|0x106aa070UL
block|,
literal|0x19a4c116UL
block|,
literal|0x1e376c08UL
block|,
literal|0x2748774cUL
block|,
literal|0x34b0bcb5UL
block|,
literal|0x391c0cb3UL
block|,
literal|0x4ed8aa4aUL
block|,
literal|0x5b9cca4fUL
block|,
literal|0x682e6ff3UL
block|,
literal|0x748f82eeUL
block|,
literal|0x78a5636fUL
block|,
literal|0x84c87814UL
block|,
literal|0x8cc70208UL
block|,
literal|0x90befffaUL
block|,
literal|0xa4506cebUL
block|,
literal|0xbef9a3f7UL
block|,
literal|0xc67178f2UL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various logical functions */
end_comment

begin_define
define|#
directive|define
name|RORc
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|( ((((unsigned long) (x)& 0xFFFFFFFFUL)>> (unsigned long) ((y)& 31)) | \    ((unsigned long) (x)<< (unsigned long) (32 - ((y)& 31))))& 0xFFFFFFFFUL)
end_define

begin_define
define|#
directive|define
name|Ch
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(z ^ (x& (y ^ z)))
end_define

begin_define
define|#
directive|define
name|Maj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x | y)& z) | (x& y))
end_define

begin_define
define|#
directive|define
name|S
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|RORc((x), (n))
end_define

begin_define
define|#
directive|define
name|R
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)&0xFFFFFFFFUL)>>(n))
end_define

begin_define
define|#
directive|define
name|Sigma0
parameter_list|(
name|x
parameter_list|)
value|(S(x, 2) ^ S(x, 13) ^ S(x, 22))
end_define

begin_define
define|#
directive|define
name|Sigma1
parameter_list|(
name|x
parameter_list|)
value|(S(x, 6) ^ S(x, 11) ^ S(x, 25))
end_define

begin_define
define|#
directive|define
name|Gamma0
parameter_list|(
name|x
parameter_list|)
value|(S(x, 7) ^ S(x, 18) ^ R(x, 3))
end_define

begin_define
define|#
directive|define
name|Gamma1
parameter_list|(
name|x
parameter_list|)
value|(S(x, 17) ^ S(x, 19) ^ R(x, 10))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)< (y)) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* compress 512-bits */
end_comment

begin_function
specifier|static
name|int
name|sha256_compress
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|S
index|[
literal|8
index|]
decl_stmt|,
name|W
index|[
literal|64
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|;
name|u32
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* copy state into S */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|S
index|[
name|i
index|]
operator|=
name|md
operator|->
name|state
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* copy the state into 512-bits into W[0..15] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|W
index|[
name|i
index|]
operator|=
name|WPA_GET_BE32
argument_list|(
name|buf
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* fill W[16..63] */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|W
index|[
name|i
index|]
operator|=
name|Gamma1
argument_list|(
name|W
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
operator|+
name|W
index|[
name|i
operator|-
literal|7
index|]
operator|+
name|Gamma0
argument_list|(
name|W
index|[
name|i
operator|-
literal|15
index|]
argument_list|)
operator|+
name|W
index|[
name|i
operator|-
literal|16
index|]
expr_stmt|;
block|}
comment|/* Compress */
define|#
directive|define
name|RND
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|,
name|i
parameter_list|)
define|\
value|t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\ 	t1 = Sigma0(a) + Maj(a, b, c);			\ 	d += t0;					\ 	h  = t0 + t1;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
block|{
name|RND
argument_list|(
name|S
index|[
literal|0
index|]
argument_list|,
name|S
index|[
literal|1
index|]
argument_list|,
name|S
index|[
literal|2
index|]
argument_list|,
name|S
index|[
literal|3
index|]
argument_list|,
name|S
index|[
literal|4
index|]
argument_list|,
name|S
index|[
literal|5
index|]
argument_list|,
name|S
index|[
literal|6
index|]
argument_list|,
name|S
index|[
literal|7
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|S
index|[
literal|7
index|]
expr_stmt|;
name|S
index|[
literal|7
index|]
operator|=
name|S
index|[
literal|6
index|]
expr_stmt|;
name|S
index|[
literal|6
index|]
operator|=
name|S
index|[
literal|5
index|]
expr_stmt|;
name|S
index|[
literal|5
index|]
operator|=
name|S
index|[
literal|4
index|]
expr_stmt|;
name|S
index|[
literal|4
index|]
operator|=
name|S
index|[
literal|3
index|]
expr_stmt|;
name|S
index|[
literal|3
index|]
operator|=
name|S
index|[
literal|2
index|]
expr_stmt|;
name|S
index|[
literal|2
index|]
operator|=
name|S
index|[
literal|1
index|]
expr_stmt|;
name|S
index|[
literal|1
index|]
operator|=
name|S
index|[
literal|0
index|]
expr_stmt|;
name|S
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
block|}
comment|/* feedback */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|->
name|state
index|[
name|i
index|]
operator|=
name|md
operator|->
name|state
index|[
name|i
index|]
operator|+
name|S
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize the hash state */
end_comment

begin_function
specifier|static
name|void
name|sha256_init
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|)
block|{
name|md
operator|->
name|curlen
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|0
index|]
operator|=
literal|0x6A09E667UL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|1
index|]
operator|=
literal|0xBB67AE85UL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|2
index|]
operator|=
literal|0x3C6EF372UL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|3
index|]
operator|=
literal|0xA54FF53AUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|4
index|]
operator|=
literal|0x510E527FUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|5
index|]
operator|=
literal|0x9B05688CUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|6
index|]
operator|=
literal|0x1F83D9ABUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|7
index|]
operator|=
literal|0x5BE0CD19UL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    Process a block of memory though the hash    @param md     The hash state    @param in     The data to hash    @param inlen  The length of the data (octets)    @return CRYPT_OK if successful */
end_comment

begin_function
specifier|static
name|int
name|sha256_process
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|long
name|inlen
parameter_list|)
block|{
name|unsigned
name|long
name|n
decl_stmt|;
define|#
directive|define
name|block_size
value|64
if|if
condition|(
name|md
operator|->
name|curlen
operator|>
sizeof|sizeof
argument_list|(
name|md
operator|->
name|buf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|inlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|curlen
operator|==
literal|0
operator|&&
name|inlen
operator|>=
name|block_size
condition|)
block|{
if|if
condition|(
name|sha256_compress
argument_list|(
name|md
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|md
operator|->
name|length
operator|+=
name|block_size
operator|*
literal|8
expr_stmt|;
name|in
operator|+=
name|block_size
expr_stmt|;
name|inlen
operator|-=
name|block_size
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|MIN
argument_list|(
name|inlen
argument_list|,
operator|(
name|block_size
operator|-
name|md
operator|->
name|curlen
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|md
operator|->
name|buf
operator|+
name|md
operator|->
name|curlen
argument_list|,
name|in
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|md
operator|->
name|curlen
operator|+=
name|n
expr_stmt|;
name|in
operator|+=
name|n
expr_stmt|;
name|inlen
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|curlen
operator|==
name|block_size
condition|)
block|{
if|if
condition|(
name|sha256_compress
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|md
operator|->
name|length
operator|+=
literal|8
operator|*
name|block_size
expr_stmt|;
name|md
operator|->
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**    Terminate the hash to get the digest    @param md  The hash state    @param out [out] The destination of the hash (32 bytes)    @return CRYPT_OK if successful */
end_comment

begin_function
specifier|static
name|int
name|sha256_done
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|md
operator|->
name|curlen
operator|>=
sizeof|sizeof
argument_list|(
name|md
operator|->
name|buf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* increase the length of the message */
name|md
operator|->
name|length
operator|+=
name|md
operator|->
name|curlen
operator|*
literal|8
expr_stmt|;
comment|/* append the '1' bit */
name|md
operator|->
name|buf
index|[
name|md
operator|->
name|curlen
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0x80
expr_stmt|;
comment|/* if the length is currently above 56 bytes we append zeros 	 * then compress.  Then we can fall back to padding zeros and length 	 * encoding like normal. 	 */
if|if
condition|(
name|md
operator|->
name|curlen
operator|>
literal|56
condition|)
block|{
while|while
condition|(
name|md
operator|->
name|curlen
operator|<
literal|64
condition|)
block|{
name|md
operator|->
name|buf
index|[
name|md
operator|->
name|curlen
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0
expr_stmt|;
block|}
name|sha256_compress
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|buf
argument_list|)
expr_stmt|;
name|md
operator|->
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* pad upto 56 bytes of zeroes */
while|while
condition|(
name|md
operator|->
name|curlen
operator|<
literal|56
condition|)
block|{
name|md
operator|->
name|buf
index|[
name|md
operator|->
name|curlen
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0
expr_stmt|;
block|}
comment|/* store length */
name|WPA_PUT_BE64
argument_list|(
name|md
operator|->
name|buf
operator|+
literal|56
argument_list|,
name|md
operator|->
name|length
argument_list|)
expr_stmt|;
name|sha256_compress
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|buf
argument_list|)
expr_stmt|;
comment|/* copy output */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|WPA_PUT_BE32
argument_list|(
name|out
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|,
name|md
operator|->
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ===== end - public domain SHA256 implementation ===== */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTERNAL_SHA256 */
end_comment

end_unit

