begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / dbus-based control interface  * Copyright (c) 2006, Dan Williams<dcbw@redhat.com> and Red Hat, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<dbus/dbus.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"wpa.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"eapol_sm.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant_i.h"
end_include

begin_include
include|#
directive|include
file|"ctrl_iface_dbus.h"
end_include

begin_include
include|#
directive|include
file|"ctrl_iface_dbus_handlers.h"
end_include

begin_include
include|#
directive|include
file|"l2_packet.h"
end_include

begin_include
include|#
directive|include
file|"preauth.h"
end_include

begin_include
include|#
directive|include
file|"wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"eap.h"
end_include

begin_struct
struct|struct
name|ctrl_iface_dbus_priv
block|{
name|DBusConnection
modifier|*
name|con
decl_stmt|;
name|int
name|should_dispatch
decl_stmt|;
name|struct
name|wpa_global
modifier|*
name|global
decl_stmt|;
name|u32
name|next_objid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|process_watch
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|eloop_event_type
name|type
parameter_list|)
block|{
name|dbus_connection_ref
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
name|iface
operator|->
name|should_dispatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_READ
condition|)
name|dbus_watch_handle
argument_list|(
name|watch
argument_list|,
name|DBUS_WATCH_READABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_WRITE
condition|)
name|dbus_watch_handle
argument_list|(
name|watch
argument_list|,
name|DBUS_WATCH_WRITABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_EXCEPTION
condition|)
name|dbus_watch_handle
argument_list|(
name|watch
argument_list|,
name|DBUS_WATCH_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|should_dispatch
condition|)
block|{
while|while
condition|(
name|dbus_connection_get_dispatch_status
argument_list|(
name|iface
operator|->
name|con
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
name|dbus_connection_dispatch
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
name|iface
operator|->
name|should_dispatch
operator|=
literal|0
expr_stmt|;
block|}
name|dbus_connection_unref
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch_exception
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|process_watch
argument_list|(
name|eloop_ctx
argument_list|,
name|sock_ctx
argument_list|,
name|EVENT_TYPE_EXCEPTION
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch_read
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|process_watch
argument_list|(
name|eloop_ctx
argument_list|,
name|sock_ctx
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch_write
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|process_watch
argument_list|(
name|eloop_ctx
argument_list|,
name|sock_ctx
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connection_setup_add_watch
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
condition|)
return|return;
name|flags
operator|=
name|dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|fd
operator|=
name|dbus_watch_get_fd
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|eloop_register_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_EXCEPTION
argument_list|,
name|process_watch_exception
argument_list|,
name|iface
argument_list|,
name|watch
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
condition|)
block|{
name|eloop_register_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_READ
argument_list|,
name|process_watch_read
argument_list|,
name|iface
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
condition|)
block|{
name|eloop_register_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|,
name|process_watch_write
argument_list|,
name|iface
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
name|dbus_watch_set_data
argument_list|(
name|watch
argument_list|,
name|iface
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connection_setup_remove_watch
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|flags
operator|=
name|dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|fd
operator|=
name|dbus_watch_get_fd
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|eloop_unregister_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_EXCEPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
condition|)
name|eloop_unregister_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
condition|)
name|eloop_unregister_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|)
expr_stmt|;
name|dbus_watch_set_data
argument_list|(
name|watch
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dbus_bool_t
name|add_watch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|connection_setup_add_watch
argument_list|(
name|data
argument_list|,
name|watch
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_watch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|connection_setup_remove_watch
argument_list|(
name|data
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|watch_toggled
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
condition|)
name|add_watch
argument_list|(
name|watch
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|remove_watch
argument_list|(
name|watch
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|DBusTimeout
modifier|*
name|timeout
init|=
name|sock_ctx
decl_stmt|;
name|dbus_timeout_handle
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connection_setup_add_timeout
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|,
name|DBusTimeout
modifier|*
name|timeout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
condition|)
return|return;
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
name|dbus_timeout_get_interval
argument_list|(
name|timeout
argument_list|)
operator|*
literal|1000
argument_list|,
name|process_timeout
argument_list|,
name|iface
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dbus_timeout_set_data
argument_list|(
name|timeout
argument_list|,
name|iface
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connection_setup_remove_timeout
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|,
name|DBusTimeout
modifier|*
name|timeout
parameter_list|)
block|{
name|eloop_cancel_timeout
argument_list|(
name|process_timeout
argument_list|,
name|iface
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dbus_timeout_set_data
argument_list|(
name|timeout
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dbus_bool_t
name|add_timeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|connection_setup_add_timeout
argument_list|(
name|data
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_timeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|connection_setup_remove_timeout
argument_list|(
name|data
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_toggled
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
condition|)
name|add_timeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|remove_timeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_wakeup_main
parameter_list|(
name|int
name|sig
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|signal_ctx
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
init|=
name|signal_ctx
decl_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGPOLL
operator|||
operator|!
name|iface
operator|->
name|con
condition|)
return|return;
if|if
condition|(
name|dbus_connection_get_dispatch_status
argument_list|(
name|iface
operator|->
name|con
argument_list|)
operator|!=
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
return|return;
comment|/* Only dispatch once - we do not want to starve other events */
name|dbus_connection_ref
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
name|dbus_connection_dispatch
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
name|dbus_connection_unref
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wakeup_main - Attempt to wake our mainloop up  * @data: dbus control interface private data  *  * Try to wake up the main eloop so it will process  * dbus events that may have happened.  */
end_comment

begin_function
specifier|static
name|void
name|wakeup_main
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
init|=
name|data
decl_stmt|;
comment|/* Use SIGPOLL to break out of the eloop select() */
name|raise
argument_list|(
name|SIGPOLL
argument_list|)
expr_stmt|;
name|iface
operator|->
name|should_dispatch
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * connection_setup_wakeup_main - Tell dbus about our wakeup_main function  * @iface: dbus control interface private data  * Returns: 0 on success, -1 on failure  *  * Register our wakeup_main handler with dbus  */
end_comment

begin_function
specifier|static
name|int
name|connection_setup_wakeup_main
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|)
block|{
if|if
condition|(
name|eloop_register_signal
argument_list|(
name|SIGPOLL
argument_list|,
name|process_wakeup_main
argument_list|,
name|iface
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|dbus_connection_set_wakeup_main_function
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|wakeup_main
argument_list|,
name|iface
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_next_objid - Return next available object id  * @iface: dbus control interface private data  * Returns: Object id  */
end_comment

begin_function
name|u32
name|wpa_supplicant_dbus_next_objid
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|)
block|{
return|return
name|iface
operator|->
name|next_objid
operator|++
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_decompose_object_path - Decompose an interface object path into parts  * @path: The dbus object path  * @network: (out) the configured network this object path refers to, if any  * @bssid: (out) the scanned bssid this object path refers to, if any  * Returns: The object path of the network interface this path refers to  *  * For a given object path, decomposes the object path into object id, network,  * and BSSID parts, if those parts exist.  */
end_comment

begin_function
name|char
modifier|*
name|wpas_dbus_decompose_object_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|network
parameter_list|,
name|char
modifier|*
modifier|*
name|bssid
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|dev_path_prefix_len
init|=
name|strlen
argument_list|(
name|WPAS_DBUS_PATH_INTERFACES
literal|"/"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|obj_path_only
decl_stmt|;
name|char
modifier|*
name|next_sep
decl_stmt|;
comment|/* Be a bit paranoid about path */
if|if
condition|(
operator|!
name|path
operator|||
name|strncmp
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_PATH_INTERFACES
literal|"/"
argument_list|,
name|dev_path_prefix_len
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Ensure there's something at the end of the path */
if|if
condition|(
operator|(
name|path
operator|+
name|dev_path_prefix_len
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|obj_path_only
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_path_only
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|next_sep
operator|=
name|strchr
argument_list|(
name|obj_path_only
operator|+
name|dev_path_prefix_len
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_sep
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|net_part
init|=
name|strstr
argument_list|(
name|next_sep
argument_list|,
name|WPAS_DBUS_NETWORKS_PART
literal|"/"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|bssid_part
init|=
name|strstr
argument_list|(
name|next_sep
argument_list|,
name|WPAS_DBUS_BSSIDS_PART
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|network
operator|&&
name|net_part
condition|)
block|{
comment|/* Deal with a request for a configured network */
specifier|const
name|char
modifier|*
name|net_name
init|=
name|net_part
operator|+
name|strlen
argument_list|(
name|WPAS_DBUS_NETWORKS_PART
literal|"/"
argument_list|)
decl_stmt|;
operator|*
name|network
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|net_name
argument_list|)
condition|)
operator|*
name|network
operator|=
name|strdup
argument_list|(
name|net_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bssid
operator|&&
name|bssid_part
condition|)
block|{
comment|/* Deal with a request for a scanned BSSID */
specifier|const
name|char
modifier|*
name|bssid_name
init|=
name|bssid_part
operator|+
name|strlen
argument_list|(
name|WPAS_DBUS_BSSIDS_PART
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|bssid_name
argument_list|)
condition|)
operator|*
name|bssid
operator|=
name|strdup
argument_list|(
name|bssid_name
argument_list|)
expr_stmt|;
else|else
operator|*
name|bssid
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Cut off interface object path before "/" */
operator|*
name|next_sep
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|obj_path_only
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_invalid_iface_error - Return a new invalid interface error message  * @message: Pointer to incoming dbus message this error refers to  * Returns: A dbus error message  *  * Convenience function to create and return an invalid interface error  */
end_comment

begin_function
name|DBusMessage
modifier|*
name|wpas_dbus_new_invalid_iface_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|WPAS_ERROR_INVALID_IFACE
argument_list|,
literal|"wpa_supplicant knows nothing about "
literal|"this interface."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_invalid_network_error - Return a new invalid network error message  * @message: Pointer to incoming dbus message this error refers to  * Returns: a dbus error message  *  * Convenience function to create and return an invalid network error  */
end_comment

begin_function
name|DBusMessage
modifier|*
name|wpas_dbus_new_invalid_network_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|WPAS_ERROR_INVALID_NETWORK
argument_list|,
literal|"The requested network does not exist."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_invalid_bssid_error - Return a new invalid bssid error message  * @message: Pointer to incoming dbus message this error refers to  * Returns: a dbus error message  *  * Convenience function to create and return an invalid bssid error  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|wpas_dbus_new_invalid_bssid_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|WPAS_ERROR_INVALID_BSSID
argument_list|,
literal|"The BSSID requested was invalid."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dispatch_network_method - dispatch messages for configured networks  * @message: the incoming dbus message  * @wpa_s: a network interface's data  * @network_id: id of the configured network we're interested in  * Returns: a reply dbus message, or a dbus error message  *  * This function dispatches all incoming dbus messages for configured networks.  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|wpas_dispatch_network_method
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|network_id
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
init|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|ssid
operator|=
name|wpa_config_get_network
argument_list|(
name|wpa_s
operator|->
name|conf
argument_list|,
name|network_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssid
operator|==
name|NULL
condition|)
return|return
name|wpas_dbus_new_invalid_network_error
argument_list|(
name|message
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"set"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_set_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"enable"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_enable_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"disable"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_disable_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dispatch_bssid_method - dispatch messages for scanned networks  * @message: the incoming dbus message  * @wpa_s: a network interface's data  * @bssid: bssid of the scanned network we're interested in  * Returns: a reply dbus message, or a dbus error message  *  * This function dispatches all incoming dbus messages for scanned networks.  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|wpas_dispatch_bssid_method
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|char
modifier|*
name|bssid
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
init|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|struct
name|wpa_scan_result
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Ensure we actually have scan data */
if|if
condition|(
name|wpa_s
operator|->
name|scan_results
operator|==
name|NULL
operator|&&
name|wpa_supplicant_get_scan_results
argument_list|(
name|wpa_s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_new_invalid_bssid_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Find the bssid's scan data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpa_s
operator|->
name|num_scan_results
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpa_scan_result
modifier|*
name|search_res
init|=
operator|&
name|wpa_s
operator|->
name|scan_results
index|[
name|i
index|]
decl_stmt|;
name|char
name|mac_str
index|[
literal|18
index|]
decl_stmt|;
name|memset
argument_list|(
name|mac_str
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mac_str
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mac_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mac_str
argument_list|)
operator|-
literal|1
argument_list|,
name|WPAS_DBUS_BSSID_FORMAT
argument_list|,
name|MAC2STR
argument_list|(
name|search_res
operator|->
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bssid
argument_list|,
name|mac_str
argument_list|)
condition|)
block|{
name|res
operator|=
name|search_res
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_new_invalid_bssid_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Dispatch the method call against the scanned bssid */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"properties"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_bssid_properties
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|reply
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_iface_message_handler - Dispatch messages for interfaces or networks  * @connection: Connection to the system message bus  * @message: An incoming dbus message  * @user_data: A pointer to a dbus control interface data structure  * Returns: Whether or not the message was handled  *  * This function dispatches all incoming dbus messages for network interfaces,  * or objects owned by them, such as scanned BSSIDs and configured networks.  */
end_comment

begin_function
specifier|static
name|DBusHandlerResult
name|wpas_iface_message_handler
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
init|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
init|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|char
modifier|*
name|iface_obj_path
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|network
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|bssid
init|=
name|NULL
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
comment|/* Caller must specify a message interface */
if|if
condition|(
operator|!
name|msg_interface
condition|)
goto|goto
name|out
goto|;
name|iface_obj_path
operator|=
name|wpas_dbus_decompose_object_path
argument_list|(
name|path
argument_list|,
operator|&
name|network
argument_list|,
operator|&
name|bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface_obj_path
operator|==
name|NULL
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_new_invalid_iface_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Make sure the message's object path actually refers to the 	 * wpa_supplicant structure it's supposed to (which is wpa_s) 	 */
if|if
condition|(
name|wpa_supplicant_get_iface_by_dbus_path
argument_list|(
name|wpa_s
operator|->
name|global
argument_list|,
name|iface_obj_path
argument_list|)
operator|!=
name|wpa_s
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_new_invalid_iface_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|network
operator|&&
operator|!
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_IFACE_NETWORK
argument_list|)
condition|)
block|{
comment|/* A method for one of this interface's configured networks */
name|int
name|nid
init|=
name|strtoul
argument_list|(
name|network
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
name|reply
operator|=
name|wpas_dispatch_network_method
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|nid
argument_list|)
expr_stmt|;
else|else
name|reply
operator|=
name|wpas_dbus_new_invalid_network_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bssid
operator|&&
operator|!
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_IFACE_BSSID
argument_list|)
condition|)
block|{
comment|/* A method for one of this interface's scanned BSSIDs */
name|reply
operator|=
name|wpas_dispatch_bssid_method
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|)
condition|)
block|{
comment|/* A method for an interface only. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"scan"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_scan
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"scanResults"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_scan_results
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"addNetwork"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_add_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"removeNetwork"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_remove_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"selectNetwork"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_select_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"capabilities"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_capabilities
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"disconnect"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_disconnect
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"setAPScan"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_set_ap_scan
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"state"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_get_state
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
block|}
comment|/* If the message was handled, send back the reply */
if|if
condition|(
name|reply
condition|)
block|{
name|dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|reply
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|iface_obj_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|network
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bssid
argument_list|)
expr_stmt|;
return|return
name|reply
condition|?
name|DBUS_HANDLER_RESULT_HANDLED
else|:
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_message_handler - dispatch incoming dbus messages  * @connection: connection to the system message bus  * @message: an incoming dbus message  * @user_data: a pointer to a dbus control interface data structure  * Returns: whether or not the message was handled  *  * This function dispatches all incoming dbus messages to the correct  * handlers, depending on what the message's target object path is,  * and what the method call is.  */
end_comment

begin_function
specifier|static
name|DBusHandlerResult
name|wpas_message_handler
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|ctrl_iface
init|=
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|path
operator|=
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|msg_interface
operator|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method
operator|||
operator|!
name|path
operator|||
operator|!
name|ctrl_iface
operator|||
operator|!
name|msg_interface
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
comment|/* Validate the method interface */
if|if
condition|(
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_PATH
argument_list|)
condition|)
block|{
comment|/* dispatch methods against our global dbus interface here */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"addInterface"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_add_interface
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"removeInterface"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_remove_interface
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"getInterface"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_get_interface
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the message was handled, send back the reply */
if|if
condition|(
name|reply
condition|)
block|{
name|dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|reply
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
return|return
name|reply
condition|?
name|DBUS_HANDLER_RESULT_HANDLED
else|:
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_notify_scan_results - Send a scan results signal  * @wpa_s: %wpa_supplicant network interface data  * Returns: 0 on success, -1 on failure  *  * Notify listeners that this interface has updated scan results.  */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_notify_scan_results
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
init|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus_ctrl_iface
decl_stmt|;
name|DBusMessage
modifier|*
name|signal
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
name|path
operator|=
name|wpa_supplicant_get_dbus_path
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"wpa_supplicant_dbus_notify_scan_results[dbus]: "
literal|"interface didn't have a dbus path"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"wpa_supplicant_dbus_notify_scan_results[dbus]: "
literal|"interface didn't have a dbus path; can't send "
literal|"scan result signal."
argument_list|)
expr_stmt|;
return|return;
block|}
name|signal
operator|=
name|dbus_message_new_signal
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|,
literal|"ScanResultsAvailable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"wpa_supplicant_dbus_notify_scan_results[dbus]: "
literal|"couldn't create dbus signal; likely out of memory"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus control interface: not enough "
literal|"memory to send scan results signal."
argument_list|)
expr_stmt|;
return|return;
block|}
name|dbus_connection_send
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|signal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_notify_state_change - Send a state change signal  * @wpa_s: %wpa_supplicant network interface data  * @new_state: new state wpa_supplicant is entering  * @old_state: old state wpa_supplicant is leaving  * Returns: 0 on success, -1 on failure  *  * Notify listeners that wpa_supplicant has changed state  */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_notify_state_change
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|wpa_states
name|new_state
parameter_list|,
name|wpa_states
name|old_state
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
decl_stmt|;
name|DBusMessage
modifier|*
name|signal
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_state_str
decl_stmt|,
modifier|*
name|old_state_str
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|wpa_s
operator|->
name|global
operator|==
name|NULL
condition|)
return|return;
name|iface
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus_ctrl_iface
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
comment|/* Only send signal if state really changed */
if|if
condition|(
name|new_state
operator|==
name|old_state
condition|)
return|return;
name|path
operator|=
name|wpa_supplicant_get_dbus_path
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"interface didn't have a dbus path"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"interface didn't have a dbus path; can't send "
literal|"signal."
argument_list|)
expr_stmt|;
return|return;
block|}
name|signal
operator|=
name|dbus_message_new_signal
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|,
literal|"StateChange"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"couldn't create dbus signal; likely out of memory"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"couldn't create dbus signal; likely out of "
literal|"memory."
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_state_str
operator|=
name|wpa_supplicant_state_txt
argument_list|(
name|new_state
argument_list|)
expr_stmt|;
name|old_state_str
operator|=
name|wpa_supplicant_state_txt
argument_list|(
name|old_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state_str
operator|==
name|NULL
operator|||
name|old_state_str
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"couldn't convert state strings"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"couldn't convert state strings."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|dbus_message_append_args
argument_list|(
name|signal
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|new_state_str
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|old_state_str
argument_list|,
name|DBUS_TYPE_INVALID
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"not enough memory to construct state change signal."
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"wpa_supplicant_dbus_notify_state_change[dbus]: "
literal|"not enough memory to construct state change "
literal|"signal."
argument_list|)
expr_stmt|;
block|}
name|dbus_connection_send
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|signal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * integrate_with_eloop - Register our mainloop integration with dbus  * @connection: connection to the system message bus  * @iface: a dbus control interface data structure  * Returns: 0 on success, -1 on failure  *  * We register our mainloop integration functions with dbus here.  */
end_comment

begin_function
specifier|static
name|int
name|integrate_with_eloop
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dbus_connection_set_watch_functions
argument_list|(
name|connection
argument_list|,
name|add_watch
argument_list|,
name|remove_watch
argument_list|,
name|watch_toggled
argument_list|,
name|iface
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"dbus_connection_set_watch_functions[dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Not enough memory to set up dbus."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|dbus_connection_set_timeout_functions
argument_list|(
name|connection
argument_list|,
name|add_timeout
argument_list|,
name|remove_timeout
argument_list|,
name|timeout_toggled
argument_list|,
name|iface
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"dbus_connection_set_timeout_functions[dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Not enough memory to set up dbus."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|connection_setup_wakeup_main
argument_list|(
name|iface
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connection_setup_wakeup_main[dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Could not setup main wakeup function."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * dispatch_initial_dbus_messages - Dispatch initial dbus messages after  *     claiming bus name  * @eloop_ctx: the DBusConnection to dispatch on  * @timeout_ctx: unused  *  * If clients are quick to notice that wpa_supplicant claimed its bus name,  * there may have been messages that came in before initialization was  * all finished.  Dispatch those here.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_initial_dbus_messages
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
init|=
name|eloop_ctx
decl_stmt|;
while|while
condition|(
name|dbus_connection_get_dispatch_status
argument_list|(
name|con
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
name|dbus_connection_dispatch
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_ctrl_iface_init - Initialize dbus control interface  * @global: Pointer to global data from wpa_supplicant_init()  * Returns: Pointer to dbus_ctrl_iface date or %NULL on failure  *  * Initialize the dbus control interface and start receiving commands from  * external programs over the bus.  */
end_comment

begin_function
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|wpa_supplicant_dbus_ctrl_iface_init
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|DBusObjectPathVTable
name|wpas_vtable
init|=
block|{
name|NULL
block|,
operator|&
name|wpas_message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|iface
operator|=
name|wpa_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctrl_iface_dbus_priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|iface
operator|->
name|global
operator|=
name|global
expr_stmt|;
comment|/* Get a reference to the system bus */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
name|iface
operator|->
name|con
operator|=
name|dbus_bus_get
argument_list|(
name|DBUS_BUS_SYSTEM
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iface
operator|->
name|con
condition|)
block|{
name|perror
argument_list|(
literal|"dbus_bus_get[ctrl_iface_dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Could not acquire the system bus."
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Tell dbus about our mainloop integration functions */
if|if
condition|(
name|integrate_with_eloop
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|iface
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Register the message handler for the global dbus interface */
if|if
condition|(
operator|!
name|dbus_connection_register_object_path
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|WPAS_DBUS_PATH
argument_list|,
operator|&
name|wpas_vtable
argument_list|,
name|iface
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"dbus_connection_register_object_path[dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Could not set up DBus message "
literal|"handler."
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Register our service with the message bus */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dbus_bus_request_name
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|WPAS_DBUS_SERVICE
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
case|case
name|DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DBUS_REQUEST_NAME_REPLY_EXISTS
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_IN_QUEUE
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER
case|:
name|perror
argument_list|(
literal|"dbus_bus_request_name[dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Could not request DBus service name: "
literal|"already registered."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"dbus_bus_request_name[dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Could not request DBus service name: "
literal|"%s %s."
argument_list|,
name|error
operator|.
name|name
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Providing DBus service '"
name|WPAS_DBUS_SERVICE
literal|"'."
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch initial DBus messages that may have come in since the bus 	 * name was claimed above. Happens when clients are quick to notice the 	 * wpa_supplicant service. 	 * 	 * FIXME: is there a better solution to this problem? 	 */
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
literal|50
argument_list|,
name|dispatch_initial_dbus_messages
argument_list|,
name|iface
operator|->
name|con
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|iface
return|;
name|fail
label|:
name|wpa_supplicant_dbus_ctrl_iface_deinit
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_ctrl_iface_deinit - Deinitialize dbus ctrl interface  * @iface: Pointer to dbus private data from  * wpa_supplicant_dbus_ctrl_iface_init()  *  * Deinitialize the dbus control interface that was initialized with  * wpa_supplicant_dbus_ctrl_iface_init().  */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_ctrl_iface_deinit
parameter_list|(
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|iface
parameter_list|)
block|{
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|iface
operator|->
name|con
condition|)
block|{
name|eloop_cancel_timeout
argument_list|(
name|dispatch_initial_dbus_messages
argument_list|,
name|iface
operator|->
name|con
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_connection_set_watch_functions
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_connection_set_timeout_functions
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_connection_unref
argument_list|(
name|iface
operator|->
name|con
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctrl_iface_dbus_priv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_register_new_iface - Register a new interface with dbus  * @global: Global %wpa_supplicant data  * @wpa_s: %wpa_supplicant interface description structure to register  * Returns: 0 on success, -1 on error  *  * Registers a new interface with dbus and assigns it a dbus object path.  */
end_comment

begin_function
name|int
name|wpas_dbus_register_iface
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|ctrl_iface
init|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus_ctrl_iface
decl_stmt|;
name|DBusConnection
modifier|*
name|con
decl_stmt|;
name|u32
name|next
decl_stmt|;
name|DBusObjectPathVTable
name|vtable
init|=
block|{
name|NULL
block|,
operator|&
name|wpas_iface_message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|con
operator|=
name|ctrl_iface
operator|->
name|con
expr_stmt|;
name|next
operator|=
name|wpa_supplicant_dbus_next_objid
argument_list|(
name|ctrl_iface
argument_list|)
expr_stmt|;
comment|/* Create and set the interface's object path */
name|path
operator|=
name|wpa_zalloc
argument_list|(
name|WPAS_DBUS_OBJECT_PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|snprintf
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_OBJECT_PATH_MAX
argument_list|,
name|WPAS_DBUS_PATH_INTERFACES
literal|"/%u"
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_set_dbus_path
argument_list|(
name|wpa_s
argument_list|,
name|path
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Failed to set dbus path for interface %s"
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Register the message handler for the interface functions */
if|if
condition|(
operator|!
name|dbus_connection_register_fallback
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|&
name|vtable
argument_list|,
name|wpa_s
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"wpas_dbus_register_iface [dbus]"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Could not set up DBus message "
literal|"handler for interface %s."
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_unregister_iface - Unregister an interface from dbus  * @wpa_s: wpa_supplicant interface structure  * Returns: 0 on success, -1 on failure  *  * Unregisters the interface with dbus  */
end_comment

begin_function
name|int
name|wpas_dbus_unregister_iface
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|ctrl_iface_dbus_priv
modifier|*
name|ctrl_iface
decl_stmt|;
name|DBusConnection
modifier|*
name|con
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|wpa_s
operator|==
name|NULL
operator|||
name|wpa_s
operator|->
name|global
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ctrl_iface
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus_ctrl_iface
expr_stmt|;
if|if
condition|(
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|con
operator|=
name|ctrl_iface
operator|->
name|con
expr_stmt|;
name|path
operator|=
name|wpa_supplicant_get_dbus_path
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_connection_unregister_object_path
argument_list|(
name|con
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|free
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|dbus_path
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_iface_by_dbus_path - Get a new network interface  * @global: Pointer to global data from wpa_supplicant_init()  * @path: Pointer to a dbus object path representing an interface  * Returns: Pointer to the interface or %NULL if not found  */
end_comment

begin_function
name|struct
name|wpa_supplicant
modifier|*
name|wpa_supplicant_get_iface_by_dbus_path
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
for|for
control|(
name|wpa_s
operator|=
name|global
operator|->
name|ifaces
init|;
name|wpa_s
condition|;
name|wpa_s
operator|=
name|wpa_s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
return|return
name|wpa_s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_set_dbus_path - Assign a dbus path to an interface  * @wpa_s: wpa_supplicant interface structure  * @path: dbus path to set on the interface  * Returns: 0 on succes, -1 on error  */
end_comment

begin_function
name|int
name|wpa_supplicant_set_dbus_path
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|u32
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|WPAS_DBUS_OBJECT_PATH_MAX
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_s
operator|->
name|dbus_path
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_s
operator|->
name|dbus_path
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_dbus_path - Get an interface's dbus path  * @wpa_s: %wpa_supplicant interface structure  * Returns: Interface's dbus object path, or %NULL on error  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|wpa_supplicant_get_dbus_path
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
return|return
name|wpa_s
operator|->
name|dbus_path
return|;
block|}
end_function

end_unit

