begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: pamc_load.c,v 1.1.1.1 2000/06/20 22:11:26 agmorgan Exp $  *  * Copyright (c) 1999 Andrew G. Morgan<morgan@ftp.kernel.org>  *  * pamc_load  */
end_comment

begin_include
include|#
directive|include
file|"libpamc.h"
end_include

begin_function
specifier|static
name|int
name|__pamc_exec_agent
parameter_list|(
name|pamc_handle_t
name|pch
parameter_list|,
name|pamc_agent_t
modifier|*
name|agent
parameter_list|)
block|{
name|char
modifier|*
name|full_path
decl_stmt|;
name|int
name|found_agent
decl_stmt|,
name|length
decl_stmt|,
name|reset_length
decl_stmt|,
name|to_agent
index|[
literal|2
index|]
decl_stmt|,
name|from_agent
index|[
literal|2
index|]
decl_stmt|;
name|int
name|return_code
init|=
name|PAM_BPC_FAIL
decl_stmt|;
if|if
condition|(
name|agent
operator|->
name|id
index|[
name|agent
operator|->
name|id_length
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|PAM_BP_ASSERT
argument_list|(
literal|"libpamc: internal error agent_id not terminated"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|length
operator|=
literal|0
init|;
operator|(
name|length
operator|<
name|agent
operator|->
name|id_length
operator|)
condition|;
operator|++
name|length
control|)
block|{
switch|switch
condition|(
name|agent
operator|->
name|id
index|[
name|length
index|]
condition|)
block|{
case|case
literal|'/'
case|:
name|D
argument_list|(
operator|(
literal|"ill formed agent id"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FAIL
return|;
block|}
block|}
comment|/* enough memory for any path + this agent */
name|reset_length
operator|=
literal|3
operator|+
name|pch
operator|->
name|max_path
operator|+
name|agent
operator|->
name|id_length
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"reset_length = %d (3+%d+%d)"
operator|,
name|reset_length
operator|,
name|pch
operator|->
name|max_path
operator|,
name|agent
operator|->
name|id_length
operator|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|malloc
argument_list|(
name|reset_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_path
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no memory for agent path"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FAIL
return|;
block|}
name|found_agent
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|length
operator|=
literal|0
init|;
name|pch
operator|->
name|agent_paths
index|[
name|length
index|]
condition|;
operator|++
name|length
control|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"path: [%s]"
operator|,
name|pch
operator|->
name|agent_paths
index|[
name|length
index|]
operator|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"agent id: [%s]"
operator|,
name|agent
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|full_path
argument_list|,
literal|"%s/%s"
argument_list|,
name|pch
operator|->
name|agent_paths
index|[
name|length
index|]
argument_list|,
name|agent
operator|->
name|id
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"looking for agent here: [%s]\n"
operator|,
name|full_path
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|full_path
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"file existis"
operator|)
argument_list|)
expr_stmt|;
name|found_agent
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_agent
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no agent was found"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|free_and_return
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|to_agent
argument_list|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"failed to open pipe to agent"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|free_and_return
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|from_agent
argument_list|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"failed to open pipe from agent"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|close_the_agent
goto|;
block|}
name|agent
operator|->
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|agent
operator|->
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"failed to fork for agent"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|close_both_pipes
goto|;
block|}
elseif|else
if|if
condition|(
name|agent
operator|->
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|dup2
argument_list|(
name|from_agent
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|to_agent
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
comment|/* we close all of the files that have filedescriptors lower 	   and equal to twice the highest we have seen, The idea is 	   that we don't want to leak filedescriptors to agents from a 	   privileged client application.  	   XXX - this is a heuristic at this point. There is a growing 	    need for an extra 'set param' libpamc function, that could 	    be used to supply info like the highest fd to close etc.. 	*/
if|if
condition|(
name|from_agent
index|[
literal|1
index|]
operator|>
name|pch
operator|->
name|highest_fd_to_close
condition|)
block|{
name|pch
operator|->
name|highest_fd_to_close
operator|=
literal|2
operator|*
name|from_agent
index|[
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|pch
operator|->
name|highest_fd_to_close
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|STDOUT_FILENO
case|:
case|case
name|STDERR_FILENO
case|:
case|case
name|STDIN_FILENO
case|:
comment|/* only these three remain open */
break|break;
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* don't care if its not open */
block|}
block|}
comment|/* we make no attempt to drop other privileges - this library 	   has no idea how that would be done in the general case. It 	   is up to the client application (when calling 	   pamc_converse) to make sure no privilege will leak into an 	   (untrusted) agent. */
comment|/* we propogate no environment - future versions of this            library may have the ability to audit all agent            transactions. */
name|D
argument_list|(
operator|(
literal|"exec'ing agent %s"
operator|,
name|full_path
operator|)
argument_list|)
expr_stmt|;
name|execle
argument_list|(
name|full_path
argument_list|,
literal|"pam-agent"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"exec failed"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|to_agent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_agent
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|agent
operator|->
name|writer
operator|=
name|to_agent
index|[
literal|1
index|]
expr_stmt|;
name|agent
operator|->
name|reader
operator|=
name|from_agent
index|[
literal|0
index|]
expr_stmt|;
name|return_code
operator|=
name|PAM_BPC_TRUE
expr_stmt|;
goto|goto
name|free_and_return
goto|;
name|close_both_pipes
label|:
name|close
argument_list|(
name|from_agent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_agent
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close_the_agent
label|:
name|close
argument_list|(
name|to_agent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|to_agent
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free_and_return
label|:
name|memset
argument_list|(
name|full_path
argument_list|,
literal|0
argument_list|,
name|reset_length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|full_path
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"returning %d"
operator|,
name|return_code
operator|)
argument_list|)
expr_stmt|;
return|return
name|return_code
return|;
block|}
end_function

begin_comment
comment|/*  * has the named agent been loaded?  */
end_comment

begin_function
specifier|static
name|int
name|__pamc_agent_is_enabled
parameter_list|(
name|pamc_handle_t
name|pch
parameter_list|,
specifier|const
name|char
modifier|*
name|agent_id
parameter_list|)
block|{
name|pamc_agent_t
modifier|*
name|agent
decl_stmt|;
for|for
control|(
name|agent
operator|=
name|pch
operator|->
name|chain
init|;
name|agent
condition|;
name|agent
operator|=
name|agent
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|agent
operator|->
name|id
argument_list|,
name|agent_id
argument_list|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"agent already loaded"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_TRUE
return|;
block|}
block|}
name|D
argument_list|(
operator|(
literal|"agent is not loaded"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * has the named agent been disabled?  */
end_comment

begin_function
specifier|static
name|int
name|__pamc_agent_is_disabled
parameter_list|(
name|pamc_handle_t
name|pch
parameter_list|,
specifier|const
name|char
modifier|*
name|agent_id
parameter_list|)
block|{
name|pamc_blocked_t
modifier|*
name|blocked
decl_stmt|;
for|for
control|(
name|blocked
operator|=
name|pch
operator|->
name|blocked_agents
init|;
name|blocked
condition|;
name|blocked
operator|=
name|blocked
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|agent_id
argument_list|,
name|blocked
operator|->
name|id
argument_list|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"agent is disabled"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_TRUE
return|;
block|}
block|}
name|D
argument_list|(
operator|(
literal|"agent is not disabled"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * disable an agent  */
end_comment

begin_function
name|int
name|pamc_disable
parameter_list|(
name|pamc_handle_t
name|pch
parameter_list|,
specifier|const
name|char
modifier|*
name|agent_id
parameter_list|)
block|{
name|pamc_blocked_t
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|pch
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"pch is NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
if|if
condition|(
name|agent_id
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"agent_id is NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
if|if
condition|(
name|__pamc_agent_is_enabled
argument_list|(
name|pch
argument_list|,
name|agent_id
argument_list|)
operator|!=
name|PAM_BPC_FALSE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"agent is already loaded"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
if|if
condition|(
name|__pamc_agent_is_disabled
argument_list|(
name|pch
argument_list|,
name|agent_id
argument_list|)
operator|!=
name|PAM_BPC_FALSE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"agent is already disabled"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_TRUE
return|;
block|}
name|block
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|pamc_blocked_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no memory for new blocking structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
name|block
operator|->
name|id
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|agent_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|->
name|id
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no memory for agent id"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
name|strcpy
argument_list|(
name|block
operator|->
name|id
argument_list|,
name|agent_id
argument_list|)
expr_stmt|;
name|block
operator|->
name|next
operator|=
name|pch
operator|->
name|blocked_agents
expr_stmt|;
name|pch
operator|->
name|blocked_agents
operator|=
name|block
expr_stmt|;
return|return
name|PAM_BPC_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * force the loading of a particular agent  */
end_comment

begin_function
name|int
name|pamc_load
parameter_list|(
name|pamc_handle_t
name|pch
parameter_list|,
specifier|const
name|char
modifier|*
name|agent_id
parameter_list|)
block|{
name|pamc_agent_t
modifier|*
name|agent
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* santity checking */
if|if
condition|(
name|pch
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"pch is NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
if|if
condition|(
name|agent_id
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"agent_id is NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
if|if
condition|(
name|__pamc_agent_is_disabled
argument_list|(
name|pch
argument_list|,
name|agent_id
argument_list|)
operator|!=
name|PAM_BPC_FALSE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"sorry agent is disabled"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|agent_id
argument_list|)
expr_stmt|;
comment|/* scan list to see if agent is loaded */
if|if
condition|(
name|__pamc_agent_is_enabled
argument_list|(
name|pch
argument_list|,
name|agent_id
argument_list|)
operator|==
name|PAM_BPC_TRUE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no need to load an already loaded agent (%s)"
operator|,
name|agent_id
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_TRUE
return|;
block|}
comment|/* not in the list, so we need to load it and add it to the head        of the chain */
name|agent
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|pamc_agent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agent
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no memory for new agent"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
name|agent
operator|->
name|id
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|agent
operator|->
name|id
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no memory for new agent's id"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_free_agent
goto|;
block|}
name|memcpy
argument_list|(
name|agent
operator|->
name|id
argument_list|,
name|agent_id
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|agent
operator|->
name|id
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|agent
operator|->
name|id_length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|__pamc_exec_agent
argument_list|(
name|pch
argument_list|,
name|agent
argument_list|)
operator|!=
name|PAM_BPC_TRUE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"unable to exec agent"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_free_agent_id
goto|;
block|}
name|agent
operator|->
name|next
operator|=
name|pch
operator|->
name|chain
expr_stmt|;
name|pch
operator|->
name|chain
operator|=
name|agent
expr_stmt|;
return|return
name|PAM_BPC_TRUE
return|;
name|fail_free_agent_id
label|:
name|memset
argument_list|(
name|agent
operator|->
name|id
argument_list|,
literal|0
argument_list|,
name|agent
operator|->
name|id_length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|agent
operator|->
name|id
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|agent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|agent
argument_list|)
argument_list|)
expr_stmt|;
name|fail_free_agent
label|:
name|free
argument_list|(
name|agent
argument_list|)
expr_stmt|;
return|return
name|PAM_BPC_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * what's a valid agent name?  */
end_comment

begin_function
name|int
name|__pamc_valid_agent_id
parameter_list|(
name|int
name|id_length
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|int
name|post
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|post
operator|=
literal|0
init|;
name|i
operator|<
name|id_length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ch
init|=
name|id
index|[
name|i
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|||
name|isdigit
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'_'
operator|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|post
operator|&&
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|!
name|post
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|'@'
operator|)
condition|)
block|{
name|post
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"id=%s contains '%c' which is illegal"
operator|,
name|id
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"length of id is 0"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
comment|/* id is valid */
block|}
block|}
end_function

begin_comment
comment|/*  * building a tree of available agent names  */
end_comment

begin_function
specifier|static
name|pamc_id_node_t
modifier|*
name|__pamc_add_node
parameter_list|(
name|pamc_id_node_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
modifier|*
name|counter
parameter_list|)
block|{
if|if
condition|(
name|root
condition|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
operator|(
name|cmp
operator|=
name|strcmp
argument_list|(
name|id
argument_list|,
name|root
operator|->
name|agent_id
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|root
operator|->
name|right
operator|=
name|__pamc_add_node
argument_list|(
name|root
operator|->
name|right
argument_list|,
name|id
argument_list|,
operator|&
operator|(
name|root
operator|->
name|child_count
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root
operator|->
name|left
operator|=
name|__pamc_add_node
argument_list|(
name|root
operator|->
name|left
argument_list|,
name|id
argument_list|,
operator|&
operator|(
name|root
operator|->
name|child_count
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|root
return|;
block|}
else|else
block|{
name|pamc_id_node_t
modifier|*
name|node
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|pamc_id_node_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|node
operator|->
name|agent_id
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|agent_id
condition|)
block|{
name|strcpy
argument_list|(
name|node
operator|->
name|agent_id
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|counter
operator|)
operator|++
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * drop all of the tree and any remaining ids  */
end_comment

begin_function
specifier|static
name|pamc_id_node_t
modifier|*
name|__pamc_liberate_nodes
parameter_list|(
name|pamc_id_node_t
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|agent_id
condition|)
block|{
name|free
argument_list|(
name|tree
operator|->
name|agent_id
argument_list|)
expr_stmt|;
name|tree
operator|->
name|agent_id
operator|=
name|NULL
expr_stmt|;
block|}
name|tree
operator|->
name|left
operator|=
name|__pamc_liberate_nodes
argument_list|(
name|tree
operator|->
name|left
argument_list|)
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|__pamc_liberate_nodes
argument_list|(
name|tree
operator|->
name|right
argument_list|)
expr_stmt|;
name|tree
operator|->
name|child_count
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * fill a list with the contents of the tree (in ascii order)  */
end_comment

begin_function
specifier|static
name|void
name|__pamc_fill_list_from_tree
parameter_list|(
name|pamc_id_node_t
modifier|*
name|tree
parameter_list|,
name|char
modifier|*
modifier|*
name|agent_list
parameter_list|,
name|int
modifier|*
name|counter
parameter_list|)
block|{
if|if
condition|(
name|tree
condition|)
block|{
name|__pamc_fill_list_from_tree
argument_list|(
name|tree
operator|->
name|left
argument_list|,
name|agent_list
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|agent_list
index|[
operator|(
operator|*
name|counter
operator|)
operator|++
index|]
operator|=
name|tree
operator|->
name|agent_id
expr_stmt|;
name|tree
operator|->
name|agent_id
operator|=
name|NULL
expr_stmt|;
name|__pamc_fill_list_from_tree
argument_list|(
name|tree
operator|->
name|right
argument_list|,
name|agent_list
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * get a list of the available agents  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|pamc_list_agents
parameter_list|(
name|pamc_handle_t
name|pch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|total_agent_count
init|=
literal|0
decl_stmt|;
name|pamc_id_node_t
modifier|*
name|tree
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|agent_list
decl_stmt|;
comment|/* loop over agent paths */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pch
operator|->
name|agent_paths
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|DIR
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|pch
operator|->
name|agent_paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
name|struct
name|dirent
modifier|*
name|item
decl_stmt|;
while|while
condition|(
operator|(
name|item
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
comment|/* this is a cheat on recognizing agent_ids */
if|if
condition|(
operator|!
name|__pamc_valid_agent_id
argument_list|(
name|strlen
argument_list|(
name|item
operator|->
name|d_name
argument_list|)
argument_list|,
name|item
operator|->
name|d_name
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|tree
operator|=
name|__pamc_add_node
argument_list|(
name|tree
argument_list|,
name|item
operator|->
name|d_name
argument_list|,
operator|&
name|total_agent_count
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now, we build a list of ids */
name|D
argument_list|(
operator|(
literal|"total of %d available agents\n"
operator|,
name|total_agent_count
operator|)
argument_list|)
expr_stmt|;
name|agent_list
operator|=
name|calloc
argument_list|(
name|total_agent_count
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agent_list
condition|)
block|{
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|__pamc_fill_list_from_tree
argument_list|(
name|tree
argument_list|,
name|agent_list
argument_list|,
operator|&
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|!=
name|total_agent_count
condition|)
block|{
name|PAM_BP_ASSERT
argument_list|(
literal|"libpamc: internal error transcribing tree"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"no memory for agent list"
operator|)
argument_list|)
expr_stmt|;
block|}
name|__pamc_liberate_nodes
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
name|agent_list
return|;
block|}
end_function

end_unit

