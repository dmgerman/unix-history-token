begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pam_dispatch.c - handles module function dispatch */
end_comment

begin_comment
comment|/*  * $Id: pam_dispatch.c,v 1.8 1997/01/04 20:04:09 morgan Exp morgan $  * $FreeBSD$  *  * last modified by AGM  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pam_private.h"
end_include

begin_comment
comment|/*  * this is the return code we return when a function pointer is NULL  * or, the handler structure indicates a broken module config line  */
end_comment

begin_define
define|#
directive|define
name|PAM_MUST_FAIL_CODE
value|PAM_PERM_DENIED
end_define

begin_comment
comment|/* impression codes - this gives some sense to the logical choices */
end_comment

begin_define
define|#
directive|define
name|_PAM_UNDEF
value|0
end_define

begin_define
define|#
directive|define
name|_PAM_POSITIVE
value|+1
end_define

begin_define
define|#
directive|define
name|_PAM_NEGATIVE
value|-1
end_define

begin_comment
comment|/*  * walk a stack of modules.  Interpret the administrator's instructions  * when combining the return code of each module.  */
end_comment

begin_function
specifier|static
name|int
name|_pam_dispatch_aux
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|handler
modifier|*
name|h
parameter_list|,
name|_pam_boolean
name|resumed
parameter_list|)
block|{
name|int
name|depth
decl_stmt|,
name|impression
decl_stmt|,
name|status
decl_stmt|,
name|skip_depth
decl_stmt|;
name|IF_NO_PAMH
argument_list|(
literal|"_pam_dispatch_aux"
argument_list|,
name|pamh
argument_list|,
name|PAM_SYSTEM_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|service
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_SERVICE
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|service
argument_list|)
expr_stmt|;
name|pam_system_log
argument_list|(
name|pamh
argument_list|,
name|NULL
argument_list|,
name|LOG_ERR
argument_list|,
literal|"no modules loaded for `%s' service"
argument_list|,
name|service
condition|?
name|service
else|:
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
return|return
name|PAM_MUST_FAIL_CODE
return|;
block|}
comment|/* if we are recalling this module stack because a former call did        not complete, we restore the state of play from pamh. */
if|if
condition|(
name|resumed
condition|)
block|{
name|skip_depth
operator|=
name|pamh
operator|->
name|former
operator|.
name|depth
expr_stmt|;
name|status
operator|=
name|pamh
operator|->
name|former
operator|.
name|status
expr_stmt|;
name|impression
operator|=
name|pamh
operator|->
name|former
operator|.
name|impression
expr_stmt|;
comment|/* forget all that */
name|pamh
operator|->
name|former
operator|.
name|impression
operator|=
name|_PAM_UNDEF
expr_stmt|;
name|pamh
operator|->
name|former
operator|.
name|status
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
name|pamh
operator|->
name|former
operator|.
name|depth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|skip_depth
operator|=
literal|0
expr_stmt|;
name|impression
operator|=
name|_PAM_UNDEF
expr_stmt|;
name|status
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
block|}
comment|/* Loop through module logic stack */
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|next
operator|,
operator|++
name|depth
control|)
block|{
name|int
name|retval
decl_stmt|,
name|action
decl_stmt|;
comment|/* skip leading modules if they have already returned */
if|if
condition|(
name|depth
operator|<
name|skip_depth
condition|)
block|{
continue|continue;
block|}
comment|/* attempt to call the module */
if|if
condition|(
name|h
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"module function is not defined, indicating failure"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_MODULE_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"passing control to module..."
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|h
operator|->
name|func
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|h
operator|->
name|argc
argument_list|,
name|h
operator|->
name|argv
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"module returned: %s"
operator|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|must_fail
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"module poorly listed in pam.conf; forcing failure"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
block|}
block|}
comment|/* 	 * PAM_INCOMPLETE return is special.  It indicates that the 	 * module wants to wait for the application before continuing. 	 * In order to return this, the module will have saved its 	 * state so it can resume from an equivalent position when it 	 * is called next time.  (This was added as of 0.65) 	 */
if|if
condition|(
name|retval
operator|==
name|PAM_INCOMPLETE
condition|)
block|{
name|pamh
operator|->
name|former
operator|.
name|impression
operator|=
name|impression
expr_stmt|;
name|pamh
operator|->
name|former
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|pamh
operator|->
name|former
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"module %d returned PAM_INCOMPLETE"
operator|,
name|depth
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* verify that the return value is a valid one */
if|if
condition|(
name|retval
operator|<
name|PAM_SUCCESS
operator|||
name|retval
operator|>=
name|_PAM_RETURN_VALUES
condition|)
block|{
name|retval
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
name|action
operator|=
name|_PAM_ACTION_BAD
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
name|h
operator|->
name|actions
index|[
name|retval
index|]
expr_stmt|;
block|}
comment|/* decide what to do */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|_PAM_ACTION_RESET
case|:
name|impression
operator|=
name|_PAM_UNDEF
expr_stmt|;
name|status
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
break|break;
case|case
name|_PAM_ACTION_OK
case|:
case|case
name|_PAM_ACTION_DONE
case|:
if|if
condition|(
name|impression
operator|==
name|_PAM_UNDEF
operator|||
operator|(
name|impression
operator|==
name|_PAM_POSITIVE
operator|&&
name|status
operator|==
name|PAM_SUCCESS
operator|)
condition|)
block|{
name|impression
operator|=
name|_PAM_POSITIVE
expr_stmt|;
name|status
operator|=
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|impression
operator|==
name|_PAM_POSITIVE
operator|&&
name|action
operator|==
name|_PAM_ACTION_DONE
condition|)
block|{
goto|goto
name|decision_made
goto|;
block|}
break|break;
case|case
name|_PAM_ACTION_BAD
case|:
case|case
name|_PAM_ACTION_DIE
case|:
ifdef|#
directive|ifdef
name|PAM_FAIL_NOW_ON
if|if
condition|(
name|retval
operator|==
name|PAM_ABORT
condition|)
block|{
name|impression
operator|=
name|_PAM_NEGATIVE
expr_stmt|;
name|status
operator|=
name|PAM_PERM_DENIED
expr_stmt|;
goto|goto
name|decision_made
goto|;
block|}
endif|#
directive|endif
comment|/* PAM_FAIL_NOW_ON */
if|if
condition|(
name|impression
operator|!=
name|_PAM_NEGATIVE
condition|)
block|{
name|impression
operator|=
name|_PAM_NEGATIVE
expr_stmt|;
name|status
operator|=
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|_PAM_ACTION_DIE
condition|)
block|{
goto|goto
name|decision_made
goto|;
block|}
break|break;
case|case
name|_PAM_ACTION_IGNORE
case|:
break|break;
comment|/* if we get here, we expect action is a positive number --            this is what the ...JUMP macro checks. */
default|default:
if|if
condition|(
name|_PAM_ACTION_IS_JUMP
argument_list|(
name|action
argument_list|)
condition|)
block|{
comment|/* this means that we need to skip #action stacked modules */
do|do
block|{
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|action
operator|>
literal|0
operator|&&
name|h
operator|!=
name|NULL
condition|)
do|;
comment|/* note if we try to skip too many modules action is                    still non-zero and we snag the next if. */
block|}
comment|/* this case is a syntax error: we can't succeed */
if|if
condition|(
name|action
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"action syntax error"
operator|)
argument_list|)
expr_stmt|;
name|impression
operator|=
name|_PAM_NEGATIVE
expr_stmt|;
name|status
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
block|}
block|}
block|}
name|decision_made
label|:
comment|/* by getting  here we have made a decision */
comment|/* Sanity check */
if|if
condition|(
name|status
operator|==
name|PAM_SUCCESS
operator|&&
name|impression
operator|!=
name|_PAM_POSITIVE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"caught on sanity check -- this is probably a config error!"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PAM_MUST_FAIL_CODE
expr_stmt|;
block|}
comment|/* We have made a decision about the modules executed */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * This function translates the module dispatch request into a pointer  * to the stack of modules that will actually be run.  the  * _pam_dispatch_aux() function (above) is responsible for walking the  * module stack.  */
end_comment

begin_function
name|int
name|_pam_dispatch
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|choice
parameter_list|)
block|{
name|struct
name|handler
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|_pam_boolean
name|resumed
decl_stmt|;
name|IF_NO_PAMH
argument_list|(
literal|"_pam_dispatch"
argument_list|,
name|pamh
argument_list|,
name|PAM_SYSTEM_ERR
argument_list|)
expr_stmt|;
comment|/* Load all modules, resolve all symbols */
if|if
condition|(
operator|(
name|retval
operator|=
name|_pam_init_handlers
argument_list|(
name|pamh
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|pam_system_log
argument_list|(
name|pamh
argument_list|,
name|NULL
argument_list|,
name|LOG_ERR
argument_list|,
literal|"unable to dispatch function"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
switch|switch
condition|(
name|choice
condition|)
block|{
case|case
name|PAM_AUTHENTICATE
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|conf
operator|.
name|authenticate
expr_stmt|;
break|break;
case|case
name|PAM_SETCRED
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|conf
operator|.
name|setcred
expr_stmt|;
break|break;
case|case
name|PAM_ACCOUNT
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|conf
operator|.
name|acct_mgmt
expr_stmt|;
break|break;
case|case
name|PAM_OPEN_SESSION
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|conf
operator|.
name|open_session
expr_stmt|;
break|break;
case|case
name|PAM_CLOSE_SESSION
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|conf
operator|.
name|close_session
expr_stmt|;
break|break;
case|case
name|PAM_CHAUTHTOK
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|conf
operator|.
name|chauthtok
expr_stmt|;
break|break;
default|default:
name|pam_system_log
argument_list|(
name|pamh
argument_list|,
name|NULL
argument_list|,
name|LOG_ERR
argument_list|,
literal|"undefined fn choice; %d"
argument_list|,
name|choice
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* there was no handlers.conf... entry; will use 			  * handlers.other... */
switch|switch
condition|(
name|choice
condition|)
block|{
case|case
name|PAM_AUTHENTICATE
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|other
operator|.
name|authenticate
expr_stmt|;
break|break;
case|case
name|PAM_SETCRED
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|other
operator|.
name|setcred
expr_stmt|;
break|break;
case|case
name|PAM_ACCOUNT
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|other
operator|.
name|acct_mgmt
expr_stmt|;
break|break;
case|case
name|PAM_OPEN_SESSION
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|other
operator|.
name|open_session
expr_stmt|;
break|break;
case|case
name|PAM_CLOSE_SESSION
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|other
operator|.
name|close_session
expr_stmt|;
break|break;
case|case
name|PAM_CHAUTHTOK
case|:
name|h
operator|=
name|pamh
operator|->
name|handlers
operator|.
name|other
operator|.
name|chauthtok
expr_stmt|;
break|break;
block|}
block|}
comment|/* Did a module return an "incomplete state" last time? */
if|if
condition|(
name|pamh
operator|->
name|former
operator|.
name|choice
operator|!=
name|PAM_NOT_STACKED
condition|)
block|{
if|if
condition|(
name|pamh
operator|->
name|former
operator|.
name|choice
operator|!=
name|choice
condition|)
block|{
name|pam_system_log
argument_list|(
name|pamh
argument_list|,
name|NULL
argument_list|,
name|LOG_ERR
argument_list|,
literal|"application failed to re-exec stack [%d:%d]"
argument_list|,
name|pamh
operator|->
name|former
operator|.
name|choice
argument_list|,
name|choice
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
name|resumed
operator|=
name|PAM_TRUE
expr_stmt|;
block|}
else|else
block|{
name|resumed
operator|=
name|PAM_FALSE
expr_stmt|;
block|}
comment|/* call the list of module functions */
name|retval
operator|=
name|_pam_dispatch_aux
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|h
argument_list|,
name|resumed
argument_list|)
expr_stmt|;
name|resumed
operator|=
name|PAM_FALSE
expr_stmt|;
comment|/* Should we recall where to resume next time? */
if|if
condition|(
name|retval
operator|==
name|PAM_INCOMPLETE
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"module [%d] returned PAM_INCOMPLETE"
operator|)
argument_list|)
expr_stmt|;
name|pamh
operator|->
name|former
operator|.
name|choice
operator|=
name|choice
expr_stmt|;
block|}
else|else
block|{
name|pamh
operator|->
name|former
operator|.
name|choice
operator|=
name|PAM_NOT_STACKED
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * $Log: pam_dispatch.c,v $  */
end_comment

end_unit

