begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pam_delay.c  *  * Copyright (c) Andrew G. Morgan<morgan@linux.kernel.org> 1996-8  * All rights reserved.  *  * $Id: pam_delay.c,v 1.5 1997/04/05 06:54:19 morgan Exp $  * $FreeBSD$  *  * $Log: pam_delay.c,v $  */
end_comment

begin_comment
comment|/*  * This is a simple implementation of a delay on failure mechanism; an  * attempt to overcome authentication-time attacks in a simple manner.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pam_private.h"
end_include

begin_comment
comment|/* **********************************************************************  * initialize the time as unset, this is set on the return from the  * authenticating pair of of the libpam pam_XXX calls.  */
end_comment

begin_function
name|void
name|_pam_reset_timer
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|)
block|{
name|D
argument_list|(
operator|(
literal|"setting pamh->fail_delay.set to FALSE"
operator|)
argument_list|)
expr_stmt|;
name|pamh
operator|->
name|fail_delay
operator|.
name|set
operator|=
name|PAM_FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **********************************************************************  * this function sets the start time for possible delayed failing.  *  * Eventually, it may set the timer so libpam knows how long the program  * has already been executing. Currently, this value is used to seed  * a pseudo-random number generator...  */
end_comment

begin_function
name|void
name|_pam_start_timer
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|)
block|{
name|pamh
operator|->
name|fail_delay
operator|.
name|begin
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"starting timer..."
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* *******************************************************************  * Compute a pseudo random time. The value is base*(1 +/- 1/5) where  * the distribution is pseudo gausian (the sum of three evenly  * distributed random numbers -- central limit theorem and all ;^) The  * linear random numbers are based on a formulae given in Knuth's  * Seminumerical recipies that was reproduced in `Numerical Recipies  * in C'. It is *not* a cryptographically strong generator, but it is  * probably "good enough" for our purposes here.  *  * /dev/random might be a better place to look for some numbers...  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|_pam_rand
parameter_list|(
name|unsigned
name|int
name|seed
parameter_list|)
block|{
define|#
directive|define
name|N1
value|1664525
define|#
directive|define
name|N2
value|1013904223
return|return
name|N1
operator|*
name|seed
operator|+
name|N2
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_pam_compute_delay
parameter_list|(
name|unsigned
name|int
name|seed
parameter_list|,
name|unsigned
name|int
name|base
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|sum
decl_stmt|;
name|unsigned
name|int
name|ans
decl_stmt|;
for|for
control|(
name|sum
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|seed
operator|=
name|_pam_rand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|sum
operator|+=
call|(
name|double
call|)
argument_list|(
operator|(
name|seed
operator|/
literal|10
operator|)
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
name|sum
operator|=
operator|(
name|sum
operator|/
literal|3.
operator|)
operator|/
literal|1e6
operator|-
literal|.5
expr_stmt|;
comment|/* rescale */
name|ans
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|base
operator|*
operator|(
literal|1.
operator|+
name|sum
operator|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"random number: base=%u -> ans=%u\n"
operator|,
name|base
operator|,
name|ans
operator|)
argument_list|)
expr_stmt|;
return|return
name|ans
return|;
block|}
end_function

begin_comment
comment|/* **********************************************************************  * the following function sleeps for a random time. The actual time  * slept is computed above.. It is based on the requested time but will  * differ by up to +/- 25%.  */
end_comment

begin_function
name|void
name|_pam_await_timer
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|unsigned
name|int
name|delay
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"waiting?..."
operator|)
argument_list|)
expr_stmt|;
name|delay
operator|=
name|_pam_compute_delay
argument_list|(
name|pamh
operator|->
name|fail_delay
operator|.
name|begin
argument_list|,
name|pamh
operator|->
name|fail_delay
operator|.
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|pamh
operator|->
name|fail_delay
operator|.
name|delay_fn_ptr
condition|)
block|{
union|union
block|{
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
block|}
name|hack_fn_u
union|;
comment|/* always call the applications delay function, even if 	   the delay is zero - indicate status */
name|hack_fn_u
operator|.
name|value
operator|=
name|pamh
operator|->
name|fail_delay
operator|.
name|delay_fn_ptr
expr_stmt|;
name|hack_fn_u
operator|.
name|fn
argument_list|(
name|status
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|PAM_SUCCESS
operator|&&
name|pamh
operator|->
name|fail_delay
operator|.
name|set
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"will wait %u usec"
operator|,
name|delay
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
name|struct
name|timeval
name|tval
decl_stmt|;
name|tval
operator|.
name|tv_sec
operator|=
name|delay
operator|/
literal|1000000
expr_stmt|;
name|tval
operator|.
name|tv_usec
operator|=
name|delay
operator|%
literal|1000000
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tval
argument_list|)
expr_stmt|;
block|}
block|}
name|_pam_reset_timer
argument_list|(
name|pamh
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"waiting done"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **********************************************************************  * this function is known to both the module and the application, it  * keeps a running score of the largest-requested delay so far, as  * specified by either modules or an application.  */
end_comment

begin_function
name|int
name|pam_fail_delay
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|unsigned
name|int
name|usec
parameter_list|)
block|{
name|int
name|largest
decl_stmt|;
name|IF_NO_PAMH
argument_list|(
literal|"pam_fail_delay"
argument_list|,
name|pamh
argument_list|,
name|PAM_SYSTEM_ERR
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"setting delay to %u"
operator|,
name|usec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pamh
operator|->
name|fail_delay
operator|.
name|set
condition|)
block|{
name|largest
operator|=
name|pamh
operator|->
name|fail_delay
operator|.
name|delay
expr_stmt|;
block|}
else|else
block|{
name|pamh
operator|->
name|fail_delay
operator|.
name|set
operator|=
name|PAM_TRUE
expr_stmt|;
name|largest
operator|=
literal|0
expr_stmt|;
block|}
name|D
argument_list|(
operator|(
literal|"largest = %u"
operator|,
name|largest
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest
operator|<
name|usec
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"resetting largest delay"
operator|)
argument_list|)
expr_stmt|;
name|pamh
operator|->
name|fail_delay
operator|.
name|delay
operator|=
name|usec
expr_stmt|;
block|}
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

end_unit

