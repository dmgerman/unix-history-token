begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pam_static.c -- static module loading helper functions */
end_comment

begin_comment
comment|/* created by Michael K. Johnson, johnsonm@redhat.com  *  * $Id: pam_static.c,v 1.4 1996/12/01 03:14:13 morgan Exp $  *  * $Log: pam_static.c,v $  * Revision 1.4  1996/12/01 03:14:13  morgan  * use _pam_macros.h  *  * Revision 1.3  1996/11/10 20:09:16  morgan  * name convention change _pam_  *  * Revision 1.2  1996/06/02 08:02:56  morgan  * Michael's minor alterations  *  * Revision 1.1  1996/05/26 04:34:04  morgan  * Initial revision  *  */
end_comment

begin_comment
comment|/* This whole file is only used for PAM_STATIC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pam_private.h"
end_include

begin_comment
comment|/*  * Need to include pointers to static modules; this was built by each  * of the modules that register...  */
end_comment

begin_include
include|#
directive|include
file|"../modules/_static_module_list"
end_include

begin_comment
comment|/*  * and here is a structure that connects libpam to the above static  * modules  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pam_module
modifier|*
name|static_modules
index|[]
init|=
block|{
include|#
directive|include
file|"../modules/_static_module_entry"
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * and now for the functions  */
end_comment

begin_comment
comment|/* Return pointer to data structure used to define a static module */
end_comment

begin_function
name|struct
name|pam_module
modifier|*
name|_pam_open_static_handler
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|lpath
init|=
name|path
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|lpath
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* ignore path and leading "/" */
name|lpath
operator|=
name|strrchr
argument_list|(
name|lpath
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* create copy to muck with (must free before return) */
name|lpath
operator|=
name|_pam_strdup
argument_list|(
name|lpath
argument_list|)
expr_stmt|;
comment|/* chop .so off copy if it exists (or other extension on other        platform...) */
name|end
operator|=
name|strstr
argument_list|(
name|lpath
argument_list|,
literal|".so"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* now go find the module */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|static_modules
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|D
argument_list|(
operator|(
literal|"%s=?%s\n"
operator|,
name|lpath
operator|,
name|static_modules
index|[
name|i
index|]
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_modules
index|[
name|i
index|]
operator|->
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|static_modules
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|lpath
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|static_modules
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pam_system_log
argument_list|(
name|pamh
argument_list|,
name|NULL
argument_list|,
name|LOG_ERR
argument_list|,
literal|"no static module named %s"
argument_list|,
name|lpath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|static_modules
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return pointer to function requested from static module  * Can't just return void *, because ANSI C disallows casting a  * pointer to a function to a void *...  * This definition means:  * _pam_get_static_sym is a function taking two arguments and  * returning a pointer to a function which takes no arguments  * and returns void... */
end_comment

begin_function
name|voidfunc
modifier|*
name|_pam_get_static_sym
parameter_list|(
name|struct
name|pam_module
modifier|*
name|mod
parameter_list|,
specifier|const
name|char
modifier|*
name|symname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"pam_sm_authenticate"
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|mod
operator|->
name|pam_sm_authenticate
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"pam_sm_setcred"
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|mod
operator|->
name|pam_sm_setcred
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"pam_sm_acct_mgmt"
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|mod
operator|->
name|pam_sm_acct_mgmt
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"pam_sm_open_session"
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|mod
operator|->
name|pam_sm_open_session
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"pam_sm_close_session"
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|mod
operator|->
name|pam_sm_close_session
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"pam_sm_chauthtok"
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|mod
operator|->
name|pam_sm_chauthtok
operator|)
return|;
block|}
comment|/* getting to this point is an error */
return|return
operator|(
operator|(
name|voidfunc
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PAM_STATIC */
end_comment

begin_comment
comment|/*  * Copyright (C) 1995 by Red Hat Software, Michael K. Johnson  * All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *   * ALTERNATIVELY, this product may be distributed under the terms of  * the GNU Public License, in which case the provisions of the GPL are  * required INSTEAD OF the above restrictions.  (This clause is  * necessary due to a potential bad interaction between the GPL and  * the restrictions contained in a BSD-style copyright.)  *   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

end_unit

