begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: pam_malloc.c,v 1.3 2000/12/04 19:02:34 baggins Exp $  */
end_comment

begin_comment
comment|/*  * This pair of files helps to locate memory leaks. It is a wrapper for  * the malloc family of calls. (Actutally, it currently only deals  * with calloc, malloc, realloc, free and exit)  *  * To use these functions the header "pam_malloc.h" must be included  * in all parts of the code (that use the malloc functions) and this  * file must be linked with the result. The pam_malloc_flags can be  * set from another function and determine the level of logging.  *  * The output is via the macros defined in _pam_macros.h  *  * It is a debugging tool and should be turned off in released code.  *  * This suite was written by Andrew Morgan<morgan@parc.power.net> for  * Linux-PAM.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pam_private.h"
end_include

begin_include
include|#
directive|include
file|<security/pam_malloc.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_comment
comment|/* this must be done to stop infinite recursion! */
end_comment

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_undef
undef|#
directive|undef
name|exit
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * default debugging level  */
end_comment

begin_decl_stmt
name|int
name|pam_malloc_flags
init|=
name|PAM_MALLOC_ALL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pam_malloc_delay_length
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|on
parameter_list|(
name|x
parameter_list|)
value|((pam_malloc_flags&(x))==(x))
end_define

begin_comment
comment|/*  * the implementation  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_fn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_call
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_line
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|err
parameter_list|(
name|x
parameter_list|)
value|{ _pam_output_xdebug_info(); _pam_output_debug x ; }
end_define

begin_function
specifier|static
name|void
name|set_last_
parameter_list|(
specifier|const
name|char
modifier|*
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|l
parameter_list|)
block|{
name|last_fn
operator|=
name|x
condition|?
name|x
else|:
literal|"error-in-pam_malloc.."
expr_stmt|;
name|last_file
operator|=
name|f
condition|?
name|f
else|:
literal|"*bad-file*"
expr_stmt|;
name|last_call
operator|=
name|fn
condition|?
name|fn
else|:
literal|"*bad-fn*"
expr_stmt|;
name|last_line
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_pam_output_xdebug_info
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|logfile
decl_stmt|;
name|int
name|must_close
init|=
literal|1
decl_stmt|,
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|O_NOFOLLOW
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PAM_LOGFILE
argument_list|,
name|O_WRONLY
operator||
name|O_NOFOLLOW
operator||
name|O_APPEND
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PAM_LOGFILE
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|logfile
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"a"
argument_list|)
operator|)
condition|)
block|{
name|logfile
operator|=
name|stderr
expr_stmt|;
name|must_close
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logfile
operator|=
name|stderr
expr_stmt|;
name|must_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"[%s:%s(%d)->%s()] "
argument_list|,
name|last_file
argument_list|,
name|last_call
argument_list|,
name|last_line
argument_list|,
name|last_fn
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_close
condition|)
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|hinder
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_PAUSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"pause requested"
operator|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|pam_malloc_delay_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_STOP
argument_list|)
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"stop requested"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * here are the memory pointer registering functions.. these actually  * use malloc(!) but that's ok! ;^)  */
struct|struct
name|reference
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
comment|/* pointer */
name|int
name|nelements
decl_stmt|;
comment|/* number of elements */
name|int
name|size
decl_stmt|;
comment|/* - each of this size */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* where it was requested - filename */
name|char
modifier|*
name|function
decl_stmt|;
comment|/*                        - function */
name|int
name|line
decl_stmt|;
comment|/*                        - line number */
comment|/*  * linking info  */
name|struct
name|reference
modifier|*
name|next
decl_stmt|;
block|}
struct|;
specifier|static
name|void
name|_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|say
parameter_list|,
specifier|const
name|struct
name|reference
modifier|*
name|ref
parameter_list|)
block|{
name|_pam_output_debug
argument_list|(
literal|"<%s: %p (#%d of %d) req. by %s(); %s line %d>\n"
argument_list|,
name|say
argument_list|,
name|ref
operator|->
name|ptr
argument_list|,
name|ref
operator|->
name|nelements
argument_list|,
name|ref
operator|->
name|size
argument_list|,
name|ref
operator|->
name|function
argument_list|,
name|ref
operator|->
name|file
argument_list|,
name|ref
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
specifier|static
name|struct
name|reference
modifier|*
name|root
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|x
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"_strdup failed"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
specifier|static
name|void
name|add_new_ref
parameter_list|(
name|void
modifier|*
name|new
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|reference
modifier|*
name|ref
init|=
name|NULL
decl_stmt|;
name|ref
operator|=
operator|(
expr|struct
name|reference
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reference
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
operator|||
name|ref
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"internal error {add_new_ref}"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ref
operator|->
name|ptr
operator|=
name|new
expr_stmt|;
name|ref
operator|->
name|nelements
operator|=
name|n
expr_stmt|;
name|ref
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|ref
operator|->
name|file
operator|=
name|_strdup
argument_list|(
name|last_file
argument_list|)
expr_stmt|;
name|ref
operator|->
name|function
operator|=
name|_strdup
argument_list|(
name|last_call
argument_list|)
expr_stmt|;
name|ref
operator|->
name|line
operator|=
name|last_line
expr_stmt|;
name|ref
operator|->
name|next
operator|=
name|root
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_REQUEST
argument_list|)
condition|)
block|{
name|_dump
argument_list|(
literal|"new_ptr"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
name|root
operator|=
name|ref
expr_stmt|;
block|}
specifier|static
name|void
name|del_old_ref
parameter_list|(
name|void
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|reference
modifier|*
name|this
decl_stmt|,
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"internal error {del_old_ref}"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* locate old pointer */
name|last
operator|=
name|NULL
expr_stmt|;
name|this
operator|=
name|root
expr_stmt|;
while|while
condition|(
name|this
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|ptr
operator|==
name|old
condition|)
break|break;
name|last
operator|=
name|this
expr_stmt|;
name|this
operator|=
name|this
operator|->
name|next
expr_stmt|;
block|}
comment|/* Did we find a reference ? */
if|if
condition|(
name|this
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FREE
argument_list|)
condition|)
block|{
name|_dump
argument_list|(
literal|"free old_ptr"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
name|root
operator|=
name|this
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|last
operator|->
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|this
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|this
operator|->
name|function
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"ERROR!: bad memory"
operator|)
argument_list|)
expr_stmt|;
name|hinder
argument_list|()
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|verify_old_ref
parameter_list|(
name|void
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|reference
modifier|*
name|this
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"internal error {verify_old_ref}"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* locate old pointer */
name|this
operator|=
name|root
expr_stmt|;
while|while
condition|(
name|this
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|ptr
operator|==
name|old
condition|)
break|break;
name|this
operator|=
name|this
operator|->
name|next
expr_stmt|;
block|}
comment|/* Did we find a reference ? */
if|if
condition|(
name|this
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_VERIFY
argument_list|)
condition|)
block|{
name|_dump
argument_list|(
literal|"verify_ptr"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"ERROR!: bad request"
operator|)
argument_list|)
expr_stmt|;
name|hinder
argument_list|()
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|dump_memory_list
parameter_list|(
specifier|const
name|char
modifier|*
name|dump
parameter_list|)
block|{
name|struct
name|reference
modifier|*
name|this
decl_stmt|;
name|this
operator|=
name|root
expr_stmt|;
if|if
condition|(
name|this
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"un-free()'d memory"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|this
condition|)
block|{
name|_dump
argument_list|(
name|dump
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|=
name|this
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"no memory allocated"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now for the wrappers */
define|#
directive|define
name|_fn
parameter_list|(
name|x
parameter_list|)
value|set_last_(x,file,fn,line)
name|void
modifier|*
name|pam_malloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|_fn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FUNC
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"request for %d"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FAIL
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"returned NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_REQUEST
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"request new"
operator|)
argument_list|)
expr_stmt|;
name|add_new_ref
argument_list|(
name|new
argument_list|,
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
name|void
modifier|*
name|pam_calloc
parameter_list|(
name|size_t
name|nelm
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|_fn
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FUNC
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"request for %d of %d"
operator|,
name|nelm
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|calloc
argument_list|(
name|nelm
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FAIL
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"returned NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_REQUEST
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"request new"
operator|)
argument_list|)
expr_stmt|;
name|add_new_ref
argument_list|(
name|new
argument_list|,
name|nelm
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
name|void
name|pam_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|_fn
argument_list|(
literal|"free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FUNC
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"request to free %p"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_NULL
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"passed NULL pointer"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FREE
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"deleted old"
operator|)
argument_list|)
expr_stmt|;
name|del_old_ref
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|void
modifier|*
name|pam_memalign
parameter_list|(
name|size_t
name|ali
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|_fn
argument_list|(
literal|"memalign"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"not implemented currently (Sorry)"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|pam_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|_fn
argument_list|(
literal|"realloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FUNC
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"resize %p to %d"
operator|,
name|ptr
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_NULL
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"passed NULL pointer"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify_old_ref
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FAIL
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"returned NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_FREE
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"deleted old"
operator|)
argument_list|)
expr_stmt|;
name|del_old_ref
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_NULL
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"old is NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_REQUEST
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"request new"
operator|)
argument_list|)
expr_stmt|;
name|add_new_ref
argument_list|(
name|new
argument_list|,
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
name|void
modifier|*
name|pam_valloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|_fn
argument_list|(
literal|"valloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"not implemented currently (Sorry)"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
include|#
directive|include
file|<alloca.h>
name|void
modifier|*
name|pam_alloca
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|_fn
argument_list|(
literal|"alloca"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"not implemented currently (Sorry)"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|pam_exit
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|int
name|line
parameter_list|)
block|{
name|_fn
argument_list|(
literal|"exit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
literal|0
argument_list|)
condition|)
name|err
argument_list|(
operator|(
literal|"passed (%d)"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
argument_list|(
name|PAM_MALLOC_LEAKED
argument_list|)
condition|)
block|{
name|dump_memory_list
argument_list|(
literal|"leaked"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of file */
end_comment

end_unit

