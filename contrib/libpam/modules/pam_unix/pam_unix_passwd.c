begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main coding by Elliot Lee<sopwith@redhat.com>, Red Hat Software.     Copyright (C) 1996. */
end_comment

begin_comment
comment|/*  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *   * ALTERNATIVELY, this product may be distributed under the terms of  * the GNU Public License, in which case the provisions of the GPL are  * required INSTEAD OF the above restrictions.  (This clause is  * necessary due to a potential bad interaction between the GPL and  * the restrictions contained in a BSD-style copyright.)  *   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*   How it works:      Gets in username (has to be done) from the calling program      Does authentication of user (only if we are not running as root)      Gets new password/checks for sanity      Sets it.  */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_PASSWORD
end_define

begin_comment
comment|/* #define DEBUG 1 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|_BSD_SOURCE
end_define

begin_define
define|#
directive|define
name|_SVID_SOURCE
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|__USE_BSD
end_define

begin_define
define|#
directive|define
name|_BSD_SOURCE
end_define

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* why not defined? */
end_comment

begin_function_decl
name|void
name|setpwent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|endpwent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chmod
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|mode_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|passwd
modifier|*
name|fgetpwent
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|putpwent
parameter_list|(
specifier|const
name|struct
name|passwd
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function_decl
name|char
modifier|*
name|crypt
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CRACKLIB
end_ifdef

begin_include
include|#
directive|include
file|<crack.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LINUX
end_ifndef

begin_comment
comment|/* AGM added this as of 0.2 */
end_comment

begin_include
include|#
directive|include
file|<security/pam_appl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SHADOW_H
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_PASSWD_TRIES
value|3
end_define

begin_define
define|#
directive|define
name|OLD_PASSWORD_PROMPT
value|"Password: "
end_define

begin_define
define|#
directive|define
name|NEW_PASSWORD_PROMPT
value|"New password: "
end_define

begin_define
define|#
directive|define
name|AGAIN_PASSWORD_PROMPT
value|"New password (again): "
end_define

begin_define
define|#
directive|define
name|PW_TMPFILE
value|"/etc/npasswd"
end_define

begin_define
define|#
directive|define
name|SH_TMPFILE
value|"/etc/nshadow"
end_define

begin_define
define|#
directive|define
name|CRACKLIB_DICTS
value|"/usr/lib/cracklib_dict"
end_define

begin_comment
comment|/* Various flags for the getpass routine to send back in... */
end_comment

begin_define
define|#
directive|define
name|PPW_EXPIRED
value|1
end_define

begin_define
define|#
directive|define
name|PPW_EXPIRING
value|2
end_define

begin_define
define|#
directive|define
name|PPW_WILLEXPIRE
value|4
end_define

begin_define
define|#
directive|define
name|PPW_NOSUCHUSER
value|8
end_define

begin_define
define|#
directive|define
name|PPW_SHADOW
value|16
end_define

begin_define
define|#
directive|define
name|PPW_TOOEARLY
value|32
end_define

begin_define
define|#
directive|define
name|PPW_ERROR
value|64
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DO_TEST
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STATIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sets a password for the specified user to the specified password    Returns flags PPW_*, or'd. */
end_comment

begin_function_decl
name|STATIC
name|int
name|_do_setpass
parameter_list|(
name|char
modifier|*
name|forwho
parameter_list|,
name|char
modifier|*
name|towhat
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Gets a password for the specified user    Returns flags PPW_*, or'd. */
end_comment

begin_function_decl
name|STATIC
name|int
name|_do_getpass
parameter_list|(
name|char
modifier|*
name|forwho
parameter_list|,
name|char
modifier|*
modifier|*
name|theirpass
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Checks whether the password entered is same as listed in the database    'entered' should not be crypt()'d or anything (it should be as the    user entered it...), 'listed' should be as it is listed in the    password database file */
end_comment

begin_function_decl
name|STATIC
name|int
name|_do_checkpass
parameter_list|(
specifier|const
name|char
modifier|*
name|entered
parameter_list|,
name|char
modifier|*
name|listed
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sends a one-way message to the user, either error or info... */
end_comment

begin_function_decl
name|STATIC
name|int
name|conv_sendmsg
parameter_list|(
name|struct
name|pam_conv
modifier|*
name|aconv
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|int
name|style
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sends a message and returns the results of the conversation */
end_comment

begin_function_decl
name|STATIC
name|int
name|conv_getitem
parameter_list|(
name|struct
name|pam_conv
modifier|*
name|aconv
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|style
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|PAM_EXTERN
name|int
name|pam_sm_chauthtok
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|_pam_log
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"PAM-unix_passwd"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_LCKPWDF
end_ifdef

begin_comment
comment|/* This is a hack, but until libc and glibc both include this function  * by default (libc only includes it if nys is not being used, at the  * moment, and glibc doesn't appear to have it at all) we need to have  * it here, too.  :-(  *  * This should not become an official part of PAM.  *  * BEGIN_HACK */
end_comment

begin_comment
comment|/*  * lckpwdf.c -- prevent simultaneous updates of password files  *  * Before modifying any of the password files, call lckpwdf().  It may block  * for up to 15 seconds trying to get the lock.  Return value is 0 on success  * or -1 on failure.  When you are done, call ulckpwdf() to release the lock.  * The lock is also released automatically when the process exits.  Only one  * process at a time may hold the lock.  *  * These functions are supposed to be conformant with AT&T SVID Issue 3.  *  * Written by Marek Michalkiewicz<marekm@i17linuxb.ists.pwr.wroc.pl>,  * public domain.  */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|LOCKFILE
value|"/etc/.pwd.lock"
end_define

begin_define
define|#
directive|define
name|TIMEOUT
value|15
end_define

begin_decl_stmt
specifier|static
name|int
name|lockfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|set_close_on_exec
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|flags
init|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|flags
operator||=
name|FD_CLOEXEC
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_lock
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|flock
name|fl
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|fl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|alarm_catch
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* does nothing, but fcntl F_SETLKW will fail with EINTR */
block|}
end_function

begin_function
specifier|static
name|int
name|lckpwdf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oldact
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oldset
decl_stmt|;
if|if
condition|(
name|lockfd
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|lockfd
operator|=
name|open
argument_list|(
name|LOCKFILE
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfd
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|set_close_on_exec
argument_list|(
name|lockfd
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cleanup_fd
goto|;
name|memset
argument_list|(
operator|&
name|act
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|act
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|alarm_catch
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oldact
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cleanup_fd
goto|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oldset
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cleanup_sig
goto|;
name|alarm
argument_list|(
name|TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lock
argument_list|(
name|lockfd
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cleanup_alarm
goto|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oldset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|oldact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|cleanup_alarm
label|:
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oldset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cleanup_sig
label|:
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|oldact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cleanup_fd
label|:
name|close
argument_list|(
name|lockfd
argument_list|)
expr_stmt|;
name|lockfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ulckpwdf
parameter_list|(
name|void
parameter_list|)
block|{
name|unlink
argument_list|(
name|LOCKFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfd
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|close
argument_list|(
name|lockfd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|lockfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lockfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* END_HACK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAM_FAIL_CHECK
value|if(retval != PAM_SUCCESS) { return retval; }
end_define

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_chauthtok
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|usrname
decl_stmt|,
modifier|*
name|curpass
decl_stmt|,
modifier|*
name|newpass
decl_stmt|;
comment|/* pointers to the username, 					current password, and new password */
name|struct
name|pam_conv
modifier|*
name|appconv
decl_stmt|;
comment|/* conversation with the app */
name|struct
name|pam_message
name|msg
decl_stmt|,
modifier|*
name|pmsg
decl_stmt|;
comment|/* Misc for conversations */
name|struct
name|pam_response
modifier|*
name|resp
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Gets the return values for all our function calls */
name|unsigned
name|int
name|pflags
init|=
literal|0
decl_stmt|;
comment|/* Holds the flags from our getpass& setpass 			 functions */
specifier|const
name|char
modifier|*
name|cmiscptr
decl_stmt|;
comment|/* Utility variables, used for different purposes at 		    different times */
name|char
modifier|*
name|miscptr
decl_stmt|;
comment|/* Utility variables, used for different purposes at 		    different times */
name|unsigned
name|int
name|miscint
decl_stmt|;
name|int
name|fascist
init|=
literal|1
decl_stmt|;
comment|/* Be fascist by default.  If compiled with cracklib,                       call cracklib.  Otherwise just check length... */
name|char
name|argbuf
index|[
literal|256
index|]
decl_stmt|,
name|argval
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_CONV
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|appconv
argument_list|)
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_USER
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|usrname
argument_list|)
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PAM_PRELIM_CHECK
condition|)
block|{
name|pflags
operator|=
name|_do_getpass
argument_list|(
name|usrname
argument_list|,
operator|&
name|miscptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflags
operator|&
name|PPW_NOSUCHUSER
condition|)
return|return
name|PAM_USER_UNKNOWN
return|;
elseif|else
if|if
condition|(
name|pflags
operator|&
operator|~
operator|(
name|PPW_SHADOW
operator||
name|PPW_EXPIRING
operator||
name|PPW_WILLEXPIRE
operator|)
condition|)
return|return
name|PAM_AUTHTOK_ERR
return|;
else|else
return|return
name|PAM_SUCCESS
return|;
block|}
comment|/* else... */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got username of %s\n"
argument_list|,
name|usrname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|usrname
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|usrname
argument_list|)
operator|<
literal|1
operator|)
condition|)
block|{
comment|/* The app is supposed to get us the username! */
name|retval
operator|=
name|PAM_USER_UNKNOWN
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
block|{
name|char
modifier|*
name|tmp
init|=
name|x_strdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|argbuf
argument_list|,
name|strtok
argument_list|(
name|tmp
argument_list|,
literal|"="
argument_list|)
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|argval
argument_list|,
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"="
argument_list|)
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* For PC functionality use "strict" -- historically "fascist" */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argbuf
argument_list|,
literal|"strict"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argbuf
argument_list|,
literal|"fascist"
argument_list|)
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argval
argument_list|,
literal|"true"
argument_list|)
condition|)
name|fascist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argval
argument_list|,
literal|"false"
argument_list|)
condition|)
name|fascist
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|PAM_SERVICE_ERR
return|;
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown option: %s"
argument_list|,
name|argbuf
argument_list|)
expr_stmt|;
return|return
name|PAM_SERVICE_ERR
return|;
block|}
block|}
comment|/* Now we have all the initial information we need from the app to      set things up (we assume that getting the username succeeded...) */
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_OLDAUTHTOK
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|curpass
argument_list|)
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
comment|/* If this is being run by root, we don't need to get their 		    old password. 		    note */
comment|/* If we haven't been given a password yet, prompt for one... */
name|miscint
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|curpass
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|miscint
operator|++
operator|<
name|MAX_PASSWD_TRIES
operator|)
condition|)
block|{
name|pflags
operator|=
name|_do_getpass
argument_list|(
name|usrname
argument_list|,
operator|&
name|miscptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflags
operator|&
name|PPW_NOSUCHUSER
condition|)
return|return
name|PAM_USER_UNKNOWN
return|;
comment|/* If the user that was passed in doesn't 				    exist, say so and exit (app passes in 				    username) */
comment|/* Get the password from the user... */
name|pmsg
operator|=
operator|&
name|msg
expr_stmt|;
name|msg
operator|.
name|msg_style
operator|=
name|PAM_PROMPT_ECHO_OFF
expr_stmt|;
name|msg
operator|.
name|msg
operator|=
name|OLD_PASSWORD_PROMPT
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|appconv
operator|->
name|conv
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
operator|&
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|,
name|appconv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
name|curpass
operator|=
name|resp
operator|->
name|resp
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_do_checkpass
argument_list|(
name|curpass
condition|?
name|curpass
else|:
literal|""
argument_list|,
name|miscptr
argument_list|)
condition|)
block|{
name|int
name|abortme
init|=
literal|0
decl_stmt|;
comment|/* password is incorrect... */
if|if
condition|(
name|curpass
operator|&&
name|curpass
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* ...and it was zero-length; user wishes to abort change */
name|abortme
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|curpass
condition|)
block|{
name|free
argument_list|(
name|curpass
argument_list|)
expr_stmt|;
block|}
name|curpass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|abortme
condition|)
block|{
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"Password change aborted."
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
block|}
block|}
if|if
condition|(
name|curpass
operator|==
name|NULL
condition|)
return|return
name|PAM_AUTH_ERR
return|;
comment|/* They didn't seem to enter the right password 			      for three tries - error */
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_OLDAUTHTOK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|curpass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"I am ROOT!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pflags
operator|=
name|_do_getpass
argument_list|(
name|usrname
argument_list|,
operator|&
name|curpass
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpass
operator|==
name|NULL
condition|)
name|curpass
operator|=
name|x_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pflags
operator|&
name|PPW_TOOEARLY
condition|)
block|{
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"You must wait longer to change your password"
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
if|if
condition|(
name|pflags
operator|&
name|PPW_WILLEXPIRE
condition|)
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"Your password is about to expire"
argument_list|,
name|PAM_TEXT_INFO
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pflags
operator|&
name|PPW_EXPIRED
condition|)
return|return
name|PAM_ACCT_EXPIRED
return|;
comment|/* If their account has expired, we can't auth 				them to change their password */
if|if
condition|(
operator|!
operator|(
name|pflags
operator|&
name|PPW_EXPIRING
operator|)
operator|&&
operator|(
name|flags
operator|&
name|PAM_CHANGE_EXPIRED_AUTHTOK
operator|)
condition|)
return|return
name|PAM_SUCCESS
return|;
comment|/* If we haven't been given a password yet, prompt for one... */
name|miscint
operator|=
literal|0
expr_stmt|;
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|newpass
argument_list|)
expr_stmt|;
name|cmiscptr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|newpass
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|miscint
operator|++
operator|<
name|MAX_PASSWD_TRIES
operator|)
condition|)
block|{
comment|/* Get the password from the user... */
name|pmsg
operator|=
operator|&
name|msg
expr_stmt|;
name|msg
operator|.
name|msg_style
operator|=
name|PAM_PROMPT_ECHO_OFF
expr_stmt|;
name|msg
operator|.
name|msg
operator|=
name|NEW_PASSWORD_PROMPT
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|appconv
operator|->
name|conv
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
operator|&
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|,
name|appconv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
name|newpass
operator|=
name|resp
operator|->
name|resp
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|newpass
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got password of %s\n"
argument_list|,
name|newpass
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No new password...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newpass
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|newpass
argument_list|)
expr_stmt|;
name|newpass
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|cmiscptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newpass
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_CRACKLIB
if|if
condition|(
name|fascist
operator|&&
name|getuid
argument_list|()
condition|)
name|cmiscptr
operator|=
name|FascistCheck
argument_list|(
name|newpass
argument_list|,
name|CRACKLIB_DICTS
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fascist
operator|&&
name|getuid
argument_list|()
operator|&&
name|strlen
argument_list|(
name|newpass
argument_list|)
operator|<
literal|6
condition|)
name|cmiscptr
operator|=
literal|"You must choose a longer password"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curpass
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|curpass
argument_list|,
name|newpass
argument_list|)
condition|)
block|{
name|cmiscptr
operator|=
literal|"You must choose a new password."
expr_stmt|;
name|newpass
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We want to abort the password change */
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"Password change aborted"
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
if|if
condition|(
operator|!
name|cmiscptr
condition|)
block|{
comment|/* We ask them to enter their password again... */
comment|/* Get the password from the user... */
name|pmsg
operator|=
operator|&
name|msg
expr_stmt|;
name|msg
operator|.
name|msg_style
operator|=
name|PAM_PROMPT_ECHO_OFF
expr_stmt|;
name|msg
operator|.
name|msg
operator|=
name|AGAIN_PASSWORD_PROMPT
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|appconv
operator|->
name|conv
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
operator|&
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|,
name|appconv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
name|PAM_FAIL_CHECK
expr_stmt|;
name|miscptr
operator|=
name|resp
operator|->
name|resp
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|miscptr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|miscptr
argument_list|)
expr_stmt|;
name|miscptr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|miscptr
condition|)
block|{
comment|/* Aborting password change... */
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"Password change aborted"
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|newpass
argument_list|,
name|miscptr
argument_list|)
condition|)
block|{
name|miscptr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"You must enter the same password twice."
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
name|miscptr
operator|=
name|NULL
expr_stmt|;
name|newpass
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
name|cmiscptr
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
name|newpass
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmiscptr
condition|)
block|{
comment|/* conv_sendmsg(appconv,cmiscptr,PAM_ERROR_MSG); */
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
elseif|else
if|if
condition|(
name|newpass
operator|==
name|NULL
condition|)
return|return
name|PAM_AUTHTOK_ERR
return|;
comment|/* They didn't seem to enter the right password 			      for three tries - error */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Changing password for sure!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* From now on, we are bound and determined to get their password      changed :-) */
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|newpass
argument_list|)
expr_stmt|;
name|retval
operator|=
name|_do_setpass
argument_list|(
name|usrname
argument_list|,
name|newpass
argument_list|,
name|pflags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"retval was %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retval
operator|&
operator|~
name|PPW_SHADOW
condition|)
block|{
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"Error: Password NOT changed"
argument_list|,
name|PAM_ERROR_MSG
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
else|else
block|{
name|conv_sendmsg
argument_list|(
name|appconv
argument_list|,
literal|"Password changed"
argument_list|,
name|PAM_TEXT_INFO
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
block|}
end_function

begin_comment
comment|/* _do_checkpass() returns 0 on success, non-0 on failure */
end_comment

begin_function
name|STATIC
name|int
name|_do_checkpass
parameter_list|(
specifier|const
name|char
modifier|*
name|entered
parameter_list|,
name|char
modifier|*
name|listed
parameter_list|)
block|{
name|char
name|salt
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|listed
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|entered
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* no password in database; no password entered */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|salt
index|[
literal|0
index|]
operator|=
name|listed
index|[
literal|0
index|]
expr_stmt|;
name|salt
index|[
literal|1
index|]
operator|=
name|listed
index|[
literal|1
index|]
expr_stmt|;
name|salt
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|entered
argument_list|,
name|salt
argument_list|)
argument_list|,
name|listed
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
name|mksalt
parameter_list|(
name|int
name|seed
parameter_list|)
block|{
name|int
name|num
init|=
name|seed
operator|%
literal|64
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|26
condition|)
return|return
literal|'a'
operator|+
name|num
return|;
elseif|else
if|if
condition|(
name|num
operator|<
literal|52
condition|)
return|return
literal|'A'
operator|+
operator|(
name|num
operator|-
literal|26
operator|)
return|;
elseif|else
if|if
condition|(
name|num
operator|<
literal|62
condition|)
return|return
literal|'0'
operator|+
operator|(
name|num
operator|-
literal|52
operator|)
return|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|63
condition|)
return|return
literal|'.'
return|;
else|else
return|return
literal|'/'
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|_do_setpass
parameter_list|(
name|char
modifier|*
name|forwho
parameter_list|,
name|char
modifier|*
name|towhat
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmpent
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|pwfile
decl_stmt|,
modifier|*
name|opwfile
decl_stmt|;
name|char
name|thesalt
index|[
literal|3
index|]
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|time1
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SHADOW_H
name|struct
name|spwd
modifier|*
name|spwdent
init|=
name|NULL
decl_stmt|,
modifier|*
name|stmpent
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|PPW_SHADOW
condition|)
block|{
name|retval
operator||=
name|PPW_SHADOW
expr_stmt|;
block|}
name|gettimeofday
argument_list|(
operator|&
name|time1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|srand
argument_list|(
name|time1
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|thesalt
index|[
literal|0
index|]
operator|=
name|mksalt
argument_list|(
name|rand
argument_list|()
argument_list|)
expr_stmt|;
name|thesalt
index|[
literal|1
index|]
operator|=
name|mksalt
argument_list|(
name|rand
argument_list|()
argument_list|)
expr_stmt|;
name|thesalt
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* lock the entire password subsystem */
ifdef|#
directive|ifdef
name|USE_LCKPWDF
name|lckpwdf
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|setpwent
argument_list|()
expr_stmt|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|forwho
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Got %p, for %s (salt %s)\n"
argument_list|,
name|pwd
argument_list|,
name|forwho
argument_list|,
name|thesalt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
return|return
name|PPW_NOSUCHUSER
return|;
name|endpwent
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SHADOW_H
if|if
condition|(
name|flags
operator|&
name|PPW_SHADOW
condition|)
block|{
name|spwdent
operator|=
name|getspnam
argument_list|(
name|forwho
argument_list|)
expr_stmt|;
if|if
condition|(
name|spwdent
operator|==
name|NULL
condition|)
return|return
name|PPW_NOSUCHUSER
return|;
name|spwdent
operator|->
name|sp_pwdp
operator|=
name|towhat
expr_stmt|;
name|spwdent
operator|->
name|sp_lstchg
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
name|pwfile
operator|=
name|fopen
argument_list|(
name|SH_TMPFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|opwfile
operator|=
name|fopen
argument_list|(
literal|"/etc/shadow"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwfile
operator|==
name|NULL
operator|||
name|opwfile
operator|==
name|NULL
condition|)
return|return
name|PPW_ERROR
return|;
name|chown
argument_list|(
name|SH_TMPFILE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|SH_TMPFILE
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|stmpent
operator|=
name|fgetspent
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|stmpent
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|stmpent
operator|->
name|sp_namp
argument_list|,
name|forwho
argument_list|)
condition|)
block|{
name|stmpent
operator|->
name|sp_pwdp
operator|=
name|crypt
argument_list|(
name|towhat
argument_list|,
name|thesalt
argument_list|)
expr_stmt|;
name|stmpent
operator|->
name|sp_lstchg
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Set password %s for %s\n"
argument_list|,
name|stmpent
operator|->
name|sp_pwdp
argument_list|,
name|forwho
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|putspent
argument_list|(
name|stmpent
argument_list|,
name|pwfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing entry to shadow file: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|PPW_ERROR
expr_stmt|;
break|break;
block|}
name|stmpent
operator|=
name|fgetspent
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|pwfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing entries to shadow file: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PPW_ERROR
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|rename
argument_list|(
name|SH_TMPFILE
argument_list|,
literal|"/etc/shadow"
argument_list|)
expr_stmt|;
else|else
name|unlink
argument_list|(
name|SH_TMPFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pwd
operator|->
name|pw_passwd
operator|=
name|towhat
expr_stmt|;
name|pwfile
operator|=
name|fopen
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|opwfile
operator|=
name|fopen
argument_list|(
literal|"/etc/passwd"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwfile
operator|==
name|NULL
operator|||
name|opwfile
operator|==
name|NULL
condition|)
return|return
name|PPW_ERROR
return|;
name|chown
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|tmpent
operator|=
name|fgetpwent
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpent
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmpent
operator|->
name|pw_name
argument_list|,
name|forwho
argument_list|)
condition|)
block|{
name|tmpent
operator|->
name|pw_passwd
operator|=
name|crypt
argument_list|(
name|towhat
argument_list|,
name|thesalt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|putpwent
argument_list|(
name|tmpent
argument_list|,
name|pwfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing entry to password file: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|PPW_ERROR
expr_stmt|;
break|break;
block|}
name|tmpent
operator|=
name|fgetpwent
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|pwfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing entries to password file: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PPW_ERROR
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|rename
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|"/etc/passwd"
argument_list|)
expr_stmt|;
else|else
name|unlink
argument_list|(
name|PW_TMPFILE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|pwd
operator|->
name|pw_passwd
operator|=
name|towhat
expr_stmt|;
name|pwfile
operator|=
name|fopen
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|opwfile
operator|=
name|fopen
argument_list|(
literal|"/etc/passwd"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwfile
operator|==
name|NULL
operator|||
name|opwfile
operator|==
name|NULL
condition|)
return|return
name|PPW_ERROR
return|;
name|chown
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|tmpent
operator|=
name|fgetpwent
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpent
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmpent
operator|->
name|pw_name
argument_list|,
name|forwho
argument_list|)
condition|)
block|{
name|tmpent
operator|->
name|pw_passwd
operator|=
name|crypt
argument_list|(
name|towhat
argument_list|,
name|thesalt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|putpwent
argument_list|(
name|tmpent
argument_list|,
name|pwfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing entry to shadow file: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|PPW_ERROR
expr_stmt|;
break|break;
block|}
name|tmpent
operator|=
name|fgetpwent
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|opwfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|pwfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error writing entries to password file: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PPW_ERROR
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|rename
argument_list|(
name|PW_TMPFILE
argument_list|,
literal|"/etc/passwd"
argument_list|)
expr_stmt|;
else|else
name|unlink
argument_list|(
name|PW_TMPFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* unlock the entire password subsystem */
ifdef|#
directive|ifdef
name|USE_LCKPWDF
name|ulckpwdf
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|_do_getpass
parameter_list|(
name|char
modifier|*
name|forwho
parameter_list|,
name|char
modifier|*
modifier|*
name|theirpass
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
comment|/* Password and shadow password */
ifdef|#
directive|ifdef
name|HAVE_SHADOW_H
name|struct
name|spwd
modifier|*
name|spwdent
init|=
name|NULL
decl_stmt|;
comment|/* file entries for the user */
name|time_t
name|curdays
decl_stmt|;
endif|#
directive|endif
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* UNIX passwords area */
name|setpwent
argument_list|()
expr_stmt|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|forwho
argument_list|)
expr_stmt|;
comment|/* Get password file entry... */
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
return|return
name|PPW_NOSUCHUSER
return|;
comment|/* We don't need to do the rest... */
ifdef|#
directive|ifdef
name|HAVE_SHADOW_H
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
literal|"x"
argument_list|)
condition|)
block|{
comment|/* ...and shadow password file entry for this user, if shadowing        is enabled */
name|retval
operator||=
name|PPW_SHADOW
expr_stmt|;
name|setspent
argument_list|()
expr_stmt|;
name|spwdent
operator|=
name|getspnam
argument_list|(
name|forwho
argument_list|)
expr_stmt|;
name|endspent
argument_list|()
expr_stmt|;
if|if
condition|(
name|spwdent
operator|==
name|NULL
condition|)
return|return
name|PPW_NOSUCHUSER
return|;
operator|*
name|theirpass
operator|=
name|x_strdup
argument_list|(
name|spwdent
operator|->
name|sp_pwdp
argument_list|)
expr_stmt|;
comment|/* We have the user's information, now let's check if their account      has expired (60 * 60 * 24 = number of seconds in a day) */
comment|/* Get the current number of days since 1970 */
name|curdays
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|curdays
operator|<
operator|(
name|spwdent
operator|->
name|sp_lstchg
operator|+
name|spwdent
operator|->
name|sp_min
operator|)
operator|)
operator|&&
operator|(
name|spwdent
operator|->
name|sp_min
operator|!=
operator|-
literal|1
operator|)
condition|)
name|retval
operator||=
name|PPW_TOOEARLY
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curdays
operator|>
operator|(
name|spwdent
operator|->
name|sp_lstchg
operator|+
name|spwdent
operator|->
name|sp_max
operator|+
name|spwdent
operator|->
name|sp_inact
operator|)
operator|)
operator|&&
operator|(
name|spwdent
operator|->
name|sp_max
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|spwdent
operator|->
name|sp_inact
operator|!=
operator|-
literal|1
operator|)
condition|)
comment|/* Their password change has been put off too long, 	 OR their account has just plain expired */
name|retval
operator||=
name|PPW_EXPIRED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curdays
operator|>
operator|(
name|spwdent
operator|->
name|sp_lstchg
operator|+
name|spwdent
operator|->
name|sp_max
operator|)
operator|)
operator|&&
operator|(
name|spwdent
operator|->
name|sp_max
operator|!=
operator|-
literal|1
operator|)
condition|)
comment|/* Their passwd needs to be changed */
name|retval
operator||=
name|PPW_EXPIRING
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curdays
operator|>
operator|(
name|spwdent
operator|->
name|sp_lstchg
operator|+
name|spwdent
operator|->
name|sp_max
operator|-
name|spwdent
operator|->
name|sp_warn
operator|)
operator|)
operator|&&
operator|(
name|spwdent
operator|->
name|sp_max
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|spwdent
operator|->
name|sp_warn
operator|!=
operator|-
literal|1
operator|)
condition|)
name|retval
operator||=
name|PPW_WILLEXPIRE
expr_stmt|;
comment|/*    if(spwdent->sp_lstchg< 0)       retval&= ~(PPW_WILLEXPIRE | PPW_EXPIRING | PPW_EXPIRED);     if(spwdent->sp_max< 0)       retval&= ~(PPW_EXPIRING | PPW_EXPIRED); */
block|}
else|else
block|{
operator|*
name|theirpass
operator|=
operator|(
name|char
operator|*
operator|)
name|x_strdup
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|*
name|theirpass
operator|=
operator|(
name|char
operator|*
operator|)
name|x_strdup
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|conv_sendmsg
parameter_list|(
name|struct
name|pam_conv
modifier|*
name|aconv
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|int
name|style
parameter_list|)
block|{
name|struct
name|pam_message
name|msg
decl_stmt|,
modifier|*
name|pmsg
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|resp
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* Get the password from the user... */
name|pmsg
operator|=
operator|&
name|msg
expr_stmt|;
name|msg
operator|.
name|msg_style
operator|=
name|style
expr_stmt|;
name|msg
operator|.
name|msg
operator|=
name|message
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|aconv
operator|->
name|conv
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
operator|&
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|,
name|aconv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|_pam_drop_reply
argument_list|(
name|resp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|conv_getitem
parameter_list|(
name|struct
name|pam_conv
modifier|*
name|aconv
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|style
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pam_message
name|msg
decl_stmt|,
modifier|*
name|pmsg
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|resp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"called."
operator|)
argument_list|)
expr_stmt|;
comment|/* Get the password from the user... */
name|pmsg
operator|=
operator|&
name|msg
expr_stmt|;
name|msg
operator|.
name|msg_style
operator|=
name|style
expr_stmt|;
name|msg
operator|.
name|msg
operator|=
name|message
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|aconv
operator|->
name|conv
argument_list|(
literal|1
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
operator|&
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|,
name|aconv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
return|return
name|retval
return|;
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|result
operator|=
name|resp
operator|->
name|resp
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
else|else
return|return
name|PAM_SERVICE_ERR
return|;
block|}
end_function

end_unit

