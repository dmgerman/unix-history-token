begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This function implements the "bigcrypt" algorithm specifically for  * Linux-PAM.  *    * This algorithm is algorithm 0 (default) shipped with the C2 secure  * implementation of Digital UNIX.  *   * Disclaimer: This work is not based on the source code to Digital  * UNIX, nor am I connected to Digital Equipment Corp, in any way  * other than as a customer. This code is based on published  * interfaces and reasonable guesswork.  *   * Description: The cleartext is divided into blocks of SEGMENT_SIZE=8  * characters or less. Each block is encrypted using the standard UNIX  * libc crypt function. The result of the encryption for one block  * provides the salt for the suceeding block.  *   * Restrictions: The buffer used to hold the encrypted result is  * statically allocated. (see MAX_PASS_LEN below).  This is necessary,  * as the returned pointer points to "static data that are overwritten  * by each call", (XPG3: XSI System Interface + Headers pg 109), and  * this is a drop in replacement for crypt();  *  * Andy Phillips<atp@mssl.ucl.ac.uk>  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_function_decl
name|char
modifier|*
name|crypt
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|bigcrypt
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Max cleartext password length in segments of 8 characters this  * function can deal with (16 segments of 8 chars= max 128 character  * password).  */
end_comment

begin_define
define|#
directive|define
name|MAX_PASS_LEN
value|16
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|SALT_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|KEYBUF_SIZE
value|((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)
end_define

begin_define
define|#
directive|define
name|ESEGMENT_SIZE
value|11
end_define

begin_define
define|#
directive|define
name|CBUF_SIZE
value|((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)
end_define

begin_function
name|char
modifier|*
name|bigcrypt
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
block|{
specifier|static
name|char
name|dec_c2_cryptbuf
index|[
name|CBUF_SIZE
index|]
decl_stmt|;
comment|/* static storage area */
name|unsigned
name|long
name|int
name|keylen
decl_stmt|,
name|n_seg
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|cipher_ptr
decl_stmt|,
modifier|*
name|plaintext_ptr
decl_stmt|,
modifier|*
name|tmp_ptr
decl_stmt|,
modifier|*
name|salt_ptr
decl_stmt|;
name|char
name|keybuf
index|[
name|KEYBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"called with key='%s', salt='%s'."
operator|,
name|key
operator|,
name|salt
operator|)
argument_list|)
expr_stmt|;
comment|/* reset arrays */
name|memset
argument_list|(
name|keybuf
argument_list|,
literal|0
argument_list|,
name|KEYBUF_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dec_c2_cryptbuf
argument_list|,
literal|0
argument_list|,
name|CBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* fill KEYBUF_SIZE with key */
name|strncpy
argument_list|(
name|keybuf
argument_list|,
name|key
argument_list|,
name|KEYBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* deal with case that we are doing a password check for a 	   conventially encrypted password: the salt will be 	   SALT_SIZE+ESEGMENT_SIZE long. */
if|if
condition|(
name|strlen
argument_list|(
name|salt
argument_list|)
operator|==
operator|(
name|SALT_SIZE
operator|+
name|ESEGMENT_SIZE
operator|)
condition|)
name|keybuf
index|[
name|SEGMENT_SIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate password early(?) */
name|keylen
operator|=
name|strlen
argument_list|(
name|keybuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keylen
condition|)
block|{
name|n_seg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* work out how many segments */
name|n_seg
operator|=
literal|1
operator|+
operator|(
operator|(
name|keylen
operator|-
literal|1
operator|)
operator|/
name|SEGMENT_SIZE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|n_seg
operator|>
name|MAX_PASS_LEN
condition|)
name|n_seg
operator|=
name|MAX_PASS_LEN
expr_stmt|;
comment|/* truncate at max length */
comment|/* set up some pointers */
name|cipher_ptr
operator|=
name|dec_c2_cryptbuf
expr_stmt|;
name|plaintext_ptr
operator|=
name|keybuf
expr_stmt|;
comment|/* do the first block with supplied salt */
name|tmp_ptr
operator|=
name|crypt
argument_list|(
name|plaintext_ptr
argument_list|,
name|salt
argument_list|)
expr_stmt|;
comment|/* libc crypt() */
comment|/* and place in the static area */
name|strncpy
argument_list|(
name|cipher_ptr
argument_list|,
name|tmp_ptr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|cipher_ptr
operator|+=
name|ESEGMENT_SIZE
operator|+
name|SALT_SIZE
expr_stmt|;
name|plaintext_ptr
operator|+=
name|SEGMENT_SIZE
expr_stmt|;
comment|/* first block of SEGMENT_SIZE */
comment|/* change the salt (1st 2 chars of previous block) - this was found 	   by dowsing */
name|salt_ptr
operator|=
name|cipher_ptr
operator|-
name|ESEGMENT_SIZE
expr_stmt|;
comment|/* so far this is identical to "return crypt(key, salt);", if 	   there is more than one block encrypt them... */
if|if
condition|(
name|n_seg
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<=
name|n_seg
condition|;
name|j
operator|++
control|)
block|{
name|tmp_ptr
operator|=
name|crypt
argument_list|(
name|plaintext_ptr
argument_list|,
name|salt_ptr
argument_list|)
expr_stmt|;
comment|/* skip the salt for seg!=0 */
name|strncpy
argument_list|(
name|cipher_ptr
argument_list|,
operator|(
name|tmp_ptr
operator|+
name|SALT_SIZE
operator|)
argument_list|,
name|ESEGMENT_SIZE
argument_list|)
expr_stmt|;
name|cipher_ptr
operator|+=
name|ESEGMENT_SIZE
expr_stmt|;
name|plaintext_ptr
operator|+=
name|SEGMENT_SIZE
expr_stmt|;
name|salt_ptr
operator|=
name|cipher_ptr
operator|-
name|ESEGMENT_SIZE
expr_stmt|;
block|}
block|}
name|D
argument_list|(
operator|(
literal|"key=|%s|, salt=|%s|\nbuf=|%s|\n"
operator|,
name|key
operator|,
name|salt
operator|,
name|dec_c2_cryptbuf
operator|)
argument_list|)
expr_stmt|;
comment|/* this is the<NUL> terminated encrypted password */
return|return
name|dec_c2_cryptbuf
return|;
block|}
end_function

end_unit

