begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pam_cracklib module */
end_comment

begin_comment
comment|/*  * 0.85.  added six new options to use this with long passwords.  * 0.8. tidied output and improved D(()) usage for debugging.  * 0.7. added support for more obscure checks for new passwd.  * 0.6. root can reset user passwd to any values (it's only warned)  * 0.5. supports retries - 'retry=N' argument  * 0.4. added argument 'type=XXX' for 'New XXX password' prompt  * 0.3. Added argument 'debug'  * 0.2. new password is feeded to cracklib for verify after typed once  * 0.1. First release  */
end_comment

begin_comment
comment|/*  * Written by Cristian Gafton<gafton@redhat.com> 1996/09/10  * Long password support by Philip W. Dalrymple<pwd@mdtsoft.com> 1997/07/18  * See the end of the file for Copyright Information  *  * Modification for long password systems (>8 chars).  The original  * module had problems when used in a md5 password system in that it  * allowed too short passwords but required that at least half of the  * bytes in the new password did not appear in the old one.  this  * action is still the default and the changes should not break any  * current user. This modification adds 6 new options, one to set the  * number of bytes in the new password that are not in the old one,  * the other five to control the length checking, these are all  * documented (or will be before anyone else sees this code) in the PAM  * S.A.G. in the section on the cracklib module.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|__USE_BSD
end_define

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|FascistCheck
parameter_list|(
name|char
modifier|*
name|pw
parameter_list|,
specifier|const
name|char
modifier|*
name|dictpath
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CRACKLIB_DICTPATH
end_ifndef

begin_define
define|#
directive|define
name|CRACKLIB_DICTPATH
value|"/usr/lib/cracklib_dict"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROMPT1
value|"New %s password: "
end_define

begin_define
define|#
directive|define
name|PROMPT2
value|"Retype new %s password: "
end_define

begin_define
define|#
directive|define
name|MISTYPED_PASS
value|"Sorry, passwords do not match"
end_define

begin_comment
comment|/*  * here, we make a definition for the externally accessible function  * in this file (this definition is required for static a module  * but strongly encouraged generally) it is used to instruct the  * modules include file to define the function prototypes.  */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_PASSWORD
end_define

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LINUX_PAM
end_ifndef

begin_include
include|#
directive|include
file|<security/pam_appl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINUX_PAM */
end_comment

begin_comment
comment|/* some syslogging */
end_comment

begin_function
specifier|static
name|void
name|_pam_log
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"PAM-Cracklib"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* argument parsing */
end_comment

begin_define
define|#
directive|define
name|PAM_DEBUG_ARG
value|0x0001
end_define

begin_comment
comment|/* module data - AGM: please remove these static variables... PAM was  * designed to be reentrant based soley on a unique pamh... this  * breaks that.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|retry_times
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|diff_ok
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_length
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dig_credit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|up_credit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|low_credit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oth_credit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|prompt_type
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|_pam_parse
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ctrl
init|=
literal|0
decl_stmt|;
comment|/* step through arguments */
for|for
control|(
name|ctrl
operator|=
literal|0
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
operator|++
name|argv
control|)
block|{
name|char
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
comment|/* generic options */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"debug"
argument_list|)
condition|)
name|ctrl
operator||=
name|PAM_DEBUG_ARG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"type="
argument_list|,
literal|5
argument_list|)
condition|)
name|strcpy
argument_list|(
name|prompt_type
argument_list|,
operator|*
name|argv
operator|+
literal|5
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"retry="
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|retry_times
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|6
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|retry_times
operator|<
literal|1
operator|)
condition|)
name|retry_times
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"difok="
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|diff_ok
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|6
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|diff_ok
operator|<
literal|0
operator|)
condition|)
name|diff_ok
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"minlen="
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|min_length
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|7
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|min_length
operator|<
literal|5
operator|)
condition|)
name|min_length
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"dcredit="
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|dig_credit
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|8
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|dig_credit
operator|<
literal|0
operator|)
condition|)
name|dig_credit
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ucredit="
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|up_credit
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|8
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|up_credit
operator|<
literal|0
operator|)
condition|)
name|up_credit
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"lcredit="
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|low_credit
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|8
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|low_credit
operator|<
literal|0
operator|)
condition|)
name|low_credit
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ocredit="
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|oth_credit
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|8
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|(
name|oth_credit
operator|<
literal|0
operator|)
condition|)
name|oth_credit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_parse: unknown option; %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ctrl
return|;
block|}
end_function

begin_comment
comment|/* Helper functions */
end_comment

begin_comment
comment|/* this is a front-end for module-application conversations */
end_comment

begin_function
specifier|static
name|int
name|converse
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|ctrl
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|pam_message
modifier|*
modifier|*
name|message
parameter_list|,
name|struct
name|pam_response
modifier|*
modifier|*
name|response
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|pam_conv
modifier|*
name|conv
decl_stmt|;
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_CONV
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
condition|)
block|{
name|retval
operator|=
name|conv
operator|->
name|conv
argument_list|(
name|nargs
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
name|message
argument_list|,
name|response
argument_list|,
name|conv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
operator|&&
operator|(
name|ctrl
operator|&&
name|PAM_DEBUG_ARG
operator|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"conversation failure [%s]"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't obtain coversation function [%s]"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
comment|/* propagate error status */
block|}
end_function

begin_function
specifier|static
name|int
name|make_remark
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|unsigned
name|int
name|ctrl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
name|struct
name|pam_message
modifier|*
name|pmsg
index|[
literal|1
index|]
decl_stmt|,
name|msg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|resp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|pmsg
index|[
literal|0
index|]
operator|=
operator|&
name|msg
index|[
literal|0
index|]
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg
operator|=
name|text
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg_style
operator|=
name|type
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|converse
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
literal|1
argument_list|,
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
condition|)
name|_pam_drop_reply
argument_list|(
name|resp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* use this to free strings. ESPECIALLY password strings */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_pam_delete
parameter_list|(
specifier|register
name|char
modifier|*
name|xx
parameter_list|)
block|{
name|_pam_overwrite
argument_list|(
name|xx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * can't be a palindrome - like `R A D A R' or `M A D A M'  */
end_comment

begin_function
specifier|static
name|int
name|palindrome
parameter_list|(
specifier|const
name|char
modifier|*
name|old
parameter_list|,
specifier|const
name|char
modifier|*
name|new
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|new
index|[
name|i
operator|-
name|j
operator|-
literal|1
index|]
operator|!=
name|new
index|[
name|j
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * more than half of the characters are different ones.  * or at least diff_ok are different  * NOTE that the defaults are NOT the same as befor this  * change. as long as there are at least 10 different bytes  * in a new password it will now pass even if the password  * is longer than 20 bytes (MD5)  */
end_comment

begin_function
specifier|static
name|int
name|similiar
parameter_list|(
specifier|const
name|char
modifier|*
name|old
parameter_list|,
specifier|const
name|char
modifier|*
name|new
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|new
index|[
name|i
index|]
operator|&&
name|old
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|new
argument_list|,
name|old
index|[
name|i
index|]
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|diff_ok
operator|||
name|i
operator|>=
name|j
operator|*
literal|2
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * a nice mix of characters.  */
end_comment

begin_function
specifier|static
name|int
name|simple
parameter_list|(
specifier|const
name|char
modifier|*
name|old
parameter_list|,
specifier|const
name|char
modifier|*
name|new
parameter_list|)
block|{
name|int
name|digits
init|=
literal|0
decl_stmt|;
name|int
name|uppers
init|=
literal|0
decl_stmt|;
name|int
name|lowers
init|=
literal|0
decl_stmt|;
name|int
name|others
init|=
literal|0
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|new
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
condition|)
name|digits
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
condition|)
name|uppers
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
condition|)
name|lowers
operator|++
expr_stmt|;
else|else
name|others
operator|++
expr_stmt|;
block|}
comment|/* 	 * The scam was this - a password of only one character type 	 * must be 8 letters long.  Two types, 7, and so on. 	 * This is now changed, the base size and the credits or defaults 	 * see the docs on the module for info on these parameters, the 	 * defaults cause the effect to be the same as before the change 	 */
if|if
condition|(
name|digits
operator|>
name|dig_credit
condition|)
name|digits
operator|=
name|dig_credit
expr_stmt|;
if|if
condition|(
name|uppers
operator|>
name|up_credit
condition|)
name|uppers
operator|=
name|up_credit
expr_stmt|;
if|if
condition|(
name|lowers
operator|>
name|low_credit
condition|)
name|lowers
operator|=
name|low_credit
expr_stmt|;
if|if
condition|(
name|others
operator|>
name|oth_credit
condition|)
name|others
operator|=
name|oth_credit
expr_stmt|;
name|size
operator|=
name|min_length
expr_stmt|;
name|size
operator|-=
name|digits
expr_stmt|;
name|size
operator|-=
name|uppers
expr_stmt|;
name|size
operator|-=
name|lowers
expr_stmt|;
name|size
operator|-=
name|others
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|i
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|str_lower
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|password_check
parameter_list|(
specifier|const
name|char
modifier|*
name|old
parameter_list|,
specifier|const
name|char
modifier|*
name|new
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldmono
decl_stmt|,
modifier|*
name|newmono
decl_stmt|,
modifier|*
name|wrapped
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msg
operator|=
literal|"is the same as the old one"
expr_stmt|;
return|return
name|msg
return|;
block|}
name|newmono
operator|=
name|str_lower
argument_list|(
name|x_strdup
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|oldmono
operator|=
name|str_lower
argument_list|(
name|x_strdup
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|wrapped
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|oldmono
argument_list|)
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|wrapped
argument_list|,
name|oldmono
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|wrapped
argument_list|,
name|oldmono
argument_list|)
expr_stmt|;
if|if
condition|(
name|palindrome
argument_list|(
name|oldmono
argument_list|,
name|newmono
argument_list|)
condition|)
name|msg
operator|=
literal|"is a palindrome"
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|&&
name|strcmp
argument_list|(
name|oldmono
argument_list|,
name|newmono
argument_list|)
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"case changes only"
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|&&
name|similiar
argument_list|(
name|oldmono
argument_list|,
name|newmono
argument_list|)
condition|)
name|msg
operator|=
literal|"is too similiar to the old one"
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|&&
name|simple
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
name|msg
operator|=
literal|"is too simple"
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|&&
name|strstr
argument_list|(
name|wrapped
argument_list|,
name|newmono
argument_list|)
condition|)
name|msg
operator|=
literal|"is rotated"
expr_stmt|;
name|memset
argument_list|(
name|newmono
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|newmono
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|oldmono
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|oldmono
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|wrapped
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|wrapped
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newmono
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldmono
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wrapped
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_pam_unix_approve_pass
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|unsigned
name|int
name|ctrl
parameter_list|,
specifier|const
name|char
modifier|*
name|pass_old
parameter_list|,
specifier|const
name|char
modifier|*
name|pass_new
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pass_new
operator|==
name|NULL
operator|||
operator|(
name|pass_old
operator|&&
operator|!
name|strcmp
argument_list|(
name|pass_old
argument_list|,
name|pass_new
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bad authentication token"
argument_list|)
expr_stmt|;
name|make_remark
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|PAM_ERROR_MSG
argument_list|,
name|pass_new
operator|==
name|NULL
condition|?
literal|"No password supplied"
else|:
literal|"Password unchanged"
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
comment|/*      * if one wanted to hardwire authentication token strength      * checking this would be the place      */
name|msg
operator|=
name|password_check
argument_list|(
name|pass_old
argument_list|,
name|pass_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|char
name|remark
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|memset
argument_list|(
name|remark
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|remark
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|remark
argument_list|,
literal|"BAD PASSWORD: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|&&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"new passwd fails strength check: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|make_remark
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|PAM_ERROR_MSG
argument_list|,
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTHTOK_ERR
return|;
block|}
empty_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* The Main Thing (by Cristian Gafton, CEO at this module :-)   * (stolen from http://home.netscape.com)  */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_chauthtok
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|int
name|ctrl
decl_stmt|;
name|retry_times
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|prompt_type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt_type
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|_pam_parse
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"called."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_type
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|prompt_type
argument_list|,
literal|"UNIX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PAM_PRELIM_CHECK
condition|)
block|{
comment|/* Check for passwd dictionary */
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|CRACKLIB_DICTPATH
argument_list|)
operator|+
literal|10
index|]
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"prelim check"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the buffer */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.pwd"
argument_list|,
name|CRACKLIB_DICTPATH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|st
operator|.
name|st_size
condition|)
return|return
name|PAM_SUCCESS
return|;
else|else
block|{
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"dict path '%s'[.pwd] is invalid"
argument_list|,
name|CRACKLIB_DICTPATH
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* Not reached */
return|return
name|PAM_SERVICE_ERR
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|PAM_UPDATE_AUTHTOK
condition|)
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|token1
decl_stmt|,
modifier|*
name|token2
decl_stmt|,
modifier|*
name|oldtoken
decl_stmt|;
specifier|const
name|char
modifier|*
name|item
decl_stmt|;
name|struct
name|pam_message
name|msg
index|[
literal|1
index|]
decl_stmt|,
modifier|*
name|pmsg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|resp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cracklib_dictpath
init|=
name|CRACKLIB_DICTPATH
decl_stmt|;
name|char
name|prompt
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"do update"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_OLDAUTHTOK
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|oldtoken
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can not get old passwd"
argument_list|)
expr_stmt|;
name|oldtoken
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|PAM_SUCCESS
expr_stmt|;
block|}
do|do
block|{
comment|/*          * make sure nothing inappropriate gets returned          */
name|token1
operator|=
name|token2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|retry_times
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"returning %s because maxtries reached"
operator|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* Planned modus operandi:          * Get a passwd.          * Verify it against cracklib.          * If okay get it a second time.           * Check to be the same with the first one.          * set PAM_AUTHTOK and return          */
comment|/* Prepare to ask the user for the first time */
name|memset
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|PROMPT1
argument_list|,
name|prompt_type
argument_list|)
expr_stmt|;
name|pmsg
index|[
literal|0
index|]
operator|=
operator|&
name|msg
index|[
literal|0
index|]
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg_style
operator|=
name|PAM_PROMPT_ECHO_OFF
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg
operator|=
name|prompt
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|converse
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
literal|1
argument_list|,
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
block|{
comment|/* interpret the response */
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
condition|)
block|{
comment|/* a good conversation */
name|token1
operator|=
name|x_strdup
argument_list|(
name|resp
index|[
literal|0
index|]
operator|.
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token1
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"could not recover authentication token 1"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_AUTHTOK_RECOVER_ERR
expr_stmt|;
block|}
block|}
comment|/*              * tidy up the conversation (resp_retcode) is ignored              */
name|_pam_drop_reply
argument_list|(
name|resp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
operator|(
name|retval
operator|==
name|PAM_SUCCESS
operator|)
condition|?
name|PAM_AUTHTOK_RECOVER_ERR
else|:
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to obtain a password"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|D
argument_list|(
operator|(
literal|"testing password, retval = %s"
operator|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* now test this passwd against cracklib */
block|{
name|char
modifier|*
name|crack_msg
decl_stmt|;
name|char
name|remark
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|bzero
argument_list|(
name|remark
argument_list|,
sizeof|sizeof
argument_list|(
name|remark
argument_list|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"against cracklib"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crack_msg
operator|=
name|FascistCheck
argument_list|(
name|token1
argument_list|,
name|cracklib_dictpath
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bad password: %s"
argument_list|,
name|crack_msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|remark
argument_list|,
literal|"BAD PASSWORD: %s"
argument_list|,
name|crack_msg
argument_list|)
expr_stmt|;
name|make_remark
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|PAM_ERROR_MSG
argument_list|,
name|remark
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|||
operator|(
name|flags
operator|&
name|PAM_CHANGE_EXPIRED_AUTHTOK
operator|)
condition|)
name|retval
operator|=
name|PAM_AUTHTOK_ERR
expr_stmt|;
else|else
name|retval
operator|=
name|PAM_SUCCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* check it for strength too... */
name|D
argument_list|(
operator|(
literal|"for strength"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtoken
condition|)
block|{
name|retval
operator|=
name|_pam_unix_approve_pass
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|oldtoken
argument_list|,
name|token1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
if|if
condition|(
name|getuid
argument_list|()
operator|||
operator|(
name|flags
operator|&
name|PAM_CHANGE_EXPIRED_AUTHTOK
operator|)
condition|)
name|retval
operator|=
name|PAM_AUTHTOK_ERR
expr_stmt|;
else|else
name|retval
operator|=
name|PAM_SUCCESS
expr_stmt|;
block|}
block|}
block|}
name|D
argument_list|(
operator|(
literal|"after testing: retval = %s"
operator|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* if cracklib/strength check said it is a bad passwd... */
if|if
condition|(
operator|(
name|retval
operator|!=
name|PAM_SUCCESS
operator|)
operator|&&
operator|(
name|retval
operator|!=
name|PAM_IGNORE
operator|)
condition|)
block|{
name|int
name|temp_unused
decl_stmt|;
name|temp_unused
operator|=
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|token1
operator|=
name|_pam_delete
argument_list|(
name|token1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now we have a good passwd. Ask for it once again */
name|bzero
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|PROMPT2
argument_list|,
name|prompt_type
argument_list|)
expr_stmt|;
name|pmsg
index|[
literal|0
index|]
operator|=
operator|&
name|msg
index|[
literal|0
index|]
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg_style
operator|=
name|PAM_PROMPT_ECHO_OFF
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg
operator|=
name|prompt
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|converse
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
literal|1
argument_list|,
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
block|{
comment|/* interpret the response */
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
condition|)
block|{
comment|/* a good conversation */
name|token2
operator|=
name|x_strdup
argument_list|(
name|resp
index|[
literal|0
index|]
operator|.
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|token2
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"could not recover authentication token 2"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_AUTHTOK_RECOVER_ERR
expr_stmt|;
block|}
block|}
comment|/*              * tidy up the conversation (resp_retcode) is ignored              */
name|_pam_drop_reply
argument_list|(
name|resp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
operator|(
name|retval
operator|==
name|PAM_SUCCESS
operator|)
condition|?
name|PAM_AUTHTOK_RECOVER_ERR
else|:
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to obtain the password a second time"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Hopefully now token1 and token2 the same password ... */
if|if
condition|(
name|strcmp
argument_list|(
name|token1
argument_list|,
name|token2
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* tell the user */
name|make_remark
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|PAM_ERROR_MSG
argument_list|,
name|MISTYPED_PASS
argument_list|)
expr_stmt|;
name|token1
operator|=
name|_pam_delete
argument_list|(
name|token1
argument_list|)
expr_stmt|;
name|token2
operator|=
name|_pam_delete
argument_list|(
name|token2
argument_list|)
expr_stmt|;
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Password mistyped"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_AUTHTOK_RECOVER_ERR
expr_stmt|;
continue|continue;
block|}
comment|/* Yes, the password was typed correct twice          * we store this password as an item          */
name|retval
operator|=
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
name|token1
argument_list|)
expr_stmt|;
comment|/* clean it up */
name|token1
operator|=
name|_pam_delete
argument_list|(
name|token1
argument_list|)
expr_stmt|;
name|token2
operator|=
name|_pam_delete
argument_list|(
name|token2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
name|PAM_SUCCESS
operator|)
operator|||
operator|(
operator|(
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
operator|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"error manipulating password"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|item
operator|=
name|NULL
expr_stmt|;
comment|/* break link to password */
return|return
name|PAM_SUCCESS
return|;
block|}
do|while
condition|(
name|retry_times
operator|--
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"UNKNOWN flags setting %02X"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|PAM_SERVICE_ERR
return|;
block|}
comment|/* Not reached */
return|return
name|PAM_SERVICE_ERR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* static module data */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_cracklib_modstruct
init|=
block|{
literal|"pam_cracklib"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|pam_sm_chauthtok
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Copyright (c) Cristian Gafton<gafton@redhat.com>, 1996.  *                                              All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * ALTERNATIVELY, this product may be distributed under the terms of  * the GNU Public License, in which case the provisions of the GPL are  * required INSTEAD OF the above restrictions.  (This clause is  * necessary due to a potential bad interaction between the GPL and  * the restrictions contained in a BSD-style copyright.)  *  * THIS SOFTWARE IS PROVIDED `AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The following copyright was appended for the long password support  * added with the libpam 0.58 release:  *  * Modificaton Copyright (c) Philip W. Dalrymple III<pwd@mdtsoft.com>  *       1997. All rights reserved  *  * THE MODIFICATION THAT PROVIDES SUPPORT FOR LONG PASSWORD TYPE CHECKING TO  * THIS SOFTWARE IS PROVIDED `AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

end_unit

