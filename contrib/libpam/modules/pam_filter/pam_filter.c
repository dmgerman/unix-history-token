begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: pam_filter.c,v 1.2 2000/11/19 23:54:03 agmorgan Exp $  *  * written by Andrew Morgan<morgan@transmeta.com> with much help from  * Richard Stevens' UNIX Network Programming book.  */
end_comment

begin_include
include|#
directive|include
file|<security/_pam_aconf.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|PAM_SM_AUTH
end_define

begin_define
define|#
directive|define
name|PAM_SM_ACCOUNT
end_define

begin_define
define|#
directive|define
name|PAM_SM_SESSION
end_define

begin_define
define|#
directive|define
name|PAM_SM_PASSWORD
end_define

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/pam_filter.h>
end_include

begin_comment
comment|/* ------ some tokens used for convenience throughout this file ------- */
end_comment

begin_define
define|#
directive|define
name|FILTER_DEBUG
value|01
end_define

begin_define
define|#
directive|define
name|FILTER_RUN1
value|02
end_define

begin_define
define|#
directive|define
name|FILTER_RUN2
value|04
end_define

begin_define
define|#
directive|define
name|NEW_TERM
value|010
end_define

begin_define
define|#
directive|define
name|NON_TERM
value|020
end_define

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* log errors */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_function
specifier|static
name|void
name|_pam_log
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"pam_filter"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TERMINAL_LEN
value|12
end_define

begin_function
specifier|static
name|int
name|master
parameter_list|(
name|char
modifier|*
name|terminal
parameter_list|)
comment|/*  * try to open all of the terminals in sequence return first free one,  * or -1  */
block|{
specifier|const
name|char
name|ptys
index|[]
init|=
literal|"pqrs"
decl_stmt|,
modifier|*
name|pty
init|=
name|ptys
decl_stmt|;
specifier|const
name|char
name|hexs
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|,
modifier|*
name|hex
decl_stmt|;
name|struct
name|stat
name|tstat
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|strcpy
argument_list|(
name|terminal
argument_list|,
literal|"/dev/pty??"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pty
condition|)
block|{
comment|/* step through four types */
name|terminal
index|[
literal|8
index|]
operator|=
operator|*
name|pty
operator|++
expr_stmt|;
name|terminal
index|[
literal|9
index|]
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|terminal
argument_list|,
operator|&
name|tstat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unknown pseudo terminal; %s"
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|hex
operator|=
name|hexs
init|;
operator|*
name|hex
condition|;
control|)
block|{
comment|/* step through 16 of these */
name|terminal
index|[
literal|9
index|]
operator|=
operator|*
name|hex
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|terminal
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
return|return
name|fd
return|;
block|}
block|}
block|}
comment|/* no terminal found */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_args
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|evp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filtername
parameter_list|)
block|{
name|int
name|ctrl
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"debug"
argument_list|,
operator|*
name|argv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctrl
operator||=
name|FILTER_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"new_term"
argument_list|,
operator|*
name|argv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctrl
operator||=
name|NEW_TERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"non_term"
argument_list|,
operator|*
name|argv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctrl
operator||=
name|NON_TERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"run1"
argument_list|,
operator|*
name|argv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctrl
operator||=
name|FILTER_RUN1
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"no run filter supplied"
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"run2"
argument_list|,
operator|*
name|argv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctrl
operator||=
name|FILTER_RUN2
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"no run filter supplied"
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unrecognized option: %s (ignored)"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
operator|++
name|argv
expr_stmt|;
comment|/* step along list */
block|}
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
block|{
comment|/* there was no reference to a filter */
operator|*
name|filtername
operator|=
name|NULL
expr_stmt|;
operator|*
name|evp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|levp
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
operator|*
name|filtername
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|FILTER_DEBUG
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"will run filter %s\n"
argument_list|,
operator|*
name|filtername
argument_list|)
expr_stmt|;
block|}
name|levp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"no memory for environment of filter"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|size
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|size
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* the "ARGS" variable */
define|#
directive|define
name|ARGS_OFFSET
value|5
comment|/*  sizeof("ARGS=");  */
define|#
directive|define
name|ARGS_NAME
value|"ARGS="
name|size
operator|+=
name|ARGS_OFFSET
expr_stmt|;
name|levp
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"no memory for filter arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
condition|)
block|{
name|free
argument_list|(
name|levp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|levp
index|[
literal|0
index|]
argument_list|,
name|ARGS_NAME
argument_list|,
name|ARGS_OFFSET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|size
operator|=
name|ARGS_OFFSET
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|strcpy
argument_list|(
name|levp
index|[
literal|0
index|]
operator|+
name|size
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|levp
index|[
literal|0
index|]
index|[
name|size
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|levp
index|[
literal|0
index|]
index|[
operator|--
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*<NUL> terminate */
comment|/* the "SERVICE" variable */
define|#
directive|define
name|SERVICE_OFFSET
value|8
comment|/*  sizeof("SERVICE=");  */
define|#
directive|define
name|SERVICE_NAME
value|"SERVICE="
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_SERVICE
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|size
operator|=
name|SERVICE_OFFSET
operator|+
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|levp
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"no memory for service name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
condition|)
block|{
name|free
argument_list|(
name|levp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|levp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|levp
index|[
literal|1
index|]
argument_list|,
name|SERVICE_NAME
argument_list|,
name|SERVICE_OFFSET
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|levp
index|[
literal|1
index|]
operator|+
name|SERVICE_OFFSET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|levp
index|[
literal|1
index|]
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*<NUL> terminate */
comment|/* the "USER" variable */
define|#
directive|define
name|USER_OFFSET
value|5
comment|/*  sizeof("USER=");  */
define|#
directive|define
name|USER_NAME
value|"USER="
name|pam_get_user
argument_list|(
name|pamh
argument_list|,
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|tmp
operator|=
literal|"<unknown>"
expr_stmt|;
block|}
name|size
operator|=
name|USER_OFFSET
operator|+
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|levp
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"no memory for user's name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
condition|)
block|{
name|free
argument_list|(
name|levp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|levp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|levp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|levp
index|[
literal|2
index|]
argument_list|,
name|USER_NAME
argument_list|,
name|USER_OFFSET
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|levp
index|[
literal|2
index|]
operator|+
name|USER_OFFSET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|levp
index|[
literal|2
index|]
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*<NUL> terminate */
comment|/* the "USER" variable */
define|#
directive|define
name|TYPE_OFFSET
value|5
comment|/*  sizeof("TYPE=");  */
define|#
directive|define
name|TYPE_NAME
value|"TYPE="
name|size
operator|=
name|TYPE_OFFSET
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|levp
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
index|[
literal|3
index|]
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"no memory for type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levp
condition|)
block|{
name|free
argument_list|(
name|levp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|levp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|levp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|levp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|levp
index|[
literal|3
index|]
argument_list|,
name|TYPE_NAME
argument_list|,
name|TYPE_OFFSET
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|levp
index|[
literal|3
index|]
operator|+
name|TYPE_OFFSET
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|levp
index|[
literal|3
index|]
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*<NUL> terminate */
name|levp
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* end list */
operator|*
name|evp
operator|=
name|levp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctrl
operator|&
name|FILTER_DEBUG
operator|)
operator|&&
operator|*
name|filtername
condition|)
block|{
name|char
modifier|*
modifier|*
name|e
decl_stmt|;
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"filter[%s]: %s"
argument_list|,
name|type
argument_list|,
operator|*
name|filtername
argument_list|)
expr_stmt|;
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"environment:"
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
operator|*
name|evp
init|;
name|e
operator|&&
operator|*
name|e
condition|;
operator|++
name|e
control|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  %s"
argument_list|,
operator|*
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ctrl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_evp
parameter_list|(
name|char
modifier|*
name|evp
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|evp
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|evp
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|evp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|evp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ctrl
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|evp
parameter_list|,
specifier|const
name|char
modifier|*
name|filtername
parameter_list|)
block|{
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|terminal
index|[
name|TERMINAL_LEN
index|]
decl_stmt|;
name|struct
name|termio
name|stored_mode
decl_stmt|;
comment|/* initial terminal mode settings */
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|,
name|child
init|=
literal|0
decl_stmt|,
name|child2
init|=
literal|0
decl_stmt|,
name|aterminal
decl_stmt|;
if|if
condition|(
name|filtername
operator|==
name|NULL
operator|||
operator|*
name|filtername
operator|!=
literal|'/'
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"filtername not permitted; require full path"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|||
operator|!
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
name|aterminal
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|aterminal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|aterminal
condition|)
block|{
comment|/* open the master pseudo terminal */
name|fd
index|[
literal|0
index|]
operator|=
name|master
argument_list|(
name|terminal
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
index|[
literal|0
index|]
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"no master terminal"
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTH_ERR
return|;
block|}
comment|/* set terminal into raw mode.. remember old mode so that we can 	   revert to it after the child has quit. */
comment|/* this is termio terminal handling... */
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCGETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stored_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* in trouble, so close down */
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"couldn't copy terminal mode"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
else|else
block|{
name|struct
name|termio
name|t_mode
init|=
name|stored_mode
decl_stmt|;
name|t_mode
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
comment|/* no input control */
name|t_mode
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
comment|/* no ouput post processing */
comment|/* no signals, canonical input, echoing, upper/lower output */
name|t_mode
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|XCASE
operator|)
expr_stmt|;
name|t_mode
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
comment|/* no parity */
name|t_mode
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
comment|/* 8 bit chars */
name|t_mode
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
comment|/* number of chars to satisfy a read */
name|t_mode
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 0/10th second for chars */
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"couldn't put terminal in RAW mode"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* 	     * NOTE: Unlike the stream socket case here the child 	     * opens the slave terminal as fd[1] *after* the fork... 	     */
block|}
block|}
else|else
block|{
comment|/* 	 * not a terminal line so just open a stream socket fd[0-1] 	 * both set... 	 */
if|if
condition|(
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"couldn't open a stream pipe"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
block|}
comment|/* start child process */
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"first fork failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aterminal
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stored_mode
argument_list|)
expr_stmt|;
block|}
return|return
name|PAM_AUTH_ERR
return|;
block|}
if|if
condition|(
name|child
operator|==
literal|0
condition|)
block|{
comment|/* child process *is* application */
if|if
condition|(
name|aterminal
condition|)
block|{
comment|/* close the controlling tty */
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NOCTTY
argument_list|)
name|int
name|t
init|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|t
init|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(__hpux)&& defined(O_NOCTTY) */
comment|/* make this process it's own process leader */
if|if
condition|(
name|setsid
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"child cannot become new session"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* find slave's name */
name|terminal
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
comment|/* want to open slave terminal */
name|fd
index|[
literal|1
index|]
operator|=
name|open
argument_list|(
name|terminal
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* process is the child -- uses line fd[1] */
if|if
condition|(
name|fd
index|[
literal|1
index|]
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cannot open slave terminal; %s"
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* initialize the child's terminal to be the way the 	       parent's was before we set it into RAW mode */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|TCSETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stored_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cannot set slave terminal mode; %s"
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
block|}
else|else
block|{
comment|/* nothing to do for a simple stream socket */
block|}
comment|/* re-assign the stdin/out to fd[1]<- (talks to filter). */
if|if
condition|(
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
operator|||
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|!=
name|STDOUT_FILENO
operator|||
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|!=
name|STDERR_FILENO
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unable to re-assign STDIN/OUT/ERR...'s"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* make sure that file descriptors survive 'exec's */
if|if
condition|(
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|||
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|||
name|fcntl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unable to re-assign STDIN/OUT/ERR...'s"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* now the user input is read from the parent/filter: forget fd */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* the current process is now aparently working with filtered 	   stdio/stdout/stderr --- success! */
return|return
name|PAM_SUCCESS
return|;
block|}
comment|/*      * process is the parent here. So we can close the application's      * input/output      */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Clear out passwords... there is a security problem here in      * that this process never executes pam_end.  Consequently, any      * other sensitive data in this process is *not* explicitly      * overwritten, before the process terminates */
operator|(
name|void
operator|)
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_AUTHTOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_OLDAUTHTOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* fork a copy of process to run the actual filter executable */
if|if
condition|(
operator|(
name|child2
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"filter fork failed"
argument_list|)
expr_stmt|;
name|child2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child2
operator|==
literal|0
condition|)
block|{
comment|/* exec the child filter */
if|if
condition|(
name|dup2
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|APPIN_FILENO
argument_list|)
operator|!=
name|APPIN_FILENO
operator|||
name|dup2
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|APPOUT_FILENO
argument_list|)
operator|!=
name|APPOUT_FILENO
operator|||
name|dup2
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|APPERR_FILENO
argument_list|)
operator|!=
name|APPERR_FILENO
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unable to re-assign APPIN/OUT/ERR...'s"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* make sure that file descriptors survive 'exec's */
if|if
condition|(
name|fcntl
argument_list|(
name|APPIN_FILENO
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|fcntl
argument_list|(
name|APPOUT_FILENO
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|fcntl
argument_list|(
name|APPERR_FILENO
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unable to retain APPIN/OUT/ERR...'s"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|APPIN_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|APPOUT_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|APPERR_FILENO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* now the user input is read from the parent through filter */
name|execle
argument_list|(
name|filtername
argument_list|,
literal|"<pam_filter>"
argument_list|,
name|NULL
argument_list|,
name|evp
argument_list|)
expr_stmt|;
comment|/* getting to here is an error */
name|_pam_log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"filter: %s, not executable"
argument_list|,
name|filtername
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* wait for either of the two children to exit */
while|while
condition|(
name|child
operator|&&
name|child2
condition|)
block|{
comment|/* loop if there are two children */
name|int
name|lstatus
init|=
literal|0
decl_stmt|;
name|int
name|chid
decl_stmt|;
name|chid
operator|=
name|wait
argument_list|(
operator|&
name|lstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|chid
operator|==
name|child
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|lstatus
argument_list|)
condition|)
block|{
comment|/* exited ? */
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|lstatus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|lstatus
argument_list|)
condition|)
block|{
comment|/* killed ? */
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* just stopped etc.. */
name|child
operator|=
literal|0
expr_stmt|;
comment|/* the child has exited */
block|}
elseif|else
if|if
condition|(
name|chid
operator|==
name|child2
condition|)
block|{
comment|/* 		 * if the filter has exited. Let the child die 		 * naturally below 		 */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|lstatus
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|lstatus
argument_list|)
condition|)
name|child2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"programming error<chid=%d,lstatus=%x>: "
name|__FILE__
literal|" line %d"
argument_list|,
name|lstatus
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|child
operator|=
name|child2
operator|=
literal|0
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* if there is something running, wait for it to exit */
while|while
condition|(
name|child
operator|||
name|child2
condition|)
block|{
name|int
name|lstatus
init|=
literal|0
decl_stmt|;
name|int
name|chid
decl_stmt|;
name|chid
operator|=
name|wait
argument_list|(
operator|&
name|lstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|&&
name|chid
operator|==
name|child
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|lstatus
argument_list|)
condition|)
block|{
comment|/* exited ? */
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|lstatus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|lstatus
argument_list|)
condition|)
block|{
comment|/* killed ? */
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* just stopped etc.. */
name|child
operator|=
literal|0
expr_stmt|;
comment|/* the child has exited */
block|}
elseif|else
if|if
condition|(
name|child2
operator|&&
name|chid
operator|==
name|child2
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|lstatus
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|lstatus
argument_list|)
condition|)
name|child2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"programming error<chid=%d,lstatus=%x>: "
name|__FILE__
literal|" line %d"
argument_list|,
name|lstatus
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|child
operator|=
name|child2
operator|=
literal|0
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aterminal
condition|)
block|{
comment|/* reset to initial terminal mode */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stored_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctrl
operator|&
name|FILTER_DEBUG
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"parent process exited"
argument_list|)
expr_stmt|;
comment|/* clock off */
block|}
comment|/* quit the parent process, returning the child's exit status */
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_the_terminal
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tty
decl_stmt|;
if|if
condition|(
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|tty
argument_list|)
operator|!=
name|PAM_SUCCESS
operator|||
name|tty
operator|==
name|NULL
condition|)
block|{
name|tty
operator|=
name|ttyname
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't get the tty name"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
if|if
condition|(
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
name|tty
argument_list|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't set tty name"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
block|}
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|need_a_filter
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|which_run
parameter_list|)
block|{
name|int
name|ctrl
decl_stmt|;
name|char
modifier|*
modifier|*
name|evp
decl_stmt|;
specifier|const
name|char
modifier|*
name|filterfile
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ctrl
operator|=
name|process_args
argument_list|(
name|pamh
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|name
argument_list|,
operator|&
name|evp
argument_list|,
operator|&
name|filterfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|PAM_AUTHINFO_UNAVAIL
return|;
block|}
comment|/* set the tty to the old or the new one? */
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|NON_TERM
operator|)
operator|&&
operator|!
operator|(
name|ctrl
operator|&
name|NEW_TERM
operator|)
condition|)
block|{
name|retval
operator|=
name|set_the_terminal
argument_list|(
name|pamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tried and failed to set PAM_TTY"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|retval
operator|=
name|PAM_SUCCESS
expr_stmt|;
comment|/* nothing to do which is always a success */
block|}
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
operator|&&
operator|(
name|ctrl
operator|&
name|which_run
operator|)
condition|)
block|{
name|retval
operator|=
name|set_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|ctrl
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|evp
argument_list|,
name|filterfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
operator|&&
operator|!
operator|(
name|ctrl
operator|&
name|NON_TERM
operator|)
operator|&&
operator|(
name|ctrl
operator|&
name|NEW_TERM
operator|)
condition|)
block|{
name|retval
operator|=
name|set_the_terminal
argument_list|(
name|pamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tried and failed to set new terminal as PAM_TTY"
argument_list|)
expr_stmt|;
block|}
block|}
name|free_evp
argument_list|(
name|evp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|FILTER_DEBUG
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"filter/%s, returning %d"
argument_list|,
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"[%s]"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* ----------------- public functions ---------------- */
end_comment

begin_comment
comment|/*  * here are the advertised access points ...  */
end_comment

begin_comment
comment|/* ------------------ authentication ----------------- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_authenticate
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|need_a_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|"authenticate"
argument_list|,
name|FILTER_RUN1
argument_list|)
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_setcred
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|need_a_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|"setcred"
argument_list|,
name|FILTER_RUN2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------- account management ---------------- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_acct_mgmt
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|need_a_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|"setcred"
argument_list|,
name|FILTER_RUN1
operator||
name|FILTER_RUN2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------- session management ---------------- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_open_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|need_a_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|"open_session"
argument_list|,
name|FILTER_RUN1
argument_list|)
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_close_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|need_a_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|"close_session"
argument_list|,
name|FILTER_RUN2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------- updating authentication tokens --------- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_chauthtok
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|runN
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|PAM_PRELIM_CHECK
condition|)
name|runN
operator|=
name|FILTER_RUN1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PAM_UPDATE_AUTHTOK
condition|)
name|runN
operator|=
name|FILTER_RUN2
expr_stmt|;
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown flags for chauthtok (0x%X)"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|PAM_TRY_AGAIN
return|;
block|}
return|return
name|need_a_filter
argument_list|(
name|pamh
argument_list|,
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|"chauthtok"
argument_list|,
name|runN
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* ------------ stuff for static modules ------------ */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_filter_modstruct
init|=
block|{
literal|"pam_filter"
block|,
name|pam_sm_authenticate
block|,
name|pam_sm_setcred
block|,
name|pam_sm_acct_mgmt
block|,
name|pam_sm_open_session
block|,
name|pam_sm_close_session
block|,
name|pam_sm_chauthtok
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

