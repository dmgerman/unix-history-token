begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: pam_listfile.c,v 1.6 1997/04/05 06:38:35 morgan Exp $  *  * $Log: pam_listfile.c,v $  * Revision 1.6  1997/04/05 06:38:35  morgan  * reformat mostly  *  * Revision 1.5  1997/02/15 17:29:41  morgan  * removed fixed length buffer in logging  *  * Revision 1.4  1997/01/04 20:32:10  morgan  * ammendments for pam_listfile handling  *  * Revision 1.3  1996/11/10 21:02:08  morgan  * compiles with .53  *  * Revision 1.2  1996/09/05 06:22:58  morgan  * Michael's patches  *  */
end_comment

begin_comment
comment|/*  * by Elliot Lee<sopwith@redhat.com>, Red Hat Software.  * July 25, 1996.  * This code shamelessly ripped from the pam_rootok module.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_define
define|#
directive|define
name|_SVID_SOURCE
end_define

begin_define
define|#
directive|define
name|_BSD_SOURCE
end_define

begin_define
define|#
directive|define
name|__USE_BSD
end_define

begin_define
define|#
directive|define
name|__USE_SVID
end_define

begin_define
define|#
directive|define
name|__USE_MISC
end_define

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<features.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * here, we make a definition for the externally accessible function  * in this file (this definition is required for static a module  * but strongly encouraged generally) it is used to instruct the  * modules include file to define the function prototypes.  */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_AUTH
end_define

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_comment
comment|/* some syslogging */
end_comment

begin_function
specifier|static
name|void
name|_pam_log
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"PAM-listfile"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* checks if a user is on a list of members */
end_comment

begin_function
specifier|static
name|int
name|is_on_list
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|list
argument_list|,
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|list
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Checks if a user is a member of a group */
end_comment

begin_function
specifier|static
name|int
name|is_on_group
parameter_list|(
specifier|const
name|char
modifier|*
name|user_name
parameter_list|,
specifier|const
name|char
modifier|*
name|group_name
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|,
modifier|*
name|pgrp
decl_stmt|;
name|char
name|uname
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|gname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|user_name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|group_name
argument_list|)
condition|)
return|return
literal|0
return|;
name|bzero
argument_list|(
name|uname
argument_list|,
sizeof|sizeof
argument_list|(
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|uname
argument_list|,
name|user_name
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gname
argument_list|,
sizeof|sizeof
argument_list|(
name|gname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|gname
argument_list|,
name|group_name
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pwd
condition|)
return|return
literal|0
return|;
comment|/* the info about this group */
name|setgrent
argument_list|()
expr_stmt|;
name|grp
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|grp
condition|)
return|return
literal|0
return|;
comment|/* first check: is a member of the group_name group ? */
if|if
condition|(
name|is_on_list
argument_list|(
name|grp
operator|->
name|gr_mem
argument_list|,
name|uname
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* next check: user primary group is group_name ? */
name|setgrent
argument_list|()
expr_stmt|;
name|pgrp
operator|=
name|getgrgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pgrp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pgrp
operator|->
name|gr_name
argument_list|,
name|gname
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --- authentication management functions (only) --- */
end_comment

begin_comment
comment|/* Extended Items that are not directly available via pam_get_item() */
end_comment

begin_define
define|#
directive|define
name|EI_GROUP
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|EI_SHELL
value|(1<< 1)
end_define

begin_comment
comment|/* Constants for apply= parameter */
end_comment

begin_define
define|#
directive|define
name|APPLY_TYPE_NULL
value|0
end_define

begin_define
define|#
directive|define
name|APPLY_TYPE_NONE
value|1
end_define

begin_define
define|#
directive|define
name|APPLY_TYPE_USER
value|2
end_define

begin_define
define|#
directive|define
name|APPLY_TYPE_GROUP
value|3
end_define

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_authenticate
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|,
name|citem
init|=
literal|0
decl_stmt|,
name|extitem
init|=
literal|0
decl_stmt|,
name|onerr
init|=
name|PAM_SERVICE_ERR
decl_stmt|,
name|sense
init|=
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|citemp
decl_stmt|;
name|char
modifier|*
name|ifname
init|=
name|NULL
decl_stmt|;
name|char
name|aline
index|[
literal|256
index|]
decl_stmt|;
name|char
name|mybuf
index|[
literal|256
index|]
decl_stmt|,
name|myval
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
name|char
name|apply_val
index|[
literal|256
index|]
decl_stmt|;
name|int
name|apply_type
decl_stmt|;
comment|/* Stuff for "extended" items */
name|struct
name|passwd
modifier|*
name|userinfo
decl_stmt|;
name|struct
name|group
modifier|*
name|grpinfo
decl_stmt|;
name|char
modifier|*
name|itemlist
index|[
literal|256
index|]
decl_stmt|;
comment|/* Maximum of 256 items */
name|D
argument_list|(
operator|(
literal|"called."
operator|)
argument_list|)
expr_stmt|;
name|apply_type
operator|=
name|APPLY_TYPE_NULL
expr_stmt|;
name|memset
argument_list|(
name|apply_val
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|apply_val
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
block|{
name|char
modifier|*
name|junk
decl_stmt|;
name|junk
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|junk
operator|==
name|NULL
condition|)
block|{
return|return
name|PAM_BUF_ERR
return|;
block|}
name|strcpy
argument_list|(
name|junk
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mybuf
argument_list|,
name|strtok
argument_list|(
name|junk
argument_list|,
literal|"="
argument_list|)
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|myval
argument_list|,
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"="
argument_list|)
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|junk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mybuf
argument_list|,
literal|"onerr"
argument_list|)
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"succeed"
argument_list|)
condition|)
name|onerr
operator|=
name|PAM_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"fail"
argument_list|)
condition|)
name|onerr
operator|=
name|PAM_SERVICE_ERR
expr_stmt|;
else|else
return|return
name|PAM_SERVICE_ERR
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mybuf
argument_list|,
literal|"sense"
argument_list|)
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"allow"
argument_list|)
condition|)
name|sense
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"deny"
argument_list|)
condition|)
name|sense
operator|=
literal|1
expr_stmt|;
else|else
return|return
name|onerr
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mybuf
argument_list|,
literal|"file"
argument_list|)
condition|)
block|{
name|ifname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|myval
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ifname
argument_list|,
name|myval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mybuf
argument_list|,
literal|"item"
argument_list|)
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"user"
argument_list|)
condition|)
name|citem
operator|=
name|PAM_USER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"tty"
argument_list|)
condition|)
name|citem
operator|=
name|PAM_TTY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"rhost"
argument_list|)
condition|)
name|citem
operator|=
name|PAM_RHOST
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"ruser"
argument_list|)
condition|)
name|citem
operator|=
name|PAM_RUSER
expr_stmt|;
else|else
block|{
comment|/* These items are related to the user, but are not 		      directly gettable with pam_get_item */
name|citem
operator|=
name|PAM_USER
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"group"
argument_list|)
condition|)
name|extitem
operator|=
name|EI_GROUP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|myval
argument_list|,
literal|"shell"
argument_list|)
condition|)
name|extitem
operator|=
name|EI_SHELL
expr_stmt|;
else|else
name|citem
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mybuf
argument_list|,
literal|"apply"
argument_list|)
condition|)
block|{
name|apply_type
operator|=
name|APPLY_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|myval
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|apply_type
operator|=
name|APPLY_TYPE_GROUP
expr_stmt|;
name|strncpy
argument_list|(
name|apply_val
argument_list|,
name|myval
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|apply_val
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apply_type
operator|=
name|APPLY_TYPE_USER
expr_stmt|;
name|strncpy
argument_list|(
name|apply_val
argument_list|,
name|myval
argument_list|,
sizeof|sizeof
argument_list|(
name|apply_val
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown option: %s"
argument_list|,
name|mybuf
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
block|}
if|if
condition|(
operator|!
name|citem
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown item or item not specified"
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ifname
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"List filename not specified"
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
elseif|else
if|if
condition|(
name|sense
operator|==
literal|2
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown sense or sense not specified"
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|apply_type
operator|==
name|APPLY_TYPE_NONE
operator|)
operator|||
operator|(
operator|(
name|apply_type
operator|!=
name|APPLY_TYPE_NULL
operator|)
operator|&&
operator|(
operator|*
name|apply_val
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Invalid usage for apply= parameter"
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
comment|/* Check if it makes sense to use the apply= parameter */
if|if
condition|(
name|apply_type
operator|!=
name|APPLY_TYPE_NULL
condition|)
block|{
if|if
condition|(
operator|(
name|citem
operator|==
name|PAM_USER
operator|)
operator|||
operator|(
name|citem
operator|==
name|PAM_RUSER
operator|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Non-sense use for apply= parameter"
argument_list|)
expr_stmt|;
name|apply_type
operator|=
name|APPLY_TYPE_NULL
expr_stmt|;
block|}
if|if
condition|(
name|extitem
operator|&&
operator|(
name|extitem
operator|==
name|EI_GROUP
operator|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Non-sense use for apply= parameter"
argument_list|)
expr_stmt|;
name|apply_type
operator|=
name|APPLY_TYPE_NULL
expr_stmt|;
block|}
block|}
comment|/* Short-circuit - test if this session apply for this user */
block|{
specifier|const
name|char
modifier|*
name|user_name
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|pam_get_user
argument_list|(
name|pamh
argument_list|,
operator|&
name|user_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|==
name|PAM_SUCCESS
operator|)
operator|&&
name|user_name
index|[
literal|0
index|]
condition|)
block|{
comment|/* Got it ? Valid ? */
if|if
condition|(
name|apply_type
operator|==
name|APPLY_TYPE_USER
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|user_name
argument_list|,
name|apply_val
argument_list|)
condition|)
block|{
comment|/* Does not apply to this user */
ifdef|#
directive|ifdef
name|DEBUG
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"don't apply: apply=%s, user=%s"
argument_list|,
name|apply_val
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|PAM_IGNORE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|apply_type
operator|==
name|APPLY_TYPE_GROUP
condition|)
block|{
if|if
condition|(
operator|!
name|is_on_group
argument_list|(
name|user_name
argument_list|,
name|apply_val
argument_list|)
condition|)
block|{
comment|/* Not a member of apply= group */
ifdef|#
directive|ifdef
name|DEBUG
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"don't apply: %s not a member of group %s"
argument_list|,
name|user_name
argument_list|,
name|apply_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|PAM_IGNORE
return|;
block|}
block|}
block|}
block|}
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|citem
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|citemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
return|return
name|onerr
return|;
block|}
if|if
condition|(
operator|(
name|citem
operator|==
name|PAM_USER
operator|)
operator|&&
operator|!
name|citemp
condition|)
block|{
name|pam_get_user
argument_list|(
name|pamh
argument_list|,
operator|&
name|citemp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
return|return
name|PAM_SERVICE_ERR
return|;
block|}
if|if
condition|(
operator|!
name|citemp
operator|||
operator|(
name|strlen
argument_list|(
name|citemp
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* The item was NULL - we are sure not to match */
return|return
name|sense
condition|?
name|PAM_SUCCESS
else|:
name|PAM_AUTH_ERR
return|;
block|}
if|if
condition|(
name|extitem
condition|)
block|{
switch|switch
condition|(
name|extitem
condition|)
block|{
case|case
name|EI_GROUP
case|:
name|setpwent
argument_list|()
expr_stmt|;
name|userinfo
operator|=
name|getpwnam
argument_list|(
name|citemp
argument_list|)
expr_stmt|;
name|setgrent
argument_list|()
expr_stmt|;
name|grpinfo
operator|=
name|getgrgid
argument_list|(
name|userinfo
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|itemlist
index|[
literal|0
index|]
operator|=
name|x_strdup
argument_list|(
name|grpinfo
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|setgrent
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|itemlist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|itemlist
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|grpinfo
operator|=
name|getgrent
argument_list|()
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|is_on_list
argument_list|(
name|grpinfo
operator|->
name|gr_mem
argument_list|,
name|citemp
argument_list|)
condition|)
block|{
name|itemlist
index|[
name|i
operator|++
index|]
operator|=
name|x_strdup
argument_list|(
name|grpinfo
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
block|}
name|itemlist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
break|break;
case|case
name|EI_SHELL
case|:
name|setpwent
argument_list|()
expr_stmt|;
name|userinfo
operator|=
name|getpwnam
argument_list|(
name|citemp
argument_list|)
expr_stmt|;
comment|/* Assume that we have already gotten 						PAM_USER in pam_get_item() - a valid 						assumption since citem gets set to 						PAM_USER in the extitem switch */
name|citemp
operator|=
name|userinfo
operator|->
name|pw_shell
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
break|break;
default|default:
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Internal weirdness, unknown extended item %d"
argument_list|,
name|extitem
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|_pam_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Got file = %s, item = %d, value = %s, sense = %d"
argument_list|,
name|ifname
argument_list|,
name|citem
argument_list|,
name|citemp
argument_list|,
name|sense
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lstat
argument_list|(
name|ifname
argument_list|,
operator|&
name|fileinfo
argument_list|)
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't open %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
name|onerr
return|;
block|}
if|if
condition|(
operator|(
name|fileinfo
operator|.
name|st_mode
operator|&
name|S_IWOTH
operator|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* If the file is world writable or is not a 	   normal file, return error */
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is either world writable or not a normal file"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTH_ERR
return|;
block|}
name|inf
operator|=
name|fopen
argument_list|(
name|ifname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
name|NULL
condition|)
block|{
comment|/* Check that we opened it successfully */
if|if
condition|(
name|onerr
operator|==
name|PAM_SERVICE_ERR
condition|)
block|{
comment|/* Only report if it's an error... */
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error opening %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
block|}
return|return
name|onerr
return|;
block|}
comment|/* There should be no more errors from here on */
name|retval
operator|=
name|PAM_AUTH_ERR
expr_stmt|;
comment|/* This loop assumes that PAM_SUCCESS == 0        and PAM_AUTH_ERR != 0 */
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|PAM_SUCCESS
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|PAM_AUTH_ERR
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|extitem
operator|==
name|EI_GROUP
condition|)
block|{
while|while
condition|(
operator|(
name|fgets
argument_list|(
name|aline
argument_list|,
literal|255
argument_list|,
name|inf
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
name|retval
condition|)
block|{
if|if
condition|(
name|aline
index|[
name|strlen
argument_list|(
name|aline
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|aline
index|[
name|strlen
argument_list|(
name|aline
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|itemlist
index|[
name|i
index|]
condition|;
control|)
comment|/* If any of the items match, strcmp() == 0, and we get out 		   of this loop */
name|retval
operator|=
operator|(
name|strcmp
argument_list|(
name|aline
argument_list|,
name|itemlist
index|[
name|i
operator|++
index|]
argument_list|)
operator|&&
name|retval
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|itemlist
index|[
name|i
index|]
condition|;
control|)
name|free
argument_list|(
name|itemlist
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|fgets
argument_list|(
name|aline
argument_list|,
literal|255
argument_list|,
name|inf
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
name|retval
condition|)
block|{
if|if
condition|(
name|aline
index|[
name|strlen
argument_list|(
name|aline
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|aline
index|[
name|strlen
argument_list|(
name|aline
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|retval
operator|=
name|strcmp
argument_list|(
name|aline
argument_list|,
name|citemp
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Returning %d, retval = %d"
argument_list|,
name|sense
condition|?
name|PAM_AUTH_ERR
else|:
name|PAM_SUCCESS
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|sense
condition|?
name|PAM_SUCCESS
else|:
name|PAM_AUTH_ERR
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Returning %d, retval = %d"
argument_list|,
name|sense
condition|?
name|PAM_SUCCESS
else|:
name|PAM_AUTH_ERR
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|sense
condition|?
name|PAM_AUTH_ERR
else|:
name|PAM_SUCCESS
return|;
block|}
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_setcred
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* static module data */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_listfile_modstruct
init|=
block|{
literal|"pam_listfile"
block|,
name|pam_sm_authenticate
block|,
name|pam_sm_setcred
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of module definition */
end_comment

end_unit

