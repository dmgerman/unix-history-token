begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pam_limits - impose resource limits when opening a user session  *  * 1.5 - Elliot Lee's "max system logins patch"  * 1.4 - addressed bug in configuration file parser  * 1.3 - modified the configuration file format  * 1.2 - added 'debug' and 'conf=' arguments  * 1.1 - added @group support      * 1.0 - initial release - Linux ONLY  *  * See end for Copyright information  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|linux
argument_list|)
operator|)
end_if

begin_error
error|#
directive|error
error|THIS CODE IS KNOWN TO WORK ONLY ON LINUX !!!
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|__USE_POSIX2
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|UT_USER
end_ifndef

begin_comment
comment|/* some systems have ut_name instead of ut_user */
end_comment

begin_define
define|#
directive|define
name|UT_USER
value|ut_user
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Module defines */
end_comment

begin_define
define|#
directive|define
name|LINE_LENGTH
value|1024
end_define

begin_define
define|#
directive|define
name|LIMITS_DEF_USER
value|0
end_define

begin_comment
comment|/* limit was set by an user entry */
end_comment

begin_define
define|#
directive|define
name|LIMITS_DEF_GROUP
value|1
end_define

begin_comment
comment|/* limit was set by a group entry */
end_comment

begin_define
define|#
directive|define
name|LIMITS_DEF_DEFAULT
value|2
end_define

begin_comment
comment|/* limit was set by an default entry */
end_comment

begin_define
define|#
directive|define
name|LIMITS_DEF_NONE
value|3
end_define

begin_comment
comment|/* this limit was not set yet */
end_comment

begin_comment
comment|/* internal data */
end_comment

begin_decl_stmt
specifier|static
name|char
name|conf_file
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|user_limits_struct
block|{
name|int
name|src_soft
decl_stmt|;
name|int
name|src_hard
decl_stmt|;
name|struct
name|rlimit
name|limit
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|user_limits_struct
name|limits
index|[
name|RLIM_NLIMITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|login_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the max logins limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|login_limit_def
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which entry set the login limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_numsyslogins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether to limit logins only for a 				 specific user or to count all logins */
end_comment

begin_define
define|#
directive|define
name|LIMIT_LOGIN
value|RLIM_NLIMITS+1
end_define

begin_define
define|#
directive|define
name|LIMIT_NUMSYSLOGINS
value|RLIM_NLIMITS+2
end_define

begin_define
define|#
directive|define
name|LIMIT_SOFT
value|1
end_define

begin_define
define|#
directive|define
name|LIMIT_HARD
value|2
end_define

begin_define
define|#
directive|define
name|PAM_SM_SESSION
end_define

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_include
include|#
directive|include
file|<pwdb/pwdb_map.h>
end_include

begin_comment
comment|/* logging */
end_comment

begin_function
specifier|static
name|void
name|_pam_log
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"pam_limits"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* argument parsing */
end_comment

begin_define
define|#
directive|define
name|PAM_DEBUG_ARG
value|0x0001
end_define

begin_function
specifier|static
name|int
name|_pam_parse
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ctrl
init|=
literal|0
decl_stmt|;
comment|/* step through arguments */
for|for
control|(
name|ctrl
operator|=
literal|0
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
operator|++
name|argv
control|)
block|{
comment|/* generic options */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"debug"
argument_list|)
condition|)
name|ctrl
operator||=
name|PAM_DEBUG_ARG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"conf="
argument_list|,
literal|5
argument_list|)
condition|)
name|strcpy
argument_list|(
name|conf_file
argument_list|,
operator|*
name|argv
operator|+
literal|5
argument_list|)
expr_stmt|;
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_parse: unknown option; %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ctrl
return|;
block|}
end_function

begin_comment
comment|/* limits stuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIMITS_FILE
end_ifndef

begin_define
define|#
directive|define
name|LIMITS_FILE
value|"/etc/security/limits.conf"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LIMIT_ERR
value|1
end_define

begin_comment
comment|/* error setting a limit */
end_comment

begin_define
define|#
directive|define
name|LOGIN_ERR
value|2
end_define

begin_comment
comment|/* too many logins err */
end_comment

begin_comment
comment|/* Counts the number of user logins and check against the limit*/
end_comment

begin_function
specifier|static
name|int
name|check_logins
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|ctrl
parameter_list|)
block|{
name|struct
name|utmp
modifier|*
name|ut
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"checking logins for '%s' / %d\n"
argument_list|,
name|name
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no limits imposed */
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
comment|/* maximum 0 logins ? */
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"No logins allowed for '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|LOGIN_ERR
return|;
block|}
name|setutent
argument_list|()
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ut
operator|=
name|getutent
argument_list|()
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USER_PROCESS
if|if
condition|(
name|ut
operator|->
name|ut_type
operator|!=
name|USER_PROCESS
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|ut
operator|->
name|UT_USER
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|flag_numsyslogins
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|ut
operator|->
name|UT_USER
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|UT_USER
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|++
name|count
operator|>=
name|limit
condition|)
break|break;
block|}
name|endutent
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|name
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Too many logins (max %d) for %s"
argument_list|,
name|limit
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Too many system logins (max %d)"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
return|return
name|LOGIN_ERR
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* checks if a user is on a list of members of the GID 0 group */
end_comment

begin_function
specifier|static
name|int
name|is_on_list
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|list
argument_list|,
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|list
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Checks if a user is a member of a group */
end_comment

begin_function
specifier|static
name|int
name|is_on_group
parameter_list|(
specifier|const
name|char
modifier|*
name|user_name
parameter_list|,
specifier|const
name|char
modifier|*
name|group_name
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|,
modifier|*
name|pgrp
decl_stmt|;
name|char
name|uname
index|[
name|LINE_LENGTH
index|]
decl_stmt|,
name|gname
index|[
name|LINE_LENGTH
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|user_name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|group_name
argument_list|)
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|uname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|uname
argument_list|,
name|user_name
argument_list|,
name|LINE_LENGTH
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|gname
argument_list|,
name|group_name
argument_list|,
name|LINE_LENGTH
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pwd
condition|)
return|return
literal|0
return|;
comment|/* the info about this group */
name|setgrent
argument_list|()
expr_stmt|;
name|grp
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|grp
condition|)
return|return
literal|0
return|;
comment|/* first check: is a member of the group_name group ? */
if|if
condition|(
name|is_on_list
argument_list|(
name|grp
operator|->
name|gr_mem
argument_list|,
name|uname
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* next check: user primary group is group_name ? */
name|setgrent
argument_list|()
expr_stmt|;
name|pgrp
operator|=
name|getgrgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pgrp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pgrp
operator|->
name|gr_name
argument_list|,
name|gname
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_limits
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|retval
init|=
name|PAM_SUCCESS
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"called."
operator|)
argument_list|)
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_CPU
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_CPU
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_CPU
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_CPU
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_FSIZE
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_DATA
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_DATA
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_DATA
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_STACK
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_STACK
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_STACK
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_CORE
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_CORE
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_CORE
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_RSS
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_RSS
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_RSS
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_RSS
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_NPROC
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_NPROC
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_NPROC
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_NPROC
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_NOFILE
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_NOFILE
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_NOFILE
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_MEMLOCK
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_MEMLOCK
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_MEMLOCK
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_MEMLOCK
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|retval
operator||=
name|getrlimit
argument_list|(
name|RLIMIT_AS
argument_list|,
operator|&
name|limits
index|[
name|RLIMIT_AS
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|limits
index|[
name|RLIMIT_AS
index|]
operator|.
name|src_soft
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|limits
index|[
name|RLIMIT_AS
index|]
operator|.
name|src_hard
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
name|login_limit
operator|=
operator|-
literal|2
expr_stmt|;
name|login_limit_def
operator|=
name|LIMITS_DEF_NONE
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_limit
parameter_list|(
name|int
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|lim_type
parameter_list|,
specifier|const
name|char
modifier|*
name|lim_item
parameter_list|,
specifier|const
name|char
modifier|*
name|lim_value
parameter_list|,
name|int
name|ctrl
parameter_list|)
block|{
name|int
name|limit_item
decl_stmt|;
name|int
name|limit_type
init|=
literal|0
decl_stmt|;
name|long
name|limit_value
decl_stmt|;
name|char
modifier|*
modifier|*
name|endptr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|lim_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|value_orig
init|=
name|lim_value
decl_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: processing(%d) %s %s %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|source
argument_list|,
name|lim_type
argument_list|,
name|lim_item
argument_list|,
name|lim_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"cpu"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_CPU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"fsize"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_FSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"stack"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_STACK
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"core"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_CORE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"rss"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_RSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"nproc"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_NPROC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"nofile"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_NOFILE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"memlock"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_MEMLOCK
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"as"
argument_list|)
operator|==
literal|0
condition|)
name|limit_item
operator|=
name|RLIMIT_AS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"maxlogins"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|limit_item
operator|=
name|LIMIT_LOGIN
expr_stmt|;
name|flag_numsyslogins
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_item
argument_list|,
literal|"maxsyslogins"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|limit_item
operator|=
name|LIMIT_NUMSYSLOGINS
expr_stmt|;
name|flag_numsyslogins
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unknown limit item '%s'"
argument_list|,
name|lim_item
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|lim_type
argument_list|,
literal|"soft"
argument_list|)
operator|==
literal|0
condition|)
name|limit_type
operator|=
name|LIMIT_SOFT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_type
argument_list|,
literal|"hard"
argument_list|)
operator|==
literal|0
condition|)
name|limit_type
operator|=
name|LIMIT_HARD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lim_type
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|limit_type
operator|=
name|LIMIT_SOFT
operator||
name|LIMIT_HARD
expr_stmt|;
elseif|else
if|if
condition|(
name|limit_item
operator|!=
name|LIMIT_LOGIN
operator|&&
name|limit_item
operator|!=
name|LIMIT_NUMSYSLOGINS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unknown limit type '%s'"
argument_list|,
name|lim_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|limit_value
operator|=
name|strtol
argument_list|(
name|lim_value
argument_list|,
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit_value
operator|==
literal|0
operator|&&
name|value_orig
operator|==
operator|*
name|endptr
condition|)
block|{
comment|/* no chars read */
if|if
condition|(
name|strcmp
argument_list|(
name|lim_value
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"wrong limit value '%s'"
argument_list|,
name|lim_value
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|limit_item
operator|!=
name|LIMIT_LOGIN
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"'-' limit value valid for maxlogins type only"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|limit_value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|limit_item
condition|)
block|{
case|case
name|RLIMIT_CPU
case|:
name|limit_value
operator|*=
literal|60
expr_stmt|;
break|break;
case|case
name|RLIMIT_FSIZE
case|:
case|case
name|RLIMIT_DATA
case|:
case|case
name|RLIMIT_STACK
case|:
case|case
name|RLIMIT_CORE
case|:
case|case
name|RLIMIT_RSS
case|:
case|case
name|RLIMIT_MEMLOCK
case|:
case|case
name|RLIMIT_AS
case|:
name|limit_value
operator|*=
literal|1024
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|limit_item
operator|!=
name|LIMIT_LOGIN
operator|&&
name|limit_item
operator|!=
name|LIMIT_NUMSYSLOGINS
condition|)
block|{
if|if
condition|(
name|limit_type
operator|&
name|LIMIT_SOFT
condition|)
if|if
condition|(
name|limits
index|[
name|limit_item
index|]
operator|.
name|src_soft
operator|<
name|source
condition|)
return|return;
else|else
block|{
name|limits
index|[
name|limit_item
index|]
operator|.
name|limit
operator|.
name|rlim_cur
operator|=
name|limit_value
expr_stmt|;
name|limits
index|[
name|limit_item
index|]
operator|.
name|src_soft
operator|=
name|source
expr_stmt|;
block|}
if|if
condition|(
name|limit_type
operator|&
name|LIMIT_HARD
condition|)
if|if
condition|(
name|limits
index|[
name|limit_item
index|]
operator|.
name|src_hard
operator|<
name|source
condition|)
return|return;
else|else
block|{
name|limits
index|[
name|limit_item
index|]
operator|.
name|limit
operator|.
name|rlim_max
operator|=
name|limit_value
expr_stmt|;
name|limits
index|[
name|limit_item
index|]
operator|.
name|src_hard
operator|=
name|source
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|login_limit_def
operator|<
name|source
condition|)
return|return;
else|else
block|{
name|login_limit
operator|=
name|limit_value
expr_stmt|;
name|login_limit_def
operator|=
name|source
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_config_file
parameter_list|(
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|int
name|ctrl
parameter_list|)
block|{
name|FILE
modifier|*
name|fil
decl_stmt|;
name|char
name|buf
index|[
name|LINE_LENGTH
index|]
decl_stmt|;
define|#
directive|define
name|CONF_FILE
value|(conf_file[0])?conf_file:LIMITS_FILE
comment|/* check for the LIMITS_FILE */
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reading settings from '%s'"
argument_list|,
name|CONF_FILE
argument_list|)
expr_stmt|;
name|fil
operator|=
name|fopen
argument_list|(
name|CONF_FILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fil
operator|==
name|NULL
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can not read settings from %s"
argument_list|,
name|CONF_FILE
argument_list|)
expr_stmt|;
return|return
name|PAM_SERVICE_ERR
return|;
block|}
undef|#
directive|undef
name|CONF_FILE
comment|/* init things */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start the show */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINE_LENGTH
argument_list|,
name|fil
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|domain
index|[
name|LINE_LENGTH
index|]
decl_stmt|;
name|char
name|ltype
index|[
name|LINE_LENGTH
index|]
decl_stmt|;
name|char
name|item
index|[
name|LINE_LENGTH
index|]
decl_stmt|;
name|char
name|value
index|[
name|LINE_LENGTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|tptr
decl_stmt|;
name|tptr
operator|=
name|buf
expr_stmt|;
comment|/* skip the leading white space */
while|while
condition|(
operator|*
name|tptr
operator|&&
name|isspace
argument_list|(
operator|*
name|tptr
argument_list|)
condition|)
name|tptr
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|tptr
argument_list|)
expr_stmt|;
comment|/* Rip off the comments */
name|tptr
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tptr
condition|)
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Rip off the newline char */
name|tptr
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tptr
condition|)
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Anything left ? */
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memset
argument_list|(
name|domain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ltype
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ltype
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|domain
argument_list|,
name|ltype
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|domain
argument_list|)
condition|;
name|j
operator|++
control|)
name|domain
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|domain
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|ltype
argument_list|)
condition|;
name|j
operator|++
control|)
name|ltype
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|ltype
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|item
argument_list|)
condition|;
name|j
operator|++
control|)
name|item
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|item
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|value
argument_list|)
condition|;
name|j
operator|++
control|)
name|value
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|value
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|4
condition|)
block|{
comment|/* a complete line */
if|if
condition|(
name|strcmp
argument_list|(
name|uname
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
comment|/* this user have a limit */
name|process_limit
argument_list|(
name|LIMITS_DEF_USER
argument_list|,
name|ltype
argument_list|,
name|item
argument_list|,
name|value
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|domain
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|is_on_group
argument_list|(
name|uname
argument_list|,
name|domain
operator|+
literal|1
argument_list|)
condition|)
name|process_limit
argument_list|(
name|LIMITS_DEF_GROUP
argument_list|,
name|ltype
argument_list|,
name|item
argument_list|,
name|value
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|domain
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|process_limit
argument_list|(
name|LIMITS_DEF_DEFAULT
argument_list|,
name|ltype
argument_list|,
name|item
argument_list|,
name|value
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
else|else
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"invalid line '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fil
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_limits
parameter_list|(
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|int
name|ctrl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|retval
init|=
name|PAM_SUCCESS
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RLIM_NLIMITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|limits
index|[
name|i
index|]
operator|.
name|limit
operator|.
name|rlim_cur
operator|>
name|limits
index|[
name|i
index|]
operator|.
name|limit
operator|.
name|rlim_max
condition|)
name|limits
index|[
name|i
index|]
operator|.
name|limit
operator|.
name|rlim_cur
operator|=
name|limits
index|[
name|i
index|]
operator|.
name|limit
operator|.
name|rlim_max
expr_stmt|;
name|retval
operator||=
name|setrlimit
argument_list|(
name|i
argument_list|,
operator|&
name|limits
index|[
name|i
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
name|retval
operator|=
name|LIMIT_ERR
expr_stmt|;
if|if
condition|(
name|login_limit
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|check_logins
argument_list|(
name|uname
argument_list|,
name|login_limit
argument_list|,
name|ctrl
argument_list|)
operator|==
name|LOGIN_ERR
condition|)
name|retval
operator||=
name|LOGIN_ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|login_limit
operator|==
literal|0
condition|)
name|retval
operator||=
name|LOGIN_ERR
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* now the session stuff */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_open_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|user_name
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|int
name|ctrl
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"called."
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|conf_file
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conf_file
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|_pam_parse
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_USER
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_name
operator|==
name|NULL
operator|||
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"open_session - error recovering username"
argument_list|)
expr_stmt|;
return|return
name|PAM_SESSION_ERR
return|;
block|}
name|setpwent
argument_list|()
expr_stmt|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pwd
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"open_session username '%s' does not exist"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
return|return
name|PAM_SESSION_ERR
return|;
block|}
comment|/* do not impose limits on UID 0 accounts */
if|if
condition|(
operator|!
name|pwd
operator|->
name|pw_uid
condition|)
block|{
if|if
condition|(
name|ctrl
operator|&
name|PAM_DEBUG_ARG
condition|)
name|_pam_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"user '%s' have UID 0 - no limits imposed"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
name|retval
operator|=
name|init_limits
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can not initialize"
argument_list|)
expr_stmt|;
return|return
name|PAM_IGNORE
return|;
block|}
name|retval
operator|=
name|parse_config_file
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_pam_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"error parsing the configuration file"
argument_list|)
expr_stmt|;
return|return
name|PAM_IGNORE
return|;
block|}
name|retval
operator|=
name|setup_limits
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|&
name|LOGIN_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"\nToo many logins for '%s'\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_close_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* nothing to do */
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* static module data */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_limits_modstruct
init|=
block|{
literal|"pam_limits"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|pam_sm_open_session
block|,
name|pam_sm_close_session
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Copyright (c) Cristian Gafton, 1996-1997,<gafton@redhat.com>  *                                              All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *   * ALTERNATIVELY, this product may be distributed under the terms of  * the GNU Public License, in which case the provisions of the GPL are  * required INSTEAD OF the above restrictions.  (This clause is  * necessary due to a potential bad interaction between the GPL and  * the restrictions contained in a BSD-style copyright.)  *   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

end_unit

