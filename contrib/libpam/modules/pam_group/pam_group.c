begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pam_group module */
end_comment

begin_comment
comment|/*  * $Id: pam_group.c,v 1.3 2000/11/26 07:32:39 agmorgan Exp $  *  * Written by Andrew Morgan<morgan@linux.kernel.org> 1996/7/6  */
end_comment

begin_decl_stmt
specifier|const
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: pam_group.c,v 1.3 2000/11/26 07:32:39 agmorgan Exp $;\n"
literal|"Version 0.5 for Linux-PAM\n"
literal|"Copyright (c) Andrew G. Morgan 1996<morgan@linux.kernel.org>\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|_BSD_SOURCE
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CONF_FILE
end_ifdef

begin_define
define|#
directive|define
name|PAM_GROUP_CONF
value|DEFAULT_CONF_FILE
end_define

begin_comment
comment|/* from external define */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PAM_GROUP_CONF
value|"/etc/security/group.conf"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAM_GROUP_BUFLEN
value|1000
end_define

begin_define
define|#
directive|define
name|FIELD_SEPARATOR
value|';'
end_define

begin_comment
comment|/* this is new as of .02 */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FALSE
block|,
name|TRUE
block|}
name|boolean
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|AND
block|,
name|OR
block|}
name|operator
typedef|;
end_typedef

begin_comment
comment|/*  * here, we make definitions for the externally accessible functions  * in this file (these definitions are required for static modules  * but strongly encouraged generally) they are used to instruct the  * modules include file to define their prototypes.  */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_AUTH
end_define

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_comment
comment|/* --- static functions for checking whether the user should be let in --- */
end_comment

begin_function
specifier|static
name|void
name|_log_err
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"pam_group"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shift_bytes
parameter_list|(
name|char
modifier|*
name|mem
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|by
parameter_list|)
block|{
while|while
condition|(
name|by
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|mem
operator|=
name|mem
index|[
name|from
index|]
expr_stmt|;
operator|++
name|mem
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|read_field
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|)
block|{
comment|/* is buf set ? */
if|if
condition|(
operator|!
operator|*
name|buf
condition|)
block|{
operator|*
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|PAM_GROUP_BUFLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|buf
condition|)
block|{
name|_log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|from
operator|=
operator|*
name|to
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|PAM_GROUP_CONF
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
comment|/* do we have a file open ? return error */
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
operator|*
name|to
operator|<=
literal|0
condition|)
block|{
name|_log_err
argument_list|(
name|PAM_GROUP_CONF
literal|" not opened"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|buf
argument_list|,
literal|0
argument_list|,
name|PAM_GROUP_BUFLEN
argument_list|)
expr_stmt|;
name|_pam_drop
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check if there was a newline last time */
if|if
condition|(
operator|(
operator|*
name|to
operator|>
operator|*
name|from
operator|)
operator|&&
operator|(
operator|*
name|to
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|*
name|buf
operator|)
index|[
operator|*
name|from
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* previous line ended */
operator|(
operator|*
name|from
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|fd
return|;
block|}
comment|/* ready for more data: first shift the buffer's remaining data */
operator|*
name|to
operator|-=
operator|*
name|from
expr_stmt|;
name|shift_bytes
argument_list|(
operator|*
name|buf
argument_list|,
operator|*
name|from
argument_list|,
operator|*
name|to
argument_list|)
expr_stmt|;
operator|*
name|from
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
operator|*
name|to
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fd
operator|>=
literal|0
operator|&&
operator|*
name|to
operator|<
name|PAM_GROUP_BUFLEN
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* now try to fill the remainder of the buffer */
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|*
name|to
operator|+
operator|*
name|buf
argument_list|,
name|PAM_GROUP_BUFLEN
operator|-
operator|*
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|_log_err
argument_list|(
literal|"error reading "
name|PAM_GROUP_CONF
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* end of file reached */
block|}
else|else
operator|*
name|to
operator|+=
name|i
expr_stmt|;
comment|/* 	 * contract the buffer. Delete any comments, and replace all 	 * multiple spaces with single commas 	 */
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DUMP
name|D
argument_list|(
operator|(
literal|"buffer=<%s>"
operator|,
operator|*
name|buf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|i
operator|<
operator|*
name|to
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|==
literal|','
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|j
operator|<
operator|*
name|to
operator|&&
operator|(
operator|*
name|buf
operator|)
index|[
name|j
index|]
operator|==
literal|','
condition|;
operator|++
name|j
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
name|shift_bytes
argument_list|(
name|i
operator|+
operator|(
operator|*
name|buf
operator|)
argument_list|,
name|j
operator|-
name|i
argument_list|,
operator|(
operator|*
name|to
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
operator|*
name|to
operator|-=
name|j
operator|-
name|i
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
condition|)
block|{
name|int
name|j
decl_stmt|,
name|c
decl_stmt|;
case|case
literal|'#'
case|:
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
operator|*
name|to
operator|&&
operator|(
name|c
operator|=
operator|(
operator|*
name|buf
operator|)
index|[
name|j
index|]
operator|)
operator|!=
literal|'\n'
condition|;
operator|++
name|j
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|>=
operator|*
name|to
condition|)
block|{
operator|(
operator|*
name|buf
operator|)
index|[
operator|*
name|to
operator|=
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|shift_bytes
argument_list|(
name|i
operator|+
operator|(
operator|*
name|buf
operator|)
argument_list|,
name|j
operator|-
name|i
argument_list|,
operator|(
operator|*
name|to
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
operator|*
name|to
operator|-=
name|j
operator|-
name|i
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|_log_err
argument_list|(
literal|"internal error in "
name|__FILE__
literal|" at line %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
operator|*
name|buf
operator|)
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|shift_bytes
argument_list|(
name|i
operator|+
operator|*
name|buf
argument_list|,
literal|2
argument_list|,
operator|*
name|to
operator|-
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|*
name|to
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
comment|/* we don't escape non-newline characters */
block|}
break|break;
case|case
literal|'!'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|!=
literal|'!'
condition|)
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|=
literal|','
expr_stmt|;
comment|/* delete any trailing spaces */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|j
operator|<
operator|*
name|to
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
operator|*
name|buf
operator|)
index|[
name|j
index|]
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|;
operator|++
name|j
control|)
empty_stmt|;
name|shift_bytes
argument_list|(
name|i
operator|+
operator|*
name|buf
argument_list|,
name|j
operator|-
name|i
argument_list|,
operator|(
operator|*
name|to
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
operator|*
name|to
operator|-=
name|j
operator|-
name|i
expr_stmt|;
break|break;
default|default:
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
operator|(
operator|*
name|buf
operator|)
index|[
operator|*
name|to
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* now return the next field (set the from/to markers) */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|to
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'\n'
case|:
comment|/* end of the line/file */
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|from
operator|=
name|i
expr_stmt|;
return|return
name|fd
return|;
case|case
name|FIELD_SEPARATOR
case|:
comment|/* end of the field */
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|from
operator|=
operator|++
name|i
expr_stmt|;
return|return
name|fd
return|;
block|}
block|}
operator|*
name|from
operator|=
name|i
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
operator|*
name|from
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|to
operator|<=
literal|0
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"[end of text]"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* read a member from a field */
end_comment

begin_function
specifier|static
name|int
name|logic_member
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|at
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|c
decl_stmt|,
name|to
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|token
init|=
literal|0
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|to
operator|=
operator|*
name|at
expr_stmt|;
do|do
block|{
name|c
operator|=
name|string
index|[
name|to
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
operator|--
name|to
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'!'
case|:
if|if
condition|(
name|token
condition|)
block|{
operator|--
name|to
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'*'
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'/'
condition|)
block|{
name|token
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
condition|)
block|{
operator|--
name|to
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
operator|*
name|at
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
name|to
operator|-
operator|*
name|at
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|VAL
block|,
name|OP
block|}
name|expect
typedef|;
end_typedef

begin_function
specifier|static
name|boolean
name|logic_field
parameter_list|(
specifier|const
name|void
modifier|*
name|me
parameter_list|,
specifier|const
name|char
modifier|*
name|x
parameter_list|,
name|int
name|rule
parameter_list|,
name|boolean
function_decl|(
modifier|*
name|agrees
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|boolean
name|left
init|=
name|FALSE
decl_stmt|,
name|right
decl_stmt|,
name|not
init|=
name|FALSE
decl_stmt|;
name|operator
name|oper
init|=
name|OR
decl_stmt|;
name|int
name|at
init|=
literal|0
decl_stmt|,
name|l
decl_stmt|;
name|expect
name|next
init|=
name|VAL
decl_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|logic_member
argument_list|(
name|x
argument_list|,
operator|&
name|at
argument_list|)
operator|)
condition|)
block|{
name|int
name|c
init|=
name|x
index|[
name|at
index|]
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|VAL
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'*'
condition|)
block|{
name|right
operator|=
name|not
operator|^
name|agrees
argument_list|(
name|me
argument_list|,
name|x
operator|+
name|at
argument_list|,
name|l
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
operator|==
name|AND
condition|)
name|left
operator|&=
name|right
expr_stmt|;
else|else
name|left
operator||=
name|right
expr_stmt|;
name|next
operator|=
name|OP
expr_stmt|;
block|}
else|else
block|{
name|_log_err
argument_list|(
literal|"garbled syntax; expected name (rule #%d)"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* OP */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'&'
case|:
name|oper
operator|=
name|AND
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|oper
operator|=
name|OR
expr_stmt|;
break|break;
default|default:
name|_log_err
argument_list|(
literal|"garbled syntax; expected& or | (rule #%d)"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"%c at %d"
operator|,
name|c
operator|,
name|at
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|next
operator|=
name|VAL
expr_stmt|;
block|}
name|at
operator|+=
name|l
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|is_same
parameter_list|(
specifier|const
name|void
modifier|*
name|A
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rule
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|A
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|i
operator|,
operator|--
name|len
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
index|]
operator|!=
name|a
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|b
index|[
name|i
operator|++
index|]
operator|==
literal|'*'
condition|)
block|{
return|return
operator|(
operator|!
operator|--
name|len
operator|||
operator|!
name|strncmp
argument_list|(
name|b
operator|+
name|i
argument_list|,
name|a
operator|+
name|strlen
argument_list|(
name|a
argument_list|)
operator|-
name|len
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
block|}
return|return
operator|(
operator|!
name|len
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|day
decl_stmt|;
comment|/* array of 7 bits, one set for today */
name|int
name|minute
decl_stmt|;
comment|/* integer, hour*100+minute for now */
block|}
name|TIME
typedef|;
end_typedef

begin_struct
struct|struct
name|day
block|{
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
decl|static const
name|days
index|[
literal|11
index|]
init|=
block|{
block|{
literal|"su"
block|,
literal|01
block|}
block|,
block|{
literal|"mo"
block|,
literal|02
block|}
block|,
block|{
literal|"tu"
block|,
literal|04
block|}
block|,
block|{
literal|"we"
block|,
literal|010
block|}
block|,
block|{
literal|"th"
block|,
literal|020
block|}
block|,
block|{
literal|"fr"
block|,
literal|040
block|}
block|,
block|{
literal|"sa"
block|,
literal|0100
block|}
block|,
block|{
literal|"wk"
block|,
literal|076
block|}
block|,
block|{
literal|"wd"
block|,
literal|0101
block|}
block|,
block|{
literal|"al"
block|,
literal|0177
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|TIME
name|time_now
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|local
decl_stmt|;
name|time_t
name|the_time
decl_stmt|;
name|TIME
name|this
decl_stmt|;
name|the_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* get the current time */
name|local
operator|=
name|localtime
argument_list|(
operator|&
name|the_time
argument_list|)
expr_stmt|;
name|this
operator|.
name|day
operator|=
name|days
index|[
name|local
operator|->
name|tm_wday
index|]
operator|.
name|bit
expr_stmt|;
name|this
operator|.
name|minute
operator|=
name|local
operator|->
name|tm_hour
operator|*
literal|100
operator|+
name|local
operator|->
name|tm_min
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"day: 0%o, time: %.4d"
operator|,
name|this
operator|.
name|day
operator|,
name|this
operator|.
name|minute
operator|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/* take the current date and see if the range "date" passes it */
end_comment

begin_function
specifier|static
name|boolean
name|check_time
parameter_list|(
specifier|const
name|void
modifier|*
name|AT
parameter_list|,
specifier|const
name|char
modifier|*
name|times
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rule
parameter_list|)
block|{
name|boolean
name|not
decl_stmt|,
name|pass
decl_stmt|;
name|int
name|marked_day
decl_stmt|,
name|time_start
decl_stmt|,
name|time_end
decl_stmt|;
specifier|const
name|TIME
modifier|*
name|at
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|at
operator|=
name|AT
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"checking: 0%o/%.4d vs. %s"
operator|,
name|at
operator|->
name|day
operator|,
name|at
operator|->
name|minute
operator|,
name|times
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|times
operator|==
name|NULL
condition|)
block|{
comment|/* this should not happen */
name|_log_err
argument_list|(
literal|"internal error: "
name|__FILE__
literal|" line %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|times
index|[
name|j
index|]
operator|==
literal|'!'
condition|)
block|{
operator|++
name|j
expr_stmt|;
name|not
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|not
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|marked_day
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|isalpha
argument_list|(
name|times
index|[
name|j
index|]
argument_list|)
condition|;
operator|--
name|len
control|)
block|{
name|int
name|this_day
init|=
operator|-
literal|1
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"%c%c ?"
operator|,
name|times
index|[
name|j
index|]
operator|,
name|times
index|[
name|j
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|days
index|[
name|i
index|]
operator|.
name|d
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tolower
argument_list|(
name|times
index|[
name|j
index|]
argument_list|)
operator|==
name|days
index|[
name|i
index|]
operator|.
name|d
index|[
literal|0
index|]
operator|&&
name|tolower
argument_list|(
name|times
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
operator|==
name|days
index|[
name|i
index|]
operator|.
name|d
index|[
literal|1
index|]
condition|)
block|{
name|this_day
operator|=
name|days
index|[
name|i
index|]
operator|.
name|bit
expr_stmt|;
break|break;
block|}
block|}
name|j
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|this_day
operator|==
operator|-
literal|1
condition|)
block|{
name|_log_err
argument_list|(
literal|"bad day specified (rule #%d)"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|marked_day
operator|^=
name|this_day
expr_stmt|;
block|}
if|if
condition|(
name|marked_day
operator|==
literal|0
condition|)
block|{
name|_log_err
argument_list|(
literal|"no day specified"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|D
argument_list|(
operator|(
literal|"day range = 0%o"
operator|,
name|marked_day
operator|)
argument_list|)
expr_stmt|;
name|time_start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|i
operator|<
literal|4
operator|&&
name|isdigit
argument_list|(
name|times
index|[
name|i
operator|+
name|j
index|]
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|--
name|len
control|)
block|{
name|time_start
operator|*=
literal|10
expr_stmt|;
name|time_start
operator|+=
name|times
index|[
name|i
operator|+
name|j
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* is this portable? */
block|}
name|j
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|times
index|[
name|j
index|]
operator|==
literal|'-'
condition|)
block|{
name|time_end
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|len
operator|>
literal|0
operator|&&
name|i
operator|<
literal|5
operator|&&
name|isdigit
argument_list|(
name|times
index|[
name|i
operator|+
name|j
index|]
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|--
name|len
control|)
block|{
name|time_end
operator|*=
literal|10
expr_stmt|;
name|time_end
operator|+=
name|times
index|[
name|i
operator|+
name|j
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* is this portable? */
block|}
name|j
operator|+=
name|i
expr_stmt|;
block|}
else|else
name|time_end
operator|=
operator|-
literal|1
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"i=%d, time_end=%d, times[j]='%c'"
operator|,
name|i
operator|,
name|time_end
operator|,
name|times
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|5
operator|||
name|time_end
operator|==
operator|-
literal|1
condition|)
block|{
name|_log_err
argument_list|(
literal|"no/bad times specified (rule #%d)"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|D
argument_list|(
operator|(
literal|"times(%d to %d)"
operator|,
name|time_start
operator|,
name|time_end
operator|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"marked_day = 0%o"
operator|,
name|marked_day
operator|)
argument_list|)
expr_stmt|;
comment|/* compare with the actual time now */
name|pass
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|time_start
operator|<
name|time_end
condition|)
block|{
comment|/* start< end ? --> same day */
if|if
condition|(
operator|(
name|at
operator|->
name|day
operator|&
name|marked_day
operator|)
operator|&&
operator|(
name|at
operator|->
name|minute
operator|>=
name|time_start
operator|)
operator|&&
operator|(
name|at
operator|->
name|minute
operator|<
name|time_end
operator|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"time is listed"
operator|)
argument_list|)
expr_stmt|;
name|pass
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* spans two days */
if|if
condition|(
operator|(
name|at
operator|->
name|day
operator|&
name|marked_day
operator|)
operator|&&
operator|(
name|at
operator|->
name|minute
operator|>=
name|time_start
operator|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"caught on first day"
operator|)
argument_list|)
expr_stmt|;
name|pass
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|marked_day
operator|<<=
literal|1
expr_stmt|;
name|marked_day
operator||=
operator|(
name|marked_day
operator|&
literal|0200
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"next day = 0%o"
operator|,
name|marked_day
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|->
name|day
operator|&
name|marked_day
operator|)
operator|&&
operator|(
name|at
operator|->
name|minute
operator|<=
name|time_end
operator|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"caught on second day"
operator|)
argument_list|)
expr_stmt|;
name|pass
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|not
operator|^
name|pass
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_member
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|at
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|c
decl_stmt|,
name|to
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|token
init|=
literal|0
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|to
operator|=
operator|*
name|at
expr_stmt|;
do|do
block|{
name|c
operator|=
name|string
index|[
name|to
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
operator|--
name|to
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'!'
case|:
if|if
condition|(
name|token
condition|)
block|{
operator|--
name|to
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|token
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
condition|)
block|{
operator|--
name|to
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
operator|*
name|at
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
name|to
operator|-
operator|*
name|at
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GROUP_BLK
value|10
end_define

begin_define
define|#
directive|define
name|blk_size
parameter_list|(
name|len
parameter_list|)
value|(((len-1 + GROUP_BLK)/GROUP_BLK)*GROUP_BLK)
end_define

begin_function
specifier|static
name|int
name|mkgrplist
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|gid_t
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|at
init|=
literal|0
decl_stmt|;
name|int
name|blks
decl_stmt|;
name|blks
operator|=
name|blk_size
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"cf. blks=%d and len=%d"
operator|,
name|blks
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|find_member
argument_list|(
name|buf
argument_list|,
operator|&
name|at
argument_list|)
operator|)
condition|)
block|{
name|int
name|edge
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|blks
condition|)
block|{
name|gid_t
modifier|*
name|tmp
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"allocating new block"
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|gid_t
operator|*
operator|)
name|realloc
argument_list|(
operator|(
operator|*
name|list
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
operator|*
operator|(
name|blks
operator|+=
name|GROUP_BLK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|list
operator|)
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|_log_err
argument_list|(
literal|"out of memory for group list"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
operator|(
operator|*
name|list
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* '\0' terminate the entry */
name|edge
operator|=
operator|(
name|buf
index|[
name|at
operator|+
name|l
index|]
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|buf
index|[
name|at
operator|+
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"found group: %s"
operator|,
name|buf
operator|+
name|at
operator|)
argument_list|)
expr_stmt|;
comment|/* this is where we convert a group name to a gid_t */
ifdef|#
directive|ifdef
name|WANT_PWDB
block|{
name|int
name|retval
decl_stmt|;
specifier|const
name|struct
name|pwdb
modifier|*
name|pw
init|=
name|NULL
decl_stmt|;
name|retval
operator|=
name|pwdb_locate
argument_list|(
literal|"group"
argument_list|,
name|PWDB_DEFAULT
argument_list|,
name|buf
operator|+
name|at
argument_list|,
name|PWDB_ID_UNKNOWN
argument_list|,
operator|&
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PWDB_SUCCESS
condition|)
block|{
name|_log_err
argument_list|(
literal|"bad group: %s; %s"
argument_list|,
name|buf
operator|+
name|at
argument_list|,
name|pwdb_strerror
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|pwdb_entry
modifier|*
name|pwe
init|=
name|NULL
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"group %s exists"
operator|,
name|buf
operator|+
name|at
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|pwdb_get_entry
argument_list|(
name|pw
argument_list|,
literal|"gid"
argument_list|,
operator|&
name|pwe
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|PWDB_SUCCESS
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"gid = %d [%p]"
operator|,
operator|*
operator|(
specifier|const
name|gid_t
operator|*
operator|)
name|pwe
operator|->
name|value
operator|,
name|list
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
name|len
operator|++
index|]
operator|=
operator|*
operator|(
specifier|const
name|gid_t
operator|*
operator|)
name|pwe
operator|->
name|value
expr_stmt|;
name|pwdb_entry_delete
argument_list|(
operator|&
name|pwe
argument_list|)
expr_stmt|;
comment|/* tidy up */
block|}
else|else
block|{
name|_log_err
argument_list|(
literal|"%s group entry is bad; %s"
argument_list|,
name|pwdb_strerror
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pw
operator|=
name|NULL
expr_stmt|;
comment|/* break link - cached for later use */
block|}
block|}
else|#
directive|else
block|{
specifier|const
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|grp
operator|=
name|getgrnam
argument_list|(
name|buf
operator|+
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
name|_log_err
argument_list|(
literal|"bad group: %s"
argument_list|,
name|buf
operator|+
name|at
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"group %s exists"
operator|,
name|buf
operator|+
name|at
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
name|len
operator|++
index|]
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* next entry along */
name|at
operator|+=
name|l
operator|+
name|edge
expr_stmt|;
block|}
name|D
argument_list|(
operator|(
literal|"returning with [%p/len=%d]->%p"
operator|,
name|list
operator|,
name|len
operator|,
operator|*
name|list
operator|)
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_account
parameter_list|(
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|tty
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|)
block|{
name|int
name|from
init|=
literal|0
decl_stmt|,
name|to
init|=
literal|0
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|TIME
name|here_and_now
decl_stmt|;
name|int
name|retval
init|=
name|PAM_SUCCESS
decl_stmt|;
name|gid_t
modifier|*
name|grps
decl_stmt|;
name|int
name|no_grps
decl_stmt|;
comment|/*      * first we get the current list of groups - the application      * will have previously done an initgroups(), or equivalent.      */
name|D
argument_list|(
operator|(
literal|"counting supplementary groups"
operator|)
argument_list|)
expr_stmt|;
name|no_grps
operator|=
name|getgroups
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* find the current number of groups */
if|if
condition|(
name|no_grps
operator|>
literal|0
condition|)
block|{
name|grps
operator|=
name|calloc
argument_list|(
name|blk_size
argument_list|(
name|no_grps
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"copying current list into grps [%d big]"
operator|,
name|blk_size
argument_list|(
name|no_grps
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getgroups
argument_list|(
name|no_grps
argument_list|,
name|grps
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|z
decl_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|no_grps
condition|;
operator|++
name|z
control|)
block|{
name|D
argument_list|(
operator|(
literal|"gid[%d]=%d"
operator|,
name|z
operator|,
name|grps
index|[
name|z
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"no supplementary groups known"
operator|)
argument_list|)
expr_stmt|;
name|no_grps
operator|=
literal|0
expr_stmt|;
name|grps
operator|=
name|NULL
expr_stmt|;
block|}
name|here_and_now
operator|=
name|time_now
argument_list|()
expr_stmt|;
comment|/* find current time */
comment|/* parse the rules in the configuration file */
do|do
block|{
name|int
name|good
init|=
name|TRUE
decl_stmt|;
comment|/* here we get the service name field */
name|fd
operator|=
name|read_field
argument_list|(
name|fd
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|buffer
index|[
literal|0
index|]
condition|)
block|{
comment|/* empty line .. ? */
continue|continue;
block|}
operator|++
name|count
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"working on rule #%d"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|good
operator|=
name|logic_field
argument_list|(
name|service
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|,
name|is_same
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"with service: %s"
operator|,
name|good
condition|?
literal|"passes"
else|:
literal|"fails"
operator|)
argument_list|)
expr_stmt|;
comment|/* here we get the terminal name field */
name|fd
operator|=
name|read_field
argument_list|(
name|fd
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|buffer
index|[
literal|0
index|]
condition|)
block|{
name|_log_err
argument_list|(
name|PAM_GROUP_CONF
literal|"; no tty entry #%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|good
operator|&=
name|logic_field
argument_list|(
name|tty
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|,
name|is_same
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"with tty: %s"
operator|,
name|good
condition|?
literal|"passes"
else|:
literal|"fails"
operator|)
argument_list|)
expr_stmt|;
comment|/* here we get the username field */
name|fd
operator|=
name|read_field
argument_list|(
name|fd
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|buffer
index|[
literal|0
index|]
condition|)
block|{
name|_log_err
argument_list|(
name|PAM_GROUP_CONF
literal|"; no user entry #%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|good
operator|&=
name|logic_field
argument_list|(
name|user
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|,
name|is_same
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"with user: %s"
operator|,
name|good
condition|?
literal|"passes"
else|:
literal|"fails"
operator|)
argument_list|)
expr_stmt|;
comment|/* here we get the time field */
name|fd
operator|=
name|read_field
argument_list|(
name|fd
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|buffer
index|[
literal|0
index|]
condition|)
block|{
name|_log_err
argument_list|(
name|PAM_GROUP_CONF
literal|"; no time entry #%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|good
operator|&=
name|logic_field
argument_list|(
operator|&
name|here_and_now
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|,
name|check_time
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"with time: %s"
operator|,
name|good
condition|?
literal|"passes"
else|:
literal|"fails"
operator|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|read_field
argument_list|(
name|fd
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|buffer
index|[
literal|0
index|]
condition|)
block|{
name|_log_err
argument_list|(
name|PAM_GROUP_CONF
literal|"; no listed groups for rule #%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * so we have a list of groups, we need to turn it into 	 * something to send to setgroups(2) 	 */
if|if
condition|(
name|good
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"adding %s to gid list"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
name|good
operator|=
name|mkgrplist
argument_list|(
name|buffer
argument_list|,
operator|&
name|grps
argument_list|,
name|no_grps
argument_list|)
expr_stmt|;
if|if
condition|(
name|good
operator|<
literal|0
condition|)
block|{
name|no_grps
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|no_grps
operator|=
name|good
expr_stmt|;
block|}
block|}
comment|/* check the line is terminated correctly */
name|fd
operator|=
name|read_field
argument_list|(
name|fd
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|&&
name|buffer
index|[
literal|0
index|]
condition|)
block|{
name|_log_err
argument_list|(
name|PAM_GROUP_CONF
literal|"; poorly terminated rule #%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|good
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"rule #%d passed, added %d groups"
operator|,
name|count
operator|,
name|good
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|good
operator|<
literal|0
condition|)
block|{
name|retval
operator|=
name|PAM_BUF_ERR
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"rule #%d failed"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|buffer
condition|)
do|;
comment|/* now set the groups for the user */
if|if
condition|(
name|no_grps
operator|>
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"trying to set %d groups"
operator|,
name|no_grps
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|err
operator|=
literal|0
init|;
name|err
operator|<
name|no_grps
condition|;
operator|++
name|err
control|)
block|{
name|D
argument_list|(
operator|(
literal|"gid[%d]=%d"
operator|,
name|err
operator|,
name|grps
index|[
name|err
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|err
operator|=
name|setgroups
argument_list|(
name|no_grps
argument_list|,
name|grps
argument_list|)
operator|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"but couldn't set groups %d"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
literal|"unable to set the group membership for user (err=%d)"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_CRED_ERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|grps
condition|)
block|{
comment|/* tidy up */
name|memset
argument_list|(
name|grps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
operator|*
name|blk_size
argument_list|(
name|no_grps
argument_list|)
argument_list|)
expr_stmt|;
name|_pam_drop
argument_list|(
name|grps
argument_list|)
expr_stmt|;
name|no_grps
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* --- public authentication management functions --- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_authenticate
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|PAM_IGNORE
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_setcred
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|service
init|=
name|NULL
decl_stmt|,
modifier|*
name|tty
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|unsigned
name|setting
decl_stmt|;
comment|/* only interested in establishing credentials */
name|setting
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|setting
operator|&
name|PAM_ESTABLISH_CRED
operator|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"ignoring call - not for establishing credentials"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
comment|/* don't fail because of this */
block|}
comment|/* set service name */
if|if
condition|(
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_SERVICE
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|service
argument_list|)
operator|!=
name|PAM_SUCCESS
operator|||
name|service
operator|==
name|NULL
condition|)
block|{
name|_log_err
argument_list|(
literal|"cannot find the current service name"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* set username */
if|if
condition|(
name|pam_get_user
argument_list|(
name|pamh
argument_list|,
operator|&
name|user
argument_list|,
name|NULL
argument_list|)
operator|!=
name|PAM_SUCCESS
operator|||
name|user
operator|==
name|NULL
operator|||
operator|*
name|user
operator|==
literal|'\0'
condition|)
block|{
name|_log_err
argument_list|(
literal|"cannot determine the user's name"
argument_list|)
expr_stmt|;
return|return
name|PAM_USER_UNKNOWN
return|;
block|}
comment|/* set tty name */
if|if
condition|(
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|tty
argument_list|)
operator|!=
name|PAM_SUCCESS
operator|||
name|tty
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"PAM_TTY not set, probing stdin"
operator|)
argument_list|)
expr_stmt|;
name|tty
operator|=
name|ttyname
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
block|{
name|_log_err
argument_list|(
literal|"couldn't get the tty name"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
if|if
condition|(
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
name|tty
argument_list|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|_log_err
argument_list|(
literal|"couldn't set tty name"
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"/dev/"
argument_list|,
name|tty
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* strip leading /dev/ */
name|tty
operator|+=
literal|5
expr_stmt|;
block|}
comment|/* good, now we have the service name, the user and the terminal name */
name|D
argument_list|(
operator|(
literal|"service=%s"
operator|,
name|service
operator|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"user=%s"
operator|,
name|user
operator|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"tty=%s"
operator|,
name|tty
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WANT_PWDB
comment|/* We initialize the pwdb library and check the account */
name|retval
operator|=
name|pwdb_start
argument_list|()
expr_stmt|;
comment|/* initialize */
if|if
condition|(
name|retval
operator|==
name|PWDB_SUCCESS
condition|)
block|{
name|retval
operator|=
name|check_account
argument_list|(
name|service
argument_list|,
name|tty
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* get groups */
operator|(
name|void
operator|)
name|pwdb_end
argument_list|()
expr_stmt|;
comment|/* tidy up */
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"failed to initialize pwdb; %s"
operator|,
name|pwdb_strerror
argument_list|(
name|retval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
literal|"unable to initialize libpwdb"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_ABORT
expr_stmt|;
block|}
else|#
directive|else
comment|/* WANT_PWDB */
name|retval
operator|=
name|check_account
argument_list|(
name|service
argument_list|,
name|tty
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* get groups */
endif|#
directive|endif
comment|/* WANT_PWDB */
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* end of module definition */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* static module data */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_group_modstruct
init|=
block|{
literal|"pam_group"
block|,
name|pam_sm_authenticate
block|,
name|pam_sm_setcred
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

