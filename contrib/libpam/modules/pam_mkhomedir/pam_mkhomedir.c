begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PAM Make Home Dir module     This module will create a users home directory if it does not exist    when the session begins. This allows users to be present in central    database (such as nis, kerb or ldap) without using a distributed    file system or pre-creating a large number of directories.        Here is a sample /etc/pam.d/login file for Debian GNU/Linux    2.1:        auth       requisite  pam_securetty.so    auth       sufficient pam_ldap.so    auth       required   pam_pwdb.so    auth       optional   pam_group.so    auth       optional   pam_mail.so    account    requisite  pam_time.so    account    sufficient pam_ldap.so    account    required   pam_pwdb.so    session    required   pam_mkhomedir.so skel=/etc/skel/ umask=0022    session    required   pam_pwdb.so    session    optional   pam_lastlog.so    password   required   pam_pwdb.so           Released under the GNU LGPL version 2 or later    Originally written by Jason Gunthorpe<jgg@debian.org> Feb 1999    Structure taken from pam_lastlogin by Andrew Morgan<morgan@parc.power.net> 1996  */
end_comment

begin_comment
comment|/* I want snprintf dammit */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_comment
comment|/*  * here, we make a definition for the externally accessible function  * in this file (this definition is required for static a module  * but strongly encouraged generally) it is used to instruct the  * modules include file to define the function prototypes.  */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_SESSION
end_define

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_comment
comment|/* argument parsing */
end_comment

begin_define
define|#
directive|define
name|MKHOMEDIR_DEBUG
value|020
end_define

begin_comment
comment|/* keep quiet about things */
end_comment

begin_define
define|#
directive|define
name|MKHOMEDIR_QUIET
value|040
end_define

begin_comment
comment|/* keep quiet about things */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|UMask
init|=
literal|0022
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|SkelDir
index|[
name|BUFSIZ
index|]
init|=
literal|"/etc/skel"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some syslogging */
end_comment

begin_function
specifier|static
name|void
name|_log_err
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"PAM-mkhomedir"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_pam_parse
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ctrl
init|=
literal|0
decl_stmt|;
comment|/* does the appliction require quiet? */
if|if
condition|(
operator|(
name|flags
operator|&
name|PAM_SILENT
operator|)
operator|==
name|PAM_SILENT
condition|)
name|ctrl
operator||=
name|MKHOMEDIR_QUIET
expr_stmt|;
comment|/* step through arguments */
for|for
control|(
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
operator|++
name|argv
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"silent"
argument_list|)
condition|)
block|{
name|ctrl
operator||=
name|MKHOMEDIR_QUIET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"umask="
argument_list|,
literal|6
argument_list|)
condition|)
name|UMask
operator|=
name|strtol
argument_list|(
operator|*
name|argv
operator|+
literal|6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"skel="
argument_list|,
literal|5
argument_list|)
condition|)
name|strcpy
argument_list|(
name|SkelDir
argument_list|,
operator|*
name|argv
operator|+
literal|5
argument_list|)
expr_stmt|;
else|else
block|{
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown option; %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
name|D
argument_list|(
operator|(
literal|"ctrl = %o"
operator|,
name|ctrl
operator|)
argument_list|)
expr_stmt|;
return|return
name|ctrl
return|;
block|}
end_function

begin_comment
comment|/* This common function is used to send a message to the applications     conversion function. Our only use is to ask the application to print     an informative message that we are creating a home directory */
end_comment

begin_function
specifier|static
name|int
name|converse
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|ctrl
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|pam_message
modifier|*
modifier|*
name|message
parameter_list|,
name|struct
name|pam_response
modifier|*
modifier|*
name|response
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|pam_conv
modifier|*
name|conv
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"begin to converse"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_CONV
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|PAM_SUCCESS
condition|)
block|{
name|retval
operator|=
name|conv
operator|->
name|conv
argument_list|(
name|nargs
argument_list|,
operator|(
specifier|const
expr|struct
name|pam_message
operator|*
operator|*
operator|)
name|message
argument_list|,
name|response
argument_list|,
name|conv
operator|->
name|appdata_ptr
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"returned from application's conversation function"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
operator|&&
operator|(
name|ctrl
operator|&
name|MKHOMEDIR_DEBUG
operator|)
condition|)
block|{
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"conversation failure [%s]"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't obtain coversation function [%s]"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|D
argument_list|(
operator|(
literal|"ready to return from module conversation"
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
comment|/* propagate error status */
block|}
end_function

begin_comment
comment|/* Ask the application to display a short text string for us. */
end_comment

begin_function
specifier|static
name|int
name|make_remark
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|ctrl
parameter_list|,
specifier|const
name|char
modifier|*
name|remark
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|ctrl
operator|&
name|MKHOMEDIR_QUIET
operator|)
operator|!=
name|MKHOMEDIR_QUIET
condition|)
block|{
name|struct
name|pam_message
name|msg
index|[
literal|1
index|]
decl_stmt|,
modifier|*
name|mesg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|mesg
index|[
literal|0
index|]
operator|=
operator|&
name|msg
index|[
literal|0
index|]
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg_style
operator|=
name|PAM_TEXT_INFO
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg
operator|=
name|remark
expr_stmt|;
name|retval
operator|=
name|converse
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
literal|1
argument_list|,
name|mesg
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|.
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|_pam_drop_reply
argument_list|(
name|resp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"keeping quiet"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PAM_SUCCESS
expr_stmt|;
block|}
name|D
argument_list|(
operator|(
literal|"returning %s"
operator|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|retval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Do the actual work of creating a home dir */
end_comment

begin_function
specifier|static
name|int
name|create_homedir
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|ctrl
parameter_list|,
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|)
block|{
name|char
modifier|*
name|remark
decl_stmt|;
name|DIR
modifier|*
name|D
decl_stmt|;
name|struct
name|dirent
modifier|*
name|Dir
decl_stmt|;
comment|/* Some scratch space */
name|remark
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|remark
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"no memory for last login remark"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_BUF_ERR
return|;
block|}
comment|/* Mention what is happening, if the notification fails that is OK */
if|if
condition|(
name|snprintf
argument_list|(
name|remark
argument_list|,
name|BUFSIZ
argument_list|,
literal|"Creating home directory '%s'."
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PAM_PERM_DENIED
return|;
name|make_remark
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|remark
argument_list|)
expr_stmt|;
comment|/* Crete the home directory */
if|if
condition|(
name|mkdir
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
literal|0700
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to create home directory %s"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
literal|0777
operator|&
operator|(
operator|~
name|UMask
operator|)
argument_list|)
operator|!=
literal|0
operator|||
name|chown
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to chance perms on home directory %s"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
comment|/* See if we need to copy the skel dir over. */
if|if
condition|(
name|SkelDir
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
comment|/* Scan the directory */
name|D
operator|=
name|opendir
argument_list|(
name|SkelDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|D
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to read directory %s"
argument_list|,
name|SkelDir
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
for|for
control|(
name|Dir
operator|=
name|readdir
argument_list|(
name|D
argument_list|)
init|;
name|Dir
operator|!=
literal|0
condition|;
name|Dir
operator|=
name|readdir
argument_list|(
name|D
argument_list|)
control|)
block|{
name|int
name|SrcFd
decl_stmt|;
name|int
name|DestFd
decl_stmt|;
name|int
name|Res
decl_stmt|;
name|struct
name|stat
name|St
decl_stmt|;
comment|/* Skip some files.. */
if|if
condition|(
name|strcmp
argument_list|(
name|Dir
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|Dir
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Check if it is a directory */
name|snprintf
argument_list|(
name|remark
argument_list|,
name|BUFSIZ
argument_list|,
literal|"%s/%s"
argument_list|,
name|SkelDir
argument_list|,
name|Dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|remark
argument_list|,
operator|&
name|St
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|St
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|remark
argument_list|,
name|BUFSIZ
argument_list|,
literal|"%s/%s"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|Dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|remark
argument_list|,
operator|(
name|St
operator|.
name|st_mode
operator||
literal|0222
operator|)
operator|&
operator|(
operator|~
name|UMask
operator|)
argument_list|)
operator|!=
literal|0
operator|||
name|chmod
argument_list|(
name|remark
argument_list|,
operator|(
name|St
operator|.
name|st_mode
operator||
literal|0222
operator|)
operator|&
operator|(
operator|~
name|UMask
operator|)
argument_list|)
operator|!=
literal|0
operator|||
name|chown
argument_list|(
name|remark
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to change perms on copy %s"
argument_list|,
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
continue|continue;
block|}
comment|/* Open the source file */
if|if
condition|(
operator|(
name|SrcFd
operator|=
name|open
argument_list|(
name|remark
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|SrcFd
argument_list|,
operator|&
name|St
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to open src file %s"
argument_list|,
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
name|stat
argument_list|(
name|remark
argument_list|,
operator|&
name|St
argument_list|)
expr_stmt|;
comment|/* Open the dest file */
name|snprintf
argument_list|(
name|remark
argument_list|,
name|BUFSIZ
argument_list|,
literal|"%s/%s"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|Dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DestFd
operator|=
name|open
argument_list|(
name|remark
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|SrcFd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to open dest file %s"
argument_list|,
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
comment|/* Set the proper ownership and permissions for the module. We make        	 the file a+w and then mask it with the set mask. This preseves        	 execute bits */
if|if
condition|(
name|fchmod
argument_list|(
name|DestFd
argument_list|,
operator|(
name|St
operator|.
name|st_mode
operator||
literal|0222
operator|)
operator|&
operator|(
operator|~
name|UMask
operator|)
argument_list|)
operator|!=
literal|0
operator|||
name|fchown
argument_list|(
name|DestFd
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to chang perms on copy %s"
argument_list|,
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
comment|/* Copy the file */
do|do
block|{
name|Res
operator|=
name|read
argument_list|(
name|SrcFd
argument_list|,
name|remark
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|Res
operator|<
literal|0
operator|||
name|write
argument_list|(
name|DestFd
argument_list|,
name|remark
argument_list|,
name|Res
argument_list|)
operator|!=
name|Res
condition|)
block|{
name|close
argument_list|(
name|SrcFd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|DestFd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unable to perform IO"
argument_list|)
expr_stmt|;
return|return
name|PAM_PERM_DENIED
return|;
block|}
block|}
do|while
condition|(
name|Res
operator|!=
literal|0
condition|)
do|;
name|close
argument_list|(
name|SrcFd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|DestFd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|remark
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* --- authentication management functions (only) --- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_open_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|ctrl
decl_stmt|;
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|stat
name|St
decl_stmt|;
comment|/* Parse the flag values */
name|ctrl
operator|=
name|_pam_parse
argument_list|(
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Determine the user name so we can get the home directory */
name|retval
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_USER
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
operator|||
name|user
operator|==
name|NULL
operator|||
operator|*
name|user
operator|==
literal|'\0'
condition|)
block|{
name|_log_err
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"user unknown"
argument_list|)
expr_stmt|;
return|return
name|PAM_USER_UNKNOWN
return|;
block|}
comment|/* Get the password entry */
name|pwd
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"couldn't identify user %s"
operator|,
name|user
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_CRED_INSUFFICIENT
return|;
block|}
comment|/* Stat the home directory, if something exists then we assume it is       correct and return a success*/
if|if
condition|(
name|stat
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
operator|&
name|St
argument_list|)
operator|==
literal|0
condition|)
return|return
name|PAM_SUCCESS
return|;
return|return
name|create_homedir
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
name|pwd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ignore */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_close_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* static module data */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_mkhomedir_modstruct
init|=
block|{
literal|"pam_mkhomedir"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|pam_sm_open_session
block|,
name|pam_sm_close_session
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

