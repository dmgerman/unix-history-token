begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pam_mail module */
end_comment

begin_comment
comment|/*  * $Id: pam_env.c,v 1.2 2000/11/19 23:54:03 agmorgan Exp $  *  * Written by Dave Kinchlea<kinch@kinch.ark.com> 1997/01/31  * Inspired by Andrew Morgan<morgan@parc.power.net, who also supplied the   * template for this file (via pam_mail)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_CONF_FILE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_CONF_FILE
value|"/etc/security/pam_env.conf"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFAULT_ETC_ENVFILE
value|"/etc/environment"
end_define

begin_define
define|#
directive|define
name|DEFAULT_READ_ENVFILE
value|1
end_define

begin_include
include|#
directive|include
file|<security/_pam_aconf.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * here, we make a definition for the externally accessible function  * in this file (this definition is required for static a module  * but strongly encouraged generally) it is used to instruct the  * modules include file to define the function prototypes.  */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_AUTH
end_define

begin_comment
comment|/* This is primarily a AUTH_SETCRED module */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_SESSION
end_define

begin_comment
comment|/* But I like to be friendly */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_PASSWORD
end_define

begin_comment
comment|/*        ""                 */
end_comment

begin_define
define|#
directive|define
name|PAM_SM_ACCOUNT
end_define

begin_comment
comment|/*        ""                 */
end_comment

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<security/_pam_macros.h>
end_include

begin_comment
comment|/* This little structure makes it easier to keep variables together */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|var
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|defval
decl_stmt|;
name|char
modifier|*
name|override
decl_stmt|;
block|}
name|VAR
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BUF_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|MAX_ENV
value|8192
end_define

begin_define
define|#
directive|define
name|GOOD_LINE
value|0
end_define

begin_define
define|#
directive|define
name|BAD_LINE
value|100
end_define

begin_comment
comment|/* This must be> the largest PAM_* error code */
end_comment

begin_define
define|#
directive|define
name|DEFINE_VAR
value|101
end_define

begin_define
define|#
directive|define
name|UNDEFINE_VAR
value|102
end_define

begin_define
define|#
directive|define
name|ILLEGAL_VAR
value|103
end_define

begin_function_decl
specifier|static
name|int
name|_assemble_line
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_parse_line
parameter_list|(
name|char
modifier|*
parameter_list|,
name|VAR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_check_var
parameter_list|(
name|pam_handle_t
modifier|*
parameter_list|,
name|VAR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is the real meat */
end_comment

begin_function_decl
specifier|static
name|void
name|_clean_var
parameter_list|(
name|VAR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_expand_arg
parameter_list|(
name|pam_handle_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|_pam_get_item_byname
parameter_list|(
name|pam_handle_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_define_var
parameter_list|(
name|pam_handle_t
modifier|*
parameter_list|,
name|VAR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_undefine_var
parameter_list|(
name|pam_handle_t
modifier|*
parameter_list|,
name|VAR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is a flag used to designate an empty string */
end_comment

begin_decl_stmt
specifier|static
name|char
name|quote
init|=
literal|'Z'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some syslogging */
end_comment

begin_function
specifier|static
name|void
name|_log_err
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"PAM-env"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|err
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* argument parsing */
end_comment

begin_define
define|#
directive|define
name|PAM_DEBUG_ARG
value|0x01
end_define

begin_define
define|#
directive|define
name|PAM_NEW_CONF_FILE
value|0x02
end_define

begin_define
define|#
directive|define
name|PAM_ENV_SILENT
value|0x04
end_define

begin_define
define|#
directive|define
name|PAM_NEW_ENV_FILE
value|0x10
end_define

begin_function
specifier|static
name|int
name|_pam_parse
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|conffile
parameter_list|,
name|char
modifier|*
modifier|*
name|envfile
parameter_list|,
name|int
modifier|*
name|readenv
parameter_list|)
block|{
name|int
name|ctrl
init|=
literal|0
decl_stmt|;
comment|/* step through arguments */
for|for
control|(
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
operator|++
name|argv
control|)
block|{
comment|/* generic options */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"debug"
argument_list|)
condition|)
name|ctrl
operator||=
name|PAM_DEBUG_ARG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"conffile="
argument_list|,
literal|9
argument_list|)
condition|)
block|{
operator|*
name|conffile
operator|=
name|x_strdup
argument_list|(
literal|9
operator|+
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|conffile
operator|!=
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"new Configuration File: %s"
operator|,
operator|*
name|conffile
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|PAM_NEW_CONF_FILE
expr_stmt|;
block|}
else|else
block|{
name|_log_err
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Configuration file specification missing argument - ignored"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"envfile="
argument_list|,
literal|8
argument_list|)
condition|)
block|{
operator|*
name|envfile
operator|=
name|x_strdup
argument_list|(
literal|8
operator|+
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|envfile
operator|!=
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"new Env File: %s"
operator|,
operator|*
name|envfile
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|PAM_NEW_ENV_FILE
expr_stmt|;
block|}
else|else
block|{
name|_log_err
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Env file specification missing argument - ignored"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"readenv="
argument_list|,
literal|8
argument_list|)
condition|)
operator|*
name|readenv
operator|=
name|atoi
argument_list|(
literal|8
operator|+
operator|*
name|argv
argument_list|)
expr_stmt|;
else|else
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_parse: unknown option; %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|ctrl
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_parse_config_file
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|ctrl
parameter_list|,
name|char
modifier|*
modifier|*
name|conffile
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|char
name|buffer
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|FILE
modifier|*
name|conf
decl_stmt|;
name|VAR
name|Var
decl_stmt|,
modifier|*
name|var
init|=
operator|&
name|Var
decl_stmt|;
name|var
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|defval
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|override
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Called."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|PAM_NEW_CONF_FILE
condition|)
block|{
name|file
operator|=
operator|*
name|conffile
expr_stmt|;
block|}
else|else
block|{
name|file
operator|=
name|DEFAULT_CONF_FILE
expr_stmt|;
block|}
name|D
argument_list|(
operator|(
literal|"Config file name is: %s"
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
comment|/*       * Lets try to open the config file, parse it and process       * any variables found.      */
if|if
condition|(
operator|(
name|conf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to open config file: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PAM_IGNORE
return|;
block|}
comment|/* _pam_assemble_line will provide a complete line from the config file, with all       * comments removed and any escaped newlines fixed up      */
while|while
condition|(
operator|(
name|retval
operator|=
name|_assemble_line
argument_list|(
name|conf
argument_list|,
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Read line: %s"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|_parse_line
argument_list|(
name|buffer
argument_list|,
name|var
argument_list|)
operator|)
operator|==
name|GOOD_LINE
condition|)
block|{
name|retval
operator|=
name|_check_var
argument_list|(
name|pamh
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFINE_VAR
operator|==
name|retval
condition|)
block|{
name|retval
operator|=
name|_define_var
argument_list|(
name|pamh
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UNDEFINE_VAR
operator|==
name|retval
condition|)
block|{
name|retval
operator|=
name|_undefine_var
argument_list|(
name|pamh
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PAM_SUCCESS
operator|!=
name|retval
operator|&&
name|ILLEGAL_VAR
operator|!=
name|retval
operator|&&
name|BAD_LINE
operator|!=
name|retval
operator|&&
name|PAM_BAD_ITEM
operator|!=
name|retval
condition|)
break|break;
name|_clean_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* while */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|/* tidy up */
name|_clean_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* We could have got here prematurely, this is safe though */
name|_pam_overwrite
argument_list|(
operator|*
name|conffile
argument_list|)
expr_stmt|;
name|_pam_drop
argument_list|(
operator|*
name|conffile
argument_list|)
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|<
literal|0
condition|?
name|PAM_ABORT
else|:
name|PAM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_parse_env_file
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|ctrl
parameter_list|,
name|char
modifier|*
modifier|*
name|env_file
parameter_list|)
block|{
name|int
name|retval
init|=
name|PAM_SUCCESS
decl_stmt|,
name|i
decl_stmt|,
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|char
name|buffer
index|[
name|BUF_SIZE
index|]
decl_stmt|,
modifier|*
name|key
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
name|FILE
modifier|*
name|conf
decl_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|PAM_NEW_ENV_FILE
condition|)
name|file
operator|=
operator|*
name|env_file
expr_stmt|;
else|else
name|file
operator|=
name|DEFAULT_ETC_ENVFILE
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Env file name is: %s"
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Unable to open env file: %s"
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
while|while
condition|(
name|_assemble_line
argument_list|(
name|conf
argument_list|,
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|)
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Read line: %s"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|buffer
expr_stmt|;
comment|/* skip leading white space */
name|key
operator|+=
name|strspn
argument_list|(
name|key
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
comment|/* skip blanks lines and comments */
if|if
condition|(
operator|!
name|key
operator|||
name|key
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* skip over "export " if present so we can be compat with 	   bash type declerations */
if|if
condition|(
name|strncmp
argument_list|(
name|key
argument_list|,
literal|"export "
argument_list|,
operator|(
name|size_t
operator|)
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|key
operator|+=
literal|7
expr_stmt|;
comment|/* now find the end of value */
name|mark
operator|=
name|key
expr_stmt|;
while|while
condition|(
name|mark
index|[
literal|0
index|]
operator|!=
literal|'\n'
operator|&&
name|mark
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|&&
name|mark
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|mark
operator|++
expr_stmt|;
if|if
condition|(
name|mark
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|mark
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	* sanity check, the key must be alpha-numeric 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|key
index|[
name|i
index|]
operator|!=
literal|'='
operator|&&
name|key
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|key
index|[
name|i
index|]
argument_list|)
operator|&&
name|key
index|[
name|i
index|]
operator|!=
literal|'_'
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"key is not alpha numeric - '%s', ignoring"
operator|,
name|key
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now we try to be smart about quotes around the value, 	   but not too smart, we can't get all fancy with escaped 	   values like bash */
if|if
condition|(
name|key
index|[
name|i
index|]
operator|==
literal|'='
operator|&&
operator|(
name|key
index|[
operator|++
name|i
index|]
operator|==
literal|'\"'
operator|||
name|key
index|[
name|i
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|i
operator|+
literal|1
init|;
name|key
index|[
name|t
index|]
operator|!=
literal|'\0'
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|key
index|[
name|t
index|]
operator|!=
literal|'\"'
operator|&&
name|key
index|[
name|t
index|]
operator|!=
literal|'\''
condition|)
name|key
index|[
name|i
operator|++
index|]
operator|=
name|key
index|[
name|t
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|key
index|[
name|t
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|key
index|[
name|i
operator|++
index|]
operator|=
name|key
index|[
name|t
index|]
expr_stmt|;
name|key
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* set the env var, if it fails, we break out of the loop */
name|retval
operator|=
name|pam_putenv
argument_list|(
name|pamh
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"error setting env \"%s\""
operator|,
name|key
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|/* tidy up */
name|_pam_overwrite
argument_list|(
operator|*
name|env_file
argument_list|)
expr_stmt|;
name|_pam_drop
argument_list|(
operator|*
name|env_file
argument_list|)
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|<
literal|0
condition|?
name|PAM_IGNORE
else|:
name|PAM_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is where we read a line of the PAM config file. The line may be  * preceeded by lines of comments and also extended with "\\\n"  */
end_comment

begin_function
specifier|static
name|int
name|_assemble_line
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buf_len
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|os
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
comment|/* loop broken with a 'break' when a non-'\\n' ended line is read */
name|D
argument_list|(
operator|(
literal|"called."
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|used
operator|>=
name|buf_len
condition|)
block|{
comment|/* Overflow */
name|D
argument_list|(
operator|(
literal|"_assemble_line: overflow"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|p
argument_list|,
name|buf_len
operator|-
name|used
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|used
condition|)
block|{
comment|/* Incomplete read */
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* EOF */
return|return
literal|0
return|;
block|}
block|}
comment|/* skip leading spaces --- line may be blank */
name|s
operator|=
name|p
operator|+
name|strspn
argument_list|(
name|p
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'#'
operator|)
condition|)
block|{
name|os
operator|=
name|s
expr_stmt|;
comment|/* 	     * we are only interested in characters before the first '#' 	     * character 	     */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'#'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|used
operator|+=
name|strlen
argument_list|(
name|os
argument_list|)
expr_stmt|;
break|break;
comment|/* the line has been read */
block|}
name|s
operator|=
name|os
expr_stmt|;
comment|/* 	     * Check for backslash by scanning back from the end of 	     * the entered line, the '\n' has been included since 	     * normally a line is terminated with this 	     * character. fgets() should only return one though! 	     */
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|os
operator|&&
operator|(
operator|(
operator|*
operator|--
name|s
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\n'
operator|)
operator|)
condition|)
empty_stmt|;
comment|/* check if it ends with a backslash */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate the line here */
name|used
operator|+=
name|strlen
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
comment|/* there is more ... */
block|}
else|else
block|{
comment|/* End of the line! */
name|used
operator|+=
name|strlen
argument_list|(
name|os
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the complete line */
block|}
block|}
else|else
block|{
comment|/* Nothing in this line */
comment|/* Don't move p         */
block|}
block|}
return|return
name|used
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_parse_line
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|VAR
modifier|*
name|var
parameter_list|)
block|{
comment|/*     * parse buffer into var, legal syntax is     * VARIABLE [DEFAULT=[[string]] [OVERRIDE=[value]]    *    * Any other options defined make this a bad line,     * error logged and no var set    */
name|int
name|length
decl_stmt|,
name|quoteflg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
modifier|*
name|valptr
decl_stmt|,
modifier|*
name|tmpptr
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"Called buffer =<%s>"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|strcspn
argument_list|(
name|buffer
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't malloc %d bytes"
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|PAM_BUF_ERR
return|;
block|}
comment|/*     * The first thing on the line HAS to be the variable name,     * it may be the only thing though.    */
name|strncpy
argument_list|(
name|var
operator|->
name|name
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"var->name =<%s>, length = %d"
operator|,
name|var
operator|->
name|name
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/*     * Now we check for arguments, we only support two kinds and ('cause I am lazy)    * each one can actually be listed any number of times    */
name|ptr
operator|=
name|buffer
operator|+
name|length
expr_stmt|;
while|while
condition|(
operator|(
name|length
operator|=
name|strspn
argument_list|(
name|ptr
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|ptr
operator|+=
name|length
expr_stmt|;
comment|/* remove leading whitespace */
name|D
argument_list|(
operator|(
name|ptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"DEFAULT="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|8
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Default arg found:<%s>"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
name|valptr
operator|=
operator|&
operator|(
name|var
operator|->
name|defval
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"OVERRIDE="
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|9
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Override arg found:<%s>"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
name|valptr
operator|=
operator|&
operator|(
name|var
operator|->
name|override
operator|)
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"Unrecognized options:<%s> - ignoring line"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unrecognized Option: %s - ignoring line"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
name|BAD_LINE
return|;
block|}
if|if
condition|(
literal|'"'
operator|!=
operator|*
name|ptr
condition|)
block|{
comment|/* Escaped quotes not supported */
name|length
operator|=
name|strcspn
argument_list|(
name|ptr
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
name|tmpptr
operator|=
name|ptr
operator|+
name|length
expr_stmt|;
block|}
else|else
block|{
name|tmpptr
operator|=
name|strchr
argument_list|(
operator|++
name|ptr
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpptr
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Unterminated quoted string: %s"
operator|,
name|ptr
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unterminated quoted string: %s"
argument_list|,
name|ptr
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|BAD_LINE
return|;
block|}
name|length
operator|=
name|tmpptr
operator|-
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|tmpptr
operator|&&
literal|' '
operator|!=
operator|*
name|tmpptr
operator|&&
literal|'\t'
operator|!=
operator|*
name|tmpptr
operator|&&
literal|'\n'
operator|!=
operator|*
name|tmpptr
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Quotes must cover the entire string:<%s>"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Quotes must cover the entire string:<%s>"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
name|BAD_LINE
return|;
block|}
name|quoteflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|valptr
operator|=
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Couldn't malloc %d bytes"
operator|,
name|length
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't malloc %d bytes"
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|PAM_BUF_ERR
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|*
name|valptr
argument_list|,
name|ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|(
operator|*
name|valptr
operator|)
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quoteflg
operator|--
condition|)
block|{
operator|*
name|valptr
operator|=
operator|&
name|quote
expr_stmt|;
comment|/* a quick hack to handle the empty string */
block|}
name|ptr
operator|=
name|tmpptr
expr_stmt|;
comment|/* Start the search where we stopped */
block|}
comment|/* while */
comment|/*     * The line is parsed, all is well.    */
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
name|tmpptr
operator|=
name|NULL
expr_stmt|;
name|valptr
operator|=
name|NULL
expr_stmt|;
return|return
name|GOOD_LINE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_check_var
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|VAR
modifier|*
name|var
parameter_list|)
block|{
comment|/*     * Examine the variable and determine what action to take.     * Returns DEFINE_VAR, UNDEFINE_VAR depending on action to take    * or a PAM_* error code if passed back from other routines    *    * if no DEFAULT provided, the empty string is assumed    * if no OVERRIDE provided, the empty string is assumed    * if DEFAULT=  and OVERRIDE evaluates to the empty string,     *    this variable should be undefined    * if DEFAULT=""  and OVERRIDE evaluates to the empty string,     *    this variable should be defined with no value    * if OVERRIDE=value   and value turns into the empty string, DEFAULT is used    *    * If DEFINE_VAR is to be returned, the correct value to define will    * be pointed to by var->value    */
name|int
name|retval
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"Called."
operator|)
argument_list|)
expr_stmt|;
comment|/*    * First thing to do is to expand any arguments, but only    * if they are not the special quote values (cause expand_arg    * changes memory).    */
if|if
condition|(
name|var
operator|->
name|defval
operator|&&
operator|(
operator|&
name|quote
operator|!=
name|var
operator|->
name|defval
operator|)
operator|&&
operator|(
operator|(
name|retval
operator|=
name|_expand_arg
argument_list|(
name|pamh
argument_list|,
operator|&
operator|(
name|var
operator|->
name|defval
operator|)
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
operator|)
condition|)
block|{
return|return
name|retval
return|;
block|}
if|if
condition|(
name|var
operator|->
name|override
operator|&&
operator|(
operator|&
name|quote
operator|!=
name|var
operator|->
name|override
operator|)
operator|&&
operator|(
operator|(
name|retval
operator|=
name|_expand_arg
argument_list|(
name|pamh
argument_list|,
operator|&
operator|(
name|var
operator|->
name|override
operator|)
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
operator|)
condition|)
block|{
return|return
name|retval
return|;
block|}
comment|/* Now its easy */
if|if
condition|(
name|var
operator|->
name|override
operator|&&
operator|*
operator|(
name|var
operator|->
name|override
operator|)
operator|&&
operator|&
name|quote
operator|!=
name|var
operator|->
name|override
condition|)
block|{
comment|/* if there is a non-empty string in var->override, we use it */
name|D
argument_list|(
operator|(
literal|"OVERRIDE variable<%s> being used:<%s>"
operator|,
name|var
operator|->
name|name
operator|,
name|var
operator|->
name|override
operator|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|var
operator|->
name|override
expr_stmt|;
name|retval
operator|=
name|DEFINE_VAR
expr_stmt|;
block|}
else|else
block|{
name|var
operator|->
name|value
operator|=
name|var
operator|->
name|defval
expr_stmt|;
if|if
condition|(
operator|&
name|quote
operator|==
name|var
operator|->
name|defval
condition|)
block|{
comment|/*         * This means that the empty string was given for defval value         * which indicates that a variable should be defined with no value        */
operator|*
name|var
operator|->
name|defval
operator|=
literal|'\0'
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"An empty variable:<%s>"
operator|,
name|var
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|DEFINE_VAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|->
name|defval
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"DEFAULT variable<%s> being used:<%s>"
operator|,
name|var
operator|->
name|name
operator|,
name|var
operator|->
name|defval
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|DEFINE_VAR
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"UNDEFINE variable<%s>"
operator|,
name|var
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|UNDEFINE_VAR
expr_stmt|;
block|}
block|}
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_expand_arg
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|char
modifier|*
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|orig
init|=
operator|*
name|value
decl_stmt|,
modifier|*
name|tmpptr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/*  		    * Sure would be nice to use tmpptr but it needs to be  		    * a constant so that the compiler will shut up when I 		    * call pam_getenv and _pam_get_item_byname -- sigh 		    */
name|char
name|type
decl_stmt|,
name|tmpval
index|[
name|BUF_SIZE
index|]
decl_stmt|;
comment|/* No unexpanded variable can be bigger than BUF_SIZE */
name|char
name|tmp
index|[
name|MAX_ENV
index|]
decl_stmt|;
comment|/* I know this shouldn't be hard-coded but it's so  			* much easier this way */
name|D
argument_list|(
operator|(
literal|"Remember to initialize tmp!"
operator|)
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*     * (possibly non-existent) environment variables can be used as values    * by prepending a "$" and wrapping in {} (ie: ${HOST}), can escape with "\"    * (possibly non-existent) PAM items can be used as values     * by prepending a "@" and wrapping in {} (ie: @{PAM_RHOST}, can escape     *    */
name|D
argument_list|(
operator|(
literal|"Expanding<%s>"
operator|,
name|orig
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|orig
condition|)
block|{
comment|/* while there is some input to deal with */
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|orig
condition|)
block|{
operator|++
name|orig
expr_stmt|;
if|if
condition|(
literal|'$'
operator|!=
operator|*
name|orig
operator|&&
literal|'@'
operator|!=
operator|*
name|orig
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Unrecognized escaped character:<%c> - ignoring"
operator|,
operator|*
name|orig
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unrecognized escaped character:<%c> - ignoring"
argument_list|,
operator|*
name|orig
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|MAX_ENV
condition|)
block|{
name|tmp
index|[
name|strlen
argument_list|(
name|tmp
argument_list|)
index|]
operator|=
operator|*
name|orig
operator|++
expr_stmt|;
comment|/* Note the increment */
block|}
else|else
block|{
comment|/* is it really a good idea to try to log this? */
name|D
argument_list|(
operator|(
literal|"Variable buffer overflow:<%s> +<%s>"
operator|,
name|tmp
operator|,
name|tmpptr
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Variable buffer overflow:<%s> +<%s>"
argument_list|,
name|tmp
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
literal|'$'
operator|==
operator|*
name|orig
operator|||
literal|'@'
operator|==
operator|*
name|orig
condition|)
block|{
if|if
condition|(
literal|'{'
operator|!=
operator|*
operator|(
name|orig
operator|+
literal|1
operator|)
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Expandable variables must be wrapped in {}<%s> - ignoring"
operator|,
name|orig
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Expandable variables must be wrapped in {}<%s> - ignoring"
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|MAX_ENV
condition|)
block|{
name|tmp
index|[
name|strlen
argument_list|(
name|tmp
argument_list|)
index|]
operator|=
operator|*
name|orig
operator|++
expr_stmt|;
comment|/* Note the increment */
block|}
continue|continue;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"Expandable argument:<%s>"
operator|,
name|orig
operator|)
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|orig
expr_stmt|;
name|orig
operator|+=
literal|2
expr_stmt|;
comment|/* skip the ${ or @{ characters */
name|ptr
operator|=
name|strchr
argument_list|(
name|orig
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"Unterminated expandable variable:<%s>"
operator|,
name|orig
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unterminated expandable variable:<%s>"
argument_list|,
name|orig
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
name|strncpy
argument_list|(
name|tmpval
argument_list|,
name|orig
argument_list|,
operator|(
name|size_t
operator|)
name|BUF_SIZE
argument_list|)
expr_stmt|;
name|orig
operator|=
name|ptr
expr_stmt|;
comment|/*  	 * so, we know we need to expand tmpval, it is either  	 * an environment variable or a PAM_ITEM. type will tell us which 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'$'
case|:
name|D
argument_list|(
operator|(
literal|"Expanding env var:<%s>"
operator|,
name|tmpval
operator|)
argument_list|)
expr_stmt|;
name|tmpptr
operator|=
name|pam_getenv
argument_list|(
name|pamh
argument_list|,
name|tmpval
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Expanded to<%s>"
operator|,
name|tmpptr
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|D
argument_list|(
operator|(
literal|"Expanding pam item:<%s>"
operator|,
name|tmpval
operator|)
argument_list|)
expr_stmt|;
name|tmpptr
operator|=
name|_pam_get_item_byname
argument_list|(
name|pamh
argument_list|,
name|tmpval
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Expanded to<%s>"
operator|,
name|tmpptr
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
operator|(
literal|"Impossible error, type ==<%c>"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Impossible error, type ==<%c>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|PAM_ABORT
return|;
block|}
comment|/* switch */
if|if
condition|(
name|tmpptr
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
name|strlen
argument_list|(
name|tmpptr
argument_list|)
operator|)
operator|<
name|MAX_ENV
condition|)
block|{
name|strcat
argument_list|(
name|tmp
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* is it really a good idea to try to log this? */
name|D
argument_list|(
operator|(
literal|"Variable buffer overflow:<%s> +<%s>"
operator|,
name|tmp
operator|,
name|tmpptr
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Variable buffer overflow:<%s> +<%s>"
argument_list|,
name|tmp
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if ('{' != *orig++) */
block|}
else|else
block|{
comment|/* if ( '$' == *orig || '@' == *orig) */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|MAX_ENV
condition|)
block|{
name|tmp
index|[
name|strlen
argument_list|(
name|tmp
argument_list|)
index|]
operator|=
operator|*
name|orig
operator|++
expr_stmt|;
comment|/* Note the increment */
block|}
else|else
block|{
comment|/* is it really a good idea to try to log this? */
name|D
argument_list|(
operator|(
literal|"Variable buffer overflow:<%s> +<%s>"
operator|,
name|tmp
operator|,
name|tmpptr
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Variable buffer overflow:<%s> +<%s>"
argument_list|,
name|tmp
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* for (;*orig;) */
if|if
condition|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|>
name|strlen
argument_list|(
operator|*
name|value
argument_list|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|value
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Couldn't malloc %d bytes for expanded var"
operator|,
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't malloc %d bytes for expanded var"
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|PAM_BUF_ERR
return|;
block|}
block|}
name|strcpy
argument_list|(
operator|*
name|value
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_pam_get_item_byname
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/*     * This function just allows me to use names as given in the config    * file and translate them into the appropriate PAM_ITEM macro    */
name|int
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|itemval
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"Called."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PAM_USER"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|item
operator|=
name|PAM_USER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PAM_USER_PROMPT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|item
operator|=
name|PAM_USER_PROMPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PAM_TTY"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|item
operator|=
name|PAM_TTY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PAM_RUSER"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|item
operator|=
name|PAM_RUSER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PAM_RHOST"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|item
operator|=
name|PAM_RHOST
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
operator|(
literal|"Unknown PAM_ITEM:<%s>"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown PAM_ITEM:<%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|item
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|itemval
argument_list|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"pam_get_item failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* let pam_get_item() log the error */
block|}
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|itemval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_define_var
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|VAR
modifier|*
name|var
parameter_list|)
block|{
comment|/* We have a variable to define, this is a simple function */
name|char
modifier|*
name|envvar
decl_stmt|;
name|int
name|size
decl_stmt|,
name|retval
init|=
name|PAM_SUCCESS
decl_stmt|;
name|D
argument_list|(
operator|(
literal|"Called."
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|var
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|var
operator|->
name|value
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|envvar
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
operator|(
literal|"Malloc fail, size = %d"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|_log_err
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Malloc fail, size = %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|PAM_BUF_ERR
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|envvar
argument_list|,
literal|"%s=%s"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|retval
operator|=
name|pam_putenv
argument_list|(
name|pamh
argument_list|,
name|envvar
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|envvar
argument_list|)
expr_stmt|;
name|envvar
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_undefine_var
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|VAR
modifier|*
name|var
parameter_list|)
block|{
comment|/* We have a variable to undefine, this is a simple function */
name|D
argument_list|(
operator|(
literal|"Called and exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|pam_putenv
argument_list|(
name|pamh
argument_list|,
name|var
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_clean_var
parameter_list|(
name|VAR
modifier|*
name|var
parameter_list|)
block|{
if|if
condition|(
name|var
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|->
name|defval
operator|&&
operator|(
operator|&
name|quote
operator|!=
name|var
operator|->
name|defval
operator|)
condition|)
block|{
name|free
argument_list|(
name|var
operator|->
name|defval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|->
name|override
operator|&&
operator|(
operator|&
name|quote
operator|!=
name|var
operator|->
name|override
operator|)
condition|)
block|{
name|free
argument_list|(
name|var
operator|->
name|override
argument_list|)
expr_stmt|;
block|}
name|var
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
comment|/* never has memory specific to it */
name|var
operator|->
name|defval
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|override
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* --- authentication management functions (only) --- */
end_comment

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_authenticate
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|PAM_IGNORE
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_setcred
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|ctrl
decl_stmt|,
name|readenv
init|=
name|DEFAULT_READ_ENVFILE
decl_stmt|;
name|char
modifier|*
name|conf_file
init|=
name|NULL
decl_stmt|,
modifier|*
name|env_file
init|=
name|NULL
decl_stmt|;
comment|/*    * this module sets environment variables read in from a file    */
name|D
argument_list|(
operator|(
literal|"Called."
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|_pam_parse
argument_list|(
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|conf_file
argument_list|,
operator|&
name|env_file
argument_list|,
operator|&
name|readenv
argument_list|)
expr_stmt|;
name|retval
operator|=
name|_parse_config_file
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
operator|&
name|conf_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|readenv
condition|)
name|_parse_env_file
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
operator|&
name|env_file
argument_list|)
expr_stmt|;
comment|/* indicate success or failure */
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_acct_mgmt
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|_log_err
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"pam_sm_acct_mgmt called inappropriatly"
argument_list|)
expr_stmt|;
return|return
name|PAM_SERVICE_ERR
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_open_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|ctrl
decl_stmt|,
name|readenv
init|=
name|DEFAULT_READ_ENVFILE
decl_stmt|;
name|char
modifier|*
name|conf_file
init|=
name|NULL
decl_stmt|,
modifier|*
name|env_file
init|=
name|NULL
decl_stmt|;
comment|/*    * this module sets environment variables read in from a file    */
name|D
argument_list|(
operator|(
literal|"Called."
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|_pam_parse
argument_list|(
name|flags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|conf_file
argument_list|,
operator|&
name|env_file
argument_list|,
operator|&
name|readenv
argument_list|)
expr_stmt|;
name|retval
operator|=
name|_parse_config_file
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
operator|&
name|conf_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|readenv
condition|)
name|_parse_env_file
argument_list|(
name|pamh
argument_list|,
name|ctrl
argument_list|,
operator|&
name|env_file
argument_list|)
expr_stmt|;
comment|/* indicate success or failure */
name|D
argument_list|(
operator|(
literal|"Exit."
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_close_session
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|D
argument_list|(
operator|(
literal|"Called and Exit"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_function
name|PAM_EXTERN
name|int
name|pam_sm_chauthtok
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|_log_err
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"pam_sm_chauthtok called inappropriatly"
argument_list|)
expr_stmt|;
return|return
name|PAM_SERVICE_ERR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_STATIC
end_ifdef

begin_comment
comment|/* static module data */
end_comment

begin_decl_stmt
name|struct
name|pam_module
name|_pam_env_modstruct
init|=
block|{
literal|"pam_env"
block|,
name|pam_sm_authenticate
block|,
name|pam_sm_setcred
block|,
name|pam_sm_acct_mgmt
block|,
name|pam_sm_open_session
block|,
name|pam_sm_close_session
block|,
name|pam_sm_chauthtok
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of module definition */
end_comment

end_unit

