begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    minizip.c    Version 1.1, February 14h, 2010    sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )           Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )           Modifications of Unzip for Zip64          Copyright (C) 2007-2008 Even Rouault           Modifications for Zip64 support on both zip and unzip          Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com ) */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|__USE_FILE_OFFSET64
end_ifndef

begin_define
define|#
directive|define
name|__USE_FILE_OFFSET64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__USE_LARGEFILE64
end_ifndef

begin_define
define|#
directive|define
name|__USE_LARGEFILE64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_LARGEFILE64_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_LARGEFILE64_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_FILE_OFFSET_BIT
end_ifndef

begin_define
define|#
directive|define
name|_FILE_OFFSET_BIT
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_comment
comment|// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
end_comment

begin_define
define|#
directive|define
name|FOPEN_FUNC
parameter_list|(
name|filename
parameter_list|,
name|mode
parameter_list|)
value|fopen(filename, mode)
end_define

begin_define
define|#
directive|define
name|FTELLO_FUNC
parameter_list|(
name|stream
parameter_list|)
value|ftello(stream)
end_define

begin_define
define|#
directive|define
name|FSEEKO_FUNC
parameter_list|(
name|stream
parameter_list|,
name|offset
parameter_list|,
name|origin
parameter_list|)
value|fseeko(stream, offset, origin)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FOPEN_FUNC
parameter_list|(
name|filename
parameter_list|,
name|mode
parameter_list|)
value|fopen64(filename, mode)
end_define

begin_define
define|#
directive|define
name|FTELLO_FUNC
parameter_list|(
name|stream
parameter_list|)
value|ftello64(stream)
end_define

begin_define
define|#
directive|define
name|FSEEKO_FUNC
parameter_list|(
name|stream
parameter_list|,
name|offset
parameter_list|,
name|origin
parameter_list|)
value|fseeko64(stream, offset, origin)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"zip.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|USEWIN32IOAPI
end_define

begin_include
include|#
directive|include
file|"iowin32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|WRITEBUFFERSIZE
value|(16384)
end_define

begin_define
define|#
directive|define
name|MAXFILENAME
value|(256)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
name|uLong
name|filetime
parameter_list|(
name|f
parameter_list|,
name|tmzip
parameter_list|,
name|dt
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
comment|/* name of file to get info on */
name|tm_zip
modifier|*
name|tmzip
decl_stmt|;
comment|/* return value: access, modific. and creation times */
name|uLong
modifier|*
name|dt
decl_stmt|;
comment|/* dostime */
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
block|{
name|FILETIME
name|ftLocal
decl_stmt|;
name|HANDLE
name|hFind
decl_stmt|;
name|WIN32_FIND_DATAA
name|ff32
decl_stmt|;
name|hFind
operator|=
name|FindFirstFileA
argument_list|(
name|f
argument_list|,
operator|&
name|ff32
argument_list|)
expr_stmt|;
if|if
condition|(
name|hFind
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|FileTimeToLocalFileTime
argument_list|(
operator|&
operator|(
name|ff32
operator|.
name|ftLastWriteTime
operator|)
argument_list|,
operator|&
name|ftLocal
argument_list|)
expr_stmt|;
name|FileTimeToDosDateTime
argument_list|(
operator|&
name|ftLocal
argument_list|,
operator|(
operator|(
name|LPWORD
operator|)
name|dt
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|LPWORD
operator|)
name|dt
operator|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|FindClose
argument_list|(
name|hFind
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|unix
name|||
name|__APPLE__
end_ifdef

begin_function
name|uLong
name|filetime
parameter_list|(
name|f
parameter_list|,
name|tmzip
parameter_list|,
name|dt
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
comment|/* name of file to get info on */
name|tm_zip
modifier|*
name|tmzip
decl_stmt|;
comment|/* return value: access, modific. and creation times */
name|uLong
modifier|*
name|dt
decl_stmt|;
comment|/* dostime */
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
comment|/* results of stat() */
name|struct
name|tm
modifier|*
name|filedate
decl_stmt|;
name|time_t
name|tm_t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|f
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|name
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|MAXFILENAME
condition|)
name|len
operator|=
name|MAXFILENAME
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|f
argument_list|,
name|MAXFILENAME
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* strncpy doesnt append the trailing NULL, of the string is too long. */
name|name
index|[
name|MAXFILENAME
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* not all systems allow stat'ing a file with / appended */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tm_t
operator|=
name|s
operator|.
name|st_mtime
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|filedate
operator|=
name|localtime
argument_list|(
operator|&
name|tm_t
argument_list|)
expr_stmt|;
name|tmzip
operator|->
name|tm_sec
operator|=
name|filedate
operator|->
name|tm_sec
expr_stmt|;
name|tmzip
operator|->
name|tm_min
operator|=
name|filedate
operator|->
name|tm_min
expr_stmt|;
name|tmzip
operator|->
name|tm_hour
operator|=
name|filedate
operator|->
name|tm_hour
expr_stmt|;
name|tmzip
operator|->
name|tm_mday
operator|=
name|filedate
operator|->
name|tm_mday
expr_stmt|;
name|tmzip
operator|->
name|tm_mon
operator|=
name|filedate
operator|->
name|tm_mon
expr_stmt|;
name|tmzip
operator|->
name|tm_year
operator|=
name|filedate
operator|->
name|tm_year
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|uLong
name|filetime
parameter_list|(
name|f
parameter_list|,
name|tmzip
parameter_list|,
name|dt
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
comment|/* name of file to get info on */
name|tm_zip
modifier|*
name|tmzip
decl_stmt|;
comment|/* return value: access, modific. and creation times */
name|uLong
modifier|*
name|dt
decl_stmt|;
comment|/* dostime */
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|check_exist_file
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|ftestexist
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|ftestexist
operator|=
name|FOPEN_FUNC
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftestexist
operator|==
name|NULL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|fclose
argument_list|(
name|ftestexist
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|do_banner
parameter_list|()
block|{
name|printf
argument_list|(
literal|"MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_help
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\n\n"
expr|\
literal|"  -o  Overwrite existing file.zip\n"
expr|\
literal|"  -a  Append to existing file.zip\n"
expr|\
literal|"  -0  Store only\n"
expr|\
literal|"  -1  Compress faster\n"
expr|\
literal|"  -9  Compress better\n\n"
expr|\
literal|"  -j  exclude path. store only the file name.\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* calculate the CRC32 of a file,    because to encrypt a file, we need known the CRC32 of the file before */
end_comment

begin_function
name|int
name|getFileCrc
parameter_list|(
specifier|const
name|char
modifier|*
name|filenameinzip
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size_buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|result_crc
parameter_list|)
block|{
name|unsigned
name|long
name|calculate_crc
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
name|ZIP_OK
decl_stmt|;
name|FILE
modifier|*
name|fin
init|=
name|FOPEN_FUNC
argument_list|(
name|filenameinzip
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|size_read
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|total_read
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ZIP_ERRNO
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ZIP_OK
condition|)
do|do
block|{
name|err
operator|=
name|ZIP_OK
expr_stmt|;
name|size_read
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|size_buf
argument_list|,
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_read
operator|<
name|size_buf
condition|)
if|if
condition|(
name|feof
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error in reading %s\n"
argument_list|,
name|filenameinzip
argument_list|)
expr_stmt|;
name|err
operator|=
name|ZIP_ERRNO
expr_stmt|;
block|}
if|if
condition|(
name|size_read
operator|>
literal|0
condition|)
name|calculate_crc
operator|=
name|crc32
argument_list|(
name|calculate_crc
argument_list|,
name|buf
argument_list|,
name|size_read
argument_list|)
expr_stmt|;
name|total_read
operator|+=
name|size_read
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|err
operator|==
name|ZIP_OK
operator|)
operator|&&
operator|(
name|size_read
operator|>
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|fin
condition|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
operator|*
name|result_crc
operator|=
name|calculate_crc
expr_stmt|;
name|printf
argument_list|(
literal|"file %s crc %lx\n"
argument_list|,
name|filenameinzip
argument_list|,
name|calculate_crc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|isLargeFile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|largeFile
init|=
literal|0
decl_stmt|;
name|ZPOS64_T
name|pos
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|pFile
init|=
name|FOPEN_FUNC
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pFile
operator|!=
name|NULL
condition|)
block|{
name|int
name|n
init|=
name|FSEEKO_FUNC
argument_list|(
name|pFile
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
decl_stmt|;
name|pos
operator|=
name|FTELLO_FUNC
argument_list|(
name|pFile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"File : %s is %lld bytes\n"
argument_list|,
name|filename
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0xffffffff
condition|)
name|largeFile
operator|=
literal|1
expr_stmt|;
name|fclose
argument_list|(
name|pFile
argument_list|)
expr_stmt|;
block|}
return|return
name|largeFile
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|opt_overwrite
init|=
literal|0
decl_stmt|;
name|int
name|opt_compress_level
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
name|int
name|opt_exclude_path
init|=
literal|0
decl_stmt|;
name|int
name|zipfilenamearg
init|=
literal|0
decl_stmt|;
name|char
name|filename_try
index|[
name|MAXFILENAME
operator|+
literal|16
index|]
decl_stmt|;
name|int
name|zipok
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|size_buf
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|do_banner
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|do_help
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|argv
index|[
name|i
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
init|=
operator|*
operator|(
name|p
operator|++
operator|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'o'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'O'
operator|)
condition|)
name|opt_overwrite
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'A'
operator|)
condition|)
name|opt_overwrite
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
name|opt_compress_level
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'j'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'J'
operator|)
condition|)
name|opt_exclude_path
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|==
literal|'p'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'P'
operator|)
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|<
name|argc
operator|)
condition|)
block|{
name|password
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|zipfilenamearg
operator|==
literal|0
condition|)
block|{
name|zipfilenamearg
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
name|size_buf
operator|=
name|WRITEBUFFERSIZE
expr_stmt|;
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error allocating memory\n"
argument_list|)
expr_stmt|;
return|return
name|ZIP_INTERNALERROR
return|;
block|}
if|if
condition|(
name|zipfilenamearg
operator|==
literal|0
condition|)
block|{
name|zipok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|dot_found
init|=
literal|0
decl_stmt|;
name|zipok
operator|=
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|filename_try
argument_list|,
name|argv
index|[
name|zipfilenamearg
index|]
argument_list|,
name|MAXFILENAME
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* strncpy doesnt append the trailing NULL, of the string is too long. */
name|filename_try
index|[
name|MAXFILENAME
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|filename_try
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|filename_try
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
name|dot_found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dot_found
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|filename_try
argument_list|,
literal|".zip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_overwrite
operator|==
literal|2
condition|)
block|{
comment|/* if the file don't exist, we not append file */
if|if
condition|(
name|check_exist_file
argument_list|(
name|filename_try
argument_list|)
operator|==
literal|0
condition|)
name|opt_overwrite
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_overwrite
operator|==
literal|0
condition|)
if|if
condition|(
name|check_exist_file
argument_list|(
name|filename_try
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|rep
init|=
literal|0
decl_stmt|;
do|do
block|{
name|char
name|answer
index|[
literal|128
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : "
argument_list|,
name|filename_try
argument_list|)
expr_stmt|;
name|ret
operator|=
name|scanf
argument_list|(
literal|"%1s"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|rep
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rep
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|rep
operator|<=
literal|'z'
operator|)
condition|)
name|rep
operator|-=
literal|0x20
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rep
operator|!=
literal|'Y'
operator|)
operator|&&
operator|(
name|rep
operator|!=
literal|'N'
operator|)
operator|&&
operator|(
name|rep
operator|!=
literal|'A'
operator|)
condition|)
do|;
if|if
condition|(
name|rep
operator|==
literal|'N'
condition|)
name|zipok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rep
operator|==
literal|'A'
condition|)
name|opt_overwrite
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zipok
operator|==
literal|1
condition|)
block|{
name|zipFile
name|zf
decl_stmt|;
name|int
name|errclose
decl_stmt|;
ifdef|#
directive|ifdef
name|USEWIN32IOAPI
name|zlib_filefunc64_def
name|ffunc
decl_stmt|;
name|fill_win32_filefunc64A
argument_list|(
operator|&
name|ffunc
argument_list|)
expr_stmt|;
name|zf
operator|=
name|zipOpen2_64
argument_list|(
name|filename_try
argument_list|,
operator|(
name|opt_overwrite
operator|==
literal|2
operator|)
condition|?
literal|2
else|:
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|ffunc
argument_list|)
expr_stmt|;
else|#
directive|else
name|zf
operator|=
name|zipOpen64
argument_list|(
name|filename_try
argument_list|,
operator|(
name|opt_overwrite
operator|==
literal|2
operator|)
condition|?
literal|2
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"error opening %s\n"
argument_list|,
name|filename_try
argument_list|)
expr_stmt|;
name|err
operator|=
name|ZIP_ERRNO
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"creating %s\n"
argument_list|,
name|filename_try
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|zipfilenamearg
operator|+
literal|1
init|;
operator|(
name|i
operator|<
name|argc
operator|)
operator|&&
operator|(
name|err
operator|==
name|ZIP_OK
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
operator|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|)
operator|)
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|)
operator|)
operator|==
literal|'/'
operator|)
operator|)
operator|&&
operator|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'o'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'O'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'a'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'p'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'P'
operator|)
operator|||
operator|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|)
operator|||
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|)
operator|)
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|2
operator|)
operator|)
condition|)
block|{
name|FILE
modifier|*
name|fin
decl_stmt|;
name|int
name|size_read
decl_stmt|;
specifier|const
name|char
modifier|*
name|filenameinzip
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|savefilenameinzip
decl_stmt|;
name|zip_fileinfo
name|zi
decl_stmt|;
name|unsigned
name|long
name|crcFile
init|=
literal|0
decl_stmt|;
name|int
name|zip64
init|=
literal|0
decl_stmt|;
name|zi
operator|.
name|tmz_date
operator|.
name|tm_sec
operator|=
name|zi
operator|.
name|tmz_date
operator|.
name|tm_min
operator|=
name|zi
operator|.
name|tmz_date
operator|.
name|tm_hour
operator|=
name|zi
operator|.
name|tmz_date
operator|.
name|tm_mday
operator|=
name|zi
operator|.
name|tmz_date
operator|.
name|tm_mon
operator|=
name|zi
operator|.
name|tmz_date
operator|.
name|tm_year
operator|=
literal|0
expr_stmt|;
name|zi
operator|.
name|dosDate
operator|=
literal|0
expr_stmt|;
name|zi
operator|.
name|internal_fa
operator|=
literal|0
expr_stmt|;
name|zi
operator|.
name|external_fa
operator|=
literal|0
expr_stmt|;
name|filetime
argument_list|(
name|filenameinzip
argument_list|,
operator|&
name|zi
operator|.
name|tmz_date
argument_list|,
operator|&
name|zi
operator|.
name|dosDate
argument_list|)
expr_stmt|;
comment|/*                 err = zipOpenNewFileInZip(zf,filenameinzip,&zi,                                  NULL,0,NULL,0,NULL / * comment * /,                                  (opt_compress_level != 0) ? Z_DEFLATED : 0,                                  opt_compress_level); */
if|if
condition|(
operator|(
name|password
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|err
operator|==
name|ZIP_OK
operator|)
condition|)
name|err
operator|=
name|getFileCrc
argument_list|(
name|filenameinzip
argument_list|,
name|buf
argument_list|,
name|size_buf
argument_list|,
operator|&
name|crcFile
argument_list|)
expr_stmt|;
name|zip64
operator|=
name|isLargeFile
argument_list|(
name|filenameinzip
argument_list|)
expr_stmt|;
comment|/* The path name saved, should not include a leading slash. */
comment|/*if it did, windows/xp and dynazip couldn't read the zip file. */
name|savefilenameinzip
operator|=
name|filenameinzip
expr_stmt|;
while|while
condition|(
name|savefilenameinzip
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|||
name|savefilenameinzip
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|savefilenameinzip
operator|++
expr_stmt|;
block|}
comment|/*should the zip file contain any path at all?*/
if|if
condition|(
name|opt_exclude_path
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmpptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|lastslash
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tmpptr
operator|=
name|savefilenameinzip
init|;
operator|*
name|tmpptr
condition|;
name|tmpptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tmpptr
operator|==
literal|'\\'
operator|||
operator|*
name|tmpptr
operator|==
literal|'/'
condition|)
block|{
name|lastslash
operator|=
name|tmpptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastslash
operator|!=
name|NULL
condition|)
block|{
name|savefilenameinzip
operator|=
name|lastslash
operator|+
literal|1
expr_stmt|;
comment|// base filename follows last slash.
block|}
block|}
comment|/**/
name|err
operator|=
name|zipOpenNewFileInZip3_64
argument_list|(
name|zf
argument_list|,
name|savefilenameinzip
argument_list|,
operator|&
name|zi
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
comment|/* comment*/
argument_list|,
operator|(
name|opt_compress_level
operator|!=
literal|0
operator|)
condition|?
name|Z_DEFLATED
else|:
literal|0
argument_list|,
name|opt_compress_level
argument_list|,
literal|0
argument_list|,
comment|/* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */
operator|-
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|,
name|password
argument_list|,
name|crcFile
argument_list|,
name|zip64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ZIP_OK
condition|)
name|printf
argument_list|(
literal|"error in opening %s in zipfile\n"
argument_list|,
name|filenameinzip
argument_list|)
expr_stmt|;
else|else
block|{
name|fin
operator|=
name|FOPEN_FUNC
argument_list|(
name|filenameinzip
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ZIP_ERRNO
expr_stmt|;
name|printf
argument_list|(
literal|"error in opening %s for reading\n"
argument_list|,
name|filenameinzip
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
name|ZIP_OK
condition|)
do|do
block|{
name|err
operator|=
name|ZIP_OK
expr_stmt|;
name|size_read
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|size_buf
argument_list|,
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_read
operator|<
name|size_buf
condition|)
if|if
condition|(
name|feof
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error in reading %s\n"
argument_list|,
name|filenameinzip
argument_list|)
expr_stmt|;
name|err
operator|=
name|ZIP_ERRNO
expr_stmt|;
block|}
if|if
condition|(
name|size_read
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|zipWriteInFileInZip
argument_list|(
name|zf
argument_list|,
name|buf
argument_list|,
name|size_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error in writing %s in the zipfile\n"
argument_list|,
name|filenameinzip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|err
operator|==
name|ZIP_OK
operator|)
operator|&&
operator|(
name|size_read
operator|>
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|fin
condition|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
name|err
operator|=
name|ZIP_ERRNO
expr_stmt|;
else|else
block|{
name|err
operator|=
name|zipCloseFileInZip
argument_list|(
name|zf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ZIP_OK
condition|)
name|printf
argument_list|(
literal|"error in closing %s in the zipfile\n"
argument_list|,
name|filenameinzip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|errclose
operator|=
name|zipClose
argument_list|(
name|zf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errclose
operator|!=
name|ZIP_OK
condition|)
name|printf
argument_list|(
literal|"error in closing %s\n"
argument_list|,
name|filename_try
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_help
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

