begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    miniunz.c    Version 1.1, February 14h, 2010    sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )           Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )           Modifications of Unzip for Zip64          Copyright (C) 2007-2008 Even Rouault           Modifications for Zip64 support on both zip and unzip          Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com ) */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|__USE_FILE_OFFSET64
end_ifndef

begin_define
define|#
directive|define
name|__USE_FILE_OFFSET64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__USE_LARGEFILE64
end_ifndef

begin_define
define|#
directive|define
name|__USE_LARGEFILE64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_LARGEFILE64_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_LARGEFILE64_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_FILE_OFFSET_BIT
end_ifndef

begin_define
define|#
directive|define
name|_FILE_OFFSET_BIT
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_comment
comment|// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
end_comment

begin_define
define|#
directive|define
name|FOPEN_FUNC
parameter_list|(
name|filename
parameter_list|,
name|mode
parameter_list|)
value|fopen(filename, mode)
end_define

begin_define
define|#
directive|define
name|FTELLO_FUNC
parameter_list|(
name|stream
parameter_list|)
value|ftello(stream)
end_define

begin_define
define|#
directive|define
name|FSEEKO_FUNC
parameter_list|(
name|stream
parameter_list|,
name|offset
parameter_list|,
name|origin
parameter_list|)
value|fseeko(stream, offset, origin)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FOPEN_FUNC
parameter_list|(
name|filename
parameter_list|,
name|mode
parameter_list|)
value|fopen64(filename, mode)
end_define

begin_define
define|#
directive|define
name|FTELLO_FUNC
parameter_list|(
name|stream
parameter_list|)
value|ftello64(stream)
end_define

begin_define
define|#
directive|define
name|FSEEKO_FUNC
parameter_list|(
name|stream
parameter_list|,
name|offset
parameter_list|,
name|origin
parameter_list|)
value|fseeko64(stream, offset, origin)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unzip.h"
end_include

begin_define
define|#
directive|define
name|CASESENSITIVITY
value|(0)
end_define

begin_define
define|#
directive|define
name|WRITEBUFFERSIZE
value|(8192)
end_define

begin_define
define|#
directive|define
name|MAXFILENAME
value|(256)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|USEWIN32IOAPI
end_define

begin_include
include|#
directive|include
file|"iowin32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   mini unzip, demo of unzip package    usage :   Usage : miniunz [-exvlo] file.zip [file_to_extract] [-d extractdir]    list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT     if it exists */
end_comment

begin_comment
comment|/* change_file_date : change the date/time of a file     filename : the filename of the file where date/time must be modified     dosdate : the new date at the MSDos format (4 bytes)     tmu_date : the SAME new date at the tm_unz format */
end_comment

begin_function
name|void
name|change_file_date
parameter_list|(
name|filename
parameter_list|,
name|dosdate
parameter_list|,
name|tmu_date
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|uLong
name|dosdate
decl_stmt|;
name|tm_unz
name|tmu_date
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|HANDLE
name|hFile
decl_stmt|;
name|FILETIME
name|ftm
decl_stmt|,
name|ftLocal
decl_stmt|,
name|ftCreate
decl_stmt|,
name|ftLastAcc
decl_stmt|,
name|ftLastWrite
decl_stmt|;
name|hFile
operator|=
name|CreateFileA
argument_list|(
name|filename
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GetFileTime
argument_list|(
name|hFile
argument_list|,
operator|&
name|ftCreate
argument_list|,
operator|&
name|ftLastAcc
argument_list|,
operator|&
name|ftLastWrite
argument_list|)
expr_stmt|;
name|DosDateTimeToFileTime
argument_list|(
call|(
name|WORD
call|)
argument_list|(
name|dosdate
operator|>>
literal|16
argument_list|)
argument_list|,
operator|(
name|WORD
operator|)
name|dosdate
argument_list|,
operator|&
name|ftLocal
argument_list|)
expr_stmt|;
name|LocalFileTimeToFileTime
argument_list|(
operator|&
name|ftLocal
argument_list|,
operator|&
name|ftm
argument_list|)
expr_stmt|;
name|SetFileTime
argument_list|(
name|hFile
argument_list|,
operator|&
name|ftm
argument_list|,
operator|&
name|ftLastAcc
argument_list|,
operator|&
name|ftm
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hFile
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|unix
name|||
name|__APPLE__
name|struct
name|utimbuf
name|ut
decl_stmt|;
name|struct
name|tm
name|newdate
decl_stmt|;
name|newdate
operator|.
name|tm_sec
operator|=
name|tmu_date
operator|.
name|tm_sec
expr_stmt|;
name|newdate
operator|.
name|tm_min
operator|=
name|tmu_date
operator|.
name|tm_min
expr_stmt|;
name|newdate
operator|.
name|tm_hour
operator|=
name|tmu_date
operator|.
name|tm_hour
expr_stmt|;
name|newdate
operator|.
name|tm_mday
operator|=
name|tmu_date
operator|.
name|tm_mday
expr_stmt|;
name|newdate
operator|.
name|tm_mon
operator|=
name|tmu_date
operator|.
name|tm_mon
expr_stmt|;
if|if
condition|(
name|tmu_date
operator|.
name|tm_year
operator|>
literal|1900
condition|)
name|newdate
operator|.
name|tm_year
operator|=
name|tmu_date
operator|.
name|tm_year
operator|-
literal|1900
expr_stmt|;
else|else
name|newdate
operator|.
name|tm_year
operator|=
name|tmu_date
operator|.
name|tm_year
expr_stmt|;
name|newdate
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
name|ut
operator|.
name|actime
operator|=
name|ut
operator|.
name|modtime
operator|=
name|mktime
argument_list|(
operator|&
name|newdate
argument_list|)
expr_stmt|;
name|utime
argument_list|(
name|filename
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* mymkdir and change_file_date are not 100 % portable    As I don't know well Unix, I wait feedback for the unix portion */
end_comment

begin_function
name|int
name|mymkdir
parameter_list|(
name|dirname
parameter_list|)
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|ret
operator|=
name|_mkdir
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|unix
name|ret
operator|=
name|mkdir
argument_list|(
name|dirname
argument_list|,
literal|0775
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__APPLE__
name|ret
operator|=
name|mkdir
argument_list|(
name|dirname
argument_list|,
literal|0775
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|makedir
parameter_list|(
name|newdir
parameter_list|)
name|char
modifier|*
name|newdir
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|newdir
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error allocating memory\n"
argument_list|)
expr_stmt|;
return|return
name|UNZ_INTERNALERROR
return|;
block|}
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|newdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|mymkdir
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|buffer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|hold
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\\'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|hold
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mymkdir
argument_list|(
name|buffer
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't create directory %s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hold
operator|==
literal|0
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|hold
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|do_banner
parameter_list|()
block|{
name|printf
argument_list|(
literal|"MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"more info at http://www.winimage.com/zLibDll/unzip.html\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_help
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\n\n"
expr|\
literal|"  -e  Extract without pathname (junk paths)\n"
expr|\
literal|"  -x  Extract with pathname\n"
expr|\
literal|"  -v  list files\n"
expr|\
literal|"  -l  list files\n"
expr|\
literal|"  -d  directory to extract into\n"
expr|\
literal|"  -o  overwrite files without prompting\n"
expr|\
literal|"  -p  extract crypted file using password\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Display64BitsSize
parameter_list|(
name|ZPOS64_T
name|n
parameter_list|,
name|int
name|size_char
parameter_list|)
block|{
comment|/* to avoid compatibility problem , we do here the conversion */
name|char
name|number
index|[
literal|21
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|19
decl_stmt|;
name|int
name|pos_string
init|=
literal|19
decl_stmt|;
name|number
index|[
literal|20
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|number
index|[
name|offset
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|n
operator|%
literal|10
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
index|[
name|offset
index|]
operator|!=
literal|'0'
condition|)
name|pos_string
operator|=
name|offset
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
break|break;
name|offset
operator|--
expr_stmt|;
block|}
block|{
name|int
name|size_display_string
init|=
literal|19
operator|-
name|pos_string
decl_stmt|;
while|while
condition|(
name|size_char
operator|>
name|size_display_string
condition|)
block|{
name|size_char
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|number
index|[
name|pos_string
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|do_list
parameter_list|(
name|uf
parameter_list|)
name|unzFile
name|uf
decl_stmt|;
block|{
name|uLong
name|i
decl_stmt|;
name|unz_global_info64
name|gi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|unzGetGlobalInfo64
argument_list|(
name|uf
argument_list|,
operator|&
name|gi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
name|printf
argument_list|(
literal|"error %d with zipfile in unzGetGlobalInfo \n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Length  Method     Size Ratio   Date    Time   CRC-32     Name\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ------  ------     ---- -----   ----    ----   ------     ----\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gi
operator|.
name|number_entry
condition|;
name|i
operator|++
control|)
block|{
name|char
name|filename_inzip
index|[
literal|256
index|]
decl_stmt|;
name|unz_file_info64
name|file_info
decl_stmt|;
name|uLong
name|ratio
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_method
decl_stmt|;
name|char
name|charCrypt
init|=
literal|' '
decl_stmt|;
name|err
operator|=
name|unzGetCurrentFileInfo64
argument_list|(
name|uf
argument_list|,
operator|&
name|file_info
argument_list|,
name|filename_inzip
argument_list|,
sizeof|sizeof
argument_list|(
name|filename_inzip
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzGetCurrentFileInfo\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|file_info
operator|.
name|uncompressed_size
operator|>
literal|0
condition|)
name|ratio
operator|=
call|(
name|uLong
call|)
argument_list|(
operator|(
name|file_info
operator|.
name|compressed_size
operator|*
literal|100
operator|)
operator|/
name|file_info
operator|.
name|uncompressed_size
argument_list|)
expr_stmt|;
comment|/* display a '*' if the file is crypted */
if|if
condition|(
operator|(
name|file_info
operator|.
name|flag
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|charCrypt
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
name|file_info
operator|.
name|compression_method
operator|==
literal|0
condition|)
name|string_method
operator|=
literal|"Stored"
expr_stmt|;
elseif|else
if|if
condition|(
name|file_info
operator|.
name|compression_method
operator|==
name|Z_DEFLATED
condition|)
block|{
name|uInt
name|iLevel
init|=
call|(
name|uInt
call|)
argument_list|(
operator|(
name|file_info
operator|.
name|flag
operator|&
literal|0x6
operator|)
operator|/
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|iLevel
operator|==
literal|0
condition|)
name|string_method
operator|=
literal|"Defl:N"
expr_stmt|;
elseif|else
if|if
condition|(
name|iLevel
operator|==
literal|1
condition|)
name|string_method
operator|=
literal|"Defl:X"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|iLevel
operator|==
literal|2
operator|)
operator|||
operator|(
name|iLevel
operator|==
literal|3
operator|)
condition|)
name|string_method
operator|=
literal|"Defl:F"
expr_stmt|;
comment|/* 2:fast , 3 : extra fast*/
block|}
elseif|else
if|if
condition|(
name|file_info
operator|.
name|compression_method
operator|==
name|Z_BZIP2ED
condition|)
block|{
name|string_method
operator|=
literal|"BZip2 "
expr_stmt|;
block|}
else|else
name|string_method
operator|=
literal|"Unkn. "
expr_stmt|;
name|Display64BitsSize
argument_list|(
name|file_info
operator|.
name|uncompressed_size
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %6s%c"
argument_list|,
name|string_method
argument_list|,
name|charCrypt
argument_list|)
expr_stmt|;
name|Display64BitsSize
argument_list|(
name|file_info
operator|.
name|compressed_size
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\n"
argument_list|,
name|ratio
argument_list|,
operator|(
name|uLong
operator|)
name|file_info
operator|.
name|tmu_date
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
operator|(
name|uLong
operator|)
name|file_info
operator|.
name|tmu_date
operator|.
name|tm_mday
argument_list|,
operator|(
name|uLong
operator|)
name|file_info
operator|.
name|tmu_date
operator|.
name|tm_year
operator|%
literal|100
argument_list|,
operator|(
name|uLong
operator|)
name|file_info
operator|.
name|tmu_date
operator|.
name|tm_hour
argument_list|,
operator|(
name|uLong
operator|)
name|file_info
operator|.
name|tmu_date
operator|.
name|tm_min
argument_list|,
operator|(
name|uLong
operator|)
name|file_info
operator|.
name|crc
argument_list|,
name|filename_inzip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|gi
operator|.
name|number_entry
condition|)
block|{
name|err
operator|=
name|unzGoToNextFile
argument_list|(
name|uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzGoToNextFile\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|do_extract_currentfile
parameter_list|(
name|uf
parameter_list|,
name|popt_extract_without_path
parameter_list|,
name|popt_overwrite
parameter_list|,
name|password
parameter_list|)
name|unzFile
name|uf
decl_stmt|;
specifier|const
name|int
modifier|*
name|popt_extract_without_path
decl_stmt|;
name|int
modifier|*
name|popt_overwrite
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
block|{
name|char
name|filename_inzip
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|filename_withoutpath
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
name|UNZ_OK
decl_stmt|;
name|FILE
modifier|*
name|fout
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uInt
name|size_buf
decl_stmt|;
name|unz_file_info64
name|file_info
decl_stmt|;
name|uLong
name|ratio
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|unzGetCurrentFileInfo64
argument_list|(
name|uf
argument_list|,
operator|&
name|file_info
argument_list|,
name|filename_inzip
argument_list|,
sizeof|sizeof
argument_list|(
name|filename_inzip
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzGetCurrentFileInfo\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|size_buf
operator|=
name|WRITEBUFFERSIZE
expr_stmt|;
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error allocating memory\n"
argument_list|)
expr_stmt|;
return|return
name|UNZ_INTERNALERROR
return|;
block|}
name|p
operator|=
name|filename_withoutpath
operator|=
name|filename_inzip
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|p
operator|)
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|(
operator|*
name|p
operator|)
operator|==
literal|'\\'
operator|)
condition|)
name|filename_withoutpath
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|filename_withoutpath
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|popt_extract_without_path
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"creating directory: %s\n"
argument_list|,
name|filename_inzip
argument_list|)
expr_stmt|;
name|mymkdir
argument_list|(
name|filename_inzip
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|write_filename
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|popt_extract_without_path
operator|)
operator|==
literal|0
condition|)
name|write_filename
operator|=
name|filename_inzip
expr_stmt|;
else|else
name|write_filename
operator|=
name|filename_withoutpath
expr_stmt|;
name|err
operator|=
name|unzOpenCurrentFilePassword
argument_list|(
name|uf
argument_list|,
name|password
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzOpenCurrentFilePassword\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|popt_overwrite
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|err
operator|==
name|UNZ_OK
operator|)
condition|)
block|{
name|char
name|rep
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|ftestexist
decl_stmt|;
name|ftestexist
operator|=
name|FOPEN_FUNC
argument_list|(
name|write_filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftestexist
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ftestexist
argument_list|)
expr_stmt|;
do|do
block|{
name|char
name|answer
index|[
literal|128
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: "
argument_list|,
name|write_filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|scanf
argument_list|(
literal|"%1s"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|rep
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rep
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|rep
operator|<=
literal|'z'
operator|)
condition|)
name|rep
operator|-=
literal|0x20
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rep
operator|!=
literal|'Y'
operator|)
operator|&&
operator|(
name|rep
operator|!=
literal|'N'
operator|)
operator|&&
operator|(
name|rep
operator|!=
literal|'A'
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|rep
operator|==
literal|'N'
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rep
operator|==
literal|'A'
condition|)
operator|*
name|popt_overwrite
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|skip
operator|==
literal|0
operator|)
operator|&&
operator|(
name|err
operator|==
name|UNZ_OK
operator|)
condition|)
block|{
name|fout
operator|=
name|FOPEN_FUNC
argument_list|(
name|write_filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
comment|/* some zipfile don't contain directory alone before file */
if|if
condition|(
operator|(
name|fout
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|*
name|popt_extract_without_path
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|filename_withoutpath
operator|!=
operator|(
name|char
operator|*
operator|)
name|filename_inzip
operator|)
condition|)
block|{
name|char
name|c
init|=
operator|*
operator|(
name|filename_withoutpath
operator|-
literal|1
operator|)
decl_stmt|;
operator|*
operator|(
name|filename_withoutpath
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|makedir
argument_list|(
name|write_filename
argument_list|)
expr_stmt|;
operator|*
operator|(
name|filename_withoutpath
operator|-
literal|1
operator|)
operator|=
name|c
expr_stmt|;
name|fout
operator|=
name|FOPEN_FUNC
argument_list|(
name|write_filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"error opening %s\n"
argument_list|,
name|write_filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fout
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" extracting: %s\n"
argument_list|,
name|write_filename
argument_list|)
expr_stmt|;
do|do
block|{
name|err
operator|=
name|unzReadCurrentFile
argument_list|(
name|uf
argument_list|,
name|buf
argument_list|,
name|size_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzReadCurrentFile\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
operator|>
literal|0
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|err
argument_list|,
literal|1
argument_list|,
name|fout
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"error in writing extracted file\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|UNZ_ERRNO
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|err
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|fout
condition|)
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|change_file_date
argument_list|(
name|write_filename
argument_list|,
name|file_info
operator|.
name|dosDate
argument_list|,
name|file_info
operator|.
name|tmu_date
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|UNZ_OK
condition|)
block|{
name|err
operator|=
name|unzCloseCurrentFile
argument_list|(
name|uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzCloseCurrentFile\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|unzCloseCurrentFile
argument_list|(
name|uf
argument_list|)
expr_stmt|;
comment|/* don't lose the error */
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|do_extract
parameter_list|(
name|uf
parameter_list|,
name|opt_extract_without_path
parameter_list|,
name|opt_overwrite
parameter_list|,
name|password
parameter_list|)
name|unzFile
name|uf
decl_stmt|;
name|int
name|opt_extract_without_path
decl_stmt|;
name|int
name|opt_overwrite
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
block|{
name|uLong
name|i
decl_stmt|;
name|unz_global_info64
name|gi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|FILE
modifier|*
name|fout
init|=
name|NULL
decl_stmt|;
name|err
operator|=
name|unzGetGlobalInfo64
argument_list|(
name|uf
argument_list|,
operator|&
name|gi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
name|printf
argument_list|(
literal|"error %d with zipfile in unzGetGlobalInfo \n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gi
operator|.
name|number_entry
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|do_extract_currentfile
argument_list|(
name|uf
argument_list|,
operator|&
name|opt_extract_without_path
argument_list|,
operator|&
name|opt_overwrite
argument_list|,
name|password
argument_list|)
operator|!=
name|UNZ_OK
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|gi
operator|.
name|number_entry
condition|)
block|{
name|err
operator|=
name|unzGoToNextFile
argument_list|(
name|uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"error %d with zipfile in unzGoToNextFile\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|do_extract_onefile
parameter_list|(
name|uf
parameter_list|,
name|filename
parameter_list|,
name|opt_extract_without_path
parameter_list|,
name|opt_overwrite
parameter_list|,
name|password
parameter_list|)
name|unzFile
name|uf
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|opt_extract_without_path
decl_stmt|;
name|int
name|opt_overwrite
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
block|{
name|int
name|err
init|=
name|UNZ_OK
decl_stmt|;
if|if
condition|(
name|unzLocateFile
argument_list|(
name|uf
argument_list|,
name|filename
argument_list|,
name|CASESENSITIVITY
argument_list|)
operator|!=
name|UNZ_OK
condition|)
block|{
name|printf
argument_list|(
literal|"file %s not found in the zipfile\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|do_extract_currentfile
argument_list|(
name|uf
argument_list|,
operator|&
name|opt_extract_without_path
argument_list|,
operator|&
name|opt_overwrite
argument_list|,
name|password
argument_list|)
operator|==
name|UNZ_OK
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zipfilename
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename_to_extract
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|char
name|filename_try
index|[
name|MAXFILENAME
operator|+
literal|16
index|]
init|=
literal|""
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret_value
init|=
literal|0
decl_stmt|;
name|int
name|opt_do_list
init|=
literal|0
decl_stmt|;
name|int
name|opt_do_extract
init|=
literal|1
decl_stmt|;
name|int
name|opt_do_extract_withoutpath
init|=
literal|0
decl_stmt|;
name|int
name|opt_overwrite
init|=
literal|0
decl_stmt|;
name|int
name|opt_extractdir
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname
init|=
name|NULL
decl_stmt|;
name|unzFile
name|uf
init|=
name|NULL
decl_stmt|;
name|do_banner
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|do_help
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|argv
index|[
name|i
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
init|=
operator|*
operator|(
name|p
operator|++
operator|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'L'
operator|)
condition|)
name|opt_do_list
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'v'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'V'
operator|)
condition|)
name|opt_do_list
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|)
name|opt_do_extract
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
condition|)
name|opt_do_extract
operator|=
name|opt_do_extract_withoutpath
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'o'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'O'
operator|)
condition|)
name|opt_overwrite
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'D'
operator|)
condition|)
block|{
name|opt_extractdir
operator|=
literal|1
expr_stmt|;
name|dirname
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|==
literal|'p'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'P'
operator|)
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|<
name|argc
operator|)
condition|)
block|{
name|password
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|zipfilename
operator|==
name|NULL
condition|)
name|zipfilename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|filename_to_extract
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|opt_extractdir
operator|)
condition|)
name|filename_to_extract
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|zipfilename
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USEWIN32IOAPI
name|zlib_filefunc64_def
name|ffunc
decl_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
name|filename_try
argument_list|,
name|zipfilename
argument_list|,
name|MAXFILENAME
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* strncpy doesnt append the trailing NULL, of the string is too long. */
name|filename_try
index|[
name|MAXFILENAME
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|USEWIN32IOAPI
name|fill_win32_filefunc64A
argument_list|(
operator|&
name|ffunc
argument_list|)
expr_stmt|;
name|uf
operator|=
name|unzOpen2_64
argument_list|(
name|zipfilename
argument_list|,
operator|&
name|ffunc
argument_list|)
expr_stmt|;
else|#
directive|else
name|uf
operator|=
name|unzOpen64
argument_list|(
name|zipfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uf
operator|==
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|filename_try
argument_list|,
literal|".zip"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USEWIN32IOAPI
name|uf
operator|=
name|unzOpen2_64
argument_list|(
name|filename_try
argument_list|,
operator|&
name|ffunc
argument_list|)
expr_stmt|;
else|#
directive|else
name|uf
operator|=
name|unzOpen64
argument_list|(
name|filename_try
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|uf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot open %s or %s.zip\n"
argument_list|,
name|zipfilename
argument_list|,
name|zipfilename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"%s opened\n"
argument_list|,
name|filename_try
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_do_list
operator|==
literal|1
condition|)
name|ret_value
operator|=
name|do_list
argument_list|(
name|uf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_do_extract
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|opt_extractdir
operator|&&
name|_chdir
argument_list|(
name|dirname
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|opt_extractdir
operator|&&
name|chdir
argument_list|(
name|dirname
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|printf
argument_list|(
literal|"Error changing into %s, aborting\n"
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename_to_extract
operator|==
name|NULL
condition|)
name|ret_value
operator|=
name|do_extract
argument_list|(
name|uf
argument_list|,
name|opt_do_extract_withoutpath
argument_list|,
name|opt_overwrite
argument_list|,
name|password
argument_list|)
expr_stmt|;
else|else
name|ret_value
operator|=
name|do_extract_onefile
argument_list|(
name|uf
argument_list|,
name|filename_to_extract
argument_list|,
name|opt_do_extract_withoutpath
argument_list|,
name|opt_overwrite
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
name|unzClose
argument_list|(
name|uf
argument_list|)
expr_stmt|;
return|return
name|ret_value
return|;
block|}
end_function

end_unit

