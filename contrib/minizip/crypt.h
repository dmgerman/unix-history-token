begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypt.h -- base code for crypt/uncrypt ZIPfile      Version 1.01e, February 12th, 2005     Copyright (C) 1998-2005 Gilles Vollant     This code is a modified version of crypting code in Infozip distribution     The encryption/decryption parts of this source code (as opposed to the    non-echoing password parts) were originally written in Europe.  The    whole source package can be freely distributed, including from the USA.    (Prior to January 2000, re-export from the US was a violation of US law.)     This encryption code is a direct transcription of the algorithm from    Roger Schlafly, described by Phil Katz in the file appnote.txt.  This    file (appnote.txt) is distributed with the PKZIP program (even in the    version without encryption capabilities).     If you don't need crypting in your application, just define symbols    NOCRYPT and NOUNCRYPT.     This code support the "Traditional PKWARE Encryption".     The new AES encryption added on Zip format by Winzip (see the page    http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong    Encryption is not supported. */
end_comment

begin_define
define|#
directive|define
name|CRC32
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
value|((*(pcrc_32_tab+(((int)(c) ^ (b))& 0xff))) ^ ((c)>> 8))
end_define

begin_comment
comment|/***********************************************************************  * Return the next byte in the pseudo-random sequence  */
end_comment

begin_function
specifier|static
name|int
name|decrypt_byte
parameter_list|(
name|unsigned
name|long
modifier|*
name|pkeys
parameter_list|,
specifier|const
name|z_crc_t
modifier|*
name|pcrc_32_tab
parameter_list|)
block|{
name|unsigned
name|temp
decl_stmt|;
comment|/* POTENTIAL BUG:  temp*(temp^1) may overflow in an                      * unpredictable manner on 16-bit systems; not a problem                      * with any known compiler so far, though */
name|temp
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|*
operator|(
name|pkeys
operator|+
literal|2
operator|)
argument_list|)
operator|&
literal|0xffff
operator|)
operator||
literal|2
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|temp
operator|*
operator|(
name|temp
operator|^
literal|1
operator|)
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * Update the encryption keys with the next byte of plain text  */
end_comment

begin_function
specifier|static
name|int
name|update_keys
parameter_list|(
name|unsigned
name|long
modifier|*
name|pkeys
parameter_list|,
specifier|const
name|z_crc_t
modifier|*
name|pcrc_32_tab
parameter_list|,
name|int
name|c
parameter_list|)
block|{
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|0
operator|)
operator|)
operator|=
name|CRC32
argument_list|(
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|0
operator|)
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|1
operator|)
operator|)
operator|+=
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|0
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|1
operator|)
operator|)
operator|=
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|1
operator|)
operator|)
operator|*
literal|134775813L
operator|+
literal|1
expr_stmt|;
block|{
specifier|register
name|int
name|keyshift
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|1
operator|)
operator|)
operator|>>
literal|24
argument_list|)
decl_stmt|;
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|2
operator|)
operator|)
operator|=
name|CRC32
argument_list|(
operator|(
operator|*
operator|(
name|pkeys
operator|+
literal|2
operator|)
operator|)
argument_list|,
name|keyshift
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * Initialize the encryption keys and the random header according to  * the given password.  */
end_comment

begin_function
specifier|static
name|void
name|init_keys
parameter_list|(
specifier|const
name|char
modifier|*
name|passwd
parameter_list|,
name|unsigned
name|long
modifier|*
name|pkeys
parameter_list|,
specifier|const
name|z_crc_t
modifier|*
name|pcrc_32_tab
parameter_list|)
block|{
operator|*
operator|(
name|pkeys
operator|+
literal|0
operator|)
operator|=
literal|305419896L
expr_stmt|;
operator|*
operator|(
name|pkeys
operator|+
literal|1
operator|)
operator|=
literal|591751049L
expr_stmt|;
operator|*
operator|(
name|pkeys
operator|+
literal|2
operator|)
operator|=
literal|878082192L
expr_stmt|;
while|while
condition|(
operator|*
name|passwd
operator|!=
literal|'\0'
condition|)
block|{
name|update_keys
argument_list|(
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|,
operator|(
name|int
operator|)
operator|*
name|passwd
argument_list|)
expr_stmt|;
name|passwd
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|zdecode
parameter_list|(
name|pkeys
parameter_list|,
name|pcrc_32_tab
parameter_list|,
name|c
parameter_list|)
define|\
value|(update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
end_define

begin_define
define|#
directive|define
name|zencode
parameter_list|(
name|pkeys
parameter_list|,
name|pcrc_32_tab
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
define|\
value|(t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDECRYPTINGCODE_IFCRYPTALLOWED
end_ifdef

begin_define
define|#
directive|define
name|RAND_HEAD_LEN
value|12
end_define

begin_comment
comment|/* "last resort" source for second part of crypt seed pattern */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZCR_SEED2
end_ifndef

begin_define
define|#
directive|define
name|ZCR_SEED2
value|3141592654UL
end_define

begin_comment
comment|/* use PI as default pattern */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|crypthead
parameter_list|(
specifier|const
name|char
modifier|*
name|passwd
parameter_list|,
comment|/* password string */
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
comment|/* where to write header */
name|int
name|bufSize
parameter_list|,
name|unsigned
name|long
modifier|*
name|pkeys
parameter_list|,
specifier|const
name|z_crc_t
modifier|*
name|pcrc_32_tab
parameter_list|,
name|unsigned
name|long
name|crcForCrypting
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* index in random header */
name|int
name|t
decl_stmt|;
comment|/* temporary */
name|int
name|c
decl_stmt|;
comment|/* random byte */
name|unsigned
name|char
name|header
index|[
name|RAND_HEAD_LEN
operator|-
literal|2
index|]
decl_stmt|;
comment|/* random header */
specifier|static
name|unsigned
name|calls
init|=
literal|0
decl_stmt|;
comment|/* ensure different random header each time */
if|if
condition|(
name|bufSize
operator|<
name|RAND_HEAD_LEN
condition|)
return|return
literal|0
return|;
comment|/* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the      * output of rand() to get less predictability, since rand() is      * often poorly implemented.      */
if|if
condition|(
operator|++
name|calls
operator|==
literal|1
condition|)
block|{
name|srand
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|ZCR_SEED2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|init_keys
argument_list|(
name|passwd
argument_list|,
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|RAND_HEAD_LEN
operator|-
literal|2
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|rand
argument_list|()
operator|>>
literal|7
operator|)
operator|&
literal|0xff
expr_stmt|;
name|header
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|zencode
argument_list|(
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|,
name|c
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Encrypt random header (last two bytes is high word of crc) */
name|init_keys
argument_list|(
name|passwd
argument_list|,
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|RAND_HEAD_LEN
operator|-
literal|2
condition|;
name|n
operator|++
control|)
block|{
name|buf
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|zencode
argument_list|(
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|,
name|header
index|[
name|n
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|n
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|zencode
argument_list|(
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|,
call|(
name|int
call|)
argument_list|(
name|crcForCrypting
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|buf
index|[
name|n
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|zencode
argument_list|(
name|pkeys
argument_list|,
name|pcrc_32_tab
argument_list|,
call|(
name|int
call|)
argument_list|(
name|crcForCrypting
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

