begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016 Martin Pieuchot<mpi@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctf.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ZLIB
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZLIB */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|nitems
end_ifndef

begin_define
define|#
directive|define
name|nitems
parameter_list|(
name|_a
parameter_list|)
value|(sizeof((_a)) / sizeof((_a)[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ELF_STRTAB
end_ifndef

begin_define
define|#
directive|define
name|ELF_STRTAB
value|".strtab"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ELF_CTF
end_ifndef

begin_define
define|#
directive|define
name|ELF_CTF
value|".SUNW_ctf"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DUMP_OBJECT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DUMP_FUNCTION
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DUMP_HEADER
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|DUMP_LABEL
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|DUMP_STRTAB
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|DUMP_STATISTIC
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|DUMP_TYPE
value|(1<< 6)
end_define

begin_function_decl
name|int
name|dump
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isctf
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__dead2
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ctf_dump
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|ctf_dump_type
parameter_list|(
name|struct
name|ctf_header
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|ctf_kind2name
parameter_list|(
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|ctf_enc2name
parameter_list|(
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|ctf_off2name
parameter_list|(
name|struct
name|ctf_header
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|elf_dump
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|elf_idx2sym
parameter_list|(
name|size_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* elf.c */
end_comment

begin_function_decl
name|int
name|iself
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|elf_getshstab
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ssize_t
name|elf_getsymtab
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ssize_t
name|elf_getsection
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|decompress
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|uint8_t
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dfhlst"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|flags
operator||=
name|DUMP_OBJECT
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator||=
name|DUMP_FUNCTION
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|flags
operator||=
name|DUMP_HEADER
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|flags
operator||=
name|DUMP_LABEL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator||=
name|DUMP_STRTAB
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|flags
operator||=
name|DUMP_TYPE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Dump everything by default */
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
name|flags
operator|=
literal|0xff
expr_stmt|;
while|while
condition|(
operator|(
name|filename
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
name|error
operator||=
name|dump
argument_list|(
name|filename
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|dump
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|uintmax_t
operator|)
name|st
operator|.
name|st_size
operator|>
name|SIZE_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"file too big to fit memory"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|MAP_FAILED
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"mmap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iself
argument_list|(
name|p
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
condition|)
block|{
name|error
operator|=
name|elf_dump
argument_list|(
name|p
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isctf
argument_list|(
name|p
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
condition|)
block|{
name|error
operator|=
name|ctf_dump
argument_list|(
name|p
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|munmap
argument_list|(
name|p
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|strtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|strtabsz
decl_stmt|,
name|nsymb
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|elf_idx2sym
parameter_list|(
name|size_t
modifier|*
name|idx
parameter_list|,
name|uint8_t
name|type
parameter_list|)
block|{
specifier|const
name|Elf_Sym
modifier|*
name|st
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|idx
operator|+
literal|1
init|;
name|i
operator|<
name|nsymb
condition|;
name|i
operator|++
control|)
block|{
name|st
operator|=
operator|&
name|symtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|st
operator|->
name|st_info
argument_list|)
operator|!=
name|type
condition|)
continue|continue;
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
name|strtab
operator|+
name|st
operator|->
name|st_name
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|elf_dump
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|filesize
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|eh
init|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|p
decl_stmt|;
name|Elf_Shdr
modifier|*
name|sh
decl_stmt|;
specifier|const
name|char
modifier|*
name|shstab
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|shstabsz
decl_stmt|;
comment|/* Find section header string table location and size. */
if|if
condition|(
name|elf_getshstab
argument_list|(
name|p
argument_list|,
name|filesize
argument_list|,
operator|&
name|shstab
argument_list|,
operator|&
name|shstabsz
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Find symbol table location and number of symbols. */
if|if
condition|(
name|elf_getsymtab
argument_list|(
name|p
argument_list|,
name|shstab
argument_list|,
name|shstabsz
argument_list|,
operator|&
name|symtab
argument_list|,
operator|&
name|nsymb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"symbol table not found"
argument_list|)
expr_stmt|;
comment|/* Find string table location and size. */
if|if
condition|(
name|elf_getsection
argument_list|(
name|p
argument_list|,
name|ELF_STRTAB
argument_list|,
name|shstab
argument_list|,
name|shstabsz
argument_list|,
operator|&
name|strtab
argument_list|,
operator|&
name|strtabsz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"string table not found"
argument_list|)
expr_stmt|;
comment|/* Find CTF section and dump it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eh
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|sh
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
operator|(
name|p
operator|+
name|eh
operator|->
name|e_shoff
operator|+
name|i
operator|*
name|eh
operator|->
name|e_shentsize
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sh
operator|->
name|sh_link
operator|>=
name|eh
operator|->
name|e_shnum
operator|)
operator|||
operator|(
name|sh
operator|->
name|sh_name
operator|>=
name|shstabsz
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|shstab
operator|+
name|sh
operator|->
name|sh_name
argument_list|,
name|ELF_CTF
argument_list|,
name|strlen
argument_list|(
name|ELF_CTF
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|isctf
argument_list|(
name|p
operator|+
name|sh
operator|->
name|sh_offset
argument_list|,
name|sh
operator|->
name|sh_size
argument_list|)
condition|)
break|break;
return|return
name|ctf_dump
argument_list|(
name|p
operator|+
name|sh
operator|->
name|sh_offset
argument_list|,
name|sh
operator|->
name|sh_size
argument_list|,
name|flags
argument_list|)
return|;
block|}
name|warnx
argument_list|(
literal|"%s section not found"
argument_list|,
name|ELF_CTF
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|isctf
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|filesize
parameter_list|)
block|{
name|struct
name|ctf_header
modifier|*
name|cth
init|=
operator|(
expr|struct
name|ctf_header
operator|*
operator|)
name|p
decl_stmt|;
name|size_t
name|dlen
decl_stmt|;
if|if
condition|(
name|filesize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_header
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"file too small to be CTF"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cth
operator|->
name|cth_magic
operator|!=
name|CTF_MAGIC
operator|||
name|cth
operator|->
name|cth_version
operator|!=
name|CTF_VERSION
condition|)
return|return
literal|0
return|;
name|dlen
operator|=
name|cth
operator|->
name|cth_stroff
operator|+
name|cth
operator|->
name|cth_strlen
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|filesize
operator|&&
operator|!
operator|(
name|cth
operator|->
name|cth_flags
operator|&
name|CTF_F_COMPRESS
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus file size"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|cth
operator|->
name|cth_lbloff
operator|&
literal|3
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_objtoff
operator|&
literal|1
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_funcoff
operator|&
literal|1
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_typeoff
operator|&
literal|3
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"wrongly aligned offset"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|cth
operator|->
name|cth_lbloff
operator|>=
name|dlen
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_objtoff
operator|>=
name|dlen
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_funcoff
operator|>=
name|dlen
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_typeoff
operator|>=
name|dlen
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"truncated file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|cth
operator|->
name|cth_lbloff
operator|>
name|cth
operator|->
name|cth_objtoff
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_objtoff
operator|>
name|cth
operator|->
name|cth_funcoff
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_funcoff
operator|>
name|cth
operator|->
name|cth_typeoff
operator|)
operator|||
operator|(
name|cth
operator|->
name|cth_typeoff
operator|>
name|cth
operator|->
name|cth_stroff
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"corrupted file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ctf_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|struct
name|ctf_header
modifier|*
name|cth
init|=
operator|(
expr|struct
name|ctf_header
operator|*
operator|)
name|p
decl_stmt|;
name|off_t
name|dlen
init|=
name|cth
operator|->
name|cth_stroff
operator|+
name|cth
operator|->
name|cth_strlen
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|cth
operator|->
name|cth_flags
operator|&
name|CTF_F_COMPRESS
condition|)
block|{
name|data
operator|=
name|decompress
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cth
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cth
argument_list|)
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DUMP_HEADER
condition|)
block|{
name|printf
argument_list|(
literal|"  cth_magic    = 0x%04x\n"
argument_list|,
name|cth
operator|->
name|cth_magic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_version  = %d\n"
argument_list|,
name|cth
operator|->
name|cth_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_flags    = 0x%02x\n"
argument_list|,
name|cth
operator|->
name|cth_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_parlabel = %s\n"
argument_list|,
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|cth
operator|->
name|cth_parname
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_parname  = %s\n"
argument_list|,
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|cth
operator|->
name|cth_parname
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_lbloff   = %d\n"
argument_list|,
name|cth
operator|->
name|cth_lbloff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_objtoff  = %d\n"
argument_list|,
name|cth
operator|->
name|cth_objtoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_funcoff  = %d\n"
argument_list|,
name|cth
operator|->
name|cth_funcoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_typeoff  = %d\n"
argument_list|,
name|cth
operator|->
name|cth_typeoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_stroff   = %d\n"
argument_list|,
name|cth
operator|->
name|cth_stroff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cth_strlen   = %d\n"
argument_list|,
name|cth
operator|->
name|cth_strlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DUMP_LABEL
condition|)
block|{
name|uint32_t
name|lbloff
init|=
name|cth
operator|->
name|cth_lbloff
decl_stmt|;
name|struct
name|ctf_lblent
modifier|*
name|ctl
decl_stmt|;
while|while
condition|(
name|lbloff
operator|<
name|cth
operator|->
name|cth_objtoff
condition|)
block|{
name|ctl
operator|=
operator|(
expr|struct
name|ctf_lblent
operator|*
operator|)
operator|(
name|data
operator|+
name|lbloff
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %5u %s\n"
argument_list|,
name|ctl
operator|->
name|ctl_typeidx
argument_list|,
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|ctl
operator|->
name|ctl_label
argument_list|)
argument_list|)
expr_stmt|;
name|lbloff
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ctl
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DUMP_OBJECT
condition|)
block|{
name|uint32_t
name|objtoff
init|=
name|cth
operator|->
name|cth_objtoff
decl_stmt|;
name|size_t
name|idx
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|uint16_t
modifier|*
name|dsp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
while|while
condition|(
name|objtoff
operator|<
name|cth
operator|->
name|cth_funcoff
condition|)
block|{
name|dsp
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|data
operator|+
name|objtoff
operator|)
expr_stmt|;
name|l
operator|=
name|printf
argument_list|(
literal|"  [%zu] %u"
argument_list|,
name|i
operator|++
argument_list|,
operator|*
name|dsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|elf_idx2sym
argument_list|(
operator|&
name|idx
argument_list|,
name|STT_OBJECT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%*s %s (%zu)\n"
argument_list|,
operator|(
literal|14
operator|-
name|l
operator|)
argument_list|,
literal|""
argument_list|,
name|s
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|objtoff
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|dsp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DUMP_FUNCTION
condition|)
block|{
name|uint16_t
modifier|*
name|fsp
decl_stmt|,
name|kind
decl_stmt|,
name|vlen
decl_stmt|;
name|size_t
name|idx
init|=
literal|0
decl_stmt|,
name|i
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
name|fsp
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|data
operator|+
name|cth
operator|->
name|cth_funcoff
operator|)
expr_stmt|;
while|while
condition|(
name|fsp
operator|<
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|data
operator|+
name|cth
operator|->
name|cth_typeoff
operator|)
condition|)
block|{
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
operator|*
name|fsp
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
operator|*
name|fsp
argument_list|)
expr_stmt|;
name|s
operator|=
name|elf_idx2sym
argument_list|(
operator|&
name|idx
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|fsp
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|vlen
operator|==
literal|0
condition|)
continue|continue;
name|l
operator|=
name|printf
argument_list|(
literal|"  [%zu] FUNC "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" returns: %u args: ("
argument_list|,
operator|*
name|fsp
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|vlen
operator|--
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%u%s"
argument_list|,
operator|*
name|fsp
operator|++
argument_list|,
operator|(
name|vlen
operator|>
literal|0
operator|)
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DUMP_TYPE
condition|)
block|{
name|uint32_t
name|idx
init|=
literal|1
decl_stmt|,
name|offset
init|=
name|cth
operator|->
name|cth_typeoff
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|cth
operator|->
name|cth_stroff
condition|)
block|{
name|offset
operator|+=
name|ctf_dump_type
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|offset
argument_list|,
name|idx
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DUMP_STRTAB
condition|)
block|{
name|uint32_t
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|cth
operator|->
name|cth_strlen
condition|)
block|{
name|str
operator|=
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  [%u] "
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"(anon)"
argument_list|)
condition|)
name|offset
operator|+=
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\\0\n"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cth
operator|->
name|cth_flags
operator|&
name|CTF_F_COMPRESS
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint32_t
name|ctf_dump_type
parameter_list|(
name|struct
name|ctf_header
modifier|*
name|cth
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|off_t
name|dlen
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|idx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|data
operator|+
name|offset
decl_stmt|;
specifier|const
name|struct
name|ctf_type
modifier|*
name|ctt
init|=
operator|(
expr|struct
name|ctf_type
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|struct
name|ctf_array
modifier|*
name|cta
decl_stmt|;
name|uint16_t
modifier|*
name|argp
decl_stmt|,
name|i
decl_stmt|,
name|kind
decl_stmt|,
name|vlen
decl_stmt|,
name|root
decl_stmt|;
name|uint32_t
name|eob
decl_stmt|,
name|toff
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|kname
decl_stmt|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|root
operator|=
name|CTF_INFO_ISROOT
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|name
operator|=
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|ctt
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
condition|)
name|printf
argument_list|(
literal|"<%u> "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  [%u] "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kname
operator|=
name|ctf_kind2name
argument_list|(
name|kind
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s %s"
argument_list|,
name|kname
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctt
operator|->
name|ctt_size
operator|<=
name|CTF_MAX_SIZE
condition|)
block|{
name|size
operator|=
name|ctt
operator|->
name|ctt_size
expr_stmt|;
name|toff
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_stype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|CTF_TYPE_LSIZE
argument_list|(
name|ctt
argument_list|)
expr_stmt|;
name|toff
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_type
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_UNKNOWN
case|:
case|case
name|CTF_K_FORWARD
case|:
break|break;
case|case
name|CTF_K_INTEGER
case|:
name|eob
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
operator|)
expr_stmt|;
name|toff
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" encoding=%s offset=%u bits=%u"
argument_list|,
name|ctf_enc2name
argument_list|(
name|CTF_INT_ENCODING
argument_list|(
name|eob
argument_list|)
argument_list|)
argument_list|,
name|CTF_INT_OFFSET
argument_list|(
name|eob
argument_list|)
argument_list|,
name|CTF_INT_BITS
argument_list|(
name|eob
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FLOAT
case|:
name|eob
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
operator|)
expr_stmt|;
name|toff
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" encoding=0x%x offset=%u bits=%u"
argument_list|,
name|CTF_FP_ENCODING
argument_list|(
name|eob
argument_list|)
argument_list|,
name|CTF_FP_OFFSET
argument_list|(
name|eob
argument_list|)
argument_list|,
name|CTF_FP_BITS
argument_list|(
name|eob
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|cta
operator|=
operator|(
expr|struct
name|ctf_array
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" content: %u index: %u nelems: %u\n"
argument_list|,
name|cta
operator|->
name|cta_contents
argument_list|,
name|cta
operator|->
name|cta_index
argument_list|,
name|cta
operator|->
name|cta_nelems
argument_list|)
expr_stmt|;
name|toff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_array
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|argp
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" returns: %u args: (%u"
argument_list|,
name|ctt
operator|->
name|ctt_type
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
name|argp
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|", %u"
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|toff
operator|+=
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
name|printf
argument_list|(
literal|" (%lu bytes)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctf_member
modifier|*
name|ctm
decl_stmt|;
name|ctm
operator|=
operator|(
expr|struct
name|ctf_member
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
expr_stmt|;
name|toff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_member
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s type=%u off=%u\n"
argument_list|,
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|ctm
operator|->
name|ctm_name
argument_list|)
argument_list|,
name|ctm
operator|->
name|ctm_type
argument_list|,
name|ctm
operator|->
name|ctm_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctf_lmember
modifier|*
name|ctlm
decl_stmt|;
name|ctlm
operator|=
operator|(
expr|struct
name|ctf_lmember
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
expr_stmt|;
name|toff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_lmember
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s type=%u off=%zu\n"
argument_list|,
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|ctlm
operator|->
name|ctlm_name
argument_list|)
argument_list|,
name|ctlm
operator|->
name|ctlm_type
argument_list|,
name|CTF_LMEM_OFFSET
argument_list|(
name|ctlm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ctf_enum
modifier|*
name|cte
decl_stmt|;
name|cte
operator|=
operator|(
expr|struct
name|ctf_enum
operator|*
operator|)
operator|(
name|p
operator|+
name|toff
operator|)
expr_stmt|;
name|toff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ctf_enum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s = %d\n"
argument_list|,
name|ctf_off2name
argument_list|(
name|cth
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|cte
operator|->
name|cte_name
argument_list|)
argument_list|,
name|cte
operator|->
name|cte_value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|printf
argument_list|(
literal|" refers to %u"
argument_list|,
name|ctt
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"incorrect type %u at offset %u"
argument_list|,
name|kind
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|toff
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ctf_kind2name
parameter_list|(
name|uint16_t
name|kind
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|kind_name
index|[]
init|=
block|{
name|NULL
block|,
literal|"INTEGER"
block|,
literal|"FLOAT"
block|,
literal|"POINTER"
block|,
literal|"ARRAY"
block|,
literal|"FUNCTION"
block|,
literal|"STRUCT"
block|,
literal|"UNION"
block|,
literal|"ENUM"
block|,
literal|"FORWARD"
block|,
literal|"TYPEDEF"
block|,
literal|"VOLATILE"
block|,
literal|"CONST"
block|,
literal|"RESTRICT"
block|}
decl_stmt|;
if|if
condition|(
name|kind
operator|>=
name|nitems
argument_list|(
name|kind_name
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|kind_name
index|[
name|kind
index|]
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ctf_enc2name
parameter_list|(
name|uint16_t
name|enc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|enc_name
index|[]
init|=
block|{
literal|"SIGNED"
block|,
literal|"CHAR"
block|,
literal|"SIGNED CHAR"
block|,
literal|"BOOL"
block|,
literal|"SIGNED BOOL"
block|}
decl_stmt|;
specifier|static
name|char
name|invalid
index|[
literal|7
index|]
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|CTF_INT_VARARGS
condition|)
return|return
literal|"VARARGS"
return|;
if|if
condition|(
name|enc
operator|>
literal|0
operator|&&
name|enc
operator|<
name|nitems
argument_list|(
name|enc_name
argument_list|)
condition|)
return|return
name|enc_name
index|[
name|enc
operator|-
literal|1
index|]
return|;
name|snprintf
argument_list|(
name|invalid
argument_list|,
sizeof|sizeof
argument_list|(
name|invalid
argument_list|)
argument_list|,
literal|"0x%x"
argument_list|,
name|enc
argument_list|)
expr_stmt|;
return|return
name|invalid
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ctf_off2name
parameter_list|(
name|struct
name|ctf_header
modifier|*
name|cth
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|off_t
name|dlen
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|CTF_NAME_STID
argument_list|(
name|offset
argument_list|)
operator|!=
name|CTF_STRTAB_0
condition|)
return|return
literal|"external"
return|;
if|if
condition|(
name|CTF_NAME_OFFSET
argument_list|(
name|offset
argument_list|)
operator|>=
name|cth
operator|->
name|cth_strlen
condition|)
return|return
literal|"exceeds strlab"
return|;
if|if
condition|(
name|cth
operator|->
name|cth_stroff
operator|+
name|CTF_NAME_OFFSET
argument_list|(
name|offset
argument_list|)
operator|>=
name|dlen
condition|)
return|return
literal|"invalid"
return|;
name|name
operator|=
name|data
operator|+
name|cth
operator|->
name|cth_stroff
operator|+
name|CTF_NAME_OFFSET
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return
literal|"(anon)"
return|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|decompress
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZLIB
name|z_stream
name|stream
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|data
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|size
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|data
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"zlib inflateInit failed: %s"
argument_list|,
name|zError
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|)
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|warnx
argument_list|(
literal|"zlib inflate failed: %s"
argument_list|,
name|zError
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"zlib inflateEnd failed: %s"
argument_list|,
name|zError
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|stream
operator|.
name|total_out
operator|!=
name|len
condition|)
block|{
name|warnx
argument_list|(
literal|"decompression failed: %zu != %zu"
argument_list|,
name|stream
operator|.
name|total_out
argument_list|,
name|len
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
return|return
name|data
return|;
name|exit
label|:
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZLIB */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|__dead2
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-dfhlst] file ...\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

