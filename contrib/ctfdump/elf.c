begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016 Martin Pieuchot<mpi@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/reloc.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|ELF_SYMTAB
value|".symtab"
end_define

begin_define
define|#
directive|define
name|Elf_RelA
value|__CONCAT(__CONCAT(Elf,__ELF_WORD_SIZE),_Rela)
end_define

begin_function_decl
specifier|static
name|int
name|elf_reloc_size
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_reloc_apply
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|ssize_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|iself
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|filesize
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|eh
init|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|filesize
operator|<
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"file too small to be ELF"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_ehsize
operator|<
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|||
operator|!
name|IS_ELF
argument_list|(
operator|*
name|eh
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|eh
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_CLASS
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected word size %u"
argument_list|,
name|eh
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|ELF_TARG_VER
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected version %u"
argument_list|,
name|eh
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|>
name|ELFDATA2MSB
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected data format %u"
argument_list|,
name|eh
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_shoff
operator|>
name|filesize
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus section table offset 0x%lx"
argument_list|,
operator|(
name|off_t
operator|)
name|eh
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_shentsize
operator|<
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus section header size %u"
argument_list|,
name|eh
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_shnum
operator|>
operator|(
name|filesize
operator|-
name|eh
operator|->
name|e_shoff
operator|)
operator|/
name|eh
operator|->
name|e_shentsize
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus section header count %u"
argument_list|,
name|eh
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|e_shstrndx
operator|>=
name|eh
operator|->
name|e_shnum
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus string table index %u"
argument_list|,
name|eh
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|elf_getshstab
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|filesize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|shstab
parameter_list|,
name|size_t
modifier|*
name|shstabsize
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|eh
init|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|p
decl_stmt|;
name|Elf_Shdr
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
operator|(
name|p
operator|+
name|eh
operator|->
name|e_shoff
operator|+
name|eh
operator|->
name|e_shstrndx
operator|*
name|eh
operator|->
name|e_shentsize
operator|)
expr_stmt|;
if|if
condition|(
name|sh
operator|->
name|sh_type
operator|!=
name|SHT_STRTAB
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected string table type"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sh
operator|->
name|sh_offset
operator|>
name|filesize
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus string table offset"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sh
operator|->
name|sh_size
operator|>
name|filesize
operator|-
name|sh
operator|->
name|sh_offset
condition|)
block|{
name|warnx
argument_list|(
literal|"bogus string table size"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|shstab
operator|!=
name|NULL
condition|)
operator|*
name|shstab
operator|=
name|p
operator|+
name|sh
operator|->
name|sh_offset
expr_stmt|;
if|if
condition|(
name|shstabsize
operator|!=
name|NULL
condition|)
operator|*
name|shstabsize
operator|=
name|sh
operator|->
name|sh_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|ssize_t
name|elf_getsymtab
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|shstab
parameter_list|,
name|size_t
name|shstabsz
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
modifier|*
name|symtab
parameter_list|,
name|size_t
modifier|*
name|nsymb
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|eh
init|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|p
decl_stmt|;
name|Elf_Shdr
modifier|*
name|sh
decl_stmt|;
name|size_t
name|snlen
decl_stmt|;
name|ssize_t
name|i
decl_stmt|;
name|snlen
operator|=
name|strlen
argument_list|(
name|ELF_SYMTAB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eh
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|sh
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
operator|(
name|p
operator|+
name|eh
operator|->
name|e_shoff
operator|+
name|i
operator|*
name|eh
operator|->
name|e_shentsize
operator|)
expr_stmt|;
if|if
condition|(
name|sh
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sh
operator|->
name|sh_link
operator|>=
name|eh
operator|->
name|e_shnum
operator|)
operator|||
operator|(
name|sh
operator|->
name|sh_name
operator|>=
name|shstabsz
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|shstab
operator|+
name|sh
operator|->
name|sh_name
argument_list|,
name|ELF_SYMTAB
argument_list|,
name|snlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
operator|(
name|p
operator|+
name|sh
operator|->
name|sh_offset
operator|)
expr_stmt|;
if|if
condition|(
name|nsymb
operator|!=
name|NULL
condition|)
operator|*
name|nsymb
operator|=
operator|(
name|sh
operator|->
name|sh_size
operator|/
name|sh
operator|->
name|sh_entsize
operator|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|ssize_t
name|elf_getsection
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|sname
parameter_list|,
specifier|const
name|char
modifier|*
name|shstab
parameter_list|,
name|size_t
name|shstabsz
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|psdata
parameter_list|,
name|size_t
modifier|*
name|pssz
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|eh
init|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|p
decl_stmt|;
name|Elf_Shdr
modifier|*
name|sh
decl_stmt|;
name|char
modifier|*
name|sdata
init|=
name|NULL
decl_stmt|;
name|size_t
name|snlen
decl_stmt|,
name|ssz
init|=
literal|0
decl_stmt|;
name|ssize_t
name|sidx
decl_stmt|,
name|i
decl_stmt|;
name|snlen
operator|=
name|strlen
argument_list|(
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|snlen
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Find the given section. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eh
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|sh
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
operator|(
name|p
operator|+
name|eh
operator|->
name|e_shoff
operator|+
name|i
operator|*
name|eh
operator|->
name|e_shentsize
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sh
operator|->
name|sh_link
operator|>=
name|eh
operator|->
name|e_shnum
operator|)
operator|||
operator|(
name|sh
operator|->
name|sh_name
operator|>=
name|shstabsz
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|shstab
operator|+
name|sh
operator|->
name|sh_name
argument_list|,
name|sname
argument_list|,
name|snlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sidx
operator|=
name|i
expr_stmt|;
name|sdata
operator|=
name|p
operator|+
name|sh
operator|->
name|sh_offset
expr_stmt|;
name|ssz
operator|=
name|sh
operator|->
name|sh_size
expr_stmt|;
name|elf_reloc_apply
argument_list|(
name|p
argument_list|,
name|shstab
argument_list|,
name|shstabsz
argument_list|,
name|sidx
argument_list|,
name|sdata
argument_list|,
name|ssz
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|psdata
operator|!=
name|NULL
condition|)
operator|*
name|psdata
operator|=
name|sdata
expr_stmt|;
if|if
condition|(
name|pssz
operator|!=
name|NULL
condition|)
operator|*
name|pssz
operator|=
name|ssz
expr_stmt|;
return|return
name|sidx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_reloc_size
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|R_X86_64_64
case|case
name|R_X86_64_64
case|:
return|return
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|R_X86_64_32
case|case
name|R_X86_64_32
case|:
return|return
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RELOC_32
case|case
name|RELOC_32
case|:
return|return
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_WRITE_RELOC
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|rsize
parameter_list|)
define|\
value|do {									\ 	if (rsize == 4) {						\ 		uint32_t v32 = val;					\ 		memcpy(buf,&v32, sizeof(v32));				\ 	} else {							\ 		uint64_t v64 = val;					\ 		memcpy(buf,&v64, sizeof(v64));				\ 	}								\ } while (0)
end_define

begin_function
specifier|static
name|void
name|elf_reloc_apply
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|shstab
parameter_list|,
name|size_t
name|shstabsz
parameter_list|,
name|ssize_t
name|sidx
parameter_list|,
name|char
modifier|*
name|sdata
parameter_list|,
name|size_t
name|ssz
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|eh
init|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|p
decl_stmt|;
name|Elf_Shdr
modifier|*
name|sh
decl_stmt|;
name|Elf_Rel
modifier|*
name|rel
init|=
name|NULL
decl_stmt|;
name|Elf_RelA
modifier|*
name|rela
init|=
name|NULL
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|ssize_t
name|symtabidx
decl_stmt|;
name|size_t
name|nsymb
decl_stmt|,
name|rsym
decl_stmt|,
name|rtyp
decl_stmt|,
name|roff
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|int
name|rsize
decl_stmt|;
comment|/* Find symbol table location and number of symbols. */
name|symtabidx
operator|=
name|elf_getsymtab
argument_list|(
name|p
argument_list|,
name|shstab
argument_list|,
name|shstabsz
argument_list|,
operator|&
name|symtab
argument_list|,
operator|&
name|nsymb
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtabidx
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"symbol table not found"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Apply possible relocation. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eh
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|sh
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
operator|(
name|p
operator|+
name|eh
operator|->
name|e_shoff
operator|+
name|i
operator|*
name|eh
operator|->
name|e_shentsize
operator|)
expr_stmt|;
if|if
condition|(
name|sh
operator|->
name|sh_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sh
operator|->
name|sh_info
operator|!=
name|sidx
operator|)
operator|||
operator|(
name|sh
operator|->
name|sh_link
operator|!=
name|symtabidx
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|sh
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_RELA
case|:
name|rela
operator|=
operator|(
name|Elf_RelA
operator|*
operator|)
operator|(
name|p
operator|+
name|sh
operator|->
name|sh_offset
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|sh
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_RelA
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|rsym
operator|=
name|ELF_R_SYM
argument_list|(
name|rela
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|rtyp
operator|=
name|ELF_R_TYPE
argument_list|(
name|rela
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|roff
operator|=
name|rela
index|[
name|j
index|]
operator|.
name|r_offset
expr_stmt|;
if|if
condition|(
name|rsym
operator|>=
name|nsymb
condition|)
continue|continue;
name|sym
operator|=
operator|&
name|symtab
index|[
name|rsym
index|]
expr_stmt|;
name|value
operator|=
name|sym
operator|->
name|st_value
operator|+
name|rela
index|[
name|j
index|]
operator|.
name|r_addend
expr_stmt|;
name|rsize
operator|=
name|elf_reloc_size
argument_list|(
name|rtyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|==
operator|-
literal|1
operator|||
name|roff
operator|+
name|rsize
operator|>=
name|ssz
condition|)
continue|continue;
name|ELF_WRITE_RELOC
argument_list|(
name|sdata
operator|+
name|roff
argument_list|,
name|value
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_REL
case|:
name|rel
operator|=
operator|(
name|Elf_Rel
operator|*
operator|)
operator|(
name|p
operator|+
name|sh
operator|->
name|sh_offset
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|sh
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Rel
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|rsym
operator|=
name|ELF_R_SYM
argument_list|(
name|rel
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|rtyp
operator|=
name|ELF_R_TYPE
argument_list|(
name|rel
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|roff
operator|=
name|rel
index|[
name|j
index|]
operator|.
name|r_offset
expr_stmt|;
if|if
condition|(
name|rsym
operator|>=
name|nsymb
condition|)
continue|continue;
name|sym
operator|=
operator|&
name|symtab
index|[
name|rsym
index|]
expr_stmt|;
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|rsize
operator|=
name|elf_reloc_size
argument_list|(
name|rtyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|==
operator|-
literal|1
operator|||
name|roff
operator|+
name|rsize
operator|>=
name|ssz
condition|)
continue|continue;
name|ELF_WRITE_RELOC
argument_list|(
name|sdata
operator|+
name|roff
argument_list|,
name|value
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
continue|continue;
block|}
block|}
block|}
end_function

end_unit

