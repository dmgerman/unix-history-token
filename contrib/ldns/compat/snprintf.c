begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SNPRINTF
end_ifndef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Define this as a fall through, HAVE_STDARG_H is probably already set */
end_comment

begin_define
define|#
directive|define
name|HAVE_VARARGS_H
end_define

begin_comment
comment|/**************************************************************  * Original:  * Patrick Powell Tue Apr 11 09:48:21 PDT 1995  * A bombproof version of doprnt (dopr) included.  * Sigh.  This sort of thing is always nasty do deal with.  Note that  * the version here does not include floating point...  *  * snprintf() is used instead of sprintf() as it does limit checks  * for string length.  This covers a nasty loophole.  *  * The other functions are there to prevent NULL pointers from  * causing nast effects.  *  * More Recently:  *  Brandon Long (blong@fiction.net) 9/15/96 for mutt 0.43  *  This was ugly.  It is still ugly.  I opted out of floating point  *  numbers, but the formatter understands just about everything  *  from the normal C string format, at least as far as I can tell from  *  the Solaris 2.5 printf(3S) man page.  *  *  Brandon Long (blong@fiction.net) 10/22/97 for mutt 0.87.1  *    Ok, added some minimal floating point support, which means this  *    probably requires libm on most operating systems.  Don't yet  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()  *    was pretty badly broken, it just wasn't being exercised in ways  *    which showed it, so that's been fixed.  Also, formated the code  *    to mutt conventions, and removed dead code left over from the  *    original.  Also, there is now a builtin-test, just compile with:  *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm  *    and run snprintf for results.  *  **************************************************************/
end_comment

begin_comment
comment|/* varargs declarations: */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDARG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|HAVE_STDARGS
end_define

begin_comment
comment|/* let's hope that works everywhere (mj) */
end_comment

begin_define
define|#
directive|define
name|VA_LOCAL_DECL
value|va_list ap
end_define

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|f
parameter_list|)
value|va_start(ap, f)
end_define

begin_define
define|#
directive|define
name|VA_SHIFT
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
value|;
end_define

begin_comment
comment|/* no-op for ANSI */
end_comment

begin_define
define|#
directive|define
name|VA_END
value|va_end(ap)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_undef
undef|#
directive|undef
name|HAVE_STDARGS
end_undef

begin_define
define|#
directive|define
name|VA_LOCAL_DECL
value|va_list ap
end_define

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|f
parameter_list|)
value|va_start(ap)
end_define

begin_comment
comment|/* f is ignored! */
end_comment

begin_define
define|#
directive|define
name|VA_SHIFT
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
value|v = va_arg(ap,t)
end_define

begin_define
define|#
directive|define
name|VA_END
value|va_end(ap)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*XX ** NO VARARGS ** XX*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|snprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|double
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopr_outch
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dopr
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS3 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDARGS
end_ifdef

begin_decl_stmt
name|int
name|snprintf
argument_list|(
name|char
operator|*
name|str
argument_list|,
name|size_t
name|count
argument_list|,
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|int
name|snprintf
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|HAVE_STDARGS
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
name|VA_LOCAL_DECL
expr_stmt|;
name|VA_START
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|str
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|count
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|fmt
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
return|return
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * dopr(): poor man's version of doprintf  */
end_comment

begin_comment
comment|/* format read states */
end_comment

begin_define
define|#
directive|define
name|DP_S_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|DP_S_FLAGS
value|1
end_define

begin_define
define|#
directive|define
name|DP_S_MIN
value|2
end_define

begin_define
define|#
directive|define
name|DP_S_DOT
value|3
end_define

begin_define
define|#
directive|define
name|DP_S_MAX
value|4
end_define

begin_define
define|#
directive|define
name|DP_S_MOD
value|5
end_define

begin_define
define|#
directive|define
name|DP_S_CONV
value|6
end_define

begin_define
define|#
directive|define
name|DP_S_DONE
value|7
end_define

begin_comment
comment|/* format flags - Bits */
end_comment

begin_define
define|#
directive|define
name|DP_F_MINUS
value|1
end_define

begin_define
define|#
directive|define
name|DP_F_PLUS
value|2
end_define

begin_define
define|#
directive|define
name|DP_F_SPACE
value|4
end_define

begin_define
define|#
directive|define
name|DP_F_NUM
value|8
end_define

begin_define
define|#
directive|define
name|DP_F_ZERO
value|16
end_define

begin_define
define|#
directive|define
name|DP_F_UP
value|32
end_define

begin_comment
comment|/* Conversion Flags */
end_comment

begin_define
define|#
directive|define
name|DP_C_SHORT
value|1
end_define

begin_define
define|#
directive|define
name|DP_C_LONG
value|2
end_define

begin_define
define|#
directive|define
name|DP_C_LDOUBLE
value|3
end_define

begin_define
define|#
directive|define
name|char_to_int
parameter_list|(
name|p
parameter_list|)
value|(p - '0')
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
value|((p>= q) ? p : q)
end_define

begin_function
specifier|static
name|void
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|long
name|value
decl_stmt|;
name|long
name|double
name|fvalue
decl_stmt|;
name|char
modifier|*
name|strvalue
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|cflags
decl_stmt|;
name|size_t
name|currlen
decl_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|currlen
operator|=
name|flags
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|DP_S_DONE
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|currlen
operator|>=
name|maxlen
operator|)
condition|)
name|state
operator|=
name|DP_S_DONE
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DP_S_DEFAULT
case|:
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
name|state
operator|=
name|DP_S_FLAGS
expr_stmt|;
else|else
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
name|DP_S_FLAGS
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|flags
operator||=
name|DP_F_MINUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|flags
operator||=
name|DP_F_PLUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flags
operator||=
name|DP_F_SPACE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|flags
operator||=
name|DP_F_NUM
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|flags
operator||=
name|DP_F_ZERO
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|DP_S_MIN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DP_S_MIN
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|ch
argument_list|)
condition|)
block|{
name|min
operator|=
literal|10
operator|*
name|min
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|min
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
break|break;
case|case
name|DP_S_DOT
case|:
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|state
operator|=
name|DP_S_MAX
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
break|break;
case|case
name|DP_S_MAX
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|10
operator|*
name|max
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|max
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
break|break;
case|case
name|DP_S_MOD
case|:
comment|/* Currently, we don't support Long Long, bummer */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|cflags
operator|=
name|DP_C_SHORT
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|cflags
operator|=
name|DP_C_LONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cflags
operator|=
name|DP_C_LDOUBLE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|state
operator|=
name|DP_S_CONV
expr_stmt|;
break|break;
case|case
name|DP_S_CONV
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|flags
operator|&=
operator|~
name|DP_F_PLUS
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|8
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|flags
operator|&=
operator|~
name|DP_F_PLUS
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'x'
case|:
name|flags
operator|&=
operator|~
name|DP_F_PLUS
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/* um, floating point? */
name|fmtfp
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'e'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'g'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
name|maxlen
expr_stmt|;
comment|/* ie, no max */
name|fmtstr
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|strvalue
argument_list|,
name|flags
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|(
name|long
operator|)
name|strvalue
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
block|{
name|short
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|short int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
block|{
name|long
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
else|else
block|{
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* not supported yet, treat as next char */
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Unknown, skip */
break|break;
block|}
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|flags
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|DP_S_DONE
case|:
break|break;
default|default:
comment|/* hmm? */
break|break;
comment|/* some picky compilers need this */
block|}
block|}
if|if
condition|(
name|currlen
operator|<
name|maxlen
operator|-
literal|1
condition|)
name|buffer
index|[
name|currlen
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|buffer
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|padlen
decl_stmt|,
name|strln
decl_stmt|;
comment|/* amount to pad */
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
operator|(
name|char
operator|*
operator|)
literal|"<NULL>"
expr_stmt|;
block|}
for|for
control|(
name|strln
operator|=
literal|0
init|;
name|value
index|[
name|strln
index|]
condition|;
operator|++
name|strln
control|)
empty_stmt|;
comment|/* strlen */
name|padlen
operator|=
name|min
operator|-
name|strln
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justify */
while|while
condition|(
operator|(
name|padlen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|*
name|value
operator|++
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|padlen
operator|<
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
end_comment

begin_function
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signvalue
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|uvalue
decl_stmt|;
name|char
name|convert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|place
init|=
literal|0
decl_stmt|;
name|int
name|spadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to space pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to zero pad */
name|int
name|caps
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|uvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|signvalue
operator|=
literal|'-'
expr_stmt|;
name|uvalue
operator|=
operator|-
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_UP
condition|)
name|caps
operator|=
literal|1
expr_stmt|;
comment|/* Should characters be upper case? */
do|do
block|{
name|convert
index|[
name|place
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|uvalue
operator|%
operator|(
name|unsigned
operator|)
name|base
index|]
expr_stmt|;
name|uvalue
operator|=
operator|(
name|uvalue
operator|/
operator|(
name|unsigned
operator|)
name|base
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|uvalue
operator|&&
operator|(
name|place
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|place
operator|==
literal|20
condition|)
name|place
operator|--
expr_stmt|;
name|convert
index|[
name|place
index|]
operator|=
literal|0
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|place
expr_stmt|;
name|spadlen
operator|=
name|min
operator|-
name|MAX
argument_list|(
name|max
argument_list|,
name|place
argument_list|)
operator|-
operator|(
name|signvalue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spadlen
operator|<
literal|0
condition|)
name|spadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_ZERO
condition|)
block|{
name|zpadlen
operator|=
name|MAX
argument_list|(
name|zpadlen
argument_list|,
name|spadlen
argument_list|)
expr_stmt|;
name|spadlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|spadlen
operator|=
operator|-
name|spadlen
expr_stmt|;
comment|/* Left Justifty */
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|dprint
argument_list|(
literal|1
argument_list|,
operator|(
name|debugfile
operator|,
literal|"zpad: %d, spad: %d, min: %d, max: %d, place: %d\n"
operator|,
name|zpadlen
operator|,
name|spadlen
operator|,
name|min
operator|,
name|max
operator|,
name|place
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Spaces */
while|while
condition|(
name|spadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|spadlen
expr_stmt|;
block|}
comment|/* Sign */
if|if
condition|(
name|signvalue
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
comment|/* Zeros */
if|if
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
block|}
comment|/* Digits */
while|while
condition|(
name|place
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|convert
index|[
operator|--
name|place
index|]
argument_list|)
expr_stmt|;
comment|/* Left Justified spaces */
while|while
condition|(
name|spadlen
operator|<
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|spadlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|abs_val
parameter_list|(
name|long
name|double
name|value
parameter_list|)
block|{
name|long
name|double
name|result
init|=
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|value
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|pow10
parameter_list|(
name|double
name|exp
parameter_list|)
block|{
name|long
name|double
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|exp
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|round
parameter_list|(
name|double
name|value
parameter_list|)
block|{
name|long
name|intpart
decl_stmt|;
name|intpart
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|value
operator|-
name|intpart
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.5
condition|)
name|intpart
operator|++
expr_stmt|;
return|return
name|intpart
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|double
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signvalue
init|=
literal|0
decl_stmt|;
name|long
name|double
name|ufvalue
decl_stmt|;
name|char
name|iconvert
index|[
literal|20
index|]
decl_stmt|;
name|char
name|fconvert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|iplace
init|=
literal|0
decl_stmt|;
name|int
name|fplace
init|=
literal|0
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
comment|/* amount to pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
name|int
name|caps
init|=
literal|0
decl_stmt|;
name|long
name|intpart
decl_stmt|;
name|long
name|fracpart
decl_stmt|;
comment|/*     * AIX manpage says the default is 0, but Solaris says the default    * is 6, and sprintf on AIX defaults to 6    */
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|6
expr_stmt|;
name|ufvalue
operator|=
name|abs_val
argument_list|(
name|fvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvalue
operator|<
literal|0
condition|)
name|signvalue
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
if|#
directive|if
literal|0
block|if (flags& DP_F_UP) caps = 1;
comment|/* Should characters be upper case? */
endif|#
directive|endif
name|intpart
operator|=
name|ufvalue
expr_stmt|;
comment|/*     * Sorry, we only support 9 digits past the decimal because of our     * conversion method    */
if|if
condition|(
name|max
operator|>
literal|9
condition|)
name|max
operator|=
literal|9
expr_stmt|;
comment|/* We "cheat" by converting the fractional part to integer by    * multiplying by a factor of 10    */
name|fracpart
operator|=
name|round
argument_list|(
operator|(
name|pow10
argument_list|(
name|max
argument_list|)
operator|)
operator|*
operator|(
name|ufvalue
operator|-
name|intpart
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracpart
operator|>=
name|pow10
argument_list|(
name|max
argument_list|)
condition|)
block|{
name|intpart
operator|++
expr_stmt|;
name|fracpart
operator|-=
name|pow10
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|dprint
argument_list|(
literal|1
argument_list|,
operator|(
name|debugfile
operator|,
literal|"fmtfp: %f =? %d.%d\n"
operator|,
name|fvalue
operator|,
name|intpart
operator|,
name|fracpart
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert integer part */
do|do
block|{
name|iconvert
index|[
name|iplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|intpart
operator|%
literal|10
index|]
expr_stmt|;
name|intpart
operator|=
operator|(
name|intpart
operator|/
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|intpart
operator|&&
operator|(
name|iplace
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|iplace
operator|==
literal|20
condition|)
name|iplace
operator|--
expr_stmt|;
name|iconvert
index|[
name|iplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Convert fractional part */
do|do
block|{
name|fconvert
index|[
name|fplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|fracpart
operator|%
literal|10
index|]
expr_stmt|;
name|fracpart
operator|=
operator|(
name|fracpart
operator|/
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|fracpart
operator|&&
operator|(
name|fplace
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|fplace
operator|==
literal|20
condition|)
name|fplace
operator|--
expr_stmt|;
name|fconvert
index|[
name|fplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* -1 for decimal point, another -1 if we are printing a sign */
name|padlen
operator|=
name|min
operator|-
name|iplace
operator|-
name|max
operator|-
literal|1
operator|-
operator|(
operator|(
name|signvalue
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|fplace
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justifty */
if|if
condition|(
operator|(
name|flags
operator|&
name|DP_F_ZERO
operator|)
operator|&&
operator|(
name|padlen
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|signvalue
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
name|signvalue
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
if|if
condition|(
name|signvalue
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
while|while
condition|(
name|iplace
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|iconvert
index|[
operator|--
name|iplace
index|]
argument_list|)
expr_stmt|;
comment|/*    * Decimal point.  This should probably use locale to find the correct    * char to print out.    */
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
while|while
condition|(
name|fplace
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fconvert
index|[
operator|--
name|fplace
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dopr_outch
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|*
name|currlen
operator|<
name|maxlen
condition|)
name|buffer
index|[
operator|(
operator|*
name|currlen
operator|)
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_SNPRINTF
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_STRING
end_ifndef

begin_define
define|#
directive|define
name|LONG_STRING
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf1
index|[
name|LONG_STRING
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|LONG_STRING
index|]
decl_stmt|;
name|char
modifier|*
name|fp_fmt
index|[]
init|=
block|{
literal|"%-1.5f"
block|,
literal|"%1.5f"
block|,
literal|"%123.9f"
block|,
literal|"%10.5f"
block|,
literal|"% 10.5f"
block|,
literal|"%+22.9f"
block|,
literal|"%+4.9f"
block|,
literal|"%01.3f"
block|,
literal|"%4f"
block|,
literal|"%3.1f"
block|,
literal|"%3.2f"
block|,
name|NULL
block|}
decl_stmt|;
name|double
name|fp_nums
index|[]
init|=
block|{
operator|-
literal|1.5
block|,
literal|134.21
block|,
literal|91340.2
block|,
literal|341.1234
block|,
literal|0203.9
block|,
literal|0.96
block|,
literal|0.996
block|,
literal|0.9996
block|,
literal|1.996
block|,
literal|4.136
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|int_fmt
index|[]
init|=
block|{
literal|"%-1.5d"
block|,
literal|"%1.5d"
block|,
literal|"%123.9d"
block|,
literal|"%5.5d"
block|,
literal|"%10.5d"
block|,
literal|"% 10.5d"
block|,
literal|"%+22.33d"
block|,
literal|"%01.3d"
block|,
literal|"%4d"
block|,
name|NULL
block|}
decl_stmt|;
name|long
name|int_nums
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|134
block|,
literal|91340
block|,
literal|341
block|,
literal|0203
block|,
literal|0
block|}
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"Testing snprintf format codes against system sprintf...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|fp_fmt
index|[
name|x
index|]
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|fp_nums
index|[
name|y
index|]
operator|!=
literal|0
condition|;
name|y
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|,
name|fp_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|,
name|fp_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"snprintf doesn't match Format: %s\n\tsnprintf = %s\n\tsprintf  = %s\n"
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|int_fmt
index|[
name|x
index|]
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|int_nums
index|[
name|y
index|]
operator|!=
literal|0
condition|;
name|y
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|,
name|int_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|,
name|int_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"snprintf doesn't match Format: %s\n\tsnprintf = %s\n\tsprintf  = %s\n"
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d tests failed out of %d.\n"
argument_list|,
name|fail
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNPRINTF_TEST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SNPRINTF */
end_comment

end_unit

