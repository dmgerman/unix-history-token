begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, 1998 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_B32_NTOP
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ldns/util.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Base32
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyz234567"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";*/
end_comment

begin_comment
comment|/*       00000000001111111111222222222233          01234567890123456789012345678901*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Base32_extended_hex
index|[]
init|=
comment|/*	"0123456789ABCDEFGHIJKLMNOPQRSTUV";*/
literal|"0123456789abcdefghijklmnopqrstuv"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Pad32
init|=
literal|'='
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (From RFC3548 and draft-josefsson-rfc3548bis-00.txt) 5.  Base 32 Encoding     The Base 32 encoding is designed to represent arbitrary sequences of    octets in a form that needs to be case insensitive but need not be    humanly readable.     A 33-character subset of US-ASCII is used, enabling 5 bits to be    represented per printable character.  (The extra 33rd character, "=",    is used to signify a special processing function.)     The encoding process represents 40-bit groups of input bits as output    strings of 8 encoded characters.  Proceeding from left to right, a    40-bit input group is formed by concatenating 5 8bit input groups.    These 40 bits are then treated as 8 concatenated 5-bit groups, each    of which is translated into a single digit in the base 32 alphabet.    When encoding a bit stream via the base 32 encoding, the bit stream    must be presumed to be ordered with the most-significant-bit first.    That is, the first bit in the stream will be the high-order bit in    the first 8bit byte, and the eighth bit will be the low-order bit in    the first 8bit byte, and so on.     Each 5-bit group is used as an index into an array of 32 printable    characters.  The character referenced by the index is placed in the    output string.  These characters, identified in Table 3, below, are    selected from US-ASCII digits and uppercase letters.                        Table 3: The Base 32 Alphabet           Value Encoding  Value Encoding  Value Encoding  Value Encoding              0 A             9 J            18 S            27 3              1 B            10 K            19 T            28 4              2 C            11 L            20 U            29 5              3 D            12 M            21 V            30 6              4 E            13 N            22 W            31 7              5 F            14 O            23 X              6 G            15 P            24 Y         (pad) =              7 H            16 Q            25 Z              8 I            17 R            26 2      Special processing is performed if fewer than 40 bits are available    at the end of the data being encoded.  A full encoding quantum is    always completed at the end of a body.  When fewer than 40 input bits    are available in an input group, zero bits are added (on the right)    to form an integral number of 5-bit groups.  Padding at the end of    the data is performed using the "=" character.  Since all base 32    input is an integral number of octets, only the following cases can    arise:     (1) the final quantum of encoding input is an integral multiple of 40    bits; here, the final unit of encoded output will be an integral    multiple of 8 characters with no "=" padding,     (2) the final quantum of encoding input is exactly 8 bits; here, the    final unit of encoded output will be two characters followed by six    "=" padding characters,     (3) the final quantum of encoding input is exactly 16 bits; here, the    final unit of encoded output will be four characters followed by four    "=" padding characters,     (4) the final quantum of encoding input is exactly 24 bits; here, the    final unit of encoded output will be five characters followed by    three "=" padding characters, or     (5) the final quantum of encoding input is exactly 32 bits; here, the    final unit of encoded output will be seven characters followed by one    "=" padding character.   6.  Base 32 Encoding with Extended Hex Alphabet     The following description of base 32 is due to [7].  This encoding    should not be regarded as the same as the "base32" encoding, and    should not be referred to as only "base32".     One property with this alphabet, that the base64 and base32 alphabet    lack, is that encoded data maintain its sort order when the encoded    data is compared bit-wise.     This encoding is identical to the previous one, except for the    alphabet.  The new alphabet is found in table 4.                       Table 4: The "Extended Hex" Base 32 Alphabet           Value Encoding  Value Encoding  Value Encoding  Value Encoding              0 0             9 9            18 I            27 R              1 1            10 A            19 J            28 S              2 2            11 B            20 K            29 T              3 3            12 C            21 L            30 U              4 4            13 D            22 M            31 V              5 5            14 E            23 N              6 6            15 F            24 O         (pad) =              7 7            16 G            25 P              8 8            17 H            26 Q  */
end_comment

begin_function
specifier|static
name|int
name|ldns_b32_ntop_ar
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|,
specifier|const
name|char
name|B32_ar
index|[]
parameter_list|)
block|{
name|size_t
name|datalength
init|=
literal|0
decl_stmt|;
name|uint8_t
name|input
index|[
literal|5
index|]
decl_stmt|;
name|uint8_t
name|output
index|[
literal|8
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|memset
argument_list|(
name|output
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
literal|4
operator|<
name|srclength
condition|)
block|{
name|input
index|[
literal|0
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|input
index|[
literal|1
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|input
index|[
literal|2
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|input
index|[
literal|3
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|input
index|[
literal|4
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|srclength
operator|-=
literal|5
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
operator|(
name|input
index|[
literal|0
index|]
operator|&
literal|0xf8
operator|)
operator|>>
literal|3
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0x3e
operator|)
operator|>>
literal|1
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|2
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|output
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|3
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|output
index|[
literal|5
index|]
operator|=
operator|(
name|input
index|[
literal|3
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
expr_stmt|;
name|output
index|[
literal|6
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|3
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|4
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
name|output
index|[
literal|7
index|]
operator|=
operator|(
name|input
index|[
literal|4
index|]
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|0
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|1
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|2
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|3
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|4
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|5
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|6
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|7
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalength
operator|+
literal|8
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|0
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|1
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|2
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|3
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|4
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|5
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|6
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|7
index|]
index|]
expr_stmt|;
block|}
comment|/* Now we worry about padding. */
if|if
condition|(
literal|0
operator|!=
name|srclength
condition|)
block|{
comment|/* Get what's left. */
name|input
index|[
literal|0
index|]
operator|=
name|input
index|[
literal|1
index|]
operator|=
name|input
index|[
literal|2
index|]
operator|=
name|input
index|[
literal|3
index|]
operator|=
name|input
index|[
literal|4
index|]
operator|=
operator|(
name|uint8_t
operator|)
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srclength
condition|;
name|i
operator|++
control|)
name|input
index|[
name|i
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
operator|(
name|input
index|[
literal|0
index|]
operator|&
literal|0xf8
operator|)
operator|>>
literal|3
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|0
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|srclength
operator|>=
literal|1
condition|)
block|{
name|output
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|1
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0x3e
operator|)
operator|>>
literal|1
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|2
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srclength
operator|>=
literal|2
condition|)
block|{
name|output
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|2
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|3
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srclength
operator|>=
literal|3
condition|)
block|{
name|output
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|3
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|4
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
name|output
index|[
literal|5
index|]
operator|=
operator|(
name|input
index|[
literal|3
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|5
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srclength
operator|>=
literal|4
condition|)
block|{
name|output
index|[
literal|6
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|3
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|input
index|[
literal|4
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
name|assert
argument_list|(
name|output
index|[
literal|6
index|]
operator|<
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|srclength
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|srclength
operator|==
literal|1
operator|&&
name|output
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|2
index|]
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
if|if
condition|(
name|srclength
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|3
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
if|if
condition|(
name|srclength
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|4
index|]
index|]
expr_stmt|;
if|if
condition|(
name|srclength
operator|==
literal|3
operator|&&
name|output
index|[
literal|5
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|5
index|]
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
if|if
condition|(
name|srclength
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|B32_ar
index|[
name|output
index|[
literal|6
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad32
expr_stmt|;
block|}
if|if
condition|(
name|datalength
operator|+
literal|1
operator|>
name|targsize
condition|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|datalength
argument_list|)
return|;
block|}
name|target
index|[
name|datalength
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Returned value doesn't count \0. */
return|return
call|(
name|int
call|)
argument_list|(
name|datalength
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ldns_b32_ntop
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_ntop_ar
argument_list|(
name|src
argument_list|,
name|srclength
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* deprecated, here for backwards compatibility */
end_comment

begin_function
name|int
name|b32_ntop
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_ntop_ar
argument_list|(
name|src
argument_list|,
name|srclength
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ldns_b32_ntop_extended_hex
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_ntop_ar
argument_list|(
name|src
argument_list|,
name|srclength
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32_extended_hex
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* deprecated, here for backwards compatibility */
end_comment

begin_function
name|int
name|b32_ntop_extended_hex
parameter_list|(
name|uint8_t
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_ntop_ar
argument_list|(
name|src
argument_list|,
name|srclength
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32_extended_hex
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_B32_NTOP */
end_comment

end_unit

