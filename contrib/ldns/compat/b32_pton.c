begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, 1998 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_B32_PTON
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ldns/util.h>
end_include

begin_comment
comment|/*	"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Base32
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyz234567"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	"0123456789ABCDEFGHIJKLMNOPQRSTUV";*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Base32_extended_hex
index|[]
init|=
literal|"0123456789abcdefghijklmnopqrstuv"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Pad32
init|=
literal|'='
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (From RFC1521 and draft-ietf-dnssec-secext-03.txt) 5.  Base 32 Encoding     The Base 32 encoding is designed to represent arbitrary sequences of    octets in a form that needs to be case insensitive but need not be    humanly readable.     A 33-character subset of US-ASCII is used, enabling 5 bits to be    represented per printable character.  (The extra 33rd character, "=",    is used to signify a special processing function.)     The encoding process represents 40-bit groups of input bits as output    strings of 8 encoded characters.  Proceeding from left to right, a    40-bit input group is formed by concatenating 5 8bit input groups.    These 40 bits are then treated as 8 concatenated 5-bit groups, each    of which is translated into a single digit in the base 32 alphabet.    When encoding a bit stream via the base 32 encoding, the bit stream    must be presumed to be ordered with the most-significant-bit first.    That is, the first bit in the stream will be the high-order bit in    the first 8bit byte, and the eighth bit will be the low-order bit in    the first 8bit byte, and so on.     Each 5-bit group is used as an index into an array of 32 printable    characters.  The character referenced by the index is placed in the    output string.  These characters, identified in Table 3, below, are    selected from US-ASCII digits and uppercase letters.                        Table 3: The Base 32 Alphabet           Value Encoding  Value Encoding  Value Encoding  Value Encoding              0 A             9 J            18 S            27 3              1 B            10 K            19 T            28 4              2 C            11 L            20 U            29 5              3 D            12 M            21 V            30 6              4 E            13 N            22 W            31 7              5 F            14 O            23 X              6 G            15 P            24 Y         (pad) =              7 H            16 Q            25 Z              8 I            17 R            26 2      Special processing is performed if fewer than 40 bits are available    at the end of the data being encoded.  A full encoding quantum is    always completed at the end of a body.  When fewer than 40 input bits    are available in an input group, zero bits are added (on the right)    to form an integral number of 5-bit groups.  Padding at the end of    the data is performed using the "=" character.  Since all base 32    input is an integral number of octets, only the following cases can    arise:     (1) the final quantum of encoding input is an integral multiple of 40    bits; here, the final unit of encoded output will be an integral    multiple of 8 characters with no "=" padding,     (2) the final quantum of encoding input is exactly 8 bits; here, the    final unit of encoded output will be two characters followed by six    "=" padding characters,     (3) the final quantum of encoding input is exactly 16 bits; here, the    final unit of encoded output will be four characters followed by four    "=" padding characters,     (4) the final quantum of encoding input is exactly 24 bits; here, the    final unit of encoded output will be five characters followed by    three "=" padding characters, or     (5) the final quantum of encoding input is exactly 32 bits; here, the    final unit of encoded output will be seven characters followed by one    "=" padding character.   6.  Base 32 Encoding with Extended Hex Alphabet     The following description of base 32 is due to [7].  This encoding    should not be regarded as the same as the "base32" encoding, and    should not be referred to as only "base32".     One property with this alphabet, that the base32 and base32 alphabet    lack, is that encoded data maintain its sort order when the encoded    data is compared bit-wise.     This encoding is identical to the previous one, except for the    alphabet.  The new alphabet is found in table 4.                       Table 4: The "Extended Hex" Base 32 Alphabet           Value Encoding  Value Encoding  Value Encoding  Value Encoding              0 0             9 9            18 I            27 R              1 1            10 A            19 J            28 S              2 2            11 B            20 K            29 T              3 3            12 C            21 L            30 U              4 4            13 D            22 M            31 V              5 5            14 E            23 N              6 6            15 F            24 O         (pad) =              7 7            16 G            25 P              8 8            17 H            26 Q     */
end_comment

begin_comment
comment|/* skips all whitespace anywhere.    converts characters, four at a time, starting at (or after)    src from base - 32 numbers into three 8 bit bytes in the target area.    it returns the number of data bytes stored at the target, or -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|ldns_b32_pton_ar
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|,
specifier|const
name|char
name|B32_ar
index|[]
parameter_list|)
block|{
name|int
name|tarindex
decl_stmt|,
name|state
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|tarindex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|i
operator|<
operator|(
name|int
operator|)
name|hashed_owner_str_len
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
comment|/* Skip whitespace anywhere. */
continue|continue;
if|if
condition|(
name|ch
operator|==
name|Pad32
condition|)
break|break;
name|pos
operator|=
name|strchr
argument_list|(
name|B32_ar
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
comment|/* A non-base32 character. */
return|return
operator|(
operator|-
name|ch
operator|)
return|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator|=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|>>
literal|2
expr_stmt|;
name|target
index|[
name|tarindex
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|<<
literal|1
expr_stmt|;
block|}
comment|/*tarindex++;*/
name|state
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|>>
literal|4
expr_stmt|;
name|target
index|[
name|tarindex
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|6
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|>>
literal|1
expr_stmt|;
name|target
index|[
name|tarindex
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|&
literal|0x01
operator|)
operator|<<
literal|7
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|7
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
name|state
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|>>
literal|3
expr_stmt|;
name|target
index|[
name|tarindex
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|pos
operator|-
name|B32_ar
operator|)
operator|&
literal|0x07
operator|)
operator|<<
literal|5
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
block|{
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|B32_ar
operator|)
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * We are done decoding Base-32 chars.  Let's see if we ended 	 * on a byte boundary, and/or with erroneous trailing characters. 	 */
if|if
condition|(
name|ch
operator|==
name|Pad32
condition|)
block|{
comment|/* We got a pad char. */
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* Skip it, get next. */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* Invalid = in first position */
case|case
literal|1
case|:
comment|/* Invalid = in second position */
return|return
operator|(
operator|-
literal|10
operator|)
return|;
case|case
literal|2
case|:
comment|/* Valid, means one byte of info */
case|case
literal|3
case|:
comment|/* Skip any number of spaces. */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|ch
operator|!=
literal|'\0'
condition|;
name|ch
operator|=
operator|*
name|src
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
break|break;
comment|/* Make sure there is another trailing = sign. */
if|if
condition|(
name|ch
operator|!=
name|Pad32
condition|)
block|{
return|return
operator|(
operator|-
literal|11
operator|)
return|;
block|}
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* Skip the = */
comment|/* Fall through to "single trailing =" case. */
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
comment|/* Valid, means two bytes of info */
case|case
literal|5
case|:
case|case
literal|6
case|:
comment|/* 			 * We know this char is an =.  Is there anything but 			 * whitespace after it? 			 */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|ch
operator|!=
literal|'\0'
condition|;
name|ch
operator|=
operator|*
name|src
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'='
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|12
operator|)
return|;
block|}
case|case
literal|7
case|:
comment|/* Valid, means three bytes of info */
comment|/* 			 * We know this char is an =.  Is there anything but 			 * whitespace after it? 			 */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|ch
operator|!=
literal|'\0'
condition|;
name|ch
operator|=
operator|*
name|src
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
comment|/* 			 * Now make sure for cases 2 and 3 that the "extra" 			 * bits that slopped past the last full byte were 			 * zeros.  If we don't check them, they become a 			 * subliminal channel. 			 */
if|if
condition|(
name|target
operator|&&
name|target
index|[
name|tarindex
index|]
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|14
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * We ended by seeing the end of the string.  Make sure we 		 * have no partial bytes lying around. 		 */
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|15
operator|)
return|;
block|}
return|return
operator|(
name|tarindex
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ldns_b32_pton
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_pton_ar
argument_list|(
name|src
argument_list|,
name|hashed_owner_str_len
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* deprecated, here for backwards compatibility */
end_comment

begin_function
name|int
name|b32_pton
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_pton_ar
argument_list|(
name|src
argument_list|,
name|hashed_owner_str_len
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ldns_b32_pton_extended_hex
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_pton_ar
argument_list|(
name|src
argument_list|,
name|hashed_owner_str_len
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32_extended_hex
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* deprecated, here for backwards compatibility */
end_comment

begin_function
name|int
name|b32_pton_extended_hex
parameter_list|(
name|char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|hashed_owner_str_len
parameter_list|,
name|uint8_t
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
return|return
name|ldns_b32_pton_ar
argument_list|(
name|src
argument_list|,
name|hashed_owner_str_len
argument_list|,
name|target
argument_list|,
name|targsize
argument_list|,
name|Base32_extended_hex
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_B32_PTON */
end_comment

end_unit

