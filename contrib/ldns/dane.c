begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Verify or create TLS authentication with DANE (RFC6698)  *  * (c) NLnetLabs 2012  *  * See the file LICENSE for the license.  *  */
end_comment

begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DANE
end_ifdef

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<ldns/dane.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|ldns_status
name|ldns_dane_create_tlsa_owner
parameter_list|(
name|ldns_rdf
modifier|*
modifier|*
name|tlsa_owner
parameter_list|,
specifier|const
name|ldns_rdf
modifier|*
name|name
parameter_list|,
name|uint16_t
name|port
parameter_list|,
name|ldns_dane_transport
name|transport
parameter_list|)
block|{
name|char
name|buf
index|[
name|LDNS_MAX_DOMAINLEN
index|]
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|assert
argument_list|(
name|tlsa_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ldns_rdf_get_type
argument_list|(
name|name
argument_list|)
operator|==
name|LDNS_RDF_TYPE_DNAME
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|size_t
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|LDNS_MAX_DOMAINLEN
argument_list|,
literal|"X_%d"
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|s
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transport
condition|)
block|{
case|case
name|LDNS_DANE_TRANSPORT_TCP
case|:
name|s
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|s
argument_list|,
name|LDNS_MAX_DOMAINLEN
operator|-
name|s
argument_list|,
literal|"\004_tcp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_DANE_TRANSPORT_UDP
case|:
name|s
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|s
argument_list|,
name|LDNS_MAX_DOMAINLEN
operator|-
name|s
argument_list|,
literal|"\004_udp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_DANE_TRANSPORT_SCTP
case|:
name|s
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|s
argument_list|,
name|LDNS_MAX_DOMAINLEN
operator|-
name|s
argument_list|,
literal|"\005_sctp"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|LDNS_STATUS_DANE_UNKNOWN_TRANSPORT
return|;
block|}
if|if
condition|(
name|s
operator|+
name|ldns_rdf_size
argument_list|(
name|name
argument_list|)
operator|>
name|LDNS_MAX_DOMAINLEN
condition|)
block|{
return|return
name|LDNS_STATUS_DOMAINNAME_OVERFLOW
return|;
block|}
name|memcpy
argument_list|(
name|buf
operator|+
name|s
argument_list|,
name|ldns_rdf_data
argument_list|(
name|name
argument_list|)
argument_list|,
name|ldns_rdf_size
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tlsa_owner
operator|=
name|ldns_rdf_new_frm_data
argument_list|(
name|LDNS_RDF_TYPE_DNAME
argument_list|,
name|s
operator|+
name|ldns_rdf_size
argument_list|(
name|name
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tlsa_owner
operator|==
name|NULL
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_function
name|ldns_status
name|ldns_dane_cert2rdf
parameter_list|(
name|ldns_rdf
modifier|*
modifier|*
name|rdf
parameter_list|,
name|X509
modifier|*
name|cert
parameter_list|,
name|ldns_tlsa_selector
name|selector
parameter_list|,
name|ldns_tlsa_matching_type
name|matching_type
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|X509_PUBKEY
modifier|*
name|xpubkey
decl_stmt|;
name|EVP_PKEY
modifier|*
name|epubkey
decl_stmt|;
name|unsigned
name|char
modifier|*
name|digest
decl_stmt|;
name|assert
argument_list|(
name|rdf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|selector
condition|)
block|{
case|case
name|LDNS_TLSA_SELECTOR_FULL_CERTIFICATE
case|:
name|len
operator|=
operator|(
name|size_t
operator|)
name|i2d_X509
argument_list|(
name|cert
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_TLSA_SELECTOR_SUBJECTPUBLICKEYINFO
case|:
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|xpubkey
operator|=
name|X509_get_X509_PUBKEY
argument_list|(
name|cert
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|xpubkey
condition|)
block|{
return|return
name|LDNS_STATUS_SSL_ERR
return|;
block|}
name|epubkey
operator|=
name|X509_PUBKEY_get
argument_list|(
name|xpubkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|epubkey
condition|)
block|{
return|return
name|LDNS_STATUS_SSL_ERR
return|;
block|}
name|len
operator|=
operator|(
name|size_t
operator|)
name|i2d_PUBKEY
argument_list|(
name|epubkey
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|LDNS_STATUS_DANE_UNKNOWN_SELECTOR
return|;
block|}
switch|switch
condition|(
name|matching_type
condition|)
block|{
case|case
name|LDNS_TLSA_MATCHING_TYPE_NO_HASH_USED
case|:
operator|*
name|rdf
operator|=
name|ldns_rdf_new
argument_list|(
name|LDNS_RDF_TYPE_HEX
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|*
name|rdf
condition|?
name|LDNS_STATUS_OK
else|:
name|LDNS_STATUS_MEM_ERR
return|;
break|break;
case|case
name|LDNS_TLSA_MATCHING_TYPE_SHA256
case|:
name|digest
operator|=
name|LDNS_XMALLOC
argument_list|(
argument|unsigned char
argument_list|,
argument|LDNS_SHA256_DIGEST_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest
operator|==
name|NULL
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
operator|(
name|void
operator|)
name|ldns_sha256
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|digest
argument_list|)
expr_stmt|;
operator|*
name|rdf
operator|=
name|ldns_rdf_new
argument_list|(
name|LDNS_RDF_TYPE_HEX
argument_list|,
name|LDNS_SHA256_DIGEST_LENGTH
argument_list|,
name|digest
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|*
name|rdf
condition|?
name|LDNS_STATUS_OK
else|:
name|LDNS_STATUS_MEM_ERR
return|;
break|break;
case|case
name|LDNS_TLSA_MATCHING_TYPE_SHA512
case|:
name|digest
operator|=
name|LDNS_XMALLOC
argument_list|(
argument|unsigned char
argument_list|,
argument|LDNS_SHA512_DIGEST_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest
operator|==
name|NULL
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
operator|(
name|void
operator|)
name|ldns_sha512
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|digest
argument_list|)
expr_stmt|;
operator|*
name|rdf
operator|=
name|ldns_rdf_new
argument_list|(
name|LDNS_RDF_TYPE_HEX
argument_list|,
name|LDNS_SHA512_DIGEST_LENGTH
argument_list|,
name|digest
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|*
name|rdf
condition|?
name|LDNS_STATUS_OK
else|:
name|LDNS_STATUS_MEM_ERR
return|;
break|break;
default|default:
name|LDNS_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_DANE_UNKNOWN_MATCHING_TYPE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Ordinary PKIX validation of cert (with extra_certs to help)  * against the CA's in store  */
end_comment

begin_decl_stmt
specifier|static
name|ldns_status
name|ldns_dane_pkix_validate
argument_list|(
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|store
argument_list|)
block|{
name|X509_STORE_CTX
modifier|*
name|vrfy_ctx
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|store
condition|)
block|{
return|return
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
return|;
block|}
name|vrfy_ctx
operator|=
name|X509_STORE_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vrfy_ctx
condition|)
block|{
return|return
name|LDNS_STATUS_SSL_ERR
return|;
block|}
elseif|else
if|if
condition|(
name|X509_STORE_CTX_init
argument_list|(
name|vrfy_ctx
argument_list|,
name|store
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X509_verify_cert
argument_list|(
name|vrfy_ctx
argument_list|)
operator|==
literal|1
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
expr_stmt|;
block|}
name|X509_STORE_CTX_free
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Orinary PKIX validation of cert (with extra_certs to help)  * against the CA's in store, but also return the validation chain.  */
end_comment

begin_decl_stmt
specifier|static
name|ldns_status
name|ldns_dane_pkix_validate_and_get_chain
argument_list|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|chain
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|store
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|X509_STORE
modifier|*
name|empty_store
init|=
name|NULL
decl_stmt|;
name|X509_STORE_CTX
modifier|*
name|vrfy_ctx
decl_stmt|;
name|assert
argument_list|(
name|chain
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store
condition|)
block|{
name|store
operator|=
name|empty_store
operator|=
name|X509_STORE_new
argument_list|()
expr_stmt|;
block|}
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
name|vrfy_ctx
operator|=
name|X509_STORE_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vrfy_ctx
condition|)
block|{
goto|goto
name|exit_free_empty_store
goto|;
block|}
elseif|else
if|if
condition|(
name|X509_STORE_CTX_init
argument_list|(
name|vrfy_ctx
argument_list|,
name|store
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
operator|!=
literal|1
condition|)
block|{
goto|goto
name|exit_free_vrfy_ctx
goto|;
block|}
elseif|else
if|if
condition|(
name|X509_verify_cert
argument_list|(
name|vrfy_ctx
argument_list|)
operator|==
literal|1
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
expr_stmt|;
block|}
operator|*
name|chain
operator|=
name|X509_STORE_CTX_get1_chain
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
block|}
name|exit_free_vrfy_ctx
label|:
name|X509_STORE_CTX_free
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
name|exit_free_empty_store
label|:
if|if
condition|(
name|empty_store
condition|)
block|{
name|X509_STORE_free
argument_list|(
name|empty_store
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return the validation chain that can be build out of cert, with extra_certs.  */
end_comment

begin_decl_stmt
specifier|static
name|ldns_status
name|ldns_dane_pkix_get_chain
argument_list|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|chain
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|X509_STORE
modifier|*
name|empty_store
init|=
name|NULL
decl_stmt|;
name|X509_STORE_CTX
modifier|*
name|vrfy_ctx
decl_stmt|;
name|assert
argument_list|(
name|chain
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|empty_store
operator|=
name|X509_STORE_new
argument_list|()
expr_stmt|;
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
name|vrfy_ctx
operator|=
name|X509_STORE_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vrfy_ctx
condition|)
block|{
goto|goto
name|exit_free_empty_store
goto|;
block|}
elseif|else
if|if
condition|(
name|X509_STORE_CTX_init
argument_list|(
name|vrfy_ctx
argument_list|,
name|empty_store
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
operator|!=
literal|1
condition|)
block|{
goto|goto
name|exit_free_vrfy_ctx
goto|;
block|}
operator|(
name|void
operator|)
name|X509_verify_cert
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|X509_STORE_CTX_get1_chain
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
block|}
name|exit_free_vrfy_ctx
label|:
name|X509_STORE_CTX_free
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
name|exit_free_empty_store
label|:
name|X509_STORE_free
argument_list|(
name|empty_store
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Pop n+1 certs and return the last popped.  */
end_comment

begin_decl_stmt
specifier|static
name|ldns_status
name|ldns_dane_get_nth_cert_from_validation_chain
argument_list|(
name|X509
operator|*
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
argument_list|,
name|int
name|n
argument_list|,
name|bool
name|ca
argument_list|)
block|{
if|if
condition|(
name|n
operator|>=
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
operator|||
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|LDNS_STATUS_DANE_OFFSET_OUT_OF_RANGE
return|;
block|}
operator|*
name|cert
operator|=
name|sk_X509_pop
argument_list|(
name|chain
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|X509_free
argument_list|(
operator|*
name|cert
argument_list|)
expr_stmt|;
operator|*
name|cert
operator|=
name|sk_X509_pop
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ca
operator|&&
operator|!
name|X509_check_ca
argument_list|(
operator|*
name|cert
argument_list|)
condition|)
block|{
return|return
name|LDNS_STATUS_DANE_NON_CA_CERTIFICATE
return|;
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create validation chain with cert and extra_certs and returns the last  * self-signed (if present).  */
end_comment

begin_decl_stmt
specifier|static
name|ldns_status
name|ldns_dane_pkix_get_last_self_signed
argument_list|(
name|X509
operator|*
operator|*
name|out_cert
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|X509_STORE
modifier|*
name|empty_store
init|=
name|NULL
decl_stmt|;
name|X509_STORE_CTX
modifier|*
name|vrfy_ctx
decl_stmt|;
name|assert
argument_list|(
name|out_cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|empty_store
operator|=
name|X509_STORE_new
argument_list|()
expr_stmt|;
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
name|vrfy_ctx
operator|=
name|X509_STORE_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vrfy_ctx
condition|)
block|{
goto|goto
name|exit_free_empty_store
goto|;
block|}
elseif|else
if|if
condition|(
name|X509_STORE_CTX_init
argument_list|(
name|vrfy_ctx
argument_list|,
name|empty_store
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
operator|!=
literal|1
condition|)
block|{
goto|goto
name|exit_free_vrfy_ctx
goto|;
block|}
operator|(
name|void
operator|)
name|X509_verify_cert
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrfy_ctx
operator|->
name|error
operator|==
name|X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
operator|||
name|vrfy_ctx
operator|->
name|error
operator|==
name|X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
condition|)
block|{
operator|*
name|out_cert
operator|=
name|X509_STORE_CTX_get_current_cert
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
name|s
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|LDNS_STATUS_DANE_PKIX_NO_SELF_SIGNED_TRUST_ANCHOR
expr_stmt|;
block|}
name|exit_free_vrfy_ctx
label|:
name|X509_STORE_CTX_free
argument_list|(
name|vrfy_ctx
argument_list|)
expr_stmt|;
name|exit_free_empty_store
label|:
name|X509_STORE_free
argument_list|(
name|empty_store
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|ldns_status
name|ldns_dane_select_certificate
argument_list|(
name|X509
operator|*
operator|*
name|selected_cert
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|pkix_validation_store
argument_list|,
name|ldns_tlsa_certificate_usage
name|cert_usage
argument_list|,
name|int
name|offset
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|pkix_validation_chain
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|selected_cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* With PKIX validation explicitely turned off (pkix_validation_store 	 *  == NULL), treat the "CA constraint" and "Service certificate 	 * constraint" the same as "Trust anchor assertion" and "Domain issued 	 * certificate" respectively. 	 */
if|if
condition|(
name|pkix_validation_store
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|cert_usage
condition|)
block|{
case|case
name|LDNS_TLSA_USAGE_CA_CONSTRAINT
case|:
name|cert_usage
operator|=
name|LDNS_TLSA_USAGE_TRUST_ANCHOR_ASSERTION
expr_stmt|;
break|break;
case|case
name|LDNS_TLSA_USAGE_SERVICE_CERTIFICATE_CONSTRAINT
case|:
name|cert_usage
operator|=
name|LDNS_TLSA_USAGE_DOMAIN_ISSUED_CERTIFICATE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Now what to do with each Certificate usage... 	 */
switch|switch
condition|(
name|cert_usage
condition|)
block|{
case|case
name|LDNS_TLSA_USAGE_CA_CONSTRAINT
case|:
name|s
operator|=
name|ldns_dane_pkix_validate_and_get_chain
argument_list|(
operator|&
name|pkix_validation_chain
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkix_validation_chain
condition|)
block|{
return|return
name|s
return|;
block|}
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|ldns_dane_get_nth_cert_from_validation_chain
argument_list|(
name|selected_cert
argument_list|,
name|pkix_validation_chain
argument_list|,
name|offset
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|sk_X509_pop_free
argument_list|(
name|pkix_validation_chain
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
return|return
name|s
return|;
break|break;
case|case
name|LDNS_TLSA_USAGE_SERVICE_CERTIFICATE_CONSTRAINT
case|:
operator|*
name|selected_cert
operator|=
name|cert
expr_stmt|;
return|return
name|ldns_dane_pkix_validate
argument_list|(
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
return|;
break|break;
case|case
name|LDNS_TLSA_USAGE_TRUST_ANCHOR_ASSERTION
case|:
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|ldns_dane_pkix_get_last_self_signed
argument_list|(
name|selected_cert
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
name|s
operator|=
name|ldns_dane_pkix_get_chain
argument_list|(
operator|&
name|pkix_validation_chain
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|s
operator|=
name|ldns_dane_get_nth_cert_from_validation_chain
argument_list|(
name|selected_cert
argument_list|,
name|pkix_validation_chain
argument_list|,
name|offset
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pkix_validation_chain
condition|)
block|{
return|return
name|s
return|;
block|}
name|sk_X509_pop_free
argument_list|(
name|pkix_validation_chain
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
break|break;
case|case
name|LDNS_TLSA_USAGE_DOMAIN_ISSUED_CERTIFICATE
case|:
operator|*
name|selected_cert
operator|=
name|cert
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
break|break;
default|default:
return|return
name|LDNS_STATUS_DANE_UNKNOWN_CERTIFICATE_USAGE
return|;
break|break;
block|}
block|}
end_decl_stmt

begin_function
name|ldns_status
name|ldns_dane_create_tlsa_rr
parameter_list|(
name|ldns_rr
modifier|*
modifier|*
name|tlsa
parameter_list|,
name|ldns_tlsa_certificate_usage
name|certificate_usage
parameter_list|,
name|ldns_tlsa_selector
name|selector
parameter_list|,
name|ldns_tlsa_matching_type
name|matching_type
parameter_list|,
name|X509
modifier|*
name|cert
parameter_list|)
block|{
name|ldns_rdf
modifier|*
name|rdf
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
name|assert
argument_list|(
name|tlsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* create rr */
operator|*
name|tlsa
operator|=
name|ldns_rr_new_frm_type
argument_list|(
name|LDNS_RR_TYPE_TLSA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tlsa
operator|==
name|NULL
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
name|rdf
operator|=
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_INT8
argument_list|,
operator|(
name|uint8_t
operator|)
name|certificate_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdf
operator|==
name|NULL
condition|)
block|{
goto|goto
name|memerror
goto|;
block|}
operator|(
name|void
operator|)
name|ldns_rr_set_rdf
argument_list|(
operator|*
name|tlsa
argument_list|,
name|rdf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rdf
operator|=
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_INT8
argument_list|,
operator|(
name|uint8_t
operator|)
name|selector
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdf
operator|==
name|NULL
condition|)
block|{
goto|goto
name|memerror
goto|;
block|}
operator|(
name|void
operator|)
name|ldns_rr_set_rdf
argument_list|(
operator|*
name|tlsa
argument_list|,
name|rdf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rdf
operator|=
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_INT8
argument_list|,
operator|(
name|uint8_t
operator|)
name|matching_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdf
operator|==
name|NULL
condition|)
block|{
goto|goto
name|memerror
goto|;
block|}
operator|(
name|void
operator|)
name|ldns_rr_set_rdf
argument_list|(
operator|*
name|tlsa
argument_list|,
name|rdf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|ldns_dane_cert2rdf
argument_list|(
operator|&
name|rdf
argument_list|,
name|cert
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
operator|(
name|void
operator|)
name|ldns_rr_set_rdf
argument_list|(
operator|*
name|tlsa
argument_list|,
name|rdf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
name|ldns_rr_free
argument_list|(
operator|*
name|tlsa
argument_list|)
expr_stmt|;
operator|*
name|tlsa
operator|=
name|NULL
expr_stmt|;
return|return
name|s
return|;
name|memerror
label|:
name|ldns_rr_free
argument_list|(
operator|*
name|tlsa
argument_list|)
expr_stmt|;
operator|*
name|tlsa
operator|=
name|NULL
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
end_function

begin_comment
comment|/* Return tlsas that actually are TLSA resource records with known values  * for the Certificate usage, Selector and Matching type rdata fields.  */
end_comment

begin_function
specifier|static
name|ldns_rr_list
modifier|*
name|ldns_dane_filter_unusable_records
parameter_list|(
specifier|const
name|ldns_rr_list
modifier|*
name|tlsas
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr_list
modifier|*
name|r
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
name|ldns_rr
modifier|*
name|tlsa_rr
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|tlsas
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tlsa_rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|tlsas
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|tlsa_rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_TLSA
operator|&&
name|ldns_rr_rd_count
argument_list|(
name|tlsa_rr
argument_list|)
operator|==
literal|4
operator|&&
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|3
operator|&&
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|1
operator|&&
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|r
argument_list|,
name|tlsa_rr
argument_list|)
condition|)
block|{
name|ldns_rr_list_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return whether cert/selector/matching_type matches data.  */
end_comment

begin_function
specifier|static
name|ldns_status
name|ldns_dane_match_cert_with_data
parameter_list|(
name|X509
modifier|*
name|cert
parameter_list|,
name|ldns_tlsa_selector
name|selector
parameter_list|,
name|ldns_tlsa_matching_type
name|matching_type
parameter_list|,
name|ldns_rdf
modifier|*
name|data
parameter_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|ldns_rdf
modifier|*
name|match_data
decl_stmt|;
name|s
operator|=
name|ldns_dane_cert2rdf
argument_list|(
operator|&
name|match_data
argument_list|,
name|cert
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|ldns_rdf_compare
argument_list|(
name|data
argument_list|,
name|match_data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH
expr_stmt|;
block|}
name|ldns_rdf_free
argument_list|(
name|match_data
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return whether any certificate from the chain with selector/matching_type  * matches data.  * ca should be true if the certificate has to be a CA certificate too.  */
end_comment

begin_decl_stmt
specifier|static
name|ldns_status
name|ldns_dane_match_any_cert_with_data
argument_list|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
argument_list|,
name|ldns_tlsa_selector
name|selector
argument_list|,
name|ldns_tlsa_matching_type
name|matching_type
argument_list|,
name|ldns_rdf
operator|*
name|data
argument_list|,
name|bool
name|ca
argument_list|)
block|{
name|ldns_status
name|s
init|=
name|LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|i
decl_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|n
operator|=
operator|(
name|size_t
operator|)
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|cert
operator|=
name|sk_X509_pop
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_SSL_ERR
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|ldns_dane_match_cert_with_data
argument_list|(
name|cert
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|&&
name|s
operator|==
name|LDNS_STATUS_OK
operator|&&
operator|!
name|X509_check_ca
argument_list|(
name|cert
argument_list|)
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_DANE_NON_CA_CERTIFICATE
expr_stmt|;
block|}
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH
condition|)
block|{
break|break;
block|}
comment|/* when s == LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH, 		 * try to match the next certificate 		 */
block|}
return|return
name|s
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|ldns_status
name|ldns_dane_verify_rr
argument_list|(
specifier|const
name|ldns_rr
operator|*
name|tlsa_rr
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|pkix_validation_store
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|pkix_validation_chain
operator|=
name|NULL
expr_stmt|;
name|ldns_tlsa_certificate_usage
name|cert_usage
decl_stmt|;
name|ldns_tlsa_selector
name|selector
decl_stmt|;
name|ldns_tlsa_matching_type
name|matching_type
decl_stmt|;
name|ldns_rdf
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|tlsa_rr
condition|)
block|{
comment|/* No TLSA, so regular PKIX validation 		 */
return|return
name|ldns_dane_pkix_validate
argument_list|(
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
return|;
block|}
name|cert_usage
operator|=
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|selector
operator|=
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|matching_type
operator|=
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|ldns_rr_rdf
argument_list|(
name|tlsa_rr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cert_usage
condition|)
block|{
case|case
name|LDNS_TLSA_USAGE_CA_CONSTRAINT
case|:
name|s
operator|=
name|ldns_dane_pkix_validate_and_get_chain
argument_list|(
operator|&
name|pkix_validation_chain
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkix_validation_chain
condition|)
block|{
return|return
name|s
return|;
block|}
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
condition|)
block|{
comment|/* 			 * NO PKIX validation. We still try to match *any* 			 * certificate from the chain, so we return 			 * TLSA errors over PKIX errors. 			 * 			 * i.e. When the TLSA matches no certificate, we return 			 * TLSA_DID_NOT_MATCH and not PKIX_DID_NOT_VALIDATE 			 */
name|s
operator|=
name|ldns_dane_match_any_cert_with_data
argument_list|(
name|pkix_validation_chain
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|data
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
comment|/* A TLSA record did match a cert from the 				 * chain, thus the error is failed PKIX 				 * validation. 				 */
name|s
operator|=
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
comment|/* PKIX validated, does the TLSA match too? */
name|s
operator|=
name|ldns_dane_match_any_cert_with_data
argument_list|(
name|pkix_validation_chain
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|data
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|sk_X509_pop_free
argument_list|(
name|pkix_validation_chain
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
return|return
name|s
return|;
break|break;
case|case
name|LDNS_TLSA_USAGE_SERVICE_CERTIFICATE_CONSTRAINT
case|:
name|s
operator|=
name|ldns_dane_match_cert_with_data
argument_list|(
name|cert
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|ldns_dane_pkix_validate
argument_list|(
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
return|;
block|}
return|return
name|s
return|;
break|break;
case|case
name|LDNS_TLSA_USAGE_TRUST_ANCHOR_ASSERTION
case|:
name|s
operator|=
name|ldns_dane_pkix_get_chain
argument_list|(
operator|&
name|pkix_validation_chain
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|s
operator|=
name|ldns_dane_match_any_cert_with_data
argument_list|(
name|pkix_validation_chain
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|data
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pkix_validation_chain
condition|)
block|{
return|return
name|s
return|;
block|}
name|sk_X509_pop_free
argument_list|(
name|pkix_validation_chain
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
return|return
name|s
return|;
break|break;
case|case
name|LDNS_TLSA_USAGE_DOMAIN_ISSUED_CERTIFICATE
case|:
return|return
name|ldns_dane_match_cert_with_data
argument_list|(
name|cert
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|data
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|LDNS_STATUS_DANE_UNKNOWN_CERTIFICATE_USAGE
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|ldns_status
name|ldns_dane_verify
argument_list|(
name|ldns_rr_list
operator|*
name|tlsas
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|pkix_validation_store
argument_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|tlsa_rr
decl_stmt|;
name|ldns_status
name|s
init|=
name|LDNS_STATUS_OK
decl_stmt|,
name|ps
decl_stmt|;
name|assert
argument_list|(
name|cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlsas
operator|&&
name|ldns_rr_list_rr_count
argument_list|(
name|tlsas
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tlsas
operator|=
name|ldns_dane_filter_unusable_records
argument_list|(
name|tlsas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tlsas
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
block|}
if|if
condition|(
operator|!
name|tlsas
operator|||
name|ldns_rr_list_rr_count
argument_list|(
name|tlsas
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* No TLSA's, so regular PKIX validation 		 */
return|return
name|ldns_dane_pkix_validate
argument_list|(
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|tlsas
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tlsa_rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|tlsas
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ps
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|ldns_dane_verify_rr
argument_list|(
name|tlsa_rr
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|pkix_validation_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH
operator|&&
name|s
operator|!=
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
condition|)
block|{
comment|/* which would be LDNS_STATUS_OK (match) 				 * or some fatal error preventing use from 				 * trying the next TLSA record. 				 */
break|break;
block|}
name|s
operator|=
operator|(
name|s
operator|>
name|ps
condition|?
name|s
else|:
name|ps
operator|)
expr_stmt|;
comment|/* prefer PKIX_DID_NOT_VALIDATE 						* over   TLSA_DID_NOT_MATCH 						*/
block|}
name|ldns_rr_list_free
argument_list|(
name|tlsas
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DANE */
end_comment

end_unit

