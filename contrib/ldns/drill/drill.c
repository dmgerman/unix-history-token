begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * drill.c  * the main file of drill  * (c) 2005-2008 NLnet Labs  *  * See the file LICENSE for the license  *  */
end_comment

begin_include
include|#
directive|include
file|"drill.h"
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IP6_ARPA_MAX_LEN
value|65
end_define

begin_comment
comment|/* query debug, 2 hex dumps */
end_comment

begin_decl_stmt
name|int
name|verbosity
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  Usage: %s name [@server] [type] [class]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t<name>  can be a domain name or an IP address (-x lookups)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t<type>  defaults to A\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t<class> defaults to IN\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n\targuments may be placed in random order\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n  Options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-D\t\tenable DNSSEC (DO bit)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-T\t\ttrace from the root down to<name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-S\t\tchase signature(s) from<name> to a know key [*]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*HAVE_SSL*/
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-V<number>\tverbosity (0-5)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-Q\t\tquiet mode (overrules -V)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-f file\t\tread packet from file and send it\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-i file\t\tread packet from file and print it\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-w file\t\twrite answer packet to file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-q file\t\twrite query packet to file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-h\t\tshow this help\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-v\t\tshow version\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n  Query options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-4\t\tstay on ip4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-6\t\tstay on ip6\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-a\t\tfallback to EDNS0 and TCP if the answer is truncated\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-b<bufsize>\tuse<bufsize> as the buffer size (defaults to 512 b)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-c<file>\tuse file for rescursive nameserver configuration"
literal|"\n\t\t\t(/etc/resolv.conf)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-k<file>\tspecify a file that contains a trusted DNSSEC key [**]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t\t\tUsed to verify any signatures in the current answer.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t\t\tWhen DNSSEC enabled tracing (-TD) or signature\n"
literal|"\t\t\tchasing (-S) and no key files are given, keys are read\n"
literal|"\t\t\tfrom: %s\n"
argument_list|,
name|LDNS_TRUST_ANCHOR_FILE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-o<mnemonic>\tset flags to:"
literal|"\n\t\t\t[QR|qr][AA|aa][TC|tc][RD|rd][CD|cd][RA|ra][AD|ad]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t\t\tlowercase: unset bit, uppercase: set bit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-p<port>\tuse<port> as remote port number\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-s\t\tshow the DS RR for each key in a packet\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-u\t\tsend the query with udp (the default)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-x\t\tdo a reverse lookup\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhen doing a secure trace:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-r<file>\tuse file as root servers hint file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-t\t\tsend the query with tcp (connected)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-d<domain>\tuse domain as the start point for the trace\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-y<name:key[:algo]>\tspecify named base64 tsig key, and optional an\n\t\t\talgorithm (defaults to hmac-md5.sig-alg.reg.int)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t-z\t\tdon't randomize the nameservers before use\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n  [*] = enables/implies DNSSEC\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  [**] = can be given more than once\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n  ldns-team@nlnetlabs.nl | http://www.nlnetlabs.nl/ldns/\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Prints the drill version to stderr  */
end_comment

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s version %s (ldns version %s)\n"
argument_list|,
name|progname
argument_list|,
name|DRILL_VERSION
argument_list|,
name|ldns_version
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Written by NLnet Labs.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nCopyright (c) 2004-2008 NLnet Labs.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Licensed under the revised BSD license.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"There is NO warranty; not even for MERCHANTABILITY or FITNESS\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"FOR A PARTICULAR PURPOSE.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Main function of drill  * parse the arguments and prepare a query  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|ldns_resolver
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|ldns_resolver
modifier|*
name|cmdline_res
init|=
name|NULL
decl_stmt|;
comment|/* only used to resolv @name names */
name|ldns_rr_list
modifier|*
name|cmdline_rr_list
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|cmdline_dname
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|qname
decl_stmt|,
modifier|*
name|qname_tmp
decl_stmt|;
name|ldns_pkt
modifier|*
name|pkt
decl_stmt|;
name|ldns_pkt
modifier|*
name|qpkt
decl_stmt|;
name|char
modifier|*
name|serv
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|name2
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
name|query_file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|answer_file
init|=
name|NULL
decl_stmt|;
name|ldns_buffer
modifier|*
name|query_buffer
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|serv_rdf
decl_stmt|;
name|ldns_rr_type
name|type
decl_stmt|;
name|ldns_rr_class
name|clas
decl_stmt|;
if|#
directive|if
literal|0
block|ldns_pkt_opcode opcode = LDNS_PACKET_QUERY;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|int
name|int_type
decl_stmt|;
name|int
name|int_clas
decl_stmt|;
name|int
name|PURPOSE
decl_stmt|;
name|char
modifier|*
name|tsig_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tsig_data
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tsig_algorithm
init|=
name|NULL
decl_stmt|;
name|size_t
name|tsig_separator
decl_stmt|;
name|size_t
name|tsig_separator2
decl_stmt|;
name|ldns_rr
modifier|*
name|axfr_rr
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|char
modifier|*
name|type_str
decl_stmt|;
comment|/* list of keys used in dnssec operations */
name|ldns_rr_list
modifier|*
name|key_list
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
comment|/* what key verify the current answer */
name|ldns_rr_list
modifier|*
name|key_verified
decl_stmt|;
comment|/* resolver options */
name|uint16_t
name|qflags
decl_stmt|;
name|uint16_t
name|qbuf
decl_stmt|;
name|uint16_t
name|qport
decl_stmt|;
name|uint8_t
name|qfamily
decl_stmt|;
name|bool
name|qdnssec
decl_stmt|;
name|bool
name|qfallback
decl_stmt|;
name|bool
name|qds
decl_stmt|;
name|bool
name|qusevc
decl_stmt|;
name|bool
name|qrandom
decl_stmt|;
name|char
modifier|*
name|resolv_conf_file
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|trace_start_name
init|=
name|NULL
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|int
name|r
decl_stmt|;
name|WSADATA
name|wsa_data
decl_stmt|;
endif|#
directive|endif
name|int_type
operator|=
operator|-
literal|1
expr_stmt|;
name|serv
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
name|int_clas
operator|=
operator|-
literal|1
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|clas
operator|=
literal|0
expr_stmt|;
name|qname
operator|=
name|NULL
expr_stmt|;
name|progname
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|r
operator|=
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Failed WSAStartup: %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
endif|#
directive|endif
comment|/* USE_WINSOCK */
name|PURPOSE
operator|=
name|DRILL_QUERY
expr_stmt|;
name|qflags
operator|=
name|LDNS_RD
expr_stmt|;
name|qport
operator|=
name|LDNS_PORT
expr_stmt|;
name|verbosity
operator|=
literal|2
expr_stmt|;
name|qdnssec
operator|=
name|false
expr_stmt|;
name|qfamily
operator|=
name|LDNS_RESOLV_INETANY
expr_stmt|;
name|qfallback
operator|=
name|false
expr_stmt|;
name|qds
operator|=
name|false
expr_stmt|;
name|qbuf
operator|=
literal|0
expr_stmt|;
name|qusevc
operator|=
name|false
expr_stmt|;
name|qrandom
operator|=
name|true
expr_stmt|;
name|key_verified
operator|=
name|NULL
expr_stmt|;
name|ldns_init_random
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|usage
argument_list|(
name|stdout
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* string from orig drill: "i:w:I46Sk:TNp:b:DsvhVcuaq:f:xr" */
comment|/* global first, query opt next, option with parm's last 	 * and sorted */
comment|/*  "46DITSVQf:i:w:q:achuvxzy:so:p:b:k:" */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46ab:c:d:Df:hi:Ik:o:p:q:Qr:sStTuvV:w:xy:z"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* global options */
case|case
literal|'4'
case|:
name|qfamily
operator|=
name|LDNS_RESOLV_INET
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|qfamily
operator|=
name|LDNS_RESOLV_INET6
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|qdnssec
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* reserved for backward compatibility */
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|PURPOSE
operator|==
name|DRILL_CHASE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-T and -S cannot be used at the same time.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|PURPOSE
operator|=
name|DRILL_TRACE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_SSL
case|case
literal|'S'
case|:
if|if
condition|(
name|PURPOSE
operator|==
name|DRILL_TRACE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-T and -S cannot be used at the same time.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|PURPOSE
operator|=
name|DRILL_CHASE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_SSL */
case|case
literal|'V'
case|:
if|if
condition|(
name|strtok
argument_list|(
name|optarg
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-V expects an number as an argument.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|verbosity
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|verbosity
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|query_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|answer_file
operator|=
name|optarg
expr_stmt|;
name|PURPOSE
operator|=
name|DRILL_AFROMFILE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|answer_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|query_file
operator|=
name|optarg
expr_stmt|;
name|PURPOSE
operator|=
name|DRILL_QTOFILE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|global_dns_root
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There was already a series of root servers set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|global_dns_root
operator|=
name|read_root_hints
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|global_dns_root
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to read root hints file %s, aborting\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* query options */
case|case
literal|'a'
case|:
name|qfallback
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|qbuf
operator|=
operator|(
name|uint16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbuf
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"<bufsize> could not be converted"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|resolv_conf_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|qusevc
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|status
operator|=
name|read_key_file
argument_list|(
name|optarg
argument_list|,
name|key_list
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse the key file %s: %s"
argument_list|,
name|optarg
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qdnssec
operator|=
name|true
expr_stmt|;
comment|/* enable that too */
break|break;
case|case
literal|'o'
case|:
comment|/* only looks at the first hit: capital=ON, lowercase=OFF*/
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"QR"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_QR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"qr"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_QR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"AA"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_AA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"aa"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_AA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"TC"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_TC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"tc"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_TC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"RD"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"rd"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"CD"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_CD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"cd"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_CD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"RA"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_RA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"ra"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_RA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"AD"
argument_list|)
condition|)
block|{
name|DRILL_ON
argument_list|(
name|qflags
argument_list|,
name|LDNS_AD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|optarg
argument_list|,
literal|"ad"
argument_list|)
condition|)
block|{
name|DRILL_OFF
argument_list|(
name|qflags
argument_list|,
name|LDNS_AD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|qport
operator|=
operator|(
name|uint16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"<port> could not be converted"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|qds
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|qusevc
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|version
argument_list|(
name|stdout
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_SUCCESS
expr_stmt|;
goto|goto
name|exit
goto|;
case|case
literal|'x'
case|:
name|PURPOSE
operator|=
name|DRILL_REVERSE
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
ifdef|#
directive|ifdef
name|HAVE_SSL
if|if
condition|(
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|tsig_separator
operator|=
call|(
name|size_t
call|)
argument_list|(
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
operator|-
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|optarg
operator|+
name|tsig_separator
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|tsig_separator2
operator|=
call|(
name|size_t
call|)
argument_list|(
name|strchr
argument_list|(
name|optarg
operator|+
name|tsig_separator
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|-
name|optarg
argument_list|)
expr_stmt|;
name|tsig_algorithm
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
name|tsig_separator2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tsig_algorithm
argument_list|,
name|optarg
operator|+
name|tsig_separator2
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
name|tsig_separator2
argument_list|)
expr_stmt|;
name|tsig_algorithm
index|[
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
name|tsig_separator2
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|tsig_separator2
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|tsig_algorithm
operator|=
name|xmalloc
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tsig_algorithm
argument_list|,
literal|"hmac-md5.sig-alg.reg.int."
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|tsig_algorithm
index|[
literal|25
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|tsig_name
operator|=
name|xmalloc
argument_list|(
name|tsig_separator
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tsig_data
operator|=
name|xmalloc
argument_list|(
name|tsig_separator2
operator|-
name|tsig_separator
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tsig_name
argument_list|,
name|optarg
argument_list|,
name|tsig_separator
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tsig_data
argument_list|,
name|optarg
operator|+
name|tsig_separator
operator|+
literal|1
argument_list|,
name|tsig_separator2
operator|-
name|tsig_separator
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* strncpy does not append \0 if source is longer than n */
name|tsig_name
index|[
name|tsig_separator
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tsig_data
index|[
name|tsig_separator2
operator|-
name|tsig_separator
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TSIG requested, but SSL is not supported\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
endif|#
directive|endif
comment|/* HAVE_SSL */
break|break;
case|case
literal|'z'
case|:
name|qrandom
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|trace_start_name
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trace_start_name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse argument for -%c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
break|break;
case|case
literal|'h'
case|:
name|version
argument_list|(
name|stdout
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stdout
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_SUCCESS
expr_stmt|;
goto|goto
name|exit
goto|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown argument: -%c, use -h to see usage\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|(
name|PURPOSE
operator|==
name|DRILL_CHASE
operator|||
operator|(
name|PURPOSE
operator|==
name|DRILL_TRACE
operator|&&
name|qdnssec
operator|)
operator|)
operator|&&
name|ldns_rr_list_rr_count
argument_list|(
name|key_list
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|read_key_file
argument_list|(
name|LDNS_TRUST_ANCHOR_FILE
argument_list|,
name|key_list
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|key_list
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|";; Number of trusted keys: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|ldns_rr_list_rr_count
argument_list|(
name|key_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* do a secure trace when requested */
if|if
condition|(
name|PURPOSE
operator|==
name|DRILL_TRACE
operator|&&
name|qdnssec
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|key_list
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"%s"
argument_list|,
literal|"No trusted keys were given. Will not be able to verify authenticity!"
argument_list|)
expr_stmt|;
block|}
name|PURPOSE
operator|=
name|DRILL_SECTRACE
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns has not been compiled with OpenSSL support. Secure trace not available\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SSL */
block|}
comment|/* parse the arguments, with multiple arguments, the last argument 	 * found is used */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* if ^@ then it's a server */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"%s"
argument_list|,
literal|"No nameserver given"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|serv
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* if has a dot, it's a name */
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* if it matches a type, it's a type */
if|if
condition|(
name|int_type
operator|==
operator|-
literal|1
condition|)
block|{
name|type
operator|=
name|ldns_get_rr_type_by_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|int_type
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* if it matches a class, it's a class */
if|if
condition|(
name|int_clas
operator|==
operator|-
literal|1
condition|)
block|{
name|clas
operator|=
name|ldns_get_rr_class_by_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clas
operator|!=
literal|0
condition|)
block|{
name|int_clas
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* it all fails assume it's a name */
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* act like dig and use for . NS */
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|name
operator|=
literal|"."
expr_stmt|;
name|int_type
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|LDNS_RR_TYPE_NS
expr_stmt|;
block|}
comment|/* defaults if not given */
if|if
condition|(
name|int_clas
operator|==
operator|-
literal|1
condition|)
block|{
name|clas
operator|=
name|LDNS_RR_CLASS_IN
expr_stmt|;
block|}
if|if
condition|(
name|int_type
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|PURPOSE
operator|!=
name|DRILL_REVERSE
condition|)
block|{
name|type
operator|=
name|LDNS_RR_TYPE_A
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|LDNS_RR_TYPE_PTR
expr_stmt|;
block|}
block|}
comment|/* set the nameserver to use */
if|if
condition|(
operator|!
name|serv
condition|)
block|{
comment|/* no server given make a resolver from /etc/resolv.conf */
name|status
operator|=
name|ldns_resolver_new_frm_file
argument_list|(
operator|&
name|res
argument_list|,
name|resolv_conf_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Could not create a resolver structure: %s (%s)\n"
literal|"Try drill @localhost if you have a resolver running on your machine."
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|,
name|resolv_conf_file
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
else|else
block|{
name|res
operator|=
name|ldns_resolver_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|res
operator|||
name|strlen
argument_list|(
name|serv
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Could not create a resolver structure"
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* add the nameserver */
name|serv_rdf
operator|=
name|ldns_rdf_new_addr_frm_str
argument_list|(
name|serv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serv_rdf
condition|)
block|{
comment|/* try to resolv the name if possible */
name|status
operator|=
name|ldns_resolver_new_frm_file
argument_list|(
operator|&
name|cmdline_res
argument_list|,
name|resolv_conf_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"@server ip could not be converted"
argument_list|)
expr_stmt|;
block|}
name|ldns_resolver_set_dnssec
argument_list|(
name|cmdline_res
argument_list|,
name|qdnssec
argument_list|)
expr_stmt|;
name|ldns_resolver_set_ip6
argument_list|(
name|cmdline_res
argument_list|,
name|qfamily
argument_list|)
expr_stmt|;
name|ldns_resolver_set_fallback
argument_list|(
name|cmdline_res
argument_list|,
name|qfallback
argument_list|)
expr_stmt|;
name|ldns_resolver_set_usevc
argument_list|(
name|cmdline_res
argument_list|,
name|qusevc
argument_list|)
expr_stmt|;
name|cmdline_dname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|serv
argument_list|)
expr_stmt|;
name|cmdline_rr_list
operator|=
name|ldns_get_rr_list_addr_by_name
argument_list|(
name|cmdline_res
argument_list|,
name|cmdline_dname
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|cmdline_dname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmdline_rr_list
condition|)
block|{
comment|/* This error msg is not always accurate */
name|error
argument_list|(
literal|"%s `%s\'"
argument_list|,
literal|"could not find any address for the name:"
argument_list|,
name|serv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ldns_resolver_push_nameserver_rr_list
argument_list|(
name|res
argument_list|,
name|cmdline_rr_list
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"pushing nameserver"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|ldns_resolver_push_nameserver
argument_list|(
name|res
argument_list|,
name|serv_rdf
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"pushing nameserver"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_rdf_deep_free
argument_list|(
name|serv_rdf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set the resolver options */
name|ldns_resolver_set_port
argument_list|(
name|res
argument_list|,
name|qport
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|5
condition|)
block|{
name|ldns_resolver_set_debug
argument_list|(
name|res
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_resolver_set_debug
argument_list|(
name|res
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|ldns_resolver_set_dnssec
argument_list|(
name|res
argument_list|,
name|qdnssec
argument_list|)
expr_stmt|;
comment|/*	ldns_resolver_set_dnssec_cd(res, qdnssec);*/
name|ldns_resolver_set_ip6
argument_list|(
name|res
argument_list|,
name|qfamily
argument_list|)
expr_stmt|;
name|ldns_resolver_set_fallback
argument_list|(
name|res
argument_list|,
name|qfallback
argument_list|)
expr_stmt|;
name|ldns_resolver_set_usevc
argument_list|(
name|res
argument_list|,
name|qusevc
argument_list|)
expr_stmt|;
name|ldns_resolver_set_random
argument_list|(
name|res
argument_list|,
name|qrandom
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbuf
operator|!=
literal|0
condition|)
block|{
name|ldns_resolver_set_edns_udp_size
argument_list|(
name|res
argument_list|,
name|qbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|name
operator|&&
name|PURPOSE
operator|!=
name|DRILL_AFROMFILE
operator|&&
operator|!
name|query_file
condition|)
block|{
name|usage
argument_list|(
name|stdout
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|tsig_name
operator|&&
name|tsig_data
condition|)
block|{
name|ldns_resolver_set_tsig_keyname
argument_list|(
name|res
argument_list|,
name|tsig_name
argument_list|)
expr_stmt|;
name|ldns_resolver_set_tsig_keydata
argument_list|(
name|res
argument_list|,
name|tsig_data
argument_list|)
expr_stmt|;
name|ldns_resolver_set_tsig_algorithm
argument_list|(
name|res
argument_list|,
name|tsig_algorithm
argument_list|)
expr_stmt|;
block|}
comment|/* main switching part of drill */
switch|switch
condition|(
name|PURPOSE
condition|)
block|{
case|case
name|DRILL_TRACE
case|:
comment|/* do a trace from the root down */
if|if
condition|(
operator|!
name|global_dns_root
condition|)
block|{
name|init_root
argument_list|()
expr_stmt|;
block|}
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qname
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"parsing query name"
argument_list|)
expr_stmt|;
block|}
comment|/* don't care about return packet */
operator|(
name|void
operator|)
name|do_trace
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|)
expr_stmt|;
name|clear_root
argument_list|()
expr_stmt|;
break|break;
case|case
name|DRILL_SECTRACE
case|:
comment|/* do a secure trace from the root down */
if|if
condition|(
operator|!
name|global_dns_root
condition|)
block|{
name|init_root
argument_list|()
expr_stmt|;
block|}
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qname
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"making qname"
argument_list|)
expr_stmt|;
block|}
comment|/* don't care about return packet */
ifdef|#
directive|ifdef
name|HAVE_SSL
name|result
operator|=
name|do_secure_trace
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|,
name|key_list
argument_list|,
name|trace_start_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SSL */
name|clear_root
argument_list|()
expr_stmt|;
break|break;
case|case
name|DRILL_CHASE
case|:
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qname
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"making qname"
argument_list|)
expr_stmt|;
block|}
name|ldns_resolver_set_dnssec
argument_list|(
name|res
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ldns_resolver_set_dnssec_cd
argument_list|(
name|res
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* set dnssec implies udp_size of 4096 */
name|ldns_resolver_set_edns_udp_size
argument_list|(
name|res
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|ldns_resolver_query
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkt
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"error pkt sending"
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|3
condition|)
block|{
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ldns_pkt_answer
argument_list|(
name|pkt
argument_list|)
condition|)
block|{
name|mesg
argument_list|(
literal|"No answer in packet"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|ldns_resolver_set_dnssec_anchors
argument_list|(
name|res
argument_list|,
name|ldns_rr_list_clone
argument_list|(
name|key_list
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|do_chase
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|,
name|key_list
argument_list|,
name|pkt
argument_list|,
name|qflags
argument_list|,
name|NULL
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|mesg
argument_list|(
literal|"Chase successful"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|mesg
argument_list|(
literal|"Chase failed."
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_SSL */
block|}
name|ldns_pkt_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DRILL_AFROMFILE
case|:
name|pkt
operator|=
name|read_hex_pkt
argument_list|(
name|answer_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
name|ldns_pkt_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DRILL_QTOFILE
case|:
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qname
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"making qname"
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|ldns_resolver_prepare_query_pkt
argument_list|(
operator|&
name|qpkt
argument_list|,
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"making query: %s"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dump_hex
argument_list|(
name|qpkt
argument_list|,
name|query_file
argument_list|)
expr_stmt|;
name|ldns_pkt_free
argument_list|(
name|qpkt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRILL_NSEC
case|:
break|break;
case|case
name|DRILL_REVERSE
case|:
comment|/* ipv4 or ipv6 addr? */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Syntax error: both '.' and ':' seen in address\n"
argument_list|)
expr_stmt|;
block|}
name|name2
operator|=
name|malloc
argument_list|(
name|IP6_ARPA_MAX_LEN
operator|+
literal|20
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|IP6_ARPA_MAX_LEN
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"reverse argument to long"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|&&
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|":: not supported (yet)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|==
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|||
name|name
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|3
operator|==
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|||
name|name
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|':'
condition|)
block|{
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|4
operator|==
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|||
name|name
index|[
name|i
operator|+
literal|4
index|]
operator|==
literal|':'
condition|)
block|{
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|name2
index|[
name|c
operator|++
index|]
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
name|name2
index|[
name|c
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|qname_tmp
operator|=
name|ldns_dname_reverse
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|qname
operator|=
name|qname_tmp
expr_stmt|;
name|qname_tmp
operator|=
name|ldns_dname_new_frm_str
argument_list|(
literal|"ip6.arpa."
argument_list|)
expr_stmt|;
name|status
operator|=
name|ldns_dname_cat
argument_list|(
name|qname
argument_list|,
name|qname_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"could not create reverse address for ip6: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ldns_rdf_deep_free
argument_list|(
name|qname_tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|qname_tmp
operator|=
name|ldns_dname_reverse
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|qname
operator|=
name|qname_tmp
expr_stmt|;
name|qname_tmp
operator|=
name|ldns_dname_new_frm_str
argument_list|(
literal|"in-addr.arpa."
argument_list|)
expr_stmt|;
name|status
operator|=
name|ldns_dname_cat
argument_list|(
name|qname
argument_list|,
name|qname_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"could not create reverse address for ip4: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ldns_rdf_deep_free
argument_list|(
name|qname_tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qname
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"-x implies an ip address"
argument_list|)
expr_stmt|;
block|}
comment|/* create a packet and set the RD flag on it */
name|pkt
operator|=
name|ldns_resolver_query
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkt
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"pkt sending"
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
name|ldns_pkt_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DRILL_QUERY
case|:
default|default:
if|if
condition|(
name|query_file
condition|)
block|{
comment|/* this old way, the query packet needed 				   to be parseable, but we want to be able 				   to send mangled packets, so we need 				   to do it directly */
if|#
directive|if
literal|0
block|qpkt = read_hex_pkt(query_file); 				if (qpkt) { 					status = ldns_resolver_send_pkt(&pkt, res, qpkt); 					if (status != LDNS_STATUS_OK) { 						printf("Error: %s\n", ldns_get_errorstr_by_id(status)); 						exit(1); 					} 				} else {
comment|/* qpkt was bogus, reset pkt */
block|pkt = NULL; 				}
endif|#
directive|endif
name|query_buffer
operator|=
name|read_hex_buffer
argument_list|(
name|query_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_buffer
condition|)
block|{
name|status
operator|=
name|ldns_send_buffer
argument_list|(
operator|&
name|pkt
argument_list|,
name|res
argument_list|,
name|query_buffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|query_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|printf
argument_list|(
literal|"Error: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"NO BUFFER\n"
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qname
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
literal|"error in making qname"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_AXFR
condition|)
block|{
name|status
operator|=
name|ldns_axfr_start
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|clas
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"Error starting axfr: %s"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|axfr_rr
operator|=
name|ldns_axfr_next
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|axfr_rr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AXFR failed.\n"
argument_list|)
expr_stmt|;
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|ldns_axfr_last_pkt
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
while|while
condition|(
name|axfr_rr
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|ldns_rr_print
argument_list|(
name|stdout
argument_list|,
name|axfr_rr
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_free
argument_list|(
name|axfr_rr
argument_list|)
expr_stmt|;
name|axfr_rr
operator|=
name|ldns_axfr_next
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit
goto|;
block|}
else|else
block|{
comment|/* create a packet and set the RD flag on it */
name|pkt
operator|=
name|ldns_resolver_query
argument_list|(
name|res
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|clas
argument_list|,
name|qflags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pkt
condition|)
block|{
name|mesg
argument_list|(
literal|"No packet received"
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_pkt_tc
argument_list|(
name|pkt
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n;; WARNING: The answer packet was truncated; you might want to\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|";; query again with TCP (-t argument), or EDNS0 (-b for buffer size)\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qds
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|print_ds_of_keys
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|key_list
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* -k's were given on the cmd line */
name|ldns_rr_list
modifier|*
name|rrset_verified
decl_stmt|;
name|uint16_t
name|key_count
decl_stmt|;
name|rrset_verified
operator|=
name|ldns_pkt_rr_list_by_name_and_type
argument_list|(
name|pkt
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|LDNS_SECTION_ANY_NOQUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LDNS_RR_TYPE_ANY
condition|)
block|{
comment|/* don't verify this */
break|break;
block|}
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|ldns_rr_list_print
argument_list|(
name|stdout
argument_list|,
name|rrset_verified
argument_list|)
expr_stmt|;
block|}
comment|/* verify */
ifdef|#
directive|ifdef
name|HAVE_SSL
name|key_verified
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|result
operator|=
name|ldns_pkt_verify
argument_list|(
name|pkt
argument_list|,
name|type
argument_list|,
name|qname
argument_list|,
name|key_list
argument_list|,
name|NULL
argument_list|,
name|key_verified
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|LDNS_STATUS_ERR
condition|)
block|{
comment|/* is the existence denied then? */
name|result
operator|=
name|ldns_verify_denial
argument_list|(
name|pkt
argument_list|,
name|qname
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Existence denied for "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|type_str
operator|=
name|ldns_rr_type2str
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|type_str
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|type_str
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Bad data; RR for name and "
literal|"type not found or failed to "
literal|"verify, and denial of "
literal|"existence failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
for|for
control|(
name|key_count
operator|=
literal|0
init|;
name|key_count
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|key_verified
argument_list|)
condition|;
name|key_count
operator|++
control|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"; VALIDATED by id = %u, owner = "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_calc_keytag
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|key_verified
argument_list|,
name|key_count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|ldns_rr_owner
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|key_list
argument_list|,
name|key_count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|key_count
operator|=
literal|0
init|;
name|key_count
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|key_count
operator|++
control|)
block|{
if|if
condition|(
name|verbosity
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"; %s for id = %u, owner = "
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|result
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_calc_keytag
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|key_list
argument_list|,
name|key_count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|ldns_rr_owner
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|key_list
argument_list|,
name|key_count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ldns_rr_list_free
argument_list|(
name|key_verified
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|key_count
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SSL */
block|}
if|if
condition|(
name|answer_file
condition|)
block|{
name|dump_hex
argument_list|(
name|pkt
argument_list|,
name|answer_file
argument_list|)
expr_stmt|;
block|}
name|ldns_pkt_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|exit
label|:
name|ldns_rdf_deep_free
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|ldns_resolver_deep_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|ldns_resolver_deep_free
argument_list|(
name|cmdline_res
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|key_list
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|cmdline_rr_list
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|trace_start_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tsig_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tsig_data
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tsig_algorithm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
name|ERR_remove_state
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|CRYPTO_cleanup_all_ex_data
argument_list|()
expr_stmt|;
name|ERR_free_strings
argument_list|()
expr_stmt|;
name|EVP_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

end_unit

