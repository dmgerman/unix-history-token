begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * work.c  * Where all the hard work is done  * (c) 2005 NLnet Labs  *  * See the file LICENSE for the license  *  */
end_comment

begin_include
include|#
directive|include
file|"drill.h"
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_comment
comment|/**  * Converts a hex string to binary data  * len is the length of the string  * buf is the buffer to store the result in  * offset is the starting position in the result buffer  *  * This function returns the length of the result  */
end_comment

begin_function
name|size_t
name|hexstr2bin
parameter_list|(
name|char
modifier|*
name|hexstr
parameter_list|,
name|int
name|len
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|buf_len
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|int8
init|=
literal|0
decl_stmt|;
name|int
name|sec
init|=
literal|0
decl_stmt|;
name|size_t
name|bufpos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|hexstr
index|[
name|i
index|]
expr_stmt|;
comment|/* case insensitive, skip spaces */
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|int8
operator|+=
name|c
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
block|{
name|int8
operator|+=
operator|(
name|c
operator|&
literal|0x0f
operator|)
operator|+
literal|9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
block|{
name|int8
operator|+=
operator|(
name|c
operator|&
literal|0x0f
operator|)
operator|+
literal|9
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sec
operator|==
literal|0
condition|)
block|{
name|int8
operator|=
name|int8
operator|<<
literal|4
expr_stmt|;
name|sec
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bufpos
operator|+
name|offset
operator|+
literal|1
operator|<=
name|buf_len
condition|)
block|{
name|buf
index|[
name|bufpos
operator|+
name|offset
index|]
operator|=
name|int8
expr_stmt|;
name|int8
operator|=
literal|0
expr_stmt|;
name|sec
operator|=
literal|0
expr_stmt|;
name|bufpos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Buffer too small in hexstr2bin"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|bufpos
return|;
block|}
end_function

begin_function
name|size_t
name|packetbuffromfile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|uint8_t
modifier|*
name|wire
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* stat hack 	 * 0 = normal 	 * 1 = comment (skip to end of line) 	 * 2 = unprintable character found, read binary data directly 	 */
name|int
name|state
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|hexbuf
init|=
name|xmalloc
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
decl_stmt|;
name|int
name|hexbufpos
init|=
literal|0
decl_stmt|;
name|size_t
name|wirelen
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to open file for reading"
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*verbose("Opened %s\n", filename);*/
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|hexbufpos
operator|<
name|LDNS_MAX_PACKETLEN
condition|)
block|{
if|if
condition|(
name|state
operator|<
literal|2
operator|&&
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/*verbose("non ascii character found in file: (%d) switching to raw mode\n", c);*/
name|state
operator|=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
condition|)
block|{
name|hexbuf
index|[
name|hexbufpos
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|c
expr_stmt|;
name|hexbufpos
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* skip whitespace */
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|hexbuf
index|[
name|hexbufpos
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|c
expr_stmt|;
name|hexbufpos
operator|++
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* 		if (have_drill_opt&& drill_opt->verbose) { 			verbose("END OF FILE REACHED\n"); 			if (state< 2) { 				verbose("read:\n"); 				verbose("%s\n", hexbuf); 			} else { 				verbose("Not printing wire because it contains non ascii data\n"); 			} 		} 		*/
block|}
if|if
condition|(
name|hexbufpos
operator|>=
name|LDNS_MAX_PACKETLEN
condition|)
block|{
comment|/*verbose("packet size reached\n");*/
block|}
comment|/* lenient mode: length must be multiple of 2 */
if|if
condition|(
name|hexbufpos
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|hexbuf
index|[
name|hexbufpos
index|]
operator|=
operator|(
name|uint8_t
operator|)
literal|'0'
expr_stmt|;
name|hexbufpos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|<
literal|2
condition|)
block|{
name|wirelen
operator|=
name|hexstr2bin
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hexbuf
argument_list|,
name|hexbufpos
argument_list|,
name|wire
argument_list|,
literal|0
argument_list|,
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|wire
argument_list|,
name|hexbuf
argument_list|,
operator|(
name|size_t
operator|)
name|hexbufpos
argument_list|)
expr_stmt|;
name|wirelen
operator|=
operator|(
name|size_t
operator|)
name|hexbufpos
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
return|return
name|wirelen
return|;
block|}
end_function

begin_function
name|ldns_buffer
modifier|*
name|read_hex_buffer
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|uint8_t
modifier|*
name|wire
decl_stmt|;
name|size_t
name|wiresize
decl_stmt|;
name|ldns_buffer
modifier|*
name|result_buffer
init|=
name|NULL
decl_stmt|;
name|wire
operator|=
name|xmalloc
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
name|wiresize
operator|=
name|packetbuffromfile
argument_list|(
name|filename
argument_list|,
name|wire
argument_list|)
expr_stmt|;
name|result_buffer
operator|=
name|LDNS_MALLOC
argument_list|(
name|ldns_buffer
argument_list|)
expr_stmt|;
name|ldns_buffer_new_frm_data
argument_list|(
name|result_buffer
argument_list|,
name|wire
argument_list|,
name|wiresize
argument_list|)
expr_stmt|;
name|ldns_buffer_set_position
argument_list|(
name|result_buffer
argument_list|,
name|ldns_buffer_capacity
argument_list|(
name|result_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|wire
argument_list|)
expr_stmt|;
return|return
name|result_buffer
return|;
block|}
end_function

begin_function
name|ldns_pkt
modifier|*
name|read_hex_pkt
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|uint8_t
modifier|*
name|wire
decl_stmt|;
name|size_t
name|wiresize
decl_stmt|;
name|ldns_pkt
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
name|ldns_status
name|status
init|=
name|LDNS_STATUS_ERR
decl_stmt|;
name|wire
operator|=
name|xmalloc
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
name|wiresize
operator|=
name|packetbuffromfile
argument_list|(
name|filename
argument_list|,
name|wire
argument_list|)
expr_stmt|;
if|if
condition|(
name|wiresize
operator|>
literal|0
condition|)
block|{
name|status
operator|=
name|ldns_wire2pkt
argument_list|(
operator|&
name|pkt
argument_list|,
name|wire
argument_list|,
name|wiresize
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|wire
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|pkt
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error parsing hex file: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|void
name|dump_hex
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|uint8_t
modifier|*
name|wire
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to open %s for writing"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|ldns_pkt2wire
argument_list|(
operator|&
name|wire
argument_list|,
name|pkt
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|error
argument_list|(
literal|"Unable to convert packet: error code %u"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|wire
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"; 0"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %2u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";--"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" --"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|20
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t;\t%4u-%4u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
operator|-
literal|19
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|wire
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|wire
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

