begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file contains routines to manage the work-share queue for a team    of threads.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Create a new work share structure.  */
end_comment

begin_function
name|struct
name|gomp_work_share
modifier|*
name|gomp_new_work_share
parameter_list|(
name|bool
name|ordered
parameter_list|,
name|unsigned
name|nthreads
parameter_list|)
block|{
name|struct
name|gomp_work_share
modifier|*
name|ws
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|ordered
condition|)
name|size
operator|+=
name|nthreads
operator|*
sizeof|sizeof
argument_list|(
name|ws
operator|->
name|ordered_team_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ws
operator|=
name|gomp_malloc_cleared
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|gomp_mutex_init
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ws
operator|->
name|ordered_owner
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ws
return|;
block|}
end_function

begin_comment
comment|/* Free a work share structure.  */
end_comment

begin_function
specifier|static
name|void
name|free_work_share
parameter_list|(
name|struct
name|gomp_work_share
modifier|*
name|ws
parameter_list|)
block|{
name|gomp_mutex_destroy
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The current thread is ready to begin the next work sharing construct.    In all cases, thr->ts.work_share is updated to point to the new    structure.  In all cases the work_share lock is locked.  Return true    if this was the first thread to reach this point.  */
end_comment

begin_function
name|bool
name|gomp_work_share_start
parameter_list|(
name|bool
name|ordered
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
decl_stmt|;
name|unsigned
name|ws_index
decl_stmt|,
name|ws_gen
decl_stmt|;
comment|/* Work sharing constructs can be orphaned.  */
if|if
condition|(
name|team
operator|==
name|NULL
condition|)
block|{
name|ws
operator|=
name|gomp_new_work_share
argument_list|(
name|ordered
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|ws
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|gomp_mutex_lock
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
comment|/* This thread is beginning its next generation.  */
name|ws_gen
operator|=
operator|++
name|thr
operator|->
name|ts
operator|.
name|work_share_generation
expr_stmt|;
comment|/* If this next generation is not newer than any other generation in      the team, then simply reference the existing construct.  */
if|if
condition|(
name|ws_gen
operator|-
name|team
operator|->
name|oldest_live_gen
operator|<
name|team
operator|->
name|num_live_gen
condition|)
block|{
name|ws_index
operator|=
name|ws_gen
operator|&
name|team
operator|->
name|generation_mask
expr_stmt|;
name|ws
operator|=
name|team
operator|->
name|work_shares
index|[
name|ws_index
index|]
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|ws
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Resize the work shares queue if we've run out of space.  */
if|if
condition|(
name|team
operator|->
name|num_live_gen
operator|++
operator|==
name|team
operator|->
name|generation_mask
condition|)
block|{
name|team
operator|->
name|work_shares
operator|=
name|gomp_realloc
argument_list|(
name|team
operator|->
name|work_shares
argument_list|,
literal|2
operator|*
name|team
operator|->
name|num_live_gen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|team
operator|->
name|work_shares
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless oldest_live_gen is zero, the sequence of live elements 	 wraps around the end of the array.  If we do nothing, we break 	 lookup of the existing elements.  Fix that by unwrapping the 	 data from the front to the end.  */
if|if
condition|(
name|team
operator|->
name|oldest_live_gen
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|team
operator|->
name|work_shares
operator|+
name|team
operator|->
name|num_live_gen
argument_list|,
name|team
operator|->
name|work_shares
argument_list|,
operator|(
name|team
operator|->
name|oldest_live_gen
operator|&
name|team
operator|->
name|generation_mask
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|team
operator|->
name|work_shares
argument_list|)
argument_list|)
expr_stmt|;
name|team
operator|->
name|generation_mask
operator|=
name|team
operator|->
name|generation_mask
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
name|ws_index
operator|=
name|ws_gen
operator|&
name|team
operator|->
name|generation_mask
expr_stmt|;
name|ws
operator|=
name|gomp_new_work_share
argument_list|(
name|ordered
argument_list|,
name|team
operator|->
name|nthreads
argument_list|)
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|ws
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
name|team
operator|->
name|work_shares
index|[
name|ws_index
index|]
operator|=
name|ws
expr_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The current thread is done with its current work sharing construct.    This version does imply a barrier at the end of the work-share.  */
end_comment

begin_function
name|void
name|gomp_work_share_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|NULL
expr_stmt|;
comment|/* Work sharing constructs can be orphaned.  */
if|if
condition|(
name|team
operator|==
name|NULL
condition|)
block|{
name|free_work_share
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|gomp_barrier_wait_start
argument_list|(
operator|&
name|team
operator|->
name|barrier
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|unsigned
name|ws_index
decl_stmt|;
name|ws_index
operator|=
name|thr
operator|->
name|ts
operator|.
name|work_share_generation
operator|&
name|team
operator|->
name|generation_mask
expr_stmt|;
name|team
operator|->
name|work_shares
index|[
name|ws_index
index|]
operator|=
name|NULL
expr_stmt|;
name|team
operator|->
name|oldest_live_gen
operator|++
expr_stmt|;
name|team
operator|->
name|num_live_gen
operator|=
literal|0
expr_stmt|;
name|free_work_share
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
name|gomp_barrier_wait_end
argument_list|(
operator|&
name|team
operator|->
name|barrier
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The current thread is done with its current work sharing construct.    This version does NOT imply a barrier at the end of the work-share.  */
end_comment

begin_function
name|void
name|gomp_work_share_end_nowait
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|unsigned
name|completed
decl_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|NULL
expr_stmt|;
comment|/* Work sharing constructs can be orphaned.  */
if|if
condition|(
name|team
operator|==
name|NULL
condition|)
block|{
name|free_work_share
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
name|completed
operator|=
name|__sync_add_and_fetch
argument_list|(
operator|&
name|ws
operator|->
name|threads_completed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|gomp_mutex_lock
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
name|completed
operator|=
operator|++
name|ws
operator|->
name|threads_completed
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|ws
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|completed
operator|==
name|team
operator|->
name|nthreads
condition|)
block|{
name|unsigned
name|ws_index
decl_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
name|ws_index
operator|=
name|thr
operator|->
name|ts
operator|.
name|work_share_generation
operator|&
name|team
operator|->
name|generation_mask
expr_stmt|;
name|team
operator|->
name|work_shares
index|[
name|ws_index
index|]
operator|=
name|NULL
expr_stmt|;
name|team
operator|->
name|oldest_live_gen
operator|++
expr_stmt|;
name|team
operator|->
name|num_live_gen
operator|--
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
name|free_work_share
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

