begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file defines the OpenMP internal control variables, and arranges    for them to be initialized from environment variables at startup.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|"libgomp_f.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|unsigned
name|long
name|gomp_nthreads_var
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|gomp_dyn_var
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|gomp_nest_var
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|gomp_schedule_type
name|gomp_run_sched_var
init|=
name|GFS_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|gomp_run_sched_chunk
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
modifier|*
name|gomp_cpu_affinity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|gomp_cpu_affinity_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the OMP_SCHEDULE environment variable.  */
end_comment

begin_function
specifier|static
name|void
name|parse_schedule
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"OMP_SCHEDULE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"static"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gomp_run_sched_var
operator|=
name|GFS_STATIC
expr_stmt|;
name|env
operator|+=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"dynamic"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gomp_run_sched_var
operator|=
name|GFS_DYNAMIC
expr_stmt|;
name|env
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"guided"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gomp_run_sched_var
operator|=
name|GFS_GUIDED
expr_stmt|;
name|env
operator|+=
literal|6
expr_stmt|;
block|}
else|else
goto|goto
name|unknown
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
operator|*
name|env
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|unknown
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|strtoul
argument_list|(
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
goto|goto
name|invalid
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
argument_list|)
condition|)
operator|++
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|gomp_run_sched_chunk
operator|=
name|value
expr_stmt|;
return|return;
name|unknown
label|:
name|gomp_error
argument_list|(
literal|"Unknown value for environment variable OMP_SCHEDULE"
argument_list|)
expr_stmt|;
return|return;
name|invalid
label|:
name|gomp_error
argument_list|(
literal|"Invalid value for chunk size in "
literal|"environment variable OMP_SCHEDULE"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse an unsigned long environment varible.  Return true if one was    present and it was successfully parsed.  */
end_comment

begin_function
specifier|static
name|bool
name|parse_unsigned_long
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
modifier|*
name|pvalue
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
name|false
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|strtoul
argument_list|(
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|long
operator|)
name|value
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
argument_list|)
condition|)
operator|++
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
operator|*
name|pvalue
operator|=
name|value
expr_stmt|;
return|return
name|true
return|;
name|invalid
label|:
name|gomp_error
argument_list|(
literal|"Invalid value for environment variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Parse a boolean value for environment variable NAME and store the     result in VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|parse_boolean
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"true"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|true
expr_stmt|;
name|env
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|env
argument_list|,
literal|"false"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|false
expr_stmt|;
name|env
operator|+=
literal|5
expr_stmt|;
block|}
else|else
name|env
operator|=
literal|"X"
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|env
argument_list|)
condition|)
operator|++
name|env
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|!=
literal|'\0'
condition|)
name|gomp_error
argument_list|(
literal|"Invalid value for environment variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the GOMP_CPU_AFFINITY environment varible.  Return true if one was    present and it was successfully parsed.  */
end_comment

begin_function
specifier|static
name|bool
name|parse_affinity
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|cpu_beg
decl_stmt|,
name|cpu_end
decl_stmt|,
name|cpu_stride
decl_stmt|;
name|unsigned
name|short
modifier|*
name|cpus
init|=
name|NULL
decl_stmt|;
name|size_t
name|allocated
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|,
name|needed
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"GOMP_CPU_AFFINITY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
name|false
return|;
do|do
block|{
while|while
condition|(
operator|*
name|env
operator|==
literal|' '
operator|||
operator|*
name|env
operator|==
literal|'\t'
condition|)
name|env
operator|++
expr_stmt|;
name|cpu_beg
operator|=
name|strtoul
argument_list|(
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_end
operator|=
name|cpu_beg
expr_stmt|;
name|cpu_stride
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|end
operator|||
name|cpu_beg
operator|>=
literal|65536
condition|)
goto|goto
name|invalid
goto|;
name|env
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'-'
condition|)
block|{
name|cpu_end
operator|=
name|strtoul
argument_list|(
operator|++
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|end
operator|||
name|cpu_end
operator|>=
literal|65536
operator|||
name|cpu_end
operator|<
name|cpu_beg
condition|)
goto|goto
name|invalid
goto|;
name|env
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|':'
condition|)
block|{
name|cpu_stride
operator|=
name|strtoul
argument_list|(
operator|++
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|end
operator|||
name|cpu_stride
operator|==
literal|0
operator|||
name|cpu_stride
operator|>=
literal|65536
condition|)
goto|goto
name|invalid
goto|;
name|env
operator|=
name|end
expr_stmt|;
block|}
block|}
name|needed
operator|=
operator|(
name|cpu_end
operator|-
name|cpu_beg
operator|)
operator|/
name|cpu_stride
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|used
operator|+
name|needed
operator|>=
name|allocated
condition|)
block|{
name|unsigned
name|short
modifier|*
name|new_cpus
decl_stmt|;
if|if
condition|(
name|allocated
operator|<
literal|64
condition|)
name|allocated
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|allocated
operator|>
name|needed
condition|)
name|allocated
operator|<<=
literal|1
expr_stmt|;
else|else
name|allocated
operator|+=
literal|2
operator|*
name|needed
expr_stmt|;
name|new_cpus
operator|=
name|realloc
argument_list|(
name|cpus
argument_list|,
name|allocated
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_cpus
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cpus
argument_list|)
expr_stmt|;
name|gomp_error
argument_list|(
literal|"not enough memory to store GOMP_CPU_AFFINITY list"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|cpus
operator|=
name|new_cpus
expr_stmt|;
block|}
while|while
condition|(
name|needed
operator|--
condition|)
block|{
name|cpus
index|[
name|used
operator|++
index|]
operator|=
name|cpu_beg
expr_stmt|;
name|cpu_beg
operator|+=
name|cpu_stride
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|env
operator|==
literal|' '
operator|||
operator|*
name|env
operator|==
literal|'\t'
condition|)
name|env
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|','
condition|)
name|env
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|gomp_cpu_affinity
operator|=
name|cpus
expr_stmt|;
name|gomp_cpu_affinity_len
operator|=
name|used
expr_stmt|;
return|return
name|true
return|;
name|invalid
label|:
name|gomp_error
argument_list|(
literal|"Invalid value for enviroment variable GOMP_CPU_AFFINITY"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|constructor
operator|)
argument_list|)
name|initialize_env
argument_list|(
name|void
argument_list|)
block|{
name|unsigned
name|long
name|stacksize
decl_stmt|;
comment|/* Do a compile time check that mkomp_h.pl did good job.  */
name|omp_check_defines
argument_list|()
expr_stmt|;
name|parse_schedule
argument_list|()
expr_stmt|;
name|parse_boolean
argument_list|(
literal|"OMP_DYNAMIC"
argument_list|,
operator|&
name|gomp_dyn_var
argument_list|)
expr_stmt|;
name|parse_boolean
argument_list|(
literal|"OMP_NESTED"
argument_list|,
operator|&
name|gomp_nest_var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_unsigned_long
argument_list|(
literal|"OMP_NUM_THREADS"
argument_list|,
operator|&
name|gomp_nthreads_var
argument_list|)
condition|)
name|gomp_init_num_threads
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse_affinity
argument_list|()
condition|)
name|gomp_init_affinity
argument_list|()
expr_stmt|;
comment|/* Not strictly environment related, but ordering constructors is tricky.  */
name|pthread_attr_init
argument_list|(
operator|&
name|gomp_thread_attr
argument_list|)
expr_stmt|;
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|gomp_thread_attr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_unsigned_long
argument_list|(
literal|"GOMP_STACKSIZE"
argument_list|,
operator|&
name|stacksize
argument_list|)
condition|)
block|{
name|int
name|err
decl_stmt|;
name|stacksize
operator|*=
literal|1024
expr_stmt|;
name|err
operator|=
name|pthread_attr_setstacksize
argument_list|(
operator|&
name|gomp_thread_attr
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTHREAD_STACK_MIN
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
block|{
if|if
condition|(
name|stacksize
operator|<
name|PTHREAD_STACK_MIN
condition|)
name|gomp_error
argument_list|(
literal|"Stack size less than minimum of %luk"
argument_list|,
name|PTHREAD_STACK_MIN
operator|/
literal|1024ul
operator|+
operator|(
name|PTHREAD_STACK_MIN
operator|%
literal|1024
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
else|else
name|gomp_error
argument_list|(
literal|"Stack size larger than system limit"
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|gomp_error
argument_list|(
literal|"Stack size change failed: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The public OpenMP API routines that access these variables.  */
end_comment

begin_function
name|void
name|omp_set_num_threads
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|gomp_nthreads_var
operator|=
operator|(
name|n
operator|>
literal|0
condition|?
name|n
else|:
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|omp_set_dynamic
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|gomp_dyn_var
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|int
name|omp_get_dynamic
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gomp_dyn_var
return|;
block|}
end_function

begin_function
name|void
name|omp_set_nested
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|gomp_nest_var
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|int
name|omp_get_nested
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gomp_nest_var
return|;
block|}
end_function

begin_macro
name|ialias
argument_list|(
argument|omp_set_dynamic
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_set_nested
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_set_num_threads
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_get_dynamic
argument_list|)
end_macro

begin_macro
name|ialias
argument_list|(
argument|omp_get_nested
argument_list|)
end_macro

end_unit

