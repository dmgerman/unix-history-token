begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file handles the maintainence of threads in response to team    creation and termination.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* This array manages threads spawned from the top level, which will    return to the idle loop once the current PARALLEL construct ends.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gomp_thread
modifier|*
modifier|*
name|gomp_threads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|gomp_threads_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|gomp_threads_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This attribute contains PTHREAD_CREATE_DETACHED.  */
end_comment

begin_decl_stmt
name|pthread_attr_t
name|gomp_thread_attr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This barrier holds and releases threads waiting in gomp_threads.  */
end_comment

begin_decl_stmt
specifier|static
name|gomp_barrier_t
name|gomp_threads_dock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the libgomp per-thread data structure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TLS
end_ifdef

begin_decl_stmt
name|__thread
name|struct
name|gomp_thread
name|gomp_tls_data
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|pthread_key_t
name|gomp_tls_key
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure is used to communicate across pthread_create.  */
end_comment

begin_struct
struct|struct
name|gomp_thread_start_data
block|{
name|struct
name|gomp_team_state
name|ts
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|fn_data
decl_stmt|;
name|bool
name|nested
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This function is a pthread_create entry point.  This contains the idle    loop in which a thread waits to be called up to become part of a team.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|gomp_thread_start
parameter_list|(
name|void
modifier|*
name|xdata
parameter_list|)
block|{
name|struct
name|gomp_thread_start_data
modifier|*
name|data
init|=
name|xdata
decl_stmt|;
name|struct
name|gomp_thread
modifier|*
name|thr
decl_stmt|;
name|void
function_decl|(
modifier|*
name|local_fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|local_data
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TLS
name|thr
operator|=
operator|&
name|gomp_tls_data
expr_stmt|;
else|#
directive|else
name|struct
name|gomp_thread
name|local_thr
decl_stmt|;
name|thr
operator|=
operator|&
name|local_thr
expr_stmt|;
name|pthread_setspecific
argument_list|(
name|gomp_tls_key
argument_list|,
name|thr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gomp_sem_init
argument_list|(
operator|&
name|thr
operator|->
name|release
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Extract what we need from data.  */
name|local_fn
operator|=
name|data
operator|->
name|fn
expr_stmt|;
name|local_data
operator|=
name|data
operator|->
name|fn_data
expr_stmt|;
name|thr
operator|->
name|ts
operator|=
name|data
operator|->
name|ts
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|team
operator|->
name|ordered_release
index|[
name|thr
operator|->
name|ts
operator|.
name|team_id
index|]
operator|=
operator|&
name|thr
operator|->
name|release
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|nested
condition|)
block|{
name|gomp_barrier_wait
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|team
operator|->
name|barrier
argument_list|)
expr_stmt|;
name|local_fn
argument_list|(
name|local_data
argument_list|)
expr_stmt|;
name|gomp_barrier_wait
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|team
operator|->
name|barrier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gomp_threads
index|[
name|thr
operator|->
name|ts
operator|.
name|team_id
index|]
operator|=
name|thr
expr_stmt|;
name|gomp_barrier_wait
argument_list|(
operator|&
name|gomp_threads_dock
argument_list|)
expr_stmt|;
do|do
block|{
name|struct
name|gomp_team
modifier|*
name|team
decl_stmt|;
name|local_fn
argument_list|(
name|local_data
argument_list|)
expr_stmt|;
comment|/* Clear out the team and function data.  This is a debugging 	     signal that we're in fact back in the dock.  */
name|team
operator|=
name|thr
operator|->
name|ts
operator|.
name|team
expr_stmt|;
name|thr
operator|->
name|fn
operator|=
name|NULL
expr_stmt|;
name|thr
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|team
operator|=
name|NULL
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|NULL
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|team_id
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share_generation
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
name|gomp_barrier_wait
argument_list|(
operator|&
name|team
operator|->
name|barrier
argument_list|)
expr_stmt|;
name|gomp_barrier_wait
argument_list|(
operator|&
name|gomp_threads_dock
argument_list|)
expr_stmt|;
name|local_fn
operator|=
name|thr
operator|->
name|fn
expr_stmt|;
name|local_data
operator|=
name|thr
operator|->
name|data
expr_stmt|;
block|}
do|while
condition|(
name|local_fn
condition|)
do|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create a new team data structure.  */
end_comment

begin_function
specifier|static
name|struct
name|gomp_team
modifier|*
name|new_team
parameter_list|(
name|unsigned
name|nthreads
parameter_list|,
name|struct
name|gomp_work_share
modifier|*
name|work_share
parameter_list|)
block|{
name|struct
name|gomp_team
modifier|*
name|team
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|team
argument_list|)
operator|+
name|nthreads
operator|*
sizeof|sizeof
argument_list|(
name|team
operator|->
name|ordered_release
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|team
operator|=
name|gomp_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|gomp_mutex_init
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
name|team
operator|->
name|work_shares
operator|=
name|gomp_malloc
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gomp_work_share
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|team
operator|->
name|generation_mask
operator|=
literal|3
expr_stmt|;
name|team
operator|->
name|oldest_live_gen
operator|=
name|work_share
operator|==
name|NULL
expr_stmt|;
name|team
operator|->
name|num_live_gen
operator|=
name|work_share
operator|!=
name|NULL
expr_stmt|;
name|team
operator|->
name|work_shares
index|[
literal|0
index|]
operator|=
name|work_share
expr_stmt|;
name|team
operator|->
name|nthreads
operator|=
name|nthreads
expr_stmt|;
name|gomp_barrier_init
argument_list|(
operator|&
name|team
operator|->
name|barrier
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
name|gomp_sem_init
argument_list|(
operator|&
name|team
operator|->
name|master_release
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|team
operator|->
name|ordered_release
index|[
literal|0
index|]
operator|=
operator|&
name|team
operator|->
name|master_release
expr_stmt|;
return|return
name|team
return|;
block|}
end_function

begin_comment
comment|/* Free a team data structure.  */
end_comment

begin_function
specifier|static
name|void
name|free_team
parameter_list|(
name|struct
name|gomp_team
modifier|*
name|team
parameter_list|)
block|{
name|free
argument_list|(
name|team
operator|->
name|work_shares
argument_list|)
expr_stmt|;
name|gomp_mutex_destroy
argument_list|(
operator|&
name|team
operator|->
name|work_share_lock
argument_list|)
expr_stmt|;
name|gomp_barrier_destroy
argument_list|(
operator|&
name|team
operator|->
name|barrier
argument_list|)
expr_stmt|;
name|gomp_sem_destroy
argument_list|(
operator|&
name|team
operator|->
name|master_release
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|team
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Launch a team.  */
end_comment

begin_function
name|void
name|gomp_team_start
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|nthreads
parameter_list|,
name|struct
name|gomp_work_share
modifier|*
name|work_share
parameter_list|)
block|{
name|struct
name|gomp_thread_start_data
modifier|*
name|start_data
decl_stmt|;
name|struct
name|gomp_thread
modifier|*
name|thr
decl_stmt|,
modifier|*
name|nthr
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
decl_stmt|;
name|bool
name|nested
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|,
name|old_threads_used
init|=
literal|0
decl_stmt|;
name|thr
operator|=
name|gomp_thread
argument_list|()
expr_stmt|;
name|nested
operator|=
name|thr
operator|->
name|ts
operator|.
name|team
operator|!=
name|NULL
expr_stmt|;
name|team
operator|=
name|new_team
argument_list|(
name|nthreads
argument_list|,
name|work_share
argument_list|)
expr_stmt|;
comment|/* Always save the previous state, even if this isn't a nested team.      In particular, we should save any work share state from an outer      orphaned work share construct.  */
name|team
operator|->
name|prev_ts
operator|=
name|thr
operator|->
name|ts
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|team
operator|=
name|team
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|work_share
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|team_id
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|work_share_generation
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nthreads
operator|==
literal|1
condition|)
return|return;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* We only allow the reuse of idle threads for non-nested PARALLEL      regions.  This appears to be implied by the semantics of      threadprivate variables, but perhaps that's reading too much into      things.  Certainly it does prevent any locking problems, since      only the initial program thread will modify gomp_threads.  */
if|if
condition|(
operator|!
name|nested
condition|)
block|{
name|old_threads_used
operator|=
name|gomp_threads_used
expr_stmt|;
if|if
condition|(
name|nthreads
operator|<=
name|old_threads_used
condition|)
name|n
operator|=
name|nthreads
expr_stmt|;
elseif|else
if|if
condition|(
name|old_threads_used
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|gomp_barrier_init
argument_list|(
operator|&
name|gomp_threads_dock
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|old_threads_used
expr_stmt|;
comment|/* Increase the barrier threshold to make sure all new 	     threads arrive before the team is released.  */
name|gomp_barrier_reinit
argument_list|(
operator|&
name|gomp_threads_dock
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
block|}
comment|/* Not true yet, but soon will be.  We're going to release all 	 threads from the dock, and those that aren't part of the  	 team will exit.  */
name|gomp_threads_used
operator|=
name|nthreads
expr_stmt|;
comment|/* Release existing idle threads.  */
for|for
control|(
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|nthr
operator|=
name|gomp_threads
index|[
name|i
index|]
expr_stmt|;
name|nthr
operator|->
name|ts
operator|.
name|team
operator|=
name|team
expr_stmt|;
name|nthr
operator|->
name|ts
operator|.
name|work_share
operator|=
name|work_share
expr_stmt|;
name|nthr
operator|->
name|ts
operator|.
name|team_id
operator|=
name|i
expr_stmt|;
name|nthr
operator|->
name|ts
operator|.
name|work_share_generation
operator|=
literal|0
expr_stmt|;
name|nthr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
name|nthr
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|nthr
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|team
operator|->
name|ordered_release
index|[
name|i
index|]
operator|=
operator|&
name|nthr
operator|->
name|release
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|nthreads
condition|)
goto|goto
name|do_release
goto|;
comment|/* If necessary, expand the size of the gomp_threads array.  It is 	 expected that changes in the number of threads is rare, thus we 	 make no effort to expand gomp_threads_size geometrically.  */
if|if
condition|(
name|nthreads
operator|>=
name|gomp_threads_size
condition|)
block|{
name|gomp_threads_size
operator|=
name|nthreads
operator|+
literal|1
expr_stmt|;
name|gomp_threads
operator|=
name|gomp_realloc
argument_list|(
name|gomp_threads
argument_list|,
name|gomp_threads_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gomp_thread_data
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|start_data
operator|=
name|gomp_alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gomp_thread_start_data
argument_list|)
operator|*
operator|(
name|nthreads
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Launch new threads.  */
for|for
control|(
init|;
name|i
operator|<
name|nthreads
condition|;
operator|++
name|i
operator|,
operator|++
name|start_data
control|)
block|{
name|pthread_t
name|pt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|start_data
operator|->
name|ts
operator|.
name|team
operator|=
name|team
expr_stmt|;
name|start_data
operator|->
name|ts
operator|.
name|work_share
operator|=
name|work_share
expr_stmt|;
name|start_data
operator|->
name|ts
operator|.
name|team_id
operator|=
name|i
expr_stmt|;
name|start_data
operator|->
name|ts
operator|.
name|work_share_generation
operator|=
literal|0
expr_stmt|;
name|start_data
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|0
expr_stmt|;
name|start_data
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|start_data
operator|->
name|fn_data
operator|=
name|data
expr_stmt|;
name|start_data
operator|->
name|nested
operator|=
name|nested
expr_stmt|;
name|err
operator|=
name|pthread_create
argument_list|(
operator|&
name|pt
argument_list|,
operator|&
name|gomp_thread_attr
argument_list|,
name|gomp_thread_start
argument_list|,
name|start_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|gomp_fatal
argument_list|(
literal|"Thread creation failed: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_release
label|:
name|gomp_barrier_wait
argument_list|(
name|nested
condition|?
operator|&
name|team
operator|->
name|barrier
else|:
operator|&
name|gomp_threads_dock
argument_list|)
expr_stmt|;
comment|/* Decrease the barrier threshold to match the number of threads      that should arrive back at the end of this team.  The extra      threads should be exiting.  Note that we arrange for this test      to never be true for nested teams.  */
if|if
condition|(
name|nthreads
operator|<
name|old_threads_used
condition|)
name|gomp_barrier_reinit
argument_list|(
operator|&
name|gomp_threads_dock
argument_list|,
name|nthreads
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate the current team.  This is only to be called by the master    thread.  We assume that we must wait for the other threads.  */
end_comment

begin_function
name|void
name|gomp_team_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|gomp_barrier_wait
argument_list|(
operator|&
name|team
operator|->
name|barrier
argument_list|)
expr_stmt|;
name|thr
operator|->
name|ts
operator|=
name|team
operator|->
name|prev_ts
expr_stmt|;
name|free_team
argument_list|(
name|team
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Constructors for this file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|constructor
operator|)
argument_list|)
name|initialize_team
argument_list|(
name|void
argument_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_TLS
specifier|static
name|struct
name|gomp_thread
name|initial_thread_tls_data
decl_stmt|;
name|pthread_key_create
argument_list|(
operator|&
name|gomp_tls_key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_setspecific
argument_list|(
name|gomp_tls_key
argument_list|,
operator|&
name|initial_thread_tls_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TLS
name|thr
operator|=
operator|&
name|gomp_tls_data
expr_stmt|;
else|#
directive|else
name|thr
operator|=
operator|&
name|initial_thread_tls_data
expr_stmt|;
endif|#
directive|endif
name|gomp_sem_init
argument_list|(
operator|&
name|thr
operator|->
name|release
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

