begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file handles the ORDERED construct.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_comment
comment|/* This function is called when first allocating an iteration block.  That    is, the thread is not currently on the queue.  The work-share lock must    be held on entry.  */
end_comment

begin_function
name|void
name|gomp_ordered_first
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|unsigned
name|index
decl_stmt|;
comment|/* Work share constructs can be orphaned.  */
if|if
condition|(
name|team
operator|==
name|NULL
operator|||
name|team
operator|->
name|nthreads
operator|==
literal|1
condition|)
return|return;
name|index
operator|=
name|ws
operator|->
name|ordered_cur
operator|+
name|ws
operator|->
name|ordered_num_used
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|team
operator|->
name|nthreads
condition|)
name|index
operator|-=
name|team
operator|->
name|nthreads
expr_stmt|;
name|ws
operator|->
name|ordered_team_ids
index|[
name|index
index|]
operator|=
name|thr
operator|->
name|ts
operator|.
name|team_id
expr_stmt|;
comment|/* If this is the first and only thread in the queue, then there is      no one to release us when we get to our ordered section.  Post to      our own release queue now so that we won't block later.  */
if|if
condition|(
name|ws
operator|->
name|ordered_num_used
operator|++
operator|==
literal|0
condition|)
name|gomp_sem_post
argument_list|(
name|team
operator|->
name|ordered_release
index|[
name|thr
operator|->
name|ts
operator|.
name|team_id
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when completing the last iteration block.  That    is, there are no more iterations to perform and so the thread should be    removed from the queue entirely.  Because of the way ORDERED blocks are    managed, it follows that we currently own access to the ORDERED block,    and should now pass it on to the next thread.  The work-share lock must    be held on entry.  */
end_comment

begin_function
name|void
name|gomp_ordered_last
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|unsigned
name|next_id
decl_stmt|;
comment|/* Work share constructs can be orphaned.  */
if|if
condition|(
name|team
operator|==
name|NULL
operator|||
name|team
operator|->
name|nthreads
operator|==
literal|1
condition|)
return|return;
comment|/* We're no longer the owner.  */
name|ws
operator|->
name|ordered_owner
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we're not the last thread in the queue, then wake the next.  */
if|if
condition|(
operator|--
name|ws
operator|->
name|ordered_num_used
operator|>
literal|0
condition|)
block|{
name|unsigned
name|next
init|=
name|ws
operator|->
name|ordered_cur
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|team
operator|->
name|nthreads
condition|)
name|next
operator|=
literal|0
expr_stmt|;
name|ws
operator|->
name|ordered_cur
operator|=
name|next
expr_stmt|;
name|next_id
operator|=
name|ws
operator|->
name|ordered_team_ids
index|[
name|next
index|]
expr_stmt|;
name|gomp_sem_post
argument_list|(
name|team
operator|->
name|ordered_release
index|[
name|next_id
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called when allocating a subsequent allocation block.    That is, we're done with the current iteration block and we're allocating    another.  This is the logical combination of a call to gomp_ordered_last    followed by a call to gomp_ordered_first.  The work-share lock must be    held on entry. */
end_comment

begin_function
name|void
name|gomp_ordered_next
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|unsigned
name|index
decl_stmt|,
name|next_id
decl_stmt|;
comment|/* Work share constructs can be orphaned.  */
if|if
condition|(
name|team
operator|==
name|NULL
operator|||
name|team
operator|->
name|nthreads
operator|==
literal|1
condition|)
return|return;
comment|/* We're no longer the owner.  */
name|ws
operator|->
name|ordered_owner
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If there's only one thread in the queue, that must be us.  */
if|if
condition|(
name|ws
operator|->
name|ordered_num_used
operator|==
literal|1
condition|)
block|{
comment|/* We have a similar situation as in gomp_ordered_first 	 where we need to post to our own release semaphore.  */
name|gomp_sem_post
argument_list|(
name|team
operator|->
name|ordered_release
index|[
name|thr
operator|->
name|ts
operator|.
name|team_id
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the queue is entirely full, then we move ourself to the end of       the queue merely by incrementing ordered_cur.  Only if it's not       full do we have to write our id.  */
if|if
condition|(
name|ws
operator|->
name|ordered_num_used
operator|<
name|team
operator|->
name|nthreads
condition|)
block|{
name|index
operator|=
name|ws
operator|->
name|ordered_cur
operator|+
name|ws
operator|->
name|ordered_num_used
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|team
operator|->
name|nthreads
condition|)
name|index
operator|-=
name|team
operator|->
name|nthreads
expr_stmt|;
name|ws
operator|->
name|ordered_team_ids
index|[
name|index
index|]
operator|=
name|thr
operator|->
name|ts
operator|.
name|team_id
expr_stmt|;
block|}
name|index
operator|=
name|ws
operator|->
name|ordered_cur
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|team
operator|->
name|nthreads
condition|)
name|index
operator|=
literal|0
expr_stmt|;
name|ws
operator|->
name|ordered_cur
operator|=
name|index
expr_stmt|;
name|next_id
operator|=
name|ws
operator|->
name|ordered_team_ids
index|[
name|index
index|]
expr_stmt|;
name|gomp_sem_post
argument_list|(
name|team
operator|->
name|ordered_release
index|[
name|next_id
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when a statically scheduled loop is first    being created.  */
end_comment

begin_function
name|void
name|gomp_ordered_static_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
if|if
condition|(
name|team
operator|==
name|NULL
operator|||
name|team
operator|->
name|nthreads
operator|==
literal|1
condition|)
return|return;
name|gomp_sem_post
argument_list|(
name|team
operator|->
name|ordered_release
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when a statically scheduled loop is moving to    the next allocation block.  Static schedules are not first come first    served like the others, so we're to move to the numerically next thread,    not the next thread on a list.  The work-share lock should *not* be held    on entry.  */
end_comment

begin_function
name|void
name|gomp_ordered_static_next
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|unsigned
name|id
init|=
name|thr
operator|->
name|ts
operator|.
name|team_id
decl_stmt|;
if|if
condition|(
name|team
operator|==
name|NULL
operator|||
name|team
operator|->
name|nthreads
operator|==
literal|1
condition|)
return|return;
name|ws
operator|->
name|ordered_owner
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This thread currently owns the lock.  Increment the owner.  */
if|if
condition|(
operator|++
name|id
operator|==
name|team
operator|->
name|nthreads
condition|)
name|id
operator|=
literal|0
expr_stmt|;
name|ws
operator|->
name|ordered_team_ids
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
name|gomp_sem_post
argument_list|(
name|team
operator|->
name|ordered_release
index|[
name|id
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when we need to assert that the thread owns the    ordered section.  Due to the problem of posted-but-not-waited semaphores,    this needs to happen before completing a loop iteration.  */
end_comment

begin_function
name|void
name|gomp_ordered_sync
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
comment|/* Work share constructs can be orphaned.  But this clearly means that      we are the only thread, and so we automatically own the section.  */
if|if
condition|(
name|team
operator|==
name|NULL
operator|||
name|team
operator|->
name|nthreads
operator|==
literal|1
condition|)
return|return;
comment|/* ??? I believe it to be safe to access this data without taking the      ws->lock.  The only presumed race condition is with the previous      thread on the queue incrementing ordered_cur such that it points      to us, concurrently with our check below.  But our team_id is      already present in the queue, and the other thread will always      post to our release semaphore.  So the two cases are that we will      either win the race an momentarily block on the semaphore, or lose      the race and find the semaphore already unlocked and so not block.      Either way we get correct results.  */
if|if
condition|(
name|ws
operator|->
name|ordered_owner
operator|!=
name|thr
operator|->
name|ts
operator|.
name|team_id
condition|)
block|{
name|gomp_sem_wait
argument_list|(
name|team
operator|->
name|ordered_release
index|[
name|thr
operator|->
name|ts
operator|.
name|team_id
index|]
argument_list|)
expr_stmt|;
name|ws
operator|->
name|ordered_owner
operator|=
name|thr
operator|->
name|ts
operator|.
name|team_id
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called by user code when encountering the start of an    ORDERED block.  We must check to see if the current thread is at the    head of the queue, and if not, block.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTRIBUTE_ALIAS
end_ifdef

begin_function_decl
specifier|extern
name|void
name|GOMP_ordered_start
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(alias
parameter_list|(
function_decl|"gomp_ordered_sync"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|GOMP_ordered_start
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_ordered_sync
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called by user code when encountering the end of an    ORDERED block.  With the current ORDERED implementation there's nothing    for us to do.     However, the current implementation has a flaw in that it does not allow    the next thread into the ORDERED section immediately after the current    thread exits the ORDERED section in its last iteration.  The existance    of this function allows the implementation to change.  */
end_comment

begin_function
name|void
name|GOMP_ordered_end
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

