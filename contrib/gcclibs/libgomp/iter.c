begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file contains routines for managing work-share iteration, both    for loops and sections.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* This function implements the STATIC scheduling method.  The caller should    iterate *pstart<= x< *pend.  Return zero if there are more iterations    to perform; nonzero if not.  Return less than 0 if this thread had    received the absolutely last iteration.  */
end_comment

begin_function
name|int
name|gomp_iter_static_next
parameter_list|(
name|long
modifier|*
name|pstart
parameter_list|,
name|long
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|unsigned
name|long
name|nthreads
init|=
name|team
condition|?
name|team
operator|->
name|nthreads
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Quick test for degenerate teams and orphaned constructs.  */
if|if
condition|(
name|nthreads
operator|==
literal|1
condition|)
block|{
operator|*
name|pstart
operator|=
name|ws
operator|->
name|next
expr_stmt|;
operator|*
name|pend
operator|=
name|ws
operator|->
name|end
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ws
operator|->
name|next
operator|==
name|ws
operator|->
name|end
return|;
block|}
comment|/* We interpret chunk_size zero as "unspecified", which means that we      should break up the iterations such that each thread makes only one      trip through the outer loop.  */
if|if
condition|(
name|ws
operator|->
name|chunk_size
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|n
decl_stmt|,
name|q
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|s0
decl_stmt|,
name|e0
decl_stmt|;
name|long
name|s
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|>
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Compute the total number of iterations.  */
name|s
operator|=
name|ws
operator|->
name|incr
operator|+
operator|(
name|ws
operator|->
name|incr
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|n
operator|=
operator|(
name|ws
operator|->
name|end
operator|-
name|ws
operator|->
name|next
operator|+
name|s
operator|)
operator|/
name|ws
operator|->
name|incr
expr_stmt|;
name|i
operator|=
name|thr
operator|->
name|ts
operator|.
name|team_id
expr_stmt|;
comment|/* Compute the "zero-based" start and end points.  That is, as          if the loop began at zero and incremented by one.  */
name|q
operator|=
name|n
operator|/
name|nthreads
expr_stmt|;
name|q
operator|+=
operator|(
name|q
operator|*
name|nthreads
operator|!=
name|n
operator|)
expr_stmt|;
name|s0
operator|=
name|q
operator|*
name|i
expr_stmt|;
name|e0
operator|=
name|s0
operator|+
name|q
expr_stmt|;
if|if
condition|(
name|e0
operator|>
name|n
condition|)
name|e0
operator|=
name|n
expr_stmt|;
comment|/* Notice when no iterations allocated for this thread.  */
if|if
condition|(
name|s0
operator|>=
name|e0
condition|)
block|{
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Transform these to the actual start and end numbers.  */
name|s
operator|=
operator|(
name|long
operator|)
name|s0
operator|*
name|ws
operator|->
name|incr
operator|+
name|ws
operator|->
name|next
expr_stmt|;
name|e
operator|=
operator|(
name|long
operator|)
name|e0
operator|*
name|ws
operator|->
name|incr
operator|+
name|ws
operator|->
name|next
expr_stmt|;
operator|*
name|pstart
operator|=
name|s
expr_stmt|;
operator|*
name|pend
operator|=
name|e
expr_stmt|;
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
operator|(
name|e0
operator|==
name|n
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|unsigned
name|long
name|n
decl_stmt|,
name|s0
decl_stmt|,
name|e0
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|long
name|s
decl_stmt|,
name|e
decl_stmt|;
comment|/* Otherwise, each thread gets exactly chunk_size iterations 	 (if available) each time through the loop.  */
name|s
operator|=
name|ws
operator|->
name|incr
operator|+
operator|(
name|ws
operator|->
name|incr
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|n
operator|=
operator|(
name|ws
operator|->
name|end
operator|-
name|ws
operator|->
name|next
operator|+
name|s
operator|)
operator|/
name|ws
operator|->
name|incr
expr_stmt|;
name|i
operator|=
name|thr
operator|->
name|ts
operator|.
name|team_id
expr_stmt|;
name|c
operator|=
name|ws
operator|->
name|chunk_size
expr_stmt|;
comment|/* Initial guess is a C sized chunk positioned nthreads iterations 	 in, offset by our thread number.  */
name|s0
operator|=
operator|(
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|*
name|nthreads
operator|+
name|i
operator|)
operator|*
name|c
expr_stmt|;
name|e0
operator|=
name|s0
operator|+
name|c
expr_stmt|;
comment|/* Detect overflow.  */
if|if
condition|(
name|s0
operator|>=
name|n
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|e0
operator|>
name|n
condition|)
name|e0
operator|=
name|n
expr_stmt|;
comment|/* Transform these to the actual start and end numbers.  */
name|s
operator|=
operator|(
name|long
operator|)
name|s0
operator|*
name|ws
operator|->
name|incr
operator|+
name|ws
operator|->
name|next
expr_stmt|;
name|e
operator|=
operator|(
name|long
operator|)
name|e0
operator|*
name|ws
operator|->
name|incr
operator|+
name|ws
operator|->
name|next
expr_stmt|;
operator|*
name|pstart
operator|=
name|s
expr_stmt|;
operator|*
name|pend
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|e0
operator|==
name|n
condition|)
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|thr
operator|->
name|ts
operator|.
name|static_trip
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function implements the DYNAMIC scheduling method.  Arguments are    as for gomp_iter_static_next.  This function must be called with ws->lock    held.  */
end_comment

begin_function
name|bool
name|gomp_iter_dynamic_next_locked
parameter_list|(
name|long
modifier|*
name|pstart
parameter_list|,
name|long
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|long
name|start
decl_stmt|,
name|end
decl_stmt|,
name|chunk
decl_stmt|,
name|left
decl_stmt|;
name|start
operator|=
name|ws
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|ws
operator|->
name|end
condition|)
return|return
name|false
return|;
name|chunk
operator|=
name|ws
operator|->
name|chunk_size
operator|*
name|ws
operator|->
name|incr
expr_stmt|;
name|left
operator|=
name|ws
operator|->
name|end
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|ws
operator|->
name|incr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|chunk
operator|<
name|left
condition|)
name|chunk
operator|=
name|left
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chunk
operator|>
name|left
condition|)
name|chunk
operator|=
name|left
expr_stmt|;
block|}
name|end
operator|=
name|start
operator|+
name|chunk
expr_stmt|;
name|ws
operator|->
name|next
operator|=
name|end
expr_stmt|;
operator|*
name|pstart
operator|=
name|start
expr_stmt|;
operator|*
name|pend
operator|=
name|end
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
end_ifdef

begin_comment
comment|/* Similar, but doesn't require the lock held, and uses compare-and-swap    instead.  Note that the only memory value that changes is ws->next.  */
end_comment

begin_function
name|bool
name|gomp_iter_dynamic_next
parameter_list|(
name|long
modifier|*
name|pstart
parameter_list|,
name|long
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|long
name|start
decl_stmt|,
name|end
decl_stmt|,
name|nend
decl_stmt|,
name|chunk
decl_stmt|,
name|incr
decl_stmt|;
name|start
operator|=
name|ws
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|ws
operator|->
name|end
expr_stmt|;
name|incr
operator|=
name|ws
operator|->
name|incr
expr_stmt|;
name|chunk
operator|=
name|ws
operator|->
name|chunk_size
operator|*
name|incr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|left
init|=
name|end
operator|-
name|start
decl_stmt|;
name|long
name|tmp
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
name|false
return|;
if|if
condition|(
name|incr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|chunk
operator|<
name|left
condition|)
name|chunk
operator|=
name|left
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chunk
operator|>
name|left
condition|)
name|chunk
operator|=
name|left
expr_stmt|;
block|}
name|nend
operator|=
name|start
operator|+
name|chunk
expr_stmt|;
name|tmp
operator|=
name|__sync_val_compare_and_swap
argument_list|(
operator|&
name|ws
operator|->
name|next
argument_list|,
name|start
argument_list|,
name|nend
argument_list|)
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|tmp
operator|==
name|start
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|start
operator|=
name|tmp
expr_stmt|;
block|}
operator|*
name|pstart
operator|=
name|start
expr_stmt|;
operator|*
name|pend
operator|=
name|nend
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYNC_BUILTINS */
end_comment

begin_comment
comment|/* This function implements the GUIDED scheduling method.  Arguments are    as for gomp_iter_static_next.  This function must be called with the    work share lock held.  */
end_comment

begin_function
name|bool
name|gomp_iter_guided_next_locked
parameter_list|(
name|long
modifier|*
name|pstart
parameter_list|,
name|long
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|unsigned
name|long
name|nthreads
init|=
name|team
condition|?
name|team
operator|->
name|nthreads
else|:
literal|1
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|,
name|q
decl_stmt|;
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|ws
operator|->
name|next
operator|==
name|ws
operator|->
name|end
condition|)
return|return
name|false
return|;
name|n
operator|=
operator|(
name|ws
operator|->
name|end
operator|-
name|ws
operator|->
name|next
operator|)
operator|/
name|ws
operator|->
name|incr
expr_stmt|;
name|q
operator|=
operator|(
name|n
operator|+
name|nthreads
operator|-
literal|1
operator|)
operator|/
name|nthreads
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|ws
operator|->
name|chunk_size
condition|)
name|q
operator|=
name|ws
operator|->
name|chunk_size
expr_stmt|;
if|if
condition|(
name|q
operator|>
name|n
condition|)
name|q
operator|=
name|n
expr_stmt|;
name|start
operator|=
name|ws
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|q
operator|*
name|ws
operator|->
name|incr
expr_stmt|;
name|ws
operator|->
name|next
operator|=
name|end
expr_stmt|;
operator|*
name|pstart
operator|=
name|start
expr_stmt|;
operator|*
name|pend
operator|=
name|end
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
end_ifdef

begin_comment
comment|/* Similar, but doesn't require the lock held, and uses compare-and-swap    instead.  Note that the only memory value that changes is ws->next.  */
end_comment

begin_function
name|bool
name|gomp_iter_guided_next
parameter_list|(
name|long
modifier|*
name|pstart
parameter_list|,
name|long
modifier|*
name|pend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|struct
name|gomp_work_share
modifier|*
name|ws
init|=
name|thr
operator|->
name|ts
operator|.
name|work_share
decl_stmt|;
name|struct
name|gomp_team
modifier|*
name|team
init|=
name|thr
operator|->
name|ts
operator|.
name|team
decl_stmt|;
name|unsigned
name|long
name|nthreads
init|=
name|team
condition|?
name|team
operator|->
name|nthreads
else|:
literal|1
decl_stmt|;
name|long
name|start
decl_stmt|,
name|end
decl_stmt|,
name|nend
decl_stmt|,
name|incr
decl_stmt|;
name|unsigned
name|long
name|chunk_size
decl_stmt|;
name|start
operator|=
name|ws
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|ws
operator|->
name|end
expr_stmt|;
name|incr
operator|=
name|ws
operator|->
name|incr
expr_stmt|;
name|chunk_size
operator|=
name|ws
operator|->
name|chunk_size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|long
name|n
decl_stmt|,
name|q
decl_stmt|;
name|long
name|tmp
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
name|false
return|;
name|n
operator|=
operator|(
name|end
operator|-
name|start
operator|)
operator|/
name|ws
operator|->
name|incr
expr_stmt|;
name|q
operator|=
operator|(
name|n
operator|+
name|nthreads
operator|-
literal|1
operator|)
operator|/
name|nthreads
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|chunk_size
condition|)
name|q
operator|=
name|chunk_size
expr_stmt|;
if|if
condition|(
name|q
operator|>
name|n
condition|)
name|q
operator|=
name|n
expr_stmt|;
name|nend
operator|=
name|start
operator|+
name|q
operator|*
name|incr
expr_stmt|;
name|tmp
operator|=
name|__sync_val_compare_and_swap
argument_list|(
operator|&
name|ws
operator|->
name|next
argument_list|,
name|start
argument_list|,
name|nend
argument_list|)
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|tmp
operator|==
name|start
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|start
operator|=
name|tmp
expr_stmt|;
block|}
operator|*
name|pstart
operator|=
name|start
expr_stmt|;
operator|*
name|pend
operator|=
name|nend
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYNC_BUILTINS */
end_comment

end_unit

