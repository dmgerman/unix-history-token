begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  Generic MSDOS specialization.    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_ERRNO
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/* The structure we keep in obj->sysdep.  */
end_comment

begin_define
define|#
directive|define
name|PEX_MSDOS_FILE_COUNT
value|3
end_define

begin_define
define|#
directive|define
name|PEX_MSDOS_FD_OFFSET
value|10
end_define

begin_struct
struct|struct
name|pex_msdos
block|{
comment|/* An array of file names.  We refer to these using file descriptors      of 10 + array index.  */
specifier|const
name|char
modifier|*
name|files
index|[
name|PEX_MSDOS_FILE_COUNT
index|]
decl_stmt|;
comment|/* Exit statuses of programs which have been run.  */
name|int
modifier|*
name|statuses
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|pex_msdos_open
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_msdos_open
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_msdos_fdindex
parameter_list|(
name|struct
name|pex_msdos
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|pex_msdos_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_msdos_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_msdos_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pex_time
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pex_msdos_cleanup
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The list of functions we pass to the common routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|pex_funcs
name|funcs
init|=
block|{
name|pex_msdos_open
block|,
name|pex_msdos_open
block|,
name|pex_msdos_exec_child
block|,
name|pex_msdos_close
block|,
name|pex_msdos_wait
block|,
name|NULL
block|,
comment|/* pipe */
name|NULL
block|,
comment|/* fdopenr */
name|NULL
block|,
comment|/* fdopenw */
name|pex_msdos_cleanup
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a newly initialized pex_obj structure.  */
end_comment

begin_function
name|struct
name|pex_obj
modifier|*
name|pex_init
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|tempbase
parameter_list|)
block|{
name|struct
name|pex_obj
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* MSDOS does not support pipes.  */
name|flags
operator|&=
operator|~
name|PEX_USE_PIPES
expr_stmt|;
name|ret
operator|=
name|pex_init_common
argument_list|(
name|flags
argument_list|,
name|pname
argument_list|,
name|tempbase
argument_list|,
name|funcs
argument_list|)
expr_stmt|;
name|ret
operator|->
name|sysdep
operator|=
name|XNEW
argument_list|(
expr|struct
name|pex_msdos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEX_MSDOS_FILE_COUNT
condition|;
operator|++
name|i
control|)
name|ret
operator|->
name|files
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|statuses
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Open a file.  FIXME: We ignore the binary argument, since we have    no way to handle it.  */
end_comment

begin_function
specifier|static
name|int
name|pex_msdos_open
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|pex_msdos
modifier|*
name|ms
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ms
operator|=
operator|(
expr|struct
name|pex_msdos
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEX_MSDOS_FILE_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ms
operator|->
name|files
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|ms
operator|->
name|files
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|i
operator|+
name|PEX_MSDOS_FD_OFFSET
return|;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the index into msdos->files associated with an open file    descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|pex_msdos_fdindex
parameter_list|(
name|struct
name|pex_msdos
modifier|*
name|ms
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|fd
operator|-=
name|PEX_MSDOS_FD_OFFSET
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fd
operator|>=
name|PEX_MSDOS_FILE_COUNT
operator|||
name|ms
operator|->
name|files
index|[
name|fd
index|]
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* Close a file.  */
end_comment

begin_function
specifier|static
name|int
name|pex_msdos_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|pex_msdos
modifier|*
name|ms
decl_stmt|;
name|int
name|fdinex
decl_stmt|;
name|ms
operator|=
operator|(
expr|struct
name|pex_msdos
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
name|fdindex
operator|=
name|pe_msdos_fdindex
argument_list|(
name|ms
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ms
operator|->
name|files
index|[
name|fdindex
index|]
argument_list|)
expr_stmt|;
name|ms
operator|->
name|files
index|[
name|fdindex
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute a child.  */
end_comment

begin_function
specifier|static
name|long
name|pex_msdos_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|int
name|toclose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|errdes
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|pex_msdos
modifier|*
name|ms
decl_stmt|;
name|char
modifier|*
name|temp_base
decl_stmt|;
name|int
name|temp_base_allocated
decl_stmt|;
name|char
modifier|*
name|rf
decl_stmt|;
name|int
name|inindex
decl_stmt|;
name|char
modifier|*
name|infile
decl_stmt|;
name|int
name|outindex
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|scmd
decl_stmt|;
name|FILE
modifier|*
name|argfile
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
name|ms
operator|=
operator|(
expr|struct
name|pex_msdos
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
comment|/* FIXME: I don't know how to redirect stderr, so we ignore ERRDES      and PEX_STDERR_TO_STDOUT.  */
name|temp_base
operator|=
name|obj
operator|->
name|temp_base
expr_stmt|;
if|if
condition|(
name|temp_base
operator|!=
name|NULL
condition|)
name|temp_base_allocated
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|temp_base
operator|=
name|choose_temp_base
argument_list|()
expr_stmt|;
name|temp_base_allocated
operator|=
literal|1
expr_stmt|;
block|}
name|rf
operator|=
name|concat
argument_list|(
name|temp_base
argument_list|,
literal|".gp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_base_allocated
condition|)
name|free
argument_list|(
name|temp_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|STDIN_FILE_NO
condition|)
block|{
name|inindex
operator|=
operator|-
literal|1
expr_stmt|;
name|infile
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|inindex
operator|=
name|pex_msdos_fdindex
argument_list|(
name|ms
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|infile
operator|=
name|ms
operator|->
name|files
index|[
name|inindex
index|]
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|==
name|STDOUT_FILE_NO
condition|)
block|{
name|outindex
operator|=
operator|-
literal|1
expr_stmt|;
name|outfile
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|outindex
operator|=
name|pex_msdos_fdindex
argument_list|(
name|ms
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|ms
operator|->
name|files
index|[
name|outindex
index|]
expr_stmt|;
block|}
name|scmd
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
operator|(
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
operator|)
operator|!=
literal|0
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|rf
argument_list|)
operator|+
name|strlen
argument_list|(
name|infile
argument_list|)
operator|+
name|strlen
argument_list|(
name|outfile
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|scmd
argument_list|,
literal|"%s%s @%s%s%s%s%s"
argument_list|,
name|program
argument_list|,
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
operator|)
operator|!=
literal|0
condition|?
literal|".exe"
else|:
literal|""
argument_list|,
name|rf
argument_list|,
name|inindex
operator|!=
operator|-
literal|1
condition|?
literal|"<"
else|:
literal|""
argument_list|,
name|infile
argument_list|,
name|outindex
operator|!=
operator|-
literal|1
condition|?
literal|">"
else|:
literal|""
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|argfile
operator|=
name|fopen
argument_list|(
name|rf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argfile
operator|==
name|NULL
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"cannot open temporary command file"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|||
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|argfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|system
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|remove
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"system"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|remove
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
comment|/* Save the exit status for later.  When we are called, obj->count      is the number of children which have executed before this      one.  */
name|ms
operator|->
name|statuses
operator|=
name|XRESIZEVEC
argument_list|(
name|int
argument_list|,
name|ms
operator|->
name|statuses
argument_list|,
name|obj
operator|->
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ms
operator|->
name|statuses
index|[
name|obj
operator|->
name|count
index|]
operator|=
name|status
expr_stmt|;
return|return
name|obj
operator|->
name|count
return|;
block|}
end_function

begin_comment
comment|/* Wait for a child process to complete.  Actually the child process    has already completed, and we just need to return the exit    status.  */
end_comment

begin_function
specifier|static
name|int
name|pex_msdos_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|,
name|int
name|done
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|err
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|pex_msdos
modifier|*
name|ms
decl_stmt|;
name|ms
operator|=
operator|(
expr|struct
name|pex_msdos
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|time
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|time
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|ms
operator|->
name|statuses
index|[
name|pid
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clean up the pex_msdos structure.  */
end_comment

begin_function
specifier|static
name|void
name|pex_msdos_cleanup
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|pex_msdos
modifier|*
name|ms
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ms
operator|=
operator|(
expr|struct
name|pex_msdos
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEX_MSDOS_FILE_COUNT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|msdos
operator|->
name|files
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|msdos
operator|->
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|msdos
operator|->
name|statuses
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|msdos
operator|->
name|statuses
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msdos
argument_list|)
expr_stmt|;
name|obj
operator|->
name|sysdep
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

