begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Pexecute test program,    Copyright (C) 2005 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@airs.com>.     This file is part of GNU libiberty.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff) != 0&& ((S)& 0xff) != 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|S
parameter_list|)
value|((S)& 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff00)>> 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WSTOPSIG
end_ifndef

begin_define
define|#
directive|define
name|WSTOPSIG
value|WEXITSTATUS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREDUMP
end_ifndef

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|S
parameter_list|)
value|((S)& WCOREFLG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREFLG
end_ifndef

begin_define
define|#
directive|define
name|WCOREFLG
value|0200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_SUCCESS
end_ifndef

begin_define
define|#
directive|define
name|EXIT_SUCCESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_FAILURE
end_ifndef

begin_define
define|#
directive|define
name|EXIT_FAILURE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When this program is run with no arguments, it runs some tests of    the libiberty pexecute functions.  As a test program, it simply    invokes itself with various arguments.     argv[1]:      *empty string*      Run tests, exit with success status      exit                Exit success      error               Exit error      abort               Abort      echo                Echo remaining arguments, exit success      echoerr             Echo next arg to stdout, next to stderr, repeat      copy                Copy stdin to stdout      write               Write stdin to file named in next argument */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fatal_error
argument_list|(
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_line
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|do_cmd
argument_list|(
name|int
argument_list|,
name|char
operator|*
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of errors we have seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a fatal error and exit.  LINE is the line number where we    detected the error, ERRMSG is the error message to print, and ERR    is 0 or an errno value to print.  */
end_comment

begin_function
specifier|static
name|void
name|fatal_error
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"test-pexecute:%d: %s"
argument_list|,
name|line
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|xstrerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FATAL_ERROR
parameter_list|(
name|ERRMSG
parameter_list|,
name|ERR
parameter_list|)
value|fatal_error (__LINE__, ERRMSG, ERR)
end_define

begin_comment
comment|/* Print an error message and bump the error count.  LINE is the line    number where we detected the error, ERRMSG is the error to    print.  */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"test-pexecute:%d: %s\n"
argument_list|,
name|line
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
operator|++
name|error_count
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ERROR
parameter_list|(
name|ERRMSG
parameter_list|)
value|error (__LINE__, ERRMSG)
end_define

begin_comment
comment|/* Check a line in a file.  */
end_comment

begin_function
specifier|static
name|void
name|check_line
parameter_list|(
name|int
name|line
parameter_list|,
name|FILE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"got '%c' when expecting newline"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fatal_error
argument_list|(
name|line
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"got '%c' when expecting EOF"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fatal_error
argument_list|(
name|line
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|c
operator|!=
operator|*
name|p
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"expected '%c', got '%c'"
argument_list|,
operator|*
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fatal_error
argument_list|(
name|line
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CHECK_LINE
parameter_list|(
name|E
parameter_list|,
name|STR
parameter_list|)
value|check_line (__LINE__, E, STR)
end_define

begin_comment
comment|/* Main function for the pexecute tester.  Run the tests.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|trace
decl_stmt|;
name|struct
name|pex_obj
modifier|*
name|test_pex_tmp
decl_stmt|;
name|int
name|test_pex_status
decl_stmt|;
name|FILE
modifier|*
name|test_pex_file
decl_stmt|;
name|struct
name|pex_obj
modifier|*
name|pex1
decl_stmt|;
name|char
modifier|*
name|subargv
index|[
literal|10
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|statuses
index|[
literal|10
index|]
decl_stmt|;
name|trace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-t"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|trace
operator|=
literal|1
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|do_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
define|#
directive|define
name|TEST_PEX_INIT
parameter_list|(
name|FLAGS
parameter_list|,
name|TEMPBASE
parameter_list|)
define|\
value|(((test_pex_tmp = pex_init (FLAGS, "test-pexecute", TEMPBASE))	\     != NULL)								\    ? test_pex_tmp							\    : (FATAL_ERROR ("pex_init failed", 0), NULL))
define|#
directive|define
name|TEST_PEX_RUN
parameter_list|(
name|PEXOBJ
parameter_list|,
name|FLAGS
parameter_list|,
name|EXECUTABLE
parameter_list|,
name|ARGV
parameter_list|,
name|OUTNAME
parameter_list|,
name|ERRNAME
parameter_list|)
define|\
value|do									\     {									\       int err;								\       const char *pex_run_err;						\       if (trace)							\ 	fprintf (stderr, "Line %d: running %s %s\n",			\ 		 __LINE__, EXECUTABLE, ARGV[0]);			\       pex_run_err = pex_run (PEXOBJ, FLAGS, EXECUTABLE, ARGV, OUTNAME,	\ 			     ERRNAME,&err);				\       if (pex_run_err != NULL)						\ 	FATAL_ERROR (pex_run_err, err);					\     }									\   while (0)
define|#
directive|define
name|TEST_PEX_GET_STATUS_1
parameter_list|(
name|PEXOBJ
parameter_list|)
define|\
value|(pex_get_status (PEXOBJ, 1,&test_pex_status)				\    ? test_pex_status							\    : (FATAL_ERROR ("pex_get_status failed", errno), 1))
define|#
directive|define
name|TEST_PEX_GET_STATUS
parameter_list|(
name|PEXOBJ
parameter_list|,
name|COUNT
parameter_list|,
name|VECTOR
parameter_list|)
define|\
value|do									\     {									\       if (!pex_get_status (PEXOBJ, COUNT, VECTOR))			\ 	FATAL_ERROR ("pex_get_status failed", errno);			\     }									\   while (0)
define|#
directive|define
name|TEST_PEX_READ_OUTPUT
parameter_list|(
name|PEXOBJ
parameter_list|)
define|\
value|((test_pex_file = pex_read_output (PEXOBJ, 0)) != NULL		\    ? test_pex_file							\    : (FATAL_ERROR ("pex_read_output failed", errno), NULL))
name|remove
argument_list|(
literal|"temp.x"
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp.y"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|subargv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|subargv
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|0
index|]
operator|=
literal|"./test-pexecute"
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_USE_PIPES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"exit"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_LAST
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|status
operator|=
name|TEST_PEX_GET_STATUS_1
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"exit failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_USE_PIPES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"error"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_LAST
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|status
operator|=
name|TEST_PEX_GET_STATUS_1
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
name|EXIT_FAILURE
condition|)
name|ERROR
argument_list|(
literal|"error test failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
comment|/* We redirect stderr to a file to avoid an error message which is      printed on mingw32 when the child calls abort.  */
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_USE_PIPES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"abort"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_LAST
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
name|NULL
argument_list|,
literal|"temp.z"
argument_list|)
expr_stmt|;
name|status
operator|=
name|TEST_PEX_GET_STATUS_1
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|||
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|!=
name|SIGABRT
condition|)
name|ERROR
argument_list|(
literal|"abort failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp.z"
argument_list|)
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_USE_PIPES
argument_list|,
literal|"temp"
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"echo"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"foo"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
literal|0
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|TEST_PEX_READ_OUTPUT
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"foo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_PEX_GET_STATUS_1
argument_list|(
name|pex1
argument_list|)
operator|!=
literal|0
condition|)
name|ERROR
argument_list|(
literal|"echo exit status failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_USE_PIPES
argument_list|,
literal|"temp"
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"echo"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"bar"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".x"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"copy"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".y"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|TEST_PEX_READ_OUTPUT
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"bar"
argument_list|)
expr_stmt|;
name|TEST_PEX_GET_STATUS
argument_list|(
name|pex1
argument_list|,
literal|2
argument_list|,
name|statuses
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
operator|||
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"copy exit status failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopen
argument_list|(
literal|"temp.x"
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
operator|||
name|fopen
argument_list|(
literal|"temp.y"
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
condition|)
name|ERROR
argument_list|(
literal|"temporary files exist"
argument_list|)
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
literal|0
argument_list|,
literal|"temp"
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"echo"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"bar"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".x"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"copy"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".y"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|TEST_PEX_READ_OUTPUT
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"bar"
argument_list|)
expr_stmt|;
name|TEST_PEX_GET_STATUS
argument_list|(
name|pex1
argument_list|,
literal|2
argument_list|,
name|statuses
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
operator|||
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"copy exit status failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopen
argument_list|(
literal|"temp.x"
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
operator|||
name|fopen
argument_list|(
literal|"temp.y"
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
condition|)
name|ERROR
argument_list|(
literal|"temporary files exist"
argument_list|)
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_SAVE_TEMPS
argument_list|,
literal|"temp"
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"echo"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"quux"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".x"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"copy"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".y"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|TEST_PEX_READ_OUTPUT
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"quux"
argument_list|)
expr_stmt|;
name|TEST_PEX_GET_STATUS
argument_list|(
name|pex1
argument_list|,
literal|2
argument_list|,
name|statuses
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
operator|||
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"copy temp exit status failed"
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"temp.x"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fopen temp.x failed in copy temp"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"quux"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"temp.y"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fopen temp.y failed in copy temp"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"quux"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp.x"
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp.y"
argument_list|)
expr_stmt|;
name|pex1
operator|=
name|TEST_PEX_INIT
argument_list|(
name|PEX_USE_PIPES
argument_list|,
literal|"temp"
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"echoerr"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"one"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
literal|"two"
expr_stmt|;
name|subargv
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".x"
argument_list|,
literal|"temp2.x"
argument_list|)
expr_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"write"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"temp2.y"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|TEST_PEX_RUN
argument_list|(
name|pex1
argument_list|,
name|PEX_SUFFIX
argument_list|,
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|".y"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TEST_PEX_GET_STATUS
argument_list|(
name|pex1
argument_list|,
literal|2
argument_list|,
name|statuses
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
operator|||
operator|!
name|WIFEXITED
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|statuses
index|[
literal|1
index|]
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"echoerr exit status failed"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopen
argument_list|(
literal|"temp.x"
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
operator|||
name|fopen
argument_list|(
literal|"temp.y"
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
condition|)
name|ERROR
argument_list|(
literal|"temporary files exist"
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"temp2.x"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fopen temp2.x failed in echoerr"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"temp2.y"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fopen temp2.y failed in echoerr"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp2.x"
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp2.y"
argument_list|)
expr_stmt|;
comment|/* Test the old pexecute interface.  */
block|{
name|int
name|pid1
decl_stmt|,
name|pid2
decl_stmt|;
name|char
modifier|*
name|errmsg_fmt
decl_stmt|;
name|char
modifier|*
name|errmsg_arg
decl_stmt|;
name|char
name|errbuf1
index|[
literal|1000
index|]
decl_stmt|;
name|char
name|errbuf2
index|[
literal|1000
index|]
decl_stmt|;
name|subargv
index|[
literal|1
index|]
operator|=
literal|"echo"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"oldpexecute"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|pid1
operator|=
name|pexecute
argument_list|(
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|"test-pexecute"
argument_list|,
literal|"temp"
argument_list|,
operator|&
name|errmsg_fmt
argument_list|,
operator|&
name|errmsg_arg
argument_list|,
name|PEXECUTE_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid1
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf1
argument_list|,
sizeof|sizeof
name|errbuf1
argument_list|,
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf2
argument_list|,
sizeof|sizeof
name|errbuf2
argument_list|,
literal|"pexecute 1 failed: %s"
argument_list|,
name|errbuf1
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|errbuf2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|subargv
index|[
literal|1
index|]
operator|=
literal|"write"
expr_stmt|;
name|subargv
index|[
literal|2
index|]
operator|=
literal|"temp.y"
expr_stmt|;
name|subargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|pid2
operator|=
name|pexecute
argument_list|(
literal|"./test-pexecute"
argument_list|,
name|subargv
argument_list|,
literal|"test-pexecute"
argument_list|,
literal|"temp"
argument_list|,
operator|&
name|errmsg_fmt
argument_list|,
operator|&
name|errmsg_arg
argument_list|,
name|PEXECUTE_LAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid2
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf1
argument_list|,
sizeof|sizeof
name|errbuf1
argument_list|,
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf2
argument_list|,
sizeof|sizeof
name|errbuf2
argument_list|,
literal|"pexecute 2 failed: %s"
argument_list|,
name|errbuf1
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|errbuf2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwait
argument_list|(
name|pid1
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
literal|"write pwait 1 failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"write exit status 1 failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwait
argument_list|(
name|pid2
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
literal|"write pwait 1 failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
name|ERROR
argument_list|(
literal|"write exit status 2 failed"
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"temp.y"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fopen temp.y failed in copy temp"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|CHECK_LINE
argument_list|(
name|e
argument_list|,
literal|"oldpexecute"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|remove
argument_list|(
literal|"temp.y"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exiting with status %d\n"
argument_list|,
name|error_count
argument_list|)
expr_stmt|;
return|return
name|error_count
return|;
block|}
end_function

begin_comment
comment|/* Execute one of the special testing commands.  */
end_comment

begin_function
specifier|static
name|void
name|do_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Try to prevent generating a core dump.  */
ifdef|#
directive|ifdef
name|RLIMIT_CORE
block|{
name|struct
name|rlimit
name|r
decl_stmt|;
name|r
operator|.
name|rlim_cur
operator|=
literal|0
expr_stmt|;
name|r
operator|.
name|rlim_max
operator|=
literal|0
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"exit"
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|2
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"echoerr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|3
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
name|stdout
else|:
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
name|stdout
else|:
name|stderr
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"abort"
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"copy"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"write"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|c
decl_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fopen for write failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
literal|"fclose for write failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"unrecognized command %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

