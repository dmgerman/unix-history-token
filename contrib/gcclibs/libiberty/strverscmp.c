begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compare strings while treating digits characters numerically.    Copyright (C) 1997, 2002, 2005 Free Software Foundation, Inc.    This file is part of the libiberty library.    Contributed by Jean-Fran√ßois Bignolles<bignolle@ecoledoc.ibp.fr>, 1997.     Libiberty is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     Libiberty is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, write to the Free    Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301 USA.  */
end_comment

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/*  @deftypefun int strverscmp (const char *@var{s1}, const char *@var{s2}) The @code{strverscmp} function compares the string @var{s1} against @var{s2}, considering them as holding indices/version numbers.  Return value follows the same conventions as found in the @code{strverscmp} function.  In fact, if @var{s1} and @var{s2} contain no digits, @code{strverscmp} behaves like @code{strcmp}.  Basically, we compare strings normally (character by character), until we find a digit in each string - then we enter a special comparison mode, where each sequence of digits is taken as a whole.  If we reach the end of these two parts without noticing a difference, we return to the standard comparison mode.  There are two types of numeric parts: "integral" and "fractional" (those  begin with a '0'). The types of the numeric parts affect the way we sort them:  @itemize @bullet @item integral/integral: we compare values as you would expect.  @item fractional/integral: the fractional part is less than the integral one. Again, no surprise.  @item fractional/fractional: the things become a bit more complex. If the common prefix contains only leading zeroes, the longest part is less than the other one; else the comparison behaves normally. @end itemize  @smallexample strverscmp ("no digit", "no digit")     @result{} 0    // @r{same behavior as strcmp.} strverscmp ("item#99", "item#100")     @result{}<0   // @r{same prefix, but 99< 100.} strverscmp ("alpha1", "alpha001")     @result{}>0   // @r{fractional part inferior to integral one.} strverscmp ("part1_f012", "part1_f01")     @result{}>0   // @r{two fractional parts.} strverscmp ("foo.009", "foo.0")     @result{}<0   // @r{idem, but with leading zeroes only.} @end smallexample  This function is especially useful when dealing with filename sorting, because filenames frequently hold indices/version numbers. @end deftypefun  */
end_comment

begin_comment
comment|/* states: S_N: normal, S_I: comparing integral part, S_F: comparing            fractional parts, S_Z: idem but with leading Zeroes only */
end_comment

begin_define
define|#
directive|define
name|S_N
value|0x0
end_define

begin_define
define|#
directive|define
name|S_I
value|0x4
end_define

begin_define
define|#
directive|define
name|S_F
value|0x8
end_define

begin_define
define|#
directive|define
name|S_Z
value|0xC
end_define

begin_comment
comment|/* result_type: CMP: return diff; LEN: compare using len_diff/diff */
end_comment

begin_define
define|#
directive|define
name|CMP
value|2
end_define

begin_define
define|#
directive|define
name|LEN
value|3
end_define

begin_comment
comment|/* Compare S1 and S2 as strings holding indices/version numbers,    returning less than, equal to or greater than zero if S1 is less than,    equal to or greater than S2 (for more info, see the Glibc texinfo doc).  */
end_comment

begin_function
name|int
name|strverscmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p1
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s1
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p2
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s2
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|diff
decl_stmt|;
comment|/* Symbol(s)    0       [1-9]   others  (padding)      Transition   (10) 0  (01) d  (00) x  (11) -   */
specifier|static
specifier|const
name|unsigned
name|int
name|next_state
index|[]
init|=
block|{
comment|/* state    x    d    0    - */
comment|/* S_N */
name|S_N
block|,
name|S_I
block|,
name|S_Z
block|,
name|S_N
block|,
comment|/* S_I */
name|S_N
block|,
name|S_I
block|,
name|S_I
block|,
name|S_I
block|,
comment|/* S_F */
name|S_N
block|,
name|S_F
block|,
name|S_F
block|,
name|S_F
block|,
comment|/* S_Z */
name|S_N
block|,
name|S_F
block|,
name|S_Z
block|,
name|S_Z
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|result_type
index|[]
init|=
block|{
comment|/* state   x/x  x/d  x/0  x/-  d/x  d/d  d/0  d/-                  0/x  0/d  0/0  0/-  -/x  -/d  -/0  -/- */
comment|/* S_N */
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|LEN
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
comment|/* S_I */
name|CMP
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|CMP
block|,
operator|+
literal|1
block|,
name|LEN
block|,
name|LEN
block|,
name|CMP
block|,
operator|+
literal|1
block|,
name|LEN
block|,
name|LEN
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
comment|/* S_F */
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|LEN
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
comment|/* S_Z */
name|CMP
block|,
operator|+
literal|1
block|,
operator|+
literal|1
block|,
name|CMP
block|,
operator|-
literal|1
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|,
operator|-
literal|1
block|,
name|CMP
block|,
name|CMP
block|,
name|CMP
block|}
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
literal|0
return|;
name|c1
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
comment|/* Hint: '0' is a digit too.  */
name|state
operator|=
name|S_N
operator||
operator|(
operator|(
name|c1
operator|==
literal|'0'
operator|)
operator|+
operator|(
name|ISDIGIT
argument_list|(
name|c1
argument_list|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|diff
operator|=
name|c1
operator|-
name|c2
operator|)
operator|==
literal|0
operator|&&
name|c1
operator|!=
literal|'\0'
condition|)
block|{
name|state
operator|=
name|next_state
index|[
name|state
index|]
expr_stmt|;
name|c1
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
name|state
operator||=
operator|(
name|c1
operator|==
literal|'0'
operator|)
operator|+
operator|(
name|ISDIGIT
argument_list|(
name|c1
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|state
operator|=
name|result_type
index|[
name|state
operator|<<
literal|2
operator||
operator|(
operator|(
operator|(
name|c2
operator|==
literal|'0'
operator|)
operator|+
operator|(
name|ISDIGIT
argument_list|(
name|c2
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|CMP
case|:
return|return
name|diff
return|;
case|case
name|LEN
case|:
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p1
operator|++
argument_list|)
condition|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p2
operator|++
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|ISDIGIT
argument_list|(
operator|*
name|p2
argument_list|)
condition|?
operator|-
literal|1
else|:
name|diff
return|;
default|default:
return|return
name|state
return|;
block|}
block|}
end_function

end_unit

