begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.    Copyright (C) 2004 Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* pexecute is an old routine.  This implementation uses the newer    pex_init/pex_run/pex_get_status/pex_free routines.  Don't use    pexecute in new code.  Use the newer routines instead.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We only permit a single pexecute chain to execute at a time.  This    was always true anyhow, though it wasn't documented.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pex_obj
modifier|*
name|pex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|idx
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pexecute
parameter_list|(
specifier|const
name|char
modifier|*
name|program
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|temp_base
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg_fmt
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PEXECUTE_FIRST
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pex
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
operator|(
name|char
operator|*
operator|)
literal|"pexecute already in progress"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pex
operator|=
name|pex_init
argument_list|(
name|PEX_USE_PIPES
argument_list|,
name|pname
argument_list|,
name|temp_base
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pex
operator|==
name|NULL
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
operator|(
name|char
operator|*
operator|)
literal|"pexecute not in progress"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|errmsg
operator|=
name|pex_run
argument_list|(
name|pex
argument_list|,
operator|(
operator|(
operator|(
name|flags
operator|&
name|PEXECUTE_LAST
operator|)
operator|!=
literal|0
condition|?
name|PEX_LAST
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
operator|)
operator|!=
literal|0
condition|?
name|PEX_SEARCH
else|:
literal|0
operator|)
operator|)
argument_list|,
name|program
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
operator|(
name|char
operator|*
operator|)
name|errmsg
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Instead of a PID, we just return a one-based index into the      status values.  We avoid zero just because the old pexecute would      never return it.  */
return|return
operator|++
name|idx
return|;
block|}
end_function

begin_function
name|int
name|pwait
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* The PID returned by pexecute is one-based.  */
operator|--
name|pid
expr_stmt|;
if|if
condition|(
name|pex
operator|==
name|NULL
operator|||
name|pid
operator|<
literal|0
operator|||
name|pid
operator|>=
name|idx
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pid
operator|==
literal|0
operator|&&
name|idx
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|pex_get_status
argument_list|(
name|pex
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|int
modifier|*
name|vector
decl_stmt|;
name|vector
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pex_get_status
argument_list|(
name|pex
argument_list|,
name|idx
argument_list|,
name|vector
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|vector
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|status
operator|=
name|vector
index|[
name|pid
index|]
expr_stmt|;
name|free
argument_list|(
name|vector
argument_list|)
expr_stmt|;
block|}
comment|/* Assume that we are done after the caller has retrieved the last      exit status.  The original implementation did not require that      the exit statuses be retrieved in order, but this implementation      does.  */
if|if
condition|(
name|pid
operator|+
literal|1
operator|==
name|idx
condition|)
block|{
name|pex_free
argument_list|(
name|pex
argument_list|)
expr_stmt|;
name|pex
operator|=
name|NULL
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|pid
operator|+
literal|1
return|;
block|}
end_function

end_unit

