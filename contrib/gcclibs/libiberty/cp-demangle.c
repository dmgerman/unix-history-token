begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for g++ V3 ABI.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@wasabisystems.com>.     This file is part of the libiberty library, which is part of GCC.     This file is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combined    executable.)     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This code implements a demangler for the g++ V3 ABI.  The ABI is    described on this web page:        http://www.codesourcery.com/cxx-abi/abi.html#mangling     This code was written while looking at the demangler written by    Alex Samuel<samuel@codesourcery.com>.     This code first pulls the mangled name apart into a list of    components, and then walks the list generating the demangled    name.     This file will normally define the following functions, q.v.:       char *cplus_demangle_v3(const char *mangled, int options)       char *java_demangle_v3(const char *mangled)       enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor (const char *name)       enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor (const char *name)     Also, the interface to the component list is public, and defined in    demangle.h.  The interface consists of these types, which are    defined in demangle.h:       enum demangle_component_type       struct demangle_component    and these functions defined in this file:       cplus_demangle_fill_name       cplus_demangle_fill_extended_operator       cplus_demangle_fill_ctor       cplus_demangle_fill_dtor       cplus_demangle_print    and other functions defined in the file cp-demint.c.     This file also defines some other functions and variables which are    only to be used by the file cp-demint.c.     Preprocessor macros you can define while compiling this file:     IN_LIBGCC2       If defined, this file defines the following function, q.v.:          char *__cxa_demangle (const char *mangled, char *buf, size_t *len,                                int *status)       instead of cplus_demangle_v3() and java_demangle_v3().     IN_GLIBCPP_V3       If defined, this file defines only __cxa_demangle(), and no other       publically visible functions or variables.     STANDALONE_DEMANGLER       If defined, this file defines a main() function which demangles       any arguments, or, if none, demangles stdin.     CP_DEMANGLE_DEBUG       If defined, turns on debugging mode, which prints information on       stdout about the mangled string.  This is not generally useful. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"cp-demangle.h"
end_include

begin_comment
comment|/* If IN_GLIBCPP_V3 is defined, some functions are made static.  We    also rename them via #define to avoid compiler errors when the    static definition conflicts with the extern declaration in a header    file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IN_GLIBCPP_V3
end_ifdef

begin_define
define|#
directive|define
name|CP_STATIC_IF_GLIBCPP_V3
value|static
end_define

begin_define
define|#
directive|define
name|cplus_demangle_fill_name
value|d_fill_name
end_define

begin_function_decl
specifier|static
name|int
name|d_fill_name
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_fill_extended_operator
value|d_fill_extended_operator
end_define

begin_function_decl
specifier|static
name|int
name|d_fill_extended_operator
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_fill_ctor
value|d_fill_ctor
end_define

begin_function_decl
specifier|static
name|int
name|d_fill_ctor
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|enum
name|gnu_v3_ctor_kinds
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_fill_dtor
value|d_fill_dtor
end_define

begin_function_decl
specifier|static
name|int
name|d_fill_dtor
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|enum
name|gnu_v3_dtor_kinds
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_mangled_name
value|d_mangled_name
end_define

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_mangled_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_type
value|d_type
end_define

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_print
value|d_print
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|d_print
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|cplus_demangle_init_info
value|d_init_info
end_define

begin_function_decl
specifier|static
name|void
name|d_init_info
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined(IN_GLIBCPP_V3) */
end_comment

begin_define
define|#
directive|define
name|CP_STATIC_IF_GLIBCPP_V3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined(IN_GLIBCPP_V3) */
end_comment

begin_comment
comment|/* See if the compiler supports dynamic arrays.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|CP_DYNAMIC_ARRAYS
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC_VERSION__
end_ifdef

begin_if
if|#
directive|if
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_define
define|#
directive|define
name|CP_DYNAMIC_ARRAYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__VERSION>= 199901L */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (__STDC_VERSION__) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (__STDC__) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (__GNUC__) */
end_comment

begin_comment
comment|/* We avoid pulling in the ctype tables, to prevent pulling in    additional unresolved symbols when this code is used in a library.    FIXME: Is this really a valid reason?  This comes from the original    V3 demangler code.     As of this writing this file has the following undefined references    when compiled with -DIN_GLIBCPP_V3: malloc, realloc, free, memcpy,    strcpy, strcat, strlen.  */
end_comment

begin_define
define|#
directive|define
name|IS_DIGIT
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_define
define|#
directive|define
name|IS_UPPER
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'A'&& (c)<= 'Z')
end_define

begin_define
define|#
directive|define
name|IS_LOWER
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'a'&& (c)<= 'z')
end_define

begin_comment
comment|/* The prefix prepended by GCC to an identifier represnting the    anonymous namespace.  */
end_comment

begin_define
define|#
directive|define
name|ANONYMOUS_NAMESPACE_PREFIX
value|"_GLOBAL_"
end_define

begin_define
define|#
directive|define
name|ANONYMOUS_NAMESPACE_PREFIX_LEN
define|\
value|(sizeof (ANONYMOUS_NAMESPACE_PREFIX) - 1)
end_define

begin_comment
comment|/* Information we keep for the standard substitutions.  */
end_comment

begin_struct
struct|struct
name|d_standard_sub_info
block|{
comment|/* The code for this substitution.  */
name|char
name|code
decl_stmt|;
comment|/* The simple string it expands to.  */
specifier|const
name|char
modifier|*
name|simple_expansion
decl_stmt|;
comment|/* The length of the simple expansion.  */
name|int
name|simple_len
decl_stmt|;
comment|/* The results of a full, verbose, expansion.  This is used when      qualifying a constructor/destructor, or when in verbose mode.  */
specifier|const
name|char
modifier|*
name|full_expansion
decl_stmt|;
comment|/* The length of the full expansion.  */
name|int
name|full_len
decl_stmt|;
comment|/* What to set the last_name field of d_info to; NULL if we should      not set it.  This is only relevant when qualifying a      constructor/destructor.  */
specifier|const
name|char
modifier|*
name|set_last_name
decl_stmt|;
comment|/* The length of set_last_name.  */
name|int
name|set_last_name_len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Accessors for subtrees of struct demangle_component.  */
end_comment

begin_define
define|#
directive|define
name|d_left
parameter_list|(
name|dc
parameter_list|)
value|((dc)->u.s_binary.left)
end_define

begin_define
define|#
directive|define
name|d_right
parameter_list|(
name|dc
parameter_list|)
value|((dc)->u.s_binary.right)
end_define

begin_comment
comment|/* A list of templates.  This is used while printing.  */
end_comment

begin_struct
struct|struct
name|d_print_template
block|{
comment|/* Next template on the list.  */
name|struct
name|d_print_template
modifier|*
name|next
decl_stmt|;
comment|/* This template.  */
specifier|const
name|struct
name|demangle_component
modifier|*
name|template_decl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of type modifiers.  This is used while printing.  */
end_comment

begin_struct
struct|struct
name|d_print_mod
block|{
comment|/* Next modifier on the list.  These are in the reverse of the order      in which they appeared in the mangled string.  */
name|struct
name|d_print_mod
modifier|*
name|next
decl_stmt|;
comment|/* The modifier.  */
specifier|const
name|struct
name|demangle_component
modifier|*
name|mod
decl_stmt|;
comment|/* Whether this modifier was printed.  */
name|int
name|printed
decl_stmt|;
comment|/* The list of templates which applies to this modifier.  */
name|struct
name|d_print_template
modifier|*
name|templates
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We use this structure to hold information during printing.  */
end_comment

begin_struct
struct|struct
name|d_print_info
block|{
comment|/* The options passed to the demangler.  */
name|int
name|options
decl_stmt|;
comment|/* Buffer holding the result.  */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Current length of data in buffer.  */
name|size_t
name|len
decl_stmt|;
comment|/* Allocated size of buffer.  */
name|size_t
name|alc
decl_stmt|;
comment|/* The current list of templates, if any.  */
name|struct
name|d_print_template
modifier|*
name|templates
decl_stmt|;
comment|/* The current list of modifiers (e.g., pointer, reference, etc.),      if any.  */
name|struct
name|d_print_mod
modifier|*
name|modifiers
decl_stmt|;
comment|/* Set to 1 if we had a memory allocation failure.  */
name|int
name|allocation_failure
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|d_print_saw_error
parameter_list|(
name|dpi
parameter_list|)
value|((dpi)->buf == NULL)
end_define

begin_define
define|#
directive|define
name|d_append_char
parameter_list|(
name|dpi
parameter_list|,
name|c
parameter_list|)
define|\
value|do \     { \       if ((dpi)->buf != NULL&& (dpi)->len< (dpi)->alc) \         (dpi)->buf[(dpi)->len++] = (c); \       else \         d_print_append_char ((dpi), (c)); \     } \   while (0)
end_define

begin_define
define|#
directive|define
name|d_append_buffer
parameter_list|(
name|dpi
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
define|\
value|do \     { \       if ((dpi)->buf != NULL&& (dpi)->len + (l)<= (dpi)->alc) \         { \           memcpy ((dpi)->buf + (dpi)->len, (s), (l)); \           (dpi)->len += l; \         } \       else \         d_print_append_buffer ((dpi), (s), (l)); \     } \   while (0)
end_define

begin_define
define|#
directive|define
name|d_append_string_constant
parameter_list|(
name|dpi
parameter_list|,
name|s
parameter_list|)
define|\
value|d_append_buffer (dpi, (s), sizeof (s) - 1)
end_define

begin_define
define|#
directive|define
name|d_last_char
parameter_list|(
name|dpi
parameter_list|)
define|\
value|((dpi)->buf == NULL || (dpi)->len == 0 ? '\0' : (dpi)->buf[(dpi)->len - 1])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|d_dump
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_empty
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_comp
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|enum
name|demangle_component_type
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_builtin_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_builtin_type_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_operator
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_operator_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_extended_operator
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_ctor
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|enum
name|gnu_v3_ctor_kinds
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_dtor
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|enum
name|gnu_v3_dtor_kinds
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_template_param
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_sub
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|has_return_type
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_ctor_dtor_or_conversion
parameter_list|(
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_encoding
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_nested_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_prefix
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_unqualified_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_source_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|d_number
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_identifier
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_operator_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_special_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|d_call_offset
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_ctor_dtor_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
modifier|*
name|d_cv_qualifiers
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|struct
name|demangle_component
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_function_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_bare_function_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_class_enum_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_array_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_pointer_to_member_type
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_template_param
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_template_args
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_template_arg
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_expression
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_expr_primary
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_local_name
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|d_discriminator
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|d_add_substitution
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_substitution
parameter_list|(
name|struct
name|d_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_resize
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_append_char
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_append_buffer
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_error
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_comp
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_java_identifier
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_mod_list
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
name|struct
name|d_print_mod
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_mod
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_function_type
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|struct
name|d_print_mod
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_array_type
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|,
name|struct
name|d_print_mod
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_expr_op
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|d_print_cast
parameter_list|(
name|struct
name|d_print_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|d_demangle
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|d_dump
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dc
operator|->
name|type
condition|)
block|{
case|case
name|DEMANGLE_COMPONENT_NAME
case|:
name|printf
argument_list|(
literal|"name '%.*s'\n"
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_name
operator|.
name|len
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_name
operator|.
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TEMPLATE_PARAM
case|:
name|printf
argument_list|(
literal|"template parameter %ld\n"
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_number
operator|.
name|number
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_CTOR
case|:
name|printf
argument_list|(
literal|"constructor %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dc
operator|->
name|u
operator|.
name|s_ctor
operator|.
name|kind
argument_list|)
expr_stmt|;
name|d_dump
argument_list|(
name|dc
operator|->
name|u
operator|.
name|s_ctor
operator|.
name|name
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_DTOR
case|:
name|printf
argument_list|(
literal|"destructor %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dc
operator|->
name|u
operator|.
name|s_dtor
operator|.
name|kind
argument_list|)
expr_stmt|;
name|d_dump
argument_list|(
name|dc
operator|->
name|u
operator|.
name|s_dtor
operator|.
name|name
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_SUB_STD
case|:
name|printf
argument_list|(
literal|"standard substitution %s\n"
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_string
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
case|:
name|printf
argument_list|(
literal|"builtin type %s\n"
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_OPERATOR
case|:
name|printf
argument_list|(
literal|"operator %s\n"
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_EXTENDED_OPERATOR
case|:
name|printf
argument_list|(
literal|"extended operator with %d args\n"
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_extended_operator
operator|.
name|args
argument_list|)
expr_stmt|;
name|d_dump
argument_list|(
name|dc
operator|->
name|u
operator|.
name|s_extended_operator
operator|.
name|name
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_QUAL_NAME
case|:
name|printf
argument_list|(
literal|"qualified name\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_LOCAL_NAME
case|:
name|printf
argument_list|(
literal|"local name\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TYPED_NAME
case|:
name|printf
argument_list|(
literal|"typed name\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TEMPLATE
case|:
name|printf
argument_list|(
literal|"template\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VTABLE
case|:
name|printf
argument_list|(
literal|"vtable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VTT
case|:
name|printf
argument_list|(
literal|"VTT\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE
case|:
name|printf
argument_list|(
literal|"construction vtable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TYPEINFO
case|:
name|printf
argument_list|(
literal|"typeinfo\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_NAME
case|:
name|printf
argument_list|(
literal|"typeinfo name\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_FN
case|:
name|printf
argument_list|(
literal|"typeinfo function\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_THUNK
case|:
name|printf
argument_list|(
literal|"thunk\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VIRTUAL_THUNK
case|:
name|printf
argument_list|(
literal|"virtual thunk\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_COVARIANT_THUNK
case|:
name|printf
argument_list|(
literal|"covariant thunk\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_JAVA_CLASS
case|:
name|printf
argument_list|(
literal|"java class\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_GUARD
case|:
name|printf
argument_list|(
literal|"guard\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_REFTEMP
case|:
name|printf
argument_list|(
literal|"reference temporary\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_HIDDEN_ALIAS
case|:
name|printf
argument_list|(
literal|"hidden alias\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_RESTRICT
case|:
name|printf
argument_list|(
literal|"restrict\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VOLATILE
case|:
name|printf
argument_list|(
literal|"volatile\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_CONST
case|:
name|printf
argument_list|(
literal|"const\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
name|printf
argument_list|(
literal|"restrict this\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
name|printf
argument_list|(
literal|"volatile this\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
name|printf
argument_list|(
literal|"const this\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
case|:
name|printf
argument_list|(
literal|"vendor type qualifier\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_POINTER
case|:
name|printf
argument_list|(
literal|"pointer\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_REFERENCE
case|:
name|printf
argument_list|(
literal|"reference\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_COMPLEX
case|:
name|printf
argument_list|(
literal|"complex\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_IMAGINARY
case|:
name|printf
argument_list|(
literal|"imaginary\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE
case|:
name|printf
argument_list|(
literal|"vendor type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
case|:
name|printf
argument_list|(
literal|"function type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_ARRAY_TYPE
case|:
name|printf
argument_list|(
literal|"array type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
case|:
name|printf
argument_list|(
literal|"pointer to member type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_ARGLIST
case|:
name|printf
argument_list|(
literal|"argument list\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
case|:
name|printf
argument_list|(
literal|"template argument list\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_CAST
case|:
name|printf
argument_list|(
literal|"cast\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_UNARY
case|:
name|printf
argument_list|(
literal|"unary operator\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_BINARY
case|:
name|printf
argument_list|(
literal|"binary operator\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_BINARY_ARGS
case|:
name|printf
argument_list|(
literal|"binary operator arguments\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TRINARY
case|:
name|printf
argument_list|(
literal|"trinary operator\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG1
case|:
name|printf
argument_list|(
literal|"trinary operator arguments 1\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG2
case|:
name|printf
argument_list|(
literal|"trinary operator arguments 1\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_LITERAL
case|:
name|printf
argument_list|(
literal|"literal\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_LITERAL_NEG
case|:
name|printf
argument_list|(
literal|"negative literal\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|d_dump
argument_list|(
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d_dump
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CP_DEMANGLE_DEBUG */
end_comment

begin_comment
comment|/* Fill in a DEMANGLE_COMPONENT_NAME.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|int
name|cplus_demangle_fill_name
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|s
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_NAME
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_name
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_name
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill in a DEMANGLE_COMPONENT_EXTENDED_OPERATOR.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|int
name|cplus_demangle_fill_extended_operator
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|p
parameter_list|,
name|int
name|args
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|args
operator|<
literal|0
operator|||
name|name
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_EXTENDED_OPERATOR
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_extended_operator
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_extended_operator
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill in a DEMANGLE_COMPONENT_CTOR.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|int
name|cplus_demangle_fill_ctor
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|p
parameter_list|,
name|enum
name|gnu_v3_ctor_kinds
name|kind
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
operator|(
name|kind
operator|<
name|gnu_v3_complete_object_ctor
operator|&&
name|kind
operator|>
name|gnu_v3_complete_object_allocating_ctor
operator|)
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_CTOR
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_ctor
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_ctor
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill in a DEMANGLE_COMPONENT_DTOR.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|int
name|cplus_demangle_fill_dtor
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|p
parameter_list|,
name|enum
name|gnu_v3_dtor_kinds
name|kind
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
operator|(
name|kind
operator|<
name|gnu_v3_deleting_dtor
operator|&&
name|kind
operator|>
name|gnu_v3_base_object_dtor
operator|)
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_DTOR
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_dtor
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_dtor
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add a new component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_empty
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|di
operator|->
name|next_comp
operator|>=
name|di
operator|->
name|num_comps
condition|)
return|return
name|NULL
return|;
name|p
operator|=
operator|&
name|di
operator|->
name|comps
index|[
name|di
operator|->
name|next_comp
index|]
expr_stmt|;
operator|++
name|di
operator|->
name|next_comp
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new generic component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_comp
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|enum
name|demangle_component_type
name|type
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|left
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|right
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
comment|/* We check for errors here.  A typical error would be a NULL return      from a subroutine.  We catch those here, and return NULL      upward.  */
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* These types require two parameters.  */
case|case
name|DEMANGLE_COMPONENT_QUAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_LOCAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TYPED_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TEMPLATE
case|:
case|case
name|DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE
case|:
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
case|:
case|case
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_UNARY
case|:
case|case
name|DEMANGLE_COMPONENT_BINARY
case|:
case|case
name|DEMANGLE_COMPONENT_BINARY_ARGS
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG1
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG2
case|:
case|case
name|DEMANGLE_COMPONENT_LITERAL
case|:
case|case
name|DEMANGLE_COMPONENT_LITERAL_NEG
case|:
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
break|break;
comment|/* These types only require one parameter.  */
case|case
name|DEMANGLE_COMPONENT_VTABLE
case|:
case|case
name|DEMANGLE_COMPONENT_VTT
case|:
case|case
name|DEMANGLE_COMPONENT_TYPEINFO
case|:
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_FN
case|:
case|case
name|DEMANGLE_COMPONENT_THUNK
case|:
case|case
name|DEMANGLE_COMPONENT_VIRTUAL_THUNK
case|:
case|case
name|DEMANGLE_COMPONENT_COVARIANT_THUNK
case|:
case|case
name|DEMANGLE_COMPONENT_JAVA_CLASS
case|:
case|case
name|DEMANGLE_COMPONENT_GUARD
case|:
case|case
name|DEMANGLE_COMPONENT_REFTEMP
case|:
case|case
name|DEMANGLE_COMPONENT_HIDDEN_ALIAS
case|:
case|case
name|DEMANGLE_COMPONENT_POINTER
case|:
case|case
name|DEMANGLE_COMPONENT_REFERENCE
case|:
case|case
name|DEMANGLE_COMPONENT_COMPLEX
case|:
case|case
name|DEMANGLE_COMPONENT_IMAGINARY
case|:
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_ARGLIST
case|:
case|case
name|DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
case|:
case|case
name|DEMANGLE_COMPONENT_CAST
case|:
if|if
condition|(
name|left
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
break|break;
comment|/* This needs a right parameter, but the left parameter can be 	 empty.  */
case|case
name|DEMANGLE_COMPONENT_ARRAY_TYPE
case|:
if|if
condition|(
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
break|break;
comment|/* These are allowed to have no parameters--in some cases they 	 will be filled in later.  */
case|case
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
case|:
case|case
name|DEMANGLE_COMPONENT_RESTRICT
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE
case|:
case|case
name|DEMANGLE_COMPONENT_CONST
case|:
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
break|break;
comment|/* Other types should not be seen here.  */
default|default:
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_binary
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_binary
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new name component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cplus_demangle_fill_name
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new builtin type component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_builtin_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
specifier|const
name|struct
name|demangle_builtin_type_info
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new operator component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_operator
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
specifier|const
name|struct
name|demangle_operator_info
modifier|*
name|op
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_OPERATOR
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|=
name|op
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new extended operator component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_extended_operator
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|args
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cplus_demangle_fill_extended_operator
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new constructor component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_ctor
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|enum
name|gnu_v3_ctor_kinds
name|kind
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cplus_demangle_fill_ctor
argument_list|(
name|p
argument_list|,
name|kind
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new destructor component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_dtor
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|enum
name|gnu_v3_dtor_kinds
name|kind
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cplus_demangle_fill_dtor
argument_list|(
name|p
argument_list|,
name|kind
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new template parameter.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_template_param
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|long
name|i
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_TEMPLATE_PARAM
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_number
operator|.
name|number
operator|=
name|i
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new standard substitution component.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_make_sub
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|d_make_empty
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DEMANGLE_COMPONENT_SUB_STD
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_string
operator|.
name|string
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|s_string
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*<mangled-name> ::= _Z<encoding>     TOP_LEVEL is non-zero when called at the top level.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|struct
name|demangle_component
modifier|*
name|cplus_demangle_mangled_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|top_level
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'_'
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'Z'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_encoding
argument_list|(
name|di
argument_list|,
name|top_level
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether a function should have a return type.  The argument    is the function name, which may be qualified in various ways.  The    rules are that template functions have return types with some    exceptions, function types which are not part of a function name    mangling have return types with some exceptions, and non-template    function names do not have return types.  The exceptions are that    constructors, destructors, and conversion operators do not have    return types.  */
end_comment

begin_function
specifier|static
name|int
name|has_return_type
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|)
block|{
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|dc
operator|->
name|type
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|DEMANGLE_COMPONENT_TEMPLATE
case|:
return|return
operator|!
name|is_ctor_dtor_or_conversion
argument_list|(
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
return|;
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
return|return
name|has_return_type
argument_list|(
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether a name is a constructor, a destructor, or a    conversion operator.  */
end_comment

begin_function
specifier|static
name|int
name|is_ctor_dtor_or_conversion
parameter_list|(
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|)
block|{
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|dc
operator|->
name|type
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|DEMANGLE_COMPONENT_QUAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_LOCAL_NAME
case|:
return|return
name|is_ctor_dtor_or_conversion
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
return|;
case|case
name|DEMANGLE_COMPONENT_CTOR
case|:
case|case
name|DEMANGLE_COMPONENT_DTOR
case|:
case|case
name|DEMANGLE_COMPONENT_CAST
case|:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*<encoding> ::=<(function) name><bare-function-type>               ::=<(data) name>               ::=<special-name>     TOP_LEVEL is non-zero when called at the top level, in which case    if DMGL_PARAMS is not set we do not demangle the function    parameters.  We only set this at the top level, because otherwise    we would not correctly demangle names in local scopes.  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_encoding
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|top_level
parameter_list|)
block|{
name|char
name|peek
init|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
decl_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'G'
operator|||
name|peek
operator|==
literal|'T'
condition|)
return|return
name|d_special_name
argument_list|(
name|di
argument_list|)
return|;
else|else
block|{
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
name|dc
operator|=
name|d_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|!=
name|NULL
operator|&&
name|top_level
operator|&&
operator|(
name|di
operator|->
name|options
operator|&
name|DMGL_PARAMS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Strip off any initial CV-qualifiers, as they really apply 	     to the `this' parameter, and they were not output by the 	     v2 demangler without DMGL_PARAMS.  */
while|while
condition|(
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_RESTRICT_THIS
operator|||
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_VOLATILE_THIS
operator|||
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_CONST_THIS
condition|)
name|dc
operator|=
name|d_left
argument_list|(
name|dc
argument_list|)
expr_stmt|;
comment|/* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then 	     there may be CV-qualifiers on its right argument which 	     really apply here; this happens when parsing a class 	     which is local to a function.  */
if|if
condition|(
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_LOCAL_NAME
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|dcr
decl_stmt|;
name|dcr
operator|=
name|d_right
argument_list|(
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
name|dcr
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_RESTRICT_THIS
operator|||
name|dcr
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_VOLATILE_THIS
operator|||
name|dcr
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_CONST_THIS
condition|)
name|dcr
operator|=
name|d_left
argument_list|(
name|dcr
argument_list|)
expr_stmt|;
name|dc
operator|->
name|u
operator|.
name|s_binary
operator|.
name|right
operator|=
name|dcr
expr_stmt|;
block|}
return|return
name|dc
return|;
block|}
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
operator|||
name|peek
operator|==
literal|'\0'
operator|||
name|peek
operator|==
literal|'E'
condition|)
return|return
name|dc
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TYPED_NAME
argument_list|,
name|dc
argument_list|,
name|d_bare_function_type
argument_list|(
name|di
argument_list|,
name|has_return_type
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*<name> ::=<nested-name>           ::=<unscoped-name>           ::=<unscoped-template-name><template-args>           ::=<local-name><unscoped-name> ::=<unqualified-name>                    ::= St<unqualified-name><unscoped-template-name> ::=<unscoped-name>                             ::=<substitution> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|char
name|peek
init|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
switch|switch
condition|(
name|peek
condition|)
block|{
case|case
literal|'N'
case|:
return|return
name|d_nested_name
argument_list|(
name|di
argument_list|)
return|;
case|case
literal|'Z'
case|:
return|return
name|d_local_name
argument_list|(
name|di
argument_list|)
return|;
case|case
literal|'L'
case|:
return|return
name|d_unqualified_name
argument_list|(
name|di
argument_list|)
return|;
case|case
literal|'S'
case|:
block|{
name|int
name|subst
decl_stmt|;
if|if
condition|(
name|d_peek_next_char
argument_list|(
name|di
argument_list|)
operator|!=
literal|'t'
condition|)
block|{
name|dc
operator|=
name|d_substitution
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subst
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|d_advance
argument_list|(
name|di
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dc
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_QUAL_NAME
argument_list|,
name|d_make_name
argument_list|(
name|di
argument_list|,
literal|"std"
argument_list|,
literal|3
argument_list|)
argument_list|,
name|d_unqualified_name
argument_list|(
name|di
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|->
name|expansion
operator|+=
literal|3
expr_stmt|;
name|subst
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|!=
literal|'I'
condition|)
block|{
comment|/* The grammar does not permit this case to occur if we 	       called d_substitution() above (i.e., subst == 1).  We 	       don't bother to check.  */
block|}
else|else
block|{
comment|/* This is<template-args>, which means that we just saw<unscoped-template-name>, which is a substitution 	       candidate if we didn't just get it from a 	       substitution.  */
if|if
condition|(
operator|!
name|subst
condition|)
block|{
if|if
condition|(
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|dc
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|dc
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TEMPLATE
argument_list|,
name|dc
argument_list|,
name|d_template_args
argument_list|(
name|di
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dc
return|;
block|}
default|default:
name|dc
operator|=
name|d_unqualified_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'I'
condition|)
block|{
comment|/* This is<template-args>, which means that we just saw<unscoped-template-name>, which is a substitution 	     candidate.  */
if|if
condition|(
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|dc
argument_list|)
condition|)
return|return
name|NULL
return|;
name|dc
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TEMPLATE
argument_list|,
name|dc
argument_list|,
name|d_template_args
argument_list|(
name|di
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dc
return|;
block|}
block|}
end_function

begin_comment
comment|/*<nested-name> ::= N [<CV-qualifiers>]<prefix><unqualified-name> E                  ::= N [<CV-qualifiers>]<template-prefix><template-args> E */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_nested_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
name|struct
name|demangle_component
modifier|*
modifier|*
name|pret
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'N'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|pret
operator|=
name|d_cv_qualifiers
argument_list|(
name|di
argument_list|,
operator|&
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|pret
operator|=
name|d_prefix
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'E'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*<prefix> ::=<prefix><unqualified-name>             ::=<template-prefix><template-args>             ::=<template-param>             ::=             ::=<substitution><template-prefix> ::=<prefix><(template) unqualified-name>                      ::=<template-param>                      ::=<substitution> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_prefix
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|peek
decl_stmt|;
name|enum
name|demangle_component_type
name|comb_type
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
comment|/* The older code accepts a<local-name> here, but I don't see 	 that in the grammar.  The older code does not accept a<template-param> here.  */
name|comb_type
operator|=
name|DEMANGLE_COMPONENT_QUAL_NAME
expr_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|peek
argument_list|)
operator|||
name|IS_LOWER
argument_list|(
name|peek
argument_list|)
operator|||
name|peek
operator|==
literal|'C'
operator|||
name|peek
operator|==
literal|'D'
operator|||
name|peek
operator|==
literal|'L'
condition|)
name|dc
operator|=
name|d_unqualified_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'S'
condition|)
name|dc
operator|=
name|d_substitution
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'I'
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|comb_type
operator|=
name|DEMANGLE_COMPONENT_TEMPLATE
expr_stmt|;
name|dc
operator|=
name|d_template_args
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'T'
condition|)
name|dc
operator|=
name|d_template_param
argument_list|(
name|di
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'E'
condition|)
return|return
name|ret
return|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|dc
expr_stmt|;
else|else
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|comb_type
argument_list|,
name|ret
argument_list|,
name|dc
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|!=
literal|'S'
operator|&&
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|!=
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*<unqualified-name> ::=<operator-name>                       ::=<ctor-dtor-name>                       ::=<source-name> 		      ::=<local-source-name><local-source-name>	::= L<source-name><discriminator> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_unqualified_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|char
name|peek
decl_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|peek
argument_list|)
condition|)
return|return
name|d_source_name
argument_list|(
name|di
argument_list|)
return|;
elseif|else
if|if
condition|(
name|IS_LOWER
argument_list|(
name|peek
argument_list|)
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|d_operator_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|ret
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_OPERATOR
condition|)
name|di
operator|->
name|expansion
operator|+=
sizeof|sizeof
expr|"operator"
operator|+
name|ret
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|len
operator|-
literal|2
expr_stmt|;
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'C'
operator|||
name|peek
operator|==
literal|'D'
condition|)
return|return
name|d_ctor_dtor_name
argument_list|(
name|di
argument_list|)
return|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'L'
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_source_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|d_discriminator
argument_list|(
name|di
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*<source-name> ::=<(positive length) number><identifier>  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_source_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|long
name|len
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
name|len
operator|=
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|d_identifier
argument_list|(
name|di
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|di
operator|->
name|last_name
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* number ::= [n]<(non-negative decimal integer)>  */
end_comment

begin_function
specifier|static
name|long
name|d_number
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|int
name|negative
decl_stmt|;
name|char
name|peek
decl_stmt|;
name|long
name|ret
decl_stmt|;
name|negative
operator|=
literal|0
expr_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'n'
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
name|peek
argument_list|)
condition|)
block|{
if|if
condition|(
name|negative
condition|)
name|ret
operator|=
operator|-
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|ret
operator|*
literal|10
operator|+
name|peek
operator|-
literal|'0'
expr_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* identifier ::=<(unqualified source code identifier)>  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_identifier
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|d_str
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|send
operator|-
name|name
operator|<
name|len
condition|)
return|return
name|NULL
return|;
name|d_advance
argument_list|(
name|di
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* A Java mangled name may have a trailing '$' if it is a C++      keyword.  This '$' is not included in the length count.  We just      ignore the '$'.  */
if|if
condition|(
operator|(
name|di
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|!=
literal|0
operator|&&
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'$'
condition|)
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Look for something which looks like a gcc encoding of an      anonymous namespace, and replace it with a more user friendly      name.  */
if|if
condition|(
name|len
operator|>=
operator|(
name|int
operator|)
name|ANONYMOUS_NAMESPACE_PREFIX_LEN
operator|+
literal|2
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
name|ANONYMOUS_NAMESPACE_PREFIX
argument_list|,
name|ANONYMOUS_NAMESPACE_PREFIX_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|name
operator|+
name|ANONYMOUS_NAMESPACE_PREFIX_LEN
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'.'
operator|||
operator|*
name|s
operator|==
literal|'_'
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|di
operator|->
name|expansion
operator|-=
name|len
operator|-
sizeof|sizeof
expr|"(anonymous namespace)"
expr_stmt|;
return|return
name|d_make_name
argument_list|(
name|di
argument_list|,
literal|"(anonymous namespace)"
argument_list|,
sizeof|sizeof
expr|"(anonymous namespace)"
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
return|return
name|d_make_name
argument_list|(
name|di
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* operator_name ::= many different two character encodings.                  ::= cv<type>                  ::= v<digit><source-name> */
end_comment

begin_define
define|#
directive|define
name|NL
parameter_list|(
name|s
parameter_list|)
value|s, (sizeof s) - 1
end_define

begin_expr_stmt
name|CP_STATIC_IF_GLIBCPP_V3
specifier|const
expr|struct
name|demangle_operator_info
name|cplus_demangle_operators
index|[]
operator|=
block|{
block|{
literal|"aN"
block|,
name|NL
argument_list|(
literal|"&="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"aS"
block|,
name|NL
argument_list|(
literal|"="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"aa"
block|,
name|NL
argument_list|(
literal|"&&"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"ad"
block|,
name|NL
argument_list|(
literal|"&"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"an"
block|,
name|NL
argument_list|(
literal|"&"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"cl"
block|,
name|NL
argument_list|(
literal|"()"
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"cm"
block|,
name|NL
argument_list|(
literal|","
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"co"
block|,
name|NL
argument_list|(
literal|"~"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"dV"
block|,
name|NL
argument_list|(
literal|"/="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"da"
block|,
name|NL
argument_list|(
literal|"delete[]"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"de"
block|,
name|NL
argument_list|(
literal|"*"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"dl"
block|,
name|NL
argument_list|(
literal|"delete"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"dv"
block|,
name|NL
argument_list|(
literal|"/"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"eO"
block|,
name|NL
argument_list|(
literal|"^="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"eo"
block|,
name|NL
argument_list|(
literal|"^"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"eq"
block|,
name|NL
argument_list|(
literal|"=="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"ge"
block|,
name|NL
argument_list|(
literal|">="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"gt"
block|,
name|NL
argument_list|(
literal|">"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"ix"
block|,
name|NL
argument_list|(
literal|"[]"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"lS"
block|,
name|NL
argument_list|(
literal|"<<="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"le"
block|,
name|NL
argument_list|(
literal|"<="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"ls"
block|,
name|NL
argument_list|(
literal|"<<"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"lt"
block|,
name|NL
argument_list|(
literal|"<"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"mI"
block|,
name|NL
argument_list|(
literal|"-="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"mL"
block|,
name|NL
argument_list|(
literal|"*="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"mi"
block|,
name|NL
argument_list|(
literal|"-"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"ml"
block|,
name|NL
argument_list|(
literal|"*"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"mm"
block|,
name|NL
argument_list|(
literal|"--"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"na"
block|,
name|NL
argument_list|(
literal|"new[]"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"ne"
block|,
name|NL
argument_list|(
literal|"!="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"ng"
block|,
name|NL
argument_list|(
literal|"-"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"nt"
block|,
name|NL
argument_list|(
literal|"!"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"nw"
block|,
name|NL
argument_list|(
literal|"new"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"oR"
block|,
name|NL
argument_list|(
literal|"|="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"oo"
block|,
name|NL
argument_list|(
literal|"||"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"or"
block|,
name|NL
argument_list|(
literal|"|"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"pL"
block|,
name|NL
argument_list|(
literal|"+="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"pl"
block|,
name|NL
argument_list|(
literal|"+"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"pm"
block|,
name|NL
argument_list|(
literal|"->*"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"pp"
block|,
name|NL
argument_list|(
literal|"++"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"ps"
block|,
name|NL
argument_list|(
literal|"+"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"pt"
block|,
name|NL
argument_list|(
literal|"->"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"qu"
block|,
name|NL
argument_list|(
literal|"?"
argument_list|)
block|,
literal|3
block|}
block|,
block|{
literal|"rM"
block|,
name|NL
argument_list|(
literal|"%="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"rS"
block|,
name|NL
argument_list|(
literal|">>="
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"rm"
block|,
name|NL
argument_list|(
literal|"%"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"rs"
block|,
name|NL
argument_list|(
literal|">>"
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|"st"
block|,
name|NL
argument_list|(
literal|"sizeof "
argument_list|)
block|,
literal|1
block|}
block|,
block|{
literal|"sz"
block|,
name|NL
argument_list|(
literal|"sizeof "
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_operator_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|char
name|c1
decl_stmt|;
name|char
name|c2
decl_stmt|;
name|c1
operator|=
name|d_next_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|c2
operator|=
name|d_next_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'v'
operator|&&
name|IS_DIGIT
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|d_make_extended_operator
argument_list|(
name|di
argument_list|,
name|c2
operator|-
literal|'0'
argument_list|,
name|d_source_name
argument_list|(
name|di
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'c'
operator|&&
name|c2
operator|==
literal|'v'
condition|)
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_CAST
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
else|else
block|{
comment|/* LOW is the inclusive lower bound.  */
name|int
name|low
init|=
literal|0
decl_stmt|;
comment|/* HIGH is the exclusive upper bound.  We subtract one to ignore 	 the sentinel at the end of the array.  */
name|int
name|high
init|=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|cplus_demangle_operators
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cplus_demangle_operators
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|demangle_operator_info
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|low
operator|+
operator|(
name|high
operator|-
name|low
operator|)
operator|/
literal|2
expr_stmt|;
name|p
operator|=
name|cplus_demangle_operators
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|p
operator|->
name|code
index|[
literal|0
index|]
operator|&&
name|c2
operator|==
name|p
operator|->
name|code
index|[
literal|1
index|]
condition|)
return|return
name|d_make_operator
argument_list|(
name|di
argument_list|,
name|p
argument_list|)
return|;
if|if
condition|(
name|c1
operator|<
name|p
operator|->
name|code
index|[
literal|0
index|]
operator|||
operator|(
name|c1
operator|==
name|p
operator|->
name|code
index|[
literal|0
index|]
operator|&&
name|c2
operator|<
name|p
operator|->
name|code
index|[
literal|1
index|]
operator|)
condition|)
name|high
operator|=
name|i
expr_stmt|;
else|else
name|low
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|==
name|high
condition|)
return|return
name|NULL
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*<special-name> ::= TV<type>                   ::= TT<type>                   ::= TI<type>                   ::= TS<type>                   ::= GV<(object) name>                   ::= T<call-offset><(base) encoding>                   ::= Tc<call-offset><call-offset><(base) encoding>    Also g++ extensions:                   ::= TC<type><(offset) number> _<(base) type>                   ::= TF<type>                   ::= TJ<type>                   ::= GR<name> 		  ::= GA<encoding> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_special_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|di
operator|->
name|expansion
operator|+=
literal|20
expr_stmt|;
if|if
condition|(
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'T'
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|d_next_char
argument_list|(
name|di
argument_list|)
condition|)
block|{
case|case
literal|'V'
case|:
name|di
operator|->
name|expansion
operator|-=
literal|5
expr_stmt|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_VTABLE
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'T'
case|:
name|di
operator|->
name|expansion
operator|-=
literal|10
expr_stmt|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_VTT
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'I'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TYPEINFO
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'S'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TYPEINFO_NAME
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'h'
case|:
if|if
condition|(
operator|!
name|d_call_offset
argument_list|(
name|di
argument_list|,
literal|'h'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_THUNK
argument_list|,
name|d_encoding
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'v'
case|:
if|if
condition|(
operator|!
name|d_call_offset
argument_list|(
name|di
argument_list|,
literal|'v'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_VIRTUAL_THUNK
argument_list|,
name|d_encoding
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|d_call_offset
argument_list|(
name|di
argument_list|,
literal|'\0'
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|d_call_offset
argument_list|(
name|di
argument_list|,
literal|'\0'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_COVARIANT_THUNK
argument_list|,
name|d_encoding
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'C'
case|:
block|{
name|struct
name|demangle_component
modifier|*
name|derived_type
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|base_type
decl_stmt|;
name|derived_type
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|offset
operator|=
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'_'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|base_type
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* We don't display the offset.  FIXME: We should display 	       it in verbose mode.  */
name|di
operator|->
name|expansion
operator|+=
literal|5
expr_stmt|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE
argument_list|,
name|base_type
argument_list|,
name|derived_type
argument_list|)
return|;
block|}
case|case
literal|'F'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TYPEINFO_FN
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'J'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_JAVA_CLASS
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'G'
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|d_next_char
argument_list|(
name|di
argument_list|)
condition|)
block|{
case|case
literal|'V'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_GUARD
argument_list|,
name|d_name
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'R'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_REFTEMP
argument_list|,
name|d_name
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|'A'
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_HIDDEN_ALIAS
argument_list|,
name|d_encoding
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*<call-offset> ::= h<nv-offset> _                  ::= v<v-offset> _<nv-offset> ::=<(offset) number><v-offset> ::=<(offset) number> _<(virtual offset) number>     The C parameter, if not '\0', is a character we just read which is    the start of the<call-offset>.     We don't display the offset information anywhere.  FIXME: We should    display it in verbose mode.  */
end_comment

begin_function
specifier|static
name|int
name|d_call_offset
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|c
operator|=
name|d_next_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'h'
condition|)
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
block|{
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'_'
argument_list|)
condition|)
return|return
literal|0
return|;
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'_'
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*<ctor-dtor-name> ::= C1                     ::= C2                     ::= C3                     ::= D0                     ::= D1                     ::= D2 */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_ctor_dtor_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
if|if
condition|(
name|di
operator|->
name|last_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|last_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_NAME
condition|)
name|di
operator|->
name|expansion
operator|+=
name|di
operator|->
name|last_name
operator|->
name|u
operator|.
name|s_name
operator|.
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|di
operator|->
name|last_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_SUB_STD
condition|)
name|di
operator|->
name|expansion
operator|+=
name|di
operator|->
name|last_name
operator|->
name|u
operator|.
name|s_string
operator|.
name|len
expr_stmt|;
block|}
switch|switch
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
condition|)
block|{
case|case
literal|'C'
case|:
block|{
name|enum
name|gnu_v3_ctor_kinds
name|kind
decl_stmt|;
switch|switch
condition|(
name|d_peek_next_char
argument_list|(
name|di
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
name|kind
operator|=
name|gnu_v3_complete_object_ctor
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|kind
operator|=
name|gnu_v3_base_object_ctor
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|kind
operator|=
name|gnu_v3_complete_object_allocating_ctor
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
name|d_advance
argument_list|(
name|di
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|d_make_ctor
argument_list|(
name|di
argument_list|,
name|kind
argument_list|,
name|di
operator|->
name|last_name
argument_list|)
return|;
block|}
case|case
literal|'D'
case|:
block|{
name|enum
name|gnu_v3_dtor_kinds
name|kind
decl_stmt|;
switch|switch
condition|(
name|d_peek_next_char
argument_list|(
name|di
argument_list|)
condition|)
block|{
case|case
literal|'0'
case|:
name|kind
operator|=
name|gnu_v3_deleting_dtor
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|kind
operator|=
name|gnu_v3_complete_object_dtor
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|kind
operator|=
name|gnu_v3_base_object_dtor
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
name|d_advance
argument_list|(
name|di
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|d_make_dtor
argument_list|(
name|di
argument_list|,
name|kind
argument_list|,
name|di
operator|->
name|last_name
argument_list|)
return|;
block|}
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*<type> ::=<builtin-type>           ::=<function-type>           ::=<class-enum-type>           ::=<array-type>           ::=<pointer-to-member-type>           ::=<template-param>           ::=<template-template-param><template-args>           ::=<substitution>           ::=<CV-qualifiers><type>           ::= P<type>           ::= R<type>           ::= C<type>           ::= G<type>           ::= U<source-name><type><builtin-type> ::= various one letter codes                   ::= u<source-name> */
end_comment

begin_expr_stmt
name|CP_STATIC_IF_GLIBCPP_V3
specifier|const
expr|struct
name|demangle_builtin_type_info
name|cplus_demangle_builtin_types
index|[
name|D_BUILTIN_TYPE_COUNT
index|]
operator|=
block|{
comment|/* a */
block|{
name|NL
argument_list|(
literal|"signed char"
argument_list|)
block|,
name|NL
argument_list|(
literal|"signed char"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* b */
block|{
name|NL
argument_list|(
literal|"bool"
argument_list|)
block|,
name|NL
argument_list|(
literal|"boolean"
argument_list|)
block|,
name|D_PRINT_BOOL
block|}
block|,
comment|/* c */
block|{
name|NL
argument_list|(
literal|"char"
argument_list|)
block|,
name|NL
argument_list|(
literal|"byte"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* d */
block|{
name|NL
argument_list|(
literal|"double"
argument_list|)
block|,
name|NL
argument_list|(
literal|"double"
argument_list|)
block|,
name|D_PRINT_FLOAT
block|}
block|,
comment|/* e */
block|{
name|NL
argument_list|(
literal|"long double"
argument_list|)
block|,
name|NL
argument_list|(
literal|"long double"
argument_list|)
block|,
name|D_PRINT_FLOAT
block|}
block|,
comment|/* f */
block|{
name|NL
argument_list|(
literal|"float"
argument_list|)
block|,
name|NL
argument_list|(
literal|"float"
argument_list|)
block|,
name|D_PRINT_FLOAT
block|}
block|,
comment|/* g */
block|{
name|NL
argument_list|(
literal|"__float128"
argument_list|)
block|,
name|NL
argument_list|(
literal|"__float128"
argument_list|)
block|,
name|D_PRINT_FLOAT
block|}
block|,
comment|/* h */
block|{
name|NL
argument_list|(
literal|"unsigned char"
argument_list|)
block|,
name|NL
argument_list|(
literal|"unsigned char"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* i */
block|{
name|NL
argument_list|(
literal|"int"
argument_list|)
block|,
name|NL
argument_list|(
literal|"int"
argument_list|)
block|,
name|D_PRINT_INT
block|}
block|,
comment|/* j */
block|{
name|NL
argument_list|(
literal|"unsigned int"
argument_list|)
block|,
name|NL
argument_list|(
literal|"unsigned"
argument_list|)
block|,
name|D_PRINT_UNSIGNED
block|}
block|,
comment|/* k */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* l */
block|{
name|NL
argument_list|(
literal|"long"
argument_list|)
block|,
name|NL
argument_list|(
literal|"long"
argument_list|)
block|,
name|D_PRINT_LONG
block|}
block|,
comment|/* m */
block|{
name|NL
argument_list|(
literal|"unsigned long"
argument_list|)
block|,
name|NL
argument_list|(
literal|"unsigned long"
argument_list|)
block|,
name|D_PRINT_UNSIGNED_LONG
block|}
block|,
comment|/* n */
block|{
name|NL
argument_list|(
literal|"__int128"
argument_list|)
block|,
name|NL
argument_list|(
literal|"__int128"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* o */
block|{
name|NL
argument_list|(
literal|"unsigned __int128"
argument_list|)
block|,
name|NL
argument_list|(
literal|"unsigned __int128"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* p */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* q */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* r */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* s */
block|{
name|NL
argument_list|(
literal|"short"
argument_list|)
block|,
name|NL
argument_list|(
literal|"short"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* t */
block|{
name|NL
argument_list|(
literal|"unsigned short"
argument_list|)
block|,
name|NL
argument_list|(
literal|"unsigned short"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* u */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* v */
block|{
name|NL
argument_list|(
literal|"void"
argument_list|)
block|,
name|NL
argument_list|(
literal|"void"
argument_list|)
block|,
name|D_PRINT_VOID
block|}
block|,
comment|/* w */
block|{
name|NL
argument_list|(
literal|"wchar_t"
argument_list|)
block|,
name|NL
argument_list|(
literal|"char"
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|,
comment|/* x */
block|{
name|NL
argument_list|(
literal|"long long"
argument_list|)
block|,
name|NL
argument_list|(
literal|"long"
argument_list|)
block|,
name|D_PRINT_LONG_LONG
block|}
block|,
comment|/* y */
block|{
name|NL
argument_list|(
literal|"unsigned long long"
argument_list|)
block|,
name|NL
argument_list|(
literal|"unsigned long long"
argument_list|)
block|,
name|D_PRINT_UNSIGNED_LONG_LONG
block|}
block|,
comment|/* z */
block|{
name|NL
argument_list|(
literal|"..."
argument_list|)
block|,
name|NL
argument_list|(
literal|"..."
argument_list|)
block|,
name|D_PRINT_DEFAULT
block|}
block|, }
expr_stmt|;
end_expr_stmt

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|struct
name|demangle_component
modifier|*
name|cplus_demangle_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|char
name|peek
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
name|int
name|can_subst
decl_stmt|;
comment|/* The ABI specifies that when CV-qualifiers are used, the base type      is substitutable, and the fully qualified type is substitutable,      but the base type with a strict subset of the CV-qualifiers is      not substitutable.  The natural recursive implementation of the      CV-qualifiers would cause subsets to be substitutable, so instead      we pull them all off now.       FIXME: The ABI says that order-insensitive vendor qualifiers      should be handled in the same way, but we have no way to tell      which vendor qualifiers are order-insensitive and which are      order-sensitive.  So we just assume that they are all      order-sensitive.  g++ 3.4 supports only one vendor qualifier,      __vector, and it treats it as order-sensitive when mangling      names.  */
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'r'
operator|||
name|peek
operator|==
literal|'V'
operator|||
name|peek
operator|==
literal|'K'
condition|)
block|{
name|struct
name|demangle_component
modifier|*
modifier|*
name|pret
decl_stmt|;
name|pret
operator|=
name|d_cv_qualifiers
argument_list|(
name|di
argument_list|,
operator|&
name|ret
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|pret
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pret
operator|||
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
name|can_subst
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|peek
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|ret
operator|=
name|d_make_builtin_type
argument_list|(
name|di
argument_list|,
operator|&
name|cplus_demangle_builtin_types
index|[
name|peek
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
name|di
operator|->
name|expansion
operator|+=
name|ret
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|len
expr_stmt|;
name|can_subst
operator|=
literal|0
expr_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_VENDOR_TYPE
argument_list|,
name|d_source_name
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|ret
operator|=
name|d_function_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'N'
case|:
case|case
literal|'Z'
case|:
name|ret
operator|=
name|d_class_enum_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|ret
operator|=
name|d_array_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|ret
operator|=
name|d_pointer_to_member_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ret
operator|=
name|d_template_param
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'I'
condition|)
block|{
comment|/* This is<template-template-param><template-args>.  The<template-template-param> part is a substitution 	     candidate.  */
if|if
condition|(
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TEMPLATE
argument_list|,
name|ret
argument_list|,
name|d_template_args
argument_list|(
name|di
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* If this is a special substitution, then it is the start of<class-enum-type>.  */
block|{
name|char
name|peek_next
decl_stmt|;
name|peek_next
operator|=
name|d_peek_next_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|peek_next
argument_list|)
operator|||
name|peek_next
operator|==
literal|'_'
operator|||
name|IS_UPPER
argument_list|(
name|peek_next
argument_list|)
condition|)
block|{
name|ret
operator|=
name|d_substitution
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The substituted name may have been a template name and 	       may be followed by tepmlate args.  */
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'I'
condition|)
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TEMPLATE
argument_list|,
name|ret
argument_list|,
name|d_template_args
argument_list|(
name|di
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|can_subst
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|d_class_enum_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* If the substitution was a complete type, then it is not 	       a new substitution candidate.  However, if the 	       substitution was followed by template arguments, then 	       the whole thing is a substitution candidate.  */
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|ret
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_SUB_STD
condition|)
name|can_subst
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'P'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_POINTER
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_REFERENCE
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_COMPLEX
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_IMAGINARY
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_source_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|can_subst
condition|)
block|{
if|if
condition|(
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*<CV-qualifiers> ::= [r] [V] [K]  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
modifier|*
name|d_cv_qualifiers
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|struct
name|demangle_component
modifier|*
modifier|*
name|pret
parameter_list|,
name|int
name|member_fn
parameter_list|)
block|{
name|char
name|peek
decl_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
while|while
condition|(
name|peek
operator|==
literal|'r'
operator|||
name|peek
operator|==
literal|'V'
operator|||
name|peek
operator|==
literal|'K'
condition|)
block|{
name|enum
name|demangle_component_type
name|t
decl_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'r'
condition|)
block|{
name|t
operator|=
operator|(
name|member_fn
condition|?
name|DEMANGLE_COMPONENT_RESTRICT_THIS
else|:
name|DEMANGLE_COMPONENT_RESTRICT
operator|)
expr_stmt|;
name|di
operator|->
name|expansion
operator|+=
sizeof|sizeof
expr|"restrict"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'V'
condition|)
block|{
name|t
operator|=
operator|(
name|member_fn
condition|?
name|DEMANGLE_COMPONENT_VOLATILE_THIS
else|:
name|DEMANGLE_COMPONENT_VOLATILE
operator|)
expr_stmt|;
name|di
operator|->
name|expansion
operator|+=
sizeof|sizeof
expr|"volatile"
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|member_fn
condition|?
name|DEMANGLE_COMPONENT_CONST_THIS
else|:
name|DEMANGLE_COMPONENT_CONST
operator|)
expr_stmt|;
name|di
operator|->
name|expansion
operator|+=
sizeof|sizeof
expr|"const"
expr_stmt|;
block|}
operator|*
name|pret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|pret
operator|=
operator|&
name|d_left
argument_list|(
operator|*
name|pret
argument_list|)
expr_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
return|return
name|pret
return|;
block|}
end_function

begin_comment
comment|/*<function-type> ::= F [Y]<bare-function-type> E  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_function_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'F'
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'Y'
condition|)
block|{
comment|/* Function has C linkage.  We don't print this information. 	 FIXME: We should print it in verbose mode.  */
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|d_bare_function_type
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'E'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*<bare-function-type> ::= [J]<type>+  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_bare_function_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|has_return_type
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|return_type
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|tl
decl_stmt|;
name|struct
name|demangle_component
modifier|*
modifier|*
name|ptl
decl_stmt|;
name|char
name|peek
decl_stmt|;
comment|/* Detect special qualifier indicating that the first argument      is the return type.  */
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'J'
condition|)
block|{
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|has_return_type
operator|=
literal|1
expr_stmt|;
block|}
name|return_type
operator|=
name|NULL
expr_stmt|;
name|tl
operator|=
name|NULL
expr_stmt|;
name|ptl
operator|=
operator|&
name|tl
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|type
decl_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'\0'
operator|||
name|peek
operator|==
literal|'E'
condition|)
break|break;
name|type
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|has_return_type
condition|)
block|{
name|return_type
operator|=
name|type
expr_stmt|;
name|has_return_type
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptl
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_ARGLIST
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptl
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ptl
operator|=
operator|&
name|d_right
argument_list|(
operator|*
name|ptl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There should be at least one parameter type besides the optional      return type.  A function which takes no arguments will have a      single parameter type void.  */
if|if
condition|(
name|tl
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* If we have a single parameter type void, omit it.  */
if|if
condition|(
name|d_right
argument_list|(
name|tl
argument_list|)
operator|==
name|NULL
operator|&&
name|d_left
argument_list|(
name|tl
argument_list|)
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
operator|&&
name|d_left
argument_list|(
name|tl
argument_list|)
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|print
operator|==
name|D_PRINT_VOID
condition|)
block|{
name|di
operator|->
name|expansion
operator|-=
name|d_left
argument_list|(
name|tl
argument_list|)
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|len
expr_stmt|;
name|tl
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
argument_list|,
name|return_type
argument_list|,
name|tl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*<class-enum-type> ::=<name>  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_class_enum_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
return|return
name|d_name
argument_list|(
name|di
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*<array-type> ::= A<(positive dimension) number> _<(element) type>                 ::= A [<(dimension) expression>] _<(element) type> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_array_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|char
name|peek
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dim
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'A'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'_'
condition|)
name|dim
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|peek
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|d_str
argument_list|(
name|di
argument_list|)
expr_stmt|;
do|do
block|{
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|IS_DIGIT
argument_list|(
name|peek
argument_list|)
condition|)
do|;
name|dim
operator|=
name|d_make_name
argument_list|(
name|di
argument_list|,
name|s
argument_list|,
name|d_str
argument_list|(
name|di
argument_list|)
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
name|dim
operator|=
name|d_expression
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'_'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_ARRAY_TYPE
argument_list|,
name|dim
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*<pointer-to-member-type> ::= M<(class) type><(member) type>  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_pointer_to_member_type
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|cl
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|mem
decl_stmt|;
name|struct
name|demangle_component
modifier|*
modifier|*
name|pmem
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'M'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|cl
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* The ABI specifies that any type can be a substitution source, and      that M is followed by two types, and that when a CV-qualified      type is seen both the base type and the CV-qualified types are      substitution sources.  The ABI also specifies that for a pointer      to a CV-qualified member function, the qualifiers are attached to      the second type.  Given the grammar, a plain reading of the ABI      suggests that both the CV-qualified member function and the      non-qualified member function are substitution sources.  However,      g++ does not work that way.  g++ treats only the CV-qualified      member function as a substitution source.  FIXME.  So to work      with g++, we need to pull off the CV-qualifiers here, in order to      avoid calling add_substitution() in cplus_demangle_type().  But      for a CV-qualified member which is not a function, g++ does      follow the ABI, so we need to handle that case here by calling      d_add_substitution ourselves.  */
name|pmem
operator|=
name|d_cv_qualifiers
argument_list|(
name|di
argument_list|,
operator|&
name|mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmem
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|pmem
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pmem
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pmem
operator|!=
operator|&
name|mem
operator|&&
operator|(
operator|*
name|pmem
operator|)
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|d_add_substitution
argument_list|(
name|di
argument_list|,
name|mem
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
argument_list|,
name|cl
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*<template-param> ::= T_                     ::= T<(parameter-2 non-negative) number> _ */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_template_param
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|long
name|param
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'T'
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'_'
condition|)
name|param
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|param
operator|=
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|param
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'_'
argument_list|)
condition|)
return|return
name|NULL
return|;
operator|++
name|di
operator|->
name|did_subs
expr_stmt|;
return|return
name|d_make_template_param
argument_list|(
name|di
argument_list|,
name|param
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*<template-args> ::= I<template-arg>+ E  */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_template_args
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|hold_last_name
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|al
decl_stmt|;
name|struct
name|demangle_component
modifier|*
modifier|*
name|pal
decl_stmt|;
comment|/* Preserve the last name we saw--don't let the template arguments      clobber it, as that would give us the wrong name for a subsequent      constructor or destructor.  */
name|hold_last_name
operator|=
name|di
operator|->
name|last_name
expr_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|al
operator|=
name|NULL
expr_stmt|;
name|pal
operator|=
operator|&
name|al
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|d_template_arg
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|pal
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
argument_list|,
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pal
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|pal
operator|=
operator|&
name|d_right
argument_list|(
operator|*
name|pal
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'E'
condition|)
block|{
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|di
operator|->
name|last_name
operator|=
name|hold_last_name
expr_stmt|;
return|return
name|al
return|;
block|}
end_function

begin_comment
comment|/*<template-arg> ::=<type>                   ::= X<expression> E                   ::=<expr-primary> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_template_arg
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
switch|switch
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
condition|)
block|{
case|case
literal|'X'
case|:
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|d_expression
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'E'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
case|case
literal|'L'
case|:
return|return
name|d_expr_primary
argument_list|(
name|di
argument_list|)
return|;
default|default:
return|return
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*<expression> ::=<(unary) operator-name><expression>                 ::=<(binary) operator-name><expression><expression>                 ::=<(trinary) operator-name><expression><expression><expression>                 ::= st<type>                 ::=<template-param>                 ::= sr<type><unqualified-name>                 ::= sr<type><unqualified-name><template-args>                 ::=<expr-primary> */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_expression
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|char
name|peek
decl_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'L'
condition|)
return|return
name|d_expr_primary
argument_list|(
name|di
argument_list|)
return|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'T'
condition|)
return|return
name|d_template_param
argument_list|(
name|di
argument_list|)
return|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'s'
operator|&&
name|d_peek_next_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'r'
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|type
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|name
decl_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|name
operator|=
name|d_unqualified_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|!=
literal|'I'
condition|)
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_QUAL_NAME
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
else|else
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_QUAL_NAME
argument_list|,
name|type
argument_list|,
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TEMPLATE
argument_list|,
name|name
argument_list|,
name|d_template_args
argument_list|(
name|di
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|demangle_component
modifier|*
name|op
decl_stmt|;
name|int
name|args
decl_stmt|;
name|op
operator|=
name|d_operator_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|op
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_OPERATOR
condition|)
name|di
operator|->
name|expansion
operator|+=
name|op
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|len
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_OPERATOR
operator|&&
name|strcmp
argument_list|(
name|op
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|code
argument_list|,
literal|"st"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_UNARY
argument_list|,
name|op
argument_list|,
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|op
operator|->
name|type
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|DEMANGLE_COMPONENT_OPERATOR
case|:
name|args
operator|=
name|op
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|args
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_EXTENDED_OPERATOR
case|:
name|args
operator|=
name|op
operator|->
name|u
operator|.
name|s_extended_operator
operator|.
name|args
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_CAST
case|:
name|args
operator|=
literal|1
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|args
condition|)
block|{
case|case
literal|1
case|:
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_UNARY
argument_list|,
name|op
argument_list|,
name|d_expression
argument_list|(
name|di
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
block|{
name|struct
name|demangle_component
modifier|*
name|left
decl_stmt|;
name|left
operator|=
name|d_expression
argument_list|(
name|di
argument_list|)
expr_stmt|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_BINARY
argument_list|,
name|op
argument_list|,
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_BINARY_ARGS
argument_list|,
name|left
argument_list|,
name|d_expression
argument_list|(
name|di
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|3
case|:
block|{
name|struct
name|demangle_component
modifier|*
name|first
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|second
decl_stmt|;
name|first
operator|=
name|d_expression
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|second
operator|=
name|d_expression
argument_list|(
name|di
argument_list|)
expr_stmt|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TRINARY
argument_list|,
name|op
argument_list|,
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TRINARY_ARG1
argument_list|,
name|first
argument_list|,
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_TRINARY_ARG2
argument_list|,
name|second
argument_list|,
name|d_expression
argument_list|(
name|di
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
default|default:
return|return
name|NULL
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*<expr-primary> ::= L<type><(value) number> E                   ::= L<type><(value) float> E                   ::= L<mangled-name> E */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_expr_primary
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'L'
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'_'
condition|)
name|ret
operator|=
name|cplus_demangle_mangled_name
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|demangle_component
modifier|*
name|type
decl_stmt|;
name|enum
name|demangle_component_type
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|type
operator|=
name|cplus_demangle_type
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* If we have a type we know how to print, we aren't going to 	 print the type name itself.  */
if|if
condition|(
name|type
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
operator|&&
name|type
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|print
operator|!=
name|D_PRINT_DEFAULT
condition|)
name|di
operator|->
name|expansion
operator|-=
name|type
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|len
expr_stmt|;
comment|/* Rather than try to interpret the literal value, we just 	 collect it as a string.  Note that it's possible to have a 	 floating point literal here.  The ABI specifies that the 	 format of such literals is machine independent.  That's fine, 	 but what's not fine is that versions of g++ up to 3.2 with 	 -fabi-version=1 used upper case letters in the hex constant, 	 and dumped out gcc's internal representation.  That makes it 	 hard to tell where the constant ends, and hard to dump the 	 constant in any readable form anyhow.  We don't attempt to 	 handle these cases.  */
name|t
operator|=
name|DEMANGLE_COMPONENT_LITERAL
expr_stmt|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'n'
condition|)
block|{
name|t
operator|=
name|DEMANGLE_COMPONENT_LITERAL_NEG
expr_stmt|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|d_str
argument_list|(
name|di
argument_list|)
expr_stmt|;
while|while
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|!=
literal|'E'
condition|)
block|{
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|t
argument_list|,
name|type
argument_list|,
name|d_make_name
argument_list|(
name|di
argument_list|,
name|s
argument_list|,
name|d_str
argument_list|(
name|di
argument_list|)
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'E'
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*<local-name> ::= Z<(function) encoding> E<(entity) name> [<discriminator>]                 ::= Z<(function) encoding> E s [<discriminator>] */
end_comment

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_local_name
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|demangle_component
modifier|*
name|function
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'Z'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|function
operator|=
name|d_encoding
argument_list|(
name|di
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'E'
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|==
literal|'s'
condition|)
block|{
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_discriminator
argument_list|(
name|di
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_LOCAL_NAME
argument_list|,
name|function
argument_list|,
name|d_make_name
argument_list|(
name|di
argument_list|,
literal|"string literal"
argument_list|,
sizeof|sizeof
expr|"string literal"
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|demangle_component
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|d_name
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_discriminator
argument_list|(
name|di
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|d_make_comp
argument_list|(
name|di
argument_list|,
name|DEMANGLE_COMPONENT_LOCAL_NAME
argument_list|,
name|function
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*<discriminator> ::= _<(non-negative) number>     We demangle the discriminator, but we don't print it out.  FIXME:    We should print it out in verbose mode.  */
end_comment

begin_function
specifier|static
name|int
name|d_discriminator
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|long
name|discrim
decl_stmt|;
if|if
condition|(
name|d_peek_char
argument_list|(
name|di
argument_list|)
operator|!=
literal|'_'
condition|)
return|return
literal|1
return|;
name|d_advance
argument_list|(
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|discrim
operator|=
name|d_number
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|discrim
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add a new substitution.  */
end_comment

begin_function
specifier|static
name|int
name|d_add_substitution
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|)
block|{
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|di
operator|->
name|next_sub
operator|>=
name|di
operator|->
name|num_subs
condition|)
return|return
literal|0
return|;
name|di
operator|->
name|subs
index|[
name|di
operator|->
name|next_sub
index|]
operator|=
name|dc
expr_stmt|;
operator|++
name|di
operator|->
name|next_sub
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*<substitution> ::= S<seq-id> _                   ::= S_                   ::= St                   ::= Sa                   ::= Sb                   ::= Ss                   ::= Si                   ::= So                   ::= Sd     If PREFIX is non-zero, then this type is being used as a prefix in    a qualified name.  In this case, for the standard substitutions, we    need to check whether we are being used as a prefix for a    constructor or destructor, and return a full template name.    Otherwise we will get something like std::iostream::~iostream()    which does not correspond particularly well to any function which    actually appears in the source. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|d_standard_sub_info
name|standard_subs
index|[]
init|=
block|{
block|{
literal|'t'
block|,
name|NL
argument_list|(
literal|"std"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std"
argument_list|)
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|'a'
block|,
name|NL
argument_list|(
literal|"std::allocator"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std::allocator"
argument_list|)
block|,
name|NL
argument_list|(
literal|"allocator"
argument_list|)
block|}
block|,
block|{
literal|'b'
block|,
name|NL
argument_list|(
literal|"std::basic_string"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std::basic_string"
argument_list|)
block|,
name|NL
argument_list|(
literal|"basic_string"
argument_list|)
block|}
block|,
block|{
literal|'s'
block|,
name|NL
argument_list|(
literal|"std::string"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std::basic_string<char, std::char_traits<char>, std::allocator<char>>"
argument_list|)
block|,
name|NL
argument_list|(
literal|"basic_string"
argument_list|)
block|}
block|,
block|{
literal|'i'
block|,
name|NL
argument_list|(
literal|"std::istream"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std::basic_istream<char, std::char_traits<char>>"
argument_list|)
block|,
name|NL
argument_list|(
literal|"basic_istream"
argument_list|)
block|}
block|,
block|{
literal|'o'
block|,
name|NL
argument_list|(
literal|"std::ostream"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std::basic_ostream<char, std::char_traits<char>>"
argument_list|)
block|,
name|NL
argument_list|(
literal|"basic_ostream"
argument_list|)
block|}
block|,
block|{
literal|'d'
block|,
name|NL
argument_list|(
literal|"std::iostream"
argument_list|)
block|,
name|NL
argument_list|(
literal|"std::basic_iostream<char, std::char_traits<char>>"
argument_list|)
block|,
name|NL
argument_list|(
literal|"basic_iostream"
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|demangle_component
modifier|*
name|d_substitution
parameter_list|(
name|struct
name|d_info
modifier|*
name|di
parameter_list|,
name|int
name|prefix
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|d_check_char
argument_list|(
name|di
argument_list|,
literal|'S'
argument_list|)
condition|)
return|return
name|NULL
return|;
name|c
operator|=
name|d_next_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
operator|||
name|IS_DIGIT
argument_list|(
name|c
argument_list|)
operator|||
name|IS_UPPER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|id
decl_stmt|;
name|id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'_'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|id
operator|=
name|id
operator|*
literal|36
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_UPPER
argument_list|(
name|c
argument_list|)
condition|)
name|id
operator|=
name|id
operator|*
literal|36
operator|+
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|id
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|c
operator|=
name|d_next_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'_'
condition|)
do|;
operator|++
name|id
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|>=
name|di
operator|->
name|next_sub
condition|)
return|return
name|NULL
return|;
operator|++
name|di
operator|->
name|did_subs
expr_stmt|;
return|return
name|di
operator|->
name|subs
index|[
name|id
index|]
return|;
block|}
else|else
block|{
name|int
name|verbose
decl_stmt|;
specifier|const
name|struct
name|d_standard_sub_info
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|d_standard_sub_info
modifier|*
name|pend
decl_stmt|;
name|verbose
operator|=
operator|(
name|di
operator|->
name|options
operator|&
name|DMGL_VERBOSE
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
operator|&&
name|prefix
condition|)
block|{
name|char
name|peek
decl_stmt|;
name|peek
operator|=
name|d_peek_char
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'C'
operator|||
name|peek
operator|==
literal|'D'
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
block|}
name|pend
operator|=
operator|(
operator|&
name|standard_subs
index|[
literal|0
index|]
operator|+
sizeof|sizeof
name|standard_subs
operator|/
sizeof|sizeof
name|standard_subs
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|standard_subs
index|[
literal|0
index|]
init|;
name|p
operator|<
name|pend
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|c
operator|==
name|p
operator|->
name|code
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|set_last_name
operator|!=
name|NULL
condition|)
name|di
operator|->
name|last_name
operator|=
name|d_make_sub
argument_list|(
name|di
argument_list|,
name|p
operator|->
name|set_last_name
argument_list|,
name|p
operator|->
name|set_last_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|s
operator|=
name|p
operator|->
name|full_expansion
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|full_len
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|p
operator|->
name|simple_expansion
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|simple_len
expr_stmt|;
block|}
name|di
operator|->
name|expansion
operator|+=
name|len
expr_stmt|;
return|return
name|d_make_sub
argument_list|(
name|di
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Resize the print buffer.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_resize
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
name|size_t
name|add
parameter_list|)
block|{
name|size_t
name|need
decl_stmt|;
if|if
condition|(
name|dpi
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return;
name|need
operator|=
name|dpi
operator|->
name|len
operator|+
name|add
expr_stmt|;
while|while
condition|(
name|need
operator|>
name|dpi
operator|->
name|alc
condition|)
block|{
name|size_t
name|newalc
decl_stmt|;
name|char
modifier|*
name|newbuf
decl_stmt|;
name|newalc
operator|=
name|dpi
operator|->
name|alc
operator|*
literal|2
expr_stmt|;
name|newbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|dpi
operator|->
name|buf
argument_list|,
name|newalc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbuf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dpi
operator|->
name|buf
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|dpi
operator|->
name|allocation_failure
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|dpi
operator|->
name|buf
operator|=
name|newbuf
expr_stmt|;
name|dpi
operator|->
name|alc
operator|=
name|newalc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append a character to the print buffer.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_append_char
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|dpi
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dpi
operator|->
name|len
operator|>=
name|dpi
operator|->
name|alc
condition|)
block|{
name|d_print_resize
argument_list|(
name|dpi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpi
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return;
block|}
name|dpi
operator|->
name|buf
index|[
name|dpi
operator|->
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|dpi
operator|->
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append a buffer to the print buffer.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_append_buffer
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
if|if
condition|(
name|dpi
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dpi
operator|->
name|len
operator|+
name|l
operator|>
name|dpi
operator|->
name|alc
condition|)
block|{
name|d_print_resize
argument_list|(
name|dpi
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpi
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return;
block|}
name|memcpy
argument_list|(
name|dpi
operator|->
name|buf
operator|+
name|dpi
operator|->
name|len
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|len
operator|+=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Indicate that an error occurred during printing.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_error
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|)
block|{
name|free
argument_list|(
name|dpi
operator|->
name|buf
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn components into a human readable string.  OPTIONS is the    options bits passed to the demangler.  DC is the tree to print.    ESTIMATE is a guess at the length of the result.  This returns a    string allocated by malloc, or NULL on error.  On success, this    sets *PALC to the size of the allocated buffer.  On failure, this    sets *PALC to 0 for a bad parse, or to 1 for a memory allocation    failure.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|char
modifier|*
name|cplus_demangle_print
parameter_list|(
name|int
name|options
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|,
name|int
name|estimate
parameter_list|,
name|size_t
modifier|*
name|palc
parameter_list|)
block|{
name|struct
name|d_print_info
name|dpi
decl_stmt|;
name|dpi
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|dpi
operator|.
name|alc
operator|=
name|estimate
operator|+
literal|1
expr_stmt|;
name|dpi
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dpi
operator|.
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpi
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
operator|*
name|palc
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dpi
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|dpi
operator|.
name|templates
operator|=
name|NULL
expr_stmt|;
name|dpi
operator|.
name|modifiers
operator|=
name|NULL
expr_stmt|;
name|dpi
operator|.
name|allocation_failure
operator|=
literal|0
expr_stmt|;
name|d_print_comp
argument_list|(
operator|&
name|dpi
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
operator|&
name|dpi
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpi
operator|.
name|buf
operator|!=
name|NULL
condition|)
operator|*
name|palc
operator|=
name|dpi
operator|.
name|alc
expr_stmt|;
else|else
operator|*
name|palc
operator|=
name|dpi
operator|.
name|allocation_failure
expr_stmt|;
return|return
name|dpi
operator|.
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Subroutine to handle components.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_comp
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|)
block|{
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d_print_saw_error
argument_list|(
name|dpi
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|dc
operator|->
name|type
condition|)
block|{
case|case
name|DEMANGLE_COMPONENT_NAME
case|:
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|==
literal|0
condition|)
name|d_append_buffer
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_name
operator|.
name|s
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_name
operator|.
name|len
argument_list|)
expr_stmt|;
else|else
name|d_print_java_identifier
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_name
operator|.
name|s
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_name
operator|.
name|len
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_QUAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_LOCAL_NAME
case|:
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|==
literal|0
condition|)
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
else|else
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TYPED_NAME
case|:
block|{
name|struct
name|d_print_mod
modifier|*
name|hold_modifiers
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|typed_name
decl_stmt|;
name|struct
name|d_print_mod
name|adpm
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|d_print_template
name|dpt
decl_stmt|;
comment|/* Pass the name down to the type so that it can be printed in 	   the right place for the type.  We also have to pass down 	   any CV-qualifiers, which apply to the this parameter.  */
name|hold_modifiers
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|typed_name
operator|=
name|d_left
argument_list|(
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
name|typed_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
name|adpm
operator|/
sizeof|sizeof
name|adpm
index|[
literal|0
index|]
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
name|adpm
index|[
name|i
index|]
operator|.
name|next
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|adpm
index|[
name|i
index|]
expr_stmt|;
name|adpm
index|[
name|i
index|]
operator|.
name|mod
operator|=
name|typed_name
expr_stmt|;
name|adpm
index|[
name|i
index|]
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|adpm
index|[
name|i
index|]
operator|.
name|templates
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|typed_name
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_RESTRICT_THIS
operator|&&
name|typed_name
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_VOLATILE_THIS
operator|&&
name|typed_name
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_CONST_THIS
condition|)
break|break;
name|typed_name
operator|=
name|d_left
argument_list|(
name|typed_name
argument_list|)
expr_stmt|;
block|}
comment|/* If typed_name is a template, then it applies to the 	   function type as well.  */
if|if
condition|(
name|typed_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_TEMPLATE
condition|)
block|{
name|dpt
operator|.
name|next
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
operator|&
name|dpt
expr_stmt|;
name|dpt
operator|.
name|template_decl
operator|=
name|typed_name
expr_stmt|;
block|}
comment|/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then 	   there may be CV-qualifiers on its right argument which 	   really apply here; this happens when parsing a class which 	   is local to a function.  */
if|if
condition|(
name|typed_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_LOCAL_NAME
condition|)
block|{
name|struct
name|demangle_component
modifier|*
name|local_name
decl_stmt|;
name|local_name
operator|=
name|d_right
argument_list|(
name|typed_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|local_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_RESTRICT_THIS
operator|||
name|local_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_VOLATILE_THIS
operator|||
name|local_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_CONST_THIS
condition|)
block|{
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
name|adpm
operator|/
sizeof|sizeof
name|adpm
index|[
literal|0
index|]
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
name|adpm
index|[
name|i
index|]
operator|=
name|adpm
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|adpm
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|adpm
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|adpm
index|[
name|i
index|]
expr_stmt|;
name|adpm
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|mod
operator|=
name|local_name
expr_stmt|;
name|adpm
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|adpm
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|templates
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|local_name
operator|=
name|d_left
argument_list|(
name|local_name
argument_list|)
expr_stmt|;
block|}
block|}
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typed_name
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_TEMPLATE
condition|)
name|dpi
operator|->
name|templates
operator|=
name|dpt
operator|.
name|next
expr_stmt|;
comment|/* If the modifiers didn't get printed by the type, print them 	   now.  */
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|--
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|adpm
index|[
name|i
index|]
operator|.
name|printed
condition|)
block|{
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_print_mod
argument_list|(
name|dpi
argument_list|,
name|adpm
index|[
name|i
index|]
operator|.
name|mod
argument_list|)
expr_stmt|;
block|}
block|}
name|dpi
operator|->
name|modifiers
operator|=
name|hold_modifiers
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_TEMPLATE
case|:
block|{
name|struct
name|d_print_mod
modifier|*
name|hold_dpm
decl_stmt|;
comment|/* Don't push modifiers into a template definition.  Doing so 	   could give the wrong definition for a template argument. 	   Instead, treat the template essentially as a name.  */
name|hold_dpm
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|NULL
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|==
literal|'<'
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid generating two consecutive '>' characters, to avoid 	   the C++ syntactic ambiguity.  */
if|if
condition|(
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|==
literal|'>'
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|hold_dpm
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_TEMPLATE_PARAM
case|:
block|{
name|long
name|i
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|a
decl_stmt|;
name|struct
name|d_print_template
modifier|*
name|hold_dpt
decl_stmt|;
if|if
condition|(
name|dpi
operator|->
name|templates
operator|==
name|NULL
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|dc
operator|->
name|u
operator|.
name|s_number
operator|.
name|number
expr_stmt|;
for|for
control|(
name|a
operator|=
name|d_right
argument_list|(
name|dpi
operator|->
name|templates
operator|->
name|template_decl
argument_list|)
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|d_right
argument_list|(
name|a
argument_list|)
control|)
block|{
if|if
condition|(
name|a
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
operator|--
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
name|a
operator|==
name|NULL
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* While processing this parameter, we need to pop the list of 	   templates.  This is because the template parameter may 	   itself be a reference to a parameter of an outer 	   template.  */
name|hold_dpt
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|hold_dpt
operator|->
name|next
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|hold_dpt
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_CTOR
case|:
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_ctor
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_DTOR
case|:
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_dtor
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_VTABLE
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"vtable for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_VTT
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"VTT for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"construction vtable for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"-in-"
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TYPEINFO
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"typeinfo for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_NAME
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"typeinfo name for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TYPEINFO_FN
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"typeinfo fn for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_THUNK
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"non-virtual thunk to "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_VIRTUAL_THUNK
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"virtual thunk to "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_COVARIANT_THUNK
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"covariant return thunk to "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_JAVA_CLASS
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"java Class for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_GUARD
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"guard variable for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_REFTEMP
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"reference temporary for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_HIDDEN_ALIAS
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"hidden alias for "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_SUB_STD
case|:
name|d_append_buffer
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_string
operator|.
name|string
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_string
operator|.
name|len
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_RESTRICT
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE
case|:
case|case
name|DEMANGLE_COMPONENT_CONST
case|:
block|{
name|struct
name|d_print_mod
modifier|*
name|pdpm
decl_stmt|;
comment|/* When printing arrays, it's possible to have cases where the 	   same CV-qualifier gets pushed on the stack multiple times. 	   We only need to print it once.  */
for|for
control|(
name|pdpm
operator|=
name|dpi
operator|->
name|modifiers
init|;
name|pdpm
operator|!=
name|NULL
condition|;
name|pdpm
operator|=
name|pdpm
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|pdpm
operator|->
name|printed
condition|)
block|{
if|if
condition|(
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_RESTRICT
operator|&&
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_VOLATILE
operator|&&
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_CONST
condition|)
break|break;
if|if
condition|(
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|==
name|dc
operator|->
name|type
condition|)
block|{
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/* Fall through.  */
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
case|:
case|case
name|DEMANGLE_COMPONENT_POINTER
case|:
case|case
name|DEMANGLE_COMPONENT_REFERENCE
case|:
case|case
name|DEMANGLE_COMPONENT_COMPLEX
case|:
case|case
name|DEMANGLE_COMPONENT_IMAGINARY
case|:
block|{
comment|/* We keep a list of modifiers on the stack.  */
name|struct
name|d_print_mod
name|dpm
decl_stmt|;
name|dpm
operator|.
name|next
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|dpm
expr_stmt|;
name|dpm
operator|.
name|mod
operator|=
name|dc
expr_stmt|;
name|dpm
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|dpm
operator|.
name|templates
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the modifier didn't get printed by the type, print it 	   now.  */
if|if
condition|(
operator|!
name|dpm
operator|.
name|printed
condition|)
name|d_print_mod
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|dpm
operator|.
name|next
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
case|:
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|==
literal|0
condition|)
name|d_append_buffer
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|name
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|d_append_buffer
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|java_name
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|java_len
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE
case|:
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
case|:
block|{
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_RET_POSTFIX
operator|)
operator|!=
literal|0
condition|)
name|d_print_function_type
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|,
name|dpi
operator|->
name|modifiers
argument_list|)
expr_stmt|;
comment|/* Print return type if present */
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|d_print_mod
name|dpm
decl_stmt|;
comment|/* We must pass this type down as a modifier in order to 	       print it in the right location.  */
name|dpm
operator|.
name|next
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|dpm
expr_stmt|;
name|dpm
operator|.
name|mod
operator|=
name|dc
expr_stmt|;
name|dpm
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|dpm
operator|.
name|templates
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|dpm
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|dpm
operator|.
name|printed
condition|)
return|return;
comment|/* In standard prefix notation, there is a space between the 	       return type and the function signature.  */
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_RET_POSTFIX
operator|)
operator|==
literal|0
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_RET_POSTFIX
operator|)
operator|==
literal|0
condition|)
name|d_print_function_type
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|,
name|dpi
operator|->
name|modifiers
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_ARRAY_TYPE
case|:
block|{
name|struct
name|d_print_mod
modifier|*
name|hold_modifiers
decl_stmt|;
name|struct
name|d_print_mod
name|adpm
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|d_print_mod
modifier|*
name|pdpm
decl_stmt|;
comment|/* We must pass this type down as a modifier in order to print 	   multi-dimensional arrays correctly.  If the array itself is 	   CV-qualified, we act as though the element type were 	   CV-qualified.  We do this by copying the modifiers down 	   rather than fiddling pointers, so that we don't wind up 	   with a d_print_mod higher on the stack pointing into our 	   stack frame after we return.  */
name|hold_modifiers
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|adpm
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|hold_modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|adpm
index|[
literal|0
index|]
expr_stmt|;
name|adpm
index|[
literal|0
index|]
operator|.
name|mod
operator|=
name|dc
expr_stmt|;
name|adpm
index|[
literal|0
index|]
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|adpm
index|[
literal|0
index|]
operator|.
name|templates
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|pdpm
operator|=
name|hold_modifiers
expr_stmt|;
while|while
condition|(
name|pdpm
operator|!=
name|NULL
operator|&&
operator|(
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_RESTRICT
operator|||
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_VOLATILE
operator|||
name|pdpm
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_CONST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pdpm
operator|->
name|printed
condition|)
block|{
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
name|adpm
operator|/
sizeof|sizeof
name|adpm
index|[
literal|0
index|]
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
name|adpm
index|[
name|i
index|]
operator|=
operator|*
name|pdpm
expr_stmt|;
name|adpm
index|[
name|i
index|]
operator|.
name|next
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|adpm
index|[
name|i
index|]
expr_stmt|;
name|pdpm
operator|->
name|printed
operator|=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|pdpm
operator|=
name|pdpm
operator|->
name|next
expr_stmt|;
block|}
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|hold_modifiers
expr_stmt|;
if|if
condition|(
name|adpm
index|[
literal|0
index|]
operator|.
name|printed
condition|)
return|return;
while|while
condition|(
name|i
operator|>
literal|1
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|d_print_mod
argument_list|(
name|dpi
argument_list|,
name|adpm
index|[
name|i
index|]
operator|.
name|mod
argument_list|)
expr_stmt|;
block|}
name|d_print_array_type
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|,
name|dpi
operator|->
name|modifiers
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
case|:
block|{
name|struct
name|d_print_mod
name|dpm
decl_stmt|;
name|dpm
operator|.
name|next
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
operator|&
name|dpm
expr_stmt|;
name|dpm
operator|.
name|mod
operator|=
name|dc
expr_stmt|;
name|dpm
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|dpm
operator|.
name|templates
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the modifier didn't get printed by the type, print it 	   now.  */
if|if
condition|(
operator|!
name|dpm
operator|.
name|printed
condition|)
block|{
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"::*"
argument_list|)
expr_stmt|;
block|}
name|dpi
operator|->
name|modifiers
operator|=
name|dpm
operator|.
name|next
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_ARGLIST
case|:
case|case
name|DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
case|:
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|DEMANGLE_COMPONENT_OPERATOR
case|:
block|{
name|char
name|c
decl_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|c
operator|=
name|dc
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|IS_LOWER
argument_list|(
name|c
argument_list|)
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_buffer
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|name
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|DEMANGLE_COMPONENT_EXTENDED_OPERATOR
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_extended_operator
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_CAST
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|d_print_cast
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_UNARY
case|:
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_CAST
condition|)
name|d_print_expr_op
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|d_print_cast
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_BINARY
case|:
if|if
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_BINARY_ARGS
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We wrap an expression which uses the greater-than operator in 	 an extra layer of parens so that it does not get confused 	 with the '>' which ends the template parameters.  */
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_OPERATOR
operator|&&
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|len
operator|==
literal|1
operator|&&
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'>'
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|d_print_expr_op
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_OPERATOR
operator|&&
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|len
operator|==
literal|1
operator|&&
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'>'
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_BINARY_ARGS
case|:
comment|/* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TRINARY
case|:
if|if
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_TRINARY_ARG1
operator|||
name|d_right
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_TRINARY_ARG2
condition|)
block|{
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|d_print_expr_op
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|d_right
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|") : ("
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|d_right
argument_list|(
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG1
case|:
case|case
name|DEMANGLE_COMPONENT_TRINARY_ARG2
case|:
comment|/* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_LITERAL
case|:
case|case
name|DEMANGLE_COMPONENT_LITERAL_NEG
case|:
block|{
name|enum
name|d_builtin_type_print
name|tp
decl_stmt|;
comment|/* For some builtin types, produce simpler output.  */
name|tp
operator|=
name|D_PRINT_DEFAULT
expr_stmt|;
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_BUILTIN_TYPE
condition|)
block|{
name|tp
operator|=
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_builtin
operator|.
name|type
operator|->
name|print
expr_stmt|;
switch|switch
condition|(
name|tp
condition|)
block|{
case|case
name|D_PRINT_INT
case|:
case|case
name|D_PRINT_UNSIGNED
case|:
case|case
name|D_PRINT_LONG
case|:
case|case
name|D_PRINT_UNSIGNED_LONG
case|:
case|case
name|D_PRINT_LONG_LONG
case|:
case|case
name|D_PRINT_UNSIGNED_LONG_LONG
case|:
if|if
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_NAME
condition|)
block|{
if|if
condition|(
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_LITERAL_NEG
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tp
condition|)
block|{
default|default:
break|break;
case|case
name|D_PRINT_UNSIGNED
case|:
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_PRINT_LONG
case|:
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_PRINT_UNSIGNED_LONG
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"ul"
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_PRINT_LONG_LONG
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"ll"
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_PRINT_UNSIGNED_LONG_LONG
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"ull"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
break|break;
case|case
name|D_PRINT_BOOL
case|:
if|if
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_NAME
operator|&&
name|d_right
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_name
operator|.
name|len
operator|==
literal|1
operator|&&
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_LITERAL
condition|)
block|{
switch|switch
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|->
name|u
operator|.
name|s_name
operator|.
name|s
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'0'
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'1'
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_LITERAL_NEG
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|D_PRINT_FLOAT
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|D_PRINT_FLOAT
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|d_print_error
argument_list|(
name|dpi
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Print a Java dentifier.  For Java we try to handle encoded extended    Unicode characters.  The C++ ABI doesn't mention Unicode encoding,    so we don't it for C++.  Characters are encoded as    __U<hex-char>+_.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_java_identifier
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|name
operator|+
name|len
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
name|p
operator|<
name|end
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|end
operator|-
name|p
operator|>
literal|3
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'U'
condition|)
block|{
name|unsigned
name|long
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|+
literal|3
init|;
name|q
operator|<
name|end
condition|;
operator|++
name|q
control|)
block|{
name|int
name|dig
decl_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|dig
operator|=
operator|*
name|q
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|>=
literal|'A'
operator|&&
operator|*
name|q
operator|<=
literal|'F'
condition|)
name|dig
operator|=
operator|*
name|q
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|>=
literal|'a'
operator|&&
operator|*
name|q
operator|<=
literal|'f'
condition|)
name|dig
operator|=
operator|*
name|q
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
break|break;
name|c
operator|=
name|c
operator|*
literal|16
operator|+
name|dig
expr_stmt|;
block|}
comment|/* If the Unicode character is larger than 256, we don't try 	     to deal with it here.  FIXME.  */
if|if
condition|(
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|==
literal|'_'
operator|&&
name|c
operator|<
literal|256
condition|)
block|{
name|d_append_char
argument_list|(
name|dpi
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
continue|continue;
block|}
block|}
name|d_append_char
argument_list|(
name|dpi
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a list of modifiers.  SUFFIX is 1 if we are printing    qualifiers on this after printing a function.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_mod_list
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
name|struct
name|d_print_mod
modifier|*
name|mods
parameter_list|,
name|int
name|suffix
parameter_list|)
block|{
name|struct
name|d_print_template
modifier|*
name|hold_dpt
decl_stmt|;
if|if
condition|(
name|mods
operator|==
name|NULL
operator|||
name|d_print_saw_error
argument_list|(
name|dpi
argument_list|)
condition|)
return|return;
if|if
condition|(
name|mods
operator|->
name|printed
operator|||
operator|(
operator|!
name|suffix
operator|&&
operator|(
name|mods
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_RESTRICT_THIS
operator|||
name|mods
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_VOLATILE_THIS
operator|||
name|mods
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_CONST_THIS
operator|)
operator|)
condition|)
block|{
name|d_print_mod_list
argument_list|(
name|dpi
argument_list|,
name|mods
operator|->
name|next
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
name|mods
operator|->
name|printed
operator|=
literal|1
expr_stmt|;
name|hold_dpt
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|mods
operator|->
name|templates
expr_stmt|;
if|if
condition|(
name|mods
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_FUNCTION_TYPE
condition|)
block|{
name|d_print_function_type
argument_list|(
name|dpi
argument_list|,
name|mods
operator|->
name|mod
argument_list|,
name|mods
operator|->
name|next
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|hold_dpt
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mods
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_ARRAY_TYPE
condition|)
block|{
name|d_print_array_type
argument_list|(
name|dpi
argument_list|,
name|mods
operator|->
name|mod
argument_list|,
name|mods
operator|->
name|next
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|hold_dpt
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mods
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_LOCAL_NAME
condition|)
block|{
name|struct
name|d_print_mod
modifier|*
name|hold_modifiers
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
comment|/* When this is on the modifier stack, we have pulled any 	 qualifiers off the right argument already.  Otherwise, we 	 print it as usual, but don't let the left argument see any 	 modifiers.  */
name|hold_modifiers
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|NULL
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|mods
operator|->
name|mod
argument_list|)
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|hold_modifiers
expr_stmt|;
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|==
literal|0
condition|)
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
else|else
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|dc
operator|=
name|d_right
argument_list|(
name|mods
operator|->
name|mod
argument_list|)
expr_stmt|;
while|while
condition|(
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_RESTRICT_THIS
operator|||
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_VOLATILE_THIS
operator|||
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_CONST_THIS
condition|)
name|dc
operator|=
name|d_left
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|hold_dpt
expr_stmt|;
return|return;
block|}
name|d_print_mod
argument_list|(
name|dpi
argument_list|,
name|mods
operator|->
name|mod
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|hold_dpt
expr_stmt|;
name|d_print_mod_list
argument_list|(
name|dpi
argument_list|,
name|mods
operator|->
name|next
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a modifier.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_mod
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|mod
parameter_list|)
block|{
switch|switch
condition|(
name|mod
operator|->
name|type
condition|)
block|{
case|case
name|DEMANGLE_COMPONENT_RESTRICT
case|:
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|" restrict"
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_VOLATILE
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|" volatile"
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_CONST
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|" const"
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
case|:
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|mod
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_POINTER
case|:
comment|/* There is no pointer symbol in Java.  */
if|if
condition|(
operator|(
name|dpi
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|==
literal|0
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_REFERENCE
case|:
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_COMPLEX
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"complex "
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_IMAGINARY
case|:
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"imaginary "
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
case|:
if|if
condition|(
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|!=
literal|'('
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|mod
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|"::*"
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEMANGLE_COMPONENT_TYPED_NAME
case|:
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|mod
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Otherwise, we have something that won't go back on the 	 modifier stack, so we can just print it.  */
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|mod
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Print a function type, except for the return type.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_function_type
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|,
name|struct
name|d_print_mod
modifier|*
name|mods
parameter_list|)
block|{
name|int
name|need_paren
decl_stmt|;
name|int
name|saw_mod
decl_stmt|;
name|int
name|need_space
decl_stmt|;
name|struct
name|d_print_mod
modifier|*
name|p
decl_stmt|;
name|struct
name|d_print_mod
modifier|*
name|hold_modifiers
decl_stmt|;
name|need_paren
operator|=
literal|0
expr_stmt|;
name|saw_mod
operator|=
literal|0
expr_stmt|;
name|need_space
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mods
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|printed
condition|)
break|break;
name|saw_mod
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|mod
operator|->
name|type
condition|)
block|{
case|case
name|DEMANGLE_COMPONENT_POINTER
case|:
case|case
name|DEMANGLE_COMPONENT_REFERENCE
case|:
name|need_paren
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_RESTRICT
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE
case|:
case|case
name|DEMANGLE_COMPONENT_CONST
case|:
case|case
name|DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL
case|:
case|case
name|DEMANGLE_COMPONENT_COMPLEX
case|:
case|case
name|DEMANGLE_COMPONENT_IMAGINARY
case|:
case|case
name|DEMANGLE_COMPONENT_PTRMEM_TYPE
case|:
name|need_space
operator|=
literal|1
expr_stmt|;
name|need_paren
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|need_paren
condition|)
break|break;
block|}
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|saw_mod
condition|)
name|need_paren
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_paren
condition|)
block|{
if|if
condition|(
operator|!
name|need_space
condition|)
block|{
if|if
condition|(
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|!=
literal|'('
operator|&&
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|!=
literal|'*'
condition|)
name|need_space
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_space
operator|&&
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|!=
literal|' '
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
block|}
name|hold_modifiers
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|NULL
expr_stmt|;
name|d_print_mod_list
argument_list|(
name|dpi
argument_list|,
name|mods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_paren
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_right
argument_list|(
name|dc
argument_list|)
operator|!=
name|NULL
condition|)
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|d_print_mod_list
argument_list|(
name|dpi
argument_list|,
name|mods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|hold_modifiers
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an array type, except for the element type.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_array_type
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|,
name|struct
name|d_print_mod
modifier|*
name|mods
parameter_list|)
block|{
name|int
name|need_space
decl_stmt|;
name|need_space
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mods
operator|!=
name|NULL
condition|)
block|{
name|int
name|need_paren
decl_stmt|;
name|struct
name|d_print_mod
modifier|*
name|p
decl_stmt|;
name|need_paren
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mods
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|printed
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|mod
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_ARRAY_TYPE
condition|)
block|{
name|need_space
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|need_paren
operator|=
literal|1
expr_stmt|;
name|need_space
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|need_paren
condition|)
name|d_append_string_constant
argument_list|(
name|dpi
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|d_print_mod_list
argument_list|(
name|dpi
argument_list|,
name|mods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_paren
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_space
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|!=
name|NULL
condition|)
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an operator in an expression.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_expr_op
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|)
block|{
if|if
condition|(
name|dc
operator|->
name|type
operator|==
name|DEMANGLE_COMPONENT_OPERATOR
condition|)
name|d_append_buffer
argument_list|(
name|dpi
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|name
argument_list|,
name|dc
operator|->
name|u
operator|.
name|s_operator
operator|.
name|op
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a cast.  */
end_comment

begin_function
specifier|static
name|void
name|d_print_cast
parameter_list|(
name|struct
name|d_print_info
modifier|*
name|dpi
parameter_list|,
specifier|const
name|struct
name|demangle_component
modifier|*
name|dc
parameter_list|)
block|{
if|if
condition|(
name|d_left
argument_list|(
name|dc
argument_list|)
operator|->
name|type
operator|!=
name|DEMANGLE_COMPONENT_TEMPLATE
condition|)
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|d_print_mod
modifier|*
name|hold_dpm
decl_stmt|;
name|struct
name|d_print_template
name|dpt
decl_stmt|;
comment|/* It appears that for a templated cast operator, we need to put 	 the template parameters in scope for the operator name, but 	 not for the parameters.  The effect is that we need to handle 	 the template printing here.  */
name|hold_dpm
operator|=
name|dpi
operator|->
name|modifiers
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|NULL
expr_stmt|;
name|dpt
operator|.
name|next
operator|=
name|dpi
operator|->
name|templates
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
operator|&
name|dpt
expr_stmt|;
name|dpt
operator|.
name|template_decl
operator|=
name|d_left
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_left
argument_list|(
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|templates
operator|=
name|dpt
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|==
literal|'<'
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|d_print_comp
argument_list|(
name|dpi
argument_list|,
name|d_right
argument_list|(
name|d_left
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid generating two consecutive '>' characters, to avoid 	 the C++ syntactic ambiguity.  */
if|if
condition|(
name|d_last_char
argument_list|(
name|dpi
argument_list|)
operator|==
literal|'>'
condition|)
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|d_append_char
argument_list|(
name|dpi
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
name|dpi
operator|->
name|modifiers
operator|=
name|hold_dpm
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the information structure we use to pass around    information.  */
end_comment

begin_function
name|CP_STATIC_IF_GLIBCPP_V3
name|void
name|cplus_demangle_init_info
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|d_info
modifier|*
name|di
parameter_list|)
block|{
name|di
operator|->
name|s
operator|=
name|mangled
expr_stmt|;
name|di
operator|->
name|send
operator|=
name|mangled
operator|+
name|len
expr_stmt|;
name|di
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|di
operator|->
name|n
operator|=
name|mangled
expr_stmt|;
comment|/* We can not need more components than twice the number of chars in      the mangled string.  Most components correspond directly to      chars, but the ARGLIST types are exceptions.  */
name|di
operator|->
name|num_comps
operator|=
literal|2
operator|*
name|len
expr_stmt|;
name|di
operator|->
name|next_comp
operator|=
literal|0
expr_stmt|;
comment|/* Similarly, we can not need more substitutions than there are      chars in the mangled string.  */
name|di
operator|->
name|num_subs
operator|=
name|len
expr_stmt|;
name|di
operator|->
name|next_sub
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|did_subs
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|last_name
operator|=
name|NULL
expr_stmt|;
name|di
operator|->
name|expansion
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled    name, return a buffer allocated with malloc holding the demangled    name.  OPTIONS is the usual libiberty demangler options.  On    success, this sets *PALC to the allocated size of the returned    buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for    a memory allocation failure.  On failure, this returns NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|d_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|,
name|size_t
modifier|*
name|palc
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|d_info
name|di
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
name|int
name|estimate
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
operator|*
name|palc
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
name|type
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|mangled
argument_list|,
literal|"_GLOBAL_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|mangled
index|[
literal|8
index|]
operator|==
literal|'.'
operator|||
name|mangled
index|[
literal|8
index|]
operator|==
literal|'_'
operator|||
name|mangled
index|[
literal|8
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|mangled
index|[
literal|9
index|]
operator|==
literal|'D'
operator|||
name|mangled
index|[
literal|9
index|]
operator|==
literal|'I'
operator|)
operator|&&
name|mangled
index|[
literal|10
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|40
operator|+
name|len
operator|-
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
operator|*
name|palc
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mangled
index|[
literal|9
index|]
operator|==
literal|'I'
condition|)
name|strcpy
argument_list|(
name|r
argument_list|,
literal|"global constructors keyed to "
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|r
argument_list|,
literal|"global destructors keyed to "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|r
argument_list|,
name|mangled
operator|+
literal|11
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|DMGL_TYPES
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|type
operator|=
literal|1
expr_stmt|;
block|}
name|cplus_demangle_init_info
argument_list|(
name|mangled
argument_list|,
name|options
argument_list|,
name|len
argument_list|,
operator|&
name|di
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|CP_DYNAMIC_ARRAYS
name|__extension__
name|struct
name|demangle_component
name|comps
index|[
name|di
operator|.
name|num_comps
index|]
decl_stmt|;
name|__extension__
name|struct
name|demangle_component
modifier|*
name|subs
index|[
name|di
operator|.
name|num_subs
index|]
decl_stmt|;
name|di
operator|.
name|comps
operator|=
operator|&
name|comps
index|[
literal|0
index|]
expr_stmt|;
name|di
operator|.
name|subs
operator|=
operator|&
name|subs
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|di
operator|.
name|comps
operator|=
operator|(
operator|(
expr|struct
name|demangle_component
operator|*
operator|)
name|malloc
argument_list|(
name|di
operator|.
name|num_comps
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|demangle_component
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|di
operator|.
name|subs
operator|=
operator|(
operator|(
expr|struct
name|demangle_component
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|di
operator|.
name|num_subs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|demangle_component
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|comps
operator|==
name|NULL
operator|||
name|di
operator|.
name|subs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|di
operator|.
name|comps
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|di
operator|.
name|comps
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|subs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|di
operator|.
name|subs
argument_list|)
expr_stmt|;
operator|*
name|palc
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|type
condition|)
name|dc
operator|=
name|cplus_demangle_mangled_name
argument_list|(
operator|&
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|dc
operator|=
name|cplus_demangle_type
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
comment|/* If DMGL_PARAMS is set, then if we didn't consume the entire        mangled string, then we didn't successfully demangle it.  If        DMGL_PARAMS is not set, we didn't look at the trailing        parameters.  */
if|if
condition|(
operator|(
operator|(
name|options
operator|&
name|DMGL_PARAMS
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|d_peek_char
argument_list|(
operator|&
name|di
argument_list|)
operator|!=
literal|'\0'
condition|)
name|dc
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"failed demangling\n"
argument_list|)
expr_stmt|;
else|else
name|d_dump
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We try to guess the length of the demangled string, to minimize        calls to realloc during demangling.  */
name|estimate
operator|=
name|len
operator|+
name|di
operator|.
name|expansion
operator|+
literal|10
operator|*
name|di
operator|.
name|did_subs
expr_stmt|;
name|estimate
operator|+=
name|estimate
operator|/
literal|8
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dc
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|cplus_demangle_print
argument_list|(
name|options
argument_list|,
name|dc
argument_list|,
name|estimate
argument_list|,
name|palc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CP_DYNAMIC_ARRAYS
name|free
argument_list|(
name|di
operator|.
name|comps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|.
name|subs
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|int
name|rlen
decl_stmt|;
name|rlen
operator|=
name|strlen
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|>
literal|2
operator|*
name|estimate
condition|)
name|printf
argument_list|(
literal|"*** Length %d much greater than estimate %d\n"
argument_list|,
name|rlen
argument_list|,
name|estimate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rlen
operator|>
name|estimate
condition|)
name|printf
argument_list|(
literal|"*** Length %d greater than estimate %d\n"
argument_list|,
name|rlen
argument_list|,
name|estimate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rlen
operator|<
name|estimate
operator|/
literal|2
condition|)
name|printf
argument_list|(
literal|"*** Length %d much less than estimate %d\n"
argument_list|,
name|rlen
argument_list|,
name|estimate
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IN_LIBGCC2
argument_list|)
operator|||
name|defined
argument_list|(
name|IN_GLIBCPP_V3
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|__cxa_demangle
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ia64 ABI-mandated entry point in the C++ runtime library for    performing demangling.  MANGLED_NAME is a NUL-terminated character    string containing the name to be demangled.     OUTPUT_BUFFER is a region of memory, allocated with malloc, of    *LENGTH bytes, into which the demangled name is stored.  If    OUTPUT_BUFFER is not long enough, it is expanded using realloc.    OUTPUT_BUFFER may instead be NULL; in that case, the demangled name    is placed in a region of memory allocated with malloc.     If LENGTH is non-NULL, the length of the buffer conaining the    demangled name, is placed in *LENGTH.     The return value is a pointer to the start of the NUL-terminated    demangled name, or NULL if the demangling fails.  The caller is    responsible for deallocating this memory using free.     *STATUS is set to one of the following values:       0: The demangling operation succeeded.      -1: A memory allocation failure occurred.      -2: MANGLED_NAME is not a valid name under the C++ ABI mangling rules.      -3: One of the arguments is invalid.     The demangling is performed using the C++ ABI mangling rules, with    GNU extensions.  */
end_comment

begin_function
name|char
modifier|*
name|__cxa_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled_name
parameter_list|,
name|char
modifier|*
name|output_buffer
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
name|size_t
name|alc
decl_stmt|;
if|if
condition|(
name|mangled_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
operator|*
name|status
operator|=
operator|-
literal|3
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|output_buffer
operator|!=
name|NULL
operator|&&
name|length
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
operator|*
name|status
operator|=
operator|-
literal|3
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|demangled
operator|=
name|d_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_TYPES
argument_list|,
operator|&
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alc
operator|==
literal|1
condition|)
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|-
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|output_buffer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|alc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|demangled
argument_list|)
operator|<
operator|*
name|length
condition|)
block|{
name|strcpy
argument_list|(
name|output_buffer
argument_list|,
name|demangled
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|output_buffer
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|output_buffer
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|alc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
name|demangled
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! (IN_LIBGCC2 || IN_GLIBCPP_V3) */
end_comment

begin_comment
comment|/* Entry point for libiberty demangler.  If MANGLED is a g++ v3 ABI    mangled name, return a buffer allocated with malloc holding the    demangled name.  Otherwise, return NULL.  */
end_comment

begin_function
name|char
modifier|*
name|cplus_demangle_v3
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|size_t
name|alc
decl_stmt|;
return|return
name|d_demangle
argument_list|(
name|mangled
argument_list|,
name|options
argument_list|,
operator|&
name|alc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Demangle a Java symbol.  Java uses a subset of the V3 ABI C++ mangling     conventions, but the output formatting is a little different.    This instructs the C++ demangler not to emit pointer characters ("*"), and     to use Java's namespace separator symbol ("." instead of "::").  It then     does an additional pass over the demangled output to replace instances     of JArray<TYPE> with TYPE[].  */
end_comment

begin_function
name|char
modifier|*
name|java_demangle_v3
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|)
block|{
name|size_t
name|alc
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
name|int
name|nesting
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|demangled
operator|=
name|d_demangle
argument_list|(
name|mangled
argument_list|,
name|DMGL_JAVA
operator||
name|DMGL_PARAMS
operator||
name|DMGL_RET_POSTFIX
argument_list|,
operator|&
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nesting
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|demangled
expr_stmt|;
name|to
operator|=
name|from
expr_stmt|;
while|while
condition|(
operator|*
name|from
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|from
argument_list|,
literal|"JArray<"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|from
operator|+=
literal|7
expr_stmt|;
operator|++
name|nesting
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nesting
operator|>
literal|0
operator|&&
operator|*
name|from
operator|==
literal|'>'
condition|)
block|{
while|while
condition|(
name|to
operator|>
name|demangled
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|to
expr_stmt|;
operator|*
name|to
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|to
operator|++
operator|=
literal|']'
expr_stmt|;
operator|--
name|nesting
expr_stmt|;
operator|++
name|from
expr_stmt|;
block|}
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
name|demangled
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IN_LIBGCC2 || IN_GLIBCPP_V3 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_GLIBCPP_V3
end_ifndef

begin_comment
comment|/* Demangle a string in order to find out whether it is a constructor    or destructor.  Return non-zero on success.  Set *CTOR_KIND and    *DTOR_KIND appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|is_ctor_or_dtor
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|enum
name|gnu_v3_ctor_kinds
modifier|*
name|ctor_kind
parameter_list|,
name|enum
name|gnu_v3_dtor_kinds
modifier|*
name|dtor_kind
parameter_list|)
block|{
name|struct
name|d_info
name|di
decl_stmt|;
name|struct
name|demangle_component
modifier|*
name|dc
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|ctor_kind
operator|=
operator|(
expr|enum
name|gnu_v3_ctor_kinds
operator|)
literal|0
expr_stmt|;
operator|*
name|dtor_kind
operator|=
operator|(
expr|enum
name|gnu_v3_dtor_kinds
operator|)
literal|0
expr_stmt|;
name|cplus_demangle_init_info
argument_list|(
name|mangled
argument_list|,
name|DMGL_GNU_V3
argument_list|,
name|strlen
argument_list|(
name|mangled
argument_list|)
argument_list|,
operator|&
name|di
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|CP_DYNAMIC_ARRAYS
name|__extension__
name|struct
name|demangle_component
name|comps
index|[
name|di
operator|.
name|num_comps
index|]
decl_stmt|;
name|__extension__
name|struct
name|demangle_component
modifier|*
name|subs
index|[
name|di
operator|.
name|num_subs
index|]
decl_stmt|;
name|di
operator|.
name|comps
operator|=
operator|&
name|comps
index|[
literal|0
index|]
expr_stmt|;
name|di
operator|.
name|subs
operator|=
operator|&
name|subs
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|di
operator|.
name|comps
operator|=
operator|(
operator|(
expr|struct
name|demangle_component
operator|*
operator|)
name|malloc
argument_list|(
name|di
operator|.
name|num_comps
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|demangle_component
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|di
operator|.
name|subs
operator|=
operator|(
operator|(
expr|struct
name|demangle_component
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|di
operator|.
name|num_subs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|demangle_component
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|comps
operator|==
name|NULL
operator|||
name|di
operator|.
name|subs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|di
operator|.
name|comps
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|di
operator|.
name|comps
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|subs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|di
operator|.
name|subs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|dc
operator|=
name|cplus_demangle_mangled_name
argument_list|(
operator|&
name|di
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that because we did not pass DMGL_PARAMS, we don't expect        to demangle the entire string.  */
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dc
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|dc
operator|->
name|type
condition|)
block|{
default|default:
name|dc
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_TYPED_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_TEMPLATE
case|:
case|case
name|DEMANGLE_COMPONENT_RESTRICT_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_VOLATILE_THIS
case|:
case|case
name|DEMANGLE_COMPONENT_CONST_THIS
case|:
name|dc
operator|=
name|d_left
argument_list|(
name|dc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_QUAL_NAME
case|:
case|case
name|DEMANGLE_COMPONENT_LOCAL_NAME
case|:
name|dc
operator|=
name|d_right
argument_list|(
name|dc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_CTOR
case|:
operator|*
name|ctor_kind
operator|=
name|dc
operator|->
name|u
operator|.
name|s_ctor
operator|.
name|kind
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|dc
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|DEMANGLE_COMPONENT_DTOR
case|:
operator|*
name|dtor_kind
operator|=
name|dc
operator|->
name|u
operator|.
name|s_dtor
operator|.
name|kind
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|dc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|CP_DYNAMIC_ARRAYS
name|free
argument_list|(
name|di
operator|.
name|subs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|.
name|comps
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return whether NAME is the mangled form of a g++ V3 ABI constructor    name.  A non-zero return indicates the type of constructor.  */
end_comment

begin_function
name|enum
name|gnu_v3_ctor_kinds
name|is_gnu_v3_mangled_ctor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|gnu_v3_ctor_kinds
name|ctor_kind
decl_stmt|;
name|enum
name|gnu_v3_dtor_kinds
name|dtor_kind
decl_stmt|;
if|if
condition|(
operator|!
name|is_ctor_or_dtor
argument_list|(
name|name
argument_list|,
operator|&
name|ctor_kind
argument_list|,
operator|&
name|dtor_kind
argument_list|)
condition|)
return|return
operator|(
expr|enum
name|gnu_v3_ctor_kinds
operator|)
literal|0
return|;
return|return
name|ctor_kind
return|;
block|}
end_function

begin_comment
comment|/* Return whether NAME is the mangled form of a g++ V3 ABI destructor    name.  A non-zero return indicates the type of destructor.  */
end_comment

begin_function
name|enum
name|gnu_v3_dtor_kinds
name|is_gnu_v3_mangled_dtor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|gnu_v3_ctor_kinds
name|ctor_kind
decl_stmt|;
name|enum
name|gnu_v3_dtor_kinds
name|dtor_kind
decl_stmt|;
if|if
condition|(
operator|!
name|is_ctor_or_dtor
argument_list|(
name|name
argument_list|,
operator|&
name|ctor_kind
argument_list|,
operator|&
name|dtor_kind
argument_list|)
condition|)
return|return
operator|(
expr|enum
name|gnu_v3_dtor_kinds
operator|)
literal|0
return|;
return|return
name|dtor_kind
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IN_GLIBCPP_V3 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STANDALONE_DEMANGLER
end_ifdef

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_function_decl
specifier|static
name|void
name|print_usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|exit_value
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|IS_ALPHA
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|(((CHAR)>= 'a'&& (CHAR)<= 'z')                                     \    || ((CHAR)>= 'A'&& (CHAR)<= 'Z'))
end_define

begin_comment
comment|/* Non-zero if CHAR is a character than can occur in a mangled name.  */
end_comment

begin_define
define|#
directive|define
name|is_mangled_char
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|(IS_ALPHA (CHAR) || IS_DIGIT (CHAR)                                   \    || (CHAR) == '_' || (CHAR) == '.' || (CHAR) == '$')
end_define

begin_comment
comment|/* The name of this program, as invoked.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prints usage summary to FP and then exits with EXIT_VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|print_usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|exit_value
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s [options] [names ...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -h,--help       Display this message.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -p,--no-params  Don't display function parameters\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -v,--verbose    Produce verbose demanglings.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"If names are provided, they are demangled.  Otherwise filters standard input.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Option specification for getopt_long.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"no-params"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry for a demangling filter executable.  It will demangle    its command line arguments, if any.  If none are provided, it will    filter stdin to stdout, replacing any recognized mangled C++ names    with their demangled equivalents.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|opt_char
decl_stmt|;
name|int
name|options
init|=
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
operator||
name|DMGL_TYPES
decl_stmt|;
comment|/* Use the program name of this program, as invoked.  */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Parse options.  */
do|do
block|{
name|opt_char
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hpv"
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt_char
condition|)
block|{
case|case
literal|'?'
case|:
comment|/* Unrecognized option.  */
name|print_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|print_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|options
operator|&=
operator|~
name|DMGL_PARAMS
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|options
operator||=
name|DMGL_VERBOSE
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|opt_char
operator|!=
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
comment|/* No command line arguments were provided.  Filter stdin.  */
block|{
name|dyn_string_t
name|mangled
init|=
name|dyn_string_new
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Read all of input.  */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|char
name|c
decl_stmt|;
comment|/* Pile characters into mangled until we hit one that can't 	     occur in a mangled name.  */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
operator|&&
name|is_mangled_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|dyn_string_append_char
argument_list|(
name|mangled
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dyn_string_length
argument_list|(
name|mangled
argument_list|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IN_GLIBCPP_V3
name|s
operator|=
name|__cxa_demangle
argument_list|(
name|dyn_string_buf
argument_list|(
name|mangled
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|cplus_demangle_v3
argument_list|(
name|dyn_string_buf
argument_list|(
name|mangled
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It might not have been a mangled name.  Print the 		     original text.  */
name|fputs
argument_list|(
name|dyn_string_buf
argument_list|(
name|mangled
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|dyn_string_clear
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't hit EOF yet, we've read one character that 	     can't occur in a mangled name, so print it out.  */
if|if
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Demangle command line arguments.  */
block|{
comment|/* Loop over command line arguments.  */
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|IN_GLIBCPP_V3
name|int
name|status
decl_stmt|;
endif|#
directive|endif
comment|/* Attempt to demangle.  */
ifdef|#
directive|ifdef
name|IN_GLIBCPP_V3
name|s
operator|=
name|__cxa_demangle
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|cplus_demangle_v3
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|options
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If it worked, print the demangled name.  */
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IN_GLIBCPP_V3
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed: %s (status %d)\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STANDALONE_DEMANGLER */
end_comment

end_unit

