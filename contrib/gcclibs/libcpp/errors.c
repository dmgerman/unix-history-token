begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Default error handlers for CPP Library.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000,    2001, 2002, 2004 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_function_decl
specifier|static
name|void
name|print_location
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|source_location
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the logical file location (LINE, COL) in preparation for a    diagnostic.  Outputs the #include chain if it has changed.  A line    of zero suppresses the include stack, and outputs the program name    instead.  */
end_comment

begin_function
specifier|static
name|void
name|print_location
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|source_location
name|line
parameter_list|,
name|unsigned
name|int
name|col
parameter_list|)
block|{
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|lin
decl_stmt|;
name|map
operator|=
name|linemap_lookup
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|linemap_print_containing_files
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|lin
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
block|{
name|col
operator|=
name|SOURCE_COLUMN
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|col
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lin
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|map
operator|->
name|to_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u:"
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|lin
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u:%u:"
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|lin
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up for a diagnostic: print the file and line, bump the error    counter, etc.  SRC_LOC is the logical line number; zero means to print    at the location of the previously lexed token, which tends to be    the correct place by default.  The column number can be specified either    using COLUMN or (if COLUMN==0) extracting SOURCE_COLUMN from SRC_LOC.    (This may seem redundant, but is useful when pre-scanning (cleaning) a line,    when we haven't yet verified whether the current line_map has a    big enough max_column_hint.)     Returns 0 if the error has been suppressed.  */
end_comment

begin_function
name|int
name|_cpp_begin_message
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|code
parameter_list|,
name|source_location
name|src_loc
parameter_list|,
name|unsigned
name|int
name|column
parameter_list|)
block|{
name|int
name|level
init|=
name|CPP_DL_EXTRACT
argument_list|(
name|code
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|CPP_DL_WARNING
case|:
case|case
name|CPP_DL_PEDWARN
case|:
if|if
condition|(
name|cpp_in_system_header
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_system_headers
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fall through.  */
case|case
name|CPP_DL_WARNING_SYSHDR
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warnings_are_errors
argument_list|)
operator|||
operator|(
name|level
operator|==
name|CPP_DL_PEDWARN
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic_errors
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_errors
argument_list|)
condition|)
return|return
literal|0
return|;
name|level
operator|=
name|CPP_DL_ERROR
expr_stmt|;
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_warnings
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CPP_DL_ERROR
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_errors
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ICEs cannot be inhibited.  */
case|case
name|CPP_DL_ICE
case|:
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|print_location
argument_list|(
name|pfile
argument_list|,
name|src_loc
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_DL_WARNING_P
argument_list|(
name|level
argument_list|)
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|CPP_DL_ICE
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"internal error: "
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|_
argument_list|(
literal|"error: "
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Don't remove the blank before do, as otherwise the exgettext    script will mistake this as a function definition */
end_comment

begin_define
define|#
directive|define
name|v_message
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
define|\
value|do { vfprintf (stderr, _(msgid), ap); putc ('\n', stderr); } while (0)
end_define

begin_comment
comment|/* Exported interface.  */
end_comment

begin_comment
comment|/* Print an error at the location of the previously lexed token.  */
end_comment

begin_function
name|void
name|cpp_error
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|source_location
name|src_loc
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|client_diagnostic
argument_list|)
condition|)
name|pfile
operator|->
name|cb
operator|.
name|error
argument_list|(
name|pfile
argument_list|,
name|level
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
name|src_loc
operator|=
name|pfile
operator|->
name|directive_line
expr_stmt|;
else|else
name|src_loc
operator|=
name|pfile
operator|->
name|line_table
operator|->
name|highest_line
expr_stmt|;
block|}
else|else
block|{
comment|/* Find actual previous token.  */
name|cpp_token
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|!=
name|pfile
operator|->
name|cur_run
operator|->
name|base
condition|)
name|t
operator|=
name|pfile
operator|->
name|cur_token
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pfile
operator|->
name|cur_run
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|t
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|prev
operator|->
name|limit
expr_stmt|;
else|else
name|t
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Retrieve corresponding source location, unless we failed.  */
name|src_loc
operator|=
name|t
condition|?
name|t
operator|->
name|src_loc
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|level
argument_list|,
name|src_loc
argument_list|,
literal|0
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error at a specific location.  */
end_comment

begin_function
name|void
name|cpp_error_with_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|level
parameter_list|,
name|source_location
name|src_loc
parameter_list|,
name|unsigned
name|int
name|column
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|level
argument_list|,
name|src_loc
argument_list|,
name|column
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_errno
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
if|if
condition|(
name|msgid
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|msgid
operator|=
name|_
argument_list|(
literal|"stdout"
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|level
argument_list|,
literal|"%s: %s"
argument_list|,
name|msgid
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

