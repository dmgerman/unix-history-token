begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"localedir.h"
end_include

begin_function_decl
specifier|static
name|void
name|init_library
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_named_operators
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_original_filename
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_original_directory
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_options
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If we have designated initializers (GCC>2.7) these tables can be    initialized, constant data.  Otherwise, they have to be filled in at    runtime.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_DESIGNATED_INITIALIZERS
end_if

begin_define
define|#
directive|define
name|init_trigraph_map
parameter_list|()
end_define

begin_comment
comment|/* Nothing.  */
end_comment

begin_define
define|#
directive|define
name|TRIGRAPH_MAP
define|\
value|__extension__ const uchar _cpp_trigraph_map[UCHAR_MAX + 1] = {
end_define

begin_define
define|#
directive|define
name|END
value|};
end_define

begin_define
define|#
directive|define
name|s
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|[p] = v,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRIGRAPH_MAP
value|uchar _cpp_trigraph_map[UCHAR_MAX + 1] = { 0 }; \  static void init_trigraph_map (void) { \  unsigned char *x = _cpp_trigraph_map;
end_define

begin_define
define|#
directive|define
name|END
value|}
end_define

begin_define
define|#
directive|define
name|s
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|x[p] = v;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|TRIGRAPH_MAP
name|s
argument_list|(
literal|'='
argument_list|,
literal|'#'
argument_list|)
name|s
argument_list|(
literal|')'
argument_list|,
literal|']'
argument_list|)
name|s
argument_list|(
literal|'!'
argument_list|,
literal|'|'
argument_list|)
name|s
argument_list|(
literal|'('
argument_list|,
literal|'['
argument_list|)
name|s
argument_list|(
literal|'\''
argument_list|,
literal|'^'
argument_list|)
name|s
argument_list|(
literal|'>'
argument_list|,
literal|'}'
argument_list|)
name|s
argument_list|(
literal|'/'
argument_list|,
literal|'\\'
argument_list|)
name|s
argument_list|(
literal|'<'
argument_list|,
literal|'{'
argument_list|)
name|s
argument_list|(
literal|'-'
argument_list|,
literal|'~'
argument_list|)
name|END
undef|#
directive|undef
name|s
undef|#
directive|undef
name|END
undef|#
directive|undef
name|TRIGRAPH_MAP
comment|/* A set of booleans indicating what CPP features each source language    requires.  */
decl|struct
name|lang_flags
block|{
name|char
name|c99
decl_stmt|;
name|char
name|cplusplus
decl_stmt|;
name|char
name|extended_numbers
decl_stmt|;
name|char
name|extended_identifiers
decl_stmt|;
name|char
name|std
decl_stmt|;
name|char
name|cplusplus_comments
decl_stmt|;
name|char
name|digraphs
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|lang_flags
name|lang_defaults
index|[]
init|=
block|{
comment|/*              c99 c++ xnum xid std  //   digr  */
comment|/* GNUC89 */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GNUC99 */
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* STDC89 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* STDC94 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* STDC99 */
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* GNUCXX */
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* CXX98  */
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* ASM    */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
comment|/* xid should be 1 for GNUC99, STDC99, GNUCXX and CXX98 when no      longer experimental (when all uses of identifiers in the compiler      have been audited for correct handling of extended      identifiers).  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sets internal flags correctly for a given language.  */
end_comment

begin_function
name|void
name|cpp_set_lang
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|enum
name|c_lang
name|lang
parameter_list|)
block|{
specifier|const
name|struct
name|lang_flags
modifier|*
name|l
init|=
operator|&
name|lang_defaults
index|[
operator|(
name|int
operator|)
name|lang
index|]
decl_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|=
name|lang
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|=
name|l
operator|->
name|c99
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|=
name|l
operator|->
name|cplusplus
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|extended_numbers
argument_list|)
operator|=
name|l
operator|->
name|extended_numbers
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|extended_identifiers
argument_list|)
operator|=
name|l
operator|->
name|extended_identifiers
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|std
argument_list|)
operator|=
name|l
operator|->
name|std
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
operator|=
name|l
operator|->
name|std
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|=
name|l
operator|->
name|cplusplus_comments
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
operator|=
name|l
operator|->
name|digraphs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize library global state.  */
end_comment

begin_function
specifier|static
name|void
name|init_library
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
comment|/* Set up the trigraph map.  This doesn't need to do anything if 	 we were compiled with a compiler that supports C99 designated 	 initializers.  */
name|init_trigraph_map
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_NLS
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Initialize a cpp_reader structure.  */
end_comment

begin_function
name|cpp_reader
modifier|*
name|cpp_create_reader
parameter_list|(
name|enum
name|c_lang
name|lang
parameter_list|,
name|hash_table
modifier|*
name|table
parameter_list|,
name|struct
name|line_maps
modifier|*
name|line_table
parameter_list|)
block|{
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
comment|/* Initialize this instance of the library if it hasn't been already.  */
name|init_library
argument_list|()
expr_stmt|;
name|pfile
operator|=
name|XCNEW
argument_list|(
name|cpp_reader
argument_list|)
expr_stmt|;
name|cpp_set_lang
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_multichar
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments_in_macro_exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|tabstop
argument_list|)
operator|=
literal|8
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|=
literal|2
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_endif_labels
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_deprecated
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_long_long
argument_list|)
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_dollars
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_variadic_macros
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_normalize
argument_list|)
operator|=
name|normalized_C
expr_stmt|;
comment|/* Default CPP arithmetic to something sensible for the host for the      benefit of dumb users like fix-header.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
operator|=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
operator|=
name|CHAR_BIT
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
operator|=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_char
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_wchar
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bytes_big_endian
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* does not matter */
comment|/* Default to no charset conversion.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|narrow_charset
argument_list|)
operator|=
name|_cpp_default_encoding
argument_list|()
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wide_charset
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default the input character set to UTF-8.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|input_charset
argument_list|)
operator|=
name|_cpp_default_encoding
argument_list|()
expr_stmt|;
comment|/* A fake empty "directory" used as the starting point for files      looked up without a search path.  Name cannot be '/' because we      don't want to prepend anything at all to filenames using it.  All      other entries are correct zero-initialized.  */
name|pfile
operator|->
name|no_search_path
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|""
expr_stmt|;
comment|/* Initialize the line map.  */
name|pfile
operator|->
name|line_table
operator|=
name|line_table
expr_stmt|;
comment|/* Initialize lexer state.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
expr_stmt|;
comment|/* Set up static tokens.  */
name|pfile
operator|->
name|avoid_paste
operator|.
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
name|pfile
operator|->
name|avoid_paste
operator|.
name|val
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|eof
operator|.
name|type
operator|=
name|CPP_EOF
expr_stmt|;
name|pfile
operator|->
name|eof
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Create a token buffer for the lexer.  */
name|_cpp_init_tokenrun
argument_list|(
operator|&
name|pfile
operator|->
name|base_run
argument_list|,
literal|250
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
comment|/* Initialize the base context.  */
name|pfile
operator|->
name|context
operator|=
operator|&
name|pfile
operator|->
name|base_context
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|.
name|prev
operator|=
name|pfile
operator|->
name|base_context
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Aligned and unaligned storage.  */
name|pfile
operator|->
name|a_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|u_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The expression parser stack.  */
name|_cpp_expand_op_stack
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Initialize the buffer obstack.  */
name|_obstack_begin
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|long
argument_list|)
operator|)
name|xmalloc
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|free
argument_list|)
expr_stmt|;
name|_cpp_init_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_init_hashtable
argument_list|(
name|pfile
argument_list|,
name|table
argument_list|)
expr_stmt|;
return|return
name|pfile
return|;
block|}
end_function

begin_comment
comment|/* Free resources used by PFILE.  Accessing PFILE after this function    returns leads to undefined behavior.  Returns the error count.  */
end_comment

begin_function
name|void
name|cpp_destroy
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_context
modifier|*
name|context
decl_stmt|,
modifier|*
name|contextn
decl_stmt|;
name|tokenrun
modifier|*
name|run
decl_stmt|,
modifier|*
name|runn
decl_stmt|;
name|free
argument_list|(
name|pfile
operator|->
name|op_stack
argument_list|)
expr_stmt|;
while|while
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|!=
name|NULL
condition|)
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|out
operator|.
name|base
condition|)
name|free
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|macro_buffer
condition|)
block|{
name|free
argument_list|(
name|pfile
operator|->
name|macro_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|macro_buffer
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|macro_buffer_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|deps
condition|)
name|deps_free
argument_list|(
name|pfile
operator|->
name|deps
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_cpp_destroy_hashtable
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_cleanup_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_destroy_iconv
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|_cpp_free_buff
argument_list|(
name|pfile
operator|->
name|free_buffs
argument_list|)
expr_stmt|;
for|for
control|(
name|run
operator|=
operator|&
name|pfile
operator|->
name|base_run
init|;
name|run
condition|;
name|run
operator|=
name|runn
control|)
block|{
name|runn
operator|=
name|run
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|run
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
operator|&
name|pfile
operator|->
name|base_run
condition|)
name|free
argument_list|(
name|run
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|context
operator|=
name|pfile
operator|->
name|base_context
operator|.
name|next
init|;
name|context
condition|;
name|context
operator|=
name|contextn
control|)
block|{
name|contextn
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This structure defines one built-in identifier.  A node will be    entered in the hash table under the name NAME, with value VALUE.     There are two tables of these.  builtin_array holds all the    "builtin" macros: these are handled by builtin_macro() in    macro.c.  Builtin is somewhat of a misnomer -- the property of    interest is that these macros require special code to compute their    expansions.  The value is a "builtin_type" enumerator.     operator_array holds the C++ named operators.  These are keywords    which act as aliases for punctuators.  In C++, they cannot be    altered through #define, and #if recognizes them as operators.  In    C, these are not entered into the hash table at all (but see<iso646.h>).  The value is a token-type enumerator.  */
end_comment

begin_struct
struct|struct
name|builtin
block|{
specifier|const
name|uchar
modifier|*
name|name
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
name|unsigned
name|short
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|B
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|{ DSC(n), t }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin
name|builtin_array
index|[]
init|=
block|{
name|B
argument_list|(
literal|"__TIMESTAMP__"
argument_list|,
name|BT_TIMESTAMP
argument_list|)
block|,
name|B
argument_list|(
literal|"__TIME__"
argument_list|,
name|BT_TIME
argument_list|)
block|,
name|B
argument_list|(
literal|"__DATE__"
argument_list|,
name|BT_DATE
argument_list|)
block|,
name|B
argument_list|(
literal|"__FILE__"
argument_list|,
name|BT_FILE
argument_list|)
block|,
name|B
argument_list|(
literal|"__BASE_FILE__"
argument_list|,
name|BT_BASE_FILE
argument_list|)
block|,
name|B
argument_list|(
literal|"__LINE__"
argument_list|,
name|BT_SPECLINE
argument_list|)
block|,
name|B
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|,
name|BT_INCLUDE_LEVEL
argument_list|)
block|,
name|B
argument_list|(
literal|"__COUNTER__"
argument_list|,
name|BT_COUNTER
argument_list|)
block|,
comment|/* Keep builtins not used for -traditional-cpp at the end, and      update init_builtins() if any more are added.  */
name|B
argument_list|(
literal|"_Pragma"
argument_list|,
name|BT_PRAGMA
argument_list|)
block|,
name|B
argument_list|(
literal|"__STDC__"
argument_list|,
name|BT_STDC
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin
name|operator_array
index|[]
init|=
block|{
name|B
argument_list|(
literal|"and"
argument_list|,
name|CPP_AND_AND
argument_list|)
block|,
name|B
argument_list|(
literal|"and_eq"
argument_list|,
name|CPP_AND_EQ
argument_list|)
block|,
name|B
argument_list|(
literal|"bitand"
argument_list|,
name|CPP_AND
argument_list|)
block|,
name|B
argument_list|(
literal|"bitor"
argument_list|,
name|CPP_OR
argument_list|)
block|,
name|B
argument_list|(
literal|"compl"
argument_list|,
name|CPP_COMPL
argument_list|)
block|,
name|B
argument_list|(
literal|"not"
argument_list|,
name|CPP_NOT
argument_list|)
block|,
name|B
argument_list|(
literal|"not_eq"
argument_list|,
name|CPP_NOT_EQ
argument_list|)
block|,
name|B
argument_list|(
literal|"or"
argument_list|,
name|CPP_OR_OR
argument_list|)
block|,
name|B
argument_list|(
literal|"or_eq"
argument_list|,
name|CPP_OR_EQ
argument_list|)
block|,
name|B
argument_list|(
literal|"xor"
argument_list|,
name|CPP_XOR
argument_list|)
block|,
name|B
argument_list|(
literal|"xor_eq"
argument_list|,
argument|CPP_XOR_EQ
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|B
end_undef

begin_comment
comment|/* Mark the C++ named operators in the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|mark_named_operators
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|struct
name|builtin
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|operator_array
init|;
name|b
operator|<
operator|(
name|operator_array
operator|+
name|ARRAY_SIZE
argument_list|(
name|operator_array
argument_list|)
operator|)
condition|;
name|b
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|len
argument_list|)
decl_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_OPERATOR
expr_stmt|;
name|hp
operator|->
name|is_directive
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|directive_index
operator|=
name|b
operator|->
name|value
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cpp_init_special_builtins
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|struct
name|builtin
modifier|*
name|b
decl_stmt|;
name|size_t
name|n
init|=
name|ARRAY_SIZE
argument_list|(
name|builtin_array
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|n
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|stdc_0_in_system_headers
argument_list|)
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|std
argument_list|)
condition|)
name|n
operator|--
expr_stmt|;
for|for
control|(
name|b
operator|=
name|builtin_array
init|;
name|b
operator|<
name|builtin_array
operator|+
name|n
condition|;
name|b
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|len
argument_list|)
decl_stmt|;
name|hp
operator|->
name|type
operator|=
name|NT_MACRO
expr_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_BUILTIN
operator||
name|NODE_WARN
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|builtin
operator|=
operator|(
expr|enum
name|builtin_type
operator|)
name|b
operator|->
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the builtins table above and enter them, and language-specific    macros, into the hash table.  HOSTED is true if this is a hosted    environment.  */
end_comment

begin_function
name|void
name|cpp_init_builtins
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|hosted
parameter_list|)
block|{
name|cpp_init_special_builtins
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
operator|&&
operator|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|stdc_0_in_system_headers
argument_list|)
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|std
argument_list|)
operator|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC__ 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__cplusplus 1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_ASM
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__ASSEMBLER__ 1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_STDC94
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_VERSION__ 199409L"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_VERSION__ 199901L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosted
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_HOSTED__ 1"
argument_list|)
expr_stmt|;
else|else
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__STDC_HOSTED__ 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
condition|)
name|_cpp_define_builtin
argument_list|(
name|pfile
argument_list|,
literal|"__OBJC__ 1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sanity-checks are dependent on command-line options, so it is    called as a subroutine of cpp_read_main_file ().  */
end_comment

begin_if
if|#
directive|if
name|ENABLE_CHECKING
end_if

begin_function_decl
specifier|static
name|void
name|sanity_checks
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sanity_checks
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cppchar_t
name|test
init|=
literal|0
decl_stmt|;
name|size_t
name|max_precision
init|=
literal|2
operator|*
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|cpp_num_part
argument_list|)
decl_stmt|;
comment|/* Sanity checks for assumptions about CPP arithmetic and target      type precisions made by cpplib.  */
name|test
operator|--
expr_stmt|;
if|if
condition|(
name|test
operator|<
literal|1
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"cppchar_t must be an unsigned type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
operator|>
name|max_precision
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"preprocessor arithmetic has maximum precision of %lu bits;"
literal|" target requires %lu bits"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|max_precision
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
operator|<
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"CPP arithmetic must be at least as precise as a target int"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
operator|<
literal|8
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"target char is less than 8 bits wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|<
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"target wchar_t is narrower than target char"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
operator|<
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"target int is narrower than target char"
argument_list|)
expr_stmt|;
comment|/* This is assumed in eval_token() and could be fixed if necessary.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cppchar_t
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|cpp_num_part
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"CPP half-integer narrower than CPP character"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|>
name|BITS_PER_CPPCHAR_T
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"CPP on this host cannot handle wide character constants over"
literal|" %lu bits, but the target requires %lu bits"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|BITS_PER_CPPCHAR_T
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sanity_checks
parameter_list|(
name|PFILE
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is called after options have been parsed, and partially    processed.  */
end_comment

begin_function
name|void
name|cpp_post_options
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|sanity_checks
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|post_options
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Mark named operators before handling command line macros.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|operator_names
argument_list|)
condition|)
name|mark_named_operators
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Setup for processing input from the file named FNAME, or stdin if    it is the empty string.  Return the original filename    on success (e.g. foo.i->foo.c), or NULL on failure.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpp_read_main_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|!=
name|DEPS_NONE
condition|)
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|deps
condition|)
name|pfile
operator|->
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
comment|/* Set the default target (if there is none already).  */
name|deps_add_default_target
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|main_file
operator|=
name|_cpp_find_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
operator|&
name|pfile
operator|->
name|no_search_path
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_find_failed
argument_list|(
name|pfile
operator|->
name|main_file
argument_list|)
condition|)
return|return
name|NULL
return|;
name|_cpp_stack_file
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|main_file
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* For foo.i, read the original filename foo.c now, for the benefit      of the front ends.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
block|{
name|read_original_filename
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|fname
operator|=
name|pfile
operator|->
name|line_table
operator|->
name|maps
index|[
name|pfile
operator|->
name|line_table
operator|->
name|used
operator|-
literal|1
index|]
operator|.
name|to_file
expr_stmt|;
block|}
return|return
name|fname
return|;
block|}
end_function

begin_comment
comment|/* For preprocessed files, if the first tokens are of the form # NUM.    handle the directive so we know the original file name.  This will    generate file_change callbacks, which the front ends must handle    appropriately given their state of initialization.  */
end_comment

begin_function
specifier|static
name|void
name|read_original_filename
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|token1
decl_stmt|;
comment|/* Lex ahead; if the first tokens are of the form # NUM, then      process the directive, otherwise back up.  */
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_HASH
condition|)
block|{
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|1
expr_stmt|;
name|token1
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|0
expr_stmt|;
comment|/* If it's a #line directive, handle it.  */
if|if
condition|(
name|token1
operator|->
name|type
operator|==
name|CPP_NUMBER
condition|)
block|{
name|_cpp_handle_directive
argument_list|(
name|pfile
argument_list|,
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
argument_list|)
expr_stmt|;
name|read_original_directory
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Backup as if nothing happened.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For preprocessed files, if the tokens following the first filename    line is of the form #<line> "/path/name//", handle the    directive so we know the original current directory.  */
end_comment

begin_function
specifier|static
name|void
name|read_original_directory
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|hash
decl_stmt|,
modifier|*
name|token
decl_stmt|;
comment|/* Lex ahead; if the first tokens are of the form # NUM, then      process the directive, otherwise back up.  */
name|hash
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|type
operator|!=
name|CPP_HASH
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NUMBER
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_STRING
operator|||
operator|!
operator|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|>=
literal|5
operator|&&
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|3
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|dir_change
condition|)
block|{
name|char
modifier|*
name|debugdir
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|3
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|debugdir
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|+
literal|1
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
name|debugdir
index|[
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pfile
operator|->
name|cb
operator|.
name|dir_change
argument_list|(
name|pfile
argument_list|,
name|debugdir
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called at the end of preprocessing.  It pops the last    buffer and writes dependency output, and returns the number of    errors.     Maybe it should also reset state, such that you could call    cpp_start_read with a new filename to restart processing.  */
end_comment

begin_function
name|int
name|cpp_finish
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|FILE
modifier|*
name|deps_stream
parameter_list|)
block|{
comment|/* Warn about unused macros before popping the final buffer.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_unused_macros
argument_list|)
condition|)
name|cpp_forall_identifiers
argument_list|(
name|pfile
argument_list|,
name|_cpp_warn_if_unused_macro
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* lex.c leaves the final buffer on the stack.  This it so that      it returns an unending stream of CPP_EOFs to the client.  If we      popped the buffer, we'd dereference a NULL buffer pointer and      segfault.  It's nice to allow the client to do worry-free excess      cpp_get_token calls.  */
while|while
condition|(
name|pfile
operator|->
name|buffer
condition|)
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Don't write the deps file if there are errors.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|!=
name|DEPS_NONE
operator|&&
name|deps_stream
operator|&&
name|pfile
operator|->
name|errors
operator|==
literal|0
condition|)
block|{
name|deps_write
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|deps_stream
argument_list|,
literal|72
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|phony_targets
argument_list|)
condition|)
name|deps_phony_targets
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
block|}
comment|/* Report on headers that could use multiple include guards.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
condition|)
name|_cpp_report_missing_guards
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|pfile
operator|->
name|errors
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_options
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* -Wtraditional is not useful in C++ mode.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_traditional
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Permanently disable macro expansion if we are rescanning      preprocessed text.  Read preprocesed source in ISO mode.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|directives_only
argument_list|)
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|1
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|==
literal|2
condition|)
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
block|{
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Traditional CPP does not accurately track column information.  */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

