begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library. (Directive handling.)    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
end_comment

begin_struct
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Line where condition started.  */
specifier|const
name|cpp_hashnode
modifier|*
name|mi_cmacro
decl_stmt|;
comment|/* macro name for #ifndef around entire file */
name|bool
name|skip_elses
decl_stmt|;
comment|/* Can future #else / #elif be skipped?  */
name|bool
name|was_skipping
decl_stmt|;
comment|/* If were skipping on entry.  */
name|int
name|type
decl_stmt|;
comment|/* Most recent conditional for diagnostics.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Contains a registered pragma or pragma namespace.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|pragma_cb
function_decl|)
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|pragma_entry
block|{
name|struct
name|pragma_entry
modifier|*
name|next
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|pragma
decl_stmt|;
comment|/* Name and length.  */
name|bool
name|is_nspace
decl_stmt|;
name|bool
name|is_internal
decl_stmt|;
name|bool
name|is_deferred
decl_stmt|;
name|bool
name|allow_expansion
decl_stmt|;
union|union
block|{
name|pragma_cb
name|handler
decl_stmt|;
name|struct
name|pragma_entry
modifier|*
name|space
decl_stmt|;
name|unsigned
name|int
name|ident
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Values for the origin field of struct directive.  KANDR directives    come from traditional (K&R) C.  STDC89 directives come from the    1989 C standard.  EXTENSION directives are extensions.  */
end_comment

begin_define
define|#
directive|define
name|KANDR
value|0
end_define

begin_define
define|#
directive|define
name|STDC89
value|1
end_define

begin_define
define|#
directive|define
name|EXTENSION
value|2
end_define

begin_comment
comment|/* Values for the flags field of struct directive.  COND indicates a    conditional; IF_COND an opening conditional.  INCL means to treat    "..." and<...> as q-char and h-char sequences respectively.  IN_I    means this directive should be handled even if -fpreprocessed is in    effect (these are the directives with callback hooks).     EXPAND is set on directives that are always macro-expanded.  */
end_comment

begin_define
define|#
directive|define
name|COND
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|IF_COND
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|INCL
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|IN_I
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|EXPAND
value|(1<< 4)
end_define

begin_comment
comment|/* Defines one #-directive, including how to handle it.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|directive_handler
function_decl|)
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|directive
name|directive
typedef|;
end_typedef

begin_struct
struct|struct
name|directive
block|{
name|directive_handler
name|handler
decl_stmt|;
comment|/* Function to handle directive.  */
specifier|const
name|uchar
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive.  */
name|unsigned
name|short
name|length
decl_stmt|;
comment|/* Length of name.  */
name|unsigned
name|char
name|origin
decl_stmt|;
comment|/* Origin of directive.  */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Flags describing this directive.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|skip_rest_of_line
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_eol
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_directive
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_directive_trad
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_directive
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|directive_diagnostics
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|directive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_directive
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|glue_header_name
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|parse_include
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_conditional
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_flag
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strtoul_for_line
parameter_list|(
specifier|const
name|uchar
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_diagnostic
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_hashnode
modifier|*
name|lex_macro_node
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|undefine_macros
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_include_common
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|enum
name|include_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pragma_entry
modifier|*
name|lookup_pragma_entry
parameter_list|(
name|struct
name|pragma_entry
modifier|*
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_registered_pragmas
parameter_list|(
name|struct
name|pragma_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|save_registered_pragmas
parameter_list|(
name|struct
name|pragma_entry
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|restore_registered_pragmas
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|struct
name|pragma_entry
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_pragma_once
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_pragma_poison
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_pragma_system_header
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_pragma_dependency
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_linemarker
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get_token_no_padding
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get__Pragma_string
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destringize_and_run
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_answer
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|struct
name|answer
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_hashnode
modifier|*
name|parse_assertion
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|struct
name|answer
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|answer
modifier|*
modifier|*
name|find_answer
parameter_list|(
name|cpp_hashnode
modifier|*
parameter_list|,
specifier|const
name|struct
name|answer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_assertion
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is the table of directive handlers.  It is ordered by    frequency of occurrence; the numbers at the end are directive    counts from all the source code I have lying around (egcs and libc    CVS as of 1999-05-18, plus grub-0.5.91, linux-2.2.9, and    pcmcia-cs-3.0.9).  This is no longer important as directive lookup    is now O(1).  All extensions other than #warning and #include_next    are deprecated.  The name is where the extension appears to have    come from.  */
end_comment

begin_define
define|#
directive|define
name|DIRECTIVE_TABLE
define|\
value|D(define,	T_DEFINE = 0,	KANDR,     IN_I)
comment|/* 270554 */
value|\ D(include,	T_INCLUDE,	KANDR,     INCL | EXPAND)
comment|/*  52262 */
value|\ D(endif,	T_ENDIF,	KANDR,     COND)
comment|/*  45855 */
value|\ D(ifdef,	T_IFDEF,	KANDR,     COND | IF_COND)
comment|/*  22000 */
value|\ D(if,		T_IF,		KANDR, COND | IF_COND | EXPAND)
comment|/*  18162 */
value|\ D(else,		T_ELSE,		KANDR,     COND)
comment|/*   9863 */
value|\ D(ifndef,	T_IFNDEF,	KANDR,     COND | IF_COND)
comment|/*   9675 */
value|\ D(undef,	T_UNDEF,	KANDR,     IN_I)
comment|/*   4837 */
value|\ D(line,		T_LINE,		KANDR,     EXPAND)
comment|/*   2465 */
value|\ D(elif,		T_ELIF,		STDC89,    COND | EXPAND)
comment|/*    610 */
value|\ D(error,	T_ERROR,	STDC89,    0)
comment|/*    475 */
value|\ D(pragma,	T_PRAGMA,	STDC89,    IN_I)
comment|/*    195 */
value|\ D(warning,	T_WARNING,	EXTENSION, 0)
comment|/*     22 */
value|\ D(include_next,	T_INCLUDE_NEXT,	EXTENSION, INCL | EXPAND)
comment|/*     19 */
value|\ D(ident,	T_IDENT,	EXTENSION, IN_I)
comment|/*     11 */
value|\ D(import,	T_IMPORT,	EXTENSION, INCL | EXPAND)
comment|/* 0 ObjC */
value|\ D(assert,	T_ASSERT,	EXTENSION, 0)
comment|/* 0 SVR4 */
value|\ D(unassert,	T_UNASSERT,	EXTENSION, 0)
comment|/* 0 SVR4 */
value|\ D(sccs,		T_SCCS,		EXTENSION, IN_I)
end_define

begin_comment
comment|/* 0 SVR4? */
end_comment

begin_comment
comment|/* #sccs is synonymous with #ident.  */
end_comment

begin_define
define|#
directive|define
name|do_sccs
value|do_ident
end_define

begin_comment
comment|/* Use the table to generate a series of prototypes, an enum for the    directive names, and an array of directive handlers.  */
end_comment

begin_define
define|#
directive|define
name|D
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|,
name|o
parameter_list|,
name|f
parameter_list|)
value|static void do_##name (cpp_reader *);
end_define

begin_decl_stmt
name|DIRECTIVE_TABLE
undef|#
directive|undef
name|D
define|#
directive|define
name|D
parameter_list|(
name|n
parameter_list|,
name|tag
parameter_list|,
name|o
parameter_list|,
name|f
parameter_list|)
value|tag,
name|enum
type|{
name|DIRECTIVE_TABLE
name|N_DIRECTIVES
end_decl_stmt

begin_undef
unit|};
undef|#
directive|undef
name|D
end_undef

begin_define
define|#
directive|define
name|D
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|,
name|origin
parameter_list|,
name|flags
parameter_list|)
define|\
value|{ do_##name, (const uchar *) #name, \   sizeof #name - 1, origin, flags },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|directive
name|dtable
index|[]
init|=
block|{
name|DIRECTIVE_TABLE
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|D
end_undef

begin_undef
undef|#
directive|undef
name|DIRECTIVE_TABLE
end_undef

begin_comment
comment|/* Wrapper struct directive for linemarkers.    The origin is more or less true - the original K+R cpp    did use this notation in its preprocessed output.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|directive
name|linemarker_dir
init|=
block|{
name|do_linemarker
block|,
literal|U"#"
block|,
literal|1
block|,
name|KANDR
block|,
name|IN_I
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SEEN_EOL
parameter_list|()
value|(pfile->cur_token[-1].type == CPP_EOF)
end_define

begin_comment
comment|/* Skip any remaining tokens in a directive.  */
end_comment

begin_function
specifier|static
name|void
name|skip_rest_of_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* Discard all stacked contexts.  */
while|while
condition|(
name|pfile
operator|->
name|context
operator|->
name|prev
condition|)
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Sweep up all tokens remaining on the line.  */
if|if
condition|(
operator|!
name|SEEN_EOL
argument_list|()
condition|)
while|while
condition|(
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure there are no stray tokens at the end of a directive.  */
end_comment

begin_function
specifier|static
name|void
name|check_eol
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SEEN_EOL
argument_list|()
operator|&&
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"extra tokens at end of #%s directive"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure there are no stray tokens other than comments at the end of    a directive, and gather the comments.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
modifier|*
name|check_eol_return_comments
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|size_t
name|c
decl_stmt|;
name|size_t
name|capacity
init|=
literal|8
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|cpp_token
operator|*
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SEEN_EOL
argument_list|()
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|tok
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|type
operator|!=
name|CPP_COMMENT
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"extra tokens at end of #%s directive"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|capacity
condition|)
block|{
name|capacity
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|XRESIZEVEC
argument_list|(
specifier|const
name|cpp_token
operator|*
argument_list|,
name|buf
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|c
index|]
operator|=
name|tok
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
block|}
name|buf
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Called when entering a directive, _Pragma or command-line directive.  */
end_comment

begin_function
specifier|static
name|void
name|start_directive
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* Setup in-directive state.  */
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|1
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|directive_result
operator|.
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
comment|/* Some handlers need the position of the # for diagnostics.  */
name|pfile
operator|->
name|directive_line
operator|=
name|pfile
operator|->
name|line_table
operator|->
name|highest_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when leaving a directive, _Pragma or command-line directive.  */
end_comment

begin_function
specifier|static
name|void
name|end_directive
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|skip_line
parameter_list|)
block|{
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_deferred_pragma
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
block|{
comment|/* Revert change of prepare_directive_trad.  */
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|directive
operator|!=
operator|&
name|dtable
index|[
name|T_DEFINE
index|]
condition|)
name|_cpp_remove_overlay
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
comment|/* We don't skip for an assembler #.  */
elseif|else
if|if
condition|(
name|skip_line
condition|)
block|{
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|keep_tokens
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
block|}
block|}
comment|/* Restore state.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|in_expression
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|angled_headers
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|directive
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to handle the directive in pfile->directive.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_directive_trad
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
if|if
condition|(
name|pfile
operator|->
name|directive
operator|!=
operator|&
name|dtable
index|[
name|T_DEFINE
index|]
condition|)
block|{
name|bool
name|no_expand
init|=
operator|(
name|pfile
operator|->
name|directive
operator|&&
operator|!
operator|(
name|pfile
operator|->
name|directive
operator|->
name|flags
operator|&
name|EXPAND
operator|)
operator|)
decl_stmt|;
name|bool
name|was_skipping
init|=
name|pfile
operator|->
name|state
operator|.
name|skipping
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|in_expression
operator|=
operator|(
name|pfile
operator|->
name|directive
operator|==
operator|&
name|dtable
index|[
name|T_IF
index|]
operator|||
name|pfile
operator|->
name|directive
operator|==
operator|&
name|dtable
index|[
name|T_ELIF
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_expression
condition|)
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|no_expand
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|_cpp_scan_out_logical_line
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_expand
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|was_skipping
expr_stmt|;
name|_cpp_overlay_buffer
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|cur
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
comment|/* Stop ISO C from expanding anything.  */
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output diagnostics for a directive DIR.  INDENTED is nonzero if    the '#' was indented.  */
end_comment

begin_function
specifier|static
name|void
name|directive_diagnostics
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|directive
modifier|*
name|dir
parameter_list|,
name|int
name|indented
parameter_list|)
block|{
comment|/* Issue -pedantic warnings for extensions.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|&&
name|dir
operator|->
name|origin
operator|==
name|EXTENSION
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"#%s is a GCC extension"
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Traditionally, a directive is ignored unless its # is in      column 1.  Therefore in code intended to work with K+R      compilers, directives added by C89 must have their #      indented, and directives present in traditional C must not.      This is true even of directives in skipped conditional      blocks.  #elif cannot be used at all.  */
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|dir
operator|==
operator|&
name|dtable
index|[
name|T_ELIF
index|]
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"suggest not using #elif in traditional C"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indented
operator|&&
name|dir
operator|->
name|origin
operator|==
name|KANDR
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"traditional C ignores #%s with the # indented"
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indented
operator|&&
name|dir
operator|->
name|origin
operator|!=
name|KANDR
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"suggest hiding #%s from traditional C with an indented #"
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if we have a known directive.  INDENTED is nonzero if the    '#' of the directive was indented.  This function is in this file    to save unnecessarily exporting dtable etc. to lex.c.  Returns    nonzero if the line of tokens has been handled, zero if we should    continue processing the line.  */
end_comment

begin_function
name|int
name|_cpp_handle_directive
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|indented
parameter_list|)
block|{
specifier|const
name|directive
modifier|*
name|dir
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|dname
decl_stmt|;
name|bool
name|was_parsing_args
init|=
name|pfile
operator|->
name|state
operator|.
name|parsing_args
decl_stmt|;
name|bool
name|was_discarding_output
init|=
name|pfile
operator|->
name|state
operator|.
name|discarding_output
decl_stmt|;
name|int
name|skip
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|was_discarding_output
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|was_parsing_args
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"embedding a directive within macro arguments is not portable"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|0
expr_stmt|;
block|}
name|start_directive
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|dname
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
if|if
condition|(
name|dname
operator|->
name|val
operator|.
name|node
operator|->
name|is_directive
condition|)
name|dir
operator|=
operator|&
name|dtable
index|[
name|dname
operator|->
name|val
operator|.
name|node
operator|->
name|directive_index
index|]
expr_stmt|;
block|}
comment|/* We do not recognize the # followed by a number extension in      assembler code.  */
elseif|else
if|if
condition|(
name|dname
operator|->
name|type
operator|==
name|CPP_NUMBER
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
block|{
name|dir
operator|=
operator|&
name|linemarker_dir
expr_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"style of line directive is a GCC extension"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
condition|)
block|{
comment|/* If we have a directive that is not an opening conditional, 	 invalidate any control macro.  */
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|IF_COND
operator|)
condition|)
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
comment|/* Kluge alert.  In order to be sure that code like this  	 #define HASH # 	 HASH define foo bar  	 does not cause '#define foo bar' to get executed when 	 compiled with -save-temps, we recognize directives in 	 -fpreprocessed mode only if the # is in column 1.  macro.c 	 puts a space in front of any '#' at the start of a macro. 	  	 We exclude the -fdirectives-only case because macro expansion 	 has not been performed yet, and block comments can cause spaces 	 to preceed the directive.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|directives_only
argument_list|)
operator|&&
operator|(
name|indented
operator|||
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|IN_I
operator|)
operator|)
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* In failed conditional groups, all non-conditional 	     directives are ignored.  Before doing that, whether 	     skipping or not, we should lex angle-bracketed headers 	     correctly, and maybe output some diagnostics.  */
name|pfile
operator|->
name|state
operator|.
name|angled_headers
operator|=
name|dir
operator|->
name|flags
operator|&
name|INCL
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|directive_wants_padding
operator|=
name|dir
operator|->
name|flags
operator|&
name|INCL
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|directive_diagnostics
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|,
name|indented
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|&&
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|COND
operator|)
condition|)
name|dir
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dname
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
empty_stmt|;
comment|/* CPP_EOF is the "null directive".  */
else|else
block|{
comment|/* An unknown directive.  Don't complain about it in assembly 	 source: we don't know where the comments are, and # may 	 introduce assembler pseudo-ops.  Don't complain about invalid 	 directives in skipped conditional groups (6.10 p4).  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_ASM
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"invalid preprocessing directive #%s"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|dname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|directive
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|prepare_directive_trad
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
name|pfile
operator|->
name|directive
operator|->
name|handler
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip
operator|==
literal|0
condition|)
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end_directive
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_parsing_args
condition|)
block|{
comment|/* Restore state when within macro args.  */
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|2
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|was_discarding_output
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|=
literal|1
expr_stmt|;
return|return
name|skip
return|;
block|}
end_function

begin_comment
comment|/* Directive handler wrapper used by the command line option    processor.  BUF is \n terminated.  */
end_comment

begin_function
specifier|static
name|void
name|run_directive
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|dir_no
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|buf
argument_list|,
name|count
argument_list|,
comment|/* from_stage3 */
name|true
argument_list|)
expr_stmt|;
name|start_directive
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* This is a short-term fix to prevent a leading '#' being      interpreted as a directive.  */
name|_cpp_clean_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|directive
operator|=
operator|&
name|dtable
index|[
name|dir_no
index|]
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|prepare_directive_trad
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|directive
operator|->
name|handler
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|end_directive
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks for validity the macro name in #define, #undef, #ifdef and    #ifndef directives.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|lex_macro_node
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* The token immediately after #define must be an identifier.  That      identifier may not be "defined", per C99 6.10.8p4.      In C++, it may not be any of the "named operators" either,      per C++98 [lex.digraph], [lex.key].      Finally, the identifier may not have been poisoned.  (In that case      the lexer has issued the error message for us.)  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|token
operator|->
name|val
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_defined
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"defined\" cannot be used as a macro name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_POISONED
operator|)
condition|)
return|return
name|node
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"%s\" cannot be used as a macro name as it is an operator in C++"
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"no macro name given in #%s directive"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"macro names must be identifiers"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Process a #define directive.  Most work is done in macro.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_define
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
comment|/* If we have been requested to expand comments into macros, 	 then re-enable saving of comments.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments_in_macro_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_create_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
condition|)
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|define
condition|)
name|pfile
operator|->
name|cb
operator|.
name|define
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle #undef.  Mark the identifier NT_VOID in the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|do_undef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|undef
condition|)
name|pfile
operator|->
name|cb
operator|.
name|undef
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* 6.10.3.5 paragraph 2: [#undef] is ignored if the specified 	 identifier is not currently defined as a macro name.  */
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_WARN
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"undefining \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_unused_macros
argument_list|)
condition|)
name|_cpp_warn_if_unused_macro
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_cpp_free_definition
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undefine a single macro/assertion/whatever.  */
end_comment

begin_function
specifier|static
name|int
name|undefine_macros
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|cpp_hashnode
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Body of _cpp_free_definition inlined here for speed.      Macros and assertions no longer have anything to free.  */
name|h
operator|->
name|type
operator|=
name|NT_VOID
expr_stmt|;
name|h
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NODE_POISONED
operator||
name|NODE_BUILTIN
operator||
name|NODE_DISABLED
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Undefine all macros and assertions.  */
end_comment

begin_function
name|void
name|cpp_undef_all
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_forall_identifiers
argument_list|(
name|pfile
argument_list|,
name|undefine_macros
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper routine used by parse_include.  Reinterpret the current line    as an h-char-sequence (< ...>); we are looking at the first token    after the<.  Returns a malloced filename.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|glue_header_name
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|,
name|capacity
init|=
literal|1024
decl_stmt|;
comment|/* To avoid lexed tokens overwriting our glued name, we can only      allocate from the string pool once we've lexed everything.  */
name|buffer
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
operator|=
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
condition|)
break|break;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"missing terminating> character"
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Leading space, terminating \0.  */
if|if
condition|(
name|total_len
operator|+
name|len
operator|>
name|capacity
condition|)
block|{
name|capacity
operator|=
operator|(
name|capacity
operator|+
name|len
operator|)
operator|*
literal|2
expr_stmt|;
name|buffer
operator|=
name|XRESIZEVEC
argument_list|(
name|char
argument_list|,
name|buffer
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|buffer
index|[
name|total_len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|total_len
operator|=
operator|(
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
operator|(
name|uchar
operator|*
operator|)
operator|&
name|buffer
index|[
name|total_len
index|]
argument_list|,
name|true
argument_list|)
operator|-
operator|(
name|uchar
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
block|}
name|buffer
index|[
name|total_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Returns the file name of #include, #include_next, #import and    #pragma dependency.  The string is malloced and the caller should    free it.  Returns NULL on error.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parse_include
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
modifier|*
name|pangle_brackets
parameter_list|,
specifier|const
name|cpp_token
modifier|*
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
comment|/* Allow macro expansion.  */
name|header
operator|=
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|header
operator|->
name|type
operator|==
name|CPP_HEADER_NAME
condition|)
block|{
name|fname
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fname
argument_list|,
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|+
literal|1
argument_list|,
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|fname
index|[
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pangle_brackets
operator|=
name|header
operator|->
name|type
operator|==
name|CPP_HEADER_NAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|CPP_LESS
condition|)
block|{
name|fname
operator|=
name|glue_header_name
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
operator|*
name|pangle_brackets
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|pfile
operator|->
name|directive
operator|==
operator|&
name|dtable
index|[
name|T_PRAGMA
index|]
condition|)
name|dir
operator|=
literal|U"pragma dependency"
expr_stmt|;
else|else
name|dir
operator|=
name|pfile
operator|->
name|directive
operator|->
name|name
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#%s expects \"FILENAME\" or<FILENAME>"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we are not discarding comments, then gather them while 	 doing the eol check.  */
operator|*
name|buf
operator|=
name|check_eol_return_comments
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
return|return
name|fname
return|;
block|}
end_function

begin_comment
comment|/* Handle #include, #include_next and #import.  */
end_comment

begin_function
specifier|static
name|void
name|do_include_common
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|enum
name|include_type
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|angle_brackets
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* Re-enable saving of comments if requested, so that the include      callback can dump comments which follow #include.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
expr_stmt|;
name|fname
operator|=
name|parse_include
argument_list|(
name|pfile
argument_list|,
operator|&
name|angle_brackets
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fname
condition|)
block|{
if|if
condition|(
name|buf
condition|)
name|XDELETEVEC
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|*
name|fname
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"empty filename in #%s"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
name|XDELETEVEC
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|XDELETEVEC
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Prevent #include recursion.  */
if|if
condition|(
name|pfile
operator|->
name|line_table
operator|->
name|depth
operator|>=
name|CPP_STACK_MAX
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#include nested too deeply"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Get out of macro context, if we are.  */
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|include
condition|)
name|pfile
operator|->
name|cb
operator|.
name|include
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|,
name|fname
argument_list|,
name|angle_brackets
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|_cpp_stack_include
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|angle_brackets
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|XDELETEVEC
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|XDELETEVEC
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_include
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|do_include_common
argument_list|(
name|pfile
argument_list|,
name|IT_INCLUDE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_import
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|do_include_common
argument_list|(
name|pfile
argument_list|,
name|IT_IMPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_include_next
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|enum
name|include_type
name|type
init|=
name|IT_INCLUDE_NEXT
decl_stmt|;
comment|/* If this is the primary source file, warn and use the normal      search logic.  */
if|if
condition|(
operator|!
name|pfile
operator|->
name|buffer
operator|->
name|prev
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"#include_next in primary source file"
argument_list|)
expr_stmt|;
name|type
operator|=
name|IT_INCLUDE
expr_stmt|;
block|}
name|do_include_common
argument_list|(
name|pfile
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of do_linemarker.  Read possible flags after file name.    LAST is the last flag seen; 0 if this is the first flag. Return the    flag if it is valid, 0 at the end of the directive. Otherwise    complain.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_flag
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|unsigned
name|int
name|last
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NUMBER
operator|&&
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
literal|1
condition|)
block|{
name|unsigned
name|int
name|flag
init|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|flag
operator|>
name|last
operator|&&
name|flag
operator|<=
literal|4
operator|&&
operator|(
name|flag
operator|!=
literal|4
operator|||
name|last
operator|==
literal|3
operator|)
operator|&&
operator|(
name|flag
operator|!=
literal|2
operator|||
name|last
operator|==
literal|0
operator|)
condition|)
return|return
name|flag
return|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"invalid flag \"%s\" in line directive"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of do_line and do_linemarker.  Convert a number in STR,    of length LEN, to binary; store it in NUMP, and return 0 if the    number was well-formed, 1 if not.  Temporary, hopefully.  */
end_comment

begin_function
specifier|static
name|int
name|strtoul_for_line
parameter_list|(
specifier|const
name|uchar
modifier|*
name|str
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|long
name|unsigned
name|int
modifier|*
name|nump
parameter_list|)
block|{
name|unsigned
name|long
name|reg
init|=
literal|0
decl_stmt|;
name|uchar
name|c
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
name|reg
operator|*=
literal|10
expr_stmt|;
name|reg
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|nump
operator|=
name|reg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Interpret #line command.    Note that the filename string (if any) is a true string constant    (escapes are interpreted), unlike in #line.  */
end_comment

begin_function
specifier|static
name|void
name|do_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|struct
name|line_maps
modifier|*
name|line_table
init|=
name|pfile
operator|->
name|line_table
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
init|=
operator|&
name|line_table
operator|->
name|maps
index|[
name|line_table
operator|->
name|used
operator|-
literal|1
index|]
decl_stmt|;
comment|/* skip_rest_of_line() may cause line table to be realloc()ed so note down      sysp right now.  */
name|unsigned
name|char
name|map_sysp
init|=
name|map
operator|->
name|sysp
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_file
init|=
name|map
operator|->
name|to_file
decl_stmt|;
name|unsigned
name|long
name|new_lineno
decl_stmt|;
comment|/* C99 raised the minimum limit on #line numbers.  */
name|unsigned
name|int
name|cap
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|?
literal|2147483647
else|:
literal|32767
decl_stmt|;
comment|/* #line commands expand macros.  */
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NUMBER
operator|||
name|strtoul_for_line
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
operator|&
name|new_lineno
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"%s\" after #line is not a positive integer"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|(
name|new_lineno
operator|==
literal|0
operator|||
name|new_lineno
operator|>
name|cap
operator|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"line number out of range"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
condition|)
block|{
name|cpp_string
name|s
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|cpp_interpret_string_notranslate
argument_list|(
name|pfile
argument_list|,
operator|&
name|token
operator|->
name|val
operator|.
name|str
argument_list|,
literal|1
argument_list|,
operator|&
name|s
argument_list|,
name|false
argument_list|)
condition|)
name|new_file
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|.
name|text
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"%s\" is not a valid filename"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|new_file
argument_list|,
name|new_lineno
argument_list|,
name|map_sysp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interpret the # 44 "file" [flags] notation, which has slightly    different syntax and semantics from #line:  Flags are allowed,    and we never complain about the line number being too big.  */
end_comment

begin_function
specifier|static
name|void
name|do_linemarker
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|struct
name|line_maps
modifier|*
name|line_table
init|=
name|pfile
operator|->
name|line_table
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
init|=
operator|&
name|line_table
operator|->
name|maps
index|[
name|line_table
operator|->
name|used
operator|-
literal|1
index|]
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_file
init|=
name|map
operator|->
name|to_file
decl_stmt|;
name|unsigned
name|long
name|new_lineno
decl_stmt|;
name|unsigned
name|int
name|new_sysp
init|=
name|map
operator|->
name|sysp
decl_stmt|;
name|enum
name|lc_reason
name|reason
init|=
name|LC_RENAME
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* Back up so we can get the number again.  Putting this in      _cpp_handle_directive risks two calls to _cpp_backup_tokens in      some circumstances, which can segfault.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* #line commands expand macros.  */
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NUMBER
operator|||
name|strtoul_for_line
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
operator|&
name|new_lineno
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"%s\" after # is not a positive integer"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
condition|)
block|{
name|cpp_string
name|s
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|cpp_interpret_string_notranslate
argument_list|(
name|pfile
argument_list|,
operator|&
name|token
operator|->
name|val
operator|.
name|str
argument_list|,
literal|1
argument_list|,
operator|&
name|s
argument_list|,
name|false
argument_list|)
condition|)
name|new_file
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|.
name|text
expr_stmt|;
name|new_sysp
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
block|{
name|reason
operator|=
name|LC_ENTER
expr_stmt|;
comment|/* Fake an include for cpp_included ().  */
name|_cpp_fake_include
argument_list|(
name|pfile
argument_list|,
name|new_file
argument_list|)
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
literal|2
condition|)
block|{
name|reason
operator|=
name|LC_LEAVE
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|3
condition|)
block|{
name|new_sysp
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|4
condition|)
name|new_sysp
operator|=
literal|2
expr_stmt|;
block|}
name|pfile
operator|->
name|buffer
operator|->
name|sysp
operator|=
name|new_sysp
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"%s\" is not a valid filename"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|reason
argument_list|,
name|new_file
argument_list|,
name|new_lineno
argument_list|,
name|new_sysp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Arrange the file_change callback.  pfile->line has changed to    FILE_LINE of TO_FILE, for reason REASON.  SYSP is 1 for a system    header, 2 for a system header that needs to be extern "C" protected,    and zero otherwise.  */
end_comment

begin_function
name|void
name|_cpp_do_file_change
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|enum
name|lc_reason
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|to_file
parameter_list|,
name|unsigned
name|int
name|file_line
parameter_list|,
name|unsigned
name|int
name|sysp
parameter_list|)
block|{
specifier|const
name|struct
name|line_map
modifier|*
name|map
init|=
name|linemap_add
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|reason
argument_list|,
name|sysp
argument_list|,
name|to_file
argument_list|,
name|file_line
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|linemap_line_start
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|map
operator|->
name|to_line
argument_list|,
literal|127
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|file_change
condition|)
name|pfile
operator|->
name|cb
operator|.
name|file_change
argument_list|(
name|pfile
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning or error detected by the program we are    processing.  Use the directive's tokens in the error message.  */
end_comment

begin_function
specifier|static
name|void
name|do_diagnostic
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|print_dir
parameter_list|)
block|{
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|code
argument_list|,
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|src_loc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_dir
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#%s "
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
comment|/* APPLE LOCAL #error with unmatched quotes 5607574 */
name|pfile
operator|->
name|state
operator|.
name|in_diagnostic
operator|++
expr_stmt|;
name|cpp_output_line
argument_list|(
name|pfile
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL #error with unmatched quotes 5607574 */
name|pfile
operator|->
name|state
operator|.
name|in_diagnostic
operator|--
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_error
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|do_diagnostic
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_warning
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* We want #warning diagnostics to be emitted in system headers too.  */
name|do_diagnostic
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING_SYSHDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report program identification.  */
end_comment

begin_function
specifier|static
name|void
name|do_ident
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|str
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|->
name|type
operator|!=
name|CPP_STRING
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"invalid #%s directive"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|ident
condition|)
name|pfile
operator|->
name|cb
operator|.
name|ident
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
operator|&
name|str
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a PRAGMA name in a singly-linked CHAIN.  Returns the    matching entry, or NULL if none is found.  The returned entry could    be the start of a namespace chain, or a pragma.  */
end_comment

begin_function
specifier|static
name|struct
name|pragma_entry
modifier|*
name|lookup_pragma_entry
parameter_list|(
name|struct
name|pragma_entry
modifier|*
name|chain
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
name|pragma
parameter_list|)
block|{
while|while
condition|(
name|chain
operator|&&
name|chain
operator|->
name|pragma
operator|!=
name|pragma
condition|)
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Create and insert a blank pragma entry at the beginning of a    singly-linked CHAIN.  */
end_comment

begin_function
specifier|static
name|struct
name|pragma_entry
modifier|*
name|new_pragma_entry
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|struct
name|pragma_entry
modifier|*
modifier|*
name|chain
parameter_list|)
block|{
name|struct
name|pragma_entry
modifier|*
name|new_entry
decl_stmt|;
name|new_entry
operator|=
operator|(
expr|struct
name|pragma_entry
operator|*
operator|)
name|_cpp_aligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pragma_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pragma_entry
argument_list|)
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|next
operator|=
operator|*
name|chain
expr_stmt|;
operator|*
name|chain
operator|=
name|new_entry
expr_stmt|;
return|return
name|new_entry
return|;
block|}
end_function

begin_comment
comment|/* Register a pragma NAME in namespace SPACE.  If SPACE is null, it    goes in the global namespace.  */
end_comment

begin_function
specifier|static
name|struct
name|pragma_entry
modifier|*
name|register_pragma_1
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|allow_name_expansion
parameter_list|)
block|{
name|struct
name|pragma_entry
modifier|*
modifier|*
name|chain
init|=
operator|&
name|pfile
operator|->
name|pragmas
decl_stmt|;
name|struct
name|pragma_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|space
condition|)
block|{
name|node
operator|=
name|cpp_lookup
argument_list|(
argument|pfile
argument_list|,
argument|U space
argument_list|,
argument|strlen (space)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|lookup_pragma_entry
argument_list|(
operator|*
name|chain
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|entry
operator|=
name|new_pragma_entry
argument_list|(
name|pfile
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pragma
operator|=
name|node
expr_stmt|;
name|entry
operator|->
name|is_nspace
operator|=
name|true
expr_stmt|;
name|entry
operator|->
name|allow_expansion
operator|=
name|allow_name_expansion
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entry
operator|->
name|is_nspace
condition|)
goto|goto
name|clash
goto|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|allow_expansion
operator|!=
name|allow_name_expansion
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"registering pragmas in namespace \"%s\" with mismatched "
literal|"name expansion"
argument_list|,
name|space
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|chain
operator|=
operator|&
name|entry
operator|->
name|u
operator|.
name|space
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allow_name_expansion
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"registering pragma \"%s\" with name expansion "
literal|"and no namespace"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check for duplicates.  */
name|node
operator|=
name|cpp_lookup
argument_list|(
argument|pfile
argument_list|,
argument|U name
argument_list|,
argument|strlen (name)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|lookup_pragma_entry
argument_list|(
operator|*
name|chain
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|new_pragma_entry
argument_list|(
name|pfile
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pragma
operator|=
name|node
expr_stmt|;
return|return
name|entry
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|is_nspace
condition|)
name|clash
label|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"registering \"%s\" as both a pragma and a pragma namespace"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|space
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"#pragma %s %s is already registered"
argument_list|,
name|space
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"#pragma %s is already registered"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Register a cpplib internal pragma SPACE NAME with HANDLER.  */
end_comment

begin_function
specifier|static
name|void
name|register_pragma_internal
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|pragma_cb
name|handler
parameter_list|)
block|{
name|struct
name|pragma_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|register_pragma_1
argument_list|(
name|pfile
argument_list|,
name|space
argument_list|,
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|entry
operator|->
name|is_internal
operator|=
name|true
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|handler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register a pragma NAME in namespace SPACE.  If SPACE is null, it    goes in the global namespace.  HANDLER is the handler it will call,    which must be non-NULL.  If ALLOW_EXPANSION is set, allow macro    expansion while parsing pragma NAME.  This function is exported    from libcpp. */
end_comment

begin_function
name|void
name|cpp_register_pragma
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|pragma_cb
name|handler
parameter_list|,
name|bool
name|allow_expansion
parameter_list|)
block|{
name|struct
name|pragma_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|handler
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"registering pragma with NULL handler"
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|register_pragma_1
argument_list|(
name|pfile
argument_list|,
name|space
argument_list|,
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|entry
operator|->
name|allow_expansion
operator|=
name|allow_expansion
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|handler
operator|=
name|handler
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, but create mark the pragma for deferred processing.    When found, a CPP_PRAGMA token will be insertted into the stream    with IDENT in the token->u.pragma slot.  */
end_comment

begin_function
name|void
name|cpp_register_deferred_pragma
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|ident
parameter_list|,
name|bool
name|allow_expansion
parameter_list|,
name|bool
name|allow_name_expansion
parameter_list|)
block|{
name|struct
name|pragma_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|register_pragma_1
argument_list|(
name|pfile
argument_list|,
name|space
argument_list|,
name|name
argument_list|,
name|allow_name_expansion
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|entry
operator|->
name|is_deferred
operator|=
name|true
expr_stmt|;
name|entry
operator|->
name|allow_expansion
operator|=
name|allow_expansion
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|ident
operator|=
name|ident
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* APPLE LOCAL begin pragma mark 5614511 */
end_comment

begin_comment
comment|/* Handle #pragma mark.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_mark
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
operator|++
name|pfile
operator|->
name|state
operator|.
name|skipping
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
operator|--
name|pfile
operator|->
name|state
operator|.
name|skipping
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APPLE LOCAL end pragma mark 5614511 */
end_comment

begin_comment
comment|/* Register the pragmas the preprocessor itself handles.  */
end_comment

begin_function
name|void
name|_cpp_init_internal_pragmas
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* Pragmas in the global namespace.  */
name|register_pragma_internal
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
literal|"once"
argument_list|,
name|do_pragma_once
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL pragma mark 5614511 */
name|register_pragma_internal
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
literal|"mark"
argument_list|,
name|do_pragma_mark
argument_list|)
expr_stmt|;
comment|/* New GCC-specific pragmas should be put in the GCC namespace.  */
name|register_pragma_internal
argument_list|(
name|pfile
argument_list|,
literal|"GCC"
argument_list|,
literal|"poison"
argument_list|,
name|do_pragma_poison
argument_list|)
expr_stmt|;
name|register_pragma_internal
argument_list|(
name|pfile
argument_list|,
literal|"GCC"
argument_list|,
literal|"system_header"
argument_list|,
name|do_pragma_system_header
argument_list|)
expr_stmt|;
name|register_pragma_internal
argument_list|(
name|pfile
argument_list|,
literal|"GCC"
argument_list|,
literal|"dependency"
argument_list|,
name|do_pragma_dependency
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of registered pragmas in PE.  */
end_comment

begin_function
specifier|static
name|int
name|count_registered_pragmas
parameter_list|(
name|struct
name|pragma_entry
modifier|*
name|pe
parameter_list|)
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pe
operator|->
name|is_nspace
condition|)
name|ct
operator|+=
name|count_registered_pragmas
argument_list|(
name|pe
operator|->
name|u
operator|.
name|space
argument_list|)
expr_stmt|;
name|ct
operator|++
expr_stmt|;
block|}
return|return
name|ct
return|;
block|}
end_function

begin_comment
comment|/* Save into SD the names of the registered pragmas referenced by PE,    and return a pointer to the next free space in SD.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|save_registered_pragmas
parameter_list|(
name|struct
name|pragma_entry
modifier|*
name|pe
parameter_list|,
name|char
modifier|*
modifier|*
name|sd
parameter_list|)
block|{
for|for
control|(
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pe
operator|->
name|is_nspace
condition|)
name|sd
operator|=
name|save_registered_pragmas
argument_list|(
name|pe
operator|->
name|u
operator|.
name|space
argument_list|,
name|sd
argument_list|)
expr_stmt|;
operator|*
name|sd
operator|++
operator|=
operator|(
name|char
operator|*
operator|)
name|xmemdup
argument_list|(
name|HT_STR
argument_list|(
operator|&
name|pe
operator|->
name|pragma
operator|->
name|ident
argument_list|)
argument_list|,
name|HT_LEN
argument_list|(
operator|&
name|pe
operator|->
name|pragma
operator|->
name|ident
argument_list|)
argument_list|,
name|HT_LEN
argument_list|(
operator|&
name|pe
operator|->
name|pragma
operator|->
name|ident
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated array which saves the names of the    registered pragmas.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|_cpp_save_pragma_names
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|ct
init|=
name|count_registered_pragmas
argument_list|(
name|pfile
operator|->
name|pragmas
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
init|=
name|XNEWVEC
argument_list|(
name|char
operator|*
argument_list|,
name|ct
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|save_registered_pragmas
argument_list|(
name|pfile
operator|->
name|pragmas
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Restore from SD the names of the registered pragmas referenced by PE,    and return a pointer to the next unused name in SD.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|restore_registered_pragmas
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|struct
name|pragma_entry
modifier|*
name|pe
parameter_list|,
name|char
modifier|*
modifier|*
name|sd
parameter_list|)
block|{
for|for
control|(
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pe
operator|->
name|is_nspace
condition|)
name|sd
operator|=
name|restore_registered_pragmas
argument_list|(
name|pfile
argument_list|,
name|pe
operator|->
name|u
operator|.
name|space
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pragma
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|U
operator|*
name|sd
argument_list|,
name|strlen
argument_list|(
operator|*
name|sd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|sd
argument_list|)
expr_stmt|;
name|sd
operator|++
expr_stmt|;
block|}
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/* Restore the names of the registered pragmas from SAVED.  */
end_comment

begin_function
name|void
name|_cpp_restore_pragma_names
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|char
modifier|*
modifier|*
name|saved
parameter_list|)
block|{
operator|(
name|void
operator|)
name|restore_registered_pragmas
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|pragmas
argument_list|,
name|saved
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pragmata handling.  We handle some, and pass the rest on to the    front end.  C99 defines three pragmas and says that no macro    expansion is to be performed on them; whether or not macro    expansion happens for other pragmas is implementation defined.    This implementation allows for a mix of both, since GCC did not    traditionally macro expand its (few) pragmas, whereas OpenMP    specifies that macro expansion should happen.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|struct
name|pragma_entry
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|pragma_token
init|=
name|pfile
operator|->
name|cur_token
decl_stmt|;
name|cpp_token
name|ns_token
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|1
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|ns_token
operator|=
operator|*
name|token
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|p
operator|=
name|lookup_pragma_entry
argument_list|(
name|pfile
operator|->
name|pragmas
argument_list|,
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|is_nspace
condition|)
block|{
name|bool
name|allow_name_expansion
init|=
name|p
operator|->
name|allow_expansion
decl_stmt|;
if|if
condition|(
name|allow_name_expansion
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|p
operator|=
name|lookup_pragma_entry
argument_list|(
name|p
operator|->
name|u
operator|.
name|space
argument_list|,
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|allow_name_expansion
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|is_deferred
condition|)
block|{
name|pfile
operator|->
name|directive_result
operator|.
name|src_loc
operator|=
name|pragma_token
operator|->
name|src_loc
expr_stmt|;
name|pfile
operator|->
name|directive_result
operator|.
name|type
operator|=
name|CPP_PRAGMA
expr_stmt|;
name|pfile
operator|->
name|directive_result
operator|.
name|flags
operator|=
name|pragma_token
operator|->
name|flags
expr_stmt|;
name|pfile
operator|->
name|directive_result
operator|.
name|val
operator|.
name|pragma
operator|=
name|p
operator|->
name|u
operator|.
name|ident
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|in_deferred_pragma
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|pragma_allow_expansion
operator|=
name|p
operator|->
name|allow_expansion
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|allow_expansion
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the handler below doesn't get the line number, that 	     it might need for diagnostics, make sure it has the right 	     numbers in place.  */
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|line_change
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|line_change
call|)
argument_list|(
name|pfile
argument_list|,
name|pragma_token
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|allow_expansion
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|u
operator|.
name|handler
call|)
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|allow_expansion
condition|)
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|def_pragma
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|1
operator|||
name|pfile
operator|->
name|context
operator|->
name|prev
operator|==
name|NULL
condition|)
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Invalid name comes from macro expansion, _cpp_backup_tokens 	     won't allow backing 2 tokens.  */
comment|/* ??? The token buffer is leaked.  Perhaps if def_pragma hook 	     reads both tokens, we could perhaps free it, but if it doesn't, 	     we don't know the exact lifespan.  */
name|cpp_token
modifier|*
name|toks
init|=
name|XNEWVEC
argument_list|(
name|cpp_token
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
name|ns_token
expr_stmt|;
name|toks
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|NO_EXPAND
expr_stmt|;
name|toks
index|[
literal|1
index|]
operator|=
operator|*
name|token
expr_stmt|;
name|toks
index|[
literal|1
index|]
operator|.
name|flags
operator||=
name|NO_EXPAND
expr_stmt|;
name|_cpp_push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|toks
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|cb
operator|.
name|def_pragma
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #pragma once.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_once
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|prev
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"#pragma once in main file"
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_mark_file_once_only
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|buffer
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #pragma GCC poison, to poison one or more identifiers so    that the lexer produces a hard error for each subsequent usage.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_poison
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|cpp_hashnode
modifier|*
name|hp
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|poisoned_ok
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tok
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"invalid #pragma GCC poison directive"
argument_list|)
expr_stmt|;
break|break;
block|}
name|hp
operator|=
name|tok
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|&
name|NODE_POISONED
condition|)
continue|continue;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"poisoning existing macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
name|_cpp_free_definition
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_POISONED
operator||
name|NODE_DIAGNOSTIC
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|poisoned_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the current header as a system header.  This will suppress    some categories of warnings (notably those from -pedantic).  It is    intended for use in system libraries that cannot be implemented in    conforming C, but cannot be certain that their headers appear in a    system include directory.  To prevent abuse, it is rejected in the    primary source file.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_system_header
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|buffer
operator|->
name|prev
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"#pragma system_header ignored outside include file"
argument_list|)
expr_stmt|;
else|else
block|{
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_make_system_header
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the modified date of the current include file against a specified    file. Issue a diagnostic, if the specified file is newer. We use this to    determine if a fixed header should be refixed.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_dependency
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|angle_brackets
decl_stmt|,
name|ordering
decl_stmt|;
name|fname
operator|=
name|parse_include
argument_list|(
name|pfile
argument_list|,
operator|&
name|angle_brackets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fname
condition|)
return|return;
name|ordering
operator|=
name|_cpp_compare_file_date
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|angle_brackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ordering
operator|<
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"cannot find source file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ordering
operator|>
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"current file is older than %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_diagnostic
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a token but skip padding.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get_token_no_padding
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|result
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|->
name|type
operator|!=
name|CPP_PADDING
condition|)
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check syntax is "(string-literal)".  Returns the string on success,    or NULL on failure.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get__Pragma_string
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_OPEN_PAREN
condition|)
return|return
name|NULL
return|;
name|string
operator|=
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|->
name|type
operator|!=
name|CPP_STRING
operator|&&
name|string
operator|->
name|type
operator|!=
name|CPP_WSTRING
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
return|return
name|NULL
return|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Destringize IN into a temporary buffer, by removing the first \ of    \" and \\ sequences, and process the result as a #pragma directive.  */
end_comment

begin_function
specifier|static
name|void
name|destringize_and_run
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|in
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|cpp_context
modifier|*
name|saved_context
decl_stmt|;
name|cpp_token
modifier|*
name|saved_cur_token
decl_stmt|;
name|tokenrun
modifier|*
name|saved_cur_run
decl_stmt|;
name|cpp_token
modifier|*
name|toks
decl_stmt|;
name|int
name|count
decl_stmt|;
name|dest
operator|=
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|in
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|in
operator|->
name|text
operator|+
literal|1
operator|+
operator|(
name|in
operator|->
name|text
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
expr_stmt|;
name|limit
operator|=
name|in
operator|->
name|text
operator|+
name|in
operator|->
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|limit
condition|)
block|{
comment|/* We know there is a character following the backslash.  */
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
operator|&&
operator|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\n'
expr_stmt|;
comment|/* Ugh; an awful kludge.  We are really not set up to be lexing      tokens when in the middle of a macro expansion.  Use a new      context to force cpp_get_token to lex, and so skip_rest_of_line      doesn't go beyond the end of the text.  Also, remember the      current lexing position so we can return to it later.       Something like line-at-a-time lexing should remove the need for      this.  */
name|saved_context
operator|=
name|pfile
operator|->
name|context
expr_stmt|;
name|saved_cur_token
operator|=
name|pfile
operator|->
name|cur_token
expr_stmt|;
name|saved_cur_run
operator|=
name|pfile
operator|->
name|cur_run
expr_stmt|;
name|pfile
operator|->
name|context
operator|=
name|XNEW
argument_list|(
name|cpp_context
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|context
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|context
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|context
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Inline run_directive, since we need to delay the _cpp_pop_buffer      until we've read all of the tokens that we want.  */
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|result
argument_list|,
name|dest
operator|-
name|result
argument_list|,
comment|/* from_stage3 */
name|true
argument_list|)
expr_stmt|;
comment|/* ??? Antique Disgusting Hack.  What does this do?  */
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|prev
condition|)
name|pfile
operator|->
name|buffer
operator|->
name|file
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|prev
operator|->
name|file
expr_stmt|;
name|start_directive
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_clean_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|do_pragma
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|end_directive
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We always insert at least one token, the directive result.  It'll      either be a CPP_PADDING or a CPP_PRAGMA.  In the later case, we       need to insert *all* of the tokens, including the CPP_PRAGMA_EOL.  */
comment|/* If we're not handling the pragma internally, read all of the tokens from      the string buffer now, while the string buffer is still installed.  */
comment|/* ??? Note that the token buffer allocated here is leaked.  It's not clear      to me what the true lifespan of the tokens are.  It would appear that      the lifespan is the entire parse of the main input stream, in which case      this may not be wrong.  */
if|if
condition|(
name|pfile
operator|->
name|directive_result
operator|.
name|type
operator|==
name|CPP_PRAGMA
condition|)
block|{
name|int
name|maxcount
decl_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|maxcount
operator|=
literal|50
expr_stmt|;
name|toks
operator|=
name|XNEWVEC
argument_list|(
name|cpp_token
argument_list|,
name|maxcount
argument_list|)
expr_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
name|pfile
operator|->
name|directive_result
expr_stmt|;
do|do
block|{
if|if
condition|(
name|count
operator|==
name|maxcount
condition|)
block|{
name|maxcount
operator|=
name|maxcount
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
name|toks
operator|=
name|XRESIZEVEC
argument_list|(
name|cpp_token
argument_list|,
name|toks
argument_list|,
name|maxcount
argument_list|)
expr_stmt|;
block|}
name|toks
index|[
name|count
index|]
operator|=
operator|*
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Macros have been already expanded by cpp_get_token 	     if the pragma allowed expansion.  */
name|toks
index|[
name|count
operator|++
index|]
operator|.
name|flags
operator||=
name|NO_EXPAND
expr_stmt|;
block|}
do|while
condition|(
name|toks
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|type
operator|!=
name|CPP_PRAGMA_EOL
condition|)
do|;
block|}
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|toks
operator|=
name|XNEW
argument_list|(
name|cpp_token
argument_list|)
expr_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
name|pfile
operator|->
name|directive_result
expr_stmt|;
comment|/* If we handled the entire pragma internally, make sure we get the 	 line number correct for the next token.  */
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|line_change
condition|)
name|pfile
operator|->
name|cb
operator|.
name|line_change
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|cur_token
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Finish inlining run_directive.  */
name|pfile
operator|->
name|buffer
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Reset the old macro state before ...  */
name|XDELETE
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|context
operator|=
name|saved_context
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|saved_cur_token
expr_stmt|;
name|pfile
operator|->
name|cur_run
operator|=
name|saved_cur_run
expr_stmt|;
comment|/* ... inserting the new tokens we collected.  */
name|_cpp_push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|toks
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the _Pragma operator.  */
end_comment

begin_function
name|void
name|_cpp_do__Pragma
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|string
init|=
name|get__Pragma_string
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|directive_result
operator|.
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|destringize_and_run
argument_list|(
name|pfile
argument_list|,
operator|&
name|string
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"_Pragma takes a parenthesized string literal"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #ifdef.  */
end_comment

begin_function
specifier|static
name|void
name|do_ifdef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|skip
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
block|{
specifier|const
name|cpp_hashnode
modifier|*
name|node
init|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|skip
operator|=
name|node
operator|->
name|type
operator|!=
name|NT_MACRO
expr_stmt|;
name|_cpp_mark_macro_used
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
name|push_conditional
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IFDEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #ifndef.  */
end_comment

begin_function
specifier|static
name|void
name|do_ifndef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|skip
init|=
literal|1
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
block|{
name|node
operator|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|skip
operator|=
name|node
operator|->
name|type
operator|==
name|NT_MACRO
expr_stmt|;
name|_cpp_mark_macro_used
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
name|push_conditional
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IFNDEF
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* _cpp_parse_expr puts a macro in a "#if !defined ()" expression in    pfile->mi_ind_cmacro so we can handle multiple-include    optimizations.  If macro expansion occurs in the expression, we    cannot treat it as a controlling conditional, since the expansion    could change in the future.  That is handled by cpp_get_token.  */
end_comment

begin_function
specifier|static
name|void
name|do_if
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|skip
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|skip
operator|=
name|_cpp_parse_expr
argument_list|(
name|pfile
argument_list|)
operator|==
name|false
expr_stmt|;
name|push_conditional
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|,
name|pfile
operator|->
name|mi_ind_cmacro
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flip skipping state if appropriate and continue without changing    if_stack; this is so that the error message for missing #endif's    etc. will point to the original #if.  */
end_comment

begin_function
specifier|static
name|void
name|do_else
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
init|=
name|buffer
operator|->
name|if_stack
decl_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#else without #if"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ifs
operator|->
name|type
operator|==
name|T_ELSE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#else after #else"
argument_list|)
expr_stmt|;
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|ifs
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"the conditional began here"
argument_list|)
expr_stmt|;
block|}
name|ifs
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
comment|/* Skip any future (erroneous) #elses or #elifs.  */
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|ifs
operator|->
name|skip_elses
expr_stmt|;
name|ifs
operator|->
name|skip_elses
operator|=
name|true
expr_stmt|;
comment|/* Invalidate any controlling macro.  */
name|ifs
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
comment|/* Only check EOL if was not originally skipping.  */
if|if
condition|(
operator|!
name|ifs
operator|->
name|was_skipping
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_endif_labels
argument_list|)
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a #elif directive by not changing if_stack either.  See the    comment above do_else.  */
end_comment

begin_function
specifier|static
name|void
name|do_elif
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
init|=
name|buffer
operator|->
name|if_stack
decl_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#elif without #if"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ifs
operator|->
name|type
operator|==
name|T_ELSE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#elif after #else"
argument_list|)
expr_stmt|;
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|ifs
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"the conditional began here"
argument_list|)
expr_stmt|;
block|}
name|ifs
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
comment|/* Only evaluate this if we aren't skipping elses.  During 	 evaluation, set skipping to false to get lexer warnings.  */
if|if
condition|(
name|ifs
operator|->
name|skip_elses
condition|)
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
operator|!
name|_cpp_parse_expr
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|ifs
operator|->
name|skip_elses
operator|=
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
expr_stmt|;
block|}
comment|/* Invalidate any controlling macro.  */
name|ifs
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #endif pops the if stack and resets pfile->state.skipping.  */
end_comment

begin_function
specifier|static
name|void
name|do_endif
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
init|=
name|buffer
operator|->
name|if_stack
decl_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"#endif without #if"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only check EOL if was not originally skipping.  */
if|if
condition|(
operator|!
name|ifs
operator|->
name|was_skipping
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_endif_labels
argument_list|)
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* If potential control macro, we go back outside again.  */
if|if
condition|(
name|ifs
operator|->
name|next
operator|==
literal|0
operator|&&
name|ifs
operator|->
name|mi_cmacro
condition|)
block|{
name|pfile
operator|->
name|mi_valid
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|mi_cmacro
operator|=
name|ifs
operator|->
name|mi_cmacro
expr_stmt|;
block|}
name|buffer
operator|->
name|if_stack
operator|=
name|ifs
operator|->
name|next
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|ifs
operator|->
name|was_skipping
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
name|ifs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push an if_stack entry for a preprocessor conditional, and set    pfile->state.skipping to SKIP.  If TYPE indicates the conditional    is #if or #ifndef, CMACRO is a potentially controlling macro, and    we need to check here that we are at the top of the file.  */
end_comment

begin_function
specifier|static
name|void
name|push_conditional
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
name|cmacro
parameter_list|)
block|{
name|struct
name|if_stack
modifier|*
name|ifs
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|ifs
operator|=
name|XOBNEW
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
expr|struct
name|if_stack
argument_list|)
expr_stmt|;
name|ifs
operator|->
name|line
operator|=
name|pfile
operator|->
name|directive_line
expr_stmt|;
name|ifs
operator|->
name|next
operator|=
name|buffer
operator|->
name|if_stack
expr_stmt|;
name|ifs
operator|->
name|skip_elses
operator|=
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|||
operator|!
name|skip
expr_stmt|;
name|ifs
operator|->
name|was_skipping
operator|=
name|pfile
operator|->
name|state
operator|.
name|skipping
expr_stmt|;
name|ifs
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* This condition is effectively a test for top-of-file.  */
if|if
condition|(
name|pfile
operator|->
name|mi_valid
operator|&&
name|pfile
operator|->
name|mi_cmacro
operator|==
literal|0
condition|)
name|ifs
operator|->
name|mi_cmacro
operator|=
name|cmacro
expr_stmt|;
else|else
name|ifs
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|skip
expr_stmt|;
name|buffer
operator|->
name|if_stack
operator|=
name|ifs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the tokens of the answer into the macro pool, in a directive    of type TYPE.  Only commit the memory if we intend it as permanent    storage, i.e. the #assert case.  Returns 0 on success, and sets    ANSWERP to point to the answer.  */
end_comment

begin_function
specifier|static
name|int
name|parse_answer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|struct
name|answer
modifier|*
modifier|*
name|answerp
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|paren
decl_stmt|;
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|unsigned
name|int
name|acount
decl_stmt|;
comment|/* In a conditional, it is legal to not have an open paren.  We      should save the following token in this case.  */
name|paren
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* If not a paren, see if we're OK.  */
if|if
condition|(
name|paren
operator|->
name|type
operator|!=
name|CPP_OPEN_PAREN
condition|)
block|{
comment|/* In a conditional no answer is a test for any answer.  It          could be followed by any token.  */
if|if
condition|(
name|type
operator|==
name|T_IF
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* #unassert with no answer is valid - it removes all answers.  */
if|if
condition|(
name|type
operator|==
name|T_UNASSERT
operator|&&
name|paren
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
return|return
literal|0
return|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"missing '(' after predicate"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|acount
operator|=
literal|0
init|;
condition|;
name|acount
operator|++
control|)
block|{
name|size_t
name|room_needed
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_token
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
break|break;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"missing ')' to complete answer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* struct answer includes the space for one token.  */
name|room_needed
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
operator|+
name|acount
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|<
name|room_needed
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|&
operator|(
operator|(
expr|struct
name|answer
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|)
operator|->
name|first
index|[
name|acount
index|]
expr_stmt|;
operator|*
name|dest
operator|=
operator|*
name|token
expr_stmt|;
comment|/* Drop whitespace at start, for answer equivalence purposes.  */
if|if
condition|(
name|acount
operator|==
literal|0
condition|)
name|dest
operator|->
name|flags
operator|&=
operator|~
name|PREV_WHITE
expr_stmt|;
block|}
if|if
condition|(
name|acount
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"predicate's answer is empty"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|answer
operator|=
operator|(
expr|struct
name|answer
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|answer
operator|->
name|count
operator|=
name|acount
expr_stmt|;
name|answer
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|answerp
operator|=
name|answer
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parses an assertion directive of type TYPE, returning a pointer to    the hash node of the predicate, or 0 on error.  If an answer was    supplied, it is placed in ANSWERP, otherwise it is set to 0.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|parse_assertion
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|struct
name|answer
modifier|*
modifier|*
name|answerp
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|predicate
decl_stmt|;
comment|/* We don't expand predicates or answers.  */
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
operator|*
name|answerp
operator|=
literal|0
expr_stmt|;
name|predicate
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|predicate
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"assertion without predicate"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|predicate
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"predicate must be an identifier"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_answer
argument_list|(
name|pfile
argument_list|,
name|answerp
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|len
init|=
name|NODE_LEN
argument_list|(
name|predicate
operator|->
name|val
operator|.
name|node
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sym
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Prefix '#' to get it out of macro namespace.  */
name|sym
index|[
literal|0
index|]
operator|=
literal|'#'
expr_stmt|;
name|memcpy
argument_list|(
name|sym
operator|+
literal|1
argument_list|,
name|NODE_NAME
argument_list|(
name|predicate
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns a pointer to the pointer to CANDIDATE in the answer chain,    or a pointer to NULL if the answer is not in the chain.  */
end_comment

begin_function
specifier|static
name|struct
name|answer
modifier|*
modifier|*
name|find_answer
parameter_list|(
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
specifier|const
name|struct
name|answer
modifier|*
name|candidate
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|answer
modifier|*
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|result
operator|=
operator|&
name|node
operator|->
name|value
operator|.
name|answers
init|;
operator|*
name|result
condition|;
name|result
operator|=
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|next
control|)
block|{
name|struct
name|answer
modifier|*
name|answer
init|=
operator|*
name|result
decl_stmt|;
if|if
condition|(
name|answer
operator|->
name|count
operator|==
name|candidate
operator|->
name|count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|answer
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|_cpp_equiv_tokens
argument_list|(
operator|&
name|answer
operator|->
name|first
index|[
name|i
index|]
argument_list|,
operator|&
name|candidate
operator|->
name|first
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|answer
operator|->
name|count
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Test an assertion within a preprocessor conditional.  Returns    nonzero on failure, zero on success.  On success, the result of    the test is written into VALUE, otherwise the value 0.  */
end_comment

begin_function
name|int
name|_cpp_test_assertion
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|unsigned
name|int
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|answer
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
comment|/* For recovery, an erroneous assertion expression is handled as a      failing assertion.  */
operator|*
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
condition|)
operator|*
name|value
operator|=
operator|(
name|node
operator|->
name|type
operator|==
name|NT_ASSERTION
operator|&&
operator|(
name|answer
operator|==
literal|0
operator|||
operator|*
name|find_answer
argument_list|(
name|node
argument_list|,
name|answer
argument_list|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|CPP_EOF
condition|)
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't commit the memory for the answer - it's temporary only.  */
return|return
name|node
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle #assert.  */
end_comment

begin_function
specifier|static
name|void
name|do_assert
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|struct
name|answer
modifier|*
name|new_answer
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|new_answer
argument_list|,
name|T_ASSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|size_t
name|answer_size
decl_stmt|;
comment|/* Place the new answer in the answer list.  First check there          is not a duplicate.  */
name|new_answer
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_ASSERTION
condition|)
block|{
if|if
condition|(
operator|*
name|find_answer
argument_list|(
name|node
argument_list|,
name|new_answer
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"\"%s\" re-asserted"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_answer
operator|->
name|next
operator|=
name|node
operator|->
name|value
operator|.
name|answers
expr_stmt|;
block|}
name|answer_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
operator|+
operator|(
operator|(
name|new_answer
operator|->
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
operator|)
expr_stmt|;
comment|/* Commit or allocate storage for the object.  */
if|if
condition|(
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
condition|)
block|{
name|struct
name|answer
modifier|*
name|temp_answer
init|=
name|new_answer
decl_stmt|;
name|new_answer
operator|=
operator|(
expr|struct
name|answer
operator|*
operator|)
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
argument_list|(
name|answer_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_answer
argument_list|,
name|temp_answer
argument_list|,
name|answer_size
argument_list|)
expr_stmt|;
block|}
else|else
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|+=
name|answer_size
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|NT_ASSERTION
expr_stmt|;
name|node
operator|->
name|value
operator|.
name|answers
operator|=
name|new_answer
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle #unassert.  */
end_comment

begin_function
specifier|static
name|void
name|do_unassert
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|answer
argument_list|,
name|T_UNASSERT
argument_list|)
expr_stmt|;
comment|/* It isn't an error to #unassert something that isn't asserted.  */
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|type
operator|==
name|NT_ASSERTION
condition|)
block|{
if|if
condition|(
name|answer
condition|)
block|{
name|struct
name|answer
modifier|*
modifier|*
name|p
init|=
name|find_answer
argument_list|(
name|node
argument_list|,
name|answer
argument_list|)
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* Remove the answer from the list.  */
name|temp
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|p
operator|=
name|temp
operator|->
name|next
expr_stmt|;
comment|/* Did we free the last answer?  */
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|answers
operator|==
literal|0
condition|)
name|node
operator|->
name|type
operator|=
name|NT_VOID
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
name|_cpp_free_definition
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* We don't commit the memory for the answer - it's temporary only.  */
block|}
end_function

begin_comment
comment|/* These are for -D, -U, -A.  */
end_comment

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #define.    If STR is just an identifier, define it with value 1.    If STR has anything after the identifier, then it should    be identifier=definition.  */
end_comment

begin_function
name|void
name|cpp_define
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|count
decl_stmt|;
comment|/* Copy the entire option so we can modify it.      Change the first "=" in the string to a space.  If there is none,      tack " 1" on the end.  */
name|count
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|' '
expr_stmt|;
else|else
block|{
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|'1'
expr_stmt|;
block|}
name|buf
index|[
name|count
index|]
operator|=
literal|'\n'
expr_stmt|;
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_DEFINE
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Slight variant of the above for use by initialize_builtins.  */
end_comment

begin_function
name|void
name|_cpp_define_builtin
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_DEFINE
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process MACRO as if it appeared as the body of an #undef.  */
end_comment

begin_function
name|void
name|cpp_undef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|macro
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|macro
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_UNDEF
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #assert.  */
end_comment

begin_function
name|void
name|cpp_assert
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|handle_assertion
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|T_ASSERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process STR as if it appeared as the body of an #unassert.  */
end_comment

begin_function
name|void
name|cpp_unassert
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|handle_assertion
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|T_UNASSERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common code for cpp_assert (-A) and cpp_unassert (-A-).  */
end_comment

begin_function
specifier|static
name|void
name|handle_assertion
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|size_t
name|count
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  Change the first      "=" in the string to a '(', and tack a ')' on the end.  */
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|2
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|'('
expr_stmt|;
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
name|buf
index|[
name|count
index|]
operator|=
literal|'\n'
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|type
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The number of errors for a given reader.  */
end_comment

begin_function
name|unsigned
name|int
name|cpp_errors
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
return|return
name|pfile
operator|->
name|errors
return|;
block|}
end_function

begin_comment
comment|/* The options structure.  */
end_comment

begin_function
name|cpp_options
modifier|*
name|cpp_get_options
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
return|return
operator|&
name|pfile
operator|->
name|opts
return|;
block|}
end_function

begin_comment
comment|/* The callbacks structure.  */
end_comment

begin_function
name|cpp_callbacks
modifier|*
name|cpp_get_callbacks
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
return|return
operator|&
name|pfile
operator|->
name|cb
return|;
block|}
end_function

begin_comment
comment|/* Copy the given callbacks structure to our own.  */
end_comment

begin_function
name|void
name|cpp_set_callbacks
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_callbacks
modifier|*
name|cb
parameter_list|)
block|{
name|pfile
operator|->
name|cb
operator|=
operator|*
name|cb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The dependencies structure.  (Creates one if it hasn't already been.)  */
end_comment

begin_function
name|struct
name|deps
modifier|*
name|cpp_get_deps
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|deps
condition|)
name|pfile
operator|->
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
return|return
name|pfile
operator|->
name|deps
return|;
block|}
end_function

begin_comment
comment|/* Push a new buffer on the buffer stack.  Returns the new buffer; it    doesn't fail.  It does not generate a file change call back; that    is the responsibility of the caller.  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_push_buffer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|buffer
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|from_stage3
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|new_buffer
init|=
name|XOBNEW
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
name|cpp_buffer
argument_list|)
decl_stmt|;
comment|/* Clears, amongst other things, if_stack and mi_cmacro.  */
name|memset
argument_list|(
name|new_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|new_buffer
operator|->
name|next_line
operator|=
name|new_buffer
operator|->
name|buf
operator|=
name|buffer
expr_stmt|;
name|new_buffer
operator|->
name|rlimit
operator|=
name|buffer
operator|+
name|len
expr_stmt|;
name|new_buffer
operator|->
name|from_stage3
operator|=
name|from_stage3
expr_stmt|;
name|new_buffer
operator|->
name|prev
operator|=
name|pfile
operator|->
name|buffer
expr_stmt|;
name|new_buffer
operator|->
name|need_line
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|=
name|new_buffer
expr_stmt|;
return|return
name|new_buffer
return|;
block|}
end_function

begin_comment
comment|/* Pops a single buffer, with a file change call-back if appropriate.    Then pushes the next -include file, if any remain.  */
end_comment

begin_function
name|void
name|_cpp_pop_buffer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|_cpp_file
modifier|*
name|inc
init|=
name|buffer
operator|->
name|file
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
decl_stmt|;
comment|/* Walk back up the conditional stack till we reach its level at      entry to this file, issuing error messages.  */
for|for
control|(
name|ifs
operator|=
name|buffer
operator|->
name|if_stack
init|;
name|ifs
condition|;
name|ifs
operator|=
name|ifs
operator|->
name|next
control|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|ifs
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"unterminated #%s"
argument_list|,
name|dtable
index|[
name|ifs
operator|->
name|type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* In case of a missing #endif.  */
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
literal|0
expr_stmt|;
comment|/* _cpp_do_file_change expects pfile->buffer to be the new one.  */
name|pfile
operator|->
name|buffer
operator|=
name|buffer
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|buffer
operator|->
name|notes
argument_list|)
expr_stmt|;
comment|/* Free the buffer object now; we may want to push a new buffer      in _cpp_push_next_include_file.  */
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
condition|)
block|{
name|_cpp_pop_file_buffer
argument_list|(
name|pfile
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_LEAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter all recognized directives in the hash table.  */
end_comment

begin_function
name|void
name|_cpp_init_directives
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|N_DIRECTIVES
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|dtable
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dtable
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|node
operator|->
name|is_directive
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|directive_index
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

end_unit

