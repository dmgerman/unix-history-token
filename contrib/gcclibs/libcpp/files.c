begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  File handling.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987    Split out of cpplib.c, Zack Weinberg, Oct 1998    Reimplemented, Neil Booth, Jul 2003  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_comment
comment|/* Variable length record files on VMS will have a stat size that includes    record control characters that won't be included in the read size.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|FAB_C_VAR
value|2
end_define

begin_comment
comment|/* variable length records (see Starlet fabdef.h) */
end_comment

begin_define
define|#
directive|define
name|STAT_SIZE_RELIABLE
parameter_list|(
name|ST
parameter_list|)
value|((ST).st_fab_rfm != FAB_C_VAR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STAT_SIZE_RELIABLE
parameter_list|(
name|ST
parameter_list|)
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__DJGPP__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_comment
comment|/* For DJGPP redirected input is opened in text mode.  */
end_comment

begin_define
define|#
directive|define
name|set_stdin_to_binary_mode
parameter_list|()
define|\
value|if (! isatty (0)) setmode (0, O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|set_stdin_to_binary_mode
parameter_list|()
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure represents a file searched for by CPP, whether it    exists or not.  An instance may be pointed to by more than one    file_hash_entry; at present no reference count is kept.  */
end_comment

begin_struct
struct|struct
name|_cpp_file
block|{
comment|/* Filename as given to #include or command line switch.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The full path used to find the file.  */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The full path of the pch file.  */
specifier|const
name|char
modifier|*
name|pchname
decl_stmt|;
comment|/* The file's path with the basename stripped.  NULL if it hasn't      been calculated yet.  */
specifier|const
name|char
modifier|*
name|dir_name
decl_stmt|;
comment|/* Chain through all files.  */
name|struct
name|_cpp_file
modifier|*
name|next_file
decl_stmt|;
comment|/* The contents of NAME after calling read_file().  */
specifier|const
name|uchar
modifier|*
name|buffer
decl_stmt|;
comment|/* The macro, if any, preventing re-inclusion.  */
specifier|const
name|cpp_hashnode
modifier|*
name|cmacro
decl_stmt|;
comment|/* The directory in the search path where FILE was found.  Used for      #include_next and determining whether a header is a system      header.  */
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
comment|/* As filled in by stat(2) for the file.  */
name|struct
name|stat
name|st
decl_stmt|;
comment|/* File descriptor.  Invalid if -1, otherwise open.  */
name|int
name|fd
decl_stmt|;
comment|/* Zero if this file was successfully opened and stat()-ed,      otherwise errno obtained from failure.  */
name|int
name|err_no
decl_stmt|;
comment|/* Number of times the file has been stacked for preprocessing.  */
name|unsigned
name|short
name|stack_count
decl_stmt|;
comment|/* If opened with #import or contains #pragma once.  */
name|bool
name|once_only
decl_stmt|;
comment|/* If read() failed before.  */
name|bool
name|dont_read
decl_stmt|;
comment|/* If this file is the main file.  */
name|bool
name|main_file
decl_stmt|;
comment|/* If BUFFER above contains the true contents of the file.  */
name|bool
name|buffer_valid
decl_stmt|;
comment|/* File is a PCH (on return from find_include_file).  */
name|bool
name|pch
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A singly-linked list for all searches for a given file name, with    its head pointed to by a slot in FILE_HASH.  The file name is what    appeared between the quotes in a #include directive; it can be    determined implicitly from the hash table location or explicitly    from FILE->name.     FILE is a structure containing details about the file that was    found with that search, or details of how the search failed.     START_DIR is the starting location of the search in the include    chain.  The current directories for "" includes are also hashed in    the hash table and therefore unique.  Files that are looked up    without using a search path, such as absolute filenames and file    names from the command line share a special starting directory so    they don't cause cache hits with normal include-chain lookups.     If START_DIR is NULL then the entry is for a directory, not a file,    and the directory is in DIR.  Since the starting point in a file    lookup chain is never NULL, this means that simple pointer    comparisons against START_DIR can be made to determine cache hits    in file lookups.     If a cache lookup fails because of e.g. an extra "./" in the path,    then nothing will break.  It is just less efficient as CPP will    have to do more work re-preprocessing the file, and/or comparing    its contents against earlier once-only files. */
end_comment

begin_struct
struct|struct
name|file_hash_entry
block|{
name|struct
name|file_hash_entry
modifier|*
name|next
decl_stmt|;
name|cpp_dir
modifier|*
name|start_dir
decl_stmt|;
union|union
block|{
name|_cpp_file
modifier|*
name|file
decl_stmt|;
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bool
name|open_file
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|pch_open_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
modifier|*
name|invalid_pch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|find_file_in_dir
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
modifier|*
name|invalid_pch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|read_file_guts
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|read_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|should_stack_file
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
name|import
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cpp_dir
modifier|*
name|search_path_head
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|angle_brackets
parameter_list|,
name|enum
name|include_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dir_name_of_file
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|open_file_failed
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|search_cache
parameter_list|(
name|struct
name|file_hash_entry
modifier|*
name|head
parameter_list|,
specifier|const
name|cpp_dir
modifier|*
name|start_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|_cpp_file
modifier|*
name|make_cpp_file
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_dir
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_cpp_file
parameter_list|(
name|_cpp_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_dir
modifier|*
name|make_cpp_dir
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_name
parameter_list|,
name|int
name|sysp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_file_hash_entries
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|new_file_hash_entry
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|report_missing_guard
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|file_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|int
name|ch
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_name_map
parameter_list|(
name|cpp_dir
modifier|*
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|remap_filename
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|append_file_to_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|cpp_dir
modifier|*
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|validate_pch
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|pchname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pchf_save_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pchf_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|d_p
parameter_list|,
specifier|const
name|void
modifier|*
name|e_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_file_against_entries
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|_cpp_file
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given a filename in FILE->PATH, with the empty string interpreted    as<stdin>, open it.     On success FILE contains an open file descriptor and stat    information for the file.  On failure the file descriptor is -1 and    the appropriate errno is also stored in FILE.  Returns TRUE iff    successful.     We used to open files in nonblocking mode, but that caused more    problems than it solved.  Do take care not to acquire a controlling    terminal by mistake (this can't happen on sane systems, but    paranoia is a virtue).     Use the three-argument form of open even though we aren't    specifying O_CREAT, to defend against broken system headers.     O_BINARY tells some runtime libraries (notably DJGPP) not to do    newline translation; we can handle DOS line breaks just fine    ourselves.  */
end_comment

begin_function
specifier|static
name|bool
name|open_file
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|file
operator|->
name|fd
operator|=
literal|0
expr_stmt|;
name|set_stdin_to_binary_mode
argument_list|()
expr_stmt|;
block|}
else|else
name|file
operator|->
name|fd
operator|=
name|open
argument_list|(
name|file
operator|->
name|path
argument_list|,
name|O_RDONLY
operator||
name|O_NOCTTY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|file
operator|->
name|fd
argument_list|,
operator|&
name|file
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|file
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|file
operator|->
name|err_no
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Ignore a directory and continue the search.  The file we're 	     looking for may be elsewhere in the search path.  */
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
name|close
argument_list|(
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOTDIR
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|file
operator|->
name|err_no
operator|=
name|errno
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Temporary PCH intercept of opening a file.  Try to find a PCH file    based on FILE->name and FILE->dir, and test those found for    validity using PFILE->cb.valid_pch.  Return true iff a valid file is    found.  Set *INVALID_PCH if a PCH file is found but wasn't valid.  */
end_comment

begin_function
specifier|static
name|bool
name|pch_open_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
modifier|*
name|invalid_pch
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|extension
index|[]
init|=
literal|".gch"
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|file
operator|->
name|path
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|flen
decl_stmt|;
name|char
modifier|*
name|pchname
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|bool
name|valid
init|=
name|false
decl_stmt|;
comment|/* No PCH on<stdin> or if not requested.  */
if|if
condition|(
name|file
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|!
name|pfile
operator|->
name|cb
operator|.
name|valid_pch
condition|)
return|return
name|false
return|;
name|flen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|len
operator|=
name|flen
operator|+
sizeof|sizeof
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|pchname
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pchname
argument_list|,
name|path
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pchname
operator|+
name|flen
argument_list|,
name|extension
argument_list|,
sizeof|sizeof
argument_list|(
name|extension
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pchname
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DIR
modifier|*
name|pchdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|size_t
name|dlen
decl_stmt|,
name|plen
init|=
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|valid
operator|=
name|validate_pch
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|pchname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pchdir
operator|=
name|opendir
argument_list|(
name|pchname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pchname
index|[
name|plen
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|pchdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dlen
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|dlen
operator|+
name|plen
operator|>
name|len
condition|)
block|{
name|len
operator|+=
name|dlen
operator|+
literal|64
expr_stmt|;
name|pchname
operator|=
name|XRESIZEVEC
argument_list|(
name|char
argument_list|,
name|pchname
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pchname
operator|+
name|plen
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|valid
operator|=
name|validate_pch
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|pchname
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
break|break;
block|}
name|closedir
argument_list|(
name|pchdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
name|file
operator|->
name|pch
operator|=
name|true
expr_stmt|;
else|else
operator|*
name|invalid_pch
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
name|file
operator|->
name|pchname
operator|=
name|pchname
expr_stmt|;
else|else
name|free
argument_list|(
name|pchname
argument_list|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/* Try to open the path FILE->name appended to FILE->dir.  This is    where remap and PCH intercept the file lookup process.  Return true    if the file was found, whether or not the open was successful.    Set *INVALID_PCH to true if a PCH file is found but wasn't valid.  */
end_comment

begin_function
specifier|static
name|bool
name|find_file_in_dir
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
modifier|*
name|invalid_pch
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|remap
argument_list|)
operator|&&
operator|(
name|path
operator|=
name|remap_filename
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|file
operator|->
name|dir
operator|->
name|construct
condition|)
name|path
operator|=
name|file
operator|->
name|dir
operator|->
name|construct
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|file
operator|->
name|dir
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|append_file_to_dir
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|file
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|hashval_t
name|hv
init|=
name|htab_hash_string
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|void
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|htab_find_with_hash
argument_list|(
name|pfile
operator|->
name|nonexistent_file_hash
argument_list|,
name|path
argument_list|,
name|hv
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|file
operator|->
name|err_no
operator|=
name|ENOENT
expr_stmt|;
return|return
name|false
return|;
block|}
name|file
operator|->
name|path
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|pch_open_file
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|invalid_pch
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|open_file
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|file
operator|->
name|err_no
operator|!=
name|ENOENT
condition|)
block|{
name|open_file_failed
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We copy the path name onto an obstack partly so that we don't 	 leak the memory, but mostly so that we don't fragment the 	 heap.  */
name|copy
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|pfile
operator|->
name|nonexistent_file_ob
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|pp
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|pfile
operator|->
name|nonexistent_file_hash
argument_list|,
name|copy
argument_list|,
name|hv
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|copy
expr_stmt|;
name|file
operator|->
name|path
operator|=
name|file
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|file
operator|->
name|err_no
operator|=
name|ENOENT
expr_stmt|;
name|file
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return tue iff the missing_header callback found the given HEADER.  */
end_comment

begin_function
specifier|static
name|bool
name|search_path_exhausted
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
name|missing_header_cb
name|func
init|=
name|pfile
operator|->
name|cb
operator|.
name|missing_header
decl_stmt|;
comment|/* When the regular search path doesn't work, try context dependent      headers search paths.  */
if|if
condition|(
name|func
operator|&&
name|file
operator|->
name|dir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|file
operator|->
name|path
operator|=
name|func
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|,
operator|&
name|file
operator|->
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|open_file
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|true
return|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|file
operator|->
name|path
operator|=
name|file
operator|->
name|name
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|_cpp_find_failed
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
return|return
name|file
operator|->
name|err_no
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a filename FNAME search for such a file in the include path    starting from START_DIR.  If FNAME is the empty string it is    interpreted as STDIN if START_DIR is PFILE->no_search_path.     If the file is not found in the file cache fall back to the O/S and    add the result to our cache.     If the file was not found in the filesystem, or there was an error    opening it, then ERR_NO is nonzero and FD is -1.  If the file was    found, then ERR_NO is zero and FD could be -1 or an open file    descriptor.  FD can be -1 if the file was found in the cache and    had previously been closed.  To open it again pass the return value    to open_file(). */
end_comment

begin_function
name|_cpp_file
modifier|*
name|_cpp_find_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|cpp_dir
modifier|*
name|start_dir
parameter_list|,
name|bool
name|fake
parameter_list|,
name|int
name|angle_brackets
parameter_list|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|hash_slot
decl_stmt|;
name|_cpp_file
modifier|*
name|file
decl_stmt|;
name|bool
name|invalid_pch
init|=
name|false
decl_stmt|;
name|bool
name|saw_bracket_include
init|=
name|false
decl_stmt|;
name|bool
name|saw_quote_include
init|=
name|false
decl_stmt|;
name|struct
name|cpp_dir
modifier|*
name|found_in_cache
init|=
name|NULL
decl_stmt|;
comment|/* Ensure we get no confusion between cached files and directories.  */
if|if
condition|(
name|start_dir
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"NULL directory in find_file"
argument_list|)
expr_stmt|;
name|hash_slot
operator|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|pfile
operator|->
name|file_hash
argument_list|,
name|fname
argument_list|,
name|htab_hash_string
argument_list|(
name|fname
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* First check the cache before we resort to memory allocation.  */
name|entry
operator|=
name|search_cache
argument_list|(
operator|*
name|hash_slot
argument_list|,
name|start_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|entry
operator|->
name|u
operator|.
name|file
return|;
name|file
operator|=
name|make_cpp_file
argument_list|(
name|pfile
argument_list|,
name|start_dir
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* Try each path in the include chain.  */
for|for
control|(
init|;
operator|!
name|fake
condition|;
control|)
block|{
if|if
condition|(
name|find_file_in_dir
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
operator|&
name|invalid_pch
argument_list|)
condition|)
break|break;
name|file
operator|->
name|dir
operator|=
name|file
operator|->
name|dir
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|dir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|search_path_exhausted
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|file
argument_list|)
condition|)
block|{
comment|/* Although this file must not go in the cache, because 		 the file found might depend on things (like the current file) 		 that aren't represented in the cache, it still has to go in 		 the list of all files so that #import works.  */
name|file
operator|->
name|next_file
operator|=
name|pfile
operator|->
name|all_files
expr_stmt|;
name|pfile
operator|->
name|all_files
operator|=
name|file
expr_stmt|;
return|return
name|file
return|;
block|}
name|open_file_failed
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|angle_brackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalid_pch
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"one or more PCH files were found, but they were invalid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_invalid_pch
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"use -Winvalid-pch for more information"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Only check the cache for the starting location (done above) 	 and the quote and bracket chain heads because there are no 	 other possible starting points for searches.  */
if|if
condition|(
name|file
operator|->
name|dir
operator|==
name|pfile
operator|->
name|bracket_include
condition|)
name|saw_bracket_include
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|file
operator|->
name|dir
operator|==
name|pfile
operator|->
name|quote_include
condition|)
name|saw_quote_include
operator|=
name|true
expr_stmt|;
else|else
continue|continue;
name|entry
operator|=
name|search_cache
argument_list|(
operator|*
name|hash_slot
argument_list|,
name|file
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|found_in_cache
operator|=
name|file
operator|->
name|dir
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|entry
condition|)
block|{
comment|/* Cache for START_DIR too, sharing the _cpp_file structure.  */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|entry
operator|->
name|u
operator|.
name|file
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a new file; put it in the list.  */
name|file
operator|->
name|next_file
operator|=
name|pfile
operator|->
name|all_files
expr_stmt|;
name|pfile
operator|->
name|all_files
operator|=
name|file
expr_stmt|;
block|}
comment|/* Store this new result in the hash table.  */
name|entry
operator|=
name|new_file_hash_entry
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|hash_slot
expr_stmt|;
name|entry
operator|->
name|start_dir
operator|=
name|start_dir
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|file
operator|=
name|file
expr_stmt|;
operator|*
name|hash_slot
operator|=
name|entry
expr_stmt|;
comment|/* If we passed the quote or bracket chain heads, cache them also.      This speeds up processing if there are lots of -I options.  */
if|if
condition|(
name|saw_bracket_include
operator|&&
name|pfile
operator|->
name|bracket_include
operator|!=
name|start_dir
operator|&&
name|found_in_cache
operator|!=
name|pfile
operator|->
name|bracket_include
condition|)
block|{
name|entry
operator|=
name|new_file_hash_entry
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|hash_slot
expr_stmt|;
name|entry
operator|->
name|start_dir
operator|=
name|pfile
operator|->
name|bracket_include
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|file
operator|=
name|file
expr_stmt|;
operator|*
name|hash_slot
operator|=
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|saw_quote_include
operator|&&
name|pfile
operator|->
name|quote_include
operator|!=
name|start_dir
operator|&&
name|found_in_cache
operator|!=
name|pfile
operator|->
name|quote_include
condition|)
block|{
name|entry
operator|=
name|new_file_hash_entry
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|hash_slot
expr_stmt|;
name|entry
operator|->
name|start_dir
operator|=
name|pfile
operator|->
name|quote_include
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|file
operator|=
name|file
expr_stmt|;
operator|*
name|hash_slot
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
end_function

begin_comment
comment|/* Read a file into FILE->buffer, returning true on success.     If FILE->fd is something weird, like a block device, we don't want    to read it at all.  Don't even try to figure out what something is,    except for plain files and block devices, since there is no    reliable portable way of doing this.     FIXME: Flush file cache and try again if we run out of memory.  */
end_comment

begin_function
specifier|static
name|bool
name|read_file_guts
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
name|ssize_t
name|size
decl_stmt|,
name|total
decl_stmt|,
name|count
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|uchar
modifier|*
name|buf
decl_stmt|;
name|bool
name|regular
decl_stmt|;
if|if
condition|(
name|S_ISBLK
argument_list|(
name|file
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"%s is a block device"
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|regular
operator|=
name|S_ISREG
argument_list|(
name|file
operator|->
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|regular
condition|)
block|{
comment|/* off_t might have a wider range than ssize_t - in other words, 	 the max size of a file might be bigger than the address 	 space.  We can't handle a file that large.  (Anyone with 	 a single source file bigger than 2GB needs to rethink 	 their coding style.)  Some systems (e.g. AIX 4.1) define 	 SSIZE_MAX to be much smaller than the actual range of the 	 type.  Use INTTYPE_MAXIMUM unconditionally to ensure this 	 does not bite us.  */
if|if
condition|(
name|file
operator|->
name|st
operator|.
name|st_size
operator|>
name|INTTYPE_MAXIMUM
argument_list|(
name|ssize_t
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"%s is too large"
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|size
operator|=
name|file
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|=
name|lseek
argument_list|(
name|file
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"%s has no current position"
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
name|INTTYPE_MAXIMUM
argument_list|(
name|ssize_t
argument_list|)
operator|||
operator|(
name|ssize_t
operator|)
name|offset
operator|>
name|size
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"current position of %s is too large"
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|size
operator|-=
operator|(
name|ssize_t
operator|)
name|offset
expr_stmt|;
block|}
else|else
comment|/* 8 kilobytes is a sensible starting size.  It ought to be bigger        than the kernel pipe buffer, and it's definitely bigger than        the majority of C source files.  */
name|size
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
name|buf
operator|=
name|XNEWVEC
argument_list|(
name|uchar
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|file
operator|->
name|fd
argument_list|,
name|buf
operator|+
name|total
argument_list|,
name|size
operator|-
name|total
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|total
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|total
operator|==
name|size
condition|)
block|{
if|if
condition|(
name|regular
condition|)
break|break;
name|size
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|buf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|regular
operator|&&
name|total
operator|!=
name|size
operator|&&
name|STAT_SIZE_RELIABLE
argument_list|(
name|file
operator|->
name|st
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"%s is shorter than expected"
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
name|file
operator|->
name|buffer
operator|=
name|_cpp_convert_input
argument_list|(
name|pfile
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|input_charset
argument_list|)
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|total
argument_list|,
operator|&
name|file
operator|->
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|file
operator|->
name|buffer_valid
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Convenience wrapper around read_file_guts that opens the file if    necessary and closes the file descriptor after reading.  FILE must    have been passed through find_file() at some stage.  */
end_comment

begin_function
specifier|static
name|bool
name|read_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
comment|/* If we already have its contents in memory, succeed immediately.  */
if|if
condition|(
name|file
operator|->
name|buffer_valid
condition|)
return|return
name|true
return|;
comment|/* If an earlier read failed for some reason don't try again.  */
if|if
condition|(
name|file
operator|->
name|dont_read
operator|||
name|file
operator|->
name|err_no
condition|)
return|return
name|false
return|;
if|if
condition|(
name|file
operator|->
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|!
name|open_file
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|open_file_failed
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|file
operator|->
name|dont_read
operator|=
operator|!
name|read_file_guts
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|!
name|file
operator|->
name|dont_read
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if FILE's contents have been successfully placed in    FILE->buffer and the file should be stacked, otherwise false.  */
end_comment

begin_function
specifier|static
name|bool
name|should_stack_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
name|import
parameter_list|)
block|{
name|_cpp_file
modifier|*
name|f
decl_stmt|;
comment|/* Skip once-only files.  */
if|if
condition|(
name|file
operator|->
name|once_only
condition|)
return|return
name|false
return|;
comment|/* We must mark the file once-only if #import now, before header      guard checks.  Otherwise, undefining the header guard might      cause the file to be re-stacked.  */
if|if
condition|(
name|import
condition|)
block|{
name|_cpp_mark_file_once_only
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Don't stack files that have been stacked before.  */
if|if
condition|(
name|file
operator|->
name|stack_count
condition|)
return|return
name|false
return|;
block|}
comment|/* Skip if the file had a header guard and the macro is defined.      PCH relies on this appearing before the PCH handler below.  */
if|if
condition|(
name|file
operator|->
name|cmacro
operator|&&
name|file
operator|->
name|cmacro
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
return|return
name|false
return|;
comment|/* Handle PCH files immediately; don't stack them.  */
if|if
condition|(
name|file
operator|->
name|pch
condition|)
block|{
name|pfile
operator|->
name|cb
operator|.
name|read_pch
argument_list|(
name|pfile
argument_list|,
name|file
operator|->
name|pchname
argument_list|,
name|file
operator|->
name|fd
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|read_file
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Check the file against the PCH file.  This is done before      checking against files we've already seen, since it may save on      I/O.  */
if|if
condition|(
name|check_file_against_entries
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|import
argument_list|)
condition|)
block|{
comment|/* If this isn't a #import, but yet we can't include the file, 	 that means that it was #import-ed in the PCH file, 	 so we can never include it again.  */
if|if
condition|(
operator|!
name|import
condition|)
name|_cpp_mark_file_once_only
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Now we've read the file's contents, we can stack it if there      are no once-only files.  */
if|if
condition|(
operator|!
name|pfile
operator|->
name|seen_once_only
condition|)
return|return
name|true
return|;
comment|/* We may have read the file under a different name.  Look      for likely candidates and compare file contents to be sure.  */
for|for
control|(
name|f
operator|=
name|pfile
operator|->
name|all_files
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|f
operator|==
name|file
condition|)
continue|continue;
if|if
condition|(
operator|(
name|import
operator|||
name|f
operator|->
name|once_only
operator|)
operator|&&
name|f
operator|->
name|err_no
operator|==
literal|0
operator|&&
name|f
operator|->
name|st
operator|.
name|st_mtime
operator|==
name|file
operator|->
name|st
operator|.
name|st_mtime
operator|&&
name|f
operator|->
name|st
operator|.
name|st_size
operator|==
name|file
operator|->
name|st
operator|.
name|st_size
condition|)
block|{
name|_cpp_file
modifier|*
name|ref_file
decl_stmt|;
name|bool
name|same_file_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|buffer
operator|&&
operator|!
name|f
operator|->
name|buffer_valid
condition|)
block|{
comment|/* We already have a buffer but it is not valid, because 		 the file is still stacked.  Make a new one.  */
name|ref_file
operator|=
name|make_cpp_file
argument_list|(
name|pfile
argument_list|,
name|f
operator|->
name|dir
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|ref_file
operator|->
name|path
operator|=
name|f
operator|->
name|path
expr_stmt|;
block|}
else|else
comment|/* The file is not stacked anymore.  We can reuse it.  */
name|ref_file
operator|=
name|f
expr_stmt|;
name|same_file_p
operator|=
name|read_file
argument_list|(
name|pfile
argument_list|,
name|ref_file
argument_list|)
comment|/* Size might have changed in read_file().  */
operator|&&
name|ref_file
operator|->
name|st
operator|.
name|st_size
operator|==
name|file
operator|->
name|st
operator|.
name|st_size
operator|&&
operator|!
name|memcmp
argument_list|(
name|ref_file
operator|->
name|buffer
argument_list|,
name|file
operator|->
name|buffer
argument_list|,
name|file
operator|->
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|buffer
operator|&&
operator|!
name|f
operator|->
name|buffer_valid
condition|)
block|{
name|ref_file
operator|->
name|path
operator|=
literal|0
expr_stmt|;
name|destroy_cpp_file
argument_list|(
name|ref_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_file_p
condition|)
break|break;
block|}
block|}
return|return
name|f
operator|==
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Place the file referenced by FILE into a new buffer on the buffer    stack if possible.  IMPORT is true if this stacking attempt is    because of a #import directive.  Returns true if a buffer is    stacked.  */
end_comment

begin_function
name|bool
name|_cpp_stack_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|bool
name|import
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|sysp
decl_stmt|;
if|if
condition|(
operator|!
name|should_stack_file
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|import
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|==
name|NULL
operator|||
name|file
operator|->
name|dir
operator|==
name|NULL
condition|)
name|sysp
operator|=
literal|0
expr_stmt|;
else|else
name|sysp
operator|=
name|MAX
argument_list|(
name|pfile
operator|->
name|buffer
operator|->
name|sysp
argument_list|,
name|file
operator|->
name|dir
operator|->
name|sysp
argument_list|)
expr_stmt|;
comment|/* Add the file to the dependencies on its first inclusion.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|>
operator|!
operator|!
name|sysp
operator|&&
operator|!
name|file
operator|->
name|stack_count
condition|)
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|main_file
operator|||
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|ignore_main_file
argument_list|)
condition|)
name|deps_add_dep
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* Clear buffer_valid since _cpp_clean_line messes it up.  */
name|file
operator|->
name|buffer_valid
operator|=
name|false
expr_stmt|;
name|file
operator|->
name|stack_count
operator|++
expr_stmt|;
comment|/* Stack the buffer.  */
name|buffer
operator|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|file
operator|->
name|buffer
argument_list|,
name|file
operator|->
name|st
operator|.
name|st_size
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|directives_only
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|buffer
operator|->
name|sysp
operator|=
name|sysp
expr_stmt|;
comment|/* Initialize controlling macro state.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
comment|/* Generate the call back.  */
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_ENTER
argument_list|,
name|file
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|sysp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Mark FILE to be included once only.  */
end_comment

begin_function
name|void
name|_cpp_mark_file_once_only
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
name|pfile
operator|->
name|seen_once_only
operator|=
name|true
expr_stmt|;
name|file
operator|->
name|once_only
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the directory from which searching for FNAME should start,    considering the directive TYPE and ANGLE_BRACKETS.  If there is    nothing left in the path, returns NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|cpp_dir
modifier|*
name|search_path_head
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|angle_brackets
parameter_list|,
name|enum
name|include_type
name|type
parameter_list|)
block|{
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
name|_cpp_file
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|fname
argument_list|)
condition|)
return|return
operator|&
name|pfile
operator|->
name|no_search_path
return|;
comment|/* pfile->buffer is NULL when processing an -include command-line flag.  */
name|file
operator|=
name|pfile
operator|->
name|buffer
operator|==
name|NULL
condition|?
name|pfile
operator|->
name|main_file
else|:
name|pfile
operator|->
name|buffer
operator|->
name|file
expr_stmt|;
comment|/* For #include_next, skip in the search path past the dir in which      the current file was found, but if it was found via an absolute      path use the normal search logic.  */
if|if
condition|(
name|type
operator|==
name|IT_INCLUDE_NEXT
operator|&&
name|file
operator|->
name|dir
condition|)
name|dir
operator|=
name|file
operator|->
name|dir
operator|->
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|angle_brackets
condition|)
name|dir
operator|=
name|pfile
operator|->
name|bracket_include
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|IT_CMDLINE
condition|)
comment|/* -include and -imacros use the #include "" chain with the        preprocessor's cwd prepended.  */
return|return
name|make_cpp_dir
argument_list|(
name|pfile
argument_list|,
literal|"./"
argument_list|,
name|false
argument_list|)
return|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|quote_ignores_source_dir
condition|)
name|dir
operator|=
name|pfile
operator|->
name|quote_include
expr_stmt|;
else|else
return|return
name|make_cpp_dir
argument_list|(
name|pfile
argument_list|,
name|dir_name_of_file
argument_list|(
name|file
argument_list|)
argument_list|,
name|pfile
operator|->
name|buffer
condition|?
name|pfile
operator|->
name|buffer
operator|->
name|sysp
else|:
literal|0
argument_list|)
return|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"no include path in which to search for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

begin_comment
comment|/* Strip the basename from the file's path.  It ends with a slash if    of nonzero length.  Note that this procedure also works for<stdin>, which is represented by the empty string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dir_name_of_file
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|dir_name
condition|)
block|{
name|size_t
name|len
init|=
name|lbasename
argument_list|(
name|file
operator|->
name|path
argument_list|)
operator|-
name|file
operator|->
name|path
decl_stmt|;
name|char
modifier|*
name|dir_name
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dir_name
argument_list|,
name|file
operator|->
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dir_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|file
operator|->
name|dir_name
operator|=
name|dir_name
expr_stmt|;
block|}
return|return
name|file
operator|->
name|dir_name
return|;
block|}
end_function

begin_comment
comment|/* Handles #include-family directives (distinguished by TYPE),    including HEADER, and the command line -imacros and -include.    Returns true if a buffer was stacked.  */
end_comment

begin_function
name|bool
name|_cpp_stack_include
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|angle_brackets
parameter_list|,
name|enum
name|include_type
name|type
parameter_list|)
block|{
name|struct
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
name|_cpp_file
modifier|*
name|file
decl_stmt|;
name|dir
operator|=
name|search_path_head
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|angle_brackets
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
name|false
return|;
name|file
operator|=
name|_cpp_find_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|dir
argument_list|,
name|false
argument_list|,
name|angle_brackets
argument_list|)
expr_stmt|;
comment|/* Compensate for the increment in linemap_add.  In the case of a      normal #include, we're currently at the start of the line      *following* the #include.  A separate source_location for this      location makes no sense (until we do the LC_LEAVE), and      complicates LAST_SOURCE_LINE_LOCATION.  This does not apply if we      found a PCH file (in which case linemap_add is not called) or we      were included from the command-line.  */
if|if
condition|(
operator|!
name|file
operator|->
name|pch
operator|&&
name|file
operator|->
name|err_no
operator|==
literal|0
operator|&&
name|type
operator|!=
name|IT_CMDLINE
condition|)
name|pfile
operator|->
name|line_table
operator|->
name|highest_location
operator|--
expr_stmt|;
return|return
name|_cpp_stack_file
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|type
operator|==
name|IT_IMPORT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Could not open FILE.  The complication is dependency output.  */
end_comment

begin_function
specifier|static
name|void
name|open_file_failed
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
name|int
name|angle_brackets
parameter_list|)
block|{
name|int
name|sysp
init|=
name|pfile
operator|->
name|line_table
operator|->
name|highest_line
operator|>
literal|1
operator|&&
name|pfile
operator|->
name|buffer
condition|?
name|pfile
operator|->
name|buffer
operator|->
name|sysp
else|:
literal|0
decl_stmt|;
name|bool
name|print_dep
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|>
operator|(
name|angle_brackets
operator|||
operator|!
operator|!
name|sysp
operator|)
decl_stmt|;
name|errno
operator|=
name|file
operator|->
name|err_no
expr_stmt|;
if|if
condition|(
name|print_dep
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|missing_files
argument_list|)
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|deps_add_dep
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we are outputting dependencies but not for this file then 	 don't error because we can still produce correct output.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|deps
operator|.
name|style
argument_list|)
operator|&&
operator|!
name|print_dep
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Search in the chain beginning at HEAD for a file whose search path    started at START_DIR != NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|search_cache
parameter_list|(
name|struct
name|file_hash_entry
modifier|*
name|head
parameter_list|,
specifier|const
name|cpp_dir
modifier|*
name|start_dir
parameter_list|)
block|{
while|while
condition|(
name|head
operator|&&
name|head
operator|->
name|start_dir
operator|!=
name|start_dir
condition|)
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new _cpp_file structure.  */
end_comment

begin_function
specifier|static
name|_cpp_file
modifier|*
name|make_cpp_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_dir
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|_cpp_file
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|XCNEW
argument_list|(
name|_cpp_file
argument_list|)
expr_stmt|;
name|file
operator|->
name|main_file
operator|=
operator|!
name|pfile
operator|->
name|buffer
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|file
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|file
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_comment
comment|/* Release a _cpp_file structure.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_cpp_file
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|buffer
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|file
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A hash of directory names.  The directory names are the path names    of files which contain a #include "", the included file name is    appended to this directories.     To avoid duplicate entries we follow the convention that all    non-empty directory names should end in a '/'.  DIR_NAME must be    stored in permanently allocated memory.  */
end_comment

begin_function
specifier|static
name|cpp_dir
modifier|*
name|make_cpp_dir
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_name
parameter_list|,
name|int
name|sysp
parameter_list|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|hash_slot
decl_stmt|;
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
name|hash_slot
operator|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|pfile
operator|->
name|dir_hash
argument_list|,
name|dir_name
argument_list|,
name|htab_hash_string
argument_list|(
name|dir_name
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* Have we already hashed this directory?  */
for|for
control|(
name|entry
operator|=
operator|*
name|hash_slot
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
if|if
condition|(
name|entry
operator|->
name|start_dir
operator|==
name|NULL
condition|)
return|return
name|entry
operator|->
name|u
operator|.
name|dir
return|;
name|dir
operator|=
name|XCNEW
argument_list|(
name|cpp_dir
argument_list|)
expr_stmt|;
name|dir
operator|->
name|next
operator|=
name|pfile
operator|->
name|quote_include
expr_stmt|;
name|dir
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|dir_name
expr_stmt|;
name|dir
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|dir
operator|->
name|sysp
operator|=
name|sysp
expr_stmt|;
name|dir
operator|->
name|construct
operator|=
literal|0
expr_stmt|;
comment|/* Store this new result in the hash table.  */
name|entry
operator|=
name|new_file_hash_entry
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|hash_slot
expr_stmt|;
name|entry
operator|->
name|start_dir
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
operator|*
name|hash_slot
operator|=
name|entry
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

begin_comment
comment|/* Create a new block of memory for file hash entries.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_file_hash_entries
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|pfile
operator|->
name|file_hash_entries_used
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|file_hash_entries_allocated
operator|=
literal|127
expr_stmt|;
name|pfile
operator|->
name|file_hash_entries
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|file_hash_entry
argument_list|,
name|pfile
operator|->
name|file_hash_entries_allocated
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new file hash entry.  */
end_comment

begin_function
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|new_file_hash_entry
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
if|if
condition|(
name|pfile
operator|->
name|file_hash_entries_used
operator|==
name|pfile
operator|->
name|file_hash_entries_allocated
condition|)
name|allocate_file_hash_entries
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
operator|&
name|pfile
operator|->
name|file_hash_entries
index|[
name|pfile
operator|->
name|file_hash_entries_used
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if a file FNAME has ever been successfully opened.    This routine is not intended to correctly handle filenames aliased    by links or redundant . or .. traversals etc.  */
end_comment

begin_function
name|bool
name|cpp_included
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|pfile
operator|->
name|file_hash
argument_list|,
name|fname
argument_list|,
name|htab_hash_string
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|&&
operator|(
name|entry
operator|->
name|start_dir
operator|==
name|NULL
operator|||
name|entry
operator|->
name|u
operator|.
name|file
operator|->
name|err_no
operator|)
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
return|return
name|entry
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Calculate the hash value of a file hash entry P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|file_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|hname
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|start_dir
condition|)
name|hname
operator|=
name|entry
operator|->
name|u
operator|.
name|file
operator|->
name|name
expr_stmt|;
else|else
name|hname
operator|=
name|entry
operator|->
name|u
operator|.
name|dir
operator|->
name|name
expr_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|hname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare a string Q against a file hash entry P.  */
end_comment

begin_function
specifier|static
name|int
name|file_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|hname
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|start_dir
condition|)
name|hname
operator|=
name|entry
operator|->
name|u
operator|.
name|file
operator|->
name|name
expr_stmt|;
else|else
name|hname
operator|=
name|entry
operator|->
name|u
operator|.
name|dir
operator|->
name|name
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|hname
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare entries in the nonexistent file hash table.  These are just    strings.  */
end_comment

begin_function
specifier|static
name|int
name|nonexistent_file_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize everything in this source file.  */
end_comment

begin_function
name|void
name|_cpp_init_files
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|pfile
operator|->
name|file_hash
operator|=
name|htab_create_alloc
argument_list|(
literal|127
argument_list|,
name|file_hash_hash
argument_list|,
name|file_hash_eq
argument_list|,
name|NULL
argument_list|,
name|xcalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|dir_hash
operator|=
name|htab_create_alloc
argument_list|(
literal|127
argument_list|,
name|file_hash_hash
argument_list|,
name|file_hash_eq
argument_list|,
name|NULL
argument_list|,
name|xcalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|allocate_file_hash_entries
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|nonexistent_file_hash
operator|=
name|htab_create_alloc
argument_list|(
literal|127
argument_list|,
name|htab_hash_string
argument_list|,
name|nonexistent_file_hash_eq
argument_list|,
name|NULL
argument_list|,
name|xcalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|_obstack_begin
argument_list|(
operator|&
name|pfile
operator|->
name|nonexistent_file_ob
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|long
argument_list|)
operator|)
name|xmalloc
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize everything in this source file.  */
end_comment

begin_function
name|void
name|_cpp_cleanup_files
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|pfile
operator|->
name|file_hash
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|pfile
operator|->
name|dir_hash
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|pfile
operator|->
name|nonexistent_file_hash
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|nonexistent_file_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a file name in the hash for the sake of cpp_included.  */
end_comment

begin_function
name|void
name|_cpp_fake_include
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|_cpp_find_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|pfile
operator|->
name|buffer
operator|->
name|file
operator|->
name|dir
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not everyone who wants to set system-header-ness on a buffer can    see the details of a buffer.  This is an exported interface because    fix-header needs it.  */
end_comment

begin_function
name|void
name|cpp_make_system_header
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|syshdr
parameter_list|,
name|int
name|externc
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|line_maps
modifier|*
name|line_table
init|=
name|pfile
operator|->
name|line_table
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
init|=
operator|&
name|line_table
operator|->
name|maps
index|[
name|line_table
operator|->
name|used
operator|-
literal|1
index|]
decl_stmt|;
comment|/* 1 = system header, 2 = system header to be treated as C.  */
if|if
condition|(
name|syshdr
condition|)
name|flags
operator|=
literal|1
operator|+
operator|(
name|externc
operator|!=
literal|0
operator|)
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|sysp
operator|=
name|flags
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|pfile
operator|->
name|line_table
operator|->
name|highest_line
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allow the client to change the current file.  Used by the front end    to achieve pseudo-file names like<built-in>.    If REASON is LC_LEAVE, then NEW_NAME must be NULL.  */
end_comment

begin_function
name|void
name|cpp_change_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|enum
name|lc_reason
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|)
block|{
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|reason
argument_list|,
name|new_name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback function for htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|report_missing_guard
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|int
modifier|*
name|bannerp
init|=
operator|(
name|int
operator|*
operator|)
name|b
decl_stmt|;
comment|/* Skip directories.  */
if|if
condition|(
name|entry
operator|->
name|start_dir
operator|!=
name|NULL
condition|)
block|{
name|_cpp_file
modifier|*
name|file
init|=
name|entry
operator|->
name|u
operator|.
name|file
decl_stmt|;
comment|/* We don't want MI guard advice for the main file.  */
if|if
condition|(
name|file
operator|->
name|cmacro
operator|==
name|NULL
operator|&&
name|file
operator|->
name|stack_count
operator|==
literal|1
operator|&&
operator|!
name|file
operator|->
name|main_file
condition|)
block|{
if|if
condition|(
operator|*
name|bannerp
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"Multiple include guards may be useful for:\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|*
name|bannerp
operator|=
literal|1
expr_stmt|;
block|}
name|fputs
argument_list|(
name|entry
operator|->
name|u
operator|.
name|file
operator|->
name|path
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Report on all files that might benefit from a multiple include guard.    Triggered by -H.  */
end_comment

begin_function
name|void
name|_cpp_report_missing_guards
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|banner
init|=
literal|0
decl_stmt|;
name|htab_traverse
argument_list|(
name|pfile
operator|->
name|file_hash
argument_list|,
name|report_missing_guard
argument_list|,
operator|&
name|banner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate HEADER, and determine whether it is newer than the current    file.  If it cannot be located or dated, return -1, if it is    newer, return 1, otherwise 0.  */
end_comment

begin_function
name|int
name|_cpp_compare_file_date
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|angle_brackets
parameter_list|)
block|{
name|_cpp_file
modifier|*
name|file
decl_stmt|;
name|struct
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|search_path_head
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|angle_brackets
argument_list|,
name|IT_INCLUDE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
operator|-
literal|1
return|;
name|file
operator|=
name|_cpp_find_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|dir
argument_list|,
name|false
argument_list|,
name|angle_brackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|err_no
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|file
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|file
operator|->
name|st
operator|.
name|st_mtime
operator|>
name|pfile
operator|->
name|buffer
operator|->
name|file
operator|->
name|st
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* Pushes the given file onto the buffer stack.  Returns nonzero if    successful.  */
end_comment

begin_function
name|bool
name|cpp_push_include
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
return|return
name|_cpp_stack_include
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|false
argument_list|,
name|IT_CMDLINE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do appropriate cleanup when a file INC's buffer is popped off the    input stack.  */
end_comment

begin_function
name|void
name|_cpp_pop_file_buffer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
comment|/* Record the inclusion-preventing macro, which could be NULL      meaning no controlling macro.  */
if|if
condition|(
name|pfile
operator|->
name|mi_valid
operator|&&
name|file
operator|->
name|cmacro
operator|==
name|NULL
condition|)
name|file
operator|->
name|cmacro
operator|=
name|pfile
operator|->
name|mi_cmacro
expr_stmt|;
comment|/* Invalidate control macros in the #including file.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|buffer
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|file
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|file
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|buffer_valid
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Inteface to file statistics record in _cpp_file structure. */
end_comment

begin_function
name|struct
name|stat
modifier|*
name|_cpp_get_file_stat
parameter_list|(
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
return|return
operator|&
name|file
operator|->
name|st
return|;
block|}
end_function

begin_comment
comment|/* Set the include chain for "" to QUOTE, for<> to BRACKET.  If    QUOTE_IGNORES_SOURCE_DIR, then "" includes do not look in the    directory of the including file.     If BRACKET does not lie in the QUOTE chain, it is set to QUOTE.  */
end_comment

begin_function
name|void
name|cpp_set_include_chains
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_dir
modifier|*
name|quote
parameter_list|,
name|cpp_dir
modifier|*
name|bracket
parameter_list|,
name|int
name|quote_ignores_source_dir
parameter_list|)
block|{
name|pfile
operator|->
name|quote_include
operator|=
name|quote
expr_stmt|;
name|pfile
operator|->
name|bracket_include
operator|=
name|quote
expr_stmt|;
name|pfile
operator|->
name|quote_ignores_source_dir
operator|=
name|quote_ignores_source_dir
expr_stmt|;
for|for
control|(
init|;
name|quote
condition|;
name|quote
operator|=
name|quote
operator|->
name|next
control|)
block|{
name|quote
operator|->
name|name_map
operator|=
name|NULL
expr_stmt|;
name|quote
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|quote
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
operator|==
name|bracket
condition|)
name|pfile
operator|->
name|bracket_include
operator|=
name|bracket
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append the file name to the directory to create the path, but don't    turn / into // or // into ///; // may be a namespace escape.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|append_file_to_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|cpp_dir
modifier|*
name|dir
parameter_list|)
block|{
name|size_t
name|dlen
decl_stmt|,
name|flen
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|dlen
operator|=
name|dir
operator|->
name|len
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|path
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|dlen
operator|+
literal|1
operator|+
name|flen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|&&
name|path
index|[
name|dlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|path
index|[
name|dlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|path
index|[
name|dlen
index|]
argument_list|,
name|fname
argument_list|,
name|flen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file F.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|int
name|ch
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_space
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|XRESIZEVEC
argument_list|(
name|char
argument_list|,
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* Read the file name map file for DIR.  */
end_comment

begin_function
specifier|static
name|void
name|read_name_map
parameter_list|(
name|cpp_dir
modifier|*
name|dir
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|FILE_NAME_MAP_FILE
index|[]
init|=
literal|"header.gcc"
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|room
init|=
literal|9
decl_stmt|;
name|len
operator|=
name|dir
operator|->
name|len
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|name
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
name|len
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|dir
operator|->
name|name_map
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|room
argument_list|)
expr_stmt|;
comment|/* Silently return NULL if we cannot open.  */
if|if
condition|(
name|f
condition|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|to
decl_stmt|;
if|if
condition|(
name|is_space
argument_list|(
name|ch
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|count
operator|+
literal|2
operator|>
name|room
condition|)
block|{
name|room
operator|+=
literal|8
expr_stmt|;
name|dir
operator|->
name|name_map
operator|=
name|XRESIZEVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|dir
operator|->
name|name_map
argument_list|,
name|room
argument_list|)
expr_stmt|;
block|}
name|dir
operator|->
name|name_map
index|[
name|count
index|]
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|is_hspace
argument_list|(
name|ch
argument_list|)
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|to
argument_list|)
condition|)
name|dir
operator|->
name|name_map
index|[
name|count
operator|+
literal|1
index|]
operator|=
name|to
expr_stmt|;
else|else
block|{
name|dir
operator|->
name|name_map
index|[
name|count
operator|+
literal|1
index|]
operator|=
name|append_file_to_dir
argument_list|(
name|to
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|count
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the list of maps.  */
name|dir
operator|->
name|name_map
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remap a FILE's name based on the file_name_map, if any, for    FILE->dir.  If the file name has any directory separators,    recursively check those directories too.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remap_filename
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|new_dir
decl_stmt|;
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
name|size_t
name|index
decl_stmt|,
name|len
decl_stmt|;
name|dir
operator|=
name|file
operator|->
name|dir
expr_stmt|;
name|fname
operator|=
name|file
operator|->
name|name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|dir
operator|->
name|name_map
condition|)
name|read_name_map
argument_list|(
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|dir
operator|->
name|name_map
index|[
name|index
index|]
condition|;
name|index
operator|+=
literal|2
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dir
operator|->
name|name_map
index|[
name|index
index|]
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
name|dir
operator|->
name|name_map
index|[
name|index
operator|+
literal|1
index|]
argument_list|)
return|;
name|p
operator|=
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|p
operator|==
name|fname
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|dir
operator|->
name|len
operator|+
operator|(
name|p
operator|-
name|fname
operator|+
literal|1
operator|)
expr_stmt|;
name|new_dir
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_dir
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_dir
operator|+
name|dir
operator|->
name|len
argument_list|,
name|fname
argument_list|,
name|p
operator|-
name|fname
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_dir
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dir
operator|=
name|make_cpp_dir
argument_list|(
name|pfile
argument_list|,
name|new_dir
argument_list|,
name|dir
operator|->
name|sysp
argument_list|)
expr_stmt|;
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if PCHNAME is a valid PCH file for FILE.  */
end_comment

begin_function
specifier|static
name|bool
name|validate_pch
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_file
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|pchname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|saved_path
init|=
name|file
operator|->
name|path
decl_stmt|;
name|bool
name|valid
init|=
name|false
decl_stmt|;
name|file
operator|->
name|path
operator|=
name|pchname
expr_stmt|;
if|if
condition|(
name|open_file
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|valid
operator|=
literal|1
operator|&
name|pfile
operator|->
name|cb
operator|.
name|valid_pch
argument_list|(
name|pfile
argument_list|,
name|pchname
argument_list|,
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|close
argument_list|(
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_include_names
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pfile
operator|->
name|line_table
operator|->
name|depth
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c %s\n"
argument_list|,
name|valid
condition|?
literal|'!'
else|:
literal|'x'
argument_list|,
name|pchname
argument_list|)
expr_stmt|;
block|}
block|}
name|file
operator|->
name|path
operator|=
name|saved_path
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/* Get the path associated with the _cpp_file F.  The path includes    the base name from the include directive and the directory it was    found in via the search path.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpp_get_path
parameter_list|(
name|struct
name|_cpp_file
modifier|*
name|f
parameter_list|)
block|{
return|return
name|f
operator|->
name|path
return|;
block|}
end_function

begin_comment
comment|/* Get the directory associated with the _cpp_file F.  */
end_comment

begin_function
name|cpp_dir
modifier|*
name|cpp_get_dir
parameter_list|(
name|struct
name|_cpp_file
modifier|*
name|f
parameter_list|)
block|{
return|return
name|f
operator|->
name|dir
return|;
block|}
end_function

begin_comment
comment|/* Get the cpp_buffer currently associated with the cpp_reader    PFILE.  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_get_buffer
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
return|return
name|pfile
operator|->
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Get the _cpp_file associated with the cpp_buffer B.  */
end_comment

begin_function
name|_cpp_file
modifier|*
name|cpp_get_file
parameter_list|(
name|cpp_buffer
modifier|*
name|b
parameter_list|)
block|{
return|return
name|b
operator|->
name|file
return|;
block|}
end_function

begin_comment
comment|/* Get the previous cpp_buffer given a cpp_buffer B.  The previous    buffer is the buffer that included the given buffer.  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_get_prev
parameter_list|(
name|cpp_buffer
modifier|*
name|b
parameter_list|)
block|{
return|return
name|b
operator|->
name|prev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This data structure holds the list of header files that were seen    while the PCH was being built.  The 'entries' field is kept sorted    in memcmp() order; yes, this means that on little-endian systems,    it's sorted initially by the least-significant byte of 'size', but    that's OK.  The code does rely on having entries with the same size    next to each other.  */
end_comment

begin_struct
struct|struct
name|pchf_entry
block|{
comment|/* The size of this file.  This is used to save running a MD5 checksum      if the sizes don't match.  */
name|off_t
name|size
decl_stmt|;
comment|/* The MD5 checksum of this file.  */
name|unsigned
name|char
name|sum
index|[
literal|16
index|]
decl_stmt|;
comment|/* Is this file to be included only once?  */
name|bool
name|once_only
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pchf_data
block|{
comment|/* Number of pchf_entry structures.  */
name|size_t
name|count
decl_stmt|;
comment|/* Are there any values with once_only set?      This is used as an optimisation, it means we don't have to search      the structure if we're processing a regular #include.  */
name|bool
name|have_once_only
decl_stmt|;
name|struct
name|pchf_entry
name|entries
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pchf_data
modifier|*
name|pchf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A qsort ordering function for pchf_entry structures.  */
end_comment

begin_function
specifier|static
name|int
name|pchf_save_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
return|return
name|memcmp
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create and write to F a pchf_data structure.  */
end_comment

begin_function
name|bool
name|_cpp_save_file_entries
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|pchf_data
modifier|*
name|result
decl_stmt|;
name|size_t
name|result_size
decl_stmt|;
name|_cpp_file
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|pfile
operator|->
name|all_files
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next_file
control|)
operator|++
name|count
expr_stmt|;
name|result_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
operator|*
operator|(
name|count
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|result
operator|=
name|XCNEWVAR
argument_list|(
expr|struct
name|pchf_data
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
name|result
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|have_once_only
operator|=
name|false
expr_stmt|;
for|for
control|(
name|f
operator|=
name|pfile
operator|->
name|all_files
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next_file
control|)
block|{
name|size_t
name|count
decl_stmt|;
comment|/* This should probably never happen, since if a read error occurred 	 the PCH file shouldn't be written...  */
if|if
condition|(
name|f
operator|->
name|dont_read
operator|||
name|f
operator|->
name|err_no
condition|)
continue|continue;
if|if
condition|(
name|f
operator|->
name|stack_count
operator|==
literal|0
condition|)
continue|continue;
name|count
operator|=
name|result
operator|->
name|count
operator|++
expr_stmt|;
name|result
operator|->
name|entries
index|[
name|count
index|]
operator|.
name|once_only
operator|=
name|f
operator|->
name|once_only
expr_stmt|;
comment|/* |= is avoided in the next line because of an HP C compiler bug */
name|result
operator|->
name|have_once_only
operator|=
name|result
operator|->
name|have_once_only
operator||
name|f
operator|->
name|once_only
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|buffer_valid
condition|)
name|md5_buffer
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|f
operator|->
name|buffer
argument_list|,
name|f
operator|->
name|st
operator|.
name|st_size
argument_list|,
name|result
operator|->
name|entries
index|[
name|count
index|]
operator|.
name|sum
argument_list|)
expr_stmt|;
else|else
block|{
name|FILE
modifier|*
name|ff
decl_stmt|;
name|int
name|oldfd
init|=
name|f
operator|->
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|open_file
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|open_file_failed
argument_list|(
name|pfile
argument_list|,
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ff
operator|=
name|fdopen
argument_list|(
name|f
operator|->
name|fd
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|md5_stream
argument_list|(
name|ff
argument_list|,
name|result
operator|->
name|entries
index|[
name|count
index|]
operator|.
name|sum
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ff
argument_list|)
expr_stmt|;
name|f
operator|->
name|fd
operator|=
name|oldfd
expr_stmt|;
block|}
name|result
operator|->
name|entries
index|[
name|count
index|]
operator|.
name|size
operator|=
name|f
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
block|}
name|result_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
operator|*
operator|(
name|result
operator|->
name|count
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|qsort
argument_list|(
name|result
operator|->
name|entries
argument_list|,
name|result
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
argument_list|,
name|pchf_save_compare
argument_list|)
expr_stmt|;
return|return
name|fwrite
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read the pchf_data structure from F.  */
end_comment

begin_function
name|bool
name|_cpp_read_file_entries
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|pchf_data
name|d
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
name|pchf
operator|=
name|XNEWVAR
argument_list|(
expr|struct
name|pchf_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
operator|*
operator|(
name|d
operator|.
name|count
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pchf
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|pchf
operator|->
name|entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
argument_list|,
name|d
operator|.
name|count
argument_list|,
name|f
argument_list|)
operator|!=
name|d
operator|.
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The parameters for pchf_compare.  */
end_comment

begin_struct
struct|struct
name|pchf_compare_data
block|{
comment|/* The size of the file we're looking for.  */
name|off_t
name|size
decl_stmt|;
comment|/* The MD5 checksum of the file, if it's been computed.  */
name|unsigned
name|char
name|sum
index|[
literal|16
index|]
decl_stmt|;
comment|/* Is SUM valid?  */
name|bool
name|sum_computed
decl_stmt|;
comment|/* Do we need to worry about entries that don't have ONCE_ONLY set?  */
name|bool
name|check_included
decl_stmt|;
comment|/* The file that we're searching for.  */
name|_cpp_file
modifier|*
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* bsearch comparison function; look for D_P in E_P.  */
end_comment

begin_function
specifier|static
name|int
name|pchf_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|d_p
parameter_list|,
specifier|const
name|void
modifier|*
name|e_p
parameter_list|)
block|{
specifier|const
name|struct
name|pchf_entry
modifier|*
name|e
init|=
operator|(
specifier|const
expr|struct
name|pchf_entry
operator|*
operator|)
name|e_p
decl_stmt|;
name|struct
name|pchf_compare_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|pchf_compare_data
operator|*
operator|)
name|d_p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|memcmp
argument_list|(
operator|&
name|d
operator|->
name|size
argument_list|,
operator|&
name|e
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|sum_computed
condition|)
block|{
name|_cpp_file
modifier|*
specifier|const
name|f
init|=
name|d
operator|->
name|f
decl_stmt|;
name|md5_buffer
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|f
operator|->
name|buffer
argument_list|,
name|f
operator|->
name|st
operator|.
name|st_size
argument_list|,
name|d
operator|->
name|sum
argument_list|)
expr_stmt|;
name|d
operator|->
name|sum_computed
operator|=
name|true
expr_stmt|;
block|}
name|result
operator|=
name|memcmp
argument_list|(
name|d
operator|->
name|sum
argument_list|,
name|e
operator|->
name|sum
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|d
operator|->
name|check_included
operator|||
name|e
operator|->
name|once_only
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check that F is not in a list read from a PCH file (if any).    Assumes that f->buffer_valid is true.  Return TRUE if the file    should not be read.  */
end_comment

begin_function
specifier|static
name|bool
name|check_file_against_entries
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|_cpp_file
modifier|*
name|f
parameter_list|,
name|bool
name|check_included
parameter_list|)
block|{
name|struct
name|pchf_compare_data
name|d
decl_stmt|;
if|if
condition|(
name|pchf
operator|==
name|NULL
operator|||
operator|(
operator|!
name|check_included
operator|&&
operator|!
name|pchf
operator|->
name|have_once_only
operator|)
condition|)
return|return
name|false
return|;
name|d
operator|.
name|size
operator|=
name|f
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
name|d
operator|.
name|sum_computed
operator|=
name|false
expr_stmt|;
name|d
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|d
operator|.
name|check_included
operator|=
name|check_included
expr_stmt|;
return|return
name|bsearch
argument_list|(
operator|&
name|d
argument_list|,
name|pchf
operator|->
name|entries
argument_list|,
name|pchf
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pchf_entry
argument_list|)
argument_list|,
name|pchf_compare
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

end_unit

