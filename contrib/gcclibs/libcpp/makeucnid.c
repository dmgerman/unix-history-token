begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Make ucnid.h from various sources.    Copyright (C) 2005 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Run this program as    ./makeucnid ucnid.tab UnicodeData.txt DerivedNormalizationProps.txt \> ucnid.h */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_enum
enum|enum
block|{
name|C99
init|=
literal|1
block|,
name|CXX
init|=
literal|2
block|,
name|digit
init|=
literal|4
block|,
name|not_NFC
init|=
literal|8
block|,
name|not_NFKC
init|=
literal|16
block|,
name|maybe_not_NFC
init|=
literal|32
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|unsigned
name|flags
index|[
literal|65536
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|decomp
index|[
literal|65536
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|combining_value
index|[
literal|65536
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Die!  */
end_comment

begin_function
specifier|static
name|void
name|fail
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read ucnid.tab and set the C99 and CXX flags in header[].  */
end_comment

begin_function
specifier|static
name|void
name|read_ucnid
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|unsigned
name|fl
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|fail
argument_list|(
literal|"opening ucnid.tab"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"[C99]\n"
argument_list|)
operator|==
literal|0
condition|)
name|fl
operator|=
name|C99
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"[CXX]\n"
argument_list|)
operator|==
literal|0
condition|)
name|fl
operator|=
name|CXX
expr_stmt|;
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
while|while
condition|(
operator|*
name|l
condition|)
block|{
name|unsigned
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|start
operator|=
name|strtoul
argument_list|(
name|l
argument_list|,
operator|&
name|endptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|endptr
operator|==
name|l
operator|||
operator|(
operator|*
name|endptr
operator|!=
literal|'-'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|endptr
argument_list|)
operator|)
condition|)
name|fail
argument_list|(
literal|"parsing ucnid.tab [1]"
argument_list|)
expr_stmt|;
name|l
operator|=
name|endptr
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|!=
literal|'-'
condition|)
name|end
operator|=
name|start
expr_stmt|;
else|else
block|{
name|end
operator|=
name|strtoul
argument_list|(
name|l
operator|+
literal|1
argument_list|,
operator|&
name|endptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|fail
argument_list|(
literal|"parsing ucnid.tab, end before start"
argument_list|)
expr_stmt|;
name|l
operator|=
name|endptr
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|fail
argument_list|(
literal|"parsing ucnid.tab, junk after range"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
if|if
condition|(
name|end
operator|>
literal|0xFFFF
condition|)
name|fail
argument_list|(
literal|"parsing ucnid.tab, end too large"
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
name|flags
index|[
name|start
operator|++
index|]
operator||=
name|fl
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fail
argument_list|(
literal|"reading ucnid.tab"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read UnicodeData.txt and set the 'digit' flag, and    also fill in the 'decomp' table to be the decompositions of    characters for which both the character decomposed and all the code    points in the decomposition are either C99 or CXX.  */
end_comment

begin_function
specifier|static
name|void
name|read_table
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|fail
argument_list|(
literal|"opening UnicodeData.txt"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|long
name|codepoint
decl_stmt|,
name|this_decomp
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|decomp_useful
decl_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
break|break;
name|codepoint
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
operator|&
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|line
operator|||
operator|*
name|l
operator|!=
literal|';'
condition|)
name|fail
argument_list|(
literal|"parsing UnicodeData.txt, reading code point"
argument_list|)
expr_stmt|;
if|if
condition|(
name|codepoint
operator|>
literal|0xffff
operator|||
operator|!
operator|(
name|flags
index|[
name|codepoint
index|]
operator|&
operator|(
name|C99
operator||
name|CXX
operator|)
operator|)
condition|)
continue|continue;
do|do
block|{
name|l
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|l
operator|!=
literal|';'
condition|)
do|;
comment|/* Category value; things starting with 'N' are numbers of some 	 kind.  */
if|if
condition|(
operator|*
operator|++
name|l
operator|==
literal|'N'
condition|)
name|flags
index|[
name|codepoint
index|]
operator||=
name|digit
expr_stmt|;
do|do
block|{
name|l
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|l
operator|!=
literal|';'
condition|)
do|;
comment|/* Canonical combining class; in NFC/NFKC, they must be increasing 	 (or zero).  */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|++
name|l
argument_list|)
condition|)
name|fail
argument_list|(
literal|"parsing UnicodeData.txt, combining class not number"
argument_list|)
expr_stmt|;
name|combining_value
index|[
name|codepoint
index|]
operator|=
name|strtoul
argument_list|(
name|l
argument_list|,
operator|&
name|l
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|++
operator|!=
literal|';'
condition|)
name|fail
argument_list|(
literal|"parsing UnicodeData.txt, junk after combining class"
argument_list|)
expr_stmt|;
comment|/* Skip over bidi value.  */
do|do
block|{
name|l
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|l
operator|!=
literal|';'
condition|)
do|;
comment|/* Decomposition mapping.  */
name|decomp_useful
operator|=
name|flags
index|[
name|codepoint
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|l
operator|==
literal|'<'
condition|)
comment|/* Compatibility mapping. */
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
literal|';'
condition|)
break|break;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|fail
argument_list|(
literal|"parsing UnicodeData.txt, decomposition format"
argument_list|)
expr_stmt|;
name|this_decomp
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|l
argument_list|,
operator|&
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|decomp_useful
operator|&=
name|flags
index|[
name|this_decomp
index|[
name|i
index|]
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
comment|/* Decomposition too long.  */
name|fail
argument_list|(
literal|"parsing UnicodeData.txt, decomposition too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|decomp_useful
condition|)
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|decomp
index|[
name|codepoint
index|]
index|[
name|i
index|]
operator|=
name|this_decomp
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fail
argument_list|(
literal|"reading UnicodeData.txt"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read DerivedNormalizationProps.txt and set the flags that say whether    a character is in NFC, NFKC, or is context-dependent.  */
end_comment

begin_function
specifier|static
name|void
name|read_derived
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|fail
argument_list|(
literal|"opening DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|;
name|bool
name|not_NFC_p
decl_stmt|,
name|not_NFKC_p
decl_stmt|,
name|maybe_not_NFC_p
decl_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
break|break;
name|not_NFC_p
operator|=
operator|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"; NFC_QC; N"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|not_NFKC_p
operator|=
operator|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"; NFKC_QC; N"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|maybe_not_NFC_p
operator|=
operator|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"; NFC_QC; M"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|not_NFC_p
operator|&&
operator|!
name|not_NFKC_p
operator|&&
operator|!
name|maybe_not_NFC_p
condition|)
continue|continue;
name|start
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
operator|&
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|line
condition|)
name|fail
argument_list|(
literal|"parsing DerivedNormalizationProps.txt, reading start"
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
literal|0xffff
condition|)
continue|continue;
if|if
condition|(
operator|*
name|l
operator|==
literal|'.'
operator|&&
name|l
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|end
operator|=
name|strtoul
argument_list|(
name|l
operator|+
literal|2
argument_list|,
operator|&
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|end
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
name|flags
index|[
name|start
operator|++
index|]
operator||=
operator|(
operator|(
name|not_NFC_p
condition|?
name|not_NFC
else|:
literal|0
operator|)
operator||
operator|(
name|not_NFKC_p
condition|?
name|not_NFKC
else|:
literal|0
operator|)
operator||
operator|(
name|maybe_not_NFC_p
condition|?
name|maybe_not_NFC
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fail
argument_list|(
literal|"reading DerivedNormalizationProps.txt"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the table.    The table consists of two words per entry.  The first word is the flags    for the unicode code points up to and including the second word.  */
end_comment

begin_function
specifier|static
name|void
name|write_table
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|last_flag
init|=
name|flags
index|[
literal|0
index|]
decl_stmt|;
name|bool
name|really_safe
init|=
name|decomp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|0
decl_stmt|;
name|unsigned
name|char
name|last_combine
init|=
name|combining_value
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|65536
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
literal|65536
operator|||
operator|(
name|flags
index|[
name|i
index|]
operator|!=
name|last_flag
operator|&&
operator|(
operator|(
name|flags
index|[
name|i
index|]
operator||
name|last_flag
operator|)
operator|&
operator|(
name|C99
operator||
name|CXX
operator|)
operator|)
operator|)
operator|||
name|really_safe
operator|!=
operator|(
name|decomp
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|||
name|combining_value
index|[
name|i
index|]
operator|!=
name|last_combine
condition|)
block|{
name|printf
argument_list|(
literal|"{ %s|%s|%s|%s|%s|%s|%s, %3d, %#06x },\n"
argument_list|,
name|last_flag
operator|&
name|C99
condition|?
literal|"C99"
else|:
literal|"  0"
argument_list|,
name|last_flag
operator|&
name|digit
condition|?
literal|"DIG"
else|:
literal|"  0"
argument_list|,
name|last_flag
operator|&
name|CXX
condition|?
literal|"CXX"
else|:
literal|"  0"
argument_list|,
name|really_safe
condition|?
literal|"CID"
else|:
literal|"  0"
argument_list|,
name|last_flag
operator|&
name|not_NFC
condition|?
literal|"  0"
else|:
literal|"NFC"
argument_list|,
name|last_flag
operator|&
name|not_NFKC
condition|?
literal|"  0"
else|:
literal|"NKC"
argument_list|,
name|last_flag
operator|&
name|maybe_not_NFC
condition|?
literal|"CTX"
else|:
literal|"  0"
argument_list|,
name|combining_value
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last_flag
operator|=
name|flags
index|[
name|i
index|]
expr_stmt|;
name|last_combine
operator|=
name|combining_value
index|[
literal|0
index|]
expr_stmt|;
name|really_safe
operator|=
name|decomp
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out the huge copyright notice.  */
end_comment

begin_function
specifier|static
name|void
name|write_copyright
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"\ /* Unicode characters and various properties.\n\    Copyright (C) 2003, 2005 Free Software Foundation, Inc.\n\ \n\    This program is free software; you can redistribute it and/or modify it\n\    under the terms of the GNU General Public License as published by the\n\    Free Software Foundation; either version 2, or (at your option) any\n\    later version.\n\ \n\    This program is distributed in the hope that it will be useful,\n\    but WITHOUT ANY WARRANTY; without even the implied warranty of\n\    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\    GNU General Public License for more details.\n\ \n\    You should have received a copy of the GNU General Public License\n\    along with this program; if not, write to the Free Software\n\    Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\ \n\ \n\    Copyright (C) 1991-2005 Unicode, Inc.  All rights reserved.\n\    Distributed under the Terms of Use in\n\    http://www.unicode.org/copyright.html.\n\ \n\    Permission is hereby granted, free of charge, to any person\n\    obtaining a copy of the Unicode data files and any associated\n\    documentation (the \"Data Files\") or Unicode software and any\n\    associated documentation (the \"Software\") to deal in the Data Files\n\    or Software without restriction, including without limitation the\n\    rights to use, copy, modify, merge, publish, distribute, and/or\n\    sell copies of the Data Files or Software, and to permit persons to\n\    whom the Data Files or Software are furnished to do so, provided\n\    that (a) the above copyright notice(s) and this permission notice\n\    appear with all copies of the Data Files or Software, (b) both the\n\    above copyright notice(s) and this permission notice appear in\n\    associated documentation, and (c) there is clear notice in each\n\    modified Data File or in the Software as well as in the\n\    documentation associated with the Data File(s) or Software that the\n\    data or software has been modified.\n\ \n\    THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY\n\    OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n\    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\    NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE\n\    COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR\n\    ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY\n\    DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n\    WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n\    ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n\    OF THE DATA FILES OR SOFTWARE.\n\ \n\    Except as contained in this notice, the name of a copyright holder\n\    shall not be used in advertising or otherwise to promote the sale,\n\    use or other dealings in these Data Files or Software without prior\n\    written authorization of the copyright holder.  */\n"
decl_stmt|;
name|puts
argument_list|(
name|copyright
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main program.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
name|fail
argument_list|(
literal|"too few arguments to makeucn"
argument_list|)
expr_stmt|;
name|read_ucnid
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_table
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|read_derived
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|write_copyright
argument_list|()
expr_stmt|;
name|write_table
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

