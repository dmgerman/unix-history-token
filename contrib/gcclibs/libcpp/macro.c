begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (Macro and #define handling.)    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_typedef
typedef|typedef
name|struct
name|macro_arg
name|macro_arg
typedef|;
end_typedef

begin_struct
struct|struct
name|macro_arg
block|{
specifier|const
name|cpp_token
modifier|*
modifier|*
name|first
decl_stmt|;
comment|/* First token in unexpanded argument.  */
specifier|const
name|cpp_token
modifier|*
modifier|*
name|expanded
decl_stmt|;
comment|/* Macro-expanded argument.  */
specifier|const
name|cpp_token
modifier|*
name|stringified
decl_stmt|;
comment|/* Stringified argument.  */
name|unsigned
name|int
name|count
decl_stmt|;
comment|/* # of tokens in argument.  */
name|unsigned
name|int
name|expanded_count
decl_stmt|;
comment|/* # of tokens in expanded argument.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Macro expansion.  */
end_comment

begin_function_decl
specifier|static
name|int
name|enter_macro_context
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|builtin_macro
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_ptoken_context
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|_cpp_buff
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|_cpp_buff
modifier|*
name|collect_args
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_context
modifier|*
name|next_context
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|cpp_token
modifier|*
name|padding_token
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_arg
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|macro_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|cpp_token
modifier|*
name|new_string_token
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|uchar
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|cpp_token
modifier|*
name|stringify_arg
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|macro_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|paste_all_tokens
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|paste_tokens
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_args
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|,
name|macro_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|_cpp_buff
modifier|*
name|funlike_invocation_p
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|create_iso_definition
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* #define directive parsing and handling.  */
end_comment

begin_function_decl
specifier|static
name|cpp_token
modifier|*
name|alloc_expansion_token
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_token
modifier|*
name|lex_expansion_token
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|warn_of_redefinition
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
parameter_list|,
specifier|const
name|cpp_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|parse_params
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_macro
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_trad_stringification
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_macro
modifier|*
parameter_list|,
specifier|const
name|cpp_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Emits a warning if NODE is a macro defined in the main file that    has not been used.  */
end_comment

begin_function
name|int
name|_cpp_warn_if_unused_macro
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|v
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|cpp_macro
modifier|*
name|macro
init|=
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
if|if
condition|(
operator|!
name|macro
operator|->
name|used
operator|&&
name|MAIN_FILE_P
argument_list|(
name|linemap_lookup
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|macro
operator|->
name|line
argument_list|)
argument_list|)
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|macro
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"macro \"%s\" is not used"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Allocates and returns a CPP_STRING token, containing TEXT of length    LEN, after null-terminating it.  TEXT must be in permanent storage.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|new_string_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|unsigned
name|char
modifier|*
name|text
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|text
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_STRING
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|token
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function for builtin_macro.  Returns the text generated by    a builtin macro. */
end_comment

begin_function
specifier|const
name|uchar
modifier|*
name|_cpp_builtin_macro_text
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|number
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
condition|)
block|{
default|default:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"invalid built-in macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_TIMESTAMP
case|:
block|{
name|cpp_buffer
modifier|*
name|pbuffer
init|=
name|cpp_get_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbuffer
operator|->
name|timestamp
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize timestamp value of the assotiated file. */
name|struct
name|_cpp_file
modifier|*
name|file
init|=
name|cpp_get_file
argument_list|(
name|pbuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
comment|/* Generate __TIMESTAMP__ string, that represents  		   the date and time of the last modification  		   of the current source file. The string constant  		   looks like "Sun Sep 16 01:03:52 1973".  */
name|struct
name|tm
modifier|*
name|tb
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
modifier|*
name|st
init|=
name|_cpp_get_file_stat
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|st
condition|)
name|tb
operator|=
name|localtime
argument_list|(
operator|&
name|st
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|asctime
argument_list|(
name|tb
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'"'
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'"'
expr_stmt|;
name|pbuffer
operator|->
name|timestamp
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"could not determine file timestamp"
argument_list|)
expr_stmt|;
name|pbuffer
operator|->
name|timestamp
operator|=
literal|U"\"??? ??? ?? ??:??:?? ????\""
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|pbuffer
operator|->
name|timestamp
expr_stmt|;
block|}
break|break;
case|case
name|BT_FILE
case|:
case|case
name|BT_BASE_FILE
case|:
block|{
name|unsigned
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uchar
modifier|*
name|buf
decl_stmt|;
name|map
operator|=
name|linemap_lookup
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|pfile
operator|->
name|line_table
operator|->
name|highest_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
operator|==
name|BT_BASE_FILE
condition|)
while|while
condition|(
operator|!
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
condition|)
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|pfile
operator|->
name|line_table
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|name
operator|=
name|map
operator|->
name|to_file
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|*
literal|2
operator|+
literal|3
argument_list|)
expr_stmt|;
name|result
operator|=
name|buf
expr_stmt|;
operator|*
name|buf
operator|=
literal|'"'
expr_stmt|;
name|buf
operator|=
name|cpp_quote_string
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
name|BT_INCLUDE_LEVEL
case|:
comment|/* The line map depth counts the primary source as level 1, but 	 historically __INCLUDE_DEPTH__ has called the primary source 	 level 0.  */
name|number
operator|=
name|pfile
operator|->
name|line_table
operator|->
name|depth
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BT_SPECLINE
case|:
name|map
operator|=
operator|&
name|pfile
operator|->
name|line_table
operator|->
name|maps
index|[
name|pfile
operator|->
name|line_table
operator|->
name|used
operator|-
literal|1
index|]
expr_stmt|;
comment|/* If __LINE__ is embedded in a macro, it must expand to the 	 line of the macro's invocation, not its definition. 	 Otherwise things like assert() will not work properly.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|number
operator|=
name|pfile
operator|->
name|line_table
operator|->
name|highest_line
expr_stmt|;
else|else
name|number
operator|=
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|src_loc
expr_stmt|;
name|number
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
comment|/* __STDC__ has the value 1 under normal circumstances. 	 However, if (a) we are in a system header, (b) the option 	 stdc_0_in_system_headers is true (set by target config), and 	 (c) we are not in strictly conforming mode, then it has the 	 value 0.  (b) and (c) are already checked in cpp_init_builtins.  */
case|case
name|BT_STDC
case|:
if|if
condition|(
name|cpp_in_system_header
argument_list|(
name|pfile
argument_list|)
condition|)
name|number
operator|=
literal|0
expr_stmt|;
else|else
name|number
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BT_DATE
case|:
case|case
name|BT_TIME
case|:
if|if
condition|(
name|pfile
operator|->
name|date
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate __DATE__ and __TIME__ strings from permanent 	     storage.  We only do this once, and don't generate them 	     at init time, because time() and localtime() are very 	     slow on some systems.  */
name|time_t
name|tt
decl_stmt|;
name|struct
name|tm
modifier|*
name|tb
init|=
name|NULL
decl_stmt|;
comment|/* (time_t) -1 is a legitimate value for "number of seconds 	     since the Epoch", so we have to do a little dance to 	     distinguish that from a genuine error.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|tt
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|||
name|errno
operator|==
literal|0
condition|)
name|tb
operator|=
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|pfile
operator|->
name|date
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
literal|"\"Oct 11 1347\""
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfile
operator|->
name|date
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|tb
operator|->
name|tm_mon
index|]
argument_list|,
name|tb
operator|->
name|tm_mday
argument_list|,
name|tb
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|time
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
literal|"\"12:34:56\""
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfile
operator|->
name|time
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|tb
operator|->
name|tm_hour
argument_list|,
name|tb
operator|->
name|tm_min
argument_list|,
name|tb
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"could not determine date and time"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|date
operator|=
literal|U"\"??? ?? ????\""
expr_stmt|;
name|pfile
operator|->
name|time
operator|=
literal|U"\"??:??:??\""
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
operator|==
name|BT_DATE
condition|)
name|result
operator|=
name|pfile
operator|->
name|date
expr_stmt|;
else|else
name|result
operator|=
name|pfile
operator|->
name|time
expr_stmt|;
break|break;
case|case
name|BT_COUNTER
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|directives_only
argument_list|)
operator|&&
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"__COUNTER__ expanded inside directive with -fdirectives-only"
argument_list|)
expr_stmt|;
name|number
operator|=
name|pfile
operator|->
name|nextcounter
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
comment|/* 21 bytes holds all NUL-terminated unsigned 64-bit numbers.  */
name|result
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|,
literal|"%u"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert builtin macros like __FILE__ to a token and push it on the    context stack.  Also handles _Pragma, for which a new token may not    be created.  Returns 1 if it generates a new token context, 0 to    return the token to the caller.  */
end_comment

begin_function
specifier|static
name|int
name|builtin_macro
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
operator|==
name|BT_PRAGMA
condition|)
block|{
comment|/* Don't interpret _Pragma within directives.  The standard is          not clear on this, but to me this makes most sense.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
return|return
literal|0
return|;
name|_cpp_do__Pragma
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|buf
operator|=
name|_cpp_builtin_macro_text
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|len
operator|=
name|ustrlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
operator|(
name|uchar
operator|*
operator|)
name|nbuf
argument_list|,
name|len
argument_list|,
comment|/* from_stage3 */
name|true
argument_list|)
expr_stmt|;
name|_cpp_clean_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Set pfile->cur_token as required by _cpp_lex_direct.  */
name|pfile
operator|->
name|cur_token
operator|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|!=
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"invalid built-in macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copies SRC, of length LEN, to DEST, adding backslashes before all    backslashes and double quotes. DEST must be of sufficient size.    Returns a pointer to the end of the string.  */
end_comment

begin_function
name|uchar
modifier|*
name|cpp_quote_string
parameter_list|(
name|uchar
modifier|*
name|dest
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|uchar
name|c
init|=
operator|*
name|src
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Convert a token sequence ARG to a single string token according to    the rules of the ISO C #-operator.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|stringify_arg
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|macro_arg
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|escape_it
decl_stmt|,
name|backslash_count
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|<
literal|3
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|u_buff
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* Loop, reading in the argument's tokens.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|arg
operator|->
name|first
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
name|source
operator|=
name|token
operator|->
name|val
operator|.
name|source
expr_stmt|;
continue|continue;
block|}
name|escape_it
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CHAR
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WCHAR
operator|)
expr_stmt|;
comment|/* Room for each char being written in octal, initial space and 	 final quote and NUL.  */
name|len
operator|=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_it
condition|)
name|len
operator|*=
literal|4
expr_stmt|;
name|len
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|-
name|dest
argument_list|)
operator|<
name|len
condition|)
block|{
name|size_t
name|len_so_far
init|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
decl_stmt|;
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|u_buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|+
name|len_so_far
expr_stmt|;
block|}
comment|/* Leading white space?  */
if|if
condition|(
name|dest
operator|-
literal|1
operator|!=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
condition|)
block|{
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
name|source
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
operator|*
name|dest
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|escape_it
condition|)
block|{
name|_cpp_buff
modifier|*
name|buff
init|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|BUFF_FRONT
argument_list|(
name|buff
argument_list|)
decl_stmt|;
name|len
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|buf
argument_list|,
name|true
argument_list|)
operator|-
name|buf
expr_stmt|;
name|dest
operator|=
name|cpp_quote_string
argument_list|(
name|dest
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|dest
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OTHER
operator|&&
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
name|backslash_count
operator|++
expr_stmt|;
else|else
name|backslash_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore the final \ of invalid string literals.  */
if|if
condition|(
name|backslash_count
operator|&
literal|1
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"invalid string literal, ignoring final '\\'"
argument_list|)
expr_stmt|;
name|dest
operator|--
expr_stmt|;
block|}
comment|/* Commit the memory, including NUL, and return the token.  */
operator|*
name|dest
operator|++
operator|=
literal|'"'
expr_stmt|;
name|len
operator|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|=
name|dest
operator|+
literal|1
expr_stmt|;
return|return
name|new_string_token
argument_list|(
name|pfile
argument_list|,
name|dest
operator|-
name|len
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to paste two tokens.  On success, return nonzero.  In any    case, PLHS is updated to point to the pasted token, which is    guaranteed to not have the PASTE_LEFT flag set.  */
end_comment

begin_function
specifier|static
name|bool
name|paste_tokens
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
modifier|*
name|plhs
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|rhs
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|lhsend
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|lhs
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|lhs
operator|=
operator|*
name|plhs
expr_stmt|;
name|len
operator|=
name|cpp_token_len
argument_list|(
name|lhs
argument_list|)
operator|+
name|cpp_token_len
argument_list|(
name|rhs
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|end
operator|=
name|lhsend
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|lhs
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Avoid comment headers, since they are still processed in stage 3.      It is simpler to insert a space here, rather than modifying the      lexer to ignore comments in some circumstances.  Simply returning      false doesn't work, since we want to clear the PASTE_LEFT flag.  */
if|if
condition|(
name|lhs
operator|->
name|type
operator|==
name|CPP_DIV
operator|&&
name|rhs
operator|->
name|type
operator|!=
name|CPP_EQ
condition|)
operator|*
name|end
operator|++
operator|=
literal|' '
expr_stmt|;
name|end
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|rhs
argument_list|,
name|end
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'\n'
expr_stmt|;
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|,
comment|/* from_stage3 */
name|true
argument_list|)
expr_stmt|;
name|_cpp_clean_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Set pfile->cur_token as required by _cpp_lex_direct.  */
name|pfile
operator|->
name|cur_token
operator|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
operator|*
name|plhs
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|!=
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
condition|)
block|{
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|lhsend
operator|=
literal|'\0'
expr_stmt|;
comment|/* Mandatory error for all apart from assembler.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"pasting \"%s\" and \"%s\" does not give a valid preprocessing token"
argument_list|,
name|buf
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handles an arbitrarily long sequence of ## operators, with initial    operand LHS.  This implementation is left-associative,    non-recursive, and finishes a paste before handling succeeding    ones.  If a paste fails, we back up to the RHS of the failing ##    operator before pushing the context containing the result of prior    successful pastes, with the effect that the RHS appears in the    output stream after the pasted LHS normally.  */
end_comment

begin_function
specifier|static
name|void
name|paste_all_tokens
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|lhs
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|rhs
decl_stmt|;
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
do|do
block|{
comment|/* Take the token directly from the current context.  We can do 	 this, because we are in the replacement list of either an 	 object-like macro, or a function-like macro with arguments 	 inserted.  In either case, the constraints to #define 	 guarantee we have at least one more token.  */
if|if
condition|(
name|context
operator|->
name|direct_p
condition|)
name|rhs
operator|=
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|token
operator|++
expr_stmt|;
else|else
name|rhs
operator|=
operator|*
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|ptoken
operator|++
expr_stmt|;
if|if
condition|(
name|rhs
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|paste_tokens
argument_list|(
name|pfile
argument_list|,
operator|&
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|rhs
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
do|;
comment|/* Put the resulting token in its own context.  */
name|_cpp_push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the number of arguments ARGC supplied in an    invocation of the MACRO referenced by NODE is valid.  An empty    invocation to a macro with no parameters should pass ARGC as zero.     Note that MACRO cannot necessarily be deduced from NODE, in case    NODE was redefined whilst collecting arguments.  */
end_comment

begin_function
name|bool
name|_cpp_arguments_ok
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
name|unsigned
name|int
name|argc
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|==
name|macro
operator|->
name|paramc
condition|)
return|return
name|true
return|;
if|if
condition|(
name|argc
operator|<
name|macro
operator|->
name|paramc
condition|)
block|{
comment|/* As an extension, a rest argument is allowed to not appear in 	 the invocation at all. 	 e.g. #define debug(format, args...) something 	 debug("string");  	 This is exactly the same as if there had been an empty rest 	 argument - debug("string", ).  */
if|if
condition|(
name|argc
operator|+
literal|1
operator|==
name|macro
operator|->
name|paramc
operator|&&
name|macro
operator|->
name|variadic
condition|)
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|macro
operator|->
name|syshdr
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"ISO C99 requires rest arguments to be used"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"macro \"%s\" requires %u arguments, but only %u given"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|macro
operator|->
name|paramc
argument_list|,
name|argc
argument_list|)
expr_stmt|;
block|}
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"macro \"%s\" passed %u arguments, but takes just %u"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|argc
argument_list|,
name|macro
operator|->
name|paramc
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Reads and returns the arguments to a function-like macro    invocation.  Assumes the opening parenthesis has been processed.    If there is an error, emits an appropriate diagnostic and returns    NULL.  Each argument is terminated by a CPP_EOF token, for the    future benefit of expand_arg().  */
end_comment

begin_function
specifier|static
name|_cpp_buff
modifier|*
name|collect_args
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|buff
decl_stmt|,
modifier|*
name|base_buff
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
name|macro_arg
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|int
name|argc
decl_stmt|;
name|macro
operator|=
name|node
operator|->
name|value
operator|.
name|macro
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|paramc
condition|)
name|argc
operator|=
name|macro
operator|->
name|paramc
expr_stmt|;
else|else
name|argc
operator|=
literal|1
expr_stmt|;
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|argc
operator|*
operator|(
literal|50
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|macro_arg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|base_buff
operator|=
name|buff
expr_stmt|;
name|args
operator|=
operator|(
name|macro_arg
operator|*
operator|)
name|buff
operator|->
name|base
expr_stmt|;
name|memset
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|macro_arg
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|->
name|cur
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|args
index|[
name|argc
index|]
expr_stmt|;
name|arg
operator|=
name|args
operator|,
name|argc
operator|=
literal|0
expr_stmt|;
comment|/* Collect the tokens making up each argument.  We don't yet know      how many arguments have been supplied, whether too many or too      few.  Hence the slightly bizarre usage of "argc" and "arg".  */
do|do
block|{
name|unsigned
name|int
name|paren_depth
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ntokens
init|=
literal|0
decl_stmt|;
name|argc
operator|++
expr_stmt|;
name|arg
operator|->
name|first
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|buff
operator|->
name|cur
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Require space for 2 new tokens (including a CPP_EOF).  */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|arg
operator|->
name|first
index|[
name|ntokens
operator|+
literal|2
index|]
operator|>
name|buff
operator|->
name|limit
condition|)
block|{
name|buff
operator|=
name|_cpp_append_extend_buff
argument_list|(
name|pfile
argument_list|,
name|buff
argument_list|,
literal|1000
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|->
name|first
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|buff
operator|->
name|cur
expr_stmt|;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
comment|/* Drop leading padding.  */
if|if
condition|(
name|ntokens
operator|==
literal|0
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
name|paren_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
if|if
condition|(
name|paren_depth
operator|--
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
comment|/* A comma does not terminate an argument within 		 parentheses or as part of a variable argument.  */
if|if
condition|(
name|paren_depth
operator|==
literal|0
operator|&&
operator|!
operator|(
name|macro
operator|->
name|variadic
operator|&&
name|argc
operator|==
name|macro
operator|->
name|paramc
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_HASH
operator|&&
name|token
operator|->
name|flags
operator|&
name|BOL
operator|)
condition|)
break|break;
name|arg
operator|->
name|first
index|[
name|ntokens
operator|++
index|]
operator|=
name|token
expr_stmt|;
block|}
comment|/* Drop trailing padding.  */
while|while
condition|(
name|ntokens
operator|>
literal|0
operator|&&
name|arg
operator|->
name|first
index|[
name|ntokens
operator|-
literal|1
index|]
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
name|ntokens
operator|--
expr_stmt|;
name|arg
operator|->
name|count
operator|=
name|ntokens
expr_stmt|;
name|arg
operator|->
name|first
index|[
name|ntokens
index|]
operator|=
operator|&
name|pfile
operator|->
name|eof
expr_stmt|;
comment|/* Terminate the argument.  Excess arguments loop back and 	 overwrite the final legitimate argument, before failing.  */
if|if
condition|(
name|argc
operator|<=
name|macro
operator|->
name|paramc
condition|)
block|{
name|buff
operator|->
name|cur
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|arg
operator|->
name|first
index|[
name|ntokens
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
name|macro
operator|->
name|paramc
condition|)
name|arg
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
do|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
comment|/* We still need the CPP_EOF to end directives, and to end 	 pre-expansion of a macro argument.  Step back is not 	 unconditional, since we don't want to return a CPP_EOF to our 	 callers at the end of an -include-d file.  */
if|if
condition|(
name|pfile
operator|->
name|context
operator|->
name|prev
operator|||
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"unterminated argument list invoking macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A single empty argument is counted as no argument.  */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|macro
operator|->
name|paramc
operator|==
literal|0
operator|&&
name|args
index|[
literal|0
index|]
operator|.
name|count
operator|==
literal|0
condition|)
name|argc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_cpp_arguments_ok
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|node
argument_list|,
name|argc
argument_list|)
condition|)
block|{
comment|/* GCC has special semantics for , ## b where b is a varargs 	     parameter: we remove the comma if b was omitted entirely. 	     If b was merely an empty argument, the comma is retained. 	     If the macro takes just one (varargs) parameter, then we 	     retain the comma only if we are standards conforming.  	     If FIRST is NULL replace_args () swallows the comma.  */
if|if
condition|(
name|macro
operator|->
name|variadic
operator|&&
operator|(
name|argc
operator|<
name|macro
operator|->
name|paramc
operator|||
operator|(
name|argc
operator|==
literal|1
operator|&&
name|args
index|[
literal|0
index|]
operator|.
name|count
operator|==
literal|0
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|std
argument_list|)
operator|)
operator|)
condition|)
name|args
index|[
name|macro
operator|->
name|paramc
operator|-
literal|1
index|]
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
return|return
name|base_buff
return|;
block|}
block|}
comment|/* An error occurred.  */
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|base_buff
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Search for an opening parenthesis to the macro of NODE, in such a    way that, if none is found, we don't lose the information in any    intervening padding tokens.  If we find the parenthesis, collect    the arguments and return the buffer containing them.  */
end_comment

begin_function
specifier|static
name|_cpp_buff
modifier|*
name|funlike_invocation_p
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|padding
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_PADDING
condition|)
break|break;
if|if
condition|(
name|padding
operator|==
name|NULL
operator|||
operator|(
operator|!
operator|(
name|padding
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
operator|&&
name|token
operator|->
name|val
operator|.
name|source
operator|==
name|NULL
operator|)
condition|)
name|padding
operator|=
name|token
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|2
expr_stmt|;
return|return
name|collect_args
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/* CPP_EOF can be the end of macro arguments, or the end of the      file.  We mustn't back up over the latter.  Ugh.  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
operator|||
name|token
operator|==
operator|&
name|pfile
operator|->
name|eof
condition|)
block|{
comment|/* Back up.  We may have skipped padding, in which case backing 	 up more than one token when expanding macros is in general 	 too difficult.  We re-insert it in its own context.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|padding
condition|)
name|_cpp_push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|padding
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Push the context of a macro with hash entry NODE onto the context    stack.  If we can successfully expand the macro, we push a context    containing its yet-to-be-rescanned replacement list and return one.    Otherwise, we don't push a context and return zero.  */
end_comment

begin_function
specifier|static
name|int
name|enter_macro_context
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
comment|/* The presence of a macro invalidates a file's controlling macro.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|angled_headers
operator|=
name|false
expr_stmt|;
comment|/* Handle standard macros.  */
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|cpp_macro
modifier|*
name|macro
init|=
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
block|{
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|pfile
operator|->
name|keep_tokens
operator|++
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|1
expr_stmt|;
name|buff
operator|=
name|funlike_invocation_p
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|keep_tokens
operator|--
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|syshdr
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"function-like macro \"%s\" must be used with arguments in traditional C"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|macro
operator|->
name|paramc
operator|>
literal|0
condition|)
name|replace_args
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|macro
argument_list|,
operator|(
name|macro_arg
operator|*
operator|)
name|buff
operator|->
name|base
argument_list|)
expr_stmt|;
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* Disable the macro within its expansion.  */
name|node
operator|->
name|flags
operator||=
name|NODE_DISABLED
expr_stmt|;
name|macro
operator|->
name|used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|paramc
operator|==
literal|0
condition|)
name|_cpp_push_token_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|macro
operator|->
name|exp
operator|.
name|tokens
argument_list|,
name|macro
operator|->
name|count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Handle built-in macros and the _Pragma operator.  */
return|return
name|builtin_macro
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Replace the parameters in a function-like macro of NODE with the    actual ARGS, and place the result in a newly pushed token context.    Expand each argument before replacing, unless it is operated upon    by the # or ## operators.  */
end_comment

begin_function
specifier|static
name|void
name|replace_args
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|,
name|macro_arg
modifier|*
name|args
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|total
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|src
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|dest
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|;
name|macro_arg
modifier|*
name|arg
decl_stmt|;
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
comment|/* First, fully macro-expand arguments, calculating the number of      tokens in the final expansion as we go.  The ordering of the if      statements below is subtle; we must handle stringification before      pasting.  */
name|total
operator|=
name|macro
operator|->
name|count
expr_stmt|;
name|limit
operator|=
name|macro
operator|->
name|exp
operator|.
name|tokens
operator|+
name|macro
operator|->
name|count
expr_stmt|;
for|for
control|(
name|src
operator|=
name|macro
operator|->
name|exp
operator|.
name|tokens
init|;
name|src
operator|<
name|limit
condition|;
name|src
operator|++
control|)
if|if
condition|(
name|src
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
block|{
comment|/* Leading and trailing padding tokens.  */
name|total
operator|+=
literal|2
expr_stmt|;
comment|/* We have an argument.  If it is not being stringified or 	   pasted it is macro-replaced before insertion.  */
name|arg
operator|=
operator|&
name|args
index|[
name|src
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|stringified
condition|)
name|arg
operator|->
name|stringified
operator|=
name|stringify_arg
argument_list|(
name|pfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
operator|)
operator|||
operator|(
name|src
operator|>
name|macro
operator|->
name|exp
operator|.
name|tokens
operator|&&
operator|(
name|src
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PASTE_LEFT
operator|)
operator|)
condition|)
name|total
operator|+=
name|arg
operator|->
name|count
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|expanded
condition|)
name|expand_arg
argument_list|(
name|pfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|total
operator|+=
name|arg
operator|->
name|expanded_count
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now allocate space for the expansion, copy the tokens and replace      the arguments.  */
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|total
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|buff
operator|->
name|base
expr_stmt|;
name|dest
operator|=
name|first
expr_stmt|;
for|for
control|(
name|src
operator|=
name|macro
operator|->
name|exp
operator|.
name|tokens
init|;
name|src
operator|<
name|limit
condition|;
name|src
operator|++
control|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|from
decl_stmt|,
modifier|*
modifier|*
name|paste_flag
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|type
operator|!=
name|CPP_MACRO_ARG
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
name|src
expr_stmt|;
continue|continue;
block|}
name|paste_flag
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
operator|&
name|args
index|[
name|src
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
name|count
operator|=
literal|1
operator|,
name|from
operator|=
operator|&
name|arg
operator|->
name|stringified
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|count
operator|=
name|arg
operator|->
name|count
operator|,
name|from
operator|=
name|arg
operator|->
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|!=
name|macro
operator|->
name|exp
operator|.
name|tokens
operator|&&
operator|(
name|src
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PASTE_LEFT
operator|)
condition|)
block|{
name|count
operator|=
name|arg
operator|->
name|count
operator|,
name|from
operator|=
name|arg
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|first
condition|)
block|{
if|if
condition|(
name|dest
index|[
operator|-
literal|1
index|]
operator|->
name|type
operator|==
name|CPP_COMMA
operator|&&
name|macro
operator|->
name|variadic
operator|&&
name|src
operator|->
name|val
operator|.
name|arg_no
operator|==
name|macro
operator|->
name|paramc
condition|)
block|{
comment|/* Swallow a pasted comma if from == NULL, otherwise 		     drop the paste flag.  */
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
name|dest
operator|--
expr_stmt|;
else|else
name|paste_flag
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Remove the paste flag if the RHS is a placemarker.  */
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|paste_flag
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
name|arg
operator|->
name|expanded_count
operator|,
name|from
operator|=
name|arg
operator|->
name|expanded
expr_stmt|;
comment|/* Padding on the left of an argument (unless RHS of ##).  */
if|if
condition|(
operator|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|||
name|pfile
operator|->
name|state
operator|.
name|directive_wants_padding
operator|)
operator|&&
name|src
operator|!=
name|macro
operator|->
name|exp
operator|.
name|tokens
operator|&&
operator|!
operator|(
name|src
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PASTE_LEFT
operator|)
condition|)
operator|*
name|dest
operator|++
operator|=
name|padding_token
argument_list|(
name|pfile
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|from
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|count
expr_stmt|;
comment|/* With a non-empty argument on the LHS of ##, the last 	     token should be flagged PASTE_LEFT.  */
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|paste_flag
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Avoid paste on RHS (even case count == 0).  */
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
operator|!
operator|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
operator|)
condition|)
operator|*
name|dest
operator|++
operator|=
operator|&
name|pfile
operator|->
name|avoid_paste
expr_stmt|;
comment|/* Add a new paste flag, or remove an unwanted one.  */
if|if
condition|(
name|paste_flag
condition|)
block|{
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|token
operator|->
name|type
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|type
expr_stmt|;
name|token
operator|->
name|val
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|token
operator|->
name|flags
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|flags
operator||
name|PASTE_LEFT
expr_stmt|;
else|else
name|token
operator|->
name|flags
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|flags
operator|&
operator|~
name|PASTE_LEFT
expr_stmt|;
operator|*
name|paste_flag
operator|=
name|token
expr_stmt|;
block|}
block|}
comment|/* Free the expanded arguments.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|expanded
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|expanded
argument_list|)
expr_stmt|;
name|push_ptoken_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|buff
argument_list|,
name|first
argument_list|,
name|dest
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a special padding token, with padding inherited from SOURCE.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|padding_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|source
parameter_list|)
block|{
name|cpp_token
modifier|*
name|result
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
comment|/* Data in GCed data structures cannot be made const so far, so we      need a cast here.  */
name|result
operator|->
name|val
operator|.
name|source
operator|=
operator|(
name|cpp_token
operator|*
operator|)
name|source
expr_stmt|;
name|result
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Get a new uninitialized context.  Create a new one if we cannot    re-use an old one.  */
end_comment

begin_function
specifier|static
name|cpp_context
modifier|*
name|next_context
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_context
modifier|*
name|result
init|=
name|pfile
operator|->
name|context
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|XNEW
argument_list|(
name|cpp_context
argument_list|)
expr_stmt|;
name|result
operator|->
name|prev
operator|=
name|pfile
operator|->
name|context
expr_stmt|;
name|result
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|context
operator|->
name|next
operator|=
name|result
expr_stmt|;
block|}
name|pfile
operator|->
name|context
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Push a list of pointers to tokens.  */
end_comment

begin_function
specifier|static
name|void
name|push_ptoken_context
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|macro
parameter_list|,
name|_cpp_buff
modifier|*
name|buff
parameter_list|,
specifier|const
name|cpp_token
modifier|*
modifier|*
name|first
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|cpp_context
modifier|*
name|context
init|=
name|next_context
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|context
operator|->
name|direct_p
operator|=
name|false
expr_stmt|;
name|context
operator|->
name|macro
operator|=
name|macro
expr_stmt|;
name|context
operator|->
name|buff
operator|=
name|buff
expr_stmt|;
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|ptoken
operator|=
name|first
expr_stmt|;
name|LAST
argument_list|(
name|context
argument_list|)
operator|.
name|ptoken
operator|=
name|first
operator|+
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a list of tokens.  */
end_comment

begin_function
name|void
name|_cpp_push_token_context
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|macro
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|first
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|cpp_context
modifier|*
name|context
init|=
name|next_context
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|context
operator|->
name|direct_p
operator|=
name|true
expr_stmt|;
name|context
operator|->
name|macro
operator|=
name|macro
expr_stmt|;
name|context
operator|->
name|buff
operator|=
name|NULL
expr_stmt|;
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|token
operator|=
name|first
expr_stmt|;
name|LAST
argument_list|(
name|context
argument_list|)
operator|.
name|token
operator|=
name|first
operator|+
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a traditional macro's replacement text.  */
end_comment

begin_function
name|void
name|_cpp_push_text_context
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|macro
parameter_list|,
specifier|const
name|uchar
modifier|*
name|start
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|cpp_context
modifier|*
name|context
init|=
name|next_context
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|context
operator|->
name|direct_p
operator|=
name|true
expr_stmt|;
name|context
operator|->
name|macro
operator|=
name|macro
expr_stmt|;
name|context
operator|->
name|buff
operator|=
name|NULL
expr_stmt|;
name|CUR
argument_list|(
name|context
argument_list|)
operator|=
name|start
expr_stmt|;
name|RLIMIT
argument_list|(
name|context
argument_list|)
operator|=
name|start
operator|+
name|len
expr_stmt|;
name|macro
operator|->
name|flags
operator||=
name|NODE_DISABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an argument ARG before replacing parameters in a    function-like macro.  This works by pushing a context with the    argument's tokens, and then expanding that into a temporary buffer    as if it were a normal part of the token stream.  collect_args()    has terminated the argument's tokens with a CPP_EOF so that we know    when we have fully expanded the argument.  */
end_comment

begin_function
specifier|static
name|void
name|expand_arg
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|macro_arg
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|int
name|capacity
decl_stmt|;
name|bool
name|saved_warn_trad
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|count
operator|==
literal|0
condition|)
return|return;
comment|/* Don't warn about funlike macros when pre-expanding.  */
name|saved_warn_trad
operator|=
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Loop, reading in the arguments.  */
name|capacity
operator|=
literal|256
expr_stmt|;
name|arg
operator|->
name|expanded
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|cpp_token
operator|*
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|push_ptoken_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|arg
operator|->
name|first
argument_list|,
name|arg
operator|->
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|expanded_count
operator|+
literal|1
operator|>=
name|capacity
condition|)
block|{
name|capacity
operator|*=
literal|2
expr_stmt|;
name|arg
operator|->
name|expanded
operator|=
name|XRESIZEVEC
argument_list|(
specifier|const
name|cpp_token
operator|*
argument_list|,
name|arg
operator|->
name|expanded
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
name|arg
operator|->
name|expanded
index|[
name|arg
operator|->
name|expanded_count
operator|++
index|]
operator|=
name|token
expr_stmt|;
block|}
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|=
name|saved_warn_trad
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the current context off the stack, re-enabling the macro if the    context represented a macro's replacement list.  The context    structure is not freed so that we can re-use it later.  */
end_comment

begin_function
name|void
name|_cpp_pop_context
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|macro
condition|)
name|context
operator|->
name|macro
operator|->
name|flags
operator|&=
operator|~
name|NODE_DISABLED
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|buff
condition|)
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|context
operator|->
name|buff
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|context
operator|=
name|context
operator|->
name|prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/* External routine to get a token.  Also used nearly everywhere    internally, except for places where we know we can safely call    _cpp_lex_token directly, such as lexing a directive name.     Macro expansions and directives are transparently handled,    including entering included files.  Thus tokens are post-macro    expansion, and after any intervening directives.  External callers    see CPP_EOF only at EOF.  Internal callers also see it when meeting    a directive inside a macro call, when at the end of a directive and    state.in_directive is still 1, and at the end of argument    pre-expansion.  */
end_comment

begin_function
specifier|const
name|cpp_token
modifier|*
name|cpp_get_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|result
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
comment|/* Context->prev == 0<=> base context.  */
if|if
condition|(
operator|!
name|context
operator|->
name|prev
condition|)
name|result
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|token
operator|!=
name|LAST
argument_list|(
name|context
argument_list|)
operator|.
name|token
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|direct_p
condition|)
name|result
operator|=
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|token
operator|++
expr_stmt|;
else|else
name|result
operator|=
operator|*
name|FIRST
argument_list|(
name|context
argument_list|)
operator|.
name|ptoken
operator|++
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
block|{
name|paste_all_tokens
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
continue|continue;
return|return
name|padding_token
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
continue|continue;
return|return
operator|&
name|pfile
operator|->
name|avoid_paste
return|;
block|}
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|result
operator|->
name|type
operator|==
name|CPP_COMMENT
condition|)
continue|continue;
if|if
condition|(
name|result
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
break|break;
name|node
operator|=
name|result
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|NT_MACRO
operator|||
operator|(
name|result
operator|->
name|flags
operator|&
name|NO_EXPAND
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|&&
name|enter_macro_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
continue|continue;
return|return
name|padding_token
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Flag this token as always unexpandable.  FIXME: move this 	     to collect_args()?.  */
name|cpp_token
modifier|*
name|t
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|t
operator|->
name|type
operator|=
name|result
operator|->
name|type
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|result
operator|->
name|flags
operator||
name|NO_EXPAND
expr_stmt|;
name|t
operator|->
name|val
operator|=
name|result
operator|->
name|val
expr_stmt|;
name|result
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we're expanding an object-like macro that was    defined in a system header.  Just checks the macro at the top of    the stack.  Used for diagnostic suppression.  */
end_comment

begin_function
name|int
name|cpp_sys_macro_p
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|pfile
operator|->
name|context
operator|->
name|macro
decl_stmt|;
return|return
name|node
operator|&&
name|node
operator|->
name|value
operator|.
name|macro
operator|&&
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|syshdr
return|;
block|}
end_function

begin_comment
comment|/* Read each token in, until end of the current file.  Directives are    transparently processed.  */
end_comment

begin_function
name|void
name|cpp_scan_nooutput
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* Request a CPP_EOF token at the end of this file, rather than      transparently continuing with the including file.  */
name|pfile
operator|->
name|buffer
operator|->
name|return_at_eof
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|discarding_output
operator|++
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
while|while
condition|(
name|_cpp_read_logical_line_trad
argument_list|(
name|pfile
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
empty_stmt|;
name|pfile
operator|->
name|state
operator|.
name|discarding_output
operator|--
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Step back one (or more) tokens.  Can only step back more than 1 if    they are from the lexer, and not from macro expansion.  */
end_comment

begin_function
name|void
name|_cpp_backup_tokens
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|pfile
operator|->
name|context
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|pfile
operator|->
name|lookaheads
operator|+=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|pfile
operator|->
name|cur_token
operator|--
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|==
name|pfile
operator|->
name|cur_run
operator|->
name|base
comment|/* Possible with -fpreprocessed and no leading #line.  */
operator|&&
name|pfile
operator|->
name|cur_run
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|prev
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|limit
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|context
operator|->
name|direct_p
condition|)
name|FIRST
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|.
name|token
operator|--
expr_stmt|;
else|else
name|FIRST
argument_list|(
name|pfile
operator|->
name|context
argument_list|)
operator|.
name|ptoken
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #define directive parsing and handling.  */
end_comment

begin_comment
comment|/* Returns nonzero if a macro redefinition warning is required.  */
end_comment

begin_function
specifier|static
name|bool
name|warn_of_redefinition
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
specifier|const
name|cpp_macro
modifier|*
name|macro2
parameter_list|)
block|{
specifier|const
name|cpp_macro
modifier|*
name|macro1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Some redefinitions need to be warned about regardless.  */
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_WARN
condition|)
return|return
name|true
return|;
comment|/* Redefinition of a macro is allowed if and only if the old and new      definitions are the same.  (6.10.3 paragraph 2).  */
name|macro1
operator|=
name|node
operator|->
name|value
operator|.
name|macro
expr_stmt|;
comment|/* Don't check count here as it can be different in valid      traditional redefinitions with just whitespace differences.  */
if|if
condition|(
name|macro1
operator|->
name|paramc
operator|!=
name|macro2
operator|->
name|paramc
operator|||
name|macro1
operator|->
name|fun_like
operator|!=
name|macro2
operator|->
name|fun_like
operator|||
name|macro1
operator|->
name|variadic
operator|!=
name|macro2
operator|->
name|variadic
condition|)
return|return
name|true
return|;
comment|/* Check parameter spellings.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro1
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|macro1
operator|->
name|params
index|[
name|i
index|]
operator|!=
name|macro2
operator|->
name|params
index|[
name|i
index|]
condition|)
return|return
name|true
return|;
comment|/* Check the replacement text or tokens.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
return|return
name|_cpp_expansions_different_trad
argument_list|(
name|macro1
argument_list|,
name|macro2
argument_list|)
return|;
if|if
condition|(
name|macro1
operator|->
name|count
operator|!=
name|macro2
operator|->
name|count
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro1
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|_cpp_equiv_tokens
argument_list|(
operator|&
name|macro1
operator|->
name|exp
operator|.
name|tokens
index|[
name|i
index|]
argument_list|,
operator|&
name|macro2
operator|->
name|exp
operator|.
name|tokens
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Free the definition of hashnode H.  */
end_comment

begin_function
name|void
name|_cpp_free_definition
parameter_list|(
name|cpp_hashnode
modifier|*
name|h
parameter_list|)
block|{
comment|/* Macros and assertions no longer have anything to free.  */
name|h
operator|->
name|type
operator|=
name|NT_VOID
expr_stmt|;
comment|/* Clear builtin flag in case of redefinition.  */
name|h
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NODE_BUILTIN
operator||
name|NODE_DISABLED
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save parameter NODE to the parameter list of macro MACRO.  Returns    zero on success, nonzero if the parameter is a duplicate.  */
end_comment

begin_function
name|bool
name|_cpp_save_parameter
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
comment|/* Constraint 6.10.3.6 - duplicate parameter names.  */
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_MACRO_ARG
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"duplicate macro parameter \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|<
operator|(
name|macro
operator|->
name|paramc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|)
index|[
name|macro
operator|->
name|paramc
operator|++
index|]
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|flags
operator||=
name|NODE_MACRO_ARG
expr_stmt|;
name|len
operator|=
name|macro
operator|->
name|paramc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|_cpp_hashnode_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|macro_buffer_len
condition|)
block|{
name|pfile
operator|->
name|macro_buffer
operator|=
name|XRESIZEVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|pfile->macro_buffer
argument_list|,
argument|len
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|macro_buffer_len
operator|=
name|len
expr_stmt|;
block|}
operator|(
operator|(
expr|union
name|_cpp_hashnode_value
operator|*
operator|)
name|pfile
operator|->
name|macro_buffer
operator|)
index|[
name|macro
operator|->
name|paramc
operator|-
literal|1
index|]
operator|=
name|node
operator|->
name|value
expr_stmt|;
name|node
operator|->
name|value
operator|.
name|arg_index
operator|=
name|macro
operator|->
name|paramc
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check the syntax of the parameters in a MACRO definition.  Returns    false if an error occurs.  */
end_comment

begin_function
specifier|static
name|bool
name|parse_params
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
name|unsigned
name|int
name|prev_ident
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
default|default:
comment|/* Allow/ignore comments in parameter lists if we are 	     preserving comments in macro expansions.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMENT
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments_in_macro_exp
argument_list|)
condition|)
continue|continue;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\"%s\" may not appear in macro parameter list"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CPP_NAME
case|:
if|if
condition|(
name|prev_ident
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"macro parameters must be comma-separated"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|prev_ident
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|_cpp_save_parameter
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
condition|)
return|return
name|false
return|;
continue|continue;
case|case
name|CPP_CLOSE_PAREN
case|:
if|if
condition|(
name|prev_ident
operator|||
name|macro
operator|->
name|paramc
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Fall through to pick up the error.  */
case|case
name|CPP_COMMA
case|:
if|if
condition|(
operator|!
name|prev_ident
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"parameter name missing"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|prev_ident
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|CPP_ELLIPSIS
case|:
name|macro
operator|->
name|variadic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|prev_ident
condition|)
block|{
name|_cpp_save_parameter
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__VA_ARGS__
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|va_args_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_variadic_macros
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"anonymous variadic macros were introduced in C99"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_variadic_macros
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"ISO C does not permit named variadic macros"
argument_list|)
expr_stmt|;
comment|/* We're at the end, and just expect a closing parenthesis.  */
name|token
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
return|return
name|true
return|;
comment|/* Fall through.  */
case|case
name|CPP_EOF
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"missing ')' in macro parameter list"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Allocate room for a token from a macro's replacement list.  */
end_comment

begin_function
specifier|static
name|cpp_token
modifier|*
name|alloc_expansion_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|<
operator|(
name|macro
operator|->
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
operator|(
name|cpp_token
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|)
index|[
name|macro
operator|->
name|count
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* Lex a token from the expansion of MACRO, but mark parameters as we    find them and warn of traditional stringification.  */
end_comment

begin_function
specifier|static
name|cpp_token
modifier|*
name|lex_expansion_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|alloc_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Is this a parameter?  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
name|token
operator|->
name|val
operator|.
name|node
operator|->
name|flags
operator|&
name|NODE_MACRO_ARG
operator|)
operator|!=
literal|0
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|CPP_MACRO_ARG
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|arg_no
operator|=
name|token
operator|->
name|val
operator|.
name|node
operator|->
name|value
operator|.
name|arg_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|macro
operator|->
name|paramc
operator|>
literal|0
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CHAR
operator|)
condition|)
name|check_trad_stringification
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
operator|&
name|token
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|create_iso_definition
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_macro
modifier|*
name|macro
parameter_list|)
block|{
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|ctoken
decl_stmt|;
comment|/* Get the first token of the expansion (or the '(' of a      function-like macro).  */
name|ctoken
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoken
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|&&
operator|!
operator|(
name|ctoken
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
block|{
name|bool
name|ok
init|=
name|parse_params
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
decl_stmt|;
name|macro
operator|->
name|params
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
comment|/* Success.  Commit or allocate the parameter array.  */
if|if
condition|(
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
condition|)
block|{
name|cpp_hashnode
modifier|*
modifier|*
name|params
init|=
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
argument_list|(
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
operator|*
name|macro
operator|->
name|paramc
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|params
argument_list|,
name|macro
operator|->
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
operator|*
name|macro
operator|->
name|paramc
argument_list|)
expr_stmt|;
name|macro
operator|->
name|params
operator|=
name|params
expr_stmt|;
block|}
else|else
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|=
operator|(
name|uchar
operator|*
operator|)
operator|&
name|macro
operator|->
name|params
index|[
name|macro
operator|->
name|paramc
index|]
expr_stmt|;
name|macro
operator|->
name|fun_like
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctoken
operator|->
name|type
operator|!=
name|CPP_EOF
operator|&&
operator|!
operator|(
name|ctoken
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
block|{
comment|/* While ISO C99 requires whitespace before replacement text 	 in a macro definition, ISO C90 with TC1 allows there characters 	 from the basic source character set.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"ISO C99 requires whitespace after the macro name"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|warntype
init|=
name|CPP_DL_WARNING
decl_stmt|;
switch|switch
condition|(
name|ctoken
operator|->
name|type
condition|)
block|{
case|case
name|CPP_ATSIGN
case|:
case|case
name|CPP_AT_NAME
case|:
case|case
name|CPP_OBJC_STRING
case|:
comment|/* '@' is not in basic character set.  */
name|warntype
operator|=
name|CPP_DL_PEDWARN
expr_stmt|;
break|break;
case|case
name|CPP_OTHER
case|:
comment|/* Basic character set sans letters, digits and _.  */
if|if
condition|(
name|strchr
argument_list|(
literal|"!\"#%&'()*+,-./:;<=>?[\\]^{|}~"
argument_list|,
name|ctoken
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|warntype
operator|=
name|CPP_DL_PEDWARN
expr_stmt|;
break|break;
default|default:
comment|/* All other tokens start with a character from basic 		 character set.  */
break|break;
block|}
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|warntype
argument_list|,
literal|"missing whitespace after the macro name"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
name|token
operator|=
name|lex_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
else|else
block|{
name|token
operator|=
name|alloc_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
operator|*
name|token
operator|=
operator|*
name|ctoken
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Check the stringifying # constraint 6.10.3.2.1 of 	 function-like macros when lexing the subsequent token.  */
if|if
condition|(
name|macro
operator|->
name|count
operator|>
literal|1
operator|&&
name|token
index|[
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|CPP_HASH
operator|&&
name|macro
operator|->
name|fun_like
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
block|{
name|token
operator|->
name|flags
operator|&=
operator|~
name|PREV_WHITE
expr_stmt|;
name|token
operator|->
name|flags
operator||=
name|STRINGIFY_ARG
expr_stmt|;
name|token
operator|->
name|flags
operator||=
name|token
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PREV_WHITE
expr_stmt|;
name|token
index|[
operator|-
literal|1
index|]
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|macro
operator|->
name|count
operator|--
expr_stmt|;
block|}
comment|/* Let assembler get away with murder.  */
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"'#' is not followed by a macro parameter"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* Paste operator constraint 6.10.3.3.1.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PASTE
condition|)
block|{
comment|/* Token-paste ##, can appear in both object-like and 	     function-like macros, but not at the ends.  */
if|if
condition|(
operator|--
name|macro
operator|->
name|count
operator|>
literal|0
condition|)
name|token
operator|=
name|lex_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|count
operator|==
literal|0
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"'##' cannot appear at either end of a macro expansion"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|token
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator||=
name|PASTE_LEFT
expr_stmt|;
block|}
name|token
operator|=
name|lex_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
block|}
name|macro
operator|->
name|exp
operator|.
name|tokens
operator|=
operator|(
name|cpp_token
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|macro
operator|->
name|traditional
operator|=
literal|0
expr_stmt|;
comment|/* Don't count the CPP_EOF.  */
name|macro
operator|->
name|count
operator|--
expr_stmt|;
comment|/* Clear whitespace on first token for warn_of_redefinition().  */
if|if
condition|(
name|macro
operator|->
name|count
condition|)
name|macro
operator|->
name|exp
operator|.
name|tokens
index|[
literal|0
index|]
operator|.
name|flags
operator|&=
operator|~
name|PREV_WHITE
expr_stmt|;
comment|/* Commit or allocate the memory.  */
if|if
condition|(
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
condition|)
block|{
name|cpp_token
modifier|*
name|tokns
init|=
operator|(
name|cpp_token
operator|*
operator|)
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
argument_list|(
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
operator|*
name|macro
operator|->
name|count
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|tokns
argument_list|,
name|macro
operator|->
name|exp
operator|.
name|tokens
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
operator|*
name|macro
operator|->
name|count
argument_list|)
expr_stmt|;
name|macro
operator|->
name|exp
operator|.
name|tokens
operator|=
name|tokns
expr_stmt|;
block|}
else|else
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|=
operator|(
name|uchar
operator|*
operator|)
operator|&
name|macro
operator|->
name|exp
operator|.
name|tokens
index|[
name|macro
operator|->
name|count
index|]
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a macro and save its expansion.  Returns nonzero on success.  */
end_comment

begin_function
name|bool
name|_cpp_create_definition
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
condition|)
name|macro
operator|=
operator|(
name|cpp_macro
operator|*
operator|)
name|pfile
operator|->
name|hash_table
operator|->
name|alloc_subobject
argument_list|(
sizeof|sizeof
argument_list|(
name|cpp_macro
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|macro
operator|=
operator|(
name|cpp_macro
operator|*
operator|)
name|_cpp_aligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_macro
argument_list|)
argument_list|)
expr_stmt|;
name|macro
operator|->
name|line
operator|=
name|pfile
operator|->
name|directive_line
expr_stmt|;
name|macro
operator|->
name|params
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|paramc
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|variadic
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|used
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_unused_macros
argument_list|)
expr_stmt|;
name|macro
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|fun_like
operator|=
literal|0
expr_stmt|;
comment|/* To suppress some diagnostics.  */
name|macro
operator|->
name|syshdr
operator|=
name|pfile
operator|->
name|buffer
operator|&&
name|pfile
operator|->
name|buffer
operator|->
name|sysp
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|ok
operator|=
name|_cpp_create_trad_definition
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
else|else
block|{
name|cpp_token
modifier|*
name|saved_cur_token
init|=
name|pfile
operator|->
name|cur_token
decl_stmt|;
name|ok
operator|=
name|create_iso_definition
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
comment|/* Restore lexer position because of games lex_expansion_token() 	 plays lexing the macro.  We set the type for SEEN_EOL() in 	 directives.c.  	 Longer term we should lex the whole line before coming here, 	 and just copy the expansion.  */
name|saved_cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|type
operator|=
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|type
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|saved_cur_token
expr_stmt|;
comment|/* Stop the lexer accepting __VA_ARGS__.  */
name|pfile
operator|->
name|state
operator|.
name|va_args_ok
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear the fast argument lookup indices.  */
for|for
control|(
name|i
operator|=
name|macro
operator|->
name|paramc
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|struct
name|cpp_hashnode
modifier|*
name|node
init|=
name|macro
operator|->
name|params
index|[
name|i
index|]
decl_stmt|;
name|node
operator|->
name|flags
operator|&=
operator|~
name|NODE_MACRO_ARG
expr_stmt|;
name|node
operator|->
name|value
operator|=
operator|(
operator|(
expr|union
name|_cpp_hashnode_value
operator|*
operator|)
name|pfile
operator|->
name|macro_buffer
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|ok
return|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_unused_macros
argument_list|)
condition|)
name|_cpp_warn_if_unused_macro
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_of_redefinition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|macro
argument_list|)
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
literal|0
argument_list|,
literal|"\"%s\" redefined"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"this is the location of the previous definition"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|NT_VOID
condition|)
name|_cpp_free_definition
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Enter definition in hash table.  */
name|node
operator|->
name|type
operator|=
name|NT_MACRO
expr_stmt|;
name|node
operator|->
name|value
operator|.
name|macro
operator|=
name|macro
expr_stmt|;
if|if
condition|(
operator|!
name|ustrncmp
argument_list|(
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|DSC
argument_list|(
literal|"__STDC_"
argument_list|)
argument_list|)
condition|)
name|node
operator|->
name|flags
operator||=
name|NODE_WARN
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Warn if a token in STRING matches one of a function-like MACRO's    parameters.  */
end_comment

begin_function
specifier|static
name|void
name|check_trad_stringification
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_macro
modifier|*
name|macro
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
comment|/* Loop over the string.  */
name|limit
operator|=
name|string
operator|->
name|text
operator|+
name|string
operator|->
name|len
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
operator|->
name|text
operator|+
literal|1
init|;
name|p
operator|<
name|limit
condition|;
name|p
operator|=
name|q
control|)
block|{
comment|/* Find the start of an identifier.  */
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
name|is_idstart
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Find the end of the identifier.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|limit
operator|&&
name|is_idchar
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
name|len
operator|=
name|q
operator|-
name|p
expr_stmt|;
comment|/* Loop over the function macro arguments to see if the 	 identifier inside the string matches one of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cpp_hashnode
modifier|*
name|node
init|=
name|macro
operator|->
name|params
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|NODE_LEN
argument_list|(
name|node
argument_list|)
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"macro argument \"%s\" would be stringified in traditional C"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns the name, arguments and expansion of a macro, in a format    suitable to be read back in again, and therefore also for DWARF 2    debugging info.  e.g. "PASTE(X, Y) X ## Y", or "MACNAME EXPANSION".    Caller is expected to generate the "#define" bit if needed.  The    returned text is temporary, and automatically freed later.  */
end_comment

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|cpp_macro_definition
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|cpp_macro
modifier|*
name|macro
init|=
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|NT_MACRO
operator|||
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"invalid hash type %d in cpp_macro_definition"
argument_list|,
name|node
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Calculate length.  */
name|len
operator|=
name|NODE_LEN
argument_list|(
name|node
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* ' ' and NUL.  */
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
block|{
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* "()" plus possible final ".." of named 			   varargs (we have + 1 below).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* "," */
block|}
comment|/* This should match below where we fill in the buffer.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|len
operator|+=
name|_cpp_replacement_text_len
argument_list|(
name|macro
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cpp_token
modifier|*
name|token
init|=
operator|&
name|macro
operator|->
name|exp
operator|.
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
name|len
operator|+=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|len
operator|+=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
name|len
operator|++
expr_stmt|;
comment|/* "#" */
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|len
operator|+=
literal|3
expr_stmt|;
comment|/* " ##" */
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|len
operator|++
expr_stmt|;
comment|/* " " */
block|}
block|}
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|macro_buffer_len
condition|)
block|{
name|pfile
operator|->
name|macro_buffer
operator|=
name|XRESIZEVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|pfile->macro_buffer
argument_list|,
argument|len
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|macro_buffer_len
operator|=
name|len
expr_stmt|;
block|}
comment|/* Fill in the buffer.  Start with the macro name.  */
name|buffer
operator|=
name|pfile
operator|->
name|macro_buffer
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Parameter names.  */
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|param
init|=
name|macro
operator|->
name|params
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|param
operator|!=
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__VA_ARGS__
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|param
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|param
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|macro
operator|->
name|paramc
condition|)
comment|/* Don't emit a space after the comma here; we're trying 	       to emit a Dwarf-friendly definition, and the Dwarf spec 	       forbids spaces in the argument list.  */
operator|*
name|buffer
operator|++
operator|=
literal|','
expr_stmt|;
elseif|else
if|if
condition|(
name|macro
operator|->
name|variadic
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|'.'
operator|,
operator|*
name|buffer
operator|++
operator|=
literal|'.'
operator|,
operator|*
name|buffer
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|buffer
operator|++
operator|=
literal|')'
expr_stmt|;
block|}
comment|/* The Dwarf spec requires a space after the macro name, even if the      definition is the empty string.  */
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
name|buffer
operator|=
name|_cpp_copy_replacement_text
argument_list|(
name|macro
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|macro
operator|->
name|count
condition|)
comment|/* Expansion tokens.  */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cpp_token
modifier|*
name|token
init|=
operator|&
name|macro
operator|->
name|exp
operator|.
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|buffer
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|buffer
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* Next has PREV_WHITE; see _cpp_create_definition.  */
block|}
block|}
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|pfile
operator|->
name|macro_buffer
return|;
block|}
end_function

end_unit

