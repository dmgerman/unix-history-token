begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mudflap: narrow-pointer bounds-checking by tree rewriting.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Frank Ch. Eigler<fche@redhat.com>    and Graydon Hoare<graydon@redhat.com>    Splay Tree code originally by Mark Mitchell<mark@markmitchell.com>,    adapted from libiberty.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* These attempt to coax various unix flavours to declare all our    needed tidbits in the system headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some BSDs break<sys/socket.h> if this is defined. */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_define
define|#
directive|define
name|_XOPEN_SOURCE
end_define

begin_define
define|#
directive|define
name|_BSD_TYPES
end_define

begin_define
define|#
directive|define
name|__EXTENSIONS__
end_define

begin_define
define|#
directive|define
name|_ALL_SOURCE
end_define

begin_define
define|#
directive|define
name|_LARGE_FILE_API
end_define

begin_define
define|#
directive|define
name|_XOPEN_SOURCE_EXTENDED
value|1
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECINFO_H
end_ifdef

begin_include
include|#
directive|include
file|<execinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"mf-runtime.h"
end_include

begin_include
include|#
directive|include
file|"mf-impl.h"
end_include

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Splay-tree implementation.  */
end_comment

begin_typedef
typedef|typedef
name|uintptr_t
name|mfsplay_tree_key
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|mfsplay_tree_value
typedef|;
end_typedef

begin_comment
comment|/* Forward declaration for a node in the tree.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|mfsplay_tree_node_s
modifier|*
name|mfsplay_tree_node
typedef|;
end_typedef

begin_comment
comment|/* The type of a function used to iterate over the tree.  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|mfsplay_tree_foreach_fn
function_decl|)
parameter_list|(
name|mfsplay_tree_node
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* The nodes in the splay tree.  */
end_comment

begin_struct
struct|struct
name|mfsplay_tree_node_s
block|{
comment|/* Data.  */
name|mfsplay_tree_key
name|key
decl_stmt|;
name|mfsplay_tree_value
name|value
decl_stmt|;
comment|/* Children.  */
name|mfsplay_tree_node
name|left
decl_stmt|;
name|mfsplay_tree_node
name|right
decl_stmt|;
comment|/* XXX: The addition of a parent pointer may eliminate some recursion.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The splay tree itself.  */
end_comment

begin_struct
struct|struct
name|mfsplay_tree_s
block|{
comment|/* The root of the tree.  */
name|mfsplay_tree_node
name|root
decl_stmt|;
comment|/* The last key value for which the tree has been splayed, but not      since modified.  */
name|mfsplay_tree_key
name|last_splayed_key
decl_stmt|;
name|int
name|last_splayed_key_p
decl_stmt|;
comment|/* Statistics.  */
name|unsigned
name|num_keys
decl_stmt|;
comment|/* Traversal recursion control flags.  */
name|unsigned
name|max_depth
decl_stmt|;
name|unsigned
name|depth
decl_stmt|;
name|unsigned
name|rebalance_p
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|mfsplay_tree_s
modifier|*
name|mfsplay_tree
typedef|;
end_typedef

begin_function_decl
specifier|static
name|mfsplay_tree
name|mfsplay_tree_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_insert
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|,
name|mfsplay_tree_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfsplay_tree_remove
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_lookup
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_predecessor
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_successor
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfsplay_tree_foreach
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_foreach_fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfsplay_tree_rebalance
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Utility macros */
end_comment

begin_define
define|#
directive|define
name|CTOR
value|__attribute__ ((constructor))
end_define

begin_define
define|#
directive|define
name|DTOR
value|__attribute__ ((destructor))
end_define

begin_comment
comment|/* Codes to describe the context in which a violation occurs. */
end_comment

begin_define
define|#
directive|define
name|__MF_VIOL_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|__MF_VIOL_READ
value|1
end_define

begin_define
define|#
directive|define
name|__MF_VIOL_WRITE
value|2
end_define

begin_define
define|#
directive|define
name|__MF_VIOL_REGISTER
value|3
end_define

begin_define
define|#
directive|define
name|__MF_VIOL_UNREGISTER
value|4
end_define

begin_define
define|#
directive|define
name|__MF_VIOL_WATCH
value|5
end_define

begin_comment
comment|/* Protect against recursive calls. */
end_comment

begin_function
specifier|static
name|void
name|begin_recursion_protect1
parameter_list|(
specifier|const
name|char
modifier|*
name|pf
parameter_list|)
block|{
if|if
condition|(
name|__mf_get_state
argument_list|()
operator|==
name|reentrant
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"mf: erroneous reentrancy detected in `"
argument_list|,
literal|38
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|pf
argument_list|,
name|strlen
argument_list|(
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"'\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|\
name|abort
argument_list|()
expr_stmt|;
block|}
name|__mf_set_state
argument_list|(
name|reentrant
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BEGIN_RECURSION_PROTECT
parameter_list|()
define|\
value|begin_recursion_protect1 (__PRETTY_FUNCTION__)
end_define

begin_define
define|#
directive|define
name|END_RECURSION_PROTECT
parameter_list|()
define|\
value|__mf_set_state (active)
end_define

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Required globals.  */
end_comment

begin_define
define|#
directive|define
name|LOOKUP_CACHE_MASK_DFL
value|1023
end_define

begin_define
define|#
directive|define
name|LOOKUP_CACHE_SIZE_MAX
value|65536
end_define

begin_comment
comment|/* Allows max CACHE_MASK 0xFFFF */
end_comment

begin_define
define|#
directive|define
name|LOOKUP_CACHE_SHIFT_DFL
value|2
end_define

begin_decl_stmt
name|struct
name|__mf_cache
name|__mf_lookup_cache
index|[
name|LOOKUP_CACHE_SIZE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uintptr_t
name|__mf_lc_mask
init|=
name|LOOKUP_CACHE_MASK_DFL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|__mf_lc_shift
init|=
name|LOOKUP_CACHE_SHIFT_DFL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOOKUP_CACHE_SIZE
value|(__mf_lc_mask + 1)
end_define

begin_decl_stmt
name|struct
name|__mf_options
name|__mf_opts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__mf_starting_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TLS
end_ifdef

begin_decl_stmt
name|__thread
name|enum
name|__mf_state_enum
name|__mf_state_1
init|=
name|reentrant
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|enum
name|__mf_state_enum
name|__mf_state_1
init|=
name|reentrant
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
end_ifdef

begin_decl_stmt
name|pthread_mutex_t
name|__mf_biglock
init|=
ifdef|#
directive|ifdef
name|PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
name|PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|PTHREAD_MUTEX_INITIALIZER
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use HAVE_PTHREAD_H here instead of LIBMUDFLAPTH, so that even    the libmudflap.la (no threading support) can diagnose whether    the application is linked with -lpthread.  See __mf_usage() below.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_PTHREAD_H
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_THREADS
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|weak
name|pthread_join
end_pragma

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|pthread_join
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* stats-related globals.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_count_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_lookup_cache_reusecount
index|[
name|LOOKUP_CACHE_SIZE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_count_register
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_total_register_size
index|[
name|__MF_TYPE_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_count_unregister
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_total_unregister_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_count_violation
index|[
name|__MF_VIOL_WATCH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_sigusr1_received
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|__mf_sigusr1_handled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not static */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|__mf_reentrancy
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
end_ifdef

begin_comment
comment|/* not static */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|__mf_lock_contention
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* mode-check-related globals.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|__mf_object
block|{
name|uintptr_t
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* __mf_register parameters */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|type
decl_stmt|;
comment|/* __MF_TYPE_something */
name|char
name|watching_p
decl_stmt|;
comment|/* Trigger a VIOL_WATCH on access? */
name|unsigned
name|read_count
decl_stmt|;
comment|/* Number of times __mf_check/read was called on this object.  */
name|unsigned
name|write_count
decl_stmt|;
comment|/* Likewise for __mf_check/write.  */
name|unsigned
name|liveness
decl_stmt|;
comment|/* A measure of recent checking activity.  */
name|unsigned
name|description_epoch
decl_stmt|;
comment|/* Last epoch __mf_describe_object printed this.  */
name|uintptr_t
name|alloc_pc
decl_stmt|;
name|struct
name|timeval
name|alloc_time
decl_stmt|;
name|char
modifier|*
modifier|*
name|alloc_backtrace
decl_stmt|;
name|size_t
name|alloc_backtrace_size
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
name|pthread_t
name|alloc_thread
decl_stmt|;
endif|#
directive|endif
name|int
name|deallocated_p
decl_stmt|;
name|uintptr_t
name|dealloc_pc
decl_stmt|;
name|struct
name|timeval
name|dealloc_time
decl_stmt|;
name|char
modifier|*
modifier|*
name|dealloc_backtrace
decl_stmt|;
name|size_t
name|dealloc_backtrace_size
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
name|pthread_t
name|dealloc_thread
decl_stmt|;
endif|#
directive|endif
block|}
name|__mf_object_t
typedef|;
end_typedef

begin_comment
comment|/* Live objects: splay trees, separated by type, ordered on .low (base address).  */
end_comment

begin_comment
comment|/* Actually stored as static vars within lookup function below.  */
end_comment

begin_comment
comment|/* Dead objects: circular arrays; _MIN_CEM .. _MAX_CEM only */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|__mf_object_dead_head
index|[
name|__MF_TYPE_MAX_CEM
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next empty spot */
end_comment

begin_decl_stmt
specifier|static
name|__mf_object_t
modifier|*
name|__mf_object_cemetary
index|[
name|__MF_TYPE_MAX_CEM
operator|+
literal|1
index|]
index|[
name|__MF_PERSIST_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Forward function declarations */
end_comment

begin_expr_stmt
name|void
name|__mf_init
argument_list|()
name|CTOR
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|__mf_sigusr1_respond
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|__mf_find_objects
parameter_list|(
name|uintptr_t
name|ptr_low
parameter_list|,
name|uintptr_t
name|ptr_high
parameter_list|,
name|__mf_object_t
modifier|*
modifier|*
name|objs
parameter_list|,
name|unsigned
name|max_objs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|__mf_find_objects2
parameter_list|(
name|uintptr_t
name|ptr_low
parameter_list|,
name|uintptr_t
name|ptr_high
parameter_list|,
name|__mf_object_t
modifier|*
modifier|*
name|objs
parameter_list|,
name|unsigned
name|max_objs
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|__mf_find_dead_objects
parameter_list|(
name|uintptr_t
name|ptr_low
parameter_list|,
name|uintptr_t
name|ptr_high
parameter_list|,
name|__mf_object_t
modifier|*
modifier|*
name|objs
parameter_list|,
name|unsigned
name|max_objs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__mf_adapt_cache
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__mf_describe_object
parameter_list|(
name|__mf_object_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|__mf_watch_or_not
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|char
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mfsplay_tree
name|__mf_object_tree
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__mf_link_object
parameter_list|(
name|__mf_object_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__mf_unlink_object
parameter_list|(
name|__mf_object_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Configuration engine */
end_comment

begin_function
specifier|static
name|void
name|__mf_set_default_options
parameter_list|()
block|{
name|memset
argument_list|(
operator|&
name|__mf_opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|__mf_opts
argument_list|)
argument_list|)
expr_stmt|;
name|__mf_opts
operator|.
name|adapt_cache
operator|=
literal|1000003
expr_stmt|;
name|__mf_opts
operator|.
name|abbreviate
operator|=
literal|1
expr_stmt|;
name|__mf_opts
operator|.
name|verbose_violations
operator|=
literal|1
expr_stmt|;
name|__mf_opts
operator|.
name|free_queue_length
operator|=
literal|4
expr_stmt|;
name|__mf_opts
operator|.
name|persistent_count
operator|=
literal|100
expr_stmt|;
name|__mf_opts
operator|.
name|crumple_zone
operator|=
literal|32
expr_stmt|;
name|__mf_opts
operator|.
name|backtrace
operator|=
literal|4
expr_stmt|;
name|__mf_opts
operator|.
name|timestamps
operator|=
literal|1
expr_stmt|;
name|__mf_opts
operator|.
name|mudflap_mode
operator|=
name|mode_check
expr_stmt|;
name|__mf_opts
operator|.
name|violation_mode
operator|=
name|viol_nop
expr_stmt|;
name|__mf_opts
operator|.
name|heur_std_data
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
name|__mf_opts
operator|.
name|thread_stack
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_struct
specifier|static
struct|struct
name|option
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|description
decl_stmt|;
enum|enum
block|{
name|set_option
block|,
name|read_integer_option
block|,     }
name|type
enum|;
name|unsigned
name|value
decl_stmt|;
name|unsigned
modifier|*
name|target
decl_stmt|;
block|}
name|options
index|[]
init|=
block|{
block|{
literal|"mode-nop"
block|,
literal|"mudflaps do nothing"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|mode_nop
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|mudflap_mode
block|}
block|,
block|{
literal|"mode-populate"
block|,
literal|"mudflaps populate object tree"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|mode_populate
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|mudflap_mode
block|}
block|,
block|{
literal|"mode-check"
block|,
literal|"mudflaps check for memory violations"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|mode_check
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|mudflap_mode
block|}
block|,
block|{
literal|"mode-violate"
block|,
literal|"mudflaps always cause violations (diagnostic)"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|mode_violate
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|mudflap_mode
block|}
block|,
block|{
literal|"viol-nop"
block|,
literal|"violations do not change program execution"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|viol_nop
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|violation_mode
block|}
block|,
block|{
literal|"viol-abort"
block|,
literal|"violations cause a call to abort()"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|viol_abort
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|violation_mode
block|}
block|,
block|{
literal|"viol-segv"
block|,
literal|"violations are promoted to SIGSEGV signals"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|viol_segv
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|violation_mode
block|}
block|,
block|{
literal|"viol-gdb"
block|,
literal|"violations fork a gdb process attached to current program"
block|,
name|set_option
block|,
operator|(
name|unsigned
operator|)
name|viol_gdb
block|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|__mf_opts
operator|.
name|violation_mode
block|}
block|,
block|{
literal|"trace-calls"
block|,
literal|"trace calls to mudflap runtime library"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|trace_mf_calls
block|}
block|,
block|{
literal|"verbose-trace"
block|,
literal|"trace internal events within mudflap runtime library"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|verbose_trace
block|}
block|,
block|{
literal|"collect-stats"
block|,
literal|"collect statistics on mudflap's operation"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|collect_stats
block|}
block|,
ifdef|#
directive|ifdef
name|SIGUSR1
block|{
literal|"sigusr1-report"
block|,
literal|"print report upon SIGUSR1"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|sigusr1_report
block|}
block|,
endif|#
directive|endif
block|{
literal|"internal-checking"
block|,
literal|"perform more expensive internal checking"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|internal_checking
block|}
block|,
block|{
literal|"print-leaks"
block|,
literal|"print any memory leaks at program shutdown"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|print_leaks
block|}
block|,
block|{
literal|"check-initialization"
block|,
literal|"detect uninitialized object reads"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|check_initialization
block|}
block|,
block|{
literal|"verbose-violations"
block|,
literal|"print verbose messages when memory violations occur"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|verbose_violations
block|}
block|,
block|{
literal|"abbreviate"
block|,
literal|"abbreviate repetitive listings"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|abbreviate
block|}
block|,
block|{
literal|"timestamps"
block|,
literal|"track object lifetime timestamps"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|timestamps
block|}
block|,
block|{
literal|"ignore-reads"
block|,
literal|"ignore read accesses - assume okay"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|ignore_reads
block|}
block|,
block|{
literal|"wipe-stack"
block|,
literal|"wipe stack objects at unwind"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|wipe_stack
block|}
block|,
block|{
literal|"wipe-heap"
block|,
literal|"wipe heap objects at free"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|wipe_heap
block|}
block|,
block|{
literal|"heur-proc-map"
block|,
literal|"support /proc/self/map heuristics"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|heur_proc_map
block|}
block|,
block|{
literal|"heur-stack-bound"
block|,
literal|"enable a simple upper stack bound heuristic"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|heur_stack_bound
block|}
block|,
block|{
literal|"heur-start-end"
block|,
literal|"support _start.._end heuristics"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|heur_start_end
block|}
block|,
block|{
literal|"heur-stdlib"
block|,
literal|"register standard library data (argv, errno, stdin, ...)"
block|,
name|set_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|heur_std_data
block|}
block|,
block|{
literal|"free-queue-length"
block|,
literal|"queue N deferred free() calls before performing them"
block|,
name|read_integer_option
block|,
literal|0
block|,
operator|&
name|__mf_opts
operator|.
name|free_queue_length
block|}
block|,
block|{
literal|"persistent-count"
block|,
literal|"keep a history of N unregistered regions"
block|,
name|read_integer_option
block|,
literal|0
block|,
operator|&
name|__mf_opts
operator|.
name|persistent_count
block|}
block|,
block|{
literal|"crumple-zone"
block|,
literal|"surround allocations with crumple zones of N bytes"
block|,
name|read_integer_option
block|,
literal|0
block|,
operator|&
name|__mf_opts
operator|.
name|crumple_zone
block|}
block|,
comment|/* XXX: not type-safe.     {"lc-mask",      "set lookup cache size mask to N (2**M - 1)",      read_integer_option, 0, (int *)(&__mf_lc_mask)},     {"lc-shift",      "set lookup cache pointer shift",      read_integer_option, 0, (int *)(&__mf_lc_shift)},     */
block|{
literal|"lc-adapt"
block|,
literal|"adapt mask/shift parameters after N cache misses"
block|,
name|read_integer_option
block|,
literal|1
block|,
operator|&
name|__mf_opts
operator|.
name|adapt_cache
block|}
block|,
block|{
literal|"backtrace"
block|,
literal|"keep an N-level stack trace of each call context"
block|,
name|read_integer_option
block|,
literal|0
block|,
operator|&
name|__mf_opts
operator|.
name|backtrace
block|}
block|,
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
block|{
literal|"thread-stack"
block|,
literal|"override thread stacks allocation: N kB"
block|,
name|read_integer_option
block|,
literal|0
block|,
operator|&
name|__mf_opts
operator|.
name|thread_stack
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
name|set_option
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|__mf_usage
parameter_list|()
block|{
name|struct
name|option
modifier|*
name|opt
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This is a %s%sGCC \"mudflap\" memory-checked binary.\n"
literal|"Mudflap is Copyright (C) 2002-2004 Free Software Foundation, Inc.\n"
literal|"\n"
literal|"The mudflap code can be controlled by an environment variable:\n"
literal|"\n"
literal|"$ export MUDFLAP_OPTIONS='<options>'\n"
literal|"$<mudflapped_program>\n"
literal|"\n"
literal|"where<options> is a space-separated list of \n"
literal|"any of the following options.  Use `-no-OPTION' to disable options.\n"
literal|"\n"
argument_list|,
if|#
directive|if
name|HAVE_PTHREAD_H
operator|(
name|pthread_join
condition|?
literal|"multi-threaded "
else|:
literal|"single-threaded "
operator|)
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
if|#
directive|if
name|LIBMUDFLAPTH
literal|"thread-aware "
else|#
directive|else
literal|"thread-unaware "
endif|#
directive|endif
argument_list|)
expr_stmt|;
comment|/* XXX: The multi-threaded thread-unaware combination is bad.  */
for|for
control|(
name|opt
operator|=
name|options
init|;
name|opt
operator|->
name|name
condition|;
name|opt
operator|++
control|)
block|{
name|int
name|default_p
init|=
operator|(
name|opt
operator|->
name|value
operator|==
operator|*
name|opt
operator|->
name|target
operator|)
decl_stmt|;
switch|switch
condition|(
name|opt
operator|->
name|type
condition|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
case|case
name|set_option
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%-23.23s %s"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|opt
operator|->
name|description
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [active]\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|read_integer_option
case|:
name|strncpy
argument_list|(
name|buf
argument_list|,
name|opt
operator|->
name|name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|opt
operator|->
name|name
argument_list|)
argument_list|,
literal|"=N"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%-23.23s %s"
argument_list|,
name|buf
argument_list|,
name|opt
operator|->
name|description
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [%d]\n"
argument_list|,
operator|*
name|opt
operator|->
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__mf_set_options
parameter_list|(
specifier|const
name|char
modifier|*
name|optstr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|LOCKTH
argument_list|()
expr_stmt|;
name|BEGIN_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|rc
operator|=
name|__mfu_set_options
argument_list|(
name|optstr
argument_list|)
expr_stmt|;
comment|/* XXX: It's not really that easy.  A change to a bunch of parameters      can require updating auxiliary state or risk crashing:      free_queue_length, crumple_zone ... */
name|END_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|__mfu_set_options
parameter_list|(
specifier|const
name|char
modifier|*
name|optstr
parameter_list|)
block|{
name|struct
name|option
modifier|*
name|opts
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|nxt
init|=
literal|0
decl_stmt|;
name|long
name|tmp
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_optstr
init|=
name|optstr
decl_stmt|;
comment|/* XXX: bounds-check for optstr! */
while|while
condition|(
operator|*
name|optstr
condition|)
block|{
switch|switch
condition|(
operator|*
name|optstr
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
name|optstr
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|*
name|optstr
operator|+
literal|1
condition|)
block|{
name|int
name|negate
init|=
literal|0
decl_stmt|;
name|optstr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|optstr
operator|==
literal|'?'
operator|||
name|strncmp
argument_list|(
name|optstr
argument_list|,
literal|"help"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Caller will print help and exit.  */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|optstr
argument_list|,
literal|"no-"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|negate
operator|=
literal|1
expr_stmt|;
name|optstr
operator|=
operator|&
name|optstr
index|[
literal|3
index|]
expr_stmt|;
block|}
for|for
control|(
name|opts
operator|=
name|options
init|;
name|opts
operator|->
name|name
condition|;
name|opts
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|optstr
argument_list|,
name|opts
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|opts
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|optstr
operator|+=
name|strlen
argument_list|(
name|opts
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opts
operator|->
name|target
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opts
operator|->
name|type
condition|)
block|{
case|case
name|set_option
case|:
if|if
condition|(
name|negate
condition|)
operator|*
operator|(
name|opts
operator|->
name|target
operator|)
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|opts
operator|->
name|target
operator|)
operator|=
name|opts
operator|->
name|value
expr_stmt|;
break|break;
case|case
name|read_integer_option
case|:
if|if
condition|(
operator|!
name|negate
operator|&&
operator|(
operator|*
name|optstr
operator|==
literal|'='
operator|&&
operator|*
operator|(
name|optstr
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|optstr
operator|++
expr_stmt|;
name|tmp
operator|=
name|strtol
argument_list|(
name|optstr
argument_list|,
operator|&
name|nxt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optstr
operator|!=
name|nxt
operator|)
operator|&&
operator|(
name|tmp
operator|!=
name|LONG_MAX
operator|)
condition|)
block|{
name|optstr
operator|=
name|nxt
expr_stmt|;
operator|*
operator|(
name|opts
operator|->
name|target
operator|)
operator|=
operator|(
name|int
operator|)
name|tmp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|negate
condition|)
operator|*
name|opts
operator|->
name|target
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: unrecognized string '%s' in mudflap options\n"
argument_list|,
name|optstr
argument_list|)
expr_stmt|;
name|optstr
operator|+=
name|strlen
argument_list|(
name|optstr
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Special post-processing: bound __mf_lc_mask and free_queue_length for security. */
name|__mf_lc_mask
operator|&=
operator|(
name|LOOKUP_CACHE_SIZE_MAX
operator|-
literal|1
operator|)
expr_stmt|;
name|__mf_opts
operator|.
name|free_queue_length
operator|&=
operator|(
name|__MF_FREEQ_MAX
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Clear the lookup cache, in case the parameters got changed.  */
comment|/* XXX: race */
name|memset
argument_list|(
name|__mf_lookup_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|__mf_lookup_cache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* void slot 0 */
name|__mf_lookup_cache
index|[
literal|0
index|]
operator|.
name|low
operator|=
name|MAXPTR
expr_stmt|;
name|TRACE
argument_list|(
literal|"set options from `%s'\n"
argument_list|,
name|saved_optstr
argument_list|)
expr_stmt|;
comment|/* Call this unconditionally, in case -sigusr1-report was toggled. */
name|__mf_sigusr1_respond
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PIC
end_ifdef

begin_function
name|void
name|__mf_resolve_single_dynamic
parameter_list|(
name|struct
name|__mf_dynamic_entry
modifier|*
name|e
parameter_list|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|pointer
condition|)
return|return;
if|#
directive|if
name|HAVE_DLVSYM
if|if
condition|(
name|e
operator|->
name|version
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|version
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* non-null/empty */
name|e
operator|->
name|pointer
operator|=
name|dlvsym
argument_list|(
name|RTLD_NEXT
argument_list|,
name|e
operator|->
name|name
argument_list|,
name|e
operator|->
name|version
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|e
operator|->
name|pointer
operator|=
name|dlsym
argument_list|(
name|RTLD_NEXT
argument_list|,
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|dlerror
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mf: error in dlsym(\"%s\"): %s\n"
argument_list|,
name|e
operator|->
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|pointer
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mf: dlsym(\"%s\") = NULL\n"
argument_list|,
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__mf_resolve_dynamics
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dyn_INITRESOLVE
condition|;
name|i
operator|++
control|)
name|__mf_resolve_single_dynamic
argument_list|(
operator|&
name|__mf_dynamic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NB: order must match enums in mf-impl.h */
end_comment

begin_decl_stmt
name|struct
name|__mf_dynamic_entry
name|__mf_dynamic
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|"calloc"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"free"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"malloc"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"mmap"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"munmap"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"realloc"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"DUMMY"
block|,
name|NULL
block|}
block|,
comment|/* dyn_INITRESOLVE */
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
block|{
name|NULL
block|,
literal|"pthread_create"
block|,
name|PTHREAD_CREATE_VERSION
block|}
block|,
block|{
name|NULL
block|,
literal|"pthread_join"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"pthread_exit"
block|,
name|NULL
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Lookup& manage automatic initialization of the five or so splay trees.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree
name|__mf_object_tree
parameter_list|(
name|int
name|type
parameter_list|)
block|{
specifier|static
name|mfsplay_tree
name|trees
index|[
name|__MF_TYPE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|assert
argument_list|(
name|type
operator|>=
literal|0
operator|&&
name|type
operator|<=
name|__MF_TYPE_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|trees
index|[
name|type
index|]
operator|==
name|NULL
argument_list|)
condition|)
name|trees
index|[
name|type
index|]
operator|=
name|mfsplay_tree_new
argument_list|()
expr_stmt|;
return|return
name|trees
index|[
name|type
index|]
return|;
block|}
end_function

begin_comment
comment|/* not static */
end_comment

begin_function
name|void
name|__mf_init
parameter_list|()
block|{
name|char
modifier|*
name|ov
init|=
literal|0
decl_stmt|;
comment|/* Return if initialization has already been done. */
if|if
condition|(
name|LIKELY
argument_list|(
name|__mf_starting_p
operator|==
literal|0
argument_list|)
condition|)
return|return;
comment|/* This initial bootstrap phase requires that __mf_starting_p = 1. */
ifdef|#
directive|ifdef
name|PIC
name|__mf_resolve_dynamics
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|__mf_starting_p
operator|=
literal|0
expr_stmt|;
name|__mf_set_state
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|__mf_set_default_options
argument_list|()
expr_stmt|;
name|ov
operator|=
name|getenv
argument_list|(
literal|"MUDFLAP_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ov
condition|)
block|{
name|int
name|rc
init|=
name|__mfu_set_options
argument_list|(
name|ov
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|__mf_usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize to a non-zero description epoch. */
name|__mf_describe_object
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
define|#
directive|define
name|REG_RESERVED
parameter_list|(
name|obj
parameter_list|)
define|\
value|__mf_register (& obj, sizeof(obj), __MF_TYPE_NOACCESS, # obj)
name|REG_RESERVED
argument_list|(
name|__mf_lookup_cache
argument_list|)
expr_stmt|;
name|REG_RESERVED
argument_list|(
name|__mf_lc_mask
argument_list|)
expr_stmt|;
name|REG_RESERVED
argument_list|(
name|__mf_lc_shift
argument_list|)
expr_stmt|;
comment|/* XXX: others of our statics?  */
comment|/* Prevent access to *NULL. */
name|__mf_register
argument_list|(
name|MINPTR
argument_list|,
literal|1
argument_list|,
name|__MF_TYPE_NOACCESS
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
name|__mf_lookup_cache
index|[
literal|0
index|]
operator|.
name|low
operator|=
operator|(
name|uintptr_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__wrap_main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|extern
name|int
name|main
parameter_list|()
function_decl|;
specifier|extern
name|int
name|__real_main
parameter_list|()
function_decl|;
specifier|static
name|int
name|been_here
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|heur_std_data
operator|&&
operator|!
name|been_here
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|been_here
operator|=
literal|1
expr_stmt|;
name|__mf_register
argument_list|(
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"argv[]"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|j
init|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|__mf_register
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"argv element"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|e
init|=
name|environ
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
break|break;
name|j
operator|=
name|strlen
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|__mf_register
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"environ element"
argument_list|)
expr_stmt|;
block|}
name|__mf_register
argument_list|(
name|environ
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"environ[]"
argument_list|)
expr_stmt|;
name|__mf_register
argument_list|(
operator|&
name|errno
argument_list|,
sizeof|sizeof
argument_list|(
name|errno
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"errno area"
argument_list|)
expr_stmt|;
name|__mf_register
argument_list|(
name|stdin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stdin
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
name|__mf_register
argument_list|(
name|stdout
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stdout
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
name|__mf_register
argument_list|(
name|stderr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stderr
argument_list|)
argument_list|,
name|__MF_TYPE_STATIC
argument_list|,
literal|"stderr"
argument_list|)
expr_stmt|;
comment|/* Make some effort to register ctype.h static arrays.  */
comment|/* XXX: e.g., on Solaris, may need to register __ctype, _ctype, __ctype_mask, __toupper, etc. */
comment|/* On modern Linux GLIBC, these are thread-specific and changeable, and are dealt          with in mf-hooks2.c.  */
block|}
ifdef|#
directive|ifdef
name|PIC
return|return
name|main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|environ
argument_list|)
return|;
else|#
directive|else
return|return
name|__real_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|environ
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_extern
extern|extern void __mf_fini (
end_extern

begin_expr_stmt
unit|)
name|DTOR
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|__mf_fini
parameter_list|()
block|{
name|TRACE
argument_list|(
literal|"__mf_fini\n"
argument_list|)
expr_stmt|;
name|__mfu_report
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PIC
comment|/* Since we didn't populate the tree for allocations in constructors    before __mf_init, we cannot check destructors after __mf_fini.  */
name|__mf_opts
operator|.
name|mudflap_mode
operator|=
name|mode_nop
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* __mf_check */
end_comment

begin_function
name|void
name|__mf_check
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
block|{
name|LOCKTH
argument_list|()
expr_stmt|;
name|BEGIN_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|__mfu_check
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
name|type
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|END_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__mfu_check
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
block|{
name|unsigned
name|entry_idx
init|=
name|__MF_CACHE_INDEX
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|struct
name|__mf_cache
modifier|*
name|entry
init|=
operator|&
name|__mf_lookup_cache
index|[
name|entry_idx
index|]
decl_stmt|;
name|int
name|judgement
init|=
literal|0
decl_stmt|;
comment|/* 0=undecided;<0=violation;>0=okay */
name|uintptr_t
name|ptr_low
init|=
operator|(
name|uintptr_t
operator|)
name|ptr
decl_stmt|;
name|uintptr_t
name|ptr_high
init|=
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|struct
name|__mf_cache
name|old_entry
init|=
operator|*
name|entry
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|sigusr1_report
argument_list|)
condition|)
name|__mf_sigusr1_respond
argument_list|()
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|ignore_reads
operator|&&
name|type
operator|==
literal|0
argument_list|)
condition|)
return|return;
name|TRACE
argument_list|(
literal|"check ptr=%p b=%u size=%lu %s location=`%s'\n"
argument_list|,
name|ptr
argument_list|,
name|entry_idx
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sz
argument_list|,
operator|(
name|type
operator|==
literal|0
condition|?
literal|"read"
else|:
literal|"write"
operator|)
argument_list|,
name|location
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|__mf_opts
operator|.
name|mudflap_mode
condition|)
block|{
case|case
name|mode_nop
case|:
comment|/* It is tempting to poison the cache here similarly to          mode_populate.  However that eliminates a valuable          distinction between these two modes.  mode_nop is useful to          let a user count& trace every single check / registration          call.  mode_populate is useful to let a program run fast          while unchecked.       */
name|judgement
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|mode_populate
case|:
name|entry
operator|->
name|low
operator|=
name|ptr_low
expr_stmt|;
name|entry
operator|->
name|high
operator|=
name|ptr_high
expr_stmt|;
name|judgement
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|mode_check
case|:
block|{
name|unsigned
name|heuristics
init|=
literal|0
decl_stmt|;
comment|/* Advance aging/adaptation counters.  */
specifier|static
name|unsigned
name|adapt_count
decl_stmt|;
name|adapt_count
operator|++
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|adapt_cache
operator|>
literal|0
operator|&&
name|adapt_count
operator|>
name|__mf_opts
operator|.
name|adapt_cache
argument_list|)
condition|)
block|{
name|adapt_count
operator|=
literal|0
expr_stmt|;
name|__mf_adapt_cache
argument_list|()
expr_stmt|;
block|}
comment|/* Looping only occurs if heuristics were triggered.  */
while|while
condition|(
name|judgement
operator|==
literal|0
condition|)
block|{
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
name|p
argument_list|)
expr_stmt|;
name|__mf_object_t
modifier|*
name|ovr_obj
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|obj_count
decl_stmt|;
name|__mf_object_t
modifier|*
modifier|*
name|all_ovr_obj
init|=
name|NULL
decl_stmt|;
name|__mf_object_t
modifier|*
modifier|*
name|dealloc_me
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Find all overlapping objects.  Be optimistic that there is just one.  */
name|obj_count
operator|=
name|__mf_find_objects
argument_list|(
name|ptr_low
argument_list|,
name|ptr_high
argument_list|,
name|ovr_obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|obj_count
operator|>
literal|1
argument_list|)
condition|)
block|{
comment|/* Allocate a real buffer and do the search again.  */
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t c
argument_list|)
empty_stmt|;
name|unsigned
name|n
decl_stmt|;
name|all_ovr_obj
operator|=
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|__mf_object_t
operator|*
argument_list|)
operator|*
name|obj_count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_ovr_obj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|__mf_find_objects
argument_list|(
name|ptr_low
argument_list|,
name|ptr_high
argument_list|,
name|all_ovr_obj
argument_list|,
name|obj_count
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|n
operator|==
name|obj_count
argument_list|)
expr_stmt|;
name|dealloc_me
operator|=
name|all_ovr_obj
expr_stmt|;
block|}
else|else
block|{
name|all_ovr_obj
operator|=
name|ovr_obj
expr_stmt|;
name|dealloc_me
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Update object statistics.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj_count
condition|;
name|i
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
name|all_ovr_obj
index|[
name|i
index|]
decl_stmt|;
name|assert
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|__MF_CHECK_READ
condition|)
name|obj
operator|->
name|read_count
operator|++
expr_stmt|;
else|else
name|obj
operator|->
name|write_count
operator|++
expr_stmt|;
name|obj
operator|->
name|liveness
operator|++
expr_stmt|;
block|}
comment|/* Iterate over the various objects.  There are a number of special cases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj_count
condition|;
name|i
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
name|all_ovr_obj
index|[
name|i
index|]
decl_stmt|;
comment|/* Any __MF_TYPE_NOACCESS hit is bad.  */
if|if
condition|(
name|UNLIKELY
argument_list|(
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_NOACCESS
argument_list|)
condition|)
name|judgement
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Any object with a watch flag is bad.  */
if|if
condition|(
name|UNLIKELY
argument_list|(
name|obj
operator|->
name|watching_p
argument_list|)
condition|)
name|judgement
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* trigger VIOL_WATCH */
comment|/* A read from an uninitialized object is bad. */
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|check_initialization
comment|/* reading */
operator|&&
name|type
operator|==
name|__MF_CHECK_READ
comment|/* not written */
operator|&&
name|obj
operator|->
name|write_count
operator|==
literal|0
comment|/* uninitialized (heap) */
operator|&&
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP
argument_list|)
condition|)
name|judgement
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We now know that the access spans no invalid objects.  */
if|if
condition|(
name|LIKELY
argument_list|(
name|judgement
operator|>=
literal|0
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj_count
condition|;
name|i
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
name|all_ovr_obj
index|[
name|i
index|]
decl_stmt|;
comment|/* Is this access entirely contained within this object?  */
if|if
condition|(
name|LIKELY
argument_list|(
name|ptr_low
operator|>=
name|obj
operator|->
name|low
operator|&&
name|ptr_high
operator|<=
name|obj
operator|->
name|high
argument_list|)
condition|)
block|{
comment|/* Valid access.  */
name|entry
operator|->
name|low
operator|=
name|obj
operator|->
name|low
expr_stmt|;
name|entry
operator|->
name|high
operator|=
name|obj
operator|->
name|high
expr_stmt|;
name|judgement
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* This access runs off the end of one valid object.  That                 could be okay, if other valid objects fill in all the                 holes.  We allow this only for HEAP and GUESS type                 objects.  Accesses to STATIC and STACK variables                 should not be allowed to span.  */
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|(
name|judgement
operator|==
literal|0
operator|)
operator|&&
operator|(
name|obj_count
operator|>
literal|1
operator|)
argument_list|)
condition|)
block|{
name|unsigned
name|uncovered
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj_count
condition|;
name|i
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
name|all_ovr_obj
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|uncovered_low_p
decl_stmt|,
name|uncovered_high_p
decl_stmt|;
name|uintptr_t
name|ptr_lower
decl_stmt|,
name|ptr_higher
decl_stmt|;
name|uncovered_low_p
operator|=
name|ptr_low
operator|<
name|obj
operator|->
name|low
expr_stmt|;
name|ptr_lower
operator|=
name|CLAMPSUB
argument_list|(
name|obj
operator|->
name|low
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uncovered_high_p
operator|=
name|ptr_high
operator|>
name|obj
operator|->
name|high
expr_stmt|;
name|ptr_higher
operator|=
name|CLAMPADD
argument_list|(
name|obj
operator|->
name|high
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|obj_count
condition|;
name|j
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj2
init|=
name|all_ovr_obj
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
continue|continue;
comment|/* Filter out objects that cannot be spanned across.  */
if|if
condition|(
name|obj2
operator|->
name|type
operator|==
name|__MF_TYPE_STACK
operator|||
name|obj2
operator|->
name|type
operator|==
name|__MF_TYPE_STATIC
condition|)
continue|continue;
comment|/* Consider a side "covered" if obj2 includes                              the next byte on that side.  */
if|if
condition|(
name|uncovered_low_p
operator|&&
operator|(
name|ptr_lower
operator|>=
name|obj2
operator|->
name|low
operator|&&
name|ptr_lower
operator|<=
name|obj2
operator|->
name|high
operator|)
condition|)
name|uncovered_low_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uncovered_high_p
operator|&&
operator|(
name|ptr_high
operator|>=
name|obj2
operator|->
name|low
operator|&&
name|ptr_higher
operator|<=
name|obj2
operator|->
name|high
operator|)
condition|)
name|uncovered_high_p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|uncovered_low_p
operator|||
name|uncovered_high_p
condition|)
name|uncovered
operator|++
expr_stmt|;
block|}
comment|/* Success if no overlapping objects are uncovered.  */
if|if
condition|(
name|uncovered
operator|==
literal|0
condition|)
name|judgement
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dealloc_me
operator|!=
name|NULL
condition|)
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|dealloc_me
argument_list|)
expr_stmt|;
comment|/* If the judgment is still unknown at this stage, loop                around at most one more time.  */
if|if
condition|(
name|judgement
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|heuristics
operator|++
operator|<
literal|2
condition|)
comment|/* XXX parametrize this number? */
name|judgement
operator|=
name|__mf_heuristic_check
argument_list|(
name|ptr_low
argument_list|,
name|ptr_high
argument_list|)
expr_stmt|;
else|else
name|judgement
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|mode_violate
case|:
name|judgement
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__mf_opts
operator|.
name|collect_stats
condition|)
block|{
name|__mf_count_check
operator|++
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|old_entry
operator|.
name|low
operator|!=
name|entry
operator|->
name|low
operator|||
name|old_entry
operator|.
name|high
operator|!=
name|entry
operator|->
name|high
argument_list|)
condition|)
comment|/*&& (old_entry.low != 0)&& (old_entry.high != 0)) */
name|__mf_lookup_cache_reusecount
index|[
name|entry_idx
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|UNLIKELY
argument_list|(
name|judgement
operator|<
literal|0
argument_list|)
condition|)
name|__mf_violation
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|,
name|location
argument_list|,
operator|(
operator|(
name|judgement
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|type
operator|==
name|__MF_CHECK_READ
condition|?
name|__MF_VIOL_READ
else|:
name|__MF_VIOL_WRITE
operator|)
else|:
name|__MF_VIOL_WATCH
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__mf_object_t
modifier|*
name|__mf_insert_new_object
parameter_list|(
name|uintptr_t
name|low
parameter_list|,
name|uintptr_t
name|high
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uintptr_t
name|pc
parameter_list|)
block|{
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|calloc
argument_list|,
argument|size_t c
argument_list|,
argument|size_t n
argument_list|)
empty_stmt|;
name|__mf_object_t
modifier|*
name|new_obj
decl_stmt|;
name|new_obj
operator|=
name|CALL_REAL
argument_list|(
name|calloc
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|__mf_object_t
argument_list|)
argument_list|)
expr_stmt|;
name|new_obj
operator|->
name|low
operator|=
name|low
expr_stmt|;
name|new_obj
operator|->
name|high
operator|=
name|high
expr_stmt|;
name|new_obj
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new_obj
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new_obj
operator|->
name|alloc_pc
operator|=
name|pc
expr_stmt|;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
if|if
condition|(
name|__mf_opts
operator|.
name|timestamps
condition|)
name|gettimeofday
argument_list|(
operator|&
name|new_obj
operator|->
name|alloc_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|LIBMUDFLAPTH
name|new_obj
operator|->
name|alloc_thread
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__mf_opts
operator|.
name|backtrace
operator|>
literal|0
operator|&&
operator|(
name|type
operator|==
name|__MF_TYPE_HEAP
operator|||
name|type
operator|==
name|__MF_TYPE_HEAP_I
operator|)
condition|)
name|new_obj
operator|->
name|alloc_backtrace_size
operator|=
name|__mf_backtrace
argument_list|(
operator|&
name|new_obj
operator|->
name|alloc_backtrace
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|__mf_link_object
argument_list|(
name|new_obj
argument_list|)
expr_stmt|;
return|return
name|new_obj
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__mf_uncache_object
parameter_list|(
name|__mf_object_t
modifier|*
name|old_obj
parameter_list|)
block|{
comment|/* Remove any low/high pointers for this object from the lookup cache.  */
comment|/* Can it possibly exist in the cache?  */
if|if
condition|(
name|LIKELY
argument_list|(
name|old_obj
operator|->
name|read_count
operator|+
name|old_obj
operator|->
name|write_count
argument_list|)
condition|)
block|{
comment|/* As reported by Herman ten Brugge, we need to scan the entire          cache for entries that may hit this object. */
name|uintptr_t
name|low
init|=
name|old_obj
operator|->
name|low
decl_stmt|;
name|uintptr_t
name|high
init|=
name|old_obj
operator|->
name|high
decl_stmt|;
name|struct
name|__mf_cache
modifier|*
name|entry
init|=
operator|&
name|__mf_lookup_cache
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|__mf_lc_mask
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
comment|/* NB: the "||" in the following test permits this code to              tolerate the situation introduced by __mf_check over              contiguous objects, where a cache entry spans several              objects.  */
if|if
condition|(
name|entry
operator|->
name|low
operator|==
name|low
operator|||
name|entry
operator|->
name|high
operator|==
name|high
condition|)
block|{
name|entry
operator|->
name|low
operator|=
name|MAXPTR
expr_stmt|;
name|entry
operator|->
name|high
operator|=
name|MINPTR
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|__mf_register
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|LOCKTH
argument_list|()
expr_stmt|;
name|BEGIN_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|__mfu_register
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|END_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__mfu_register
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|TRACE
argument_list|(
literal|"register ptr=%p size=%lu type=%x name='%s'\n"
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sz
argument_list|,
name|type
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|collect_stats
condition|)
block|{
name|__mf_count_register
operator|++
expr_stmt|;
name|__mf_total_register_size
index|[
operator|(
name|type
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|type
operator|>
name|__MF_TYPE_MAX
operator|)
condition|?
literal|0
else|:
name|type
index|]
operator|+=
name|sz
expr_stmt|;
block|}
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|sigusr1_report
argument_list|)
condition|)
name|__mf_sigusr1_respond
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|__mf_opts
operator|.
name|mudflap_mode
condition|)
block|{
case|case
name|mode_nop
case|:
break|break;
case|case
name|mode_violate
case|:
name|__mf_violation
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|__MF_VIOL_REGISTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|mode_populate
case|:
comment|/* Clear the cache.  */
comment|/* XXX: why the entire cache? */
comment|/* XXX: race */
name|memset
argument_list|(
name|__mf_lookup_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|__mf_lookup_cache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* void slot 0 */
name|__mf_lookup_cache
index|[
literal|0
index|]
operator|.
name|low
operator|=
name|MAXPTR
expr_stmt|;
break|break;
case|case
name|mode_check
case|:
block|{
name|__mf_object_t
modifier|*
name|ovr_objs
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|num_overlapping_objs
decl_stmt|;
name|uintptr_t
name|low
init|=
operator|(
name|uintptr_t
operator|)
name|ptr
decl_stmt|;
name|uintptr_t
name|high
init|=
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|uintptr_t
name|pc
init|=
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* Treat unknown size indication as 1.  */
if|if
condition|(
name|UNLIKELY
argument_list|(
name|sz
operator|==
literal|0
argument_list|)
condition|)
name|sz
operator|=
literal|1
expr_stmt|;
comment|/* Look for objects only of the same type.  This will e.g. permit a registration            of a STATIC overlapping with a GUESS, and a HEAP with a NOACCESS.  At            __mf_check time however harmful overlaps will be detected. */
name|num_overlapping_objs
operator|=
name|__mf_find_objects2
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|ovr_objs
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Handle overlaps.  */
if|if
condition|(
name|UNLIKELY
argument_list|(
name|num_overlapping_objs
operator|>
literal|0
argument_list|)
condition|)
block|{
name|__mf_object_t
modifier|*
name|ovr_obj
init|=
name|ovr_objs
index|[
literal|0
index|]
decl_stmt|;
comment|/* Accept certain specific duplication pairs.  */
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|__MF_TYPE_STATIC
operator|)
operator|||
operator|(
name|type
operator|==
name|__MF_TYPE_GUESS
operator|)
operator|)
operator|&&
name|ovr_obj
operator|->
name|low
operator|==
name|low
operator|&&
name|ovr_obj
operator|->
name|high
operator|==
name|high
operator|&&
name|ovr_obj
operator|->
name|type
operator|==
name|type
condition|)
block|{
comment|/* Duplicate registration for static objects may come                    from distinct compilation units.  */
name|VERBOSE_TRACE
argument_list|(
literal|"harmless duplicate reg %p-%p `%s'\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|low
argument_list|,
operator|(
name|void
operator|*
operator|)
name|high
argument_list|,
operator|(
name|ovr_obj
operator|->
name|name
condition|?
name|ovr_obj
operator|->
name|name
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Alas, a genuine violation.  */
else|else
block|{
comment|/* Two or more *real* mappings here. */
name|__mf_violation
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
name|sz
argument_list|,
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|__MF_VIOL_REGISTER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* No overlapping objects: AOK.  */
name|__mf_insert_new_object
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* We could conceivably call __mf_check() here to prime the cache,            but then the read_count/write_count field is not reliable.  */
break|break;
block|}
block|}
comment|/* end switch (__mf_opts.mudflap_mode) */
block|}
end_function

begin_function
name|void
name|__mf_unregister
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|LOCKTH
argument_list|()
expr_stmt|;
name|BEGIN_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|__mfu_unregister
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|END_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__mfu_unregister
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|sigusr1_report
argument_list|)
condition|)
name|__mf_sigusr1_respond
argument_list|()
expr_stmt|;
name|TRACE
argument_list|(
literal|"unregister ptr=%p size=%lu type=%x\n"
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sz
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|__mf_opts
operator|.
name|mudflap_mode
condition|)
block|{
case|case
name|mode_nop
case|:
break|break;
case|case
name|mode_violate
case|:
name|__mf_violation
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|__MF_VIOL_UNREGISTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|mode_populate
case|:
comment|/* Clear the cache.  */
comment|/* XXX: race */
name|memset
argument_list|(
name|__mf_lookup_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|__mf_lookup_cache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* void slot 0 */
name|__mf_lookup_cache
index|[
literal|0
index|]
operator|.
name|low
operator|=
name|MAXPTR
expr_stmt|;
break|break;
case|case
name|mode_check
case|:
block|{
name|__mf_object_t
modifier|*
name|old_obj
init|=
name|NULL
decl_stmt|;
name|__mf_object_t
modifier|*
name|del_obj
init|=
name|NULL
decl_stmt|;
comment|/* Object to actually delete. */
name|__mf_object_t
modifier|*
name|objs
index|[
literal|1
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|unsigned
name|num_overlapping_objs
decl_stmt|;
name|num_overlapping_objs
operator|=
name|__mf_find_objects2
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
argument_list|,
name|objs
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Special case for HEAP_I - see free& realloc hook.  They don't            know whether the input region was HEAP or HEAP_I before            unmapping it.  Here we give HEAP a try in case HEAP_I            failed.  */
if|if
condition|(
operator|(
name|type
operator|==
name|__MF_TYPE_HEAP_I
operator|)
operator|&&
operator|(
name|num_overlapping_objs
operator|==
literal|0
operator|)
condition|)
block|{
name|num_overlapping_objs
operator|=
name|__mf_find_objects2
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
argument_list|,
name|objs
argument_list|,
literal|1
argument_list|,
name|__MF_TYPE_HEAP
argument_list|)
expr_stmt|;
block|}
name|old_obj
operator|=
name|objs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|(
name|num_overlapping_objs
operator|!=
literal|1
operator|)
comment|/* more than one overlap */
operator|||
operator|(
operator|(
name|sz
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|sz
operator|!=
operator|(
name|old_obj
operator|->
name|high
operator|-
name|old_obj
operator|->
name|low
operator|+
literal|1
operator|)
operator|)
operator|)
comment|/* size mismatch */
operator|||
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|!=
name|old_obj
operator|->
name|low
operator|)
argument_list|)
condition|)
comment|/* base mismatch */
block|{
name|__mf_violation
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|__MF_VIOL_UNREGISTER
argument_list|)
expr_stmt|;
break|break;
block|}
name|__mf_unlink_object
argument_list|(
name|old_obj
argument_list|)
expr_stmt|;
name|__mf_uncache_object
argument_list|(
name|old_obj
argument_list|)
expr_stmt|;
comment|/* Wipe buffer contents if desired.  */
if|if
condition|(
operator|(
name|__mf_opts
operator|.
name|wipe_stack
operator|&&
name|old_obj
operator|->
name|type
operator|==
name|__MF_TYPE_STACK
operator|)
operator|||
operator|(
name|__mf_opts
operator|.
name|wipe_heap
operator|&&
operator|(
name|old_obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP
operator|||
name|old_obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP_I
operator|)
operator|)
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|old_obj
operator|->
name|low
argument_list|,
literal|0
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|old_obj
operator|->
name|high
operator|-
name|old_obj
operator|->
name|low
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Manage the object cemetary.  */
if|if
condition|(
name|__mf_opts
operator|.
name|persistent_count
operator|>
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|old_obj
operator|->
name|type
operator|<=
name|__MF_TYPE_MAX_CEM
condition|)
block|{
name|old_obj
operator|->
name|deallocated_p
operator|=
literal|1
expr_stmt|;
name|old_obj
operator|->
name|dealloc_pc
operator|=
operator|(
name|uintptr_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
if|if
condition|(
name|__mf_opts
operator|.
name|timestamps
condition|)
name|gettimeofday
argument_list|(
operator|&
name|old_obj
operator|->
name|dealloc_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
name|old_obj
operator|->
name|dealloc_thread
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__mf_opts
operator|.
name|backtrace
operator|>
literal|0
operator|&&
name|old_obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP
condition|)
name|old_obj
operator|->
name|dealloc_backtrace_size
operator|=
name|__mf_backtrace
argument_list|(
operator|&
name|old_obj
operator|->
name|dealloc_backtrace
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Encourage this object to be displayed again in current epoch.  */
name|old_obj
operator|->
name|description_epoch
operator|--
expr_stmt|;
comment|/* Put this object into the cemetary.  This may require this plot to                be recycled, and the previous resident to be designated del_obj.  */
block|{
name|unsigned
name|row
init|=
name|old_obj
operator|->
name|type
decl_stmt|;
name|unsigned
name|plot
init|=
name|__mf_object_dead_head
index|[
name|row
index|]
decl_stmt|;
name|del_obj
operator|=
name|__mf_object_cemetary
index|[
name|row
index|]
index|[
name|plot
index|]
expr_stmt|;
name|__mf_object_cemetary
index|[
name|row
index|]
index|[
name|plot
index|]
operator|=
name|old_obj
expr_stmt|;
name|plot
operator|++
expr_stmt|;
if|if
condition|(
name|plot
operator|==
name|__mf_opts
operator|.
name|persistent_count
condition|)
name|plot
operator|=
literal|0
expr_stmt|;
name|__mf_object_dead_head
index|[
name|row
index|]
operator|=
name|plot
expr_stmt|;
block|}
block|}
else|else
name|del_obj
operator|=
name|old_obj
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|print_leaks
condition|)
block|{
if|if
condition|(
operator|(
name|old_obj
operator|->
name|read_count
operator|+
name|old_obj
operator|->
name|write_count
operator|)
operator|==
literal|0
operator|&&
operator|(
name|old_obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP
operator|||
name|old_obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP_I
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*******\n"
literal|"mudflap warning: unaccessed registered object:\n"
argument_list|)
expr_stmt|;
name|__mf_describe_object
argument_list|(
name|old_obj
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|del_obj
operator|!=
name|NULL
condition|)
comment|/* May or may not equal old_obj.  */
block|{
if|if
condition|(
name|__mf_opts
operator|.
name|backtrace
operator|>
literal|0
condition|)
block|{
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|del_obj
operator|->
name|alloc_backtrace
argument_list|)
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|persistent_count
operator|>
literal|0
condition|)
block|{
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|del_obj
operator|->
name|dealloc_backtrace
argument_list|)
expr_stmt|;
block|}
block|}
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|del_obj
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* end switch (__mf_opts.mudflap_mode) */
if|if
condition|(
name|__mf_opts
operator|.
name|collect_stats
condition|)
block|{
name|__mf_count_unregister
operator|++
expr_stmt|;
name|__mf_total_unregister_size
operator|+=
name|sz
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|tree_stats
block|{
name|unsigned
name|obj_count
decl_stmt|;
name|unsigned
name|long
name|total_size
decl_stmt|;
name|unsigned
name|live_obj_count
decl_stmt|;
name|double
name|total_weight
decl_stmt|;
name|double
name|weighted_size
decl_stmt|;
name|unsigned
name|long
name|weighted_address_bits
index|[
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
literal|8
index|]
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|__mf_adapt_cache_fn
parameter_list|(
name|mfsplay_tree_node
name|n
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
operator|(
name|__mf_object_t
operator|*
operator|)
name|n
operator|->
name|value
decl_stmt|;
name|struct
name|tree_stats
modifier|*
name|s
init|=
operator|(
expr|struct
name|tree_stats
operator|*
operator|)
name|param
decl_stmt|;
name|assert
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Exclude never-accessed objects.  */
if|if
condition|(
name|obj
operator|->
name|read_count
operator|+
name|obj
operator|->
name|write_count
condition|)
block|{
name|s
operator|->
name|obj_count
operator|++
expr_stmt|;
name|s
operator|->
name|total_size
operator|+=
operator|(
name|obj
operator|->
name|high
operator|-
name|obj
operator|->
name|low
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|liveness
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|uintptr_t
name|addr
decl_stmt|;
comment|/* VERBOSE_TRACE ("analyze low=%p live=%u name=`%s'\n",              (void *) obj->low, obj->liveness, obj->name); */
name|s
operator|->
name|live_obj_count
operator|++
expr_stmt|;
name|s
operator|->
name|total_weight
operator|+=
operator|(
name|double
operator|)
name|obj
operator|->
name|liveness
expr_stmt|;
name|s
operator|->
name|weighted_size
operator|+=
call|(
name|double
call|)
argument_list|(
name|obj
operator|->
name|high
operator|-
name|obj
operator|->
name|low
operator|+
literal|1
argument_list|)
operator|*
operator|(
name|double
operator|)
name|obj
operator|->
name|liveness
expr_stmt|;
name|addr
operator|=
name|obj
operator|->
name|low
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|bit
init|=
name|addr
operator|&
literal|1
decl_stmt|;
name|s
operator|->
name|weighted_address_bits
index|[
name|i
index|]
index|[
name|bit
index|]
operator|+=
name|obj
operator|->
name|liveness
expr_stmt|;
name|addr
operator|=
name|addr
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* Age the liveness value.  */
name|obj
operator|->
name|liveness
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__mf_adapt_cache
parameter_list|()
block|{
name|struct
name|tree_stats
name|s
decl_stmt|;
name|uintptr_t
name|new_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|new_shift
decl_stmt|;
name|float
name|cache_utilization
decl_stmt|;
name|float
name|max_value
decl_stmt|;
specifier|static
name|float
name|smoothed_new_shift
init|=
operator|-
literal|1.0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_HEAP
argument_list|)
argument_list|,
name|__mf_adapt_cache_fn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_HEAP_I
argument_list|)
argument_list|,
name|__mf_adapt_cache_fn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_STACK
argument_list|)
argument_list|,
name|__mf_adapt_cache_fn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_STATIC
argument_list|)
argument_list|,
name|__mf_adapt_cache_fn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_GUESS
argument_list|)
argument_list|,
name|__mf_adapt_cache_fn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Maybe we're dealing with funny aging/adaptation parameters, or an      empty tree.  Just leave the cache alone in such cases, rather      than risk dying by division-by-zero.  */
if|if
condition|(
operator|!
operator|(
name|s
operator|.
name|obj_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|.
name|live_obj_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|.
name|total_weight
operator|>
literal|0.0
operator|)
condition|)
return|return;
comment|/* Guess a good value for the shift parameter by finding an address bit that is a      good discriminant of lively objects.  */
name|max_value
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|float
name|value
init|=
operator|(
name|float
operator|)
name|s
operator|.
name|weighted_address_bits
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|float
operator|)
name|s
operator|.
name|weighted_address_bits
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|max_value
operator|<
name|value
condition|)
name|max_value
operator|=
name|value
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|float
name|shoulder_factor
init|=
literal|0.7
decl_stmt|;
comment|/* Include slightly less popular bits too.  */
name|float
name|value
init|=
operator|(
name|float
operator|)
name|s
operator|.
name|weighted_address_bits
index|[
name|i
index|]
index|[
literal|0
index|]
operator|*
operator|(
name|float
operator|)
name|s
operator|.
name|weighted_address_bits
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|value
operator|>=
name|max_value
operator|*
name|shoulder_factor
condition|)
break|break;
block|}
if|if
condition|(
name|smoothed_new_shift
operator|<
literal|0
condition|)
name|smoothed_new_shift
operator|=
name|__mf_lc_shift
expr_stmt|;
comment|/* Converge toward this slowly to reduce flapping. */
name|smoothed_new_shift
operator|=
literal|0.9
operator|*
name|smoothed_new_shift
operator|+
literal|0.1
operator|*
name|i
expr_stmt|;
name|new_shift
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|smoothed_new_shift
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new_shift
operator|<
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Count number of used buckets.  */
name|cache_utilization
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|+
name|__mf_lc_mask
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|__mf_lookup_cache
index|[
name|i
index|]
operator|.
name|low
operator|!=
literal|0
operator|||
name|__mf_lookup_cache
index|[
name|i
index|]
operator|.
name|high
operator|!=
literal|0
condition|)
name|cache_utilization
operator|+=
literal|1.0
expr_stmt|;
name|cache_utilization
operator|/=
operator|(
literal|1
operator|+
name|__mf_lc_mask
operator|)
expr_stmt|;
name|new_mask
operator||=
literal|0xffff
expr_stmt|;
comment|/* XXX: force a large cache.  */
name|new_mask
operator|&=
operator|(
name|LOOKUP_CACHE_SIZE_MAX
operator|-
literal|1
operator|)
expr_stmt|;
name|VERBOSE_TRACE
argument_list|(
literal|"adapt cache obj=%u/%u sizes=%lu/%.0f/%.0f => "
literal|"util=%u%% m=%p s=%u\n"
argument_list|,
name|s
operator|.
name|obj_count
argument_list|,
name|s
operator|.
name|live_obj_count
argument_list|,
name|s
operator|.
name|total_size
argument_list|,
name|s
operator|.
name|total_weight
argument_list|,
name|s
operator|.
name|weighted_size
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cache_utilization
operator|*
literal|100.0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_mask
argument_list|,
name|new_shift
argument_list|)
expr_stmt|;
comment|/* We should reinitialize cache if its parameters have changed.  */
if|if
condition|(
name|new_mask
operator|!=
name|__mf_lc_mask
operator|||
name|new_shift
operator|!=
name|__mf_lc_shift
condition|)
block|{
name|__mf_lc_mask
operator|=
name|new_mask
expr_stmt|;
name|__mf_lc_shift
operator|=
name|new_shift
expr_stmt|;
comment|/* XXX: race */
name|memset
argument_list|(
name|__mf_lookup_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|__mf_lookup_cache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* void slot 0 */
name|__mf_lookup_cache
index|[
literal|0
index|]
operator|.
name|low
operator|=
name|MAXPTR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* __mf_find_object[s] */
end_comment

begin_comment
comment|/* Find overlapping live objecs between [low,high].  Return up to    max_objs of their pointers in objs[].  Return total count of    overlaps (may exceed max_objs). */
end_comment

begin_function
name|unsigned
name|__mf_find_objects2
parameter_list|(
name|uintptr_t
name|ptr_low
parameter_list|,
name|uintptr_t
name|ptr_high
parameter_list|,
name|__mf_object_t
modifier|*
modifier|*
name|objs
parameter_list|,
name|unsigned
name|max_objs
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|mfsplay_tree
name|t
init|=
name|__mf_object_tree
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mfsplay_tree_key
name|k
init|=
operator|(
name|mfsplay_tree_key
operator|)
name|ptr_low
decl_stmt|;
name|int
name|direction
decl_stmt|;
name|mfsplay_tree_node
name|n
init|=
name|mfsplay_tree_lookup
argument_list|(
name|t
argument_list|,
name|k
argument_list|)
decl_stmt|;
comment|/* An exact match for base address implies a hit.  */
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|max_objs
condition|)
name|objs
index|[
name|count
index|]
operator|=
operator|(
name|__mf_object_t
operator|*
operator|)
name|n
operator|->
name|value
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Iterate left then right near this key value to find all overlapping objects. */
for|for
control|(
name|direction
operator|=
literal|0
init|;
name|direction
operator|<
literal|2
condition|;
name|direction
operator|++
control|)
block|{
comment|/* Reset search origin.  */
name|k
operator|=
operator|(
name|mfsplay_tree_key
operator|)
name|ptr_low
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|__mf_object_t
modifier|*
name|obj
decl_stmt|;
name|n
operator|=
operator|(
name|direction
operator|==
literal|0
condition|?
name|mfsplay_tree_successor
argument_list|(
name|t
argument_list|,
name|k
argument_list|)
else|:
name|mfsplay_tree_predecessor
argument_list|(
name|t
argument_list|,
name|k
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
name|obj
operator|=
operator|(
name|__mf_object_t
operator|*
operator|)
name|n
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|low
operator|<=
name|ptr_high
operator|&&
name|obj
operator|->
name|high
operator|>=
name|ptr_low
operator|)
condition|)
comment|/* No overlap? */
break|break;
if|if
condition|(
name|count
operator|<
name|max_objs
condition|)
name|objs
index|[
name|count
index|]
operator|=
operator|(
name|__mf_object_t
operator|*
operator|)
name|n
operator|->
name|value
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|k
operator|=
operator|(
name|mfsplay_tree_key
operator|)
name|obj
operator|->
name|low
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|unsigned
name|__mf_find_objects
parameter_list|(
name|uintptr_t
name|ptr_low
parameter_list|,
name|uintptr_t
name|ptr_high
parameter_list|,
name|__mf_object_t
modifier|*
modifier|*
name|objs
parameter_list|,
name|unsigned
name|max_objs
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
comment|/* Search each splay tree for overlaps.  */
for|for
control|(
name|type
operator|=
name|__MF_TYPE_NOACCESS
init|;
name|type
operator|<=
name|__MF_TYPE_GUESS
condition|;
name|type
operator|++
control|)
block|{
name|unsigned
name|c
init|=
name|__mf_find_objects2
argument_list|(
name|ptr_low
argument_list|,
name|ptr_high
argument_list|,
name|objs
argument_list|,
name|max_objs
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|>
name|max_objs
condition|)
block|{
name|max_objs
operator|=
literal|0
expr_stmt|;
name|objs
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* NB: C may equal 0 */
block|{
name|max_objs
operator|-=
name|c
expr_stmt|;
name|objs
operator|+=
name|c
expr_stmt|;
block|}
name|count
operator|+=
name|c
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* __mf_link_object */
end_comment

begin_function
specifier|static
name|void
name|__mf_link_object
parameter_list|(
name|__mf_object_t
modifier|*
name|node
parameter_list|)
block|{
name|mfsplay_tree
name|t
init|=
name|__mf_object_tree
argument_list|(
name|node
operator|->
name|type
argument_list|)
decl_stmt|;
name|mfsplay_tree_insert
argument_list|(
name|t
argument_list|,
operator|(
name|mfsplay_tree_key
operator|)
name|node
operator|->
name|low
argument_list|,
operator|(
name|mfsplay_tree_value
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __mf_unlink_object */
end_comment

begin_function
specifier|static
name|void
name|__mf_unlink_object
parameter_list|(
name|__mf_object_t
modifier|*
name|node
parameter_list|)
block|{
name|mfsplay_tree
name|t
init|=
name|__mf_object_tree
argument_list|(
name|node
operator|->
name|type
argument_list|)
decl_stmt|;
name|mfsplay_tree_remove
argument_list|(
name|t
argument_list|,
operator|(
name|mfsplay_tree_key
operator|)
name|node
operator|->
name|low
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __mf_find_dead_objects */
end_comment

begin_comment
comment|/* Find overlapping dead objecs between [low,high].  Return up to    max_objs of their pointers in objs[].  Return total count of    overlaps (may exceed max_objs).  */
end_comment

begin_function
specifier|static
name|unsigned
name|__mf_find_dead_objects
parameter_list|(
name|uintptr_t
name|low
parameter_list|,
name|uintptr_t
name|high
parameter_list|,
name|__mf_object_t
modifier|*
modifier|*
name|objs
parameter_list|,
name|unsigned
name|max_objs
parameter_list|)
block|{
if|if
condition|(
name|__mf_opts
operator|.
name|persistent_count
operator|>
literal|0
condition|)
block|{
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|recollection
init|=
literal|0
decl_stmt|;
name|unsigned
name|row
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|low
operator|<=
name|high
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|max_objs
operator|==
literal|0
operator|||
name|objs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Widen the search from the most recent plots in each row, looking          backward in time.  */
name|recollection
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|recollection
operator|<
name|__mf_opts
operator|.
name|persistent_count
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<=
name|__MF_TYPE_MAX_CEM
condition|;
name|row
operator|++
control|)
block|{
name|unsigned
name|plot
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|plot
operator|=
name|__mf_object_dead_head
index|[
name|row
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|recollection
condition|;
name|i
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
decl_stmt|;
comment|/* Look backward through row: it's a circular buffer.  */
if|if
condition|(
name|plot
operator|>
literal|0
condition|)
name|plot
operator|--
expr_stmt|;
else|else
name|plot
operator|=
name|__mf_opts
operator|.
name|persistent_count
operator|-
literal|1
expr_stmt|;
name|obj
operator|=
name|__mf_object_cemetary
index|[
name|row
index|]
index|[
name|plot
index|]
expr_stmt|;
if|if
condition|(
name|obj
operator|&&
name|obj
operator|->
name|low
operator|<=
name|high
operator|&&
name|obj
operator|->
name|high
operator|>=
name|low
condition|)
block|{
comment|/* Found an overlapping dead object!  */
if|if
condition|(
name|count
operator|<
name|max_objs
condition|)
name|objs
index|[
name|count
index|]
operator|=
name|obj
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
condition|)
break|break;
comment|/* Look farther back in time.  */
name|recollection
operator|=
operator|(
name|recollection
operator|*
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* __mf_describe_object */
end_comment

begin_function
specifier|static
name|void
name|__mf_describe_object
parameter_list|(
name|__mf_object_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|static
name|unsigned
name|epoch
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|epoch
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|__mf_opts
operator|.
name|abbreviate
operator|&&
name|obj
operator|->
name|description_epoch
operator|==
name|epoch
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mudflap %sobject %p: name=`%s'\n"
argument_list|,
operator|(
name|obj
operator|->
name|deallocated_p
condition|?
literal|"dead "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
argument_list|,
operator|(
name|obj
operator|->
name|name
condition|?
name|obj
operator|->
name|name
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|obj
operator|->
name|description_epoch
operator|=
name|epoch
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mudflap %sobject %p: name=`%s'\n"
literal|"bounds=[%p,%p] size=%lu area=%s check=%ur/%uw liveness=%u%s\n"
literal|"alloc time=%lu.%06lu pc=%p"
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
literal|" thread=%u"
endif|#
directive|endif
literal|"\n"
argument_list|,
operator|(
name|obj
operator|->
name|deallocated_p
condition|?
literal|"dead "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
argument_list|,
operator|(
name|obj
operator|->
name|name
condition|?
name|obj
operator|->
name|name
else|:
literal|""
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
operator|->
name|low
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
operator|->
name|high
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|obj
operator|->
name|high
operator|-
name|obj
operator|->
name|low
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_NOACCESS
condition|?
literal|"no-access"
else|:
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP
condition|?
literal|"heap"
else|:
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_HEAP_I
condition|?
literal|"heap-init"
else|:
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_STACK
condition|?
literal|"stack"
else|:
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_STATIC
condition|?
literal|"static"
else|:
name|obj
operator|->
name|type
operator|==
name|__MF_TYPE_GUESS
condition|?
literal|"guess"
else|:
literal|"unknown"
operator|)
argument_list|,
name|obj
operator|->
name|read_count
argument_list|,
name|obj
operator|->
name|write_count
argument_list|,
name|obj
operator|->
name|liveness
argument_list|,
name|obj
operator|->
name|watching_p
condition|?
literal|" watching"
else|:
literal|""
argument_list|,
name|obj
operator|->
name|alloc_time
operator|.
name|tv_sec
argument_list|,
name|obj
operator|->
name|alloc_time
operator|.
name|tv_usec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
operator|->
name|alloc_pc
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
argument_list|,
operator|(
name|unsigned
operator|)
name|obj
operator|->
name|alloc_thread
endif|#
directive|endif
argument_list|)
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|backtrace
operator|>
literal|0
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj
operator|->
name|alloc_backtrace_size
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      %s\n"
argument_list|,
name|obj
operator|->
name|alloc_backtrace
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__mf_opts
operator|.
name|persistent_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|deallocated_p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dealloc time=%lu.%06lu pc=%p"
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
literal|" thread=%u"
endif|#
directive|endif
literal|"\n"
argument_list|,
name|obj
operator|->
name|dealloc_time
operator|.
name|tv_sec
argument_list|,
name|obj
operator|->
name|dealloc_time
operator|.
name|tv_usec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
operator|->
name|dealloc_pc
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
argument_list|,
operator|(
name|unsigned
operator|)
name|obj
operator|->
name|dealloc_thread
endif|#
directive|endif
argument_list|)
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|backtrace
operator|>
literal|0
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj
operator|->
name|dealloc_backtrace_size
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      %s\n"
argument_list|,
name|obj
operator|->
name|dealloc_backtrace
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|__mf_report_leaks_fn
parameter_list|(
name|mfsplay_tree_node
name|n
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|__mf_object_t
modifier|*
name|node
init|=
operator|(
name|__mf_object_t
operator|*
operator|)
name|n
operator|->
name|value
decl_stmt|;
name|unsigned
modifier|*
name|count
init|=
operator|(
name|unsigned
operator|*
operator|)
name|param
decl_stmt|;
if|if
condition|(
name|count
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Leaked object %u:\n"
argument_list|,
operator|(
operator|*
name|count
operator|)
argument_list|)
expr_stmt|;
name|__mf_describe_object
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|__mf_report_leaks
parameter_list|()
block|{
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_HEAP
argument_list|)
argument_list|,
name|__mf_report_leaks_fn
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mfsplay_tree_foreach
argument_list|(
name|__mf_object_tree
argument_list|(
name|__MF_TYPE_HEAP_I
argument_list|)
argument_list|,
name|__mf_report_leaks_fn
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* __mf_report */
end_comment

begin_function
name|void
name|__mf_report
parameter_list|()
block|{
name|LOCKTH
argument_list|()
expr_stmt|;
name|BEGIN_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|__mfu_report
argument_list|()
expr_stmt|;
name|END_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__mfu_report
parameter_list|()
block|{
if|if
condition|(
name|__mf_opts
operator|.
name|collect_stats
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*******\n"
literal|"mudflap stats:\n"
literal|"calls to __mf_check: %lu\n"
literal|"         __mf_register: %lu [%luB, %luB, %luB, %luB, %luB]\n"
literal|"         __mf_unregister: %lu [%luB]\n"
literal|"         __mf_violation: [%lu, %lu, %lu, %lu, %lu]\n"
argument_list|,
name|__mf_count_check
argument_list|,
name|__mf_count_register
argument_list|,
name|__mf_total_register_size
index|[
literal|0
index|]
argument_list|,
name|__mf_total_register_size
index|[
literal|1
index|]
argument_list|,
name|__mf_total_register_size
index|[
literal|2
index|]
argument_list|,
name|__mf_total_register_size
index|[
literal|3
index|]
argument_list|,
name|__mf_total_register_size
index|[
literal|4
index|]
argument_list|,
comment|/* XXX */
name|__mf_count_unregister
argument_list|,
name|__mf_total_unregister_size
argument_list|,
name|__mf_count_violation
index|[
literal|0
index|]
argument_list|,
name|__mf_count_violation
index|[
literal|1
index|]
argument_list|,
name|__mf_count_violation
index|[
literal|2
index|]
argument_list|,
name|__mf_count_violation
index|[
literal|3
index|]
argument_list|,
name|__mf_count_violation
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"calls with reentrancy: %lu\n"
argument_list|,
name|__mf_reentrancy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"           lock contention: %lu\n"
argument_list|,
name|__mf_lock_contention
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Lookup cache stats.  */
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|max_reuse
init|=
literal|0
decl_stmt|;
name|unsigned
name|num_used
init|=
literal|0
decl_stmt|;
name|unsigned
name|num_unused
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOKUP_CACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|__mf_lookup_cache_reusecount
index|[
name|i
index|]
condition|)
name|num_used
operator|++
expr_stmt|;
else|else
name|num_unused
operator|++
expr_stmt|;
if|if
condition|(
name|max_reuse
operator|<
name|__mf_lookup_cache_reusecount
index|[
name|i
index|]
condition|)
name|max_reuse
operator|=
name|__mf_lookup_cache_reusecount
index|[
name|i
index|]
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lookup cache slots used: %u  unused: %u  peak-reuse: %u\n"
argument_list|,
name|num_used
argument_list|,
name|num_unused
argument_list|,
name|max_reuse
argument_list|)
expr_stmt|;
block|}
block|{
name|unsigned
name|live_count
decl_stmt|;
name|live_count
operator|=
name|__mf_find_objects
argument_list|(
name|MINPTR
argument_list|,
name|MAXPTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"number of live objects: %u\n"
argument_list|,
name|live_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__mf_opts
operator|.
name|persistent_count
operator|>
literal|0
condition|)
block|{
name|unsigned
name|dead_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|row
decl_stmt|,
name|plot
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<=
name|__MF_TYPE_MAX_CEM
condition|;
name|row
operator|++
control|)
for|for
control|(
name|plot
operator|=
literal|0
init|;
name|plot
operator|<
name|__mf_opts
operator|.
name|persistent_count
condition|;
name|plot
operator|++
control|)
if|if
condition|(
name|__mf_object_cemetary
index|[
name|row
index|]
index|[
name|plot
index|]
operator|!=
literal|0
condition|)
name|dead_count
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"          zombie objects: %u\n"
argument_list|,
name|dead_count
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__mf_opts
operator|.
name|print_leaks
operator|&&
operator|(
name|__mf_opts
operator|.
name|mudflap_mode
operator|==
name|mode_check
operator|)
condition|)
block|{
name|unsigned
name|l
decl_stmt|;
specifier|extern
name|void
modifier|*
name|__mf_wrap_alloca_indirect
argument_list|(
name|size_t
name|c
argument_list|)
decl_stmt|;
comment|/* Free up any remaining alloca()'d blocks.  */
name|__mf_wrap_alloca_indirect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__mf_describe_object
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Reset description epoch.  */
name|l
operator|=
name|__mf_report_leaks
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"number of leaked objects: %u\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* __mf_backtrace */
end_comment

begin_function
name|size_t
name|__mf_backtrace
parameter_list|(
name|char
modifier|*
modifier|*
modifier|*
name|symbols
parameter_list|,
name|void
modifier|*
name|guess_pc
parameter_list|,
name|unsigned
name|guess_omit_levels
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|pc_array
decl_stmt|;
name|unsigned
name|pc_array_size
init|=
name|__mf_opts
operator|.
name|backtrace
operator|+
name|guess_omit_levels
decl_stmt|;
name|unsigned
name|remaining_size
decl_stmt|;
name|unsigned
name|omitted_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|calloc
argument_list|,
argument|size_t c
argument_list|,
argument|size_t n
argument_list|)
empty_stmt|;
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t n
argument_list|)
empty_stmt|;
name|pc_array
operator|=
name|CALL_REAL
argument_list|(
name|calloc
argument_list|,
name|pc_array_size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_BACKTRACE
name|pc_array_size
operator|=
name|backtrace
argument_list|(
name|pc_array
argument_list|,
name|pc_array_size
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|FETCH
parameter_list|(
name|n
parameter_list|)
value|do { if (pc_array_size>= n) { \                  pc_array[n] = __builtin_return_address(n); \                  if (pc_array[n] == 0) pc_array_size = n; } } while (0)
comment|/* Unroll some calls __builtin_return_address because this function      only takes a literal integer parameter.  */
name|FETCH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: __builtin_return_address sometimes crashes (!) on>0 arguments,      rather than simply returning 0.  :-(  */
block|FETCH (1);   FETCH (2);   FETCH (3);   FETCH (4);   FETCH (5);   FETCH (6);   FETCH (7);   FETCH (8);   if (pc_array_size> 8) pc_array_size = 9;
else|#
directive|else
if|if
condition|(
name|pc_array_size
operator|>
literal|0
condition|)
name|pc_array_size
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|FETCH
endif|#
directive|endif
comment|/* We want to trim the first few levels of the stack traceback,      since they contain libmudflap wrappers and junk.  If pc_array[]      ends up containing a non-NULL guess_pc, then trim everything      before that.  Otherwise, omit the first guess_omit_levels      entries. */
if|if
condition|(
name|guess_pc
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pc_array_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pc_array
index|[
name|i
index|]
operator|==
name|guess_pc
condition|)
name|omitted_size
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|omitted_size
operator|==
literal|0
condition|)
comment|/* No match? */
if|if
condition|(
name|pc_array_size
operator|>
name|guess_omit_levels
condition|)
name|omitted_size
operator|=
name|guess_omit_levels
expr_stmt|;
name|remaining_size
operator|=
name|pc_array_size
operator|-
name|omitted_size
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_BACKTRACE_SYMBOLS
operator|*
name|symbols
operator|=
name|backtrace_symbols
argument_list|(
name|pc_array
operator|+
name|omitted_size
argument_list|,
name|remaining_size
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
comment|/* Let's construct a buffer by hand.  It will have<remaining_size>        char*'s at the front, pointing at individual strings immediately        afterwards.  */
name|void
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|chars
decl_stmt|;
name|char
modifier|*
modifier|*
name|pointers
decl_stmt|;
enum|enum
block|{
name|perline
init|=
literal|30
block|}
enum|;
name|buffer
operator|=
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|remaining_size
operator|*
operator|(
name|perline
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pointers
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|buffer
expr_stmt|;
name|chars
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|remaining_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remaining_size
condition|;
name|i
operator|++
control|)
block|{
name|pointers
index|[
name|i
index|]
operator|=
name|chars
expr_stmt|;
name|sprintf
argument_list|(
name|chars
argument_list|,
literal|"[0x%p]"
argument_list|,
name|pc_array
index|[
name|omitted_size
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|chars
operator|=
name|chars
operator|+
name|perline
expr_stmt|;
block|}
operator|*
name|symbols
operator|=
name|pointers
expr_stmt|;
block|}
endif|#
directive|endif
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|pc_array
argument_list|)
expr_stmt|;
return|return
name|remaining_size
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* __mf_violation */
end_comment

begin_function
name|void
name|__mf_violation
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|static
name|unsigned
name|violation_number
decl_stmt|;
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"violation pc=%p location=%s type=%d ptr=%p size=%lu\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pc
argument_list|,
operator|(
name|location
operator|!=
name|NULL
condition|?
name|location
else|:
literal|""
operator|)
argument_list|,
name|type
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|collect_stats
condition|)
name|__mf_count_violation
index|[
operator|(
name|type
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|type
operator|>
name|__MF_VIOL_WATCH
operator|)
condition|?
literal|0
else|:
name|type
index|]
operator|++
expr_stmt|;
comment|/* Print out a basic warning message.  */
if|if
condition|(
name|__mf_opts
operator|.
name|verbose_violations
condition|)
block|{
name|unsigned
name|dead_p
decl_stmt|;
name|unsigned
name|num_helpful
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|violation_number
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*******\n"
literal|"mudflap violation %u (%s): time=%lu.%06lu "
literal|"ptr=%p size=%lu\npc=%p%s%s%s\n"
argument_list|,
name|violation_number
argument_list|,
operator|(
operator|(
name|type
operator|==
name|__MF_VIOL_READ
operator|)
condition|?
literal|"check/read"
else|:
operator|(
name|type
operator|==
name|__MF_VIOL_WRITE
operator|)
condition|?
literal|"check/write"
else|:
operator|(
name|type
operator|==
name|__MF_VIOL_REGISTER
operator|)
condition|?
literal|"register"
else|:
operator|(
name|type
operator|==
name|__MF_VIOL_UNREGISTER
operator|)
condition|?
literal|"unregister"
else|:
operator|(
name|type
operator|==
name|__MF_VIOL_WATCH
operator|)
condition|?
literal|"watch"
else|:
literal|"unknown"
operator|)
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sz
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pc
argument_list|,
operator|(
name|location
operator|!=
name|NULL
condition|?
literal|" location=`"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|location
operator|!=
name|NULL
condition|?
name|location
else|:
literal|""
operator|)
argument_list|,
operator|(
name|location
operator|!=
name|NULL
condition|?
literal|"'"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|backtrace
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num
decl_stmt|;
name|num
operator|=
name|__mf_backtrace
argument_list|(
operator|&
name|symbols
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Note: backtrace_symbols calls malloc().  But since we're in            __mf_violation and presumably __mf_check, it'll detect            recursion, and not put the new string into the database.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      %s\n"
argument_list|,
name|symbols
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Calling free() here would trigger a violation.  */
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
block|}
comment|/* Look for nearby objects.  For this, we start with s_low/s_high        pointing to the given area, looking for overlapping objects.        If none show up, widen the search area and keep looking. */
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
name|sz
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|dead_p
operator|=
literal|0
init|;
name|dead_p
operator|<=
literal|1
condition|;
name|dead_p
operator|++
control|)
comment|/* for dead_p in 0 1 */
block|{
enum|enum
block|{
name|max_objs
init|=
literal|3
block|}
enum|;
comment|/* magic */
name|__mf_object_t
modifier|*
name|objs
index|[
name|max_objs
index|]
decl_stmt|;
name|unsigned
name|num_objs
init|=
literal|0
decl_stmt|;
name|uintptr_t
name|s_low
decl_stmt|,
name|s_high
decl_stmt|;
name|unsigned
name|tries
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|s_low
operator|=
operator|(
name|uintptr_t
operator|)
name|ptr
expr_stmt|;
name|s_high
operator|=
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
while|while
condition|(
name|tries
operator|<
literal|16
condition|)
comment|/* magic */
block|{
if|if
condition|(
name|dead_p
condition|)
name|num_objs
operator|=
name|__mf_find_dead_objects
argument_list|(
name|s_low
argument_list|,
name|s_high
argument_list|,
name|objs
argument_list|,
name|max_objs
argument_list|)
expr_stmt|;
else|else
name|num_objs
operator|=
name|__mf_find_objects
argument_list|(
name|s_low
argument_list|,
name|s_high
argument_list|,
name|objs
argument_list|,
name|max_objs
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_objs
condition|)
comment|/* good enough */
break|break;
name|tries
operator|++
expr_stmt|;
comment|/* XXX: tune this search strategy.  It's too dependent on              sz, which can vary from 1 to very big (when array index              checking) numbers. */
name|s_low
operator|=
name|CLAMPSUB
argument_list|(
name|s_low
argument_list|,
operator|(
name|sz
operator|*
name|tries
operator|*
name|tries
operator|)
argument_list|)
expr_stmt|;
name|s_high
operator|=
name|CLAMPADD
argument_list|(
name|s_high
argument_list|,
operator|(
name|sz
operator|*
name|tries
operator|*
name|tries
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
argument_list|(
name|num_objs
argument_list|,
name|max_objs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
name|objs
index|[
name|i
index|]
decl_stmt|;
name|uintptr_t
name|low
init|=
operator|(
name|uintptr_t
operator|)
name|ptr
decl_stmt|;
name|uintptr_t
name|high
init|=
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|unsigned
name|before1
init|=
operator|(
name|low
operator|<
name|obj
operator|->
name|low
operator|)
condition|?
name|obj
operator|->
name|low
operator|-
name|low
else|:
literal|0
decl_stmt|;
name|unsigned
name|after1
init|=
operator|(
name|low
operator|>
name|obj
operator|->
name|high
operator|)
condition|?
name|low
operator|-
name|obj
operator|->
name|high
else|:
literal|0
decl_stmt|;
name|unsigned
name|into1
init|=
operator|(
name|high
operator|>=
name|obj
operator|->
name|low
operator|&&
name|low
operator|<=
name|obj
operator|->
name|high
operator|)
condition|?
name|low
operator|-
name|obj
operator|->
name|low
else|:
literal|0
decl_stmt|;
name|unsigned
name|before2
init|=
operator|(
name|high
operator|<
name|obj
operator|->
name|low
operator|)
condition|?
name|obj
operator|->
name|low
operator|-
name|high
else|:
literal|0
decl_stmt|;
name|unsigned
name|after2
init|=
operator|(
name|high
operator|>
name|obj
operator|->
name|high
operator|)
condition|?
name|high
operator|-
name|obj
operator|->
name|high
else|:
literal|0
decl_stmt|;
name|unsigned
name|into2
init|=
operator|(
name|high
operator|>=
name|obj
operator|->
name|low
operator|&&
name|low
operator|<=
name|obj
operator|->
name|high
operator|)
condition|?
name|high
operator|-
name|obj
operator|->
name|low
else|:
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Nearby object %u: checked region begins %uB %s and ends %uB %s\n"
argument_list|,
name|num_helpful
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
name|before1
condition|?
name|before1
else|:
name|after1
condition|?
name|after1
else|:
name|into1
operator|)
argument_list|,
operator|(
name|before1
condition|?
literal|"before"
else|:
name|after1
condition|?
literal|"after"
else|:
literal|"into"
operator|)
argument_list|,
operator|(
name|before2
condition|?
name|before2
else|:
name|after2
condition|?
name|after2
else|:
name|into2
operator|)
argument_list|,
operator|(
name|before2
condition|?
literal|"before"
else|:
name|after2
condition|?
literal|"after"
else|:
literal|"into"
operator|)
argument_list|)
expr_stmt|;
name|__mf_describe_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|num_helpful
operator|+=
name|num_objs
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"number of nearby objects: %u\n"
argument_list|,
name|num_helpful
argument_list|)
expr_stmt|;
block|}
comment|/* How to finally handle this violation?  */
switch|switch
condition|(
name|__mf_opts
operator|.
name|violation_mode
condition|)
block|{
case|case
name|viol_nop
case|:
break|break;
case|case
name|viol_segv
case|:
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
break|break;
case|case
name|viol_abort
case|:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|viol_gdb
case|:
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|128
argument_list|,
literal|"gdb --pid=%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX: should probably fork()&& sleep(GDB_WAIT_PARAMETER)       instead, and let the forked child execlp() gdb.  That way, this       subject process can be resumed under the supervision of gdb.       This can't happen now, since system() only returns when gdb       dies.  In that case, we need to beware of starting a second       concurrent gdb child upon the next violation.  (But if the first       gdb dies, then starting a new one is appropriate.)  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|unsigned
name|__mf_watch
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|unsigned
name|rc
decl_stmt|;
name|LOCKTH
argument_list|()
expr_stmt|;
name|BEGIN_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|rc
operator|=
name|__mf_watch_or_not
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|END_RECURSION_PROTECT
argument_list|()
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|unsigned
name|__mf_unwatch
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|unsigned
name|rc
decl_stmt|;
name|LOCKTH
argument_list|()
expr_stmt|;
name|rc
operator|=
name|__mf_watch_or_not
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|__mf_watch_or_not
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|char
name|flag
parameter_list|)
block|{
name|uintptr_t
name|ptr_high
init|=
name|CLAMPSZ
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|uintptr_t
name|ptr_low
init|=
operator|(
name|uintptr_t
operator|)
name|ptr
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s ptr=%p size=%lu\n"
argument_list|,
operator|(
name|flag
condition|?
literal|"watch"
else|:
literal|"unwatch"
operator|)
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|__mf_opts
operator|.
name|mudflap_mode
condition|)
block|{
case|case
name|mode_nop
case|:
case|case
name|mode_populate
case|:
case|case
name|mode_violate
case|:
name|count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|mode_check
case|:
block|{
name|__mf_object_t
modifier|*
modifier|*
name|all_ovr_objs
decl_stmt|;
name|unsigned
name|obj_count
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t c
argument_list|)
empty_stmt|;
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
name|p
argument_list|)
expr_stmt|;
name|obj_count
operator|=
name|__mf_find_objects
argument_list|(
name|ptr_low
argument_list|,
name|ptr_high
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERBOSE_TRACE
argument_list|(
literal|" %u:"
argument_list|,
name|obj_count
argument_list|)
expr_stmt|;
name|all_ovr_objs
operator|=
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|__mf_object_t
operator|*
argument_list|)
operator|*
name|obj_count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_ovr_objs
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|__mf_find_objects
argument_list|(
name|ptr_low
argument_list|,
name|ptr_high
argument_list|,
name|all_ovr_objs
argument_list|,
name|obj_count
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|n
operator|==
name|obj_count
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|obj_count
condition|;
name|n
operator|++
control|)
block|{
name|__mf_object_t
modifier|*
name|obj
init|=
name|all_ovr_objs
index|[
name|n
index|]
decl_stmt|;
name|VERBOSE_TRACE
argument_list|(
literal|" [%p]"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|watching_p
operator|!=
name|flag
condition|)
block|{
name|obj
operator|->
name|watching_p
operator|=
name|flag
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* Remove object from cache, to ensure next access                    goes through __mf_check().  */
if|if
condition|(
name|flag
condition|)
name|__mf_uncache_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|all_ovr_objs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|void
name|__mf_sigusr1_handler
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|__mf_sigusr1_received
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install or remove SIGUSR1 handler as necessary.    Also, respond to a received pending SIGUSR1.  */
end_comment

begin_function
name|void
name|__mf_sigusr1_respond
parameter_list|()
block|{
specifier|static
name|int
name|handler_installed
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
comment|/* Manage handler */
if|if
condition|(
name|__mf_opts
operator|.
name|sigusr1_report
operator|&&
operator|!
name|handler_installed
condition|)
block|{
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|__mf_sigusr1_handler
argument_list|)
expr_stmt|;
name|handler_installed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|__mf_opts
operator|.
name|sigusr1_report
operator|&&
name|handler_installed
condition|)
block|{
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|handler_installed
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Manage enqueued signals */
if|if
condition|(
name|__mf_sigusr1_received
operator|>
name|__mf_sigusr1_handled
condition|)
block|{
name|__mf_sigusr1_handled
operator|++
expr_stmt|;
name|assert
argument_list|(
name|__mf_get_state
argument_list|()
operator|==
name|reentrant
argument_list|)
expr_stmt|;
name|__mfu_report
argument_list|()
expr_stmt|;
name|handler_installed
operator|=
literal|0
expr_stmt|;
comment|/* We may need to re-enable signal; this might be a SysV library. */
block|}
block|}
end_function

begin_comment
comment|/* XXX: provide an alternative __assert_fail function that cannot    fail due to libmudflap infinite recursion.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_function
specifier|static
name|void
name|write_itoa
parameter_list|(
name|int
name|fd
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
enum|enum
name|x
block|{
name|bufsize
init|=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
operator|*
literal|4
block|}
enum|;
name|char
name|buf
index|[
name|bufsize
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufsize
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|digit
init|=
name|n
operator|%
literal|10
decl_stmt|;
name|buf
index|[
name|bufsize
operator|-
literal|2
operator|-
name|i
index|]
operator|=
name|digit
operator|+
literal|'0'
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|m
init|=
operator|&
name|buf
index|[
name|bufsize
operator|-
literal|2
operator|-
name|i
index|]
decl_stmt|;
name|buf
index|[
name|bufsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|__assert_fail
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
define|#
directive|define
name|write2
parameter_list|(
name|string
parameter_list|)
value|write (2, (string), strlen ((string)));
name|write2
argument_list|(
literal|"mf"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBMUDFLAPTH
name|write2
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|write_itoa
argument_list|(
literal|2
argument_list|,
operator|(
name|unsigned
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|write2
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|write2
argument_list|(
literal|": assertion failure: `"
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|write2
argument_list|(
literal|"' in "
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|func
argument_list|,
name|strlen
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|write2
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|file
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|write2
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|write_itoa
argument_list|(
literal|2
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|write2
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|write2
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Adapted splay tree code, originally from libiberty.  It has been    specialized for libmudflap as requested by RMS.  */
end_comment

begin_function
specifier|static
name|void
name|mfsplay_tree_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
name|p
argument_list|)
expr_stmt|;
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|mfsplay_tree_xmalloc
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t s
argument_list|)
empty_stmt|;
return|return
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|mfsplay_tree_splay
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_splay_helper
parameter_list|(
name|mfsplay_tree
parameter_list|,
name|mfsplay_tree_key
parameter_list|,
name|mfsplay_tree_node
modifier|*
parameter_list|,
name|mfsplay_tree_node
modifier|*
parameter_list|,
name|mfsplay_tree_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent    and grandparent, respectively, of NODE.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_splay_helper
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|,
name|mfsplay_tree_node
modifier|*
name|node
parameter_list|,
name|mfsplay_tree_node
modifier|*
name|parent
parameter_list|,
name|mfsplay_tree_node
modifier|*
name|grandparent
parameter_list|)
block|{
name|mfsplay_tree_node
modifier|*
name|next
decl_stmt|;
name|mfsplay_tree_node
name|n
decl_stmt|;
name|int
name|comparison
decl_stmt|;
name|n
operator|=
operator|*
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
operator|*
name|parent
return|;
name|comparison
operator|=
operator|(
operator|(
name|key
operator|>
name|n
operator|->
name|key
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|key
operator|<
name|n
operator|->
name|key
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
comment|/* We've found the target.  */
name|next
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|comparison
operator|<
literal|0
condition|)
comment|/* The target is to the left.  */
name|next
operator|=
operator|&
name|n
operator|->
name|left
expr_stmt|;
else|else
comment|/* The target is to the right.  */
name|next
operator|=
operator|&
name|n
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
comment|/* Check whether our recursion depth is too high.  Abort this search,          and signal that a rebalance is required to continue.  */
if|if
condition|(
name|sp
operator|->
name|depth
operator|>
name|sp
operator|->
name|max_depth
condition|)
block|{
name|sp
operator|->
name|rebalance_p
operator|=
literal|1
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/* Continue down the tree.  */
name|sp
operator|->
name|depth
operator|++
expr_stmt|;
name|n
operator|=
name|mfsplay_tree_splay_helper
argument_list|(
name|sp
argument_list|,
name|key
argument_list|,
name|next
argument_list|,
name|node
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|sp
operator|->
name|depth
operator|--
expr_stmt|;
comment|/* The recursive call will change the place to which NODE          points.  */
if|if
condition|(
operator|*
name|node
operator|!=
name|n
operator|||
name|sp
operator|->
name|rebalance_p
condition|)
return|return
name|n
return|;
block|}
if|if
condition|(
operator|!
name|parent
condition|)
comment|/* NODE is the root.  We are done.  */
return|return
name|n
return|;
comment|/* First, handle the case where there is no grandparent (i.e.,    *PARENT is the root of the tree.)  */
if|if
condition|(
operator|!
name|grandparent
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|(
operator|*
name|parent
operator|)
operator|->
name|left
condition|)
block|{
operator|*
name|node
operator|=
name|n
operator|->
name|right
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|parent
expr_stmt|;
block|}
else|else
block|{
operator|*
name|node
operator|=
name|n
operator|->
name|left
expr_stmt|;
name|n
operator|->
name|left
operator|=
operator|*
name|parent
expr_stmt|;
block|}
operator|*
name|parent
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/* Next handle the cases where both N and *PARENT are left children,      or where both are right children.  */
if|if
condition|(
name|n
operator|==
operator|(
operator|*
name|parent
operator|)
operator|->
name|left
operator|&&
operator|*
name|parent
operator|==
operator|(
operator|*
name|grandparent
operator|)
operator|->
name|left
condition|)
block|{
name|mfsplay_tree_node
name|p
init|=
operator|*
name|parent
decl_stmt|;
operator|(
operator|*
name|grandparent
operator|)
operator|->
name|left
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|right
operator|=
operator|*
name|grandparent
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|n
operator|->
name|right
expr_stmt|;
name|n
operator|->
name|right
operator|=
name|p
expr_stmt|;
operator|*
name|grandparent
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
operator|(
operator|*
name|parent
operator|)
operator|->
name|right
operator|&&
operator|*
name|parent
operator|==
operator|(
operator|*
name|grandparent
operator|)
operator|->
name|right
condition|)
block|{
name|mfsplay_tree_node
name|p
init|=
operator|*
name|parent
decl_stmt|;
operator|(
operator|*
name|grandparent
operator|)
operator|->
name|right
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|left
operator|=
operator|*
name|grandparent
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|n
operator|->
name|left
expr_stmt|;
name|n
operator|->
name|left
operator|=
name|p
expr_stmt|;
operator|*
name|grandparent
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/* Finally, deal with the case where N is a left child, but *PARENT      is a right child, or vice versa.  */
if|if
condition|(
name|n
operator|==
operator|(
operator|*
name|parent
operator|)
operator|->
name|left
condition|)
block|{
operator|(
operator|*
name|parent
operator|)
operator|->
name|left
operator|=
name|n
operator|->
name|right
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|parent
expr_stmt|;
operator|(
operator|*
name|grandparent
operator|)
operator|->
name|right
operator|=
name|n
operator|->
name|left
expr_stmt|;
name|n
operator|->
name|left
operator|=
operator|*
name|grandparent
expr_stmt|;
operator|*
name|grandparent
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
operator|(
operator|*
name|parent
operator|)
operator|->
name|right
operator|=
name|n
operator|->
name|left
expr_stmt|;
name|n
operator|->
name|left
operator|=
operator|*
name|parent
expr_stmt|;
operator|(
operator|*
name|grandparent
operator|)
operator|->
name|left
operator|=
name|n
operator|->
name|right
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|grandparent
expr_stmt|;
operator|*
name|grandparent
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfsplay_tree_rebalance_helper1
parameter_list|(
name|mfsplay_tree_node
name|n
parameter_list|,
name|void
modifier|*
name|array_ptr
parameter_list|)
block|{
name|mfsplay_tree_node
modifier|*
modifier|*
name|p
init|=
name|array_ptr
decl_stmt|;
operator|*
operator|(
operator|*
name|p
operator|)
operator|=
name|n
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_rebalance_helper2
parameter_list|(
name|mfsplay_tree_node
modifier|*
name|array
parameter_list|,
name|unsigned
name|low
parameter_list|,
name|unsigned
name|high
parameter_list|)
block|{
name|unsigned
name|middle
init|=
name|low
operator|+
operator|(
name|high
operator|-
name|low
operator|)
operator|/
literal|2
decl_stmt|;
name|mfsplay_tree_node
name|n
init|=
name|array
index|[
name|middle
index|]
decl_stmt|;
comment|/* Note that since we're producing a balanced binary tree, it is not a problem      that this function is recursive.  */
if|if
condition|(
name|low
operator|+
literal|1
operator|<=
name|middle
condition|)
name|n
operator|->
name|left
operator|=
name|mfsplay_tree_rebalance_helper2
argument_list|(
name|array
argument_list|,
name|low
argument_list|,
name|middle
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|n
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|middle
operator|+
literal|1
operator|<=
name|high
condition|)
name|n
operator|->
name|right
operator|=
name|mfsplay_tree_rebalance_helper2
argument_list|(
name|array
argument_list|,
name|middle
operator|+
literal|1
argument_list|,
name|high
argument_list|)
expr_stmt|;
else|else
name|n
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Rebalance the entire tree.  Do this by copying all the node    pointers into an array, then cleverly re-linking them.  */
end_comment

begin_function
specifier|static
name|void
name|mfsplay_tree_rebalance
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|)
block|{
name|mfsplay_tree_node
modifier|*
name|all_nodes
decl_stmt|,
modifier|*
name|all_nodes_1
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|num_keys
operator|<=
literal|2
condition|)
return|return;
name|all_nodes
operator|=
name|mfsplay_tree_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mfsplay_tree_node
argument_list|)
operator|*
name|sp
operator|->
name|num_keys
argument_list|)
expr_stmt|;
comment|/* Traverse all nodes to copy their addresses into this array.  */
name|all_nodes_1
operator|=
name|all_nodes
expr_stmt|;
name|mfsplay_tree_foreach
argument_list|(
name|sp
argument_list|,
name|mfsplay_tree_rebalance_helper1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|all_nodes_1
argument_list|)
expr_stmt|;
comment|/* Relink all the nodes.  */
name|sp
operator|->
name|root
operator|=
name|mfsplay_tree_rebalance_helper2
argument_list|(
name|all_nodes
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|num_keys
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mfsplay_tree_free
argument_list|(
name|all_nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splay SP around KEY.  */
end_comment

begin_function
specifier|static
name|void
name|mfsplay_tree_splay
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|root
operator|==
literal|0
condition|)
return|return;
comment|/* If we just splayed the tree with the same key, do nothing.  */
if|if
condition|(
name|sp
operator|->
name|last_splayed_key_p
operator|&&
operator|(
name|sp
operator|->
name|last_splayed_key
operator|==
name|key
operator|)
condition|)
return|return;
comment|/* Compute a maximum recursion depth for a splay tree with NUM nodes.      The idea is to limit excessive stack usage if we're facing      degenerate access patterns.  Unfortunately such patterns can occur      e.g. during static initialization, where many static objects might      be registered in increasing address sequence, or during a case where      large tree-like heap data structures are allocated quickly.       On x86, this corresponds to roughly 200K of stack usage.      XXX: For libmudflapth, this could be a function of __mf_opts.thread_stack.  */
name|sp
operator|->
name|max_depth
operator|=
literal|2500
expr_stmt|;
name|sp
operator|->
name|rebalance_p
operator|=
name|sp
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|mfsplay_tree_splay_helper
argument_list|(
name|sp
argument_list|,
name|key
argument_list|,
operator|&
name|sp
operator|->
name|root
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rebalance_p
condition|)
block|{
name|mfsplay_tree_rebalance
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rebalance_p
operator|=
name|sp
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|mfsplay_tree_splay_helper
argument_list|(
name|sp
argument_list|,
name|key
argument_list|,
operator|&
name|sp
operator|->
name|root
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rebalance_p
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Cache this splay key. */
name|sp
operator|->
name|last_splayed_key
operator|=
name|key
expr_stmt|;
name|sp
operator|->
name|last_splayed_key_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a new splay tree.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree
name|mfsplay_tree_new
parameter_list|()
block|{
name|mfsplay_tree
name|sp
init|=
name|mfsplay_tree_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfsplay_tree_s
argument_list|)
argument_list|)
decl_stmt|;
name|sp
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|last_splayed_key_p
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|num_keys
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Insert a new node (associating KEY with DATA) into SP.  If a    previous node with the indicated KEY exists, its data is replaced    with the new value.  Returns the new node.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_insert
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|,
name|mfsplay_tree_value
name|value
parameter_list|)
block|{
name|int
name|comparison
init|=
literal|0
decl_stmt|;
name|mfsplay_tree_splay
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|root
condition|)
name|comparison
operator|=
operator|(
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|>
name|key
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|<
name|key
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|root
operator|&&
name|comparison
operator|==
literal|0
condition|)
block|{
comment|/* If the root of the tree already has the indicated KEY, just          replace the value with VALUE.  */
name|sp
operator|->
name|root
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new node, and insert it at the root.  */
name|mfsplay_tree_node
name|node
decl_stmt|;
name|node
operator|=
name|mfsplay_tree_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfsplay_tree_node_s
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|node
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|sp
operator|->
name|num_keys
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|root
condition|)
name|node
operator|->
name|left
operator|=
name|node
operator|->
name|right
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|comparison
operator|<
literal|0
condition|)
block|{
name|node
operator|->
name|left
operator|=
name|sp
operator|->
name|root
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|node
operator|->
name|left
operator|->
name|right
expr_stmt|;
name|node
operator|->
name|left
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|right
operator|=
name|sp
operator|->
name|root
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|node
operator|->
name|right
operator|->
name|left
expr_stmt|;
name|node
operator|->
name|right
operator|->
name|left
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|root
operator|=
name|node
expr_stmt|;
name|sp
operator|->
name|last_splayed_key_p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|sp
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Remove KEY from SP.  It is not an error if it did not exist.  */
end_comment

begin_function
specifier|static
name|void
name|mfsplay_tree_remove
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|)
block|{
name|mfsplay_tree_splay
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|sp
operator|->
name|last_splayed_key_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|root
operator|&&
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|==
name|key
operator|)
condition|)
block|{
name|mfsplay_tree_node
name|left
decl_stmt|,
name|right
decl_stmt|;
name|left
operator|=
name|sp
operator|->
name|root
operator|->
name|left
expr_stmt|;
name|right
operator|=
name|sp
operator|->
name|root
operator|->
name|right
expr_stmt|;
comment|/* Delete the root node itself.  */
name|mfsplay_tree_free
argument_list|(
name|sp
operator|->
name|root
argument_list|)
expr_stmt|;
name|sp
operator|->
name|num_keys
operator|--
expr_stmt|;
comment|/* One of the children is now the root.  Doesn't matter much          which, so long as we preserve the properties of the tree.  */
if|if
condition|(
name|left
condition|)
block|{
name|sp
operator|->
name|root
operator|=
name|left
expr_stmt|;
comment|/* If there was a right child as well, hang it off the              right-most leaf of the left child.  */
if|if
condition|(
name|right
condition|)
block|{
while|while
condition|(
name|left
operator|->
name|right
condition|)
name|left
operator|=
name|left
operator|->
name|right
expr_stmt|;
name|left
operator|->
name|right
operator|=
name|right
expr_stmt|;
block|}
block|}
else|else
name|sp
operator|->
name|root
operator|=
name|right
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup KEY in SP, returning VALUE if present, and NULL    otherwise.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_lookup
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|)
block|{
name|mfsplay_tree_splay
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|root
operator|&&
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|==
name|key
operator|)
condition|)
return|return
name|sp
operator|->
name|root
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the immediate predecessor KEY, or NULL if there is no    predecessor.  KEY need not be present in the tree.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_predecessor
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|)
block|{
name|int
name|comparison
decl_stmt|;
name|mfsplay_tree_node
name|node
decl_stmt|;
comment|/* If the tree is empty, there is certainly no predecessor.  */
if|if
condition|(
operator|!
name|sp
operator|->
name|root
condition|)
return|return
name|NULL
return|;
comment|/* Splay the tree around KEY.  That will leave either the KEY      itself, its predecessor, or its successor at the root.  */
name|mfsplay_tree_splay
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|comparison
operator|=
operator|(
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|>
name|key
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|<
name|key
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If the predecessor is at the root, just return it.  */
if|if
condition|(
name|comparison
operator|<
literal|0
condition|)
return|return
name|sp
operator|->
name|root
return|;
comment|/* Otherwise, find the rightmost element of the left subtree.  */
name|node
operator|=
name|sp
operator|->
name|root
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|node
condition|)
while|while
condition|(
name|node
operator|->
name|right
condition|)
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return the immediate successor KEY, or NULL if there is no    successor.  KEY need not be present in the tree.  */
end_comment

begin_function
specifier|static
name|mfsplay_tree_node
name|mfsplay_tree_successor
parameter_list|(
name|mfsplay_tree
name|sp
parameter_list|,
name|mfsplay_tree_key
name|key
parameter_list|)
block|{
name|int
name|comparison
decl_stmt|;
name|mfsplay_tree_node
name|node
decl_stmt|;
comment|/* If the tree is empty, there is certainly no successor.  */
if|if
condition|(
operator|!
name|sp
operator|->
name|root
condition|)
return|return
name|NULL
return|;
comment|/* Splay the tree around KEY.  That will leave either the KEY      itself, its predecessor, or its successor at the root.  */
name|mfsplay_tree_splay
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|comparison
operator|=
operator|(
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|>
name|key
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|sp
operator|->
name|root
operator|->
name|key
operator|<
name|key
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If the successor is at the root, just return it.  */
if|if
condition|(
name|comparison
operator|>
literal|0
condition|)
return|return
name|sp
operator|->
name|root
return|;
comment|/* Otherwise, find the leftmost element of the right subtree.  */
name|node
operator|=
name|sp
operator|->
name|root
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|node
condition|)
while|while
condition|(
name|node
operator|->
name|left
condition|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Call FN, passing it the DATA, for every node in SP, following an    in-order traversal.  If FN every returns a non-zero value, the    iteration ceases immediately, and the value is returned.    Otherwise, this function returns 0.     This function simulates recursion using dynamically allocated    arrays, since it may be called from mfsplay_tree_rebalance(), which    in turn means that the tree is already uncomfortably deep for stack    space limits.  */
end_comment

begin_function
specifier|static
name|int
name|mfsplay_tree_foreach
parameter_list|(
name|mfsplay_tree
name|st
parameter_list|,
name|mfsplay_tree_foreach_fn
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|mfsplay_tree_node
modifier|*
name|stack1
decl_stmt|;
name|char
modifier|*
name|stack2
decl_stmt|;
name|unsigned
name|sp
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
enum|enum
name|s
block|{
name|s_left
block|,
name|s_here
block|,
name|s_right
block|,
name|s_up
block|}
enum|;
if|if
condition|(
name|st
operator|->
name|root
operator|==
name|NULL
condition|)
comment|/* => num_keys == 0 */
return|return
literal|0
return|;
name|stack1
operator|=
name|mfsplay_tree_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mfsplay_tree_node
argument_list|)
operator|*
name|st
operator|->
name|num_keys
argument_list|)
expr_stmt|;
name|stack2
operator|=
name|mfsplay_tree_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|st
operator|->
name|num_keys
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|stack1
index|[
name|sp
index|]
operator|=
name|st
operator|->
name|root
expr_stmt|;
name|stack2
index|[
name|sp
index|]
operator|=
name|s_left
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mfsplay_tree_node
name|n
decl_stmt|;
name|enum
name|s
name|s
decl_stmt|;
name|n
operator|=
name|stack1
index|[
name|sp
index|]
expr_stmt|;
name|s
operator|=
name|stack2
index|[
name|sp
index|]
expr_stmt|;
comment|/* Handle each of the four possible states separately.  */
comment|/* 1: We're here to traverse the left subtree (if any).  */
if|if
condition|(
name|s
operator|==
name|s_left
condition|)
block|{
name|stack2
index|[
name|sp
index|]
operator|=
name|s_here
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|left
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|++
expr_stmt|;
name|stack1
index|[
name|sp
index|]
operator|=
name|n
operator|->
name|left
expr_stmt|;
name|stack2
index|[
name|sp
index|]
operator|=
name|s_left
expr_stmt|;
block|}
block|}
comment|/* 2: We're here to traverse this node.  */
elseif|else
if|if
condition|(
name|s
operator|==
name|s_here
condition|)
block|{
name|stack2
index|[
name|sp
index|]
operator|=
name|s_right
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|n
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
break|break;
block|}
comment|/* 3: We're here to traverse the right subtree (if any).  */
elseif|else
if|if
condition|(
name|s
operator|==
name|s_right
condition|)
block|{
name|stack2
index|[
name|sp
index|]
operator|=
name|s_up
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|++
expr_stmt|;
name|stack1
index|[
name|sp
index|]
operator|=
name|n
operator|->
name|right
expr_stmt|;
name|stack2
index|[
name|sp
index|]
operator|=
name|s_left
expr_stmt|;
block|}
block|}
comment|/* 4: We're here after both subtrees (if any) have been traversed.  */
elseif|else
if|if
condition|(
name|s
operator|==
name|s_up
condition|)
block|{
comment|/* Pop the stack.  */
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
break|break;
comment|/* Popping off the root note: we're finished!  */
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|mfsplay_tree_free
argument_list|(
name|stack1
argument_list|)
expr_stmt|;
name|mfsplay_tree_free
argument_list|(
name|stack2
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

end_unit

