begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_tables.h"
end_include

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_hooks.h"
end_include

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_include
include|#
directive|include
file|"apr_optional_hooks.h"
end_include

begin_include
include|#
directive|include
file|"apr_optional.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_MEMFUNC
end_define

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|apr_palloc
parameter_list|(
name|pool
parameter_list|,
name|size
parameter_list|)
value|malloc(size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|APU_DECLARE_DATA
name|apr_pool_t
modifier|*
name|apr_hook_global_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|APU_DECLARE_DATA
name|int
name|apr_hook_debug_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|APU_DECLARE_DATA
specifier|const
name|char
modifier|*
name|apr_hook_debug_current
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** @deprecated @see apr_hook_global_pool */
end_comment

begin_decl_stmt
name|APU_DECLARE_DATA
name|apr_pool_t
modifier|*
name|apr_global_hook_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** @deprecated @see apr_hook_debug_enabled */
end_comment

begin_decl_stmt
name|APU_DECLARE_DATA
name|int
name|apr_debug_module_hooks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** @deprecated @see apr_hook_debug_current */
end_comment

begin_decl_stmt
name|APU_DECLARE_DATA
specifier|const
name|char
modifier|*
name|apr_current_hooking_module
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NB: This must echo the LINK_##name structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
function_decl|(
modifier|*
name|dummy
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|szName
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|aszPredecessors
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|aszSuccessors
decl_stmt|;
name|int
name|nOrder
decl_stmt|;
block|}
name|TSortData
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tsort_
block|{
name|void
modifier|*
name|pData
decl_stmt|;
name|int
name|nPredecessors
decl_stmt|;
name|struct
name|tsort_
modifier|*
modifier|*
name|ppPredecessors
decl_stmt|;
name|struct
name|tsort_
modifier|*
name|pNext
decl_stmt|;
block|}
name|TSort
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|NETWARE
end_ifdef

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_define
define|#
directive|define
name|get_apd
value|APP_DATA* apd = (APP_DATA*)get_app_data(gLibId);
end_define

begin_define
define|#
directive|define
name|s_aHooksToSort
value|((apr_array_header_t *)(apd->gs_aHooksToSort))
end_define

begin_define
define|#
directive|define
name|s_phOptionalHooks
value|((apr_hash_t *)(apd->gs_phOptionalHooks))
end_define

begin_define
define|#
directive|define
name|s_phOptionalFunctions
value|((apr_hash_t *)(apd->gs_phOptionalFunctions))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|crude_order
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|)
block|{
specifier|const
name|TSortData
modifier|*
name|a
init|=
name|a_
decl_stmt|;
specifier|const
name|TSortData
modifier|*
name|b
init|=
name|b_
decl_stmt|;
return|return
name|a
operator|->
name|nOrder
operator|-
name|b
operator|->
name|nOrder
return|;
block|}
end_function

begin_function
specifier|static
name|TSort
modifier|*
name|prepare
parameter_list|(
name|apr_pool_t
modifier|*
name|p
parameter_list|,
name|TSortData
modifier|*
name|pItems
parameter_list|,
name|int
name|nItems
parameter_list|)
block|{
name|TSort
modifier|*
name|pData
init|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|nItems
operator|*
sizeof|sizeof
expr|*
name|pData
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|qsort
argument_list|(
name|pItems
argument_list|,
name|nItems
argument_list|,
sizeof|sizeof
expr|*
name|pItems
argument_list|,
name|crude_order
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nItems
condition|;
operator|++
name|n
control|)
block|{
name|pData
index|[
name|n
index|]
operator|.
name|nPredecessors
operator|=
literal|0
expr_stmt|;
name|pData
index|[
name|n
index|]
operator|.
name|ppPredecessors
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
name|nItems
operator|*
sizeof|sizeof
expr|*
name|pData
index|[
name|n
index|]
operator|.
name|ppPredecessors
argument_list|)
expr_stmt|;
name|pData
index|[
name|n
index|]
operator|.
name|pNext
operator|=
name|NULL
expr_stmt|;
name|pData
index|[
name|n
index|]
operator|.
name|pData
operator|=
operator|&
name|pItems
index|[
name|n
index|]
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nItems
condition|;
operator|++
name|n
control|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pItems
index|[
name|n
index|]
operator|.
name|aszPredecessors
operator|&&
name|pItems
index|[
name|n
index|]
operator|.
name|aszPredecessors
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nItems
condition|;
operator|++
name|k
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pItems
index|[
name|k
index|]
operator|.
name|szName
argument_list|,
name|pItems
index|[
name|n
index|]
operator|.
name|aszPredecessors
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|pData
index|[
name|n
index|]
operator|.
name|nPredecessors
condition|;
operator|++
name|l
control|)
if|if
condition|(
name|pData
index|[
name|n
index|]
operator|.
name|ppPredecessors
index|[
name|l
index|]
operator|==
operator|&
name|pData
index|[
name|k
index|]
condition|)
goto|goto
name|got_it
goto|;
name|pData
index|[
name|n
index|]
operator|.
name|ppPredecessors
index|[
name|pData
index|[
name|n
index|]
operator|.
name|nPredecessors
index|]
operator|=
operator|&
name|pData
index|[
name|k
index|]
expr_stmt|;
operator|++
name|pData
index|[
name|n
index|]
operator|.
name|nPredecessors
expr_stmt|;
name|got_it
label|:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pItems
index|[
name|n
index|]
operator|.
name|aszSuccessors
operator|&&
name|pItems
index|[
name|n
index|]
operator|.
name|aszSuccessors
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nItems
condition|;
operator|++
name|k
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pItems
index|[
name|k
index|]
operator|.
name|szName
argument_list|,
name|pItems
index|[
name|n
index|]
operator|.
name|aszSuccessors
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|pData
index|[
name|k
index|]
operator|.
name|nPredecessors
condition|;
operator|++
name|l
control|)
if|if
condition|(
name|pData
index|[
name|k
index|]
operator|.
name|ppPredecessors
index|[
name|l
index|]
operator|==
operator|&
name|pData
index|[
name|n
index|]
condition|)
goto|goto
name|got_it2
goto|;
name|pData
index|[
name|k
index|]
operator|.
name|ppPredecessors
index|[
name|pData
index|[
name|k
index|]
operator|.
name|nPredecessors
index|]
operator|=
operator|&
name|pData
index|[
name|n
index|]
expr_stmt|;
operator|++
name|pData
index|[
name|k
index|]
operator|.
name|nPredecessors
expr_stmt|;
name|got_it2
label|:
break|break;
block|}
block|}
return|return
name|pData
return|;
block|}
end_function

begin_comment
comment|/* Topologically sort, dragging out-of-order items to the front. Note that    this tends to preserve things that want to be near the front better, and    changing that behaviour might compromise some of Apache's behaviour (in    particular, mod_log_forensic might otherwise get pushed to the end, and    core.c's log open function used to end up at the end when pushing items    to the back was the methedology). Also note that the algorithm could    go back to its original simplicity by sorting from the back instead of    the front. */
end_comment

begin_function
specifier|static
name|TSort
modifier|*
name|tsort
parameter_list|(
name|TSort
modifier|*
name|pData
parameter_list|,
name|int
name|nItems
parameter_list|)
block|{
name|int
name|nTotal
decl_stmt|;
name|TSort
modifier|*
name|pHead
init|=
name|NULL
decl_stmt|;
name|TSort
modifier|*
name|pTail
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|nTotal
operator|=
literal|0
init|;
name|nTotal
operator|<
name|nItems
condition|;
operator|++
name|nTotal
control|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|n
operator|==
name|nItems
condition|)
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* we have a loop... */
if|if
condition|(
operator|!
name|pData
index|[
name|n
index|]
operator|.
name|pNext
condition|)
block|{
if|if
condition|(
name|pData
index|[
name|n
index|]
operator|.
name|nPredecessors
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
condition|;
operator|++
name|k
control|)
block|{
name|assert
argument_list|(
name|k
operator|<
name|nItems
argument_list|)
expr_stmt|;
if|if
condition|(
name|pData
index|[
name|n
index|]
operator|.
name|ppPredecessors
index|[
name|k
index|]
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|i
operator|<
name|nItems
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pData
index|[
name|i
index|]
operator|==
name|pData
index|[
name|n
index|]
operator|.
name|ppPredecessors
index|[
name|k
index|]
condition|)
block|{
name|n
operator|=
name|i
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
break|break;
block|}
block|}
if|if
condition|(
name|pTail
condition|)
name|pTail
operator|->
name|pNext
operator|=
operator|&
name|pData
index|[
name|n
index|]
expr_stmt|;
else|else
name|pHead
operator|=
operator|&
name|pData
index|[
name|n
index|]
expr_stmt|;
name|pTail
operator|=
operator|&
name|pData
index|[
name|n
index|]
expr_stmt|;
name|pTail
operator|->
name|pNext
operator|=
name|pTail
expr_stmt|;
comment|/* fudge it so it looks linked */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nItems
condition|;
operator|++
name|i
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nItems
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|pData
index|[
name|i
index|]
operator|.
name|ppPredecessors
index|[
name|k
index|]
operator|==
operator|&
name|pData
index|[
name|n
index|]
condition|)
block|{
operator|--
name|pData
index|[
name|i
index|]
operator|.
name|nPredecessors
expr_stmt|;
name|pData
index|[
name|i
index|]
operator|.
name|ppPredecessors
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
name|pTail
operator|->
name|pNext
operator|=
name|NULL
expr_stmt|;
comment|/* unfudge the tail */
return|return
name|pHead
return|;
block|}
end_function

begin_function
specifier|static
name|apr_array_header_t
modifier|*
name|sort_hook
parameter_list|(
name|apr_array_header_t
modifier|*
name|pHooks
parameter_list|,
specifier|const
name|char
modifier|*
name|szName
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|p
decl_stmt|;
name|TSort
modifier|*
name|pSort
decl_stmt|;
name|apr_array_header_t
modifier|*
name|pNew
decl_stmt|;
name|int
name|n
decl_stmt|;
name|apr_pool_create
argument_list|(
operator|&
name|p
argument_list|,
name|apr_hook_global_pool
argument_list|)
expr_stmt|;
name|pSort
operator|=
name|prepare
argument_list|(
name|p
argument_list|,
operator|(
name|TSortData
operator|*
operator|)
name|pHooks
operator|->
name|elts
argument_list|,
name|pHooks
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|pSort
operator|=
name|tsort
argument_list|(
name|pSort
argument_list|,
name|pHooks
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|pNew
operator|=
name|apr_array_make
argument_list|(
name|apr_hook_global_pool
argument_list|,
name|pHooks
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|TSortData
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hook_debug_enabled
condition|)
name|printf
argument_list|(
literal|"Sorting %s:"
argument_list|,
name|szName
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|pSort
condition|;
name|pSort
operator|=
name|pSort
operator|->
name|pNext
operator|,
operator|++
name|n
control|)
block|{
name|TSortData
modifier|*
name|pHook
decl_stmt|;
name|assert
argument_list|(
name|n
operator|<
name|pHooks
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|pHook
operator|=
name|apr_array_push
argument_list|(
name|pNew
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pHook
argument_list|,
name|pSort
operator|->
name|pData
argument_list|,
sizeof|sizeof
expr|*
name|pHook
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hook_debug_enabled
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pHook
operator|->
name|szName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|apr_hook_debug_enabled
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* destroy the pool - the sorted hooks were already copied */
name|apr_pool_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|pNew
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NETWARE
end_ifndef

begin_decl_stmt
specifier|static
name|apr_array_header_t
modifier|*
name|s_aHooksToSort
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|szHookName
decl_stmt|;
name|apr_array_header_t
modifier|*
modifier|*
name|paHooks
decl_stmt|;
block|}
name|HookSortEntry
typedef|;
end_typedef

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hook_sort_register
argument_list|(
argument|const char *szHookName
argument_list|,
argument|apr_array_header_t **paHooks
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
name|HookSortEntry
modifier|*
name|pEntry
decl_stmt|;
if|if
condition|(
operator|!
name|s_aHooksToSort
condition|)
name|s_aHooksToSort
operator|=
name|apr_array_make
argument_list|(
name|apr_hook_global_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HookSortEntry
argument_list|)
argument_list|)
expr_stmt|;
name|pEntry
operator|=
name|apr_array_push
argument_list|(
name|s_aHooksToSort
argument_list|)
expr_stmt|;
name|pEntry
operator|->
name|szHookName
operator|=
name|szHookName
expr_stmt|;
name|pEntry
operator|->
name|paHooks
operator|=
name|paHooks
expr_stmt|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hook_sort_all
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|s_aHooksToSort
condition|)
block|{
name|s_aHooksToSort
operator|=
name|apr_array_make
argument_list|(
name|apr_hook_global_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HookSortEntry
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|s_aHooksToSort
operator|->
name|nelts
condition|;
operator|++
name|n
control|)
block|{
name|HookSortEntry
modifier|*
name|pEntry
init|=
operator|&
operator|(
operator|(
name|HookSortEntry
operator|*
operator|)
name|s_aHooksToSort
operator|->
name|elts
operator|)
index|[
name|n
index|]
decl_stmt|;
operator|*
name|pEntry
operator|->
name|paHooks
operator|=
name|sort_hook
argument_list|(
operator|*
name|pEntry
operator|->
name|paHooks
argument_list|,
name|pEntry
operator|->
name|szHookName
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NETWARE
end_ifndef

begin_decl_stmt
specifier|static
name|apr_hash_t
modifier|*
name|s_phOptionalHooks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|apr_hash_t
modifier|*
name|s_phOptionalFunctions
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hook_deregister_all
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|s_aHooksToSort
condition|)
block|{
return|return;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|s_aHooksToSort
operator|->
name|nelts
condition|;
operator|++
name|n
control|)
block|{
name|HookSortEntry
modifier|*
name|pEntry
init|=
operator|&
operator|(
operator|(
name|HookSortEntry
operator|*
operator|)
name|s_aHooksToSort
operator|->
name|elts
operator|)
index|[
name|n
index|]
decl_stmt|;
operator|*
name|pEntry
operator|->
name|paHooks
operator|=
name|NULL
expr_stmt|;
block|}
name|s_aHooksToSort
operator|=
name|NULL
expr_stmt|;
name|s_phOptionalHooks
operator|=
name|NULL
expr_stmt|;
name|s_phOptionalFunctions
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hook_debug_show
argument_list|(
argument|const char *szName
argument_list|,
argument|const char * const *aszPre
argument_list|,
argument|const char * const *aszSucc
argument_list|)
end_macro

begin_block
block|{
name|int
name|nFirst
decl_stmt|;
name|printf
argument_list|(
literal|"  Hooked %s"
argument_list|,
name|szName
argument_list|)
expr_stmt|;
if|if
condition|(
name|aszPre
condition|)
block|{
name|fputs
argument_list|(
literal|" pre("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nFirst
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|aszPre
condition|)
block|{
if|if
condition|(
operator|!
name|nFirst
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nFirst
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
operator|*
name|aszPre
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|aszPre
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aszSucc
condition|)
block|{
name|fputs
argument_list|(
literal|" succ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nFirst
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|aszSucc
condition|)
block|{
if|if
condition|(
operator|!
name|nFirst
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nFirst
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
operator|*
name|aszSucc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|aszSucc
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Optional hook support */
end_comment

begin_macro
name|APR_DECLARE_EXTERNAL_HOOK
argument_list|(
argument|apr
argument_list|,
argument|APU
argument_list|,
argument|void
argument_list|,
argument|_optional
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_array_header_t *
argument_list|)
end_macro

begin_macro
name|apr_optional_hook_get
argument_list|(
argument|const char *szName
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
name|apr_array_header_t
modifier|*
modifier|*
name|ppArray
decl_stmt|;
if|if
condition|(
operator|!
name|s_phOptionalHooks
condition|)
return|return
name|NULL
return|;
name|ppArray
operator|=
name|apr_hash_get
argument_list|(
name|s_phOptionalHooks
argument_list|,
name|szName
argument_list|,
name|strlen
argument_list|(
name|szName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppArray
condition|)
return|return
name|NULL
return|;
return|return
operator|*
name|ppArray
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_optional_hook_add
argument_list|(
argument|const char *szName
argument_list|,
argument|void (*pfn)(void)
argument_list|,
argument|const char * const *aszPre
argument_list|,
argument|const char * const *aszSucc
argument_list|,
argument|int nOrder
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
name|apr_array_header_t
modifier|*
name|pArray
init|=
name|apr_optional_hook_get
argument_list|(
name|szName
argument_list|)
decl_stmt|;
name|apr_LINK__optional_t
modifier|*
name|pHook
decl_stmt|;
if|if
condition|(
operator|!
name|pArray
condition|)
block|{
name|apr_array_header_t
modifier|*
modifier|*
name|ppArray
decl_stmt|;
name|pArray
operator|=
name|apr_array_make
argument_list|(
name|apr_hook_global_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_LINK__optional_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_phOptionalHooks
condition|)
name|s_phOptionalHooks
operator|=
name|apr_hash_make
argument_list|(
name|apr_hook_global_pool
argument_list|)
expr_stmt|;
name|ppArray
operator|=
name|apr_palloc
argument_list|(
name|apr_hook_global_pool
argument_list|,
sizeof|sizeof
expr|*
name|ppArray
argument_list|)
expr_stmt|;
operator|*
name|ppArray
operator|=
name|pArray
expr_stmt|;
name|apr_hash_set
argument_list|(
name|s_phOptionalHooks
argument_list|,
name|szName
argument_list|,
name|strlen
argument_list|(
name|szName
argument_list|)
argument_list|,
name|ppArray
argument_list|)
expr_stmt|;
name|apr_hook_sort_register
argument_list|(
name|szName
argument_list|,
name|ppArray
argument_list|)
expr_stmt|;
block|}
name|pHook
operator|=
name|apr_array_push
argument_list|(
name|pArray
argument_list|)
expr_stmt|;
name|pHook
operator|->
name|pFunc
operator|=
name|pfn
expr_stmt|;
name|pHook
operator|->
name|aszPredecessors
operator|=
name|aszPre
expr_stmt|;
name|pHook
operator|->
name|aszSuccessors
operator|=
name|aszSucc
expr_stmt|;
name|pHook
operator|->
name|nOrder
operator|=
name|nOrder
expr_stmt|;
name|pHook
operator|->
name|szName
operator|=
name|apr_hook_debug_current
expr_stmt|;
if|if
condition|(
name|apr_hook_debug_enabled
condition|)
name|apr_hook_debug_show
argument_list|(
name|szName
argument_list|,
name|aszPre
argument_list|,
name|aszSucc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* optional function support */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_opt_fn_t *
argument_list|)
end_macro

begin_macro
name|apr_dynamic_fn_retrieve
argument_list|(
argument|const char *szName
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
if|if
condition|(
operator|!
name|s_phOptionalFunctions
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|apr_hash_get
argument_list|(
name|s_phOptionalFunctions
argument_list|,
name|szName
argument_list|,
name|strlen
argument_list|(
name|szName
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Deprecated */
end_comment

begin_macro
name|APU_DECLARE_NONSTD
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_dynamic_fn_register
argument_list|(
argument|const char *szName
argument_list|,
argument|apr_opt_fn_t *pfn
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
name|get_apd
endif|#
directive|endif
if|if
condition|(
operator|!
name|s_phOptionalFunctions
condition|)
name|s_phOptionalFunctions
operator|=
name|apr_hash_make
argument_list|(
name|apr_hook_global_pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|s_phOptionalFunctions
argument_list|,
name|szName
argument_list|,
name|strlen
argument_list|(
name|szName
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pfn
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void main() {     const char *aszAPre[]={"b","c",NULL};     const char *aszBPost[]={"a",NULL};     const char *aszCPost[]={"b",NULL};     TSortData t1[]=     {         { "a",aszAPre,NULL },         { "b",NULL,aszBPost },         { "c",NULL,aszCPost }     };     TSort *pResult;      pResult=prepare(t1,3);     pResult=tsort(pResult,3);      for( ; pResult ; pResult=pResult->pNext)         printf("%s\n",pResult->pData->szName); }
endif|#
directive|endif
end_endif

end_unit

