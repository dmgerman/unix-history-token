begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/* Developed initially by Nick Kew and Chris Darroch.  * Contributed to the APR project by kind permission of  * Pearson Education Core Technology Group (CTG),  * formerly Central Media Group (CMG).  */
end_comment

begin_comment
comment|/* apr_dbd_oracle - a painful attempt  *  * Based first on the documentation at  * http://download-west.oracle.com/docs/cd/B10501_01/appdev.920/a96584/toc.htm  *  * Those docs have a lot of internal inconsistencies, contradictions, etc  * So I've snarfed the demo programs (from Oracle 8, not included in  * the current downloadable oracle), and used code from them.  *  * Why do cdemo81.c and cdemo82.c do the same thing in very different ways?  * e.g. cdemo82 releases all its handle on shutdown; cdemo81 doesn't  *  * All the ORA* functions return a "sword".  Some of them are documented;  * others aren't.  So I've adopted a policy of using switch statements  * everywhere, even when we're not doing anything with the return values.  *  * This makes no attempt at performance tuning, such as setting  * prefetch cache size.  We need some actual performance data  * to make that meaningful.  Input from someone with experience  * as a sysop using oracle would be a good start.  */
end_comment

begin_comment
comment|/* shut compiler up */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|int_errorcode
value|int errorcode
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|int_errorcode
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_if
if|#
directive|if
name|APU_HAVE_ORACLE
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<oci.h>
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_include
include|#
directive|include
file|"apr_buckets.h"
end_include

begin_define
define|#
directive|define
name|TRANS_TIMEOUT
value|30
end_define

begin_define
define|#
directive|define
name|MAX_ARG_LEN
value|256
end_define

begin_comment
comment|/* in line with other apr_dbd drivers.  We alloc this                          * lots of times, so a large value gets hungry.                          * Should really make it configurable                          */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_LONG_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|DBD_ORACLE_MAX_COLUMNS
value|256
end_define

begin_define
define|#
directive|define
name|NUMERIC_FIELD_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|CHECK_CONN_QUERY
value|"SELECT 1 FROM dual"
end_define

begin_define
define|#
directive|define
name|ERR_BUF_SIZE
value|200
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"apr_dbd_internal.h"
end_include

begin_comment
comment|/* declarations */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dbd_oracle_error
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbd_oracle_prepare
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|nvals
parameter_list|,
name|apr_dbd_type_e
modifier|*
name|types
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
modifier|*
name|statement
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|outputParams
parameter_list|(
name|apr_dbd_t
modifier|*
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbd_oracle_pselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbd_oracle_pquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbd_oracle_start_transaction
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_transaction_t
modifier|*
modifier|*
name|trans
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbd_oracle_end_transaction
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|apr_dbd_transaction_t
block|{
name|int
name|mode
decl_stmt|;
enum|enum
block|{
name|TRANS_NONE
block|,
name|TRANS_ERROR
block|,
name|TRANS_1
block|,
name|TRANS_2
block|}
name|status
enum|;
name|apr_dbd_t
modifier|*
name|handle
decl_stmt|;
name|OCITrans
modifier|*
name|trans
decl_stmt|;
name|OCISnapshot
modifier|*
name|snapshot1
decl_stmt|;
name|OCISnapshot
modifier|*
name|snapshot2
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_results_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_dbd_t
modifier|*
name|handle
decl_stmt|;
name|unsigned
name|int
name|rownum
decl_stmt|;
name|int
name|seek
decl_stmt|;
name|int
name|nrows
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|statement
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_t
block|{
name|sword
name|status
decl_stmt|;
name|OCIError
modifier|*
name|err
decl_stmt|;
name|OCIServer
modifier|*
name|svr
decl_stmt|;
name|OCISvcCtx
modifier|*
name|svc
decl_stmt|;
name|OCISession
modifier|*
name|auth
decl_stmt|;
name|apr_dbd_transaction_t
modifier|*
name|trans
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|char
name|buf
index|[
name|ERR_BUF_SIZE
index|]
decl_stmt|;
comment|/* for error messages */
name|apr_size_t
name|long_size
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|check_conn_stmt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_row_t
block|{
name|int
name|n
decl_stmt|;
name|apr_dbd_results_t
modifier|*
name|res
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|apr_dbd_type_e
name|type
decl_stmt|;
name|sb2
name|ind
decl_stmt|;
name|sb4
name|len
decl_stmt|;
name|OCIBind
modifier|*
name|bind
decl_stmt|;
union|union
block|{
name|void
modifier|*
name|raw
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
name|int
name|ival
decl_stmt|;
name|unsigned
name|int
name|uval
decl_stmt|;
name|double
name|fval
decl_stmt|;
name|OCILobLocator
modifier|*
name|lobval
decl_stmt|;
block|}
name|value
union|;
block|}
name|bind_arg
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|sb2
name|ind
decl_stmt|;
name|ub2
name|len
decl_stmt|;
comment|/* length of actual output */
name|OCIDefine
modifier|*
name|defn
decl_stmt|;
name|apr_size_t
name|sz
decl_stmt|;
comment|/* length of buf for output */
union|union
block|{
name|void
modifier|*
name|raw
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
name|OCILobLocator
modifier|*
name|lobval
decl_stmt|;
block|}
name|buf
union|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|define_arg
typedef|;
end_typedef

begin_struct
struct|struct
name|apr_dbd_prepared_t
block|{
name|OCIStmt
modifier|*
name|stmt
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|nvals
decl_stmt|;
name|bind_arg
modifier|*
name|args
decl_stmt|;
name|int
name|nout
decl_stmt|;
name|define_arg
modifier|*
name|out
decl_stmt|;
name|apr_dbd_t
modifier|*
name|handle
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|ub2
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* AFAICT from the docs, the OCIEnv thingey can be used async  * across threads, so lets have a global one.  *  * We'll need shorter-lived envs to deal with requests and connections  *  * Hmmm, that doesn't work: we don't have a usermem framework.  * OK, forget about using APR pools here, until we figure out  * the right way to do it (if such a thing exists).  */
end_comment

begin_decl_stmt
specifier|static
name|OCIEnv
modifier|*
name|dbd_oracle_env
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Oracle specific bucket for BLOB/CLOB types */
end_comment

begin_typedef
typedef|typedef
name|struct
name|apr_bucket_lob
name|apr_bucket_lob
typedef|;
end_typedef

begin_comment
comment|/**  * A bucket referring to a Oracle BLOB/CLOB  */
end_comment

begin_struct
struct|struct
name|apr_bucket_lob
block|{
comment|/** Number of buckets using this memory */
name|apr_bucket_refcount
name|refcount
decl_stmt|;
comment|/** The row this bucket refers to */
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
decl_stmt|;
comment|/** The column this bucket refers to */
name|int
name|col
decl_stmt|;
comment|/** The pool into which any needed structures should      *  be created while reading from this bucket */
name|apr_pool_t
modifier|*
name|readpool
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|lob_bucket_destroy
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|lob_bucket_read
parameter_list|(
name|apr_bucket
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_read_type_e
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_bucket
modifier|*
name|apr_bucket_lob_make
parameter_list|(
name|apr_bucket
modifier|*
name|b
parameter_list|,
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|col
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_bucket
modifier|*
name|apr_bucket_lob_create
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|col
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|,
name|apr_bucket_alloc_t
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|apr_bucket_type_t
name|apr_bucket_type_lob
init|=
block|{
literal|"LOB"
block|,
literal|5
block|,
name|APR_BUCKET_DATA
block|,
name|lob_bucket_destroy
block|,
name|lob_bucket_read
block|,
name|apr_bucket_setaside_notimpl
block|,
name|apr_bucket_shared_split
block|,
name|apr_bucket_shared_copy
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|lob_bucket_destroy
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_lob
modifier|*
name|f
init|=
name|data
decl_stmt|;
if|if
condition|(
name|apr_bucket_shared_destroy
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* no need to destroy database objects here; it will get          * done automatically when the pool gets cleaned up */
name|apr_bucket_free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|lob_bucket_read
parameter_list|(
name|apr_bucket
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_read_type_e
name|block
parameter_list|)
block|{
name|apr_bucket_lob
modifier|*
name|a
init|=
name|e
operator|->
name|data
decl_stmt|;
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
init|=
name|a
operator|->
name|row
decl_stmt|;
name|apr_dbd_results_t
modifier|*
name|res
init|=
name|row
operator|->
name|res
decl_stmt|;
name|int
name|col
init|=
name|a
operator|->
name|col
decl_stmt|;
name|apr_bucket
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|blength
init|=
name|e
operator|->
name|length
decl_stmt|;
comment|/* bytes remaining in file past offset */
name|apr_off_t
name|boffset
init|=
name|e
operator|->
name|start
decl_stmt|;
name|define_arg
modifier|*
name|val
init|=
operator|&
name|res
operator|->
name|statement
operator|->
name|out
index|[
name|col
index|]
decl_stmt|;
name|apr_dbd_t
modifier|*
name|sql
init|=
name|res
operator|->
name|handle
decl_stmt|;
comment|/* Only with 10g, unfortunately     oraub8 length = APR_BUCKET_BUFF_SIZE; */
name|ub4
name|length
init|=
name|APR_BUCKET_BUFF_SIZE
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
comment|/* in case we die prematurely */
comment|/* fetch from offset if not at the beginning */
name|buf
operator|=
name|apr_palloc
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|APR_BUCKET_BUFF_SIZE
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCILobRead
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|val
operator|->
name|buf
operator|.
name|lobval
argument_list|,
operator|&
name|length
argument_list|,
literal|1
operator|+
operator|(
name|size_t
operator|)
name|boffset
argument_list|,
operator|(
name|dvoid
operator|*
operator|)
name|buf
argument_list|,
name|APR_BUCKET_BUFF_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SQLCS_IMPLICIT
argument_list|)
expr_stmt|;
comment|/* Only with 10g, unfortunately     sql->status = OCILobRead2(sql->svc, sql->err, val->buf.lobval,&length, NULL, 1 + boffset,                               (dvoid*) buf, APR_BUCKET_BUFF_SIZE,                               OCI_ONE_PIECE, NULL, NULL, 0, SQLCS_IMPLICIT); */
if|if
condition|(
name|sql
operator|->
name|status
operator|!=
name|OCI_SUCCESS
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
name|blength
operator|-=
name|length
expr_stmt|;
operator|*
name|len
operator|=
name|length
expr_stmt|;
operator|*
name|str
operator|=
name|buf
expr_stmt|;
comment|/*      * Change the current bucket to refer to what we read,      * even if we read nothing because we hit EOF.      */
name|apr_bucket_pool_make
argument_list|(
name|e
argument_list|,
operator|*
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|res
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* If we have more to read from the field, then create another bucket */
if|if
condition|(
name|blength
operator|>
literal|0
condition|)
block|{
comment|/* for efficiency, we can just build a new apr_bucket struct          * to wrap around the existing LOB bucket */
name|b
operator|=
name|apr_bucket_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|,
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
name|b
operator|->
name|start
operator|=
name|boffset
operator|+
operator|*
name|len
expr_stmt|;
name|b
operator|->
name|length
operator|=
name|blength
expr_stmt|;
name|b
operator|->
name|data
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|type
operator|=
operator|&
name|apr_bucket_type_lob
expr_stmt|;
name|b
operator|->
name|free
operator|=
name|apr_bucket_free
expr_stmt|;
name|b
operator|->
name|list
operator|=
name|e
operator|->
name|list
expr_stmt|;
name|APR_BUCKET_INSERT_AFTER
argument_list|(
name|e
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lob_bucket_destroy
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_bucket
modifier|*
name|apr_bucket_lob_make
parameter_list|(
name|apr_bucket
modifier|*
name|b
parameter_list|,
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|col
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|apr_bucket_lob
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|apr_bucket_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|,
name|b
operator|->
name|list
argument_list|)
expr_stmt|;
name|f
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|f
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|f
operator|->
name|readpool
operator|=
name|p
expr_stmt|;
name|b
operator|=
name|apr_bucket_shared_make
argument_list|(
name|b
argument_list|,
name|f
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
operator|&
name|apr_bucket_type_lob
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|apr_bucket
modifier|*
name|apr_bucket_lob_create
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|col
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|,
name|apr_bucket_alloc_t
modifier|*
name|list
parameter_list|)
block|{
name|apr_bucket
modifier|*
name|b
init|=
name|apr_bucket_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|APR_BUCKET_INIT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|free
operator|=
name|apr_bucket_free
expr_stmt|;
name|b
operator|->
name|list
operator|=
name|list
expr_stmt|;
return|return
name|apr_bucket_lob_make
argument_list|(
name|b
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_free_lobdesc
parameter_list|(
name|void
modifier|*
name|lob
parameter_list|)
block|{
switch|switch
condition|(
name|OCIDescriptorFree
argument_list|(
name|lob
argument_list|,
name|OCI_DTYPE_LOB
argument_list|)
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
return|return
name|APR_SUCCESS
return|;
default|default:
return|return
name|APR_EGENERAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_free_snapshot
parameter_list|(
name|void
modifier|*
name|snap
parameter_list|)
block|{
switch|switch
condition|(
name|OCIDescriptorFree
argument_list|(
name|snap
argument_list|,
name|OCI_DTYPE_SNAP
argument_list|)
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
return|return
name|APR_SUCCESS
return|;
default|default:
return|return
name|APR_EGENERAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dbd_oracle_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|dbd_oracle_env
operator|==
name|NULL
condition|)
block|{
comment|/* Sadly, OCI_SHARED seems to be impossible to use, due to          * various Oracle bugs.  See, for example, Oracle MetaLink bug 2972890          * and PHP bug http://bugs.php.net/bug.php?id=23733          */
ifdef|#
directive|ifdef
name|OCI_NEW_LENGTH_SEMANTICS
name|OCIEnvCreate
argument_list|(
operator|&
name|dbd_oracle_env
argument_list|,
name|OCI_THREADED
operator||
name|OCI_NEW_LENGTH_SEMANTICS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|OCIEnvCreate
argument_list|(
operator|&
name|dbd_oracle_env
argument_list|,
name|OCI_THREADED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|apr_dbd_t
modifier|*
name|dbd_oracle_open
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|apr_dbd_t
modifier|*
name|ret
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|errorcode
decl_stmt|;
name|char
modifier|*
name|BLANK
init|=
literal|""
decl_stmt|;
struct|struct
block|{
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|fields
index|[]
init|=
block|{
block|{
literal|"user"
block|,
name|BLANK
block|}
block|,
block|{
literal|"pass"
block|,
name|BLANK
block|}
block|,
block|{
literal|"dbname"
block|,
name|BLANK
block|}
block|,
block|{
literal|"server"
block|,
name|BLANK
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|size_t
name|klen
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|delims
init|=
literal|" \r\n\t;|,"
decl_stmt|;
name|ret
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ret
operator|->
name|long_size
operator|=
name|DEFAULT_LONG_SIZE
expr_stmt|;
comment|/* snitch parsing from the MySQL driver */
for|for
control|(
name|ptr
operator|=
name|strchr
argument_list|(
name|params
argument_list|,
literal|'='
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'='
argument_list|)
control|)
block|{
comment|/* don't dereference memory that may not belong to us */
if|if
condition|(
name|ptr
operator|==
name|params
condition|)
block|{
operator|++
name|ptr
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|key
operator|=
name|ptr
operator|-
literal|1
init|;
name|apr_isspace
argument_list|(
operator|*
name|key
argument_list|)
condition|;
operator|--
name|key
control|)
empty_stmt|;
name|klen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|apr_isalpha
argument_list|(
operator|*
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|params
condition|)
block|{
comment|/* Don't parse off the front of the params */
operator|--
name|key
expr_stmt|;
operator|++
name|klen
expr_stmt|;
break|break;
block|}
operator|--
name|key
expr_stmt|;
operator|++
name|klen
expr_stmt|;
block|}
operator|++
name|key
expr_stmt|;
for|for
control|(
name|value
operator|=
name|ptr
operator|+
literal|1
init|;
name|apr_isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|;
operator|++
name|value
control|)
empty_stmt|;
name|vlen
operator|=
name|strcspn
argument_list|(
name|value
argument_list|,
name|delims
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fields
index|[
name|i
index|]
operator|.
name|field
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|fields
index|[
name|i
index|]
operator|.
name|field
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|fields
index|[
name|i
index|]
operator|.
name|value
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ptr
operator|=
name|value
operator|+
name|vlen
expr_stmt|;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|ret
operator|->
name|err
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"ret->status is %d\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|ret
operator|->
name|svr
argument_list|,
name|OCI_HTYPE_SERVER
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (alloc svr): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|ret
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (alloc svc): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
comment|/* All the examples use the #else */
if|#
directive|if
name|CAN_DO_LOGIN
name|ret
operator|->
name|status
operator|=
name|OCILogon
argument_list|(
name|dbd_oracle_env
argument_list|,
name|ret
operator|->
name|err
argument_list|,
operator|&
name|ret
operator|->
name|svc
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|value
argument_list|,
name|strlen
argument_list|(
name|fields
index|[
literal|0
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|value
argument_list|,
name|strlen
argument_list|(
name|fields
index|[
literal|1
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|fields
index|[
literal|2
index|]
operator|.
name|value
argument_list|,
name|strlen
argument_list|(
name|fields
index|[
literal|2
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR: %s\n"
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
else|#
directive|else
name|ret
operator|->
name|status
operator|=
name|OCIServerAttach
argument_list|(
name|ret
operator|->
name|svr
argument_list|,
name|ret
operator|->
name|err
argument_list|,
operator|(
name|text
operator|*
operator|)
name|fields
index|[
literal|3
index|]
operator|.
name|value
argument_list|,
name|strlen
argument_list|(
name|fields
index|[
literal|3
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (server attach): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIAttrSet
argument_list|(
name|ret
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
name|ret
operator|->
name|svr
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_SERVER
argument_list|,
name|ret
operator|->
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (attr set): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|ret
operator|->
name|auth
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (alloc auth): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIAttrSet
argument_list|(
name|ret
operator|->
name|auth
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|value
argument_list|,
name|strlen
argument_list|(
name|fields
index|[
literal|0
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|OCI_ATTR_USERNAME
argument_list|,
name|ret
operator|->
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (attr username): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIAttrSet
argument_list|(
name|ret
operator|->
name|auth
argument_list|,
name|OCI_HTYPE_SESSION
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|value
argument_list|,
name|strlen
argument_list|(
name|fields
index|[
literal|1
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|OCI_ATTR_PASSWORD
argument_list|,
name|ret
operator|->
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (attr password): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCISessionBegin
argument_list|(
name|ret
operator|->
name|svc
argument_list|,
name|ret
operator|->
name|err
argument_list|,
name|ret
operator|->
name|auth
argument_list|,
name|OCI_CRED_RDBMS
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (session begin): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
name|ret
operator|->
name|status
operator|=
name|OCIAttrSet
argument_list|(
name|ret
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
name|ret
operator|->
name|auth
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_SESSION
argument_list|,
name|ret
operator|->
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|status
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|ret
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPEN ERROR %d (attr session): %s\n"
argument_list|,
name|ret
operator|->
name|status
argument_list|,
name|ret
operator|->
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|error
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ERR_BUF_SIZE
argument_list|)
expr_stmt|;
name|OCIErrorGet
argument_list|(
name|ret
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|error
operator|)
argument_list|,
name|ERR_BUF_SIZE
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
endif|#
directive|endif
break|break;
case|case
name|OCI_SUCCESS
case|:
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|dbd_oracle_prepare
argument_list|(
name|pool
argument_list|,
name|ret
argument_list|,
name|CHECK_CONN_QUERY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|ret
operator|->
name|check_conn_stmt
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EXPORT_NATIVE_FUNCS
end_ifdef

begin_function
specifier|static
name|apr_size_t
name|dbd_oracle_long_size_set
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_size_t
name|long_size
parameter_list|)
block|{
name|apr_size_t
name|old_size
init|=
name|sql
operator|->
name|long_size
decl_stmt|;
name|sql
operator|->
name|long_size
operator|=
name|long_size
expr_stmt|;
return|return
name|old_size
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_oracle_get_name
parameter_list|(
specifier|const
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|define_arg
modifier|*
name|val
init|=
operator|&
name|res
operator|->
name|statement
operator|->
name|out
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|>=
name|res
operator|->
name|statement
operator|->
name|nout
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|val
operator|->
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_get_row
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|apr_dbd_row_t
modifier|*
modifier|*
name|rowp
parameter_list|,
name|int
name|rownum
parameter_list|)
block|{
name|apr_dbd_row_t
modifier|*
name|row
init|=
operator|*
name|rowp
decl_stmt|;
name|apr_dbd_t
modifier|*
name|sql
init|=
name|res
operator|->
name|handle
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
name|row
operator|==
name|NULL
condition|)
block|{
name|row
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_row_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rowp
operator|=
name|row
expr_stmt|;
name|row
operator|->
name|res
operator|=
name|res
expr_stmt|;
comment|/* Oracle starts counting at 1 according to the docs */
name|row
operator|->
name|n
operator|=
name|res
operator|->
name|seek
condition|?
name|rownum
else|:
literal|1
expr_stmt|;
name|row
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|res
operator|->
name|seek
condition|)
block|{
name|row
operator|->
name|n
operator|=
name|rownum
expr_stmt|;
block|}
else|else
block|{
operator|++
name|row
operator|->
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|res
operator|->
name|seek
condition|)
block|{
name|sql
operator|->
name|status
operator|=
name|OCIStmtFetch2
argument_list|(
name|res
operator|->
name|statement
operator|->
name|stmt
argument_list|,
name|res
operator|->
name|handle
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|OCI_FETCH_ABSOLUTE
argument_list|,
name|row
operator|->
name|n
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sql
operator|->
name|status
operator|=
name|OCIStmtFetch2
argument_list|(
name|res
operator|->
name|statement
operator|->
name|stmt
argument_list|,
name|res
operator|->
name|handle
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|OCI_FETCH_NEXT
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
operator|(
operator|*
name|rowp
operator|)
operator|->
name|res
operator|=
name|res
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OCI_NO_DATA
case|:
return|return
operator|-
literal|1
return|;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Execute error %d: %s\n"
argument_list|,
name|sql
operator|->
name|status
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fallthrough */
default|default:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_oracle_error
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* This is ugly.  Needs us to pass in a buffer of unknown size.      * Either we put it on the handle, or we have to keep allocing/copying      */
name|sb4
name|errorcode
decl_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
return|return
literal|"OCI_SUCCESS"
return|;
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
return|return
literal|"OCI_SUCCESS_WITH_INFO"
return|;
case|case
name|OCI_NEED_DATA
case|:
return|return
literal|"OCI_NEED_DATA"
return|;
case|case
name|OCI_NO_DATA
case|:
return|return
literal|"OCI_NO_DATA"
return|;
case|case
name|OCI_INVALID_HANDLE
case|:
return|return
literal|"OCI_INVALID_HANDLE"
return|;
case|case
name|OCI_STILL_EXECUTING
case|:
return|return
literal|"OCI_STILL_EXECUTING"
return|;
case|case
name|OCI_CONTINUE
case|:
return|return
literal|"OCI_CONTINUE"
return|;
block|}
switch|switch
condition|(
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
operator|(
name|text
operator|*
operator|)
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
return|return
name|sql
operator|->
name|buf
return|;
default|default:
return|return
literal|"internal error: OCIErrorGet failed"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|freeStatement
parameter_list|(
name|void
modifier|*
name|statement
parameter_list|)
block|{
name|int
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|OCIStmt
modifier|*
name|stmt
init|=
operator|(
operator|(
name|apr_dbd_prepared_t
operator|*
operator|)
name|statement
operator|)
operator|->
name|stmt
decl_stmt|;
ifdef|#
directive|ifdef
name|PREPARE2
name|OCIError
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|err
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
name|OCI_SUCCESS
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
if|if
condition|(
name|OCIStmtRelease
argument_list|(
name|stmt
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|rv
operator|=
name|APR_EGENERAL
expr_stmt|;
block|}
if|if
condition|(
name|OCIHandleFree
argument_list|(
name|err
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|rv
operator|=
name|APR_EGENERAL
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|OCIHandleFree
argument_list|(
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|)
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|rv
operator|=
name|APR_EGENERAL
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_select
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
name|int
name|seek
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|statement
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|dbd_oracle_prepare
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|query
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|statement
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|dbd_oracle_pselect
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|results
argument_list|,
name|statement
argument_list|,
name|seek
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_query
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|statement
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|status
operator|==
name|TRANS_ERROR
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* make our own pool so that APR allocations don't linger and so that      * both Stmt and LOB handles are cleaned up (LOB handles may be      * allocated when preparing APR_DBD_TYPE_CLOB/BLOBs)      */
name|apr_pool_create
argument_list|(
operator|&
name|pool
argument_list|,
name|sql
operator|->
name|pool
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dbd_oracle_prepare
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|query
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|statement
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|dbd_oracle_pquery
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|nrows
argument_list|,
name|statement
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|nrows
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_ROW_COUNT
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|apr_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_oracle_escape
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|)
block|{
return|return
name|arg
return|;
comment|/* OCI has no concept of string escape */
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_prepare
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|nvals
parameter_list|,
name|apr_dbd_type_e
modifier|*
name|types
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
modifier|*
name|statement
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|stmt
decl_stmt|;
if|if
condition|(
operator|*
name|statement
operator|==
name|NULL
condition|)
block|{
operator|*
name|statement
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_prepared_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
operator|*
name|statement
expr_stmt|;
name|stmt
operator|->
name|handle
operator|=
name|sql
expr_stmt|;
name|stmt
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|stmt
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|stmt
operator|->
name|nvals
operator|=
name|nvals
expr_stmt|;
comment|/* populate our own args, if any */
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
name|stmt
operator|->
name|args
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|bind_arg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|stmt
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
operator|=
name|types
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|sql
operator|->
name|status
operator|=
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|stmt
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sql
operator|->
name|status
operator|!=
name|OCI_SUCCESS
condition|)
block|{
return|return
literal|1
return|;
block|}
name|sql
operator|->
name|status
operator|=
name|OCIStmtPrepare
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
name|sql
operator|->
name|err
argument_list|,
operator|(
name|text
operator|*
operator|)
name|query
argument_list|,
name|strlen
argument_list|(
name|query
argument_list|)
argument_list|,
name|OCI_NTV_SYNTAX
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sql
operator|->
name|status
operator|!=
name|OCI_SUCCESS
condition|)
block|{
name|OCIHandleFree
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|stmt
argument_list|,
name|freeStatement
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Perl gets statement type here */
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
operator|&
name|stmt
operator|->
name|type
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_STMT_TYPE
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|sql
operator|->
name|status
operator|!=
name|OCI_SUCCESS
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Perl sets PREFETCH_MEMORY here, but the docs say there's a working default */
if|#
directive|if
literal|0
block|sql->status = OCIAttrSet(stmt->stmt, OCI_HTYPE_STMT,&prefetch_size,                              sizeof(prefetch_size), OCI_ATTR_PREFETCH_MEMORY,                              sql->err);     if (sql->status != OCI_SUCCESS) {         return 1;     }
endif|#
directive|endif
if|if
condition|(
name|stmt
operator|->
name|type
operator|==
name|OCI_STMT_SELECT
condition|)
block|{
name|ret
operator|=
name|outputParams
argument_list|(
name|sql
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbd_oracle_bind
parameter_list|(
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|OCIStmt
modifier|*
name|stmt
init|=
name|statement
operator|->
name|stmt
decl_stmt|;
name|apr_dbd_t
modifier|*
name|sql
init|=
name|statement
operator|->
name|handle
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sb2
name|null_ind
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|==
name|NULL
condition|)
block|{
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|null_ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|APR_DBD_TYPE_BLOB
case|:
block|{
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|values
index|[
name|j
index|]
decl_stmt|;
name|int
name|size
init|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|values
index|[
operator|++
name|j
index|]
argument_list|)
decl_stmt|;
comment|/* skip table and column for now */
name|j
operator|+=
literal|2
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|SQLT_LBI
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APR_DBD_TYPE_CLOB
case|:
block|{
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|values
index|[
name|j
index|]
decl_stmt|;
name|int
name|size
init|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|values
index|[
operator|++
name|j
index|]
argument_list|)
decl_stmt|;
comment|/* skip table and column for now */
name|j
operator|+=
literal|2
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|SQLT_LNG
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|(
name|dvoid
operator|*
operator|)
name|values
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|values
index|[
name|j
index|]
argument_list|)
operator|+
literal|1
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sql
operator|->
name|status
operator|!=
name|OCI_SUCCESS
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|outputParams
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|stmt
parameter_list|)
block|{
name|OCIParam
modifier|*
name|parms
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ub2
name|paramtype
index|[
name|DBD_ORACLE_MAX_COLUMNS
index|]
decl_stmt|;
name|ub2
name|paramsize
index|[
name|DBD_ORACLE_MAX_COLUMNS
index|]
decl_stmt|;
name|char
modifier|*
name|paramname
index|[
name|DBD_ORACLE_MAX_COLUMNS
index|]
decl_stmt|;
name|ub4
name|paramnamelen
index|[
name|DBD_ORACLE_MAX_COLUMNS
index|]
decl_stmt|;
name|int_errorcode
expr_stmt|;
comment|/* Perl uses 0 where we used 1 */
name|sql
operator|->
name|status
operator|=
name|OCIStmtExecute
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|stmt
operator|->
name|stmt
argument_list|,
name|sql
operator|->
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|OCI_DESCRIBE_ONLY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
break|break;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Describing prepared statement: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
default|default:
return|return
literal|1
return|;
block|}
while|while
condition|(
name|sql
operator|->
name|status
operator|==
name|OCI_SUCCESS
condition|)
block|{
name|sql
operator|->
name|status
operator|=
name|OCIParamGet
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|sql
operator|->
name|err
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|parms
argument_list|,
name|stmt
operator|->
name|nout
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|parms
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|paramtype
index|[
name|stmt
operator|->
name|nout
index|]
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_DATA_TYPE
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|parms
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|paramsize
index|[
name|stmt
operator|->
name|nout
index|]
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_DATA_SIZE
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|parms
argument_list|,
name|OCI_DTYPE_PARAM
argument_list|,
operator|&
name|paramname
index|[
name|stmt
operator|->
name|nout
index|]
argument_list|,
operator|&
name|paramnamelen
index|[
name|stmt
operator|->
name|nout
index|]
argument_list|,
name|OCI_ATTR_NAME
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
operator|++
name|stmt
operator|->
name|nout
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
case|case
name|OCI_ERROR
case|:
break|break;
comment|/* this is what we expect at end-of-loop */
default|default:
return|return
literal|1
return|;
block|}
comment|/* OK, the above works.  We have the params; now OCIDefine them */
name|stmt
operator|->
name|out
operator|=
name|apr_palloc
argument_list|(
name|stmt
operator|->
name|pool
argument_list|,
name|stmt
operator|->
name|nout
operator|*
sizeof|sizeof
argument_list|(
name|define_arg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stmt
operator|->
name|nout
condition|;
operator|++
name|i
control|)
block|{
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|type
operator|=
name|paramtype
index|[
name|i
index|]
expr_stmt|;
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|len
operator|=
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
name|paramsize
index|[
name|i
index|]
expr_stmt|;
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|name
operator|=
name|apr_pstrmemdup
argument_list|(
name|stmt
operator|->
name|pool
argument_list|,
name|paramname
index|[
name|i
index|]
argument_list|,
name|paramnamelen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
default|default:
switch|switch
condition|(
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SQLT_NUM
case|:
comment|/* 2: numeric, Perl worst case=130+38+3 */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
literal|171
expr_stmt|;
break|break;
case|case
name|SQLT_CHR
case|:
comment|/* 1: char */
case|case
name|SQLT_AFC
case|:
comment|/* 96: ANSI fixed char */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|*=
literal|4
expr_stmt|;
comment|/* ugh, wasteful UCS-4 handling */
break|break;
case|case
name|SQLT_DAT
case|:
comment|/* 12: date, depends on NLS date format */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
literal|75
expr_stmt|;
break|break;
case|case
name|SQLT_BIN
case|:
comment|/* 23: raw binary, perhaps UTF-16? */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|*=
literal|2
expr_stmt|;
break|break;
case|case
name|SQLT_RID
case|:
comment|/* 11: rowid */
case|case
name|SQLT_RDD
case|:
comment|/* 104: rowid descriptor */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|SQLT_TIMESTAMP
case|:
comment|/* 187: timestamp */
case|case
name|SQLT_TIMESTAMP_TZ
case|:
comment|/* 188: timestamp with time zone */
case|case
name|SQLT_INTERVAL_YM
case|:
comment|/* 189: interval year-to-month */
case|case
name|SQLT_INTERVAL_DS
case|:
comment|/* 190: interval day-to-second */
case|case
name|SQLT_TIMESTAMP_LTZ
case|:
comment|/* 232: timestamp with local time zone */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
literal|75
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Unsupported data type: %d\n"
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
operator|++
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
expr_stmt|;
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|raw
operator|=
name|apr_palloc
argument_list|(
name|stmt
operator|->
name|pool
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIDefineByPos
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|defn
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|sval
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|len
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_LNG
case|:
comment|/* 8: long */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
name|sql
operator|->
name|long_size
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
comment|/* ugh, UCS-4 handling */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|raw
operator|=
name|apr_palloc
argument_list|(
name|stmt
operator|->
name|pool
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIDefineByPos
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|defn
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|raw
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
argument_list|,
name|SQLT_LVC
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_LBI
case|:
comment|/* 24: long binary, perhaps UTF-16? */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
operator|=
name|sql
operator|->
name|long_size
operator|*
literal|2
operator|+
literal|4
expr_stmt|;
comment|/* room for int prefix */
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|raw
operator|=
name|apr_palloc
argument_list|(
name|stmt
operator|->
name|pool
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIDefineByPos
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|defn
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|raw
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|sz
argument_list|,
name|SQLT_LVB
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQLT_BLOB
case|:
comment|/* 113 */
case|case
name|SQLT_CLOB
case|:
comment|/* 112 */
comment|/*http://download-west.oracle.com/docs/cd/B10501_01/appdev.920/a96584/oci05bnd.htm#434937*/
name|sql
operator|->
name|status
operator|=
name|OCIDescriptorAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|lobval
argument_list|,
name|OCI_DTYPE_LOB
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|stmt
operator|->
name|pool
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|lobval
argument_list|,
name|dbd_free_lobdesc
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIDefineByPos
argument_list|(
name|stmt
operator|->
name|stmt
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|defn
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|(
name|dvoid
operator|*
operator|)
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|buf
operator|.
name|lobval
argument_list|,
operator|-
literal|1
argument_list|,
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|type
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
operator|&
name|stmt
operator|->
name|out
index|[
name|i
index|]
operator|.
name|len
argument_list|,
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
default|default:
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|OCISnapshot
modifier|*
name|oldsnapshot
init|=
name|NULL
decl_stmt|;
name|OCISnapshot
modifier|*
name|newsnapshot
init|=
name|NULL
decl_stmt|;
name|apr_dbd_transaction_t
modifier|*
name|trans
init|=
name|sql
operator|->
name|trans
decl_stmt|;
name|int
name|exec_mode
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
name|trans
condition|)
block|{
switch|switch
condition|(
name|trans
operator|->
name|status
condition|)
block|{
case|case
name|TRANS_ERROR
case|:
return|return
operator|-
literal|1
return|;
case|case
name|TRANS_NONE
case|:
name|trans
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|TRANS_1
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_2
expr_stmt|;
break|break;
case|case
name|TRANS_2
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_1
expr_stmt|;
break|break;
block|}
name|exec_mode
operator|=
name|OCI_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|exec_mode
operator|=
name|OCI_COMMIT_ON_SUCCESS
expr_stmt|;
block|}
name|dbd_oracle_bind
argument_list|(
name|statement
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIStmtExecute
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|statement
operator|->
name|stmt
argument_list|,
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|oldsnapshot
argument_list|,
name|newsnapshot
argument_list|,
name|exec_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Execute error %d: %s\n"
argument_list|,
name|sql
operator|->
name|status
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fallthrough */
default|default:
if|if
condition|(
name|TXN_NOTICE_ERRORS
argument_list|(
name|trans
argument_list|)
condition|)
block|{
name|trans
operator|->
name|status
operator|=
name|TRANS_ERROR
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|nrows
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_ROW_COUNT
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pvquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|status
operator|==
name|TRANS_ERROR
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|dbd_oracle_pquery
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|nrows
argument_list|,
name|statement
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|int
name|exec_mode
init|=
name|seek
condition|?
name|OCI_STMT_SCROLLABLE_READONLY
else|:
name|OCI_DEFAULT
decl_stmt|;
name|OCISnapshot
modifier|*
name|oldsnapshot
init|=
name|NULL
decl_stmt|;
name|OCISnapshot
modifier|*
name|newsnapshot
init|=
name|NULL
decl_stmt|;
name|apr_dbd_transaction_t
modifier|*
name|trans
init|=
name|sql
operator|->
name|trans
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
name|trans
condition|)
block|{
switch|switch
condition|(
name|trans
operator|->
name|status
condition|)
block|{
case|case
name|TRANS_ERROR
case|:
return|return
literal|1
return|;
case|case
name|TRANS_NONE
case|:
name|trans
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|TRANS_1
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_2
expr_stmt|;
break|break;
case|case
name|TRANS_2
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_1
expr_stmt|;
break|break;
block|}
block|}
name|dbd_oracle_bind
argument_list|(
name|statement
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIStmtExecute
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|statement
operator|->
name|stmt
argument_list|,
name|sql
operator|->
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|oldsnapshot
argument_list|,
name|newsnapshot
argument_list|,
name|exec_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Executing prepared statement: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fallthrough */
default|default:
if|if
condition|(
name|TXN_NOTICE_ERRORS
argument_list|(
name|trans
argument_list|)
condition|)
block|{
name|trans
operator|->
name|status
operator|=
name|TRANS_ERROR
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|results
condition|)
block|{
operator|*
name|results
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_results_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|results
operator|)
operator|->
name|handle
operator|=
name|sql
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|statement
operator|=
name|statement
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|seek
operator|=
name|seek
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|rownum
operator|=
name|seek
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pvselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|status
operator|==
name|TRANS_ERROR
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|dbd_oracle_pselect
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|results
argument_list|,
name|statement
argument_list|,
name|seek
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbd_oracle_bbind
parameter_list|(
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|OCIStmt
modifier|*
name|stmt
init|=
name|statement
operator|->
name|stmt
decl_stmt|;
name|apr_dbd_t
modifier|*
name|sql
init|=
name|statement
operator|->
name|handle
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sb2
name|null_ind
init|=
operator|-
literal|1
decl_stmt|;
name|apr_dbd_type_e
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|type
operator|=
operator|(
name|values
index|[
name|j
index|]
operator|==
name|NULL
condition|?
name|APR_DBD_TYPE_NULL
else|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
operator|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|APR_DBD_TYPE_TINY
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
argument_list|)
argument_list|,
name|SQLT_INT
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_UTINY
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
argument_list|)
argument_list|,
name|SQLT_UIN
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_SHORT
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
argument_list|)
argument_list|,
name|SQLT_INT
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_USHORT
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
argument_list|)
argument_list|,
name|SQLT_UIN
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_INT
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|ival
argument_list|)
argument_list|,
name|SQLT_INT
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_UINT
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|uval
argument_list|)
argument_list|,
name|SQLT_UIN
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_LONG
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
operator|=
name|apr_psprintf
argument_list|(
name|statement
operator|->
name|pool
argument_list|,
literal|"%ld"
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|values
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|,
name|strlen
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|)
operator|+
literal|1
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_ULONG
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
operator|=
name|apr_psprintf
argument_list|(
name|statement
operator|->
name|pool
argument_list|,
literal|"%lu"
argument_list|,
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|values
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|,
name|strlen
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|)
operator|+
literal|1
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_LONGLONG
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
operator|=
name|apr_psprintf
argument_list|(
name|statement
operator|->
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
operator|*
operator|(
name|apr_int64_t
operator|*
operator|)
name|values
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|,
name|strlen
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|)
operator|+
literal|1
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_ULONGLONG
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
operator|=
name|apr_psprintf
argument_list|(
name|statement
operator|->
name|pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
operator|*
operator|(
name|apr_uint64_t
operator|*
operator|)
name|values
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|,
name|strlen
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sval
argument_list|)
operator|+
literal|1
argument_list|,
name|SQLT_UIN
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_FLOAT
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|fval
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|fval
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|fval
argument_list|)
argument_list|,
name|SQLT_FLT
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_DOUBLE
case|:
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|fval
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|values
index|[
name|j
index|]
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|fval
argument_list|,
sizeof|sizeof
argument_list|(
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|value
operator|.
name|fval
argument_list|)
argument_list|,
name|SQLT_FLT
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_STRING
case|:
case|case
name|APR_DBD_TYPE_TEXT
case|:
case|case
name|APR_DBD_TYPE_TIME
case|:
case|case
name|APR_DBD_TYPE_DATE
case|:
case|case
name|APR_DBD_TYPE_DATETIME
case|:
case|case
name|APR_DBD_TYPE_TIMESTAMP
case|:
case|case
name|APR_DBD_TYPE_ZTIMESTAMP
case|:
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|(
name|dvoid
operator|*
operator|)
name|values
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|values
index|[
name|j
index|]
argument_list|)
operator|+
literal|1
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_BLOB
case|:
block|{
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|values
index|[
name|j
index|]
decl_stmt|;
name|apr_size_t
name|size
init|=
operator|*
operator|(
name|apr_size_t
operator|*
operator|)
name|values
index|[
operator|++
name|j
index|]
decl_stmt|;
comment|/* skip table and column for now */
name|j
operator|+=
literal|2
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|SQLT_LBI
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APR_DBD_TYPE_CLOB
case|:
block|{
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|values
index|[
name|j
index|]
decl_stmt|;
name|apr_size_t
name|size
init|=
operator|*
operator|(
name|apr_size_t
operator|*
operator|)
name|values
index|[
operator|++
name|j
index|]
decl_stmt|;
comment|/* skip table and column for now */
name|j
operator|+=
literal|2
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|SQLT_LNG
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APR_DBD_TYPE_NULL
case|:
default|default:
name|sql
operator|->
name|status
operator|=
name|OCIBindByPos
argument_list|(
name|stmt
argument_list|,
operator|&
name|statement
operator|->
name|args
index|[
name|i
index|]
operator|.
name|bind
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SQLT_STR
argument_list|,
operator|&
name|null_ind
argument_list|,
name|NULL
argument_list|,
operator|(
name|ub2
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|)
literal|0
argument_list|,
operator|(
name|ub4
operator|*
operator|)
literal|0
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sql
operator|->
name|status
operator|!=
name|OCI_SUCCESS
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pbquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|OCISnapshot
modifier|*
name|oldsnapshot
init|=
name|NULL
decl_stmt|;
name|OCISnapshot
modifier|*
name|newsnapshot
init|=
name|NULL
decl_stmt|;
name|apr_dbd_transaction_t
modifier|*
name|trans
init|=
name|sql
operator|->
name|trans
decl_stmt|;
name|int
name|exec_mode
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
name|trans
condition|)
block|{
switch|switch
condition|(
name|trans
operator|->
name|status
condition|)
block|{
case|case
name|TRANS_ERROR
case|:
return|return
operator|-
literal|1
return|;
case|case
name|TRANS_NONE
case|:
name|trans
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|TRANS_1
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_2
expr_stmt|;
break|break;
case|case
name|TRANS_2
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_1
expr_stmt|;
break|break;
block|}
name|exec_mode
operator|=
name|OCI_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|exec_mode
operator|=
name|OCI_COMMIT_ON_SUCCESS
expr_stmt|;
block|}
name|dbd_oracle_bbind
argument_list|(
name|statement
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIStmtExecute
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|statement
operator|->
name|stmt
argument_list|,
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|oldsnapshot
argument_list|,
name|newsnapshot
argument_list|,
name|exec_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Execute error %d: %s\n"
argument_list|,
name|sql
operator|->
name|status
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fallthrough */
default|default:
if|if
condition|(
name|TXN_NOTICE_ERRORS
argument_list|(
name|trans
argument_list|)
condition|)
block|{
name|trans
operator|->
name|status
operator|=
name|TRANS_ERROR
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|sql
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
name|nrows
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_ROW_COUNT
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pvbquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|status
operator|==
name|TRANS_ERROR
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|dbd_oracle_pbquery
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|nrows
argument_list|,
name|statement
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pbselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|int
name|exec_mode
init|=
name|seek
condition|?
name|OCI_STMT_SCROLLABLE_READONLY
else|:
name|OCI_DEFAULT
decl_stmt|;
name|OCISnapshot
modifier|*
name|oldsnapshot
init|=
name|NULL
decl_stmt|;
name|OCISnapshot
modifier|*
name|newsnapshot
init|=
name|NULL
decl_stmt|;
name|apr_dbd_transaction_t
modifier|*
name|trans
init|=
name|sql
operator|->
name|trans
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
name|trans
condition|)
block|{
switch|switch
condition|(
name|trans
operator|->
name|status
condition|)
block|{
case|case
name|TRANS_ERROR
case|:
return|return
literal|1
return|;
case|case
name|TRANS_NONE
case|:
name|trans
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|TRANS_1
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_2
expr_stmt|;
break|break;
case|case
name|TRANS_2
case|:
name|oldsnapshot
operator|=
name|trans
operator|->
name|snapshot2
expr_stmt|;
name|newsnapshot
operator|=
name|trans
operator|->
name|snapshot1
expr_stmt|;
name|trans
operator|->
name|status
operator|=
name|TRANS_1
expr_stmt|;
break|break;
block|}
block|}
name|dbd_oracle_bbind
argument_list|(
name|statement
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|sql
operator|->
name|status
operator|=
name|OCIStmtExecute
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|statement
operator|->
name|stmt
argument_list|,
name|sql
operator|->
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|oldsnapshot
argument_list|,
name|newsnapshot
argument_list|,
name|exec_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
break|break;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Executing prepared statement: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fallthrough */
default|default:
if|if
condition|(
name|TXN_NOTICE_ERRORS
argument_list|(
name|trans
argument_list|)
condition|)
block|{
name|trans
operator|->
name|status
operator|=
name|TRANS_ERROR
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|results
condition|)
block|{
operator|*
name|results
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_results_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|results
operator|)
operator|->
name|handle
operator|=
name|sql
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|statement
operator|=
name|statement
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|seek
operator|=
name|seek
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|rownum
operator|=
name|seek
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|results
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_pvbselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|status
operator|==
name|TRANS_ERROR
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|dbd_oracle_pbselect
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|results
argument_list|,
name|statement
argument_list|,
name|seek
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_start_transaction
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_transaction_t
modifier|*
modifier|*
name|trans
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
operator|*
name|trans
condition|)
block|{
name|dbd_oracle_end_transaction
argument_list|(
operator|*
name|trans
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|trans
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_transaction_t
argument_list|)
argument_list|)
expr_stmt|;
name|OCIHandleAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|trans
operator|)
operator|->
name|trans
argument_list|,
name|OCI_HTYPE_TRANS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OCIAttrSet
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|OCI_HTYPE_SVCCTX
argument_list|,
operator|(
operator|*
name|trans
operator|)
operator|->
name|trans
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_TRANS
argument_list|,
name|sql
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
name|sql
operator|->
name|status
operator|=
name|OCITransStart
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|TRANS_TIMEOUT
argument_list|,
name|OCI_TRANS_NEW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Transaction: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OCI_SUCCESS
case|:
operator|(
operator|*
name|trans
operator|)
operator|->
name|handle
operator|=
name|sql
expr_stmt|;
operator|(
operator|*
name|trans
operator|)
operator|->
name|status
operator|=
name|TRANS_1
expr_stmt|;
name|sql
operator|->
name|trans
operator|=
operator|*
name|trans
expr_stmt|;
switch|switch
condition|(
name|OCIDescriptorAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|trans
operator|)
operator|->
name|snapshot1
argument_list|,
name|OCI_DTYPE_SNAP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|(
operator|*
name|trans
operator|)
operator|->
name|snapshot1
argument_list|,
name|dbd_free_snapshot
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCI_INVALID_HANDLE
case|:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|OCIDescriptorAlloc
argument_list|(
name|dbd_oracle_env
argument_list|,
operator|(
name|dvoid
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|trans
operator|)
operator|->
name|snapshot2
argument_list|,
name|OCI_DTYPE_SNAP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|(
operator|*
name|trans
operator|)
operator|->
name|snapshot2
argument_list|,
name|dbd_free_snapshot
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCI_INVALID_HANDLE
case|:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_end_transaction
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
comment|/* no transaction is an error cond */
name|sword
name|status
decl_stmt|;
name|apr_dbd_t
modifier|*
name|handle
init|=
name|trans
operator|->
name|handle
decl_stmt|;
if|if
condition|(
name|trans
condition|)
block|{
switch|switch
condition|(
name|trans
operator|->
name|status
condition|)
block|{
case|case
name|TRANS_NONE
case|:
comment|/* No trans is an error here */
name|status
operator|=
name|OCI_ERROR
expr_stmt|;
break|break;
case|case
name|TRANS_ERROR
case|:
name|status
operator|=
name|OCITransRollback
argument_list|(
name|handle
operator|->
name|svc
argument_list|,
name|handle
operator|->
name|err
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* rollback on explicit rollback request */
if|if
condition|(
name|TXN_DO_ROLLBACK
argument_list|(
name|trans
argument_list|)
condition|)
block|{
name|status
operator|=
name|OCITransRollback
argument_list|(
name|handle
operator|->
name|svc
argument_list|,
name|handle
operator|->
name|err
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|OCITransCommit
argument_list|(
name|handle
operator|->
name|svc
argument_list|,
name|handle
operator|->
name|err
argument_list|,
name|OCI_DEFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|handle
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|3
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_transaction_mode_get
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
block|{
if|if
condition|(
operator|!
name|trans
condition|)
return|return
name|APR_DBD_TRANSACTION_COMMIT
return|;
return|return
name|trans
operator|->
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_transaction_mode_set
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|trans
condition|)
return|return
name|APR_DBD_TRANSACTION_COMMIT
return|;
return|return
name|trans
operator|->
name|mode
operator|=
operator|(
name|mode
operator|&
name|TXN_MODE_BITS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This doesn't work for BLOB because of NULLs, but it can fake it  * if the BLOB is really a string  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_oracle_get_entry
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|ub4
name|len
init|=
literal|0
decl_stmt|;
name|ub1
name|csform
init|=
literal|0
decl_stmt|;
name|ub2
name|csid
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|buflen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|define_arg
modifier|*
name|val
init|=
operator|&
name|row
operator|->
name|res
operator|->
name|statement
operator|->
name|out
index|[
name|n
index|]
decl_stmt|;
name|apr_dbd_t
modifier|*
name|sql
init|=
name|row
operator|->
name|res
operator|->
name|handle
decl_stmt|;
name|int_errorcode
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|>=
name|row
operator|->
name|res
operator|->
name|statement
operator|->
name|nout
operator|)
operator|||
operator|(
name|val
operator|->
name|ind
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|val
operator|->
name|type
condition|)
block|{
case|case
name|SQLT_BLOB
case|:
case|case
name|SQLT_CLOB
case|:
name|sql
operator|->
name|status
operator|=
name|OCILobGetLength
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|val
operator|->
name|buf
operator|.
name|lobval
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
literal|""
expr_stmt|;
block|}
break|break;
case|case
name|OCI_ERROR
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Finding LOB length: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|val
operator|->
name|type
operator|==
name|APR_DBD_TYPE_CLOB
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Is this necessary, or can it be defaulted? */
name|sql
operator|->
name|status
operator|=
name|OCILobCharSetForm
argument_list|(
name|dbd_oracle_env
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|val
operator|->
name|buf
operator|.
name|lobval
argument_list|,
operator|&
name|csform
argument_list|)
expr_stmt|;
if|if
condition|(
name|sql
operator|->
name|status
operator|==
name|OCI_SUCCESS
condition|)
block|{
name|sql
operator|->
name|status
operator|=
name|OCILobCharSetId
argument_list|(
name|dbd_oracle_env
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|val
operator|->
name|buf
operator|.
name|lobval
argument_list|,
operator|&
name|csid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
name|buflen
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* ugh, wasteful UCS-4 handling */
comment|/* zeroise all - where the string ends depends on charset */
name|buf
operator|=
name|apr_pcalloc
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|OCI_ERROR
case|:
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reading LOB character set: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
comment|/*** XXX?? ***/
endif|#
directive|endif
default|default:
break|break;
comment|/*** XXX?? ***/
block|}
else|#
directive|else
comment|/* ignore charset */
name|buflen
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* ugh, wasteful UCS-4 handling */
comment|/* zeroise all - where the string ends depends on charset */
name|buf
operator|=
name|apr_pcalloc
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* BUG: this'll only work if the BLOB looks like a string */
name|buflen
operator|=
name|len
expr_stmt|;
name|buf
operator|=
name|apr_palloc
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|buflen
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf
condition|)
block|{
break|break;
block|}
name|sql
operator|->
name|status
operator|=
name|OCILobRead
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|val
operator|->
name|buf
operator|.
name|lobval
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|,
operator|(
name|dvoid
operator|*
operator|)
name|buf
argument_list|,
name|buflen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|csid
argument_list|,
name|csform
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|OCI_ERROR
case|:
name|OCIErrorGet
argument_list|(
name|sql
operator|->
name|err
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|errorcode
argument_list|,
name|sql
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sql
operator|->
name|buf
argument_list|)
argument_list|,
name|OCI_HTYPE_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reading LOB: %s\n"
argument_list|,
name|sql
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/*** XXX?? ***/
break|break;
endif|#
directive|endif
default|default:
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/*** XXX?? ***/
break|break;
block|}
break|break;
case|case
name|SQLT_LNG
case|:
case|case
name|SQLT_LBI
case|:
comment|/* raw is struct { ub4 len; char *buf; } */
name|len
operator|=
operator|*
operator|(
name|ub4
operator|*
operator|)
name|val
operator|->
name|buf
operator|.
name|raw
expr_stmt|;
name|buf
operator|=
name|apr_pstrndup
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|val
operator|->
name|buf
operator|.
name|sval
operator|+
sizeof|sizeof
argument_list|(
name|ub4
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|buf
operator|=
name|apr_pstrndup
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|val
operator|->
name|buf
operator|.
name|sval
argument_list|,
name|val
operator|->
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
return|;
block|}
end_function

begin_comment
comment|/* XXX Should this use Oracle proper API instead of calling get_entry()? */
end_comment

begin_function
specifier|static
name|apr_status_t
name|dbd_oracle_datum_get
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|n
parameter_list|,
name|apr_dbd_type_e
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|define_arg
modifier|*
name|val
init|=
operator|&
name|row
operator|->
name|res
operator|->
name|statement
operator|->
name|out
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|n
operator|>=
name|row
operator|->
name|res
operator|->
name|statement
operator|->
name|nout
operator|)
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
if|if
condition|(
name|val
operator|->
name|ind
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|APR_DBD_TYPE_TINY
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|char
operator|*
operator|)
name|data
operator|=
name|atoi
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_UTINY
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|=
name|atoi
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_SHORT
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|short
operator|*
operator|)
name|data
operator|=
name|atoi
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_USHORT
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|data
operator|=
name|atoi
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_INT
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|atoi
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_UINT
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
name|atoi
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_LONG
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|atol
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_ULONG
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|data
operator|=
name|atol
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_LONGLONG
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|apr_int64_t
operator|*
operator|)
name|data
operator|=
name|apr_atoi64
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_ULONGLONG
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|apr_uint64_t
operator|*
operator|)
name|data
operator|=
name|apr_atoi64
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_FLOAT
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|float
operator|*
operator|)
name|data
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_DOUBLE
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|double
operator|*
operator|)
name|data
operator|=
name|atof
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_STRING
case|:
case|case
name|APR_DBD_TYPE_TEXT
case|:
case|case
name|APR_DBD_TYPE_TIME
case|:
case|case
name|APR_DBD_TYPE_DATE
case|:
case|case
name|APR_DBD_TYPE_DATETIME
case|:
case|case
name|APR_DBD_TYPE_TIMESTAMP
case|:
case|case
name|APR_DBD_TYPE_ZTIMESTAMP
case|:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|entry
expr_stmt|;
break|break;
case|case
name|APR_DBD_TYPE_BLOB
case|:
case|case
name|APR_DBD_TYPE_CLOB
case|:
block|{
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|b
init|=
operator|(
name|apr_bucket_brigade
operator|*
operator|)
name|data
decl_stmt|;
name|apr_dbd_t
modifier|*
name|sql
init|=
name|row
operator|->
name|res
operator|->
name|handle
decl_stmt|;
name|ub4
name|len
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|val
operator|->
name|type
condition|)
block|{
case|case
name|SQLT_BLOB
case|:
case|case
name|SQLT_CLOB
case|:
name|sql
operator|->
name|status
operator|=
name|OCILobGetLength
argument_list|(
name|sql
operator|->
name|svc
argument_list|,
name|sql
operator|->
name|err
argument_list|,
name|val
operator|->
name|buf
operator|.
name|lobval
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sql
operator|->
name|status
condition|)
block|{
case|case
name|OCI_SUCCESS
case|:
case|case
name|OCI_SUCCESS_WITH_INFO
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|e
operator|=
name|apr_bucket_eos_create
argument_list|(
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|apr_bucket_lob_create
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|row
operator|->
name|pool
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|APR_ENOENT
return|;
block|}
break|break;
default|default:
name|entry
operator|=
name|dbd_oracle_get_entry
argument_list|(
name|row
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOENT
return|;
block|}
name|e
operator|=
name|apr_bucket_pool_create
argument_list|(
name|entry
argument_list|,
name|strlen
argument_list|(
name|entry
argument_list|)
argument_list|,
name|row
operator|->
name|pool
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
break|break;
block|}
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APR_DBD_TYPE_NULL
case|:
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
name|APR_EGENERAL
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_oracle_close
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
comment|/* FIXME: none of the oracle docs/examples say anything about      * closing/releasing handles.  Which seems unlikely ...      */
comment|/* OK, let's grab from cdemo again.      * cdemo81 does nothing; cdemo82 does OCIHandleFree on the handles      */
switch|switch
condition|(
name|OCISessionEnd
argument_list|(
name|handle
operator|->
name|svc
argument_list|,
name|handle
operator|->
name|err
argument_list|,
name|handle
operator|->
name|auth
argument_list|,
operator|(
name|ub4
operator|)
name|OCI_DEFAULT
argument_list|)
condition|)
block|{
default|default:
break|break;
block|}
switch|switch
condition|(
name|OCIServerDetach
argument_list|(
name|handle
operator|->
name|svr
argument_list|,
name|handle
operator|->
name|err
argument_list|,
operator|(
name|ub4
operator|)
name|OCI_DEFAULT
argument_list|)
condition|)
block|{
default|default:
break|break;
block|}
comment|/* does OCISessionEnd imply this? */
switch|switch
condition|(
name|OCIHandleFree
argument_list|(
operator|(
name|dvoid
operator|*
operator|)
name|handle
operator|->
name|auth
argument_list|,
operator|(
name|ub4
operator|)
name|OCI_HTYPE_SESSION
argument_list|)
condition|)
block|{
default|default:
break|break;
block|}
switch|switch
condition|(
name|OCIHandleFree
argument_list|(
operator|(
name|dvoid
operator|*
operator|)
name|handle
operator|->
name|svr
argument_list|,
operator|(
name|ub4
operator|)
name|OCI_HTYPE_SERVER
argument_list|)
condition|)
block|{
default|default:
break|break;
block|}
switch|switch
condition|(
name|OCIHandleFree
argument_list|(
operator|(
name|dvoid
operator|*
operator|)
name|handle
operator|->
name|svc
argument_list|,
operator|(
name|ub4
operator|)
name|OCI_HTYPE_SVCCTX
argument_list|)
condition|)
block|{
default|default:
break|break;
block|}
switch|switch
condition|(
name|OCIHandleFree
argument_list|(
operator|(
name|dvoid
operator|*
operator|)
name|handle
operator|->
name|err
argument_list|,
operator|(
name|ub4
operator|)
name|OCI_HTYPE_ERROR
argument_list|)
condition|)
block|{
default|default:
break|break;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_oracle_check_conn
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|)
block|{
name|apr_dbd_results_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|apr_dbd_row_t
modifier|*
name|row
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dbd_oracle_pselect
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
operator|&
name|res
argument_list|,
name|sql
operator|->
name|check_conn_stmt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
if|if
condition|(
name|dbd_oracle_get_row
argument_list|(
name|pool
argument_list|,
name|res
argument_list|,
operator|&
name|row
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
if|if
condition|(
name|dbd_oracle_get_row
argument_list|(
name|pool
argument_list|,
name|res
argument_list|,
operator|&
name|row
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_select_db
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* FIXME: need to find this in the docs */
return|return
name|APR_ENOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dbd_oracle_native
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
comment|/* FIXME: can we do anything better?  Oracle doesn't seem to have      * a concept of a handle in the sense we use it.      */
return|return
name|dbd_oracle_env
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_num_cols
parameter_list|(
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|)
block|{
return|return
name|res
operator|->
name|statement
operator|->
name|nout
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_oracle_num_tuples
parameter_list|(
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
operator|!
name|res
operator|->
name|seek
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|res
operator|->
name|nrows
operator|>=
literal|0
condition|)
block|{
return|return
name|res
operator|->
name|nrows
return|;
block|}
name|res
operator|->
name|handle
operator|->
name|status
operator|=
name|OCIAttrGet
argument_list|(
name|res
operator|->
name|statement
operator|->
name|stmt
argument_list|,
name|OCI_HTYPE_STMT
argument_list|,
operator|&
name|res
operator|->
name|nrows
argument_list|,
literal|0
argument_list|,
name|OCI_ATTR_ROW_COUNT
argument_list|,
name|res
operator|->
name|handle
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|res
operator|->
name|nrows
return|;
block|}
end_function

begin_decl_stmt
name|APU_MODULE_DECLARE_DATA
specifier|const
name|apr_dbd_driver_t
name|apr_dbd_oracle_driver
init|=
block|{
literal|"oracle"
block|,
name|dbd_oracle_init
block|,
name|dbd_oracle_native
block|,
name|dbd_oracle_open
block|,
name|dbd_oracle_check_conn
block|,
name|dbd_oracle_close
block|,
name|dbd_oracle_select_db
block|,
name|dbd_oracle_start_transaction
block|,
name|dbd_oracle_end_transaction
block|,
name|dbd_oracle_query
block|,
name|dbd_oracle_select
block|,
name|dbd_oracle_num_cols
block|,
name|dbd_oracle_num_tuples
block|,
name|dbd_oracle_get_row
block|,
name|dbd_oracle_get_entry
block|,
name|dbd_oracle_error
block|,
name|dbd_oracle_escape
block|,
name|dbd_oracle_prepare
block|,
name|dbd_oracle_pvquery
block|,
name|dbd_oracle_pvselect
block|,
name|dbd_oracle_pquery
block|,
name|dbd_oracle_pselect
block|,
name|dbd_oracle_get_name
block|,
name|dbd_oracle_transaction_mode_get
block|,
name|dbd_oracle_transaction_mode_set
block|,
literal|":apr%d"
block|,
name|dbd_oracle_pvbquery
block|,
name|dbd_oracle_pvbselect
block|,
name|dbd_oracle_pbquery
block|,
name|dbd_oracle_pbselect
block|,
name|dbd_oracle_datum_get
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

