begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_include
include|#
directive|include
file|"apu_config.h"
end_include

begin_comment
comment|/* COMPILE_STUBS: compile stubs for unimplemented functions.  *  * This is required to compile in /trunk/, but can be  * undefined to compile a driver for httpd-2.2 and other  * APR-1.2 applications  */
end_comment

begin_define
define|#
directive|define
name|COMPILE_STUBS
end_define

begin_if
if|#
directive|if
name|APU_HAVE_FREETDS
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_dbd_internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FREETDS_SYBDB_H
end_ifdef

begin_include
include|#
directive|include
file|<freetds/sybdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYBDB_H
end_ifdef

begin_include
include|#
directive|include
file|<sybdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_comment
comment|/* This probably needs to change for different applications */
end_comment

begin_define
define|#
directive|define
name|MAX_COL_LEN
value|256
end_define

begin_typedef
typedef|typedef
struct|struct
name|freetds_cell_t
block|{
name|int
name|type
decl_stmt|;
name|DBINT
name|len
decl_stmt|;
name|BYTE
modifier|*
name|data
decl_stmt|;
block|}
name|freetds_cell_t
typedef|;
end_typedef

begin_struct
struct|struct
name|apr_dbd_transaction_t
block|{
name|int
name|mode
decl_stmt|;
name|int
name|errnum
decl_stmt|;
name|apr_dbd_t
modifier|*
name|handle
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_t
block|{
name|DBPROCESS
modifier|*
name|proc
decl_stmt|;
name|apr_dbd_transaction_t
modifier|*
name|trans
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|params
decl_stmt|;
name|RETCODE
name|err
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_results_t
block|{
name|int
name|random
decl_stmt|;
name|size_t
name|ntuples
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|DBPROCESS
modifier|*
name|proc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_row_t
block|{
name|apr_dbd_results_t
modifier|*
name|res
decl_stmt|;
name|BYTE
name|buf
index|[
name|MAX_COL_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_prepared_t
block|{
name|int
name|nargs
decl_stmt|;
name|regex_t
modifier|*
modifier|*
name|taint
decl_stmt|;
name|int
modifier|*
name|sz
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|dbd_freetds_is_success
parameter_list|(
name|x
parameter_list|)
value|(x == SUCCEED)
end_define

begin_decl_stmt
specifier|static
name|int
name|labelnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME */
end_comment

begin_decl_stmt
specifier|static
name|regex_t
name|dbd_freetds_find_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* execute a query that doesn't return a result set, mop up,  * and return and APR-flavoured status  */
end_comment

begin_function
specifier|static
name|RETCODE
name|freetds_exec
parameter_list|(
name|DBPROCESS
modifier|*
name|proc
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
name|int
name|want_results
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|)
block|{
comment|/* TBD */
name|RETCODE
name|rv
init|=
name|dbcmd
argument_list|(
name|proc
argument_list|,
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|!=
name|SUCCEED
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|dbsqlexec
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|SUCCEED
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|!
name|want_results
condition|)
block|{
while|while
condition|(
name|dbresults
argument_list|(
name|proc
argument_list|)
operator|!=
name|NO_MORE_RESULTS
condition|)
block|{
operator|++
operator|*
name|nrows
expr_stmt|;
block|}
block|}
return|return
name|SUCCEED
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|clear_result
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* clear cursor */
return|return
operator|(
name|dbcanquery
argument_list|(
operator|(
name|DBPROCESS
operator|*
operator|)
name|data
argument_list|)
operator|==
name|SUCCEED
operator|)
condition|?
name|APR_SUCCESS
else|:
name|APR_EGENERAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_select
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
name|int
name|seek
parameter_list|)
block|{
name|apr_dbd_results_t
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
operator|(
name|sql
operator|->
name|trans
operator|->
name|errnum
operator|!=
name|SUCCEED
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* the core of this is      * dbcmd(proc, query);      * dbsqlexec(proc);      * while (dbnextrow(dbproc) != NO_MORE_ROWS) {      *     do things      * }      *      * Ignore seek      */
name|sql
operator|->
name|err
operator|=
name|freetds_exec
argument_list|(
name|sql
operator|->
name|proc
argument_list|,
name|query
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbd_freetds_is_success
argument_list|(
name|sql
operator|->
name|err
argument_list|)
condition|)
block|{
if|if
condition|(
name|sql
operator|->
name|trans
condition|)
block|{
name|sql
operator|->
name|trans
operator|->
name|errnum
operator|=
name|sql
operator|->
name|err
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|sql
operator|->
name|err
operator|=
name|dbresults
argument_list|(
name|sql
operator|->
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sql
operator|->
name|err
operator|!=
name|SUCCEED
condition|)
block|{
if|if
condition|(
name|sql
operator|->
name|trans
condition|)
block|{
name|sql
operator|->
name|trans
operator|->
name|errnum
operator|=
name|sql
operator|->
name|err
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|results
condition|)
block|{
operator|*
name|results
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_results_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
operator|*
name|results
expr_stmt|;
name|res
operator|->
name|proc
operator|=
name|sql
operator|->
name|proc
expr_stmt|;
name|res
operator|->
name|random
operator|=
name|seek
expr_stmt|;
name|res
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|res
operator|->
name|ntuples
operator|=
name|dblastrow
argument_list|(
name|sql
operator|->
name|proc
argument_list|)
expr_stmt|;
name|res
operator|->
name|sz
operator|=
name|dbnumcols
argument_list|(
name|sql
operator|->
name|proc
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|sql
operator|->
name|proc
argument_list|,
name|clear_result
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now we have a result set.  We need to bind to its vars */
block|res->vars = apr_palloc(pool, res->sz * sizeof(freetds_cell_t*));     for (i=1; i<= res->sz; ++i) {         freetds_cell_t *cell =&res->vars[i-1];         cell->type = dbcoltype(sql->proc, i);         cell->len = dbcollen(sql->proc, i);         cell->data = apr_palloc(pool, cell->len);         sql->err = dbbind(sql->proc, i,
comment|/*cell->type */
block|STRINGBIND, cell->len, cell->data);         if (sql->err != SUCCEED) {             fprintf(stderr, "dbbind error: %d, %d, %d", i, cell->type, cell->len);         }         if ((sql->err != SUCCEED)&& (sql->trans != NULL)) {             sql->trans->errnum = sql->err;         }     }
endif|#
directive|endif
return|return
operator|(
name|sql
operator|->
name|err
operator|==
name|SUCCEED
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_untaint
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|regex_t
modifier|*
name|rx
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|regmatch_t
name|match
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|rx
operator|==
name|NULL
condition|)
block|{
comment|/* no untaint expression */
return|return
name|val
return|;
block|}
if|if
condition|(
name|regexec
argument_list|(
name|rx
argument_list|,
name|val
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|val
operator|+
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|-
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|)
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_statement
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|stmt
parameter_list|,
name|int
name|nargs
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|p_in
decl_stmt|;
name|char
modifier|*
name|p_out
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* compute upper bound on length (since untaint shrinks) */
name|len
operator|=
name|strlen
argument_list|(
name|stmt
operator|->
name|fmt
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|p_in
operator|=
name|stmt
operator|->
name|fmt
expr_stmt|;
name|p_out
operator|=
name|ret
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* FIXME silly bug - this'll catch %%s */
while|while
condition|(
name|q
operator|=
name|strstr
argument_list|(
name|p_in
argument_list|,
literal|"%s"
argument_list|)
operator|,
name|q
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|q
operator|-
name|p_in
expr_stmt|;
name|strncpy
argument_list|(
name|p_out
argument_list|,
name|p_in
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p_in
operator|+=
name|len
expr_stmt|;
name|p_out
operator|+=
name|len
expr_stmt|;
name|var
operator|=
name|dbd_untaint
argument_list|(
name|pool
argument_list|,
name|stmt
operator|->
name|taint
index|[
name|i
index|]
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p_out
argument_list|,
name|var
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p_in
operator|+=
literal|2
expr_stmt|;
name|p_out
operator|+=
name|len
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|p_out
argument_list|,
name|p_in
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|query
init|=
name|dbd_statement
argument_list|(
name|pool
argument_list|,
name|statement
argument_list|,
name|statement
operator|->
name|nargs
argument_list|,
name|values
argument_list|)
decl_stmt|;
return|return
name|dbd_freetds_select
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|results
argument_list|,
name|query
argument_list|,
name|seek
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pvselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|errnum
condition|)
block|{
return|return
name|sql
operator|->
name|trans
operator|->
name|errnum
return|;
block|}
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|dbd_freetds_pselect
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|results
argument_list|,
name|statement
argument_list|,
name|seek
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|dbd_freetds_query
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|dbd_freetds_pquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|query
init|=
name|dbd_statement
argument_list|(
name|pool
argument_list|,
name|statement
argument_list|,
name|statement
operator|->
name|nargs
argument_list|,
name|values
argument_list|)
decl_stmt|;
return|return
name|dbd_freetds_query
argument_list|(
name|sql
argument_list|,
name|nrows
argument_list|,
name|query
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pvquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|errnum
condition|)
block|{
return|return
name|sql
operator|->
name|trans
operator|->
name|errnum
return|;
block|}
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
name|dbd_freetds_pquery
argument_list|(
name|pool
argument_list|,
name|sql
argument_list|,
name|nrows
argument_list|,
name|statement
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_get_row
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|apr_dbd_row_t
modifier|*
modifier|*
name|rowp
parameter_list|,
name|int
name|rownum
parameter_list|)
block|{
name|RETCODE
name|rv
init|=
literal|0
decl_stmt|;
name|apr_dbd_row_t
modifier|*
name|row
init|=
operator|*
name|rowp
decl_stmt|;
name|int
name|sequential
init|=
operator|(
operator|(
name|rownum
operator|>=
literal|0
operator|)
operator|&&
name|res
operator|->
name|random
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|row
operator|==
name|NULL
condition|)
block|{
name|row
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_row_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rowp
operator|=
name|row
expr_stmt|;
name|row
operator|->
name|res
operator|=
name|res
expr_stmt|;
block|}
comment|/*     else {         if ( sequential ) {             ++row->n;         }         else {             row->n = rownum;         }     }     */
if|if
condition|(
name|sequential
condition|)
block|{
name|rv
operator|=
name|dbnextrow
argument_list|(
name|res
operator|->
name|proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
operator|(
name|rownum
operator|>=
literal|0
operator|)
condition|?
name|dbgetrow
argument_list|(
name|res
operator|->
name|proc
argument_list|,
name|rownum
argument_list|)
else|:
name|NO_MORE_ROWS
expr_stmt|;
block|}
switch|switch
condition|(
name|rv
condition|)
block|{
case|case
name|SUCCEED
case|:
return|return
literal|0
return|;
case|case
name|REG_ROW
case|:
return|return
literal|0
return|;
case|case
name|NO_MORE_ROWS
case|:
name|apr_pool_cleanup_run
argument_list|(
name|res
operator|->
name|pool
argument_list|,
name|res
operator|->
name|proc
argument_list|,
name|clear_result
argument_list|)
expr_stmt|;
operator|*
name|rowp
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|FAIL
case|:
return|return
literal|1
return|;
case|case
name|BUF_FULL
case|:
return|return
literal|2
return|;
comment|/* FIXME */
default|default:
return|return
literal|3
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_freetds_get_entry
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* FIXME: support different data types */
comment|/* this fails - bind gets some vars but not others     return (const char*)row->res->vars[n].data;      */
name|DBPROCESS
modifier|*
name|proc
init|=
name|row
operator|->
name|res
operator|->
name|proc
decl_stmt|;
name|BYTE
modifier|*
name|ptr
init|=
name|dbdata
argument_list|(
name|proc
argument_list|,
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|dbcoltype
argument_list|(
name|proc
argument_list|,
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|dbcollen
argument_list|(
name|proc
argument_list|,
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbwillconvert
argument_list|(
name|t
argument_list|,
name|SYBCHAR
argument_list|)
condition|)
block|{
name|dbconvert
argument_list|(
name|proc
argument_list|,
name|t
argument_list|,
name|ptr
argument_list|,
name|l
argument_list|,
name|SYBCHAR
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|row
operator|->
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|row
operator|->
name|buf
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_freetds_error
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* XXX this doesn't seem to exist in the API ??? */
return|return
name|apr_psprintf
argument_list|(
name|sql
operator|->
name|pool
argument_list|,
literal|"Error %d"
argument_list|,
name|sql
operator|->
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_query
parameter_list|(
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|)
block|{
if|if
condition|(
name|sql
operator|->
name|trans
operator|&&
name|sql
operator|->
name|trans
operator|->
name|errnum
condition|)
block|{
return|return
name|sql
operator|->
name|trans
operator|->
name|errnum
return|;
block|}
operator|*
name|nrows
operator|=
literal|0
expr_stmt|;
name|sql
operator|->
name|err
operator|=
name|freetds_exec
argument_list|(
name|sql
operator|->
name|proc
argument_list|,
name|query
argument_list|,
literal|0
argument_list|,
name|nrows
argument_list|)
expr_stmt|;
if|if
condition|(
name|sql
operator|->
name|err
operator|!=
name|SUCCEED
condition|)
block|{
if|if
condition|(
name|sql
operator|->
name|trans
condition|)
block|{
name|sql
operator|->
name|trans
operator|->
name|errnum
operator|=
name|sql
operator|->
name|err
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_freetds_escape
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|)
block|{
return|return
name|arg
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|freetds_regfree
parameter_list|(
name|void
modifier|*
name|rx
parameter_list|)
block|{
name|regfree
argument_list|(
operator|(
name|regex_t
operator|*
operator|)
name|rx
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recurse_args
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|stmt
parameter_list|,
name|int
name|offs
parameter_list|)
block|{
comment|/* we only support %s arguments for now */
name|int
name|ret
decl_stmt|;
name|char
name|arg
index|[
literal|256
index|]
decl_stmt|;
name|regmatch_t
name|matches
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|dbd_freetds_find_arg
argument_list|,
name|query
argument_list|,
literal|3
argument_list|,
name|matches
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* No more args */
name|stmt
operator|->
name|nargs
operator|=
name|n
expr_stmt|;
name|stmt
operator|->
name|taint
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|regex_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|sz
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|sz
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|matches
index|[
literal|1
index|]
operator|.
name|rm_eo
operator|-
name|matches
index|[
literal|1
index|]
operator|.
name|rm_so
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
block|{
return|return
literal|9999
return|;
block|}
name|ret
operator|=
name|recurse_args
argument_list|(
name|pool
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|query
operator|+
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|,
name|stmt
argument_list|,
name|offs
operator|+
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|stmt
operator|->
name|fmt
operator|+
name|offs
operator|+
name|matches
index|[
literal|1
index|]
operator|.
name|rm_so
argument_list|,
name|stmt
operator|->
name|fmt
operator|+
name|offs
operator|+
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|-
literal|1
argument_list|,
name|strlen
argument_list|(
name|stmt
operator|->
name|fmt
operator|+
name|offs
operator|+
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* compile untaint to a regex if found */
if|if
condition|(
name|matches
index|[
literal|1
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
condition|)
block|{
name|stmt
operator|->
name|taint
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|arg
argument_list|,
name|query
operator|+
name|matches
index|[
literal|1
index|]
operator|.
name|rm_so
operator|+
literal|1
argument_list|,
name|matches
index|[
literal|1
index|]
operator|.
name|rm_eo
operator|-
name|matches
index|[
literal|1
index|]
operator|.
name|rm_so
operator|-
literal|2
argument_list|)
expr_stmt|;
name|arg
index|[
name|matches
index|[
literal|1
index|]
operator|.
name|rm_eo
operator|-
name|matches
index|[
literal|1
index|]
operator|.
name|rm_so
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stmt
operator|->
name|taint
index|[
name|n
index|]
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
name|stmt
operator|->
name|taint
index|[
name|n
index|]
argument_list|,
name|arg
argument_list|,
name|REG_ICASE
operator||
name|REG_EXTENDED
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|ret
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|stmt
operator|->
name|taint
index|[
name|n
index|]
argument_list|,
name|freetds_regfree
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* record length if specified */
for|for
control|(
name|i
operator|=
name|matches
index|[
literal|2
index|]
operator|.
name|rm_so
init|;
name|i
operator|<
name|matches
index|[
literal|2
index|]
operator|.
name|rm_eo
condition|;
operator|++
name|i
control|)
block|{
name|sz
operator|=
literal|10
operator|*
name|sz
operator|+
operator|(
name|query
index|[
name|i
index|]
operator|-
literal|'\0'
operator|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_prepare
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|nvals
parameter_list|,
name|apr_dbd_type_e
modifier|*
name|types
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
modifier|*
name|statement
parameter_list|)
block|{
name|apr_dbd_prepared_t
modifier|*
name|stmt
decl_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
block|{
name|label
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%d"
argument_list|,
name|labelnum
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|statement
condition|)
block|{
operator|*
name|statement
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_prepared_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
operator|*
name|statement
expr_stmt|;
if|#
directive|if
literal|0
comment|/* count args */
block|stmt->fmt = apr_pstrdup(pool, query);     stmt->fmt = recurse_args(pool, 0, query, stmt, stmt->fmt);
comment|/* overestimate by a byte or two to simplify */
block|len = strlen("CREATE PROC apr.")             + strlen(label)             + stmt->nargs * strlen(" @arg1 varchar(len1),")             + strlen(" AS begin ")             + strlen(stmt->fmt)             + strlen(" end ");
comment|/* extra byte for terminator */
block|pquery = apr_pcalloc(pool, len);     sprintf(pquery, "CREATE PROC apr.%s", label);     for (i=0; i<stmt->nargs; ++i) {         sprintf(pquery+strlen(pquery), " @arg%d varchar(%d)", i, stmt->sz[i]);         if (i< stmt->nargs-1) {             pquery[strlen(pquery)] = ',';         }     }     strcat(pquery, " AS BEGIN ");     strcat(pquery, stmt->fmt);     strcat(pquery, " END");      return (freetds_exec(sql->proc, pquery, 0,&i) == SUCCEED) ? 0 : 1;
else|#
directive|else
name|stmt
operator|->
name|fmt
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|query
argument_list|)
expr_stmt|;
return|return
name|recurse_args
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
name|query
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_start_transaction
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_transaction_t
modifier|*
modifier|*
name|trans
parameter_list|)
block|{
name|int
name|dummy
decl_stmt|;
comment|/* XXX handle recursive transactions here */
name|handle
operator|->
name|err
operator|=
name|freetds_exec
argument_list|(
name|handle
operator|->
name|proc
argument_list|,
literal|"BEGIN TRANSACTION"
argument_list|,
literal|0
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbd_freetds_is_success
argument_list|(
name|handle
operator|->
name|err
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|trans
condition|)
block|{
operator|*
name|trans
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_transaction_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|trans
operator|)
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
name|handle
operator|->
name|trans
operator|=
operator|*
name|trans
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_end_transaction
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
block|{
name|int
name|dummy
decl_stmt|;
if|if
condition|(
name|trans
condition|)
block|{
comment|/* rollback on error or explicit rollback request */
if|if
condition|(
name|trans
operator|->
name|errnum
condition|)
block|{
name|trans
operator|->
name|errnum
operator|=
literal|0
expr_stmt|;
name|trans
operator|->
name|handle
operator|->
name|err
operator|=
name|freetds_exec
argument_list|(
name|trans
operator|->
name|handle
operator|->
name|proc
argument_list|,
literal|"ROLLBACK"
argument_list|,
literal|0
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trans
operator|->
name|handle
operator|->
name|err
operator|=
name|freetds_exec
argument_list|(
name|trans
operator|->
name|handle
operator|->
name|proc
argument_list|,
literal|"COMMIT"
argument_list|,
literal|0
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
name|trans
operator|->
name|handle
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|trans
operator|->
name|handle
operator|->
name|err
operator|==
name|SUCCEED
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|DBPROCESS
modifier|*
name|freetds_open
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|char
modifier|*
name|server
init|=
name|NULL
decl_stmt|;
name|DBPROCESS
modifier|*
name|process
decl_stmt|;
name|LOGINREC
modifier|*
name|login
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|delims
init|=
literal|" \r\n\t;|,"
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|vlen
decl_stmt|;
name|int
name|klen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|databaseName
init|=
name|NULL
decl_stmt|;
comment|/* FIXME - this uses malloc */
comment|/* FIXME - pass error message back to the caller in case of failure */
name|login
operator|=
name|dblogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|login
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* now set login properties */
for|for
control|(
name|ptr
operator|=
name|strchr
argument_list|(
name|params
argument_list|,
literal|'='
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'='
argument_list|)
control|)
block|{
comment|/* don't dereference memory that may not belong to us */
if|if
condition|(
name|ptr
operator|==
name|params
condition|)
block|{
operator|++
name|ptr
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|key
operator|=
name|ptr
operator|-
literal|1
init|;
name|apr_isspace
argument_list|(
operator|*
name|key
argument_list|)
condition|;
operator|--
name|key
control|)
empty_stmt|;
name|klen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|apr_isalpha
argument_list|(
operator|*
name|key
argument_list|)
condition|)
block|{
operator|--
name|key
expr_stmt|;
operator|++
name|klen
expr_stmt|;
block|}
operator|++
name|key
expr_stmt|;
for|for
control|(
name|value
operator|=
name|ptr
operator|+
literal|1
init|;
name|apr_isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|;
operator|++
name|value
control|)
empty_stmt|;
name|vlen
operator|=
name|strcspn
argument_list|(
name|value
argument_list|,
name|delims
argument_list|)
expr_stmt|;
name|buf
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
comment|/* NULL-terminated copy */
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"username"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|DBSETLUSER
argument_list|(
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"password"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|DBSETLPWD
argument_list|(
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"appname"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|DBSETLAPP
argument_list|(
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"dbname"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|databaseName
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"host"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|DBSETLHOST
argument_list|(
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"charset"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|DBSETLCHARSET
argument_list|(
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"lang"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|DBSETLNATLANG
argument_list|(
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|key
argument_list|,
literal|"server"
argument_list|,
name|klen
argument_list|)
condition|)
block|{
name|server
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* unknown param */
block|}
name|ptr
operator|=
name|value
operator|+
name|vlen
expr_stmt|;
block|}
name|process
operator|=
name|dbopen
argument_list|(
name|login
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|!=
name|NULL
operator|&&
name|databaseName
operator|!=
name|NULL
condition|)
block|{
name|dbuse
argument_list|(
name|process
argument_list|,
name|databaseName
argument_list|)
expr_stmt|;
block|}
name|dbloginfree
argument_list|(
name|login
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|process
return|;
block|}
end_function

begin_function
specifier|static
name|apr_dbd_t
modifier|*
name|dbd_freetds_open
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|apr_dbd_t
modifier|*
name|sql
decl_stmt|;
comment|/* FIXME - pass error message back to the caller in case of failure */
name|DBPROCESS
modifier|*
name|process
init|=
name|freetds_open
argument_list|(
name|pool
argument_list|,
name|params
argument_list|,
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|process
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|sql
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_t
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|sql
operator|->
name|proc
operator|=
name|process
expr_stmt|;
name|sql
operator|->
name|params
operator|=
name|params
expr_stmt|;
return|return
name|sql
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_freetds_close
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
name|dbclose
argument_list|(
name|handle
operator|->
name|proc
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_freetds_check_conn
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
if|if
condition|(
name|dbdead
argument_list|(
name|handle
operator|->
name|proc
argument_list|)
condition|)
block|{
comment|/* try again */
name|dbclose
argument_list|(
name|handle
operator|->
name|proc
argument_list|)
expr_stmt|;
name|handle
operator|->
name|proc
operator|=
name|freetds_open
argument_list|(
name|handle
operator|->
name|pool
argument_list|,
name|handle
operator|->
name|params
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|proc
operator|||
name|dbdead
argument_list|(
name|handle
operator|->
name|proc
argument_list|)
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
block|}
comment|/* clear it, in case this is called in error handling */
name|dbcancel
argument_list|(
name|handle
operator|->
name|proc
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_select_db
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* ouch, it's declared int.  But we can use APR 0/nonzero */
return|return
operator|(
name|dbuse
argument_list|(
name|handle
operator|->
name|proc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
operator|==
name|SUCCEED
operator|)
condition|?
name|APR_SUCCESS
else|:
name|APR_EGENERAL
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dbd_freetds_native
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
return|return
name|handle
operator|->
name|proc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_num_cols
parameter_list|(
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|)
block|{
return|return
name|res
operator|->
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_num_tuples
parameter_list|(
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|random
condition|)
block|{
return|return
name|res
operator|->
name|ntuples
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|freetds_term
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|dbexit
argument_list|()
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|dbd_freetds_find_arg
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|freetds_err_handler
parameter_list|(
name|DBPROCESS
modifier|*
name|dbproc
parameter_list|,
name|int
name|severity
parameter_list|,
name|int
name|dberr
parameter_list|,
name|int
name|oserr
parameter_list|,
name|char
modifier|*
name|dberrstr
parameter_list|,
name|char
modifier|*
name|oserrstr
parameter_list|)
block|{
return|return
name|INT_CANCEL
return|;
comment|/* never exit */
block|}
end_function

begin_function
specifier|static
name|void
name|dbd_freetds_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|rv
init|=
name|regcomp
argument_list|(
operator|&
name|dbd_freetds_find_arg
argument_list|,
literal|"%(\\{[^}]*\\})?([0-9]*)[A-Za-z]"
argument_list|,
name|REG_EXTENDED
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|char
name|errmsg
index|[
literal|256
index|]
decl_stmt|;
name|regerror
argument_list|(
name|rv
argument_list|,
operator|&
name|dbd_freetds_find_arg
argument_list|,
name|errmsg
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regcomp failed: %s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
name|dbinit
argument_list|()
expr_stmt|;
name|dberrhandle
argument_list|(
name|freetds_err_handler
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|freetds_term
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_STUBS
end_ifdef

begin_comment
comment|/* get_name is the only one of these that is implemented */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbd_freetds_get_name
parameter_list|(
specifier|const
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|dbcolname
argument_list|(
name|res
operator|->
name|proc
argument_list|,
name|n
operator|+
literal|1
argument_list|)
return|;
comment|/* numbering starts at 1 */
block|}
end_function

begin_comment
comment|/* These are stubs: transaction modes not implemented here */
end_comment

begin_define
define|#
directive|define
name|DBD_NOTIMPL
value|APR_ENOTIMPL;
end_define

begin_function
specifier|static
name|int
name|dbd_freetds_transaction_mode_get
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
block|{
return|return
name|trans
condition|?
name|trans
operator|->
name|mode
else|:
name|APR_DBD_TRANSACTION_COMMIT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_transaction_mode_set
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|trans
condition|)
block|{
name|trans
operator|->
name|mode
operator|=
name|mode
operator|&
name|TXN_MODE_BITS
expr_stmt|;
return|return
name|trans
operator|->
name|mode
return|;
block|}
return|return
name|APR_DBD_TRANSACTION_COMMIT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pvbquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
return|return
name|DBD_NOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pbquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|values
parameter_list|)
block|{
return|return
name|DBD_NOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pvbselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
return|return
name|DBD_NOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbd_freetds_pbselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|sql
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|results
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|seek
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|values
parameter_list|)
block|{
return|return
name|DBD_NOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|dbd_freetds_datum_get
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|n
parameter_list|,
name|apr_dbd_type_e
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|APR_ENOTIMPL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|APU_MODULE_DECLARE_DATA
specifier|const
name|apr_dbd_driver_t
name|apr_dbd_freetds_driver
init|=
block|{
literal|"freetds"
block|,
name|dbd_freetds_init
block|,
name|dbd_freetds_native
block|,
name|dbd_freetds_open
block|,
name|dbd_freetds_check_conn
block|,
name|dbd_freetds_close
block|,
name|dbd_freetds_select_db
block|,
name|dbd_freetds_start_transaction
block|,
name|dbd_freetds_end_transaction
block|,
name|dbd_freetds_query
block|,
name|dbd_freetds_select
block|,
name|dbd_freetds_num_cols
block|,
name|dbd_freetds_num_tuples
block|,
name|dbd_freetds_get_row
block|,
name|dbd_freetds_get_entry
block|,
name|dbd_freetds_error
block|,
name|dbd_freetds_escape
block|,
name|dbd_freetds_prepare
block|,
name|dbd_freetds_pvquery
block|,
name|dbd_freetds_pvselect
block|,
name|dbd_freetds_pquery
block|,
name|dbd_freetds_pselect
block|,
comment|/* this is only implemented to support httpd/2.2 standard usage,      * as in the original DBD implementation.  Everything else is NOTIMPL.      */
ifdef|#
directive|ifdef
name|COMPILE_STUBS
name|dbd_freetds_get_name
block|,
name|dbd_freetds_transaction_mode_get
block|,
name|dbd_freetds_transaction_mode_set
block|,
literal|""
block|,
name|dbd_freetds_pvbquery
block|,
name|dbd_freetds_pvbselect
block|,
name|dbd_freetds_pbquery
block|,
name|dbd_freetds_pbselect
block|,
name|dbd_freetds_datum_get
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

