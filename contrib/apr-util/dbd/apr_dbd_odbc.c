begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_if
if|#
directive|if
name|APU_HAVE_ODBC
end_if

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_buckets.h"
end_include

begin_include
include|#
directive|include
file|"apr_env.h"
end_include

begin_include
include|#
directive|include
file|"apr_file_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_file_info.h"
end_include

begin_include
include|#
directive|include
file|"apr_dbd_internal.h"
end_include

begin_include
include|#
directive|include
file|"apr_thread_proc.h"
end_include

begin_include
include|#
directive|include
file|"apu_version.h"
end_include

begin_include
include|#
directive|include
file|"apu_config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* If library is ODBC-V2, use macros for limited ODBC-V2 support   * No random access in V2.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ODBCV2
end_ifdef

begin_define
define|#
directive|define
name|ODBCVER
value|0x0200
end_define

begin_include
include|#
directive|include
file|"apr_dbd_odbc_v2.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* standard ODBC include files */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SQL_H
end_ifdef

begin_include
include|#
directive|include
file|<sql.h>
end_include

begin_include
include|#
directive|include
file|<sqlext.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_ODBC_SQL_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<odbc/sql.h>
end_include

begin_include
include|#
directive|include
file|<odbc/sqlext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* * MSVC6 does not support intptr_t (C99) * APR does not have a signed inptr type until 2.0  (r1557720) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|<
literal|1400
end_if

begin_if
if|#
directive|if
name|APR_SIZEOF_VOIDP
operator|==
literal|8
end_if

begin_define
define|#
directive|define
name|ODBC_INTPTR_T
value|apr_int64_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ODBC_INTPTR_T
value|apr_int32_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ODBC_INTPTR_T
value|intptr_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Driver name is "odbc" and the entry point is 'apr_dbd_odbc_driver'   * unless ODBC_DRIVER_NAME is defined and it is linked with another db library which  * is ODBC source-compatible. e.g. DB2, Informix, TimesTen, mysql.    */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ODBC_DRIVER_NAME
end_ifndef

begin_define
define|#
directive|define
name|ODBC_DRIVER_NAME
value|odbc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|x
parameter_list|)
value|#x
end_define

begin_define
define|#
directive|define
name|NAMIFY2
parameter_list|(
name|n
parameter_list|)
value|apr_dbd_##n##_driver
end_define

begin_define
define|#
directive|define
name|NAMIFY1
parameter_list|(
name|n
parameter_list|)
value|NAMIFY2(n)
end_define

begin_define
define|#
directive|define
name|ODBC_DRIVER_STRING
value|STRINGIFY(ODBC_DRIVER_NAME)
end_define

begin_define
define|#
directive|define
name|ODBC_DRIVER_ENTRY
value|NAMIFY1(ODBC_DRIVER_NAME)
end_define

begin_comment
comment|/* Required APR version for this driver */
end_comment

begin_define
define|#
directive|define
name|DRIVER_APU_VERSION_MAJOR
value|APU_MAJOR_VERSION
end_define

begin_define
define|#
directive|define
name|DRIVER_APU_VERSION_MINOR
value|APU_MINOR_VERSION
end_define

begin_decl_stmt
specifier|static
name|SQLHANDLE
name|henv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ODBC ENV handle is process-wide */
end_comment

begin_comment
comment|/* Use a CHECK_ERROR macro so we can grab the source line numbers  * for error reports  */
end_comment

begin_function_decl
specifier|static
name|void
name|check_error
parameter_list|(
name|apr_dbd_t
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|step
parameter_list|,
name|SQLRETURN
name|rc
parameter_list|,
name|SQLSMALLINT
name|type
parameter_list|,
name|SQLHANDLE
name|h
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CHECK_ERROR
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|,
name|h
parameter_list|)
value|check_error(a,s,r,t,h, __LINE__)
end_define

begin_define
define|#
directive|define
name|SOURCE_FILE
value|__FILE__
end_define

begin_comment
comment|/* source file for error messages */
end_comment

begin_define
define|#
directive|define
name|MAX_ERROR_STRING
value|1024
end_define

begin_comment
comment|/* max length of message in dbc */
end_comment

begin_define
define|#
directive|define
name|MAX_COLUMN_NAME
value|256
end_define

begin_comment
comment|/* longest column name recognized */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_BUFFER_SIZE
value|1024
end_define

begin_comment
comment|/* value for defaultBufferSize */
end_comment

begin_define
define|#
directive|define
name|MAX_PARAMS
value|20
end_define

begin_define
define|#
directive|define
name|DEFAULTSEPS
value|" \t\r\n,="
end_define

begin_define
define|#
directive|define
name|CSINGLEQUOTE
value|'\''
end_define

begin_define
define|#
directive|define
name|SSINGLEQUOTE
value|"\'"
end_define

begin_define
define|#
directive|define
name|TEXTMODE
value|1
end_define

begin_comment
comment|/* used for text (APR 1.2) mode params */
end_comment

begin_define
define|#
directive|define
name|BINARYMODE
value|0
end_define

begin_comment
comment|/* used for binary (APR 1.3+) mode params */
end_comment

begin_comment
comment|/* Identify datatypes which are LOBs   * - DB2 DRDA driver uses undefined types -98 and -99 for CLOB& BLOB  */
end_comment

begin_define
define|#
directive|define
name|IS_LOB
parameter_list|(
name|t
parameter_list|)
value|(t == SQL_LONGVARCHAR \      || t == SQL_LONGVARBINARY || t == SQL_VARBINARY \      || t == -98 || t == -99)
end_define

begin_comment
comment|/* These types are CLOBs   * - DB2 DRDA driver uses undefined type -98 for CLOB  */
end_comment

begin_define
define|#
directive|define
name|IS_CLOB
parameter_list|(
name|t
parameter_list|)
define|\
value|(t == SQL_LONGVARCHAR || t == -98)
end_define

begin_comment
comment|/* Convert a SQL result to an APR result */
end_comment

begin_define
define|#
directive|define
name|APR_FROM_SQL_RESULT
parameter_list|(
name|rc
parameter_list|)
define|\
value|(SQL_SUCCEEDED(rc) ? APR_SUCCESS : APR_EGENERAL)
end_define

begin_comment
comment|/* DBD opaque structures */
end_comment

begin_struct
struct|struct
name|apr_dbd_t
block|{
name|SQLHANDLE
name|dbc
decl_stmt|;
comment|/* SQL connection handle - NULL after close */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* connection lifetime pool */
name|char
modifier|*
name|dbname
decl_stmt|;
comment|/* ODBC datasource */
name|int
name|lasterrorcode
decl_stmt|;
name|int
name|lineNumber
decl_stmt|;
name|char
name|lastError
index|[
name|MAX_ERROR_STRING
index|]
decl_stmt|;
name|int
name|defaultBufferSize
decl_stmt|;
comment|/* used for CLOBs in text mode,                                   * and when fld size is indeterminate */
name|ODBC_INTPTR_T
name|transaction_mode
decl_stmt|;
name|ODBC_INTPTR_T
name|dboptions
decl_stmt|;
comment|/* driver options re SQLGetData */
name|ODBC_INTPTR_T
name|default_transaction_mode
decl_stmt|;
name|int
name|can_commit
decl_stmt|;
comment|/* controls end_trans behavior */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_results_t
block|{
name|SQLHANDLE
name|stmt
decl_stmt|;
comment|/* parent sql statement handle */
name|SQLHANDLE
name|dbc
decl_stmt|;
comment|/* parent sql connection handle */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* pool from query or select */
name|apr_dbd_t
modifier|*
name|apr_dbd
decl_stmt|;
comment|/* parent DBD connection handle */
name|int
name|random
decl_stmt|;
comment|/* random access requested */
name|int
name|ncols
decl_stmt|;
comment|/* number of columns */
name|int
name|isclosed
decl_stmt|;
comment|/* cursor has been closed */
name|char
modifier|*
modifier|*
name|colnames
decl_stmt|;
comment|/* array of column names (NULL until used) */
name|SQLPOINTER
modifier|*
name|colptrs
decl_stmt|;
comment|/* pointers to column data */
name|SQLINTEGER
modifier|*
name|colsizes
decl_stmt|;
comment|/* sizes for columns (enough for txt or bin) */
name|SQLINTEGER
modifier|*
name|coltextsizes
decl_stmt|;
comment|/* max-sizes if converted to text */
name|SQLSMALLINT
modifier|*
name|coltypes
decl_stmt|;
comment|/* array of SQL data types for columns */
name|SQLLEN
modifier|*
name|colinds
decl_stmt|;
comment|/* array of SQL data indicator/strlens */
name|int
modifier|*
name|colstate
decl_stmt|;
comment|/* array of column states                                  * - avail, bound, present, unavail                                   */
name|int
modifier|*
name|all_data_fetched
decl_stmt|;
comment|/* flags data as all fetched, for LOBs  */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* buffer for all data for one row */
block|}
struct|;
end_struct

begin_enum
enum|enum
comment|/* results column states */
block|{
name|COL_AVAIL
block|,
comment|/* data may be retrieved with SQLGetData */
name|COL_PRESENT
block|,
comment|/* data has been retrieved with SQLGetData */
name|COL_BOUND
block|,
comment|/* column is bound to colptr */
name|COL_RETRIEVED
block|,
comment|/* all data from column has been returned */
name|COL_UNAVAIL
comment|/* column is unavailable because ODBC driver                                  *  requires that columns be retrieved                                  *  in ascending order and a higher col                                   *  was accessed                                  */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|apr_dbd_row_t
block|{
name|SQLHANDLE
name|stmt
decl_stmt|;
comment|/* parent ODBC statement handle */
name|SQLHANDLE
name|dbc
decl_stmt|;
comment|/* parent ODBC connection handle */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* pool from get_row */
name|apr_dbd_results_t
modifier|*
name|res
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_transaction_t
block|{
name|SQLHANDLE
name|dbc
decl_stmt|;
comment|/* parent ODBC connection handle */
name|apr_dbd_t
modifier|*
name|apr_dbd
decl_stmt|;
comment|/* parent DBD connection handle */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_dbd_prepared_t
block|{
name|SQLHANDLE
name|stmt
decl_stmt|;
comment|/* ODBC statement handle */
name|SQLHANDLE
name|dbc
decl_stmt|;
comment|/* parent ODBC connection handle */
name|apr_dbd_t
modifier|*
name|apr_dbd
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|nvals
decl_stmt|;
name|int
modifier|*
name|types
decl_stmt|;
comment|/* array of DBD data types */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|odbc_lob_bucket_destroy
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|odbc_lob_bucket_setaside
parameter_list|(
name|apr_bucket
modifier|*
name|e
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|apr_status_t
name|odbc_lob_bucket_read
parameter_list|(
name|apr_bucket
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_read_type_e
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* the ODBC LOB bucket type */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_bucket_type_t
name|odbc_bucket_type
init|=
block|{
literal|"ODBC_LOB"
block|,
literal|5
block|,
name|APR_BUCKET_DATA
block|,
name|odbc_lob_bucket_destroy
block|,
name|odbc_lob_bucket_read
block|,
name|odbc_lob_bucket_setaside
block|,
name|apr_bucket_shared_split
block|,
name|apr_bucket_shared_copy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ODBC LOB bucket data */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/** Ref count for shared bucket */
name|apr_bucket_refcount
name|refcount
decl_stmt|;
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
decl_stmt|;
name|int
name|col
decl_stmt|;
name|SQLSMALLINT
name|type
decl_stmt|;
block|}
name|odbc_bucket
typedef|;
end_typedef

begin_comment
comment|/* SQL datatype mappings to DBD datatypes   * These tables must correspond *exactly* to the apr_dbd_type_e enum   * in apr_dbd.h  */
end_comment

begin_comment
comment|/* ODBC "C" types to DBD datatypes  */
end_comment

begin_decl_stmt
specifier|static
name|SQLSMALLINT
specifier|const
name|sqlCtype
index|[]
init|=
block|{
name|SQL_C_DEFAULT
block|,
comment|/* APR_DBD_TYPE_NONE              */
name|SQL_C_STINYINT
block|,
comment|/* APR_DBD_TYPE_TINY,       \%hhd */
name|SQL_C_UTINYINT
block|,
comment|/* APR_DBD_TYPE_UTINY,      \%hhu */
name|SQL_C_SSHORT
block|,
comment|/* APR_DBD_TYPE_SHORT,      \%hd  */
name|SQL_C_USHORT
block|,
comment|/* APR_DBD_TYPE_USHORT,     \%hu  */
name|SQL_C_SLONG
block|,
comment|/* APR_DBD_TYPE_INT,        \%d   */
name|SQL_C_ULONG
block|,
comment|/* APR_DBD_TYPE_UINT,       \%u   */
name|SQL_C_SLONG
block|,
comment|/* APR_DBD_TYPE_LONG,       \%ld  */
name|SQL_C_ULONG
block|,
comment|/* APR_DBD_TYPE_ULONG,      \%lu  */
name|SQL_C_SBIGINT
block|,
comment|/* APR_DBD_TYPE_LONGLONG,   \%lld */
name|SQL_C_UBIGINT
block|,
comment|/* APR_DBD_TYPE_ULONGLONG,  \%llu */
name|SQL_C_FLOAT
block|,
comment|/* APR_DBD_TYPE_FLOAT,      \%f   */
name|SQL_C_DOUBLE
block|,
comment|/* APR_DBD_TYPE_DOUBLE,     \%lf  */
name|SQL_C_CHAR
block|,
comment|/* APR_DBD_TYPE_STRING,     \%s   */
name|SQL_C_CHAR
block|,
comment|/* APR_DBD_TYPE_TEXT,       \%pDt */
name|SQL_C_CHAR
block|,
comment|/*SQL_C_TYPE_TIME,      APR_DBD_TYPE_TIME,       \%pDi */
name|SQL_C_CHAR
block|,
comment|/*SQL_C_TYPE_DATE,      APR_DBD_TYPE_DATE,       \%pDd */
name|SQL_C_CHAR
block|,
comment|/*SQL_C_TYPE_TIMESTAMP, APR_DBD_TYPE_DATETIME,   \%pDa */
name|SQL_C_CHAR
block|,
comment|/*SQL_C_TYPE_TIMESTAMP, APR_DBD_TYPE_TIMESTAMP,  \%pDs */
name|SQL_C_CHAR
block|,
comment|/*SQL_C_TYPE_TIMESTAMP, APR_DBD_TYPE_ZTIMESTAMP, \%pDz */
name|SQL_LONGVARBINARY
block|,
comment|/* APR_DBD_TYPE_BLOB,       \%pDb */
name|SQL_LONGVARCHAR
block|,
comment|/* APR_DBD_TYPE_CLOB,       \%pDc */
name|SQL_TYPE_NULL
comment|/* APR_DBD_TYPE_NULL        \%pDn */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_APR_DBD_TYPES
value|(sizeof(sqlCtype) / sizeof(sqlCtype[0]))
end_define

begin_comment
comment|/*  ODBC Base types to DBD datatypes */
end_comment

begin_decl_stmt
specifier|static
name|SQLSMALLINT
specifier|const
name|sqlBaseType
index|[]
init|=
block|{
name|SQL_C_DEFAULT
block|,
comment|/* APR_DBD_TYPE_NONE              */
name|SQL_TINYINT
block|,
comment|/* APR_DBD_TYPE_TINY,       \%hhd */
name|SQL_TINYINT
block|,
comment|/* APR_DBD_TYPE_UTINY,      \%hhu */
name|SQL_SMALLINT
block|,
comment|/* APR_DBD_TYPE_SHORT,      \%hd  */
name|SQL_SMALLINT
block|,
comment|/* APR_DBD_TYPE_USHORT,     \%hu  */
name|SQL_INTEGER
block|,
comment|/* APR_DBD_TYPE_INT,        \%d   */
name|SQL_INTEGER
block|,
comment|/* APR_DBD_TYPE_UINT,       \%u   */
name|SQL_INTEGER
block|,
comment|/* APR_DBD_TYPE_LONG,       \%ld  */
name|SQL_INTEGER
block|,
comment|/* APR_DBD_TYPE_ULONG,      \%lu  */
name|SQL_BIGINT
block|,
comment|/* APR_DBD_TYPE_LONGLONG,   \%lld */
name|SQL_BIGINT
block|,
comment|/* APR_DBD_TYPE_ULONGLONG,  \%llu */
name|SQL_FLOAT
block|,
comment|/* APR_DBD_TYPE_FLOAT,      \%f   */
name|SQL_DOUBLE
block|,
comment|/* APR_DBD_TYPE_DOUBLE,     \%lf  */
name|SQL_CHAR
block|,
comment|/* APR_DBD_TYPE_STRING,     \%s   */
name|SQL_CHAR
block|,
comment|/* APR_DBD_TYPE_TEXT,       \%pDt */
name|SQL_CHAR
block|,
comment|/*SQL_TIME,          APR_DBD_TYPE_TIME,       \%pDi */
name|SQL_CHAR
block|,
comment|/*SQL_DATE,          APR_DBD_TYPE_DATE,       \%pDd */
name|SQL_CHAR
block|,
comment|/*SQL_TIMESTAMP,     APR_DBD_TYPE_DATETIME,   \%pDa */
name|SQL_CHAR
block|,
comment|/*SQL_TIMESTAMP,     APR_DBD_TYPE_TIMESTAMP,  \%pDs */
name|SQL_CHAR
block|,
comment|/*SQL_TIMESTAMP,     APR_DBD_TYPE_ZTIMESTAMP, \%pDz */
name|SQL_LONGVARBINARY
block|,
comment|/* APR_DBD_TYPE_BLOB,       \%pDb */
name|SQL_LONGVARCHAR
block|,
comment|/* APR_DBD_TYPE_CLOB,       \%pDc */
name|SQL_TYPE_NULL
comment|/* APR_DBD_TYPE_NULL        \%pDn */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  result sizes for DBD datatypes (-1 for null-terminated) */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|sqlSizes
index|[]
init|=
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
block|,
comment|/**< \%hhd out: char* */
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
block|,
comment|/**< \%hhu out: unsigned char* */
sizeof|sizeof
argument_list|(
name|short
argument_list|)
block|,
comment|/**< \%hd  out: short* */
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
block|,
comment|/**< \%hu  out: unsigned short* */
sizeof|sizeof
argument_list|(
name|int
argument_list|)
block|,
comment|/**< \%d   out: int* */
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
block|,
comment|/**< \%u   out: unsigned int* */
sizeof|sizeof
argument_list|(
name|long
argument_list|)
block|,
comment|/**< \%ld  out: long* */
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
block|,
comment|/**< \%lu  out: unsigned long* */
sizeof|sizeof
argument_list|(
name|apr_int64_t
argument_list|)
block|,
comment|/**< \%lld out: apr_int64_t* */
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
block|,
comment|/**< \%llu out: apr_uint64_t* */
sizeof|sizeof
argument_list|(
name|float
argument_list|)
block|,
comment|/**< \%f   out: float* */
sizeof|sizeof
argument_list|(
name|double
argument_list|)
block|,
comment|/**< \%lf  out: double* */
operator|-
literal|1
block|,
comment|/**< \%s   out: char** */
operator|-
literal|1
block|,
comment|/**< \%pDt out: char** */
operator|-
literal|1
block|,
comment|/**< \%pDi out: char** */
operator|-
literal|1
block|,
comment|/**< \%pDd out: char** */
operator|-
literal|1
block|,
comment|/**< \%pDa out: char** */
operator|-
literal|1
block|,
comment|/**< \%pDs out: char** */
operator|-
literal|1
block|,
comment|/**< \%pDz out: char** */
sizeof|sizeof
argument_list|(
name|apr_bucket_brigade
argument_list|)
block|,
comment|/**< \%pDb out: apr_bucket_brigade* */
sizeof|sizeof
argument_list|(
name|apr_bucket_brigade
argument_list|)
block|,
comment|/**< \%pDc out: apr_bucket_brigade* */
literal|0
comment|/**< \%pDn : in: void*, out: void** */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * local functions  */
end_comment

begin_comment
comment|/* close any open results for the connection */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_close_results
parameter_list|(
name|void
modifier|*
name|d
parameter_list|)
block|{
name|apr_dbd_results_t
modifier|*
name|dbr
init|=
operator|(
name|apr_dbd_results_t
operator|*
operator|)
name|d
decl_stmt|;
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
if|if
condition|(
name|dbr
operator|&&
name|dbr
operator|->
name|apr_dbd
operator|&&
name|dbr
operator|->
name|apr_dbd
operator|->
name|dbc
condition|)
block|{
if|if
condition|(
operator|!
name|dbr
operator|->
name|isclosed
condition|)
name|rc
operator|=
name|SQLCloseCursor
argument_list|(
name|dbr
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|dbr
operator|->
name|isclosed
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* close the ODBC statement handle from a  prepare */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_close_pstmt
parameter_list|(
name|void
modifier|*
name|s
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|statement
init|=
name|s
decl_stmt|;
comment|/* stmt is closed if connection has already been closed */
if|if
condition|(
name|statement
condition|)
block|{
name|SQLHANDLE
name|hstmt
init|=
name|statement
operator|->
name|stmt
decl_stmt|;
if|if
condition|(
name|hstmt
operator|&&
name|statement
operator|->
name|apr_dbd
operator|&&
name|statement
operator|->
name|apr_dbd
operator|->
name|dbc
condition|)
block|{
name|rc
operator|=
name|SQLFreeHandle
argument_list|(
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
block|}
name|statement
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* close: close/release a connection obtained from open() */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_close
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
if|if
condition|(
name|handle
operator|->
name|dbc
condition|)
block|{
name|rc
operator|=
name|SQLDisconnect
argument_list|(
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLDisconnect"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLFreeHandle
argument_list|(
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLFreeHandle (DBC)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_ENV
argument_list|,
name|henv
argument_list|)
expr_stmt|;
name|handle
operator|->
name|dbc
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* odbc_close re-defined for passing to pool cleanup */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_close_cleanup
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
return|return
name|odbc_close
argument_list|(
operator|(
name|apr_dbd_t
operator|*
operator|)
name|handle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* close the ODBC environment handle at process termination */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_close_env
parameter_list|(
name|SQLHANDLE
name|henv
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|rc
operator|=
name|SQLFreeHandle
argument_list|(
name|SQL_HANDLE_ENV
argument_list|,
name|henv
argument_list|)
expr_stmt|;
name|henv
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* setup the arrays in results for all the returned columns */
end_comment

begin_function
specifier|static
name|SQLRETURN
name|odbc_set_result_column
parameter_list|(
name|int
name|icol
parameter_list|,
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|SQLHANDLE
name|stmt
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|ODBC_INTPTR_T
name|maxsize
decl_stmt|,
name|textsize
decl_stmt|,
name|realsize
decl_stmt|,
name|type
decl_stmt|,
name|isunsigned
init|=
literal|1
decl_stmt|;
comment|/* discover the sql type */
name|rc
operator|=
name|SQLColAttribute
argument_list|(
name|stmt
argument_list|,
name|icol
operator|+
literal|1
argument_list|,
name|SQL_DESC_UNSIGNED
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|SQLPOINTER
operator|)
operator|&
name|isunsigned
argument_list|)
expr_stmt|;
name|isunsigned
operator|=
operator|(
name|isunsigned
operator|==
name|SQL_TRUE
operator|)
expr_stmt|;
name|rc
operator|=
name|SQLColAttribute
argument_list|(
name|stmt
argument_list|,
name|icol
operator|+
literal|1
argument_list|,
name|SQL_DESC_TYPE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|SQLPOINTER
operator|)
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
operator|||
name|type
operator|==
name|SQL_UNKNOWN_TYPE
condition|)
block|{
comment|/* MANY ODBC v2 datasources only supply CONCISE_TYPE */
name|rc
operator|=
name|SQLColAttribute
argument_list|(
name|stmt
argument_list|,
name|icol
operator|+
literal|1
argument_list|,
name|SQL_DESC_CONCISE_TYPE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|SQLPOINTER
operator|)
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
comment|/* if still unknown make it CHAR */
name|type
operator|=
name|SQL_C_CHAR
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SQL_INTEGER
case|:
case|case
name|SQL_SMALLINT
case|:
case|case
name|SQL_TINYINT
case|:
case|case
name|SQL_BIGINT
case|:
comment|/* fix these numeric binary types up as signed/unsigned for C types */
name|type
operator|+=
operator|(
name|isunsigned
operator|)
condition|?
name|SQL_UNSIGNED_OFFSET
else|:
name|SQL_SIGNED_OFFSET
expr_stmt|;
break|break;
comment|/* LOB types are not changed to C types */
case|case
name|SQL_LONGVARCHAR
case|:
name|type
operator|=
name|SQL_LONGVARCHAR
expr_stmt|;
break|break;
case|case
name|SQL_LONGVARBINARY
case|:
name|type
operator|=
name|SQL_LONGVARBINARY
expr_stmt|;
break|break;
case|case
name|SQL_FLOAT
case|:
name|type
operator|=
name|SQL_C_FLOAT
expr_stmt|;
break|break;
case|case
name|SQL_DOUBLE
case|:
name|type
operator|=
name|SQL_C_DOUBLE
expr_stmt|;
break|break;
comment|/* DBD wants times as strings */
case|case
name|SQL_TIMESTAMP
case|:
case|case
name|SQL_DATE
case|:
case|case
name|SQL_TIME
case|:
default|default:
name|type
operator|=
name|SQL_C_CHAR
expr_stmt|;
block|}
name|res
operator|->
name|coltypes
index|[
name|icol
index|]
operator|=
operator|(
name|SQLSMALLINT
operator|)
name|type
expr_stmt|;
comment|/* size if retrieved as text */
name|rc
operator|=
name|SQLColAttribute
argument_list|(
name|stmt
argument_list|,
name|icol
operator|+
literal|1
argument_list|,
name|SQL_DESC_DISPLAY_SIZE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|SQLPOINTER
operator|)
operator|&
name|textsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
operator|||
name|textsize
operator|<
literal|0
condition|)
block|{
name|textsize
operator|=
name|res
operator|->
name|apr_dbd
operator|->
name|defaultBufferSize
expr_stmt|;
block|}
comment|/* for null-term, which sometimes isn't included */
name|textsize
operator|++
expr_stmt|;
comment|/* real size */
name|rc
operator|=
name|SQLColAttribute
argument_list|(
name|stmt
argument_list|,
name|icol
operator|+
literal|1
argument_list|,
name|SQL_DESC_OCTET_LENGTH
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|SQLPOINTER
operator|)
operator|&
name|realsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|realsize
operator|=
name|textsize
expr_stmt|;
block|}
name|maxsize
operator|=
operator|(
name|textsize
operator|>
name|realsize
operator|)
condition|?
name|textsize
else|:
name|realsize
expr_stmt|;
if|if
condition|(
name|IS_LOB
argument_list|(
name|type
argument_list|)
operator|||
name|maxsize
operator|<=
literal|0
condition|)
block|{
comment|/* LOB types are never bound and have a NULL colptr for binary.          * Ingore their real (1-2gb) length& use a default - the larger          * of defaultBufferSize or APR_BUCKET_BUFF_SIZE.          * If not a LOB, but simply unknown length - always use defaultBufferSize.          */
name|maxsize
operator|=
name|res
operator|->
name|apr_dbd
operator|->
name|defaultBufferSize
expr_stmt|;
if|if
condition|(
name|IS_LOB
argument_list|(
name|type
argument_list|)
operator|&&
name|maxsize
operator|<
name|APR_BUCKET_BUFF_SIZE
condition|)
block|{
name|maxsize
operator|=
name|APR_BUCKET_BUFF_SIZE
expr_stmt|;
block|}
name|res
operator|->
name|colptrs
index|[
name|icol
index|]
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|colstate
index|[
name|icol
index|]
operator|=
name|COL_AVAIL
expr_stmt|;
name|res
operator|->
name|colsizes
index|[
name|icol
index|]
operator|=
operator|(
name|SQLINTEGER
operator|)
name|maxsize
expr_stmt|;
name|rc
operator|=
name|SQL_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|res
operator|->
name|colptrs
index|[
name|icol
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|res
operator|->
name|pool
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|res
operator|->
name|colsizes
index|[
name|icol
index|]
operator|=
operator|(
name|SQLINTEGER
operator|)
name|maxsize
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|apr_dbd
operator|->
name|dboptions
operator|&
name|SQL_GD_BOUND
condition|)
block|{
comment|/* we are allowed to call SQLGetData if we need to */
name|rc
operator|=
name|SQLBindCol
argument_list|(
name|stmt
argument_list|,
name|icol
operator|+
literal|1
argument_list|,
name|res
operator|->
name|coltypes
index|[
name|icol
index|]
argument_list|,
name|res
operator|->
name|colptrs
index|[
name|icol
index|]
argument_list|,
name|maxsize
argument_list|,
operator|&
operator|(
name|res
operator|->
name|colinds
index|[
name|icol
index|]
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|res
operator|->
name|apr_dbd
argument_list|,
literal|"SQLBindCol"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|res
operator|->
name|colstate
index|[
name|icol
index|]
operator|=
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|?
name|COL_BOUND
else|:
name|COL_AVAIL
expr_stmt|;
block|}
else|else
block|{
comment|/* this driver won't allow us to call SQLGetData on bound               * columns - so don't bind any              */
name|res
operator|->
name|colstate
index|[
name|icol
index|]
operator|=
name|COL_AVAIL
expr_stmt|;
name|rc
operator|=
name|SQL_SUCCESS
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* create and populate an apr_dbd_results_t for a select */
end_comment

begin_function
specifier|static
name|SQLRETURN
name|odbc_create_results
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|SQLHANDLE
name|hstmt
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|int
name|random
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLSMALLINT
name|ncols
decl_stmt|;
operator|*
name|res
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_results_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|stmt
operator|=
name|hstmt
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|dbc
operator|=
name|handle
operator|->
name|dbc
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|random
operator|=
name|random
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|apr_dbd
operator|=
name|handle
expr_stmt|;
name|rc
operator|=
name|SQLNumResultCols
argument_list|(
name|hstmt
argument_list|,
operator|&
name|ncols
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLNumResultCols"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|ncols
operator|=
name|ncols
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|colnames
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|colptrs
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|colsizes
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|SQLINTEGER
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|coltypes
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|SQLSMALLINT
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|colinds
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|SQLLEN
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|colstate
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|ncols
operator|=
name|ncols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|odbc_set_result_column
argument_list|(
name|i
argument_list|,
operator|(
operator|*
name|res
operator|)
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* bind a parameter - input params only, does not support output parameters */
end_comment

begin_function
specifier|static
name|SQLRETURN
name|odbc_bind_param
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|int
name|narg
parameter_list|,
specifier|const
name|SQLSMALLINT
name|type
parameter_list|,
name|int
modifier|*
name|argp
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|args
parameter_list|,
specifier|const
name|int
name|textmode
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLSMALLINT
name|baseType
decl_stmt|,
name|cType
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|SQLULEN
name|len
decl_stmt|;
name|SQLLEN
modifier|*
name|indicator
decl_stmt|;
specifier|static
name|SQLLEN
name|nullValue
init|=
name|SQL_NULL_DATA
decl_stmt|;
specifier|static
name|SQLSMALLINT
name|inOut
init|=
name|SQL_PARAM_INPUT
decl_stmt|;
comment|/* only input params */
comment|/* bind a NULL data value */
if|if
condition|(
name|args
index|[
operator|*
name|argp
index|]
operator|==
name|NULL
operator|||
name|type
operator|==
name|APR_DBD_TYPE_NULL
condition|)
block|{
name|baseType
operator|=
name|SQL_CHAR
expr_stmt|;
name|cType
operator|=
name|SQL_C_CHAR
expr_stmt|;
name|ptr
operator|=
operator|&
name|nullValue
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|SQLINTEGER
argument_list|)
expr_stmt|;
name|indicator
operator|=
operator|&
name|nullValue
expr_stmt|;
operator|(
operator|*
name|argp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* bind a non-NULL data value */
else|else
block|{
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>=
name|NUM_APR_DBD_TYPES
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
block|}
name|baseType
operator|=
name|sqlBaseType
index|[
name|type
index|]
expr_stmt|;
name|cType
operator|=
name|sqlCtype
index|[
name|type
index|]
expr_stmt|;
name|indicator
operator|=
name|NULL
expr_stmt|;
comment|/* LOBs */
if|if
condition|(
name|IS_LOB
argument_list|(
name|cType
argument_list|)
condition|)
block|{
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
expr_stmt|;
name|len
operator|=
operator|(
name|SQLULEN
operator|)
operator|*
operator|(
name|apr_size_t
operator|*
operator|)
name|args
index|[
operator|*
name|argp
operator|+
literal|1
index|]
expr_stmt|;
name|cType
operator|=
operator|(
name|IS_CLOB
argument_list|(
name|cType
argument_list|)
operator|)
condition|?
name|SQL_C_CHAR
else|:
name|SQL_C_DEFAULT
expr_stmt|;
operator|(
operator|*
name|argp
operator|)
operator|+=
literal|4
expr_stmt|;
comment|/* LOBs consume 4 args (last two are unused) */
block|}
comment|/* non-LOBs */
else|else
block|{
switch|switch
condition|(
name|baseType
condition|)
block|{
case|case
name|SQL_CHAR
case|:
case|case
name|SQL_DATE
case|:
case|case
name|SQL_TIME
case|:
case|case
name|SQL_TIMESTAMP
case|:
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
expr_stmt|;
name|len
operator|=
operator|(
name|SQLULEN
operator|)
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQL_TINYINT
case|:
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptr
operator|=
operator|(
name|textmode
condition|?
name|atoi
argument_list|(
name|args
index|[
operator|*
name|argp
index|]
argument_list|)
else|:
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|SQL_SMALLINT
case|:
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|ptr
operator|=
operator|(
name|textmode
condition|?
name|atoi
argument_list|(
name|args
index|[
operator|*
name|argp
index|]
argument_list|)
else|:
operator|*
operator|(
name|short
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|SQL_INTEGER
case|:
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|ptr
operator|=
operator|(
name|textmode
condition|?
name|atol
argument_list|(
name|args
index|[
operator|*
name|argp
index|]
argument_list|)
else|:
operator|*
operator|(
name|long
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|SQL_FLOAT
case|:
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
operator|*
operator|(
name|float
operator|*
operator|)
name|ptr
operator|=
operator|(
name|textmode
condition|?
operator|(
name|float
operator|)
name|atof
argument_list|(
name|args
index|[
operator|*
name|argp
index|]
argument_list|)
else|:
operator|*
operator|(
name|float
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|SQL_DOUBLE
case|:
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
operator|=
operator|(
name|textmode
condition|?
name|atof
argument_list|(
name|args
index|[
operator|*
name|argp
index|]
argument_list|)
else|:
operator|*
operator|(
name|double
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|SQL_BIGINT
case|:
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|apr_int64_t
argument_list|)
expr_stmt|;
operator|*
operator|(
name|apr_int64_t
operator|*
operator|)
name|ptr
operator|=
operator|(
name|textmode
condition|?
name|apr_atoi64
argument_list|(
name|args
index|[
operator|*
name|argp
index|]
argument_list|)
else|:
operator|*
operator|(
name|apr_int64_t
operator|*
operator|)
name|args
index|[
operator|*
name|argp
index|]
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|APR_EGENERAL
return|;
block|}
operator|(
operator|*
name|argp
operator|)
operator|++
expr_stmt|;
comment|/* non LOBs consume one argument */
block|}
block|}
name|rc
operator|=
name|SQLBindParameter
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
name|narg
argument_list|,
name|inOut
argument_list|,
name|cType
argument_list|,
name|baseType
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|,
name|indicator
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|statement
operator|->
name|apr_dbd
argument_list|,
literal|"SQLBindParameter"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* LOB / Bucket Brigade functions */
end_comment

begin_comment
comment|/* bucket type specific destroy */
end_comment

begin_function
specifier|static
name|void
name|odbc_lob_bucket_destroy
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|odbc_bucket
modifier|*
name|bd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|apr_bucket_shared_destroy
argument_list|(
name|bd
argument_list|)
condition|)
name|apr_bucket_free
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set aside a bucket if possible */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_lob_bucket_setaside
parameter_list|(
name|apr_bucket
modifier|*
name|e
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|odbc_bucket
modifier|*
name|bd
init|=
operator|(
name|odbc_bucket
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
comment|/* Unlikely - but if the row pool is ancestor of this pool then it is OK */
if|if
condition|(
name|apr_pool_is_ancestor
argument_list|(
name|bd
operator|->
name|row
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
return|return
name|apr_bucket_setaside_notimpl
argument_list|(
name|e
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* split a bucket into a heap bucket followed by a LOB bkt w/remaining data */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_lob_bucket_read
parameter_list|(
name|apr_bucket
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_read_type_e
name|block
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLLEN
name|len_indicator
decl_stmt|;
name|SQLSMALLINT
name|type
decl_stmt|;
name|odbc_bucket
modifier|*
name|bd
init|=
operator|(
name|odbc_bucket
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
name|apr_bucket
modifier|*
name|nxt
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
init|=
name|bd
operator|->
name|row
operator|->
name|res
operator|->
name|apr_dbd
operator|->
name|defaultBufferSize
decl_stmt|;
name|int
name|eos
decl_stmt|;
comment|/* C type is CHAR for CLOBs, DEFAULT for BLOBs */
name|type
operator|=
name|bd
operator|->
name|row
operator|->
name|res
operator|->
name|coltypes
index|[
name|bd
operator|->
name|col
index|]
expr_stmt|;
name|type
operator|=
operator|(
name|type
operator|==
name|SQL_LONGVARCHAR
operator|)
condition|?
name|SQL_C_CHAR
else|:
name|SQL_C_DEFAULT
expr_stmt|;
comment|/* LOB buffers are always at least APR_BUCKET_BUFF_SIZE,       *   but they may be much bigger per the BUFSIZE parameter.      */
if|if
condition|(
name|bufsize
operator|<
name|APR_BUCKET_BUFF_SIZE
condition|)
name|bufsize
operator|=
name|APR_BUCKET_BUFF_SIZE
expr_stmt|;
name|buf
operator|=
name|apr_bucket_alloc
argument_list|(
name|bufsize
argument_list|,
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|SQLGetData
argument_list|(
name|bd
operator|->
name|row
operator|->
name|res
operator|->
name|stmt
argument_list|,
name|bd
operator|->
name|col
operator|+
literal|1
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
operator|&
name|len_indicator
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|bd
operator|->
name|row
operator|->
name|res
operator|->
name|apr_dbd
argument_list|,
literal|"SQLGetData"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|bd
operator|->
name|row
operator|->
name|res
operator|->
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQL_NO_DATA
operator|||
name|len_indicator
operator|==
name|SQL_NULL_DATA
operator|||
name|len_indicator
operator|<
literal|0
condition|)
name|len_indicator
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
operator|||
name|rc
operator|==
name|SQL_NO_DATA
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|SQL_SUCCESS_WITH_INFO
operator|&&
operator|(
name|len_indicator
operator|==
name|SQL_NO_TOTAL
operator|||
name|len_indicator
operator|>=
name|bufsize
operator|)
condition|)
block|{
comment|/* not the last read = a full buffer. CLOBs have a null terminator */
operator|*
name|len
operator|=
name|bufsize
operator|-
operator|(
name|IS_CLOB
argument_list|(
name|bd
operator|->
name|type
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|eos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* the last read - len_indicator is supposed to be the length,               * but some driver get this wrong and return the total length.              * We try to handle both interpretations.              */
operator|*
name|len
operator|=
operator|(
name|len_indicator
operator|>
name|bufsize
operator|&&
name|len_indicator
operator|>=
operator|(
name|SQLLEN
operator|)
name|e
operator|->
name|start
operator|)
condition|?
operator|(
name|len_indicator
operator|-
operator|(
name|SQLLEN
operator|)
name|e
operator|->
name|start
operator|)
else|:
name|len_indicator
expr_stmt|;
name|eos
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eos
condition|)
block|{
comment|/* Create a new LOB bucket to append and append it */
name|nxt
operator|=
name|apr_bucket_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|apr_bucket
operator|*
argument_list|)
argument_list|,
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
name|APR_BUCKET_INIT
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|nxt
operator|->
name|length
operator|=
operator|-
literal|1
expr_stmt|;
name|nxt
operator|->
name|data
operator|=
name|e
operator|->
name|data
expr_stmt|;
name|nxt
operator|->
name|type
operator|=
operator|&
name|odbc_bucket_type
expr_stmt|;
name|nxt
operator|->
name|free
operator|=
name|apr_bucket_free
expr_stmt|;
name|nxt
operator|->
name|list
operator|=
name|e
operator|->
name|list
expr_stmt|;
name|nxt
operator|->
name|start
operator|=
name|e
operator|->
name|start
operator|+
operator|*
name|len
expr_stmt|;
name|APR_BUCKET_INSERT_AFTER
argument_list|(
name|e
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|odbc_lob_bucket_destroy
argument_list|(
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* make current bucket into a heap bucket */
name|apr_bucket_heap_make
argument_list|(
name|e
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|,
name|apr_bucket_free
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|buf
expr_stmt|;
comment|/* No data is success in this context */
name|rc
operator|=
name|SQL_SUCCESS
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a bucket brigade on the row pool for a LOB column */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_create_bucket
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
specifier|const
name|int
name|col
parameter_list|,
name|SQLSMALLINT
name|type
parameter_list|,
name|apr_bucket_brigade
modifier|*
name|bb
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|list
init|=
name|bb
operator|->
name|bucket_alloc
decl_stmt|;
name|apr_bucket
modifier|*
name|b
init|=
name|apr_bucket_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|odbc_bucket
modifier|*
name|bd
init|=
name|apr_bucket_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|odbc_bucket
argument_list|)
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|apr_bucket
modifier|*
name|eos
init|=
name|apr_bucket_eos_create
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|bd
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|bd
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|bd
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|APR_BUCKET_INIT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
operator|&
name|odbc_bucket_type
expr_stmt|;
name|b
operator|->
name|free
operator|=
name|apr_bucket_free
expr_stmt|;
name|b
operator|->
name|list
operator|=
name|list
expr_stmt|;
comment|/* LOB lengths are unknown in ODBC */
name|b
operator|=
name|apr_bucket_shared_make
argument_list|(
name|b
argument_list|,
name|bd
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|eos
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* returns a data pointer for a column,  returns NULL for NULL value,  * return -1 if data not available  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|odbc_get
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
specifier|const
name|int
name|col
parameter_list|,
specifier|const
name|SQLSMALLINT
name|sqltype
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLLEN
name|indicator
decl_stmt|;
name|int
name|state
init|=
name|row
operator|->
name|res
operator|->
name|colstate
index|[
name|col
index|]
decl_stmt|;
name|ODBC_INTPTR_T
name|options
init|=
name|row
operator|->
name|res
operator|->
name|apr_dbd
operator|->
name|dboptions
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|(
name|COL_UNAVAIL
operator|)
case|:
return|return
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
return|;
case|case
operator|(
name|COL_RETRIEVED
operator|)
case|:
return|return
name|NULL
return|;
case|case
operator|(
name|COL_BOUND
operator|)
case|:
case|case
operator|(
name|COL_PRESENT
operator|)
case|:
if|if
condition|(
name|sqltype
operator|==
name|row
operator|->
name|res
operator|->
name|coltypes
index|[
name|col
index|]
condition|)
block|{
comment|/* same type and we already have the data */
name|row
operator|->
name|res
operator|->
name|colstate
index|[
name|col
index|]
operator|=
name|COL_RETRIEVED
expr_stmt|;
return|return
operator|(
name|row
operator|->
name|res
operator|->
name|colinds
index|[
name|col
index|]
operator|==
name|SQL_NULL_DATA
operator|)
condition|?
name|NULL
else|:
name|row
operator|->
name|res
operator|->
name|colptrs
index|[
name|col
index|]
return|;
block|}
block|}
comment|/* we need to get the data now */
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|SQL_GD_ANY_ORDER
operator|)
condition|)
block|{
comment|/* this ODBC driver requires columns to be retrieved in order,          * so we attempt to get every prior un-gotten non-LOB column          */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|col
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|row
operator|->
name|res
operator|->
name|colstate
index|[
name|i
index|]
operator|==
name|COL_AVAIL
condition|)
block|{
if|if
condition|(
name|IS_LOB
argument_list|(
name|row
operator|->
name|res
operator|->
name|coltypes
index|[
name|i
index|]
argument_list|)
condition|)
name|row
operator|->
name|res
operator|->
name|colstate
index|[
name|i
index|]
operator|=
name|COL_UNAVAIL
expr_stmt|;
else|else
block|{
name|odbc_get
argument_list|(
name|row
argument_list|,
name|i
argument_list|,
name|row
operator|->
name|res
operator|->
name|coltypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|row
operator|->
name|res
operator|->
name|colstate
index|[
name|i
index|]
operator|=
name|COL_PRESENT
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|state
operator|==
name|COL_BOUND
operator|&&
operator|!
operator|(
name|options
operator|&
name|SQL_GD_BOUND
operator|)
operator|)
condition|)
comment|/* this driver won't let us re-get bound columns */
return|return
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* a LOB might not have a buffer allocated yet - so create one */
if|if
condition|(
operator|!
name|row
operator|->
name|res
operator|->
name|colptrs
index|[
name|col
index|]
condition|)
name|row
operator|->
name|res
operator|->
name|colptrs
index|[
name|col
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|row
operator|->
name|res
operator|->
name|colsizes
index|[
name|col
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLGetData
argument_list|(
name|row
operator|->
name|res
operator|->
name|stmt
argument_list|,
name|col
operator|+
literal|1
argument_list|,
name|sqltype
argument_list|,
name|row
operator|->
name|res
operator|->
name|colptrs
index|[
name|col
index|]
argument_list|,
name|row
operator|->
name|res
operator|->
name|colsizes
index|[
name|col
index|]
argument_list|,
operator|&
name|indicator
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|row
operator|->
name|res
operator|->
name|apr_dbd
argument_list|,
literal|"SQLGetData"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|row
operator|->
name|res
operator|->
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|indicator
operator|==
name|SQL_NULL_DATA
operator|||
name|rc
operator|==
name|SQL_NO_DATA
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
comment|/* whatever it was originally, it is now this sqltype */
name|row
operator|->
name|res
operator|->
name|coltypes
index|[
name|col
index|]
operator|=
name|sqltype
expr_stmt|;
comment|/* this allows getting CLOBs in text mode by calling get_entry          *   until it returns NULL          */
name|row
operator|->
name|res
operator|->
name|colstate
index|[
name|col
index|]
operator|=
operator|(
name|rc
operator|==
name|SQL_SUCCESS_WITH_INFO
operator|)
condition|?
name|COL_AVAIL
else|:
name|COL_RETRIEVED
expr_stmt|;
return|return
name|row
operator|->
name|res
operator|->
name|colptrs
index|[
name|col
index|]
return|;
block|}
else|else
return|return
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse the parameter string for open */
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_parse_params
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
name|int
modifier|*
name|connect
parameter_list|,
name|SQLCHAR
modifier|*
modifier|*
name|datasource
parameter_list|,
name|SQLCHAR
modifier|*
modifier|*
name|user
parameter_list|,
name|SQLCHAR
modifier|*
modifier|*
name|password
parameter_list|,
name|int
modifier|*
name|defaultBufferSize
parameter_list|,
name|int
modifier|*
name|nattrs
parameter_list|,
name|int
modifier|*
modifier|*
name|attrs
parameter_list|,
name|ODBC_INTPTR_T
modifier|*
modifier|*
name|attrvals
parameter_list|)
block|{
name|char
modifier|*
name|seps
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|name
index|[
name|MAX_PARAMS
index|]
decl_stmt|,
modifier|*
name|val
index|[
name|MAX_PARAMS
index|]
decl_stmt|;
name|int
name|nparams
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|*
name|attrs
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|MAX_PARAMS
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|attrvals
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|MAX_PARAMS
operator|*
sizeof|sizeof
argument_list|(
name|ODBC_INTPTR_T
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nattrs
operator|=
literal|0
expr_stmt|;
name|seps
operator|=
name|DEFAULTSEPS
expr_stmt|;
name|name
index|[
name|nparams
index|]
operator|=
name|apr_strtok
argument_list|(
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|params
argument_list|)
argument_list|,
name|seps
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
comment|/* no params is OK here - let connect return a more useful error msg */
if|if
condition|(
operator|!
name|name
index|[
name|nparams
index|]
condition|)
return|return
name|SQL_SUCCESS
return|;
do|do
block|{
if|if
condition|(
name|last
index|[
name|strspn
argument_list|(
name|last
argument_list|,
name|seps
argument_list|)
index|]
operator|==
name|CSINGLEQUOTE
condition|)
block|{
name|last
operator|+=
name|strspn
argument_list|(
name|last
argument_list|,
name|seps
argument_list|)
expr_stmt|;
name|seps
operator|=
name|SSINGLEQUOTE
expr_stmt|;
block|}
name|val
index|[
name|nparams
index|]
operator|=
name|apr_strtok
argument_list|(
name|NULL
argument_list|,
name|seps
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|seps
operator|=
name|DEFAULTSEPS
expr_stmt|;
operator|++
name|nparams
expr_stmt|;
name|next
operator|=
name|apr_strtok
argument_list|(
name|NULL
argument_list|,
name|seps
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|nparams
operator|>=
name|MAX_PARAMS
condition|)
block|{
comment|/* too many parameters, no place to store */
return|return
name|APR_EGENERAL
return|;
block|}
name|name
index|[
name|nparams
index|]
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"CONNECT"
argument_list|)
condition|)
block|{
operator|*
name|datasource
operator|=
operator|(
name|SQLCHAR
operator|*
operator|)
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|connect
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"DATASOURCE"
argument_list|)
condition|)
block|{
operator|*
name|datasource
operator|=
operator|(
name|SQLCHAR
operator|*
operator|)
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|connect
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"USER"
argument_list|)
condition|)
block|{
operator|*
name|user
operator|=
operator|(
name|SQLCHAR
operator|*
operator|)
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"PASSWORD"
argument_list|)
condition|)
block|{
operator|*
name|password
operator|=
operator|(
name|SQLCHAR
operator|*
operator|)
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"BUFSIZE"
argument_list|)
condition|)
block|{
operator|*
name|defaultBufferSize
operator|=
name|atoi
argument_list|(
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"ACCESS"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"READ_ONLY"
argument_list|)
condition|)
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|SQL_MODE_READ_ONLY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"READ_WRITE"
argument_list|)
condition|)
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|SQL_MODE_READ_WRITE
expr_stmt|;
else|else
return|return
name|SQL_ERROR
return|;
operator|(
operator|*
name|attrs
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|SQL_ATTR_ACCESS_MODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"CTIMEOUT"
argument_list|)
condition|)
block|{
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|atoi
argument_list|(
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|attrs
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|SQL_ATTR_LOGIN_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"STIMEOUT"
argument_list|)
condition|)
block|{
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|atoi
argument_list|(
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|attrs
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|SQL_ATTR_CONNECTION_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|"TXMODE"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"READ_UNCOMMITTED"
argument_list|)
condition|)
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|SQL_TXN_READ_UNCOMMITTED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"READ_COMMITTED"
argument_list|)
condition|)
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|SQL_TXN_READ_COMMITTED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"REPEATABLE_READ"
argument_list|)
condition|)
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|SQL_TXN_REPEATABLE_READ
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"SERIALIZABLE"
argument_list|)
condition|)
operator|(
operator|*
name|attrvals
operator|)
index|[
name|j
index|]
operator|=
name|SQL_TXN_SERIALIZABLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|apr_strnatcasecmp
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|"DEFAULT"
argument_list|)
condition|)
continue|continue;
else|else
return|return
name|SQL_ERROR
return|;
operator|(
operator|*
name|attrs
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|SQL_ATTR_TXN_ISOLATION
expr_stmt|;
block|}
else|else
return|return
name|SQL_ERROR
return|;
block|}
operator|*
name|nattrs
operator|=
name|j
expr_stmt|;
return|return
operator|(
operator|*
name|datasource
operator|&&
operator|*
name|defaultBufferSize
operator|)
condition|?
name|APR_SUCCESS
else|:
name|SQL_ERROR
return|;
block|}
end_function

begin_comment
comment|/* common handling after ODBC calls - save error info (code and text) in dbc */
end_comment

begin_function
specifier|static
name|void
name|check_error
parameter_list|(
name|apr_dbd_t
modifier|*
name|dbc
parameter_list|,
specifier|const
name|char
modifier|*
name|step
parameter_list|,
name|SQLRETURN
name|rc
parameter_list|,
name|SQLSMALLINT
name|type
parameter_list|,
name|SQLHANDLE
name|h
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|SQLCHAR
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|SQLCHAR
name|sqlstate
index|[
literal|128
index|]
decl_stmt|;
name|SQLINTEGER
name|native
decl_stmt|;
name|SQLSMALLINT
name|reslength
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|logval
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* set info about last error in dbc  - fast return for SQL_SUCCESS  */
if|if
condition|(
name|rc
operator|==
name|SQL_SUCCESS
condition|)
block|{
name|char
name|successMsg
index|[]
init|=
literal|"[dbd_odbc] SQL_SUCCESS "
decl_stmt|;
name|apr_size_t
name|successMsgLen
init|=
sizeof|sizeof
name|successMsg
operator|-
literal|1
decl_stmt|;
name|dbc
operator|->
name|lasterrorcode
operator|=
name|SQL_SUCCESS
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|dbc
operator|->
name|lastError
argument_list|,
name|successMsg
argument_list|,
sizeof|sizeof
name|dbc
operator|->
name|lastError
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|dbc
operator|->
name|lastError
operator|+
name|successMsgLen
argument_list|,
name|step
argument_list|,
sizeof|sizeof
name|dbc
operator|->
name|lastError
operator|-
name|successMsgLen
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|SQL_INVALID_HANDLE
case|:
name|res
operator|=
literal|"SQL_INVALID_HANDLE"
expr_stmt|;
break|break;
case|case
name|SQL_ERROR
case|:
name|res
operator|=
literal|"SQL_ERROR"
expr_stmt|;
break|break;
case|case
name|SQL_SUCCESS_WITH_INFO
case|:
name|res
operator|=
literal|"SQL_SUCCESS_WITH_INFO"
expr_stmt|;
break|break;
case|case
name|SQL_STILL_EXECUTING
case|:
name|res
operator|=
literal|"SQL_STILL_EXECUTING"
expr_stmt|;
break|break;
case|case
name|SQL_NEED_DATA
case|:
name|res
operator|=
literal|"SQL_NEED_DATA"
expr_stmt|;
break|break;
case|case
name|SQL_NO_DATA
case|:
name|res
operator|=
literal|"SQL_NO_DATA"
expr_stmt|;
break|break;
default|default:
name|res
operator|=
literal|"unrecognized SQL return code"
expr_stmt|;
block|}
comment|/* these two returns are expected during normal execution */
if|if
condition|(
name|rc
operator|!=
name|SQL_SUCCESS_WITH_INFO
operator|&&
name|rc
operator|!=
name|SQL_NO_DATA
operator|&&
name|dbc
operator|->
name|can_commit
operator|!=
name|APR_DBD_TRANSACTION_IGNORE_ERRORS
condition|)
block|{
name|dbc
operator|->
name|can_commit
operator|=
name|APR_DBD_TRANSACTION_ROLLBACK
expr_stmt|;
block|}
name|p
operator|=
name|dbc
operator|->
name|lastError
expr_stmt|;
name|end
operator|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|dbc
operator|->
name|lastError
argument_list|)
expr_stmt|;
name|dbc
operator|->
name|lasterrorcode
operator|=
name|rc
expr_stmt|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"[dbd_odbc] %.64s returned %.30s (%d) at %.24s:%d "
argument_list|,
name|step
argument_list|,
name|res
argument_list|,
name|rc
argument_list|,
name|SOURCE_FILE
argument_list|,
name|line
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|rc
operator|=
literal|0
init|;
name|rc
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|SQLGetDiagRec
argument_list|(
name|type
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|sqlstate
argument_list|,
operator|&
name|native
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|&
name|reslength
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
operator|&&
operator|(
name|p
operator|<
operator|(
name|end
operator|-
literal|280
operator|)
operator|)
condition|)
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%.256s %.20s "
argument_list|,
name|buffer
argument_list|,
name|sqlstate
argument_list|)
expr_stmt|;
block|}
name|apr_env_get
argument_list|(
operator|&
name|logval
argument_list|,
literal|"apr_dbd_odbc_log"
argument_list|,
name|dbc
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* if env var was set or call was init/open (no dbname) - log to stderr */
if|if
condition|(
name|logval
operator|||
operator|!
name|dbc
operator|->
name|dbname
condition|)
block|{
name|char
name|timestamp
index|[
name|APR_CTIME_LEN
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|se
decl_stmt|;
name|apr_ctime
argument_list|(
name|timestamp
argument_list|,
name|apr_time_now
argument_list|()
argument_list|)
expr_stmt|;
name|apr_file_open_stderr
argument_list|(
operator|&
name|se
argument_list|,
name|dbc
operator|->
name|pool
argument_list|)
expr_stmt|;
name|apr_file_printf
argument_list|(
name|se
argument_list|,
literal|"[%s] %s\n"
argument_list|,
name|timestamp
argument_list|,
name|dbc
operator|->
name|lastError
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|int
name|odbc_check_rollback
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
if|if
condition|(
name|handle
operator|->
name|can_commit
operator|==
name|APR_DBD_TRANSACTION_ROLLBACK
condition|)
block|{
name|handle
operator|->
name|lasterrorcode
operator|=
name|SQL_ERROR
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|handle
operator|->
name|lastError
argument_list|,
literal|"[dbd_odbc] Rollback pending "
argument_list|,
sizeof|sizeof
name|handle
operator|->
name|lastError
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *   public functions per DBD driver API  */
end_comment

begin_comment
comment|/** init: allow driver to perform once-only initialisation. **/
end_comment

begin_function
specifier|static
name|void
name|odbc_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|char
modifier|*
name|step
decl_stmt|;
name|apr_version_t
name|apuver
decl_stmt|;
name|apu_version
argument_list|(
operator|&
name|apuver
argument_list|)
expr_stmt|;
if|if
condition|(
name|apuver
operator|.
name|major
operator|!=
name|DRIVER_APU_VERSION_MAJOR
operator|||
name|apuver
operator|.
name|minor
operator|!=
name|DRIVER_APU_VERSION_MINOR
condition|)
block|{
name|apr_file_t
modifier|*
name|se
decl_stmt|;
name|apr_file_open_stderr
argument_list|(
operator|&
name|se
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|apr_file_printf
argument_list|(
name|se
argument_list|,
literal|"Incorrect "
name|ODBC_DRIVER_STRING
literal|" dbd driver version\n"
literal|"Attempt to load APU version %d.%d driver with APU version %d.%d\n"
argument_list|,
name|DRIVER_APU_VERSION_MAJOR
argument_list|,
name|DRIVER_APU_VERSION_MINOR
argument_list|,
name|apuver
operator|.
name|major
argument_list|,
name|apuver
operator|.
name|minor
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|henv
condition|)
return|return;
name|step
operator|=
literal|"SQLAllocHandle (SQL_HANDLE_ENV)"
expr_stmt|;
name|rc
operator|=
name|SQLAllocHandle
argument_list|(
name|SQL_HANDLE_ENV
argument_list|,
name|SQL_NULL_HANDLE
argument_list|,
operator|&
name|henv
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|henv
argument_list|,
name|odbc_close_env
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|step
operator|=
literal|"SQLSetEnvAttr"
expr_stmt|;
name|rc
operator|=
name|SQLSetEnvAttr
argument_list|(
name|henv
argument_list|,
name|SQL_ATTR_ODBC_VERSION
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|SQL_OV_ODBC3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_dbd_t
name|tmp_dbc
decl_stmt|;
name|SQLHANDLE
name|err_h
init|=
name|henv
decl_stmt|;
name|tmp_dbc
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|tmp_dbc
operator|.
name|dbname
operator|=
name|NULL
expr_stmt|;
name|CHECK_ERROR
argument_list|(
operator|&
name|tmp_dbc
argument_list|,
name|step
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_ENV
argument_list|,
name|err_h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** native_handle: return the native database handle of the underlying db **/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|odbc_native_handle
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
return|return
name|handle
operator|->
name|dbc
return|;
block|}
end_function

begin_comment
comment|/** open: obtain a database connection from the server rec. **/
end_comment

begin_comment
comment|/* It would be more efficient to allocate a single statement handle   * here - but SQL_ATTR_CURSOR_SCROLLABLE must be set before  * SQLPrepare, and we don't know whether random-access is  * specified until SQLExecute so we cannot.  */
end_comment

begin_function
specifier|static
name|apr_dbd_t
modifier|*
name|odbc_open
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLHANDLE
name|hdbc
init|=
name|NULL
decl_stmt|;
name|apr_dbd_t
modifier|*
name|handle
decl_stmt|;
name|char
modifier|*
name|err_step
decl_stmt|;
name|int
name|err_htype
decl_stmt|,
name|i
decl_stmt|;
name|int
name|defaultBufferSize
init|=
name|DEFAULT_BUFFER_SIZE
decl_stmt|;
name|SQLHANDLE
name|err_h
init|=
name|NULL
decl_stmt|;
name|SQLCHAR
modifier|*
name|datasource
init|=
operator|(
name|SQLCHAR
operator|*
operator|)
literal|""
decl_stmt|,
modifier|*
name|user
init|=
operator|(
name|SQLCHAR
operator|*
operator|)
literal|""
decl_stmt|,
modifier|*
name|password
init|=
operator|(
name|SQLCHAR
operator|*
operator|)
literal|""
decl_stmt|;
name|int
name|nattrs
init|=
literal|0
decl_stmt|,
modifier|*
name|attrs
init|=
name|NULL
decl_stmt|,
name|connect
init|=
literal|0
decl_stmt|;
name|ODBC_INTPTR_T
modifier|*
name|attrvals
init|=
name|NULL
decl_stmt|;
name|err_step
operator|=
literal|"SQLAllocHandle (SQL_HANDLE_DBC)"
expr_stmt|;
name|err_htype
operator|=
name|SQL_HANDLE_ENV
expr_stmt|;
name|err_h
operator|=
name|henv
expr_stmt|;
name|rc
operator|=
name|SQLAllocHandle
argument_list|(
name|SQL_HANDLE_DBC
argument_list|,
name|henv
argument_list|,
operator|&
name|hdbc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|err_step
operator|=
literal|"Invalid DBD Parameters - open"
expr_stmt|;
name|err_htype
operator|=
name|SQL_HANDLE_DBC
expr_stmt|;
name|err_h
operator|=
name|hdbc
expr_stmt|;
name|rc
operator|=
name|odbc_parse_params
argument_list|(
name|pool
argument_list|,
name|params
argument_list|,
operator|&
name|connect
argument_list|,
operator|&
name|datasource
argument_list|,
operator|&
name|user
argument_list|,
operator|&
name|password
argument_list|,
operator|&
name|defaultBufferSize
argument_list|,
operator|&
name|nattrs
argument_list|,
operator|&
name|attrs
argument_list|,
operator|&
name|attrvals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nattrs
operator|&&
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|err_step
operator|=
literal|"SQLSetConnectAttr (from DBD Parameters)"
expr_stmt|;
name|err_htype
operator|=
name|SQL_HANDLE_DBC
expr_stmt|;
name|err_h
operator|=
name|hdbc
expr_stmt|;
name|rc
operator|=
name|SQLSetConnectAttr
argument_list|(
name|hdbc
argument_list|,
name|attrs
index|[
name|i
index|]
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|attrvals
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
if|if
condition|(
name|connect
condition|)
block|{
name|SQLCHAR
name|out
index|[
literal|1024
index|]
decl_stmt|;
name|SQLSMALLINT
name|outlen
decl_stmt|;
name|err_step
operator|=
literal|"SQLDriverConnect"
expr_stmt|;
name|err_htype
operator|=
name|SQL_HANDLE_DBC
expr_stmt|;
name|err_h
operator|=
name|hdbc
expr_stmt|;
name|rc
operator|=
name|SQLDriverConnect
argument_list|(
name|hdbc
argument_list|,
name|NULL
argument_list|,
name|datasource
argument_list|,
operator|(
name|SQLSMALLINT
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|datasource
argument_list|)
argument_list|,
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|,
operator|&
name|outlen
argument_list|,
name|SQL_DRIVER_NOPROMPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err_step
operator|=
literal|"SQLConnect"
expr_stmt|;
name|err_htype
operator|=
name|SQL_HANDLE_DBC
expr_stmt|;
name|err_h
operator|=
name|hdbc
expr_stmt|;
name|rc
operator|=
name|SQLConnect
argument_list|(
name|hdbc
argument_list|,
name|datasource
argument_list|,
operator|(
name|SQLSMALLINT
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|datasource
argument_list|)
argument_list|,
name|user
argument_list|,
operator|(
name|SQLSMALLINT
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|user
argument_list|)
argument_list|,
name|password
argument_list|,
operator|(
name|SQLSMALLINT
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|password
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|handle
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_t
argument_list|)
argument_list|)
expr_stmt|;
name|handle
operator|->
name|dbname
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
operator|(
name|char
operator|*
operator|)
name|datasource
argument_list|)
expr_stmt|;
name|handle
operator|->
name|dbc
operator|=
name|hdbc
expr_stmt|;
name|handle
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|handle
operator|->
name|defaultBufferSize
operator|=
name|defaultBufferSize
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLConnect"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
name|handle
operator|->
name|default_transaction_mode
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|can_commit
operator|=
name|APR_DBD_TRANSACTION_IGNORE_ERRORS
expr_stmt|;
name|SQLGetInfo
argument_list|(
name|hdbc
argument_list|,
name|SQL_DEFAULT_TXN_ISOLATION
argument_list|,
operator|&
operator|(
name|handle
operator|->
name|default_transaction_mode
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ODBC_INTPTR_T
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|handle
operator|->
name|transaction_mode
operator|=
name|handle
operator|->
name|default_transaction_mode
expr_stmt|;
name|SQLGetInfo
argument_list|(
name|hdbc
argument_list|,
name|SQL_GETDATA_EXTENSIONS
argument_list|,
operator|&
operator|(
name|handle
operator|->
name|dboptions
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ODBC_INTPTR_T
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|handle
argument_list|,
name|odbc_close_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
else|else
block|{
name|apr_dbd_t
name|tmp_dbc
decl_stmt|;
name|tmp_dbc
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|tmp_dbc
operator|.
name|dbname
operator|=
name|NULL
expr_stmt|;
name|CHECK_ERROR
argument_list|(
operator|&
name|tmp_dbc
argument_list|,
name|err_step
argument_list|,
name|rc
argument_list|,
name|err_htype
argument_list|,
name|err_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|tmp_dbc
operator|.
name|lastError
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdbc
condition|)
name|SQLFreeHandle
argument_list|(
name|SQL_HANDLE_DBC
argument_list|,
name|hdbc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/** check_conn: check status of a database connection **/
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_check_conn
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
name|SQLUINTEGER
name|isDead
decl_stmt|;
name|SQLRETURN
name|rc
decl_stmt|;
name|rc
operator|=
name|SQLGetConnectAttr
argument_list|(
name|handle
operator|->
name|dbc
argument_list|,
name|SQL_ATTR_CONNECTION_DEAD
argument_list|,
operator|&
name|isDead
argument_list|,
sizeof|sizeof
argument_list|(
name|SQLUINTEGER
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLGetConnectAttr (SQL_ATTR_CONNECTION_DEAD)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
comment|/* if driver cannot check connection, say so */
if|if
condition|(
name|rc
operator|!=
name|SQL_SUCCESS
condition|)
return|return
name|APR_ENOTIMPL
return|;
return|return
operator|(
name|isDead
operator|==
name|SQL_CD_FALSE
operator|)
condition|?
name|APR_SUCCESS
else|:
name|APR_EGENERAL
return|;
block|}
end_function

begin_comment
comment|/** set_dbname: select database name.  May be a no-op if not supported. **/
end_comment

begin_function
specifier|static
name|int
name|odbc_set_dbname
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|apr_strnatcmp
argument_list|(
name|name
argument_list|,
name|handle
operator|->
name|dbname
argument_list|)
condition|)
block|{
return|return
name|APR_EGENERAL
return|;
comment|/* It's illegal to change dbname in ODBC */
block|}
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"set_dbname (no-op)"
argument_list|,
name|SQL_SUCCESS
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
comment|/* OK if it's the same name */
block|}
end_function

begin_comment
comment|/** transaction: start a transaction.  May be a no-op. **/
end_comment

begin_function
specifier|static
name|int
name|odbc_start_transaction
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_transaction_t
modifier|*
modifier|*
name|trans
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
if|if
condition|(
name|handle
operator|->
name|transaction_mode
condition|)
block|{
name|rc
operator|=
name|SQLSetConnectAttr
argument_list|(
name|handle
operator|->
name|dbc
argument_list|,
name|SQL_ATTR_TXN_ISOLATION
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|handle
operator|->
name|transaction_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLSetConnectAttr (SQL_ATTR_TXN_ISOLATION)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
comment|/* turn off autocommit for transactions */
name|rc
operator|=
name|SQLSetConnectAttr
argument_list|(
name|handle
operator|->
name|dbc
argument_list|,
name|SQL_ATTR_AUTOCOMMIT
argument_list|,
name|SQL_AUTOCOMMIT_OFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLSetConnectAttr (SQL_ATTR_AUTOCOMMIT)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
operator|*
name|trans
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_transaction_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|trans
operator|)
operator|->
name|dbc
operator|=
name|handle
operator|->
name|dbc
expr_stmt|;
operator|(
operator|*
name|trans
operator|)
operator|->
name|apr_dbd
operator|=
name|handle
expr_stmt|;
block|}
name|handle
operator|->
name|can_commit
operator|=
name|APR_DBD_TRANSACTION_COMMIT
expr_stmt|;
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** end_transaction: end a transaction **/
end_comment

begin_function
specifier|static
name|int
name|odbc_end_transaction
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|int
name|action
init|=
operator|(
name|trans
operator|->
name|apr_dbd
operator|->
name|can_commit
operator|!=
name|APR_DBD_TRANSACTION_ROLLBACK
operator|)
condition|?
name|SQL_COMMIT
else|:
name|SQL_ROLLBACK
decl_stmt|;
name|rc
operator|=
name|SQLEndTran
argument_list|(
name|SQL_HANDLE_DBC
argument_list|,
name|trans
operator|->
name|dbc
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|trans
operator|->
name|apr_dbd
argument_list|,
literal|"SQLEndTran"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|trans
operator|->
name|dbc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLSetConnectAttr
argument_list|(
name|trans
operator|->
name|dbc
argument_list|,
name|SQL_ATTR_AUTOCOMMIT
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|SQL_AUTOCOMMIT_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|trans
operator|->
name|apr_dbd
argument_list|,
literal|"SQLSetConnectAttr (SQL_ATTR_AUTOCOMMIT)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|trans
operator|->
name|dbc
argument_list|)
expr_stmt|;
block|}
name|trans
operator|->
name|apr_dbd
operator|->
name|can_commit
operator|=
name|APR_DBD_TRANSACTION_IGNORE_ERRORS
expr_stmt|;
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** query: execute an SQL statement which doesn't return a result set **/
end_comment

begin_function
specifier|static
name|int
name|odbc_query
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
specifier|const
name|char
modifier|*
name|statement
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLHANDLE
name|hstmt
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|statement
argument_list|)
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
name|rc
operator|=
name|SQLAllocHandle
argument_list|(
name|SQL_HANDLE_STMT
argument_list|,
name|handle
operator|->
name|dbc
argument_list|,
operator|&
name|hstmt
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLAllocHandle (STMT)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
name|rc
operator|=
name|SQLExecDirect
argument_list|(
name|hstmt
argument_list|,
operator|(
name|SQLCHAR
operator|*
operator|)
name|statement
argument_list|,
operator|(
name|SQLINTEGER
operator|)
name|len
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLExecDirect"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|SQLLEN
name|rowcount
decl_stmt|;
name|rc
operator|=
name|SQLRowCount
argument_list|(
name|hstmt
argument_list|,
operator|&
name|rowcount
argument_list|)
expr_stmt|;
operator|*
name|nrows
operator|=
operator|(
name|int
operator|)
name|rowcount
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLRowCount"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
block|}
name|SQLFreeHandle
argument_list|(
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** select: execute an SQL statement which returns a result set **/
end_comment

begin_function
specifier|static
name|int
name|odbc_select
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|res
parameter_list|,
specifier|const
name|char
modifier|*
name|statement
parameter_list|,
name|int
name|random
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLHANDLE
name|hstmt
decl_stmt|;
name|apr_dbd_prepared_t
modifier|*
name|stmt
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|statement
argument_list|)
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
name|rc
operator|=
name|SQLAllocHandle
argument_list|(
name|SQL_HANDLE_STMT
argument_list|,
name|handle
operator|->
name|dbc
argument_list|,
operator|&
name|hstmt
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLAllocHandle (STMT)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
comment|/* Prepare an apr_dbd_prepared_t for pool cleanup, even though this      * is not a prepared statement.  We want the same cleanup mechanism.      */
name|stmt
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_prepared_t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|->
name|apr_dbd
operator|=
name|handle
expr_stmt|;
name|stmt
operator|->
name|dbc
operator|=
name|handle
operator|->
name|dbc
expr_stmt|;
name|stmt
operator|->
name|stmt
operator|=
name|hstmt
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|stmt
argument_list|,
name|odbc_close_pstmt
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
condition|)
block|{
name|rc
operator|=
name|SQLSetStmtAttr
argument_list|(
name|hstmt
argument_list|,
name|SQL_ATTR_CURSOR_SCROLLABLE
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|SQL_SCROLLABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLSetStmtAttr (SQL_ATTR_CURSOR_SCROLLABLE)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLExecDirect
argument_list|(
name|hstmt
argument_list|,
operator|(
name|SQLCHAR
operator|*
operator|)
name|statement
argument_list|,
operator|(
name|SQLINTEGER
operator|)
name|len
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLExecDirect"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|hstmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|odbc_create_results
argument_list|(
name|handle
argument_list|,
name|hstmt
argument_list|,
name|pool
argument_list|,
name|random
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|res
argument_list|,
name|odbc_close_results
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** num_cols: get the number of columns in a results set **/
end_comment

begin_function
specifier|static
name|int
name|odbc_num_cols
parameter_list|(
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|)
block|{
return|return
name|res
operator|->
name|ncols
return|;
block|}
end_function

begin_comment
comment|/** num_tuples: get the number of rows in a results set **/
end_comment

begin_function
specifier|static
name|int
name|odbc_num_tuples
parameter_list|(
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|SQLLEN
name|nrows
decl_stmt|;
name|rc
operator|=
name|SQLRowCount
argument_list|(
name|res
operator|->
name|stmt
argument_list|,
operator|&
name|nrows
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|res
operator|->
name|apr_dbd
argument_list|,
literal|"SQLRowCount"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|res
operator|->
name|stmt
argument_list|)
expr_stmt|;
return|return
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|?
operator|(
name|int
operator|)
name|nrows
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/** get_row: get a row from a result set **/
end_comment

begin_function
specifier|static
name|int
name|odbc_get_row
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|apr_dbd_row_t
modifier|*
modifier|*
name|row
parameter_list|,
name|int
name|rownum
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|char
modifier|*
name|fetchtype
decl_stmt|;
name|int
name|c
decl_stmt|;
operator|*
name|row
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_row_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|row
operator|)
operator|->
name|stmt
operator|=
name|res
operator|->
name|stmt
expr_stmt|;
operator|(
operator|*
name|row
operator|)
operator|->
name|dbc
operator|=
name|res
operator|->
name|dbc
expr_stmt|;
operator|(
operator|*
name|row
operator|)
operator|->
name|res
operator|=
name|res
expr_stmt|;
operator|(
operator|*
name|row
operator|)
operator|->
name|pool
operator|=
name|res
operator|->
name|pool
expr_stmt|;
comment|/* mark all the columns as needing SQLGetData unless they are bound  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|res
operator|->
name|ncols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|res
operator|->
name|colstate
index|[
name|c
index|]
operator|!=
name|COL_BOUND
condition|)
block|{
name|res
operator|->
name|colstate
index|[
name|c
index|]
operator|=
name|COL_AVAIL
expr_stmt|;
block|}
comment|/* some drivers do not null-term zero-len CHAR data */
if|if
condition|(
name|res
operator|->
name|colptrs
index|[
name|c
index|]
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|res
operator|->
name|colptrs
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|random
operator|&&
operator|(
name|rownum
operator|>
literal|0
operator|)
condition|)
block|{
name|fetchtype
operator|=
literal|"SQLFetchScroll"
expr_stmt|;
name|rc
operator|=
name|SQLFetchScroll
argument_list|(
name|res
operator|->
name|stmt
argument_list|,
name|SQL_FETCH_ABSOLUTE
argument_list|,
name|rownum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fetchtype
operator|=
literal|"SQLFetch"
expr_stmt|;
name|rc
operator|=
name|SQLFetch
argument_list|(
name|res
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
name|CHECK_ERROR
argument_list|(
name|res
operator|->
name|apr_dbd
argument_list|,
name|fetchtype
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|res
operator|->
name|stmt
argument_list|)
expr_stmt|;
operator|(
operator|*
name|row
operator|)
operator|->
name|stmt
operator|=
name|res
operator|->
name|stmt
expr_stmt|;
if|if
condition|(
operator|!
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
operator|&&
operator|!
name|res
operator|->
name|random
condition|)
block|{
comment|/* early close on any error (usually SQL_NO_DATA) if fetching          * sequentially to release resources ASAP          */
name|odbc_close_results
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/** datum_get: get a binary entry from a row **/
end_comment

begin_function
specifier|static
name|apr_status_t
name|odbc_datum_get
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|col
parameter_list|,
name|apr_dbd_type_e
name|dbdtype
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|SQLSMALLINT
name|sqltype
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|col
operator|>=
name|row
operator|->
name|res
operator|->
name|ncols
condition|)
return|return
name|APR_EGENERAL
return|;
if|if
condition|(
name|dbdtype
operator|<
literal|0
operator|||
name|dbdtype
operator|>=
name|NUM_APR_DBD_TYPES
condition|)
block|{
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* invalid type */
return|return
name|APR_EGENERAL
return|;
block|}
name|len
operator|=
name|sqlSizes
index|[
name|dbdtype
index|]
expr_stmt|;
name|sqltype
operator|=
name|sqlCtype
index|[
name|dbdtype
index|]
expr_stmt|;
comment|/* must not memcpy a brigade, sentinals are relative to orig loc */
if|if
condition|(
name|IS_LOB
argument_list|(
name|sqltype
argument_list|)
condition|)
return|return
name|odbc_create_bucket
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|sqltype
argument_list|,
name|data
argument_list|)
return|;
name|p
operator|=
name|odbc_get
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|sqltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|APR_EGENERAL
return|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|APR_ENOENT
return|;
comment|/* SQL NULL value */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/** get_entry: get an entry from a row (string data) **/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|odbc_get_entry
parameter_list|(
specifier|const
name|apr_dbd_row_t
modifier|*
name|row
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|col
operator|>=
name|row
operator|->
name|res
operator|->
name|ncols
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|odbc_get
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|SQL_C_CHAR
argument_list|)
expr_stmt|;
comment|/* NULL or invalid (-1) */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|p
return|;
else|else
return|return
name|apr_pstrdup
argument_list|(
name|row
operator|->
name|pool
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** error: get current error message (if any) **/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|odbc_error
parameter_list|(
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|int
name|errnum
parameter_list|)
block|{
return|return
operator|(
name|handle
operator|)
condition|?
name|handle
operator|->
name|lastError
else|:
literal|"[dbd_odbc]No error message available"
return|;
block|}
end_function

begin_comment
comment|/** escape: escape a string so it is safe for use in query/select **/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|odbc_escape
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|)
block|{
name|char
modifier|*
name|newstr
decl_stmt|,
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|sq
decl_stmt|;
name|int
name|qcount
decl_stmt|;
comment|/* return the original if there are no single-quotes */
if|if
condition|(
operator|!
operator|(
name|sq
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
comment|/* count the single-quotes and allocate a new buffer */
for|for
control|(
name|qcount
operator|=
literal|1
init|;
operator|(
name|sq
operator|=
name|strchr
argument_list|(
name|sq
operator|+
literal|1
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|;
control|)
name|qcount
operator|++
expr_stmt|;
name|newstr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|qcount
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* move chars, doubling all single-quotes */
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|newstr
init|;
operator|*
name|src
condition|;
name|src
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|)
operator|==
literal|'\''
condition|)
operator|*
name|dst
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_function

begin_comment
comment|/** prepare: prepare a statement **/
end_comment

begin_function
specifier|static
name|int
name|odbc_prepare
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|nvals
parameter_list|,
name|apr_dbd_type_e
modifier|*
name|types
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
modifier|*
name|statement
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
operator|*
name|statement
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_dbd_prepared_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|statement
operator|)
operator|->
name|dbc
operator|=
name|handle
operator|->
name|dbc
expr_stmt|;
operator|(
operator|*
name|statement
operator|)
operator|->
name|apr_dbd
operator|=
name|handle
expr_stmt|;
operator|(
operator|*
name|statement
operator|)
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
operator|(
operator|*
name|statement
operator|)
operator|->
name|nvals
operator|=
name|nvals
expr_stmt|;
operator|(
operator|*
name|statement
operator|)
operator|->
name|types
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|types
argument_list|,
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|apr_dbd_type_e
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLAllocHandle
argument_list|(
name|SQL_HANDLE_STMT
argument_list|,
name|handle
operator|->
name|dbc
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|statement
operator|)
operator|->
name|stmt
operator|)
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|statement
argument_list|,
name|odbc_close_pstmt
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLAllocHandle (STMT)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_DBC
argument_list|,
name|handle
operator|->
name|dbc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLPrepare
argument_list|(
operator|(
operator|*
name|statement
operator|)
operator|->
name|stmt
argument_list|,
operator|(
name|SQLCHAR
operator|*
operator|)
name|query
argument_list|,
operator|(
name|SQLINTEGER
operator|)
name|len
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLPrepare"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
operator|(
operator|*
name|statement
operator|)
operator|->
name|stmt
argument_list|)
expr_stmt|;
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pquery: query using a prepared statement + args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|,
name|argp
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
for|for
control|(
name|i
operator|=
name|argp
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
operator|&&
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|odbc_bind_param
argument_list|(
name|pool
argument_list|,
name|statement
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|types
index|[
name|i
index|]
argument_list|,
operator|&
name|argp
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
name|args
argument_list|,
name|TEXTMODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLExecute
argument_list|(
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLExecute"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|SQLLEN
name|rowcount
decl_stmt|;
name|rc
operator|=
name|SQLRowCount
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
operator|&
name|rowcount
argument_list|)
expr_stmt|;
operator|*
name|nrows
operator|=
operator|(
name|int
operator|)
name|rowcount
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLRowCount"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pvquery: query using a prepared statement + args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pvquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|odbc_pquery
argument_list|(
name|pool
argument_list|,
name|handle
argument_list|,
name|nrows
argument_list|,
name|statement
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pselect: select using a prepared statement + args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|res
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|random
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|,
name|argp
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
if|if
condition|(
name|random
condition|)
block|{
name|rc
operator|=
name|SQLSetStmtAttr
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
name|SQL_ATTR_CURSOR_SCROLLABLE
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|SQL_SCROLLABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLSetStmtAttr (SQL_ATTR_CURSOR_SCROLLABLE)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|argp
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
operator|&&
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|odbc_bind_param
argument_list|(
name|pool
argument_list|,
name|statement
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|types
index|[
name|i
index|]
argument_list|,
operator|&
name|argp
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
name|args
argument_list|,
name|TEXTMODE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLExecute
argument_list|(
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLExecute"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|odbc_create_results
argument_list|(
name|handle
argument_list|,
name|statement
operator|->
name|stmt
argument_list|,
name|pool
argument_list|,
name|random
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|res
argument_list|,
name|odbc_close_results
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pvselect: select using a prepared statement + args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pvselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|res
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|random
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|odbc_pselect
argument_list|(
name|pool
argument_list|,
name|handle
argument_list|,
name|res
argument_list|,
name|statement
argument_list|,
name|random
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** get_name: get a column title from a result set **/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|odbc_get_name
parameter_list|(
specifier|const
name|apr_dbd_results_t
modifier|*
name|res
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|SQLRETURN
name|rc
decl_stmt|;
name|char
name|buffer
index|[
name|MAX_COLUMN_NAME
index|]
decl_stmt|;
name|SQLSMALLINT
name|colnamelength
decl_stmt|,
name|coltype
decl_stmt|,
name|coldecimal
decl_stmt|,
name|colnullable
decl_stmt|;
name|SQLULEN
name|colsize
decl_stmt|;
if|if
condition|(
name|col
operator|>=
name|res
operator|->
name|ncols
condition|)
return|return
name|NULL
return|;
comment|/* bogus column number */
if|if
condition|(
name|res
operator|->
name|colnames
index|[
name|col
index|]
operator|!=
name|NULL
condition|)
return|return
name|res
operator|->
name|colnames
index|[
name|col
index|]
return|;
comment|/* we already retrieved it */
name|rc
operator|=
name|SQLDescribeCol
argument_list|(
name|res
operator|->
name|stmt
argument_list|,
name|col
operator|+
literal|1
argument_list|,
operator|(
name|SQLCHAR
operator|*
operator|)
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|&
name|colnamelength
argument_list|,
operator|&
name|coltype
argument_list|,
operator|&
name|colsize
argument_list|,
operator|&
name|coldecimal
argument_list|,
operator|&
name|colnullable
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|res
operator|->
name|apr_dbd
argument_list|,
literal|"SQLDescribeCol"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|res
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|res
operator|->
name|colnames
index|[
name|col
index|]
operator|=
name|apr_pstrdup
argument_list|(
name|res
operator|->
name|pool
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|res
operator|->
name|colnames
index|[
name|col
index|]
return|;
block|}
end_function

begin_comment
comment|/** transaction_mode_get: get the mode of transaction **/
end_comment

begin_function
specifier|static
name|int
name|odbc_transaction_mode_get
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|trans
operator|->
name|apr_dbd
operator|->
name|can_commit
return|;
block|}
end_function

begin_comment
comment|/** transaction_mode_set: set the mode of transaction **/
end_comment

begin_function
specifier|static
name|int
name|odbc_transaction_mode_set
parameter_list|(
name|apr_dbd_transaction_t
modifier|*
name|trans
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|legal
init|=
operator|(
name|APR_DBD_TRANSACTION_IGNORE_ERRORS
operator||
name|APR_DBD_TRANSACTION_COMMIT
operator||
name|APR_DBD_TRANSACTION_ROLLBACK
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|legal
operator|)
operator|!=
name|mode
condition|)
return|return
name|APR_EGENERAL
return|;
name|trans
operator|->
name|apr_dbd
operator|->
name|can_commit
operator|=
name|mode
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/** pbquery: query using a prepared statement + binary args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pbquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|,
name|argp
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
for|for
control|(
name|i
operator|=
name|argp
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
operator|&&
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
name|rc
operator|=
name|odbc_bind_param
argument_list|(
name|pool
argument_list|,
name|statement
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|types
index|[
name|i
index|]
argument_list|,
operator|&
name|argp
argument_list|,
name|args
argument_list|,
name|BINARYMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLExecute
argument_list|(
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLExecute"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|SQLLEN
name|rowcount
decl_stmt|;
name|rc
operator|=
name|SQLRowCount
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
operator|&
name|rowcount
argument_list|)
expr_stmt|;
operator|*
name|nrows
operator|=
operator|(
name|int
operator|)
name|rowcount
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLRowCount"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pbselect: select using a prepared statement + binary args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pbselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|res
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|random
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|SQLRETURN
name|rc
init|=
name|SQL_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|,
name|argp
decl_stmt|;
if|if
condition|(
name|odbc_check_rollback
argument_list|(
name|handle
argument_list|)
condition|)
return|return
name|APR_EGENERAL
return|;
if|if
condition|(
name|random
condition|)
block|{
name|rc
operator|=
name|SQLSetStmtAttr
argument_list|(
name|statement
operator|->
name|stmt
argument_list|,
name|SQL_ATTR_CURSOR_SCROLLABLE
argument_list|,
operator|(
name|SQLPOINTER
operator|)
name|SQL_SCROLLABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLSetStmtAttr (SQL_ATTR_CURSOR_SCROLLABLE)"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|argp
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nargs
operator|&&
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|odbc_bind_param
argument_list|(
name|pool
argument_list|,
name|statement
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|statement
operator|->
name|types
index|[
name|i
index|]
argument_list|,
operator|&
name|argp
argument_list|,
name|args
argument_list|,
name|BINARYMODE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLExecute
argument_list|(
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|(
name|handle
argument_list|,
literal|"SQLExecute"
argument_list|,
name|rc
argument_list|,
name|SQL_HANDLE_STMT
argument_list|,
name|statement
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL_SUCCEEDED
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|odbc_create_results
argument_list|(
name|handle
argument_list|,
name|statement
operator|->
name|stmt
argument_list|,
name|pool
argument_list|,
name|random
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|res
argument_list|,
name|odbc_close_results
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_FROM_SQL_RESULT
argument_list|(
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pvbquery: query using a prepared statement + binary args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pvbquery
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|int
modifier|*
name|nrows
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|odbc_pbquery
argument_list|(
name|pool
argument_list|,
name|handle
argument_list|,
name|nrows
argument_list|,
name|statement
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
name|values
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** pvbselect: select using a prepared statement + binary args **/
end_comment

begin_function
specifier|static
name|int
name|odbc_pvbselect
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_dbd_t
modifier|*
name|handle
parameter_list|,
name|apr_dbd_results_t
modifier|*
modifier|*
name|res
parameter_list|,
name|apr_dbd_prepared_t
modifier|*
name|statement
parameter_list|,
name|int
name|random
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|values
argument_list|)
operator|*
name|statement
operator|->
name|nvals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|statement
operator|->
name|nvals
condition|;
name|i
operator|++
control|)
name|values
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|odbc_pbselect
argument_list|(
name|pool
argument_list|,
name|handle
argument_list|,
name|res
argument_list|,
name|statement
argument_list|,
name|random
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
name|values
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|APU_MODULE_DECLARE_DATA
specifier|const
name|apr_dbd_driver_t
name|ODBC_DRIVER_ENTRY
init|=
block|{
name|ODBC_DRIVER_STRING
block|,
name|odbc_init
block|,
name|odbc_native_handle
block|,
name|odbc_open
block|,
name|odbc_check_conn
block|,
name|odbc_close
block|,
name|odbc_set_dbname
block|,
name|odbc_start_transaction
block|,
name|odbc_end_transaction
block|,
name|odbc_query
block|,
name|odbc_select
block|,
name|odbc_num_cols
block|,
name|odbc_num_tuples
block|,
name|odbc_get_row
block|,
name|odbc_get_entry
block|,
name|odbc_error
block|,
name|odbc_escape
block|,
name|odbc_prepare
block|,
name|odbc_pvquery
block|,
name|odbc_pvselect
block|,
name|odbc_pquery
block|,
name|odbc_pselect
block|,
name|odbc_get_name
block|,
name|odbc_transaction_mode_get
block|,
name|odbc_transaction_mode_set
block|,
literal|"?"
block|,
name|odbc_pvbquery
block|,
name|odbc_pvbselect
block|,
name|odbc_pbquery
block|,
name|odbc_pbselect
block|,
name|odbc_datum_get
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

