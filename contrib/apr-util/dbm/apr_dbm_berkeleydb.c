begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_MEMFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_define
define|#
directive|define
name|APU_WANT_DB
end_define

begin_include
include|#
directive|include
file|"apu_want.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for abort() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"apu_config.h"
end_include

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_if
if|#
directive|if
name|APU_HAVE_DB
end_if

begin_include
include|#
directive|include
file|"apr_dbm_private.h"
end_include

begin_comment
comment|/*  * We pick up all varieties of Berkeley DB through db.h (included through  * apu_select_dbm.h). This code has been compiled/tested against DB1,  * DB_185, DB2, DB3, and DB4.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DB_VERSION_MAJOR
argument_list|)
operator|&&
operator|(
name|DB_VERSION_MAJOR
operator|>=
literal|4
operator|)
end_if

begin_comment
comment|/* We will treat anything greater than 4.1 as DB4.  * We can treat 4.0 as DB3.  */
end_comment

begin_if
if|#
directive|if
name|DB_VERSION_MAJOR
operator|>
literal|4
operator|||
operator|(
name|defined
argument_list|(
name|DB_VERSION_MINOR
argument_list|)
operator|&&
operator|(
name|DB_VERSION_MINOR
operator|>=
literal|1
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|DB_VER
value|4
end_define

begin_elif
elif|#
directive|elif
name|DB_VERSION_MAJOR
operator|==
literal|4
end_elif

begin_define
define|#
directive|define
name|DB_VER
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|DB_VERSION_MAJOR
argument_list|)
operator|&&
operator|(
name|DB_VERSION_MAJOR
operator|==
literal|3
operator|)
end_elif

begin_define
define|#
directive|define
name|DB_VER
value|3
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|DB_VERSION_MAJOR
argument_list|)
operator|&&
operator|(
name|DB_VERSION_MAJOR
operator|==
literal|2
operator|)
end_elif

begin_define
define|#
directive|define
name|DB_VER
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DB_VER
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|DB
modifier|*
name|bdb
decl_stmt|;
if|#
directive|if
name|DB_VER
operator|!=
literal|1
name|DBC
modifier|*
name|curs
decl_stmt|;
endif|#
directive|endif
block|}
name|real_file_t
typedef|;
end_typedef

begin_if
if|#
directive|if
name|DB_VER
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|TXN_ARG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TXN_ARG
value|NULL,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GET_BDB
parameter_list|(
name|f
parameter_list|)
value|(((real_file_t *)(f))->bdb)
end_define

begin_define
define|#
directive|define
name|do_fetch
parameter_list|(
name|bdb
parameter_list|,
name|k
parameter_list|,
name|v
parameter_list|)
value|((*(bdb)->get)(bdb, TXN_ARG&(k),&(v), 0))
end_define

begin_if
if|#
directive|if
name|DB_VER
operator|==
literal|1
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RO
value|O_RDONLY
end_define

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RW
value|O_RDWR
end_define

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RWCREATE
value|(O_CREAT | O_RDWR)
end_define

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RWTRUNC
value|(O_CREAT | O_RDWR | O_TRUNC)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RO
value|DB_RDONLY
end_define

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RW
value|0
end_define

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RWCREATE
value|DB_CREATE
end_define

begin_define
define|#
directive|define
name|APR_DBM_DBMODE_RWTRUNC
value|DB_TRUNCATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBVER == 1 */
end_comment

begin_comment
comment|/* -------------------------------------------------------------------------- ** ** UTILITY FUNCTIONS */
end_comment

begin_comment
comment|/* map a DB error to an apr_status_t */
end_comment

begin_function
specifier|static
name|apr_status_t
name|db2s
parameter_list|(
name|int
name|dberr
parameter_list|)
block|{
if|if
condition|(
name|dberr
operator|!=
literal|0
condition|)
block|{
comment|/* ### need to fix this */
return|return
name|APR_OS_START_USEERR
operator|+
name|dberr
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|set_error
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_status_t
name|dbm_said
parameter_list|)
block|{
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
comment|/* ### ignore whatever the DBM said (dbm_said); ask it explicitly */
if|if
condition|(
name|dbm_said
operator|==
name|APR_SUCCESS
condition|)
block|{
name|dbm
operator|->
name|errcode
operator|=
literal|0
expr_stmt|;
name|dbm
operator|->
name|errmsg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* ### need to fix. dberr was tossed in db2s(). */
comment|/* ### use db_strerror() */
name|dbm
operator|->
name|errcode
operator|=
name|dbm_said
expr_stmt|;
if|#
directive|if
name|DB_VER
operator|==
literal|1
operator|||
name|DB_VER
operator|==
literal|2
name|dbm
operator|->
name|errmsg
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|dbm
operator|->
name|errmsg
operator|=
name|db_strerror
argument_list|(
name|dbm_said
operator|-
name|APR_OS_START_USEERR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
name|dbm_said
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- ** ** DEFINE THE VTABLE FUNCTIONS FOR BERKELEY DB ** ** ### we may need three sets of these: db1, db2, db3 */
end_comment

begin_function
specifier|static
name|apr_status_t
name|vt_db_open
parameter_list|(
name|apr_dbm_t
modifier|*
modifier|*
name|pdb
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|apr_int32_t
name|mode
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|real_file_t
name|file
decl_stmt|;
name|int
name|dbmode
decl_stmt|;
operator|*
name|pdb
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APR_DBM_READONLY
case|:
name|dbmode
operator|=
name|APR_DBM_DBMODE_RO
expr_stmt|;
break|break;
case|case
name|APR_DBM_READWRITE
case|:
name|dbmode
operator|=
name|APR_DBM_DBMODE_RW
expr_stmt|;
break|break;
case|case
name|APR_DBM_RWCREATE
case|:
name|dbmode
operator|=
name|APR_DBM_DBMODE_RWCREATE
expr_stmt|;
break|break;
case|case
name|APR_DBM_RWTRUNC
case|:
name|dbmode
operator|=
name|APR_DBM_DBMODE_RWTRUNC
expr_stmt|;
break|break;
default|default:
return|return
name|APR_EINVAL
return|;
block|}
block|{
name|int
name|dberr
decl_stmt|;
if|#
directive|if
name|DB_VER
operator|>=
literal|3
if|if
condition|(
operator|(
name|dberr
operator|=
name|db_create
argument_list|(
operator|&
name|file
operator|.
name|bdb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dberr
operator|=
call|(
modifier|*
name|file
operator|.
name|bdb
operator|->
name|open
call|)
argument_list|(
name|file
operator|.
name|bdb
argument_list|,
if|#
directive|if
name|DB_VER
operator|==
literal|4
name|NULL
argument_list|,
endif|#
directive|endif
name|pathname
argument_list|,
name|NULL
argument_list|,
name|DB_HASH
argument_list|,
name|dbmode
argument_list|,
name|apr_posix_perms2mode
argument_list|(
name|perm
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* close the DB handler */
call|(
name|void
call|)
argument_list|(
operator|*
name|file
operator|.
name|bdb
operator|->
name|close
argument_list|)
argument_list|(
name|file
operator|.
name|bdb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|file
operator|.
name|curs
operator|=
name|NULL
expr_stmt|;
elif|#
directive|elif
name|DB_VER
operator|==
literal|2
name|dberr
operator|=
name|db_open
argument_list|(
name|pathname
argument_list|,
name|DB_HASH
argument_list|,
name|dbmode
argument_list|,
name|apr_posix_perms2mode
argument_list|(
name|perm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|file
operator|.
name|bdb
argument_list|)
expr_stmt|;
name|file
operator|.
name|curs
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|file
operator|.
name|bdb
operator|=
name|dbopen
argument_list|(
name|pathname
argument_list|,
name|dbmode
argument_list|,
name|apr_posix_perms2mode
argument_list|(
name|perm
argument_list|)
argument_list|,
name|DB_HASH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|bdb
operator|==
name|NULL
condition|)
return|return
name|APR_EGENERAL
return|;
comment|/* ### need a better error */
name|dberr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dberr
operator|!=
literal|0
condition|)
return|return
name|db2s
argument_list|(
name|dberr
argument_list|)
return|;
block|}
comment|/* we have an open database... return it */
operator|*
name|pdb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pdb
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pdb
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
operator|(
operator|*
name|pdb
operator|)
operator|->
name|type
operator|=
operator|&
name|apr_dbm_type_db
expr_stmt|;
operator|(
operator|*
name|pdb
operator|)
operator|->
name|file
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### register a cleanup to close the DBM? */
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vt_db_close
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|)
block|{
operator|(
operator|*
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
operator|->
name|close
operator|)
operator|(
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
if|#
directive|if
name|DB_VER
operator|!=
literal|1
operator|,
literal|0
endif|#
directive|endif
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|vt_db_fetch
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
name|key
parameter_list|,
name|apr_datum_t
modifier|*
name|pvalue
parameter_list|)
block|{
name|DBT
name|ckey
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DBT
name|rd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|dberr
decl_stmt|;
name|ckey
operator|.
name|data
operator|=
name|key
operator|.
name|dptr
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
name|dberr
operator|=
name|do_fetch
argument_list|(
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
argument_list|,
name|ckey
argument_list|,
name|rd
argument_list|)
expr_stmt|;
comment|/* "not found" is not an error. return zero'd value. */
if|if
condition|(
name|dberr
operator|==
if|#
directive|if
name|DB_VER
operator|==
literal|1
name|RET_SPECIAL
else|#
directive|else
name|DB_NOTFOUND
endif|#
directive|endif
condition|)
block|{
name|memset
argument_list|(
operator|&
name|rd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rd
argument_list|)
argument_list|)
expr_stmt|;
name|dberr
operator|=
literal|0
expr_stmt|;
block|}
name|pvalue
operator|->
name|dptr
operator|=
name|rd
operator|.
name|data
expr_stmt|;
name|pvalue
operator|->
name|dsize
operator|=
name|rd
operator|.
name|size
expr_stmt|;
comment|/* store the error info into DBM, and return a status code. Also, note        that *pvalue should have been cleared on error. */
return|return
name|set_error
argument_list|(
name|dbm
argument_list|,
name|db2s
argument_list|(
name|dberr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|vt_db_store
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
name|key
parameter_list|,
name|apr_datum_t
name|value
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|DBT
name|ckey
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DBT
name|cvalue
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ckey
operator|.
name|data
operator|=
name|key
operator|.
name|dptr
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
name|cvalue
operator|.
name|data
operator|=
name|value
operator|.
name|dptr
expr_stmt|;
name|cvalue
operator|.
name|size
operator|=
name|value
operator|.
name|dsize
expr_stmt|;
name|rv
operator|=
name|db2s
argument_list|(
operator|(
operator|*
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
operator|->
name|put
operator|)
operator|(
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
operator|,
name|TXN_ARG
operator|&
name|ckey
operator|,
operator|&
name|cvalue
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* store any error info into DBM, and return a status code. */
return|return
name|set_error
argument_list|(
name|dbm
argument_list|,
name|rv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|vt_db_del
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
name|key
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|DBT
name|ckey
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ckey
operator|.
name|data
operator|=
name|key
operator|.
name|dptr
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
name|rv
operator|=
name|db2s
argument_list|(
operator|(
operator|*
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
operator|->
name|del
operator|)
operator|(
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
operator|,
name|TXN_ARG
operator|&
name|ckey
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* store any error info into DBM, and return a status code. */
return|return
name|set_error
argument_list|(
name|dbm
argument_list|,
name|rv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vt_db_exists
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
name|key
parameter_list|)
block|{
name|DBT
name|ckey
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* converted key */
name|DBT
name|data
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|dberr
decl_stmt|;
name|ckey
operator|.
name|data
operator|=
name|key
operator|.
name|dptr
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
name|dberr
operator|=
name|do_fetch
argument_list|(
name|GET_BDB
argument_list|(
name|dbm
operator|->
name|file
argument_list|)
argument_list|,
name|ckey
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* note: the result data is "loaned" to us; we don't need to free it */
comment|/* DB returns DB_NOTFOUND if it doesn't exist. but we want to say        that *any* error means it doesn't exist. */
return|return
name|dberr
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|vt_db_firstkey
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
modifier|*
name|pkey
parameter_list|)
block|{
name|real_file_t
modifier|*
name|f
init|=
name|dbm
operator|->
name|file
decl_stmt|;
name|DBT
name|first
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DBT
name|data
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|dberr
decl_stmt|;
if|#
directive|if
name|DB_VER
operator|==
literal|1
name|dberr
operator|=
call|(
modifier|*
name|f
operator|->
name|bdb
operator|->
name|seq
call|)
argument_list|(
name|f
operator|->
name|bdb
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|data
argument_list|,
name|R_FIRST
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|dberr
operator|=
call|(
modifier|*
name|f
operator|->
name|bdb
operator|->
name|cursor
call|)
argument_list|(
name|f
operator|->
name|bdb
argument_list|,
name|NULL
argument_list|,
operator|&
name|f
operator|->
name|curs
if|#
directive|if
name|DB_VER
operator|>=
literal|3
operator|||
operator|(
operator|(
name|DB_VERSION_MAJOR
operator|==
literal|2
operator|)
operator|&&
operator|(
name|DB_VERSION_MINOR
operator|>
literal|5
operator|)
operator|)
argument_list|,
literal|0
endif|#
directive|endif
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dberr
operator|=
call|(
modifier|*
name|f
operator|->
name|curs
operator|->
name|c_get
call|)
argument_list|(
name|f
operator|->
name|curs
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|data
argument_list|,
name|DB_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|dberr
operator|==
name|DB_NOTFOUND
condition|)
block|{
name|memset
argument_list|(
operator|&
name|first
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
operator|->
name|curs
operator|->
name|c_close
call|)
argument_list|(
name|f
operator|->
name|curs
argument_list|)
expr_stmt|;
name|f
operator|->
name|curs
operator|=
name|NULL
expr_stmt|;
name|dberr
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|pkey
operator|->
name|dptr
operator|=
name|first
operator|.
name|data
expr_stmt|;
name|pkey
operator|->
name|dsize
operator|=
name|first
operator|.
name|size
expr_stmt|;
comment|/* store any error info into DBM, and return a status code. */
return|return
name|set_error
argument_list|(
name|dbm
argument_list|,
name|db2s
argument_list|(
name|dberr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|vt_db_nextkey
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
modifier|*
name|pkey
parameter_list|)
block|{
name|real_file_t
modifier|*
name|f
init|=
name|dbm
operator|->
name|file
decl_stmt|;
name|DBT
name|ckey
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DBT
name|data
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|dberr
decl_stmt|;
name|ckey
operator|.
name|data
operator|=
name|pkey
operator|->
name|dptr
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
name|pkey
operator|->
name|dsize
expr_stmt|;
if|#
directive|if
name|DB_VER
operator|==
literal|1
name|dberr
operator|=
call|(
modifier|*
name|f
operator|->
name|bdb
operator|->
name|seq
call|)
argument_list|(
name|f
operator|->
name|bdb
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|data
argument_list|,
name|R_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dberr
operator|==
name|RET_SPECIAL
condition|)
block|{
name|dberr
operator|=
literal|0
expr_stmt|;
name|ckey
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|f
operator|->
name|curs
operator|==
name|NULL
condition|)
return|return
name|APR_EINVAL
return|;
name|dberr
operator|=
call|(
modifier|*
name|f
operator|->
name|curs
operator|->
name|c_get
call|)
argument_list|(
name|f
operator|->
name|curs
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|data
argument_list|,
name|DB_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dberr
operator|==
name|DB_NOTFOUND
condition|)
block|{
call|(
modifier|*
name|f
operator|->
name|curs
operator|->
name|c_close
call|)
argument_list|(
name|f
operator|->
name|curs
argument_list|)
expr_stmt|;
name|f
operator|->
name|curs
operator|=
name|NULL
expr_stmt|;
name|dberr
operator|=
literal|0
expr_stmt|;
name|ckey
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|ckey
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|pkey
operator|->
name|dptr
operator|=
name|ckey
operator|.
name|data
expr_stmt|;
name|pkey
operator|->
name|dsize
operator|=
name|ckey
operator|.
name|size
expr_stmt|;
comment|/* store any error info into DBM, and return a status code. */
comment|/* ### or use db2s(dberr) instead of APR_SUCCESS? */
return|return
name|set_error
argument_list|(
name|dbm
argument_list|,
name|APR_SUCCESS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vt_db_freedatum
parameter_list|(
name|apr_dbm_t
modifier|*
name|dbm
parameter_list|,
name|apr_datum_t
name|data
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
specifier|static
name|void
name|vt_db_usednames
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|used1
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|used2
parameter_list|)
block|{
operator|*
name|used1
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
operator|*
name|used2
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|APU_MODULE_DECLARE_DATA
specifier|const
name|apr_dbm_type_t
name|apr_dbm_type_db
init|=
block|{
literal|"db"
block|,
name|vt_db_open
block|,
name|vt_db_close
block|,
name|vt_db_fetch
block|,
name|vt_db_store
block|,
name|vt_db_del
block|,
name|vt_db_exists
block|,
name|vt_db_firstkey
block|,
name|vt_db_nextkey
block|,
name|vt_db_freedatum
block|,
name|vt_db_usednames
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APU_HAVE_DB */
end_comment

end_unit

