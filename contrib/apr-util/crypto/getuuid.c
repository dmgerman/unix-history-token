begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * This attempts to generate V1 UUIDs according to the Internet Draft  * located at http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_uuid.h"
end_include

begin_include
include|#
directive|include
file|"apr_md5.h"
end_include

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_portable.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* for getpid, gethostname */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for rand, srand */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STRINGS_H
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_NETDB_H
end_if

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* for gettimeofday */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NODE_LENGTH
value|6
end_define

begin_decl_stmt
specifier|static
name|int
name|uuid_state_seqnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|uuid_state_node
index|[
name|NODE_LENGTH
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_random_info
parameter_list|(
name|unsigned
name|char
name|node
index|[
name|NODE_LENGTH
index|]
parameter_list|)
block|{
if|#
directive|if
name|APR_HAS_RANDOM
operator|(
name|void
operator|)
name|apr_generate_random_bytes
argument_list|(
name|node
argument_list|,
name|NODE_LENGTH
argument_list|)
expr_stmt|;
else|#
directive|else
name|unsigned
name|char
name|seed
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|apr_md5_ctx_t
name|c
decl_stmt|;
comment|/* ### probably should revise some of this to be a bit more portable */
comment|/* Leach& Salz use Linux-specific struct sysinfo;      * replace with pid/tid for portability (in the spirit of mod_unique_id) */
struct|struct
block|{
comment|/* Add thread id here, if applicable, when we get to pthread or apr */
name|pid_t
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|NETWARE
name|apr_uint64_t
name|t
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|t
decl_stmt|;
endif|#
directive|endif
name|char
name|hostname
index|[
literal|257
index|]
decl_stmt|;
block|}
name|r
struct|;
name|apr_md5_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETWARE
name|r
operator|.
name|pid
operator|=
name|NXThreadGetId
argument_list|()
expr_stmt|;
name|NXGetTime
argument_list|(
name|NX_SINCE_BOOT
argument_list|,
name|NX_USECONDS
argument_list|,
operator|&
operator|(
name|r
operator|.
name|t
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|r
operator|.
name|t
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gethostname
argument_list|(
name|r
operator|.
name|hostname
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|apr_md5_update
argument_list|(
operator|&
name|c
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|apr_md5_final
argument_list|(
name|seed
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|node
argument_list|,
name|seed
argument_list|,
name|NODE_LENGTH
argument_list|)
expr_stmt|;
comment|/* use a subset of the seed bytes */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This implementation generates a random node ID instead of a    system-dependent call to get IEEE node ID. This is also more secure:    we aren't passing out our MAC address. */
end_comment

begin_function
specifier|static
name|void
name|get_pseudo_node_identifier
parameter_list|(
name|unsigned
name|char
modifier|*
name|node
parameter_list|)
block|{
name|get_random_info
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
index|[
literal|0
index|]
operator||=
literal|0x01
expr_stmt|;
comment|/* this designates a random multicast node ID */
block|}
end_function

begin_function
specifier|static
name|void
name|get_system_time
parameter_list|(
name|apr_uint64_t
modifier|*
name|uuid_time
parameter_list|)
block|{
comment|/* ### fix this call to be more portable? */
operator|*
name|uuid_time
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
comment|/* Offset between UUID formatted times and Unix formatted times.        UUID UTC base time is October 15, 1582.        Unix base time is January 1, 1970.      */
operator|*
name|uuid_time
operator|=
operator|(
operator|*
name|uuid_time
operator|*
literal|10
operator|)
operator|+
name|APR_TIME_C
argument_list|(
literal|0x01B21DD213814000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* true_random -- generate a crypto-quality random number. */
end_comment

begin_function
specifier|static
name|int
name|true_random
parameter_list|(
name|void
parameter_list|)
block|{
name|apr_uint64_t
name|time_now
decl_stmt|;
if|#
directive|if
name|APR_HAS_RANDOM
name|unsigned
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|apr_generate_random_bytes
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
block|{
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|1
index|]
return|;
block|}
endif|#
directive|endif
comment|/* crap. this isn't crypto quality, but it will be Good Enough */
name|time_now
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
name|srand
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
operator|(
name|time_now
operator|>>
literal|32
operator|)
operator|^
name|time_now
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rand
argument_list|()
operator|&
literal|0x0FFFF
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_state
parameter_list|(
name|void
parameter_list|)
block|{
name|uuid_state_seqnum
operator|=
name|true_random
argument_list|()
expr_stmt|;
name|get_pseudo_node_identifier
argument_list|(
name|uuid_state_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_current_time
parameter_list|(
name|apr_uint64_t
modifier|*
name|timestamp
parameter_list|)
block|{
comment|/* ### this needs to be made thread-safe! */
name|apr_uint64_t
name|time_now
decl_stmt|;
specifier|static
name|apr_uint64_t
name|time_last
init|=
literal|0
decl_stmt|;
specifier|static
name|apr_uint64_t
name|fudge
init|=
literal|0
decl_stmt|;
name|get_system_time
argument_list|(
operator|&
name|time_now
argument_list|)
expr_stmt|;
comment|/* if clock reading changed since last UUID generated... */
if|if
condition|(
name|time_last
operator|!=
name|time_now
condition|)
block|{
comment|/* The clock reading has changed since the last UUID was generated.            Reset the fudge factor. if we are generating them too fast, then            the fudge may need to be reset to something greater than zero. */
if|if
condition|(
name|time_last
operator|+
name|fudge
operator|>
name|time_now
condition|)
name|fudge
operator|=
name|time_last
operator|+
name|fudge
operator|-
name|time_now
operator|+
literal|1
expr_stmt|;
else|else
name|fudge
operator|=
literal|0
expr_stmt|;
name|time_last
operator|=
name|time_now
expr_stmt|;
block|}
else|else
block|{
comment|/* We generated two really fast. Bump the fudge factor. */
operator|++
name|fudge
expr_stmt|;
block|}
operator|*
name|timestamp
operator|=
name|time_now
operator|+
name|fudge
expr_stmt|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_uuid_get
argument_list|(
argument|apr_uuid_t *uuid
argument_list|)
end_macro

begin_block
block|{
name|apr_uint64_t
name|timestamp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
init|=
name|uuid
operator|->
name|data
decl_stmt|;
if|#
directive|if
name|APR_HAS_OS_UUID
if|if
condition|(
name|apr_os_uuid_get
argument_list|(
name|d
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
comment|/* !APR_HAS_OS_UUID */
if|if
condition|(
operator|!
name|uuid_state_node
index|[
literal|0
index|]
condition|)
name|init_state
argument_list|()
expr_stmt|;
name|get_current_time
argument_list|(
operator|&
name|timestamp
argument_list|)
expr_stmt|;
comment|/* time_low, uint32 */
name|d
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|timestamp
expr_stmt|;
name|d
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|timestamp
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|timestamp
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|timestamp
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|/* time_mid, uint16 */
name|d
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|timestamp
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|d
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|timestamp
operator|>>
literal|40
argument_list|)
expr_stmt|;
comment|/* time_hi_and_version, uint16 */
name|d
index|[
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|timestamp
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|d
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
operator|(
name|timestamp
operator|>>
literal|56
operator|)
operator|&
literal|0x0F
operator|)
operator||
literal|0x10
argument_list|)
expr_stmt|;
comment|/* clock_seq_hi_and_reserved, uint8 */
name|d
index|[
literal|8
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
operator|(
name|uuid_state_seqnum
operator|>>
literal|8
operator|)
operator|&
literal|0x3F
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* clock_seq_low, uint8 */
name|d
index|[
literal|9
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|uuid_state_seqnum
expr_stmt|;
comment|/* node, byte[6] */
name|memcpy
argument_list|(
operator|&
name|d
index|[
literal|10
index|]
argument_list|,
name|uuid_state_node
argument_list|,
name|NODE_LENGTH
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

