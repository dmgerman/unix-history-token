begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_include
include|#
directive|include
file|"apu_config.h"
end_include

begin_include
include|#
directive|include
file|"apu_errno.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_include
include|#
directive|include
file|"apr_buckets.h"
end_include

begin_include
include|#
directive|include
file|"apr_crypto_internal.h"
end_include

begin_if
if|#
directive|if
name|APU_HAVE_CRYPTO
end_if

begin_include
include|#
directive|include
file|<prerror.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS_NSS_H
end_ifdef

begin_include
include|#
directive|include
file|<nss/nss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS_H
end_ifdef

begin_include
include|#
directive|include
file|<nss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSS_PK11PUB_H
end_ifdef

begin_include
include|#
directive|include
file|<nss/pk11pub.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PK11PUB_H
end_ifdef

begin_include
include|#
directive|include
file|<pk11pub.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|apr_crypto_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
decl_stmt|;
name|apu_err_t
modifier|*
name|result
decl_stmt|;
name|apr_array_header_t
modifier|*
name|keys
decl_stmt|;
name|apr_crypto_config_t
modifier|*
name|config
decl_stmt|;
name|apr_hash_t
modifier|*
name|types
decl_stmt|;
name|apr_hash_t
modifier|*
name|modes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_crypto_config_t
block|{
name|void
modifier|*
name|opaque
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_crypto_key_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
decl_stmt|;
specifier|const
name|apr_crypto_t
modifier|*
name|f
decl_stmt|;
name|CK_MECHANISM_TYPE
name|cipherMech
decl_stmt|;
name|SECOidTag
name|cipherOid
decl_stmt|;
name|PK11SymKey
modifier|*
name|symKey
decl_stmt|;
name|int
name|ivSize
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_crypto_block_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
decl_stmt|;
specifier|const
name|apr_crypto_t
modifier|*
name|f
decl_stmt|;
name|PK11Context
modifier|*
name|ctx
decl_stmt|;
name|apr_crypto_key_t
modifier|*
name|key
decl_stmt|;
name|int
name|blockSize
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|key_3des_192
init|=
name|APR_KEY_3DES_192
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_aes_128
init|=
name|APR_KEY_AES_128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_aes_192
init|=
name|APR_KEY_AES_192
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_aes_256
init|=
name|APR_KEY_AES_256
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mode_ecb
init|=
name|APR_MODE_ECB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mode_cbc
init|=
name|APR_MODE_CBC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Fetch the most recent error from this driver.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_error
parameter_list|(
specifier|const
name|apu_err_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|result
operator|=
name|f
operator|->
name|result
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Shutdown the crypto library and release resources.  *  * It is safe to shut down twice.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|NSS_IsInitialized
argument_list|()
condition|)
block|{
name|SECStatus
name|s
init|=
name|NSS_Shutdown
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
return|return
name|APR_EINIT
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|crypto_shutdown_helper
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|crypto_shutdown
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * Initialise the crypto library and perform one time initialisation.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
name|int
modifier|*
name|rc
parameter_list|)
block|{
name|SECStatus
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyPrefix
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|certPrefix
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|secmod
init|=
name|NULL
decl_stmt|;
name|int
name|noinit
init|=
literal|0
decl_stmt|;
name|PRUint32
name|flags
init|=
literal|0
decl_stmt|;
struct|struct
block|{
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|set
decl_stmt|;
block|}
name|fields
index|[]
init|=
block|{
block|{
literal|"dir"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"key3"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"cert7"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"secmod"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"noinit"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|klen
decl_stmt|;
name|char
modifier|*
modifier|*
name|elts
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|elt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|params
condition|)
block|{
if|if
condition|(
name|APR_SUCCESS
operator|!=
operator|(
name|status
operator|=
name|apr_tokenize_to_argv
argument_list|(
name|params
argument_list|,
operator|&
name|elts
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
while|while
condition|(
operator|(
name|elt
operator|=
name|elts
index|[
name|i
index|]
operator|)
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|elt
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
for|for
control|(
name|klen
operator|=
name|ptr
operator|-
name|elt
init|;
name|klen
operator|&&
name|apr_isspace
argument_list|(
name|elt
index|[
name|klen
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|klen
control|)
empty_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|klen
operator|=
name|strlen
argument_list|(
name|elt
argument_list|)
init|;
name|klen
operator|&&
name|apr_isspace
argument_list|(
name|elt
index|[
name|klen
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|klen
control|)
empty_stmt|;
block|}
name|elt
index|[
name|klen
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|fields
index|[
name|j
index|]
operator|.
name|field
operator|!=
name|NULL
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|klen
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|field
argument_list|,
name|elt
argument_list|)
condition|)
block|{
name|fields
index|[
name|j
index|]
operator|.
name|set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|fields
index|[
name|j
index|]
operator|.
name|value
operator|=
name|ptr
expr_stmt|;
block|}
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
name|dir
operator|=
name|fields
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|keyPrefix
operator|=
name|fields
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|certPrefix
operator|=
name|fields
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|secmod
operator|=
name|fields
index|[
literal|3
index|]
operator|.
name|value
expr_stmt|;
name|noinit
operator|=
name|fields
index|[
literal|4
index|]
operator|.
name|set
expr_stmt|;
block|}
comment|/* if we've been asked to bypass, do so here */
if|if
condition|(
name|noinit
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* sanity check - we can only initialise NSS once */
if|if
condition|(
name|NSS_IsInitialized
argument_list|()
condition|)
block|{
return|return
name|APR_EREINIT
return|;
block|}
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|pool
argument_list|,
name|crypto_shutdown_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyPrefix
operator|||
name|certPrefix
operator|||
name|secmod
condition|)
block|{
name|s
operator|=
name|NSS_Initialize
argument_list|(
name|dir
argument_list|,
name|certPrefix
argument_list|,
name|keyPrefix
argument_list|,
name|secmod
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
condition|)
block|{
name|s
operator|=
name|NSS_InitReadWrite
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|NSS_NoDB_Init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
if|if
condition|(
name|rc
condition|)
block|{
operator|*
name|rc
operator|=
name|PR_GetError
argument_list|()
expr_stmt|;
block|}
return|return
name|APR_ECRYPT
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Clean encryption / decryption context.  * @note After cleanup, a context is free to be reused if necessary.  * @param f The context to use.  * @return Returns APR_ENOTIMPL if not supported.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_cleanup
parameter_list|(
name|apr_crypto_block_t
modifier|*
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|->
name|ctx
condition|)
block|{
name|PK11_DestroyContext
argument_list|(
name|block
operator|->
name|ctx
argument_list|,
name|PR_TRUE
argument_list|)
expr_stmt|;
name|block
operator|->
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|crypto_block_cleanup_helper
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_crypto_block_t
modifier|*
name|block
init|=
operator|(
name|apr_crypto_block_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
name|crypto_block_cleanup
argument_list|(
name|block
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Clean encryption / decryption context.  * @note After cleanup, a context is free to be reused if necessary.  * @param f The context to use.  * @return Returns APR_ENOTIMPL if not supported.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_cleanup
parameter_list|(
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
name|apr_crypto_key_t
modifier|*
name|key
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|keys
condition|)
block|{
while|while
condition|(
operator|(
name|key
operator|=
name|apr_array_pop
argument_list|(
name|f
operator|->
name|keys
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|symKey
condition|)
block|{
name|PK11_FreeSymKey
argument_list|(
name|key
operator|->
name|symKey
argument_list|)
expr_stmt|;
name|key
operator|->
name|symKey
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|crypto_cleanup_helper
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_crypto_t
modifier|*
name|f
init|=
operator|(
name|apr_crypto_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
name|crypto_cleanup
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Create a context for supporting encryption. Keys, certificates,  *        algorithms and other parameters will be set per context. More than  *        one context can be created at one time. A cleanup will be automatically  *        registered with the given pool to guarantee a graceful shutdown.  * @param f - context pointer will be written here  * @param provider - provider to use  * @param params - parameter string  * @param pool - process pool  * @return APR_ENOENGINE when the engine specified does not exist. APR_EINITENGINE  * if the engine cannot be initialised.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_make
parameter_list|(
name|apr_crypto_t
modifier|*
modifier|*
name|ff
parameter_list|,
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_crypto_config_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|apr_crypto_t
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
operator|*
name|ff
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|f
operator|->
name|provider
operator|=
name|provider
expr_stmt|;
name|config
operator|=
name|f
operator|->
name|config
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|f
operator|->
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apu_err_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|result
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|f
operator|->
name|keys
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_key_t
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|types
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|types
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"3des192"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_3des_192
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"aes128"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_aes_128
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"aes192"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_aes_192
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"aes256"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_aes_256
operator|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|modes
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|modes
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_hash_set
argument_list|(
name|f
operator|->
name|modes
argument_list|,
literal|"ecb"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|mode_ecb
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|modes
argument_list|,
literal|"cbc"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|mode_cbc
operator|)
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|f
argument_list|,
name|crypto_cleanup_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Get a hash table of key types, keyed by the name of the type against  * an integer pointer constant.  *  * @param types - hashtable of key types keyed to constants.  * @param f - encryption context  * @return APR_SUCCESS for success  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_get_block_key_types
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|types
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|types
operator|=
name|f
operator|->
name|types
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Get a hash table of key modes, keyed by the name of the mode against  * an integer pointer constant.  *  * @param modes - hashtable of key modes keyed to constants.  * @param f - encryption context  * @return APR_SUCCESS for success  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_get_block_key_modes
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|modes
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|modes
operator|=
name|f
operator|->
name|modes
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Create a key from the given passphrase. By default, the PBKDF2  *        algorithm is used to generate the key from the passphrase. It is expected  *        that the same pass phrase will generate the same key, regardless of the  *        backend crypto platform used. The key is cleaned up when the context  *        is cleaned, and may be reused with multiple encryption or decryption  *        operations.  * @note If *key is NULL, a apr_crypto_key_t will be created from a pool. If  *       *key is not NULL, *key must point at a previously created structure.  * @param key The key returned, see note.  * @param ivSize The size of the initialisation vector will be returned, based  *               on whether an IV is relevant for this type of crypto.  * @param pass The passphrase to use.  * @param passLen The passphrase length in bytes  * @param salt The salt to use.  * @param saltLen The salt length in bytes  * @param type 3DES_192, AES_128, AES_192, AES_256.  * @param mode Electronic Code Book / Cipher Block Chaining.  * @param doPad Pad if necessary.  * @param iterations Iteration count  * @param f The context to use.  * @param p The pool to use.  * @return Returns APR_ENOKEY if the pass phrase is missing or empty, or if a backend  *         error occurred while generating the key. APR_ENOCIPHER if the type or mode  *         is not supported by the particular backend. APR_EKEYTYPE if the key type is  *         not known. APR_EPADDING if padding was requested but is not supported.  *         APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_passphrase
parameter_list|(
name|apr_crypto_key_t
modifier|*
modifier|*
name|k
parameter_list|,
name|apr_size_t
modifier|*
name|ivSize
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|,
name|apr_size_t
name|passLen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|salt
parameter_list|,
name|apr_size_t
name|saltLen
parameter_list|,
specifier|const
name|apr_crypto_block_key_type_e
name|type
parameter_list|,
specifier|const
name|apr_crypto_block_key_mode_e
name|mode
parameter_list|,
specifier|const
name|int
name|doPad
parameter_list|,
specifier|const
name|int
name|iterations
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|PK11SlotInfo
modifier|*
name|slot
decl_stmt|;
name|SECItem
name|passItem
decl_stmt|;
name|SECItem
name|saltItem
decl_stmt|;
name|SECAlgorithmID
modifier|*
name|algid
decl_stmt|;
name|void
modifier|*
name|wincx
init|=
name|NULL
decl_stmt|;
comment|/* what is wincx? */
name|apr_crypto_key_t
modifier|*
name|key
init|=
operator|*
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
operator|*
name|k
operator|=
name|key
operator|=
name|apr_array_push
argument_list|(
name|f
operator|->
name|keys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|key
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|key
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|key
operator|->
name|provider
operator|=
name|f
operator|->
name|provider
expr_stmt|;
comment|/* decide on what cipher mechanism we will be using */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
operator|(
name|APR_KEY_3DES_192
operator|)
case|:
if|if
condition|(
name|APR_MODE_CBC
operator|==
name|mode
condition|)
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_DES_EDE3_CBC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|APR_MODE_ECB
operator|==
name|mode
condition|)
block|{
return|return
name|APR_ENOCIPHER
return|;
comment|/* No OID for CKM_DES3_ECB; */
block|}
break|break;
case|case
operator|(
name|APR_KEY_AES_128
operator|)
case|:
if|if
condition|(
name|APR_MODE_CBC
operator|==
name|mode
condition|)
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_AES_128_CBC
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_AES_128_ECB
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|APR_KEY_AES_192
operator|)
case|:
if|if
condition|(
name|APR_MODE_CBC
operator|==
name|mode
condition|)
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_AES_192_CBC
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_AES_192_ECB
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|APR_KEY_AES_256
operator|)
case|:
if|if
condition|(
name|APR_MODE_CBC
operator|==
name|mode
condition|)
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_AES_256_CBC
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipherOid
operator|=
name|SEC_OID_AES_256_ECB
expr_stmt|;
block|}
break|break;
default|default:
comment|/* unknown key type, give up */
return|return
name|APR_EKEYTYPE
return|;
block|}
comment|/* AES_128_CBC --> CKM_AES_CBC --> CKM_AES_CBC_PAD */
name|key
operator|->
name|cipherMech
operator|=
name|PK11_AlgtagToMechanism
argument_list|(
name|key
operator|->
name|cipherOid
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|cipherMech
operator|==
name|CKM_INVALID_MECHANISM
condition|)
block|{
return|return
name|APR_ENOCIPHER
return|;
block|}
if|if
condition|(
name|doPad
condition|)
block|{
name|CK_MECHANISM_TYPE
name|paddedMech
decl_stmt|;
name|paddedMech
operator|=
name|PK11_GetPadMechanism
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|)
expr_stmt|;
if|if
condition|(
name|CKM_INVALID_MECHANISM
operator|==
name|paddedMech
operator|||
name|key
operator|->
name|cipherMech
operator|==
name|paddedMech
condition|)
block|{
return|return
name|APR_EPADDING
return|;
block|}
name|key
operator|->
name|cipherMech
operator|=
name|paddedMech
expr_stmt|;
block|}
comment|/* Turn the raw passphrase and salt into SECItems */
name|passItem
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pass
expr_stmt|;
name|passItem
operator|.
name|len
operator|=
name|passLen
expr_stmt|;
name|saltItem
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|salt
expr_stmt|;
name|saltItem
operator|.
name|len
operator|=
name|saltLen
expr_stmt|;
comment|/* generate the key */
comment|/* pbeAlg and cipherAlg are the same. NSS decides the keylength. */
name|algid
operator|=
name|PK11_CreatePBEV2AlgorithmID
argument_list|(
name|key
operator|->
name|cipherOid
argument_list|,
name|key
operator|->
name|cipherOid
argument_list|,
name|SEC_OID_HMAC_SHA1
argument_list|,
literal|0
argument_list|,
name|iterations
argument_list|,
operator|&
name|saltItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|algid
condition|)
block|{
name|slot
operator|=
name|PK11_GetBestSlot
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|wincx
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
block|{
name|key
operator|->
name|symKey
operator|=
name|PK11_PBEKeyGen
argument_list|(
name|slot
argument_list|,
name|algid
argument_list|,
operator|&
name|passItem
argument_list|,
name|PR_FALSE
argument_list|,
name|wincx
argument_list|)
expr_stmt|;
name|PK11_FreeSlot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|SECOID_DestroyAlgorithmID
argument_list|(
name|algid
argument_list|,
name|PR_TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* sanity check? */
if|if
condition|(
operator|!
name|key
operator|->
name|symKey
condition|)
block|{
name|PRErrorCode
name|perr
init|=
name|PORT_GetError
argument_list|()
decl_stmt|;
if|if
condition|(
name|perr
condition|)
block|{
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|APR_ENOKEY
expr_stmt|;
block|}
block|}
name|key
operator|->
name|ivSize
operator|=
name|PK11_GetIVLength
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivSize
condition|)
block|{
operator|*
name|ivSize
operator|=
name|key
operator|->
name|ivSize
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Initialise a context for encrypting arbitrary data using the given key.  * @note If *ctx is NULL, a apr_crypto_block_t will be created from a pool. If  *       *ctx is not NULL, *ctx must point at a previously created structure.  * @param ctx The block context returned, see note.  * @param iv Optional initialisation vector. If the buffer pointed to is NULL,  *           an IV will be created at random, in space allocated from the pool.  *           If the buffer pointed to is not NULL, the IV in the buffer will be  *           used.  * @param key The key structure.  * @param blockSize The block size of the cipher.  * @param p The pool to use.  * @return Returns APR_ENOIV if an initialisation vector is required but not specified.  *         Returns APR_EINIT if the backend failed to initialise the context. Returns  *         APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_encrypt_init
parameter_list|(
name|apr_crypto_block_t
modifier|*
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|iv
parameter_list|,
specifier|const
name|apr_crypto_key_t
modifier|*
name|key
parameter_list|,
name|apr_size_t
modifier|*
name|blockSize
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|PRErrorCode
name|perr
decl_stmt|;
name|SECItem
modifier|*
name|secParam
decl_stmt|;
name|SECItem
name|ivItem
decl_stmt|;
name|unsigned
name|char
modifier|*
name|usedIv
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block
init|=
operator|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
block|{
operator|*
name|ctx
operator|=
name|block
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_block_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|block
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|block
operator|->
name|f
operator|=
name|key
operator|->
name|f
expr_stmt|;
name|block
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|block
operator|->
name|provider
operator|=
name|key
operator|->
name|provider
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
name|crypto_block_cleanup_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|ivSize
condition|)
block|{
if|if
condition|(
name|iv
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOIV
return|;
block|}
if|if
condition|(
operator|*
name|iv
operator|==
name|NULL
condition|)
block|{
name|SECStatus
name|s
decl_stmt|;
name|usedIv
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
name|key
operator|->
name|ivSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|usedIv
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|p
argument_list|,
name|usedIv
argument_list|,
name|key
operator|->
name|ivSize
argument_list|)
expr_stmt|;
name|s
operator|=
name|PK11_GenerateRandom
argument_list|(
name|usedIv
argument_list|,
name|key
operator|->
name|ivSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
return|return
name|APR_ENOIV
return|;
block|}
operator|*
name|iv
operator|=
name|usedIv
expr_stmt|;
block|}
else|else
block|{
name|usedIv
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|iv
expr_stmt|;
block|}
name|ivItem
operator|.
name|data
operator|=
name|usedIv
expr_stmt|;
name|ivItem
operator|.
name|len
operator|=
name|key
operator|->
name|ivSize
expr_stmt|;
name|secParam
operator|=
name|PK11_ParamFromIV
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
operator|&
name|ivItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|secParam
operator|=
name|PK11_GenerateNewParam
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|key
operator|->
name|symKey
argument_list|)
expr_stmt|;
block|}
name|block
operator|->
name|blockSize
operator|=
name|PK11_GetBlockSize
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|secParam
argument_list|)
expr_stmt|;
name|block
operator|->
name|ctx
operator|=
name|PK11_CreateContextBySymKey
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|CKA_ENCRYPT
argument_list|,
name|key
operator|->
name|symKey
argument_list|,
name|secParam
argument_list|)
expr_stmt|;
comment|/* did an error occur? */
name|perr
operator|=
name|PORT_GetError
argument_list|()
expr_stmt|;
if|if
condition|(
name|perr
operator|||
operator|!
name|block
operator|->
name|ctx
condition|)
block|{
name|key
operator|->
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|key
operator|->
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
return|return
name|APR_EINIT
return|;
block|}
if|if
condition|(
name|blockSize
condition|)
block|{
operator|*
name|blockSize
operator|=
name|PK11_GetBlockSize
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|secParam
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Encrypt data provided by in, write it to out.  * @note The number of bytes written will be written to outlen. If  *       out is NULL, outlen will contain the maximum size of the  *       buffer needed to hold the data, including any data  *       generated by apr_crypto_block_encrypt_finish below. If *out points  *       to NULL, a buffer sufficiently large will be created from  *       the pool provided. If *out points to a not-NULL value, this  *       value will be used as a buffer instead.  * @param out Address of a buffer to which data will be written,  *        see note.  * @param outlen Length of the output will be written here.  * @param in Address of the buffer to read.  * @param inlen Length of the buffer to read.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred. Returns APR_ENOTIMPL if  *         not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_encrypt
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|apr_size_t
name|inlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|block
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|outl
init|=
operator|(
name|int
operator|)
operator|*
name|outlen
decl_stmt|;
name|SECStatus
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
operator|*
name|outlen
operator|=
name|inlen
operator|+
name|block
operator|->
name|blockSize
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|out
condition|)
block|{
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|block
operator|->
name|pool
argument_list|,
name|inlen
operator|+
name|block
operator|->
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|block
operator|->
name|pool
argument_list|,
name|buffer
argument_list|,
name|inlen
operator|+
name|block
operator|->
name|blockSize
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|buffer
expr_stmt|;
block|}
name|s
operator|=
name|PK11_CipherOp
argument_list|(
name|block
operator|->
name|ctx
argument_list|,
operator|*
name|out
argument_list|,
operator|&
name|outl
argument_list|,
name|inlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
name|PRErrorCode
name|perr
init|=
name|PORT_GetError
argument_list|()
decl_stmt|;
if|if
condition|(
name|perr
condition|)
block|{
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_ECRYPT
return|;
block|}
operator|*
name|outlen
operator|=
name|outl
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Encrypt final data block, write it to out.  * @note If necessary the final block will be written out after being  *       padded. Typically the final block will be written to the  *       same buffer used by apr_crypto_block_encrypt, offset by the  *       number of bytes returned as actually written by the  *       apr_crypto_block_encrypt() call. After this call, the context  *       is cleaned and can be reused by apr_crypto_block_encrypt_init().  * @param out Address of a buffer to which data will be written. This  *            buffer must already exist, and is usually the same  *            buffer used by apr_evp_crypt(). See note.  * @param outlen Length of the output will be written here.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred.  * @return APR_EPADDING if padding was enabled and the block was incorrectly  *         formatted.  * @return APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_encrypt_finish
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|block
parameter_list|)
block|{
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|outl
init|=
operator|*
name|outlen
decl_stmt|;
name|SECStatus
name|s
init|=
name|PK11_DigestFinal
argument_list|(
name|block
operator|->
name|ctx
argument_list|,
name|out
argument_list|,
operator|&
name|outl
argument_list|,
name|block
operator|->
name|blockSize
argument_list|)
decl_stmt|;
operator|*
name|outlen
operator|=
name|outl
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
name|PRErrorCode
name|perr
init|=
name|PORT_GetError
argument_list|()
decl_stmt|;
if|if
condition|(
name|perr
condition|)
block|{
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|APR_ECRYPT
expr_stmt|;
block|}
name|crypto_block_cleanup
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Initialise a context for decrypting arbitrary data using the given key.  * @note If *ctx is NULL, a apr_crypto_block_t will be created from a pool. If  *       *ctx is not NULL, *ctx must point at a previously created structure.  * @param ctx The block context returned, see note.  * @param blockSize The block size of the cipher.  * @param iv Optional initialisation vector. If the buffer pointed to is NULL,  *           an IV will be created at random, in space allocated from the pool.  *           If the buffer is not NULL, the IV in the buffer will be used.  * @param key The key structure.  * @param p The pool to use.  * @return Returns APR_ENOIV if an initialisation vector is required but not specified.  *         Returns APR_EINIT if the backend failed to initialise the context. Returns  *         APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_decrypt_init
parameter_list|(
name|apr_crypto_block_t
modifier|*
modifier|*
name|ctx
parameter_list|,
name|apr_size_t
modifier|*
name|blockSize
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
specifier|const
name|apr_crypto_key_t
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|PRErrorCode
name|perr
decl_stmt|;
name|SECItem
modifier|*
name|secParam
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block
init|=
operator|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
block|{
operator|*
name|ctx
operator|=
name|block
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_block_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|block
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|block
operator|->
name|f
operator|=
name|key
operator|->
name|f
expr_stmt|;
name|block
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|block
operator|->
name|provider
operator|=
name|key
operator|->
name|provider
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
name|crypto_block_cleanup_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|ivSize
condition|)
block|{
name|SECItem
name|ivItem
decl_stmt|;
if|if
condition|(
name|iv
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOIV
return|;
comment|/* Cannot initialise without an IV */
block|}
name|ivItem
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|iv
expr_stmt|;
name|ivItem
operator|.
name|len
operator|=
name|key
operator|->
name|ivSize
expr_stmt|;
name|secParam
operator|=
name|PK11_ParamFromIV
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
operator|&
name|ivItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|secParam
operator|=
name|PK11_GenerateNewParam
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|key
operator|->
name|symKey
argument_list|)
expr_stmt|;
block|}
name|block
operator|->
name|blockSize
operator|=
name|PK11_GetBlockSize
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|secParam
argument_list|)
expr_stmt|;
name|block
operator|->
name|ctx
operator|=
name|PK11_CreateContextBySymKey
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|CKA_DECRYPT
argument_list|,
name|key
operator|->
name|symKey
argument_list|,
name|secParam
argument_list|)
expr_stmt|;
comment|/* did an error occur? */
name|perr
operator|=
name|PORT_GetError
argument_list|()
expr_stmt|;
if|if
condition|(
name|perr
operator|||
operator|!
name|block
operator|->
name|ctx
condition|)
block|{
name|key
operator|->
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|key
operator|->
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
return|return
name|APR_EINIT
return|;
block|}
if|if
condition|(
name|blockSize
condition|)
block|{
operator|*
name|blockSize
operator|=
name|PK11_GetBlockSize
argument_list|(
name|key
operator|->
name|cipherMech
argument_list|,
name|secParam
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Decrypt data provided by in, write it to out.  * @note The number of bytes written will be written to outlen. If  *       out is NULL, outlen will contain the maximum size of the  *       buffer needed to hold the data, including any data  *       generated by apr_crypto_block_decrypt_finish below. If *out points  *       to NULL, a buffer sufficiently large will be created from  *       the pool provided. If *out points to a not-NULL value, this  *       value will be used as a buffer instead.  * @param out Address of a buffer to which data will be written,  *        see note.  * @param outlen Length of the output will be written here.  * @param in Address of the buffer to read.  * @param inlen Length of the buffer to read.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred. Returns APR_ENOTIMPL if  *         not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_decrypt
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|apr_size_t
name|inlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|block
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|outl
init|=
operator|(
name|int
operator|)
operator|*
name|outlen
decl_stmt|;
name|SECStatus
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
operator|*
name|outlen
operator|=
name|inlen
operator|+
name|block
operator|->
name|blockSize
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|out
condition|)
block|{
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|block
operator|->
name|pool
argument_list|,
name|inlen
operator|+
name|block
operator|->
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|block
operator|->
name|pool
argument_list|,
name|buffer
argument_list|,
name|inlen
operator|+
name|block
operator|->
name|blockSize
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|buffer
expr_stmt|;
block|}
name|s
operator|=
name|PK11_CipherOp
argument_list|(
name|block
operator|->
name|ctx
argument_list|,
operator|*
name|out
argument_list|,
operator|&
name|outl
argument_list|,
name|inlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
name|PRErrorCode
name|perr
init|=
name|PORT_GetError
argument_list|()
decl_stmt|;
if|if
condition|(
name|perr
condition|)
block|{
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_ECRYPT
return|;
block|}
operator|*
name|outlen
operator|=
name|outl
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Decrypt final data block, write it to out.  * @note If necessary the final block will be written out after being  *       padded. Typically the final block will be written to the  *       same buffer used by apr_crypto_block_decrypt, offset by the  *       number of bytes returned as actually written by the  *       apr_crypto_block_decrypt() call. After this call, the context  *       is cleaned and can be reused by apr_crypto_block_decrypt_init().  * @param out Address of a buffer to which data will be written. This  *            buffer must already exist, and is usually the same  *            buffer used by apr_evp_crypt(). See note.  * @param outlen Length of the output will be written here.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred.  * @return APR_EPADDING if padding was enabled and the block was incorrectly  *         formatted.  * @return APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_decrypt_finish
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|block
parameter_list|)
block|{
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|outl
init|=
operator|*
name|outlen
decl_stmt|;
name|SECStatus
name|s
init|=
name|PK11_DigestFinal
argument_list|(
name|block
operator|->
name|ctx
argument_list|,
name|out
argument_list|,
operator|&
name|outl
argument_list|,
name|block
operator|->
name|blockSize
argument_list|)
decl_stmt|;
operator|*
name|outlen
operator|=
name|outl
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SECSuccess
condition|)
block|{
name|PRErrorCode
name|perr
init|=
name|PORT_GetError
argument_list|()
decl_stmt|;
if|if
condition|(
name|perr
condition|)
block|{
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|rc
operator|=
name|perr
expr_stmt|;
name|block
operator|->
name|f
operator|->
name|result
operator|->
name|msg
operator|=
name|PR_ErrorToName
argument_list|(
name|perr
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|APR_ECRYPT
expr_stmt|;
block|}
name|crypto_block_cleanup
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/**  * NSS module.  */
end_comment

begin_decl_stmt
name|APU_MODULE_DECLARE_DATA
specifier|const
name|apr_crypto_driver_t
name|apr_crypto_nss_driver
init|=
block|{
literal|"nss"
block|,
name|crypto_init
block|,
name|crypto_make
block|,
name|crypto_get_block_key_types
block|,
name|crypto_get_block_key_modes
block|,
name|crypto_passphrase
block|,
name|crypto_block_encrypt_init
block|,
name|crypto_block_encrypt
block|,
name|crypto_block_encrypt_finish
block|,
name|crypto_block_decrypt_init
block|,
name|crypto_block_decrypt
block|,
name|crypto_block_decrypt_finish
block|,
name|crypto_block_cleanup
block|,
name|crypto_cleanup
block|,
name|crypto_shutdown
block|,
name|crypto_error
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

