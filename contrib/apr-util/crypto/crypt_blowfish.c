begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The crypt_blowfish homepage is:  *  *	http://www.openwall.com/crypt/  *  * This code comes from John the Ripper password cracker, with reentrant  * and crypt(3) interfaces added, but optimizations specific to password  * cracking removed.  *  * Written by Solar Designer<solar at openwall.com> in 1998-2011.  * No copyright is claimed, and the software is hereby placed in the public  * domain.  In case this attempt to disclaim copyright and place the software  * in the public domain is deemed null and void, then the software is  * Copyright (c) 1998-2011 Solar Designer and it is hereby released to the  * general public under the following terms:  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted.  *  * There's ABSOLUTELY NO WARRANTY, express or implied.  *  * It is my intent that you should be able to use this on your system,  * as part of a software package, or anywhere else to improve security,  * ensure compatibility, or for any other purpose.  I would appreciate  * it if you give credit where it is due and keep your modifications in  * the public domain as well, but I don't require that in order to let  * you place this code and any modifications you make under a license  * of your choice.  *  * This implementation is mostly compatible with OpenBSD's bcrypt.c (prefix  * "$2a$") by Niels Provos<provos at citi.umich.edu>, and uses some of his  * ideas.  The password hashing algorithm was designed by David Mazieres  *<dm at lcs.mit.edu>.  For more information on the level of compatibility,  * prefer refer to the comments in BF_set_key() below and to the included  * crypt(3) man page.  *  * There's a paper on the algorithm that explains its design decisions:  *  *	http://www.usenix.org/events/usenix99/provos.html  *  * Some of the tricks in BF_ROUND might be inspired by Eric Young's  * Blowfish library (I can't be sure if I would think of something if I  * hadn't seen his code).  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__set_errno
end_ifndef

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|val
parameter_list|)
value|errno = (val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Just to make sure the prototypes match the actual definitions */
end_comment

begin_include
include|#
directive|include
file|"crypt_blowfish.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|BF_ASM
value|0
end_define

begin_define
define|#
directive|define
name|BF_SCALE
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|||
name|defined
argument_list|(
name|__hppa__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|BF_ASM
value|0
end_define

begin_define
define|#
directive|define
name|BF_SCALE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BF_ASM
value|0
end_define

begin_define
define|#
directive|define
name|BF_SCALE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|int
name|BF_word
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|int
name|BF_word_signed
typedef|;
end_typedef

begin_comment
comment|/* Number of Blowfish rounds, this is also hardcoded into a few places */
end_comment

begin_define
define|#
directive|define
name|BF_N
value|16
end_define

begin_typedef
typedef|typedef
name|BF_word
name|BF_key
index|[
name|BF_N
operator|+
literal|2
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BF_word
name|S
index|[
literal|4
index|]
index|[
literal|0x100
index|]
decl_stmt|;
name|BF_key
name|P
decl_stmt|;
block|}
name|BF_ctx
typedef|;
end_typedef

begin_comment
comment|/*  * Magic IV for 64 Blowfish encryptions that we do at the end.  * The string is "OrpheanBeholderScryDoubt" on big-endian.  */
end_comment

begin_decl_stmt
specifier|static
name|BF_word
name|BF_magic_w
index|[
literal|6
index|]
init|=
block|{
literal|0x4F727068
block|,
literal|0x65616E42
block|,
literal|0x65686F6C
block|,
literal|0x64657253
block|,
literal|0x63727944
block|,
literal|0x6F756274
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * P-box and S-box tables initialized with digits of Pi.  */
end_comment

begin_decl_stmt
specifier|static
name|BF_ctx
name|BF_init_state
init|=
block|{
block|{
block|{
literal|0xd1310ba6
block|,
literal|0x98dfb5ac
block|,
literal|0x2ffd72db
block|,
literal|0xd01adfb7
block|,
literal|0xb8e1afed
block|,
literal|0x6a267e96
block|,
literal|0xba7c9045
block|,
literal|0xf12c7f99
block|,
literal|0x24a19947
block|,
literal|0xb3916cf7
block|,
literal|0x0801f2e2
block|,
literal|0x858efc16
block|,
literal|0x636920d8
block|,
literal|0x71574e69
block|,
literal|0xa458fea3
block|,
literal|0xf4933d7e
block|,
literal|0x0d95748f
block|,
literal|0x728eb658
block|,
literal|0x718bcd58
block|,
literal|0x82154aee
block|,
literal|0x7b54a41d
block|,
literal|0xc25a59b5
block|,
literal|0x9c30d539
block|,
literal|0x2af26013
block|,
literal|0xc5d1b023
block|,
literal|0x286085f0
block|,
literal|0xca417918
block|,
literal|0xb8db38ef
block|,
literal|0x8e79dcb0
block|,
literal|0x603a180e
block|,
literal|0x6c9e0e8b
block|,
literal|0xb01e8a3e
block|,
literal|0xd71577c1
block|,
literal|0xbd314b27
block|,
literal|0x78af2fda
block|,
literal|0x55605c60
block|,
literal|0xe65525f3
block|,
literal|0xaa55ab94
block|,
literal|0x57489862
block|,
literal|0x63e81440
block|,
literal|0x55ca396a
block|,
literal|0x2aab10b6
block|,
literal|0xb4cc5c34
block|,
literal|0x1141e8ce
block|,
literal|0xa15486af
block|,
literal|0x7c72e993
block|,
literal|0xb3ee1411
block|,
literal|0x636fbc2a
block|,
literal|0x2ba9c55d
block|,
literal|0x741831f6
block|,
literal|0xce5c3e16
block|,
literal|0x9b87931e
block|,
literal|0xafd6ba33
block|,
literal|0x6c24cf5c
block|,
literal|0x7a325381
block|,
literal|0x28958677
block|,
literal|0x3b8f4898
block|,
literal|0x6b4bb9af
block|,
literal|0xc4bfe81b
block|,
literal|0x66282193
block|,
literal|0x61d809cc
block|,
literal|0xfb21a991
block|,
literal|0x487cac60
block|,
literal|0x5dec8032
block|,
literal|0xef845d5d
block|,
literal|0xe98575b1
block|,
literal|0xdc262302
block|,
literal|0xeb651b88
block|,
literal|0x23893e81
block|,
literal|0xd396acc5
block|,
literal|0x0f6d6ff3
block|,
literal|0x83f44239
block|,
literal|0x2e0b4482
block|,
literal|0xa4842004
block|,
literal|0x69c8f04a
block|,
literal|0x9e1f9b5e
block|,
literal|0x21c66842
block|,
literal|0xf6e96c9a
block|,
literal|0x670c9c61
block|,
literal|0xabd388f0
block|,
literal|0x6a51a0d2
block|,
literal|0xd8542f68
block|,
literal|0x960fa728
block|,
literal|0xab5133a3
block|,
literal|0x6eef0b6c
block|,
literal|0x137a3be4
block|,
literal|0xba3bf050
block|,
literal|0x7efb2a98
block|,
literal|0xa1f1651d
block|,
literal|0x39af0176
block|,
literal|0x66ca593e
block|,
literal|0x82430e88
block|,
literal|0x8cee8619
block|,
literal|0x456f9fb4
block|,
literal|0x7d84a5c3
block|,
literal|0x3b8b5ebe
block|,
literal|0xe06f75d8
block|,
literal|0x85c12073
block|,
literal|0x401a449f
block|,
literal|0x56c16aa6
block|,
literal|0x4ed3aa62
block|,
literal|0x363f7706
block|,
literal|0x1bfedf72
block|,
literal|0x429b023d
block|,
literal|0x37d0d724
block|,
literal|0xd00a1248
block|,
literal|0xdb0fead3
block|,
literal|0x49f1c09b
block|,
literal|0x075372c9
block|,
literal|0x80991b7b
block|,
literal|0x25d479d8
block|,
literal|0xf6e8def7
block|,
literal|0xe3fe501a
block|,
literal|0xb6794c3b
block|,
literal|0x976ce0bd
block|,
literal|0x04c006ba
block|,
literal|0xc1a94fb6
block|,
literal|0x409f60c4
block|,
literal|0x5e5c9ec2
block|,
literal|0x196a2463
block|,
literal|0x68fb6faf
block|,
literal|0x3e6c53b5
block|,
literal|0x1339b2eb
block|,
literal|0x3b52ec6f
block|,
literal|0x6dfc511f
block|,
literal|0x9b30952c
block|,
literal|0xcc814544
block|,
literal|0xaf5ebd09
block|,
literal|0xbee3d004
block|,
literal|0xde334afd
block|,
literal|0x660f2807
block|,
literal|0x192e4bb3
block|,
literal|0xc0cba857
block|,
literal|0x45c8740f
block|,
literal|0xd20b5f39
block|,
literal|0xb9d3fbdb
block|,
literal|0x5579c0bd
block|,
literal|0x1a60320a
block|,
literal|0xd6a100c6
block|,
literal|0x402c7279
block|,
literal|0x679f25fe
block|,
literal|0xfb1fa3cc
block|,
literal|0x8ea5e9f8
block|,
literal|0xdb3222f8
block|,
literal|0x3c7516df
block|,
literal|0xfd616b15
block|,
literal|0x2f501ec8
block|,
literal|0xad0552ab
block|,
literal|0x323db5fa
block|,
literal|0xfd238760
block|,
literal|0x53317b48
block|,
literal|0x3e00df82
block|,
literal|0x9e5c57bb
block|,
literal|0xca6f8ca0
block|,
literal|0x1a87562e
block|,
literal|0xdf1769db
block|,
literal|0xd542a8f6
block|,
literal|0x287effc3
block|,
literal|0xac6732c6
block|,
literal|0x8c4f5573
block|,
literal|0x695b27b0
block|,
literal|0xbbca58c8
block|,
literal|0xe1ffa35d
block|,
literal|0xb8f011a0
block|,
literal|0x10fa3d98
block|,
literal|0xfd2183b8
block|,
literal|0x4afcb56c
block|,
literal|0x2dd1d35b
block|,
literal|0x9a53e479
block|,
literal|0xb6f84565
block|,
literal|0xd28e49bc
block|,
literal|0x4bfb9790
block|,
literal|0xe1ddf2da
block|,
literal|0xa4cb7e33
block|,
literal|0x62fb1341
block|,
literal|0xcee4c6e8
block|,
literal|0xef20cada
block|,
literal|0x36774c01
block|,
literal|0xd07e9efe
block|,
literal|0x2bf11fb4
block|,
literal|0x95dbda4d
block|,
literal|0xae909198
block|,
literal|0xeaad8e71
block|,
literal|0x6b93d5a0
block|,
literal|0xd08ed1d0
block|,
literal|0xafc725e0
block|,
literal|0x8e3c5b2f
block|,
literal|0x8e7594b7
block|,
literal|0x8ff6e2fb
block|,
literal|0xf2122b64
block|,
literal|0x8888b812
block|,
literal|0x900df01c
block|,
literal|0x4fad5ea0
block|,
literal|0x688fc31c
block|,
literal|0xd1cff191
block|,
literal|0xb3a8c1ad
block|,
literal|0x2f2f2218
block|,
literal|0xbe0e1777
block|,
literal|0xea752dfe
block|,
literal|0x8b021fa1
block|,
literal|0xe5a0cc0f
block|,
literal|0xb56f74e8
block|,
literal|0x18acf3d6
block|,
literal|0xce89e299
block|,
literal|0xb4a84fe0
block|,
literal|0xfd13e0b7
block|,
literal|0x7cc43b81
block|,
literal|0xd2ada8d9
block|,
literal|0x165fa266
block|,
literal|0x80957705
block|,
literal|0x93cc7314
block|,
literal|0x211a1477
block|,
literal|0xe6ad2065
block|,
literal|0x77b5fa86
block|,
literal|0xc75442f5
block|,
literal|0xfb9d35cf
block|,
literal|0xebcdaf0c
block|,
literal|0x7b3e89a0
block|,
literal|0xd6411bd3
block|,
literal|0xae1e7e49
block|,
literal|0x00250e2d
block|,
literal|0x2071b35e
block|,
literal|0x226800bb
block|,
literal|0x57b8e0af
block|,
literal|0x2464369b
block|,
literal|0xf009b91e
block|,
literal|0x5563911d
block|,
literal|0x59dfa6aa
block|,
literal|0x78c14389
block|,
literal|0xd95a537f
block|,
literal|0x207d5ba2
block|,
literal|0x02e5b9c5
block|,
literal|0x83260376
block|,
literal|0x6295cfa9
block|,
literal|0x11c81968
block|,
literal|0x4e734a41
block|,
literal|0xb3472dca
block|,
literal|0x7b14a94a
block|,
literal|0x1b510052
block|,
literal|0x9a532915
block|,
literal|0xd60f573f
block|,
literal|0xbc9bc6e4
block|,
literal|0x2b60a476
block|,
literal|0x81e67400
block|,
literal|0x08ba6fb5
block|,
literal|0x571be91f
block|,
literal|0xf296ec6b
block|,
literal|0x2a0dd915
block|,
literal|0xb6636521
block|,
literal|0xe7b9f9b6
block|,
literal|0xff34052e
block|,
literal|0xc5855664
block|,
literal|0x53b02d5d
block|,
literal|0xa99f8fa1
block|,
literal|0x08ba4799
block|,
literal|0x6e85076a
block|}
block|,
block|{
literal|0x4b7a70e9
block|,
literal|0xb5b32944
block|,
literal|0xdb75092e
block|,
literal|0xc4192623
block|,
literal|0xad6ea6b0
block|,
literal|0x49a7df7d
block|,
literal|0x9cee60b8
block|,
literal|0x8fedb266
block|,
literal|0xecaa8c71
block|,
literal|0x699a17ff
block|,
literal|0x5664526c
block|,
literal|0xc2b19ee1
block|,
literal|0x193602a5
block|,
literal|0x75094c29
block|,
literal|0xa0591340
block|,
literal|0xe4183a3e
block|,
literal|0x3f54989a
block|,
literal|0x5b429d65
block|,
literal|0x6b8fe4d6
block|,
literal|0x99f73fd6
block|,
literal|0xa1d29c07
block|,
literal|0xefe830f5
block|,
literal|0x4d2d38e6
block|,
literal|0xf0255dc1
block|,
literal|0x4cdd2086
block|,
literal|0x8470eb26
block|,
literal|0x6382e9c6
block|,
literal|0x021ecc5e
block|,
literal|0x09686b3f
block|,
literal|0x3ebaefc9
block|,
literal|0x3c971814
block|,
literal|0x6b6a70a1
block|,
literal|0x687f3584
block|,
literal|0x52a0e286
block|,
literal|0xb79c5305
block|,
literal|0xaa500737
block|,
literal|0x3e07841c
block|,
literal|0x7fdeae5c
block|,
literal|0x8e7d44ec
block|,
literal|0x5716f2b8
block|,
literal|0xb03ada37
block|,
literal|0xf0500c0d
block|,
literal|0xf01c1f04
block|,
literal|0x0200b3ff
block|,
literal|0xae0cf51a
block|,
literal|0x3cb574b2
block|,
literal|0x25837a58
block|,
literal|0xdc0921bd
block|,
literal|0xd19113f9
block|,
literal|0x7ca92ff6
block|,
literal|0x94324773
block|,
literal|0x22f54701
block|,
literal|0x3ae5e581
block|,
literal|0x37c2dadc
block|,
literal|0xc8b57634
block|,
literal|0x9af3dda7
block|,
literal|0xa9446146
block|,
literal|0x0fd0030e
block|,
literal|0xecc8c73e
block|,
literal|0xa4751e41
block|,
literal|0xe238cd99
block|,
literal|0x3bea0e2f
block|,
literal|0x3280bba1
block|,
literal|0x183eb331
block|,
literal|0x4e548b38
block|,
literal|0x4f6db908
block|,
literal|0x6f420d03
block|,
literal|0xf60a04bf
block|,
literal|0x2cb81290
block|,
literal|0x24977c79
block|,
literal|0x5679b072
block|,
literal|0xbcaf89af
block|,
literal|0xde9a771f
block|,
literal|0xd9930810
block|,
literal|0xb38bae12
block|,
literal|0xdccf3f2e
block|,
literal|0x5512721f
block|,
literal|0x2e6b7124
block|,
literal|0x501adde6
block|,
literal|0x9f84cd87
block|,
literal|0x7a584718
block|,
literal|0x7408da17
block|,
literal|0xbc9f9abc
block|,
literal|0xe94b7d8c
block|,
literal|0xec7aec3a
block|,
literal|0xdb851dfa
block|,
literal|0x63094366
block|,
literal|0xc464c3d2
block|,
literal|0xef1c1847
block|,
literal|0x3215d908
block|,
literal|0xdd433b37
block|,
literal|0x24c2ba16
block|,
literal|0x12a14d43
block|,
literal|0x2a65c451
block|,
literal|0x50940002
block|,
literal|0x133ae4dd
block|,
literal|0x71dff89e
block|,
literal|0x10314e55
block|,
literal|0x81ac77d6
block|,
literal|0x5f11199b
block|,
literal|0x043556f1
block|,
literal|0xd7a3c76b
block|,
literal|0x3c11183b
block|,
literal|0x5924a509
block|,
literal|0xf28fe6ed
block|,
literal|0x97f1fbfa
block|,
literal|0x9ebabf2c
block|,
literal|0x1e153c6e
block|,
literal|0x86e34570
block|,
literal|0xeae96fb1
block|,
literal|0x860e5e0a
block|,
literal|0x5a3e2ab3
block|,
literal|0x771fe71c
block|,
literal|0x4e3d06fa
block|,
literal|0x2965dcb9
block|,
literal|0x99e71d0f
block|,
literal|0x803e89d6
block|,
literal|0x5266c825
block|,
literal|0x2e4cc978
block|,
literal|0x9c10b36a
block|,
literal|0xc6150eba
block|,
literal|0x94e2ea78
block|,
literal|0xa5fc3c53
block|,
literal|0x1e0a2df4
block|,
literal|0xf2f74ea7
block|,
literal|0x361d2b3d
block|,
literal|0x1939260f
block|,
literal|0x19c27960
block|,
literal|0x5223a708
block|,
literal|0xf71312b6
block|,
literal|0xebadfe6e
block|,
literal|0xeac31f66
block|,
literal|0xe3bc4595
block|,
literal|0xa67bc883
block|,
literal|0xb17f37d1
block|,
literal|0x018cff28
block|,
literal|0xc332ddef
block|,
literal|0xbe6c5aa5
block|,
literal|0x65582185
block|,
literal|0x68ab9802
block|,
literal|0xeecea50f
block|,
literal|0xdb2f953b
block|,
literal|0x2aef7dad
block|,
literal|0x5b6e2f84
block|,
literal|0x1521b628
block|,
literal|0x29076170
block|,
literal|0xecdd4775
block|,
literal|0x619f1510
block|,
literal|0x13cca830
block|,
literal|0xeb61bd96
block|,
literal|0x0334fe1e
block|,
literal|0xaa0363cf
block|,
literal|0xb5735c90
block|,
literal|0x4c70a239
block|,
literal|0xd59e9e0b
block|,
literal|0xcbaade14
block|,
literal|0xeecc86bc
block|,
literal|0x60622ca7
block|,
literal|0x9cab5cab
block|,
literal|0xb2f3846e
block|,
literal|0x648b1eaf
block|,
literal|0x19bdf0ca
block|,
literal|0xa02369b9
block|,
literal|0x655abb50
block|,
literal|0x40685a32
block|,
literal|0x3c2ab4b3
block|,
literal|0x319ee9d5
block|,
literal|0xc021b8f7
block|,
literal|0x9b540b19
block|,
literal|0x875fa099
block|,
literal|0x95f7997e
block|,
literal|0x623d7da8
block|,
literal|0xf837889a
block|,
literal|0x97e32d77
block|,
literal|0x11ed935f
block|,
literal|0x16681281
block|,
literal|0x0e358829
block|,
literal|0xc7e61fd6
block|,
literal|0x96dedfa1
block|,
literal|0x7858ba99
block|,
literal|0x57f584a5
block|,
literal|0x1b227263
block|,
literal|0x9b83c3ff
block|,
literal|0x1ac24696
block|,
literal|0xcdb30aeb
block|,
literal|0x532e3054
block|,
literal|0x8fd948e4
block|,
literal|0x6dbc3128
block|,
literal|0x58ebf2ef
block|,
literal|0x34c6ffea
block|,
literal|0xfe28ed61
block|,
literal|0xee7c3c73
block|,
literal|0x5d4a14d9
block|,
literal|0xe864b7e3
block|,
literal|0x42105d14
block|,
literal|0x203e13e0
block|,
literal|0x45eee2b6
block|,
literal|0xa3aaabea
block|,
literal|0xdb6c4f15
block|,
literal|0xfacb4fd0
block|,
literal|0xc742f442
block|,
literal|0xef6abbb5
block|,
literal|0x654f3b1d
block|,
literal|0x41cd2105
block|,
literal|0xd81e799e
block|,
literal|0x86854dc7
block|,
literal|0xe44b476a
block|,
literal|0x3d816250
block|,
literal|0xcf62a1f2
block|,
literal|0x5b8d2646
block|,
literal|0xfc8883a0
block|,
literal|0xc1c7b6a3
block|,
literal|0x7f1524c3
block|,
literal|0x69cb7492
block|,
literal|0x47848a0b
block|,
literal|0x5692b285
block|,
literal|0x095bbf00
block|,
literal|0xad19489d
block|,
literal|0x1462b174
block|,
literal|0x23820e00
block|,
literal|0x58428d2a
block|,
literal|0x0c55f5ea
block|,
literal|0x1dadf43e
block|,
literal|0x233f7061
block|,
literal|0x3372f092
block|,
literal|0x8d937e41
block|,
literal|0xd65fecf1
block|,
literal|0x6c223bdb
block|,
literal|0x7cde3759
block|,
literal|0xcbee7460
block|,
literal|0x4085f2a7
block|,
literal|0xce77326e
block|,
literal|0xa6078084
block|,
literal|0x19f8509e
block|,
literal|0xe8efd855
block|,
literal|0x61d99735
block|,
literal|0xa969a7aa
block|,
literal|0xc50c06c2
block|,
literal|0x5a04abfc
block|,
literal|0x800bcadc
block|,
literal|0x9e447a2e
block|,
literal|0xc3453484
block|,
literal|0xfdd56705
block|,
literal|0x0e1e9ec9
block|,
literal|0xdb73dbd3
block|,
literal|0x105588cd
block|,
literal|0x675fda79
block|,
literal|0xe3674340
block|,
literal|0xc5c43465
block|,
literal|0x713e38d8
block|,
literal|0x3d28f89e
block|,
literal|0xf16dff20
block|,
literal|0x153e21e7
block|,
literal|0x8fb03d4a
block|,
literal|0xe6e39f2b
block|,
literal|0xdb83adf7
block|}
block|,
block|{
literal|0xe93d5a68
block|,
literal|0x948140f7
block|,
literal|0xf64c261c
block|,
literal|0x94692934
block|,
literal|0x411520f7
block|,
literal|0x7602d4f7
block|,
literal|0xbcf46b2e
block|,
literal|0xd4a20068
block|,
literal|0xd4082471
block|,
literal|0x3320f46a
block|,
literal|0x43b7d4b7
block|,
literal|0x500061af
block|,
literal|0x1e39f62e
block|,
literal|0x97244546
block|,
literal|0x14214f74
block|,
literal|0xbf8b8840
block|,
literal|0x4d95fc1d
block|,
literal|0x96b591af
block|,
literal|0x70f4ddd3
block|,
literal|0x66a02f45
block|,
literal|0xbfbc09ec
block|,
literal|0x03bd9785
block|,
literal|0x7fac6dd0
block|,
literal|0x31cb8504
block|,
literal|0x96eb27b3
block|,
literal|0x55fd3941
block|,
literal|0xda2547e6
block|,
literal|0xabca0a9a
block|,
literal|0x28507825
block|,
literal|0x530429f4
block|,
literal|0x0a2c86da
block|,
literal|0xe9b66dfb
block|,
literal|0x68dc1462
block|,
literal|0xd7486900
block|,
literal|0x680ec0a4
block|,
literal|0x27a18dee
block|,
literal|0x4f3ffea2
block|,
literal|0xe887ad8c
block|,
literal|0xb58ce006
block|,
literal|0x7af4d6b6
block|,
literal|0xaace1e7c
block|,
literal|0xd3375fec
block|,
literal|0xce78a399
block|,
literal|0x406b2a42
block|,
literal|0x20fe9e35
block|,
literal|0xd9f385b9
block|,
literal|0xee39d7ab
block|,
literal|0x3b124e8b
block|,
literal|0x1dc9faf7
block|,
literal|0x4b6d1856
block|,
literal|0x26a36631
block|,
literal|0xeae397b2
block|,
literal|0x3a6efa74
block|,
literal|0xdd5b4332
block|,
literal|0x6841e7f7
block|,
literal|0xca7820fb
block|,
literal|0xfb0af54e
block|,
literal|0xd8feb397
block|,
literal|0x454056ac
block|,
literal|0xba489527
block|,
literal|0x55533a3a
block|,
literal|0x20838d87
block|,
literal|0xfe6ba9b7
block|,
literal|0xd096954b
block|,
literal|0x55a867bc
block|,
literal|0xa1159a58
block|,
literal|0xcca92963
block|,
literal|0x99e1db33
block|,
literal|0xa62a4a56
block|,
literal|0x3f3125f9
block|,
literal|0x5ef47e1c
block|,
literal|0x9029317c
block|,
literal|0xfdf8e802
block|,
literal|0x04272f70
block|,
literal|0x80bb155c
block|,
literal|0x05282ce3
block|,
literal|0x95c11548
block|,
literal|0xe4c66d22
block|,
literal|0x48c1133f
block|,
literal|0xc70f86dc
block|,
literal|0x07f9c9ee
block|,
literal|0x41041f0f
block|,
literal|0x404779a4
block|,
literal|0x5d886e17
block|,
literal|0x325f51eb
block|,
literal|0xd59bc0d1
block|,
literal|0xf2bcc18f
block|,
literal|0x41113564
block|,
literal|0x257b7834
block|,
literal|0x602a9c60
block|,
literal|0xdff8e8a3
block|,
literal|0x1f636c1b
block|,
literal|0x0e12b4c2
block|,
literal|0x02e1329e
block|,
literal|0xaf664fd1
block|,
literal|0xcad18115
block|,
literal|0x6b2395e0
block|,
literal|0x333e92e1
block|,
literal|0x3b240b62
block|,
literal|0xeebeb922
block|,
literal|0x85b2a20e
block|,
literal|0xe6ba0d99
block|,
literal|0xde720c8c
block|,
literal|0x2da2f728
block|,
literal|0xd0127845
block|,
literal|0x95b794fd
block|,
literal|0x647d0862
block|,
literal|0xe7ccf5f0
block|,
literal|0x5449a36f
block|,
literal|0x877d48fa
block|,
literal|0xc39dfd27
block|,
literal|0xf33e8d1e
block|,
literal|0x0a476341
block|,
literal|0x992eff74
block|,
literal|0x3a6f6eab
block|,
literal|0xf4f8fd37
block|,
literal|0xa812dc60
block|,
literal|0xa1ebddf8
block|,
literal|0x991be14c
block|,
literal|0xdb6e6b0d
block|,
literal|0xc67b5510
block|,
literal|0x6d672c37
block|,
literal|0x2765d43b
block|,
literal|0xdcd0e804
block|,
literal|0xf1290dc7
block|,
literal|0xcc00ffa3
block|,
literal|0xb5390f92
block|,
literal|0x690fed0b
block|,
literal|0x667b9ffb
block|,
literal|0xcedb7d9c
block|,
literal|0xa091cf0b
block|,
literal|0xd9155ea3
block|,
literal|0xbb132f88
block|,
literal|0x515bad24
block|,
literal|0x7b9479bf
block|,
literal|0x763bd6eb
block|,
literal|0x37392eb3
block|,
literal|0xcc115979
block|,
literal|0x8026e297
block|,
literal|0xf42e312d
block|,
literal|0x6842ada7
block|,
literal|0xc66a2b3b
block|,
literal|0x12754ccc
block|,
literal|0x782ef11c
block|,
literal|0x6a124237
block|,
literal|0xb79251e7
block|,
literal|0x06a1bbe6
block|,
literal|0x4bfb6350
block|,
literal|0x1a6b1018
block|,
literal|0x11caedfa
block|,
literal|0x3d25bdd8
block|,
literal|0xe2e1c3c9
block|,
literal|0x44421659
block|,
literal|0x0a121386
block|,
literal|0xd90cec6e
block|,
literal|0xd5abea2a
block|,
literal|0x64af674e
block|,
literal|0xda86a85f
block|,
literal|0xbebfe988
block|,
literal|0x64e4c3fe
block|,
literal|0x9dbc8057
block|,
literal|0xf0f7c086
block|,
literal|0x60787bf8
block|,
literal|0x6003604d
block|,
literal|0xd1fd8346
block|,
literal|0xf6381fb0
block|,
literal|0x7745ae04
block|,
literal|0xd736fccc
block|,
literal|0x83426b33
block|,
literal|0xf01eab71
block|,
literal|0xb0804187
block|,
literal|0x3c005e5f
block|,
literal|0x77a057be
block|,
literal|0xbde8ae24
block|,
literal|0x55464299
block|,
literal|0xbf582e61
block|,
literal|0x4e58f48f
block|,
literal|0xf2ddfda2
block|,
literal|0xf474ef38
block|,
literal|0x8789bdc2
block|,
literal|0x5366f9c3
block|,
literal|0xc8b38e74
block|,
literal|0xb475f255
block|,
literal|0x46fcd9b9
block|,
literal|0x7aeb2661
block|,
literal|0x8b1ddf84
block|,
literal|0x846a0e79
block|,
literal|0x915f95e2
block|,
literal|0x466e598e
block|,
literal|0x20b45770
block|,
literal|0x8cd55591
block|,
literal|0xc902de4c
block|,
literal|0xb90bace1
block|,
literal|0xbb8205d0
block|,
literal|0x11a86248
block|,
literal|0x7574a99e
block|,
literal|0xb77f19b6
block|,
literal|0xe0a9dc09
block|,
literal|0x662d09a1
block|,
literal|0xc4324633
block|,
literal|0xe85a1f02
block|,
literal|0x09f0be8c
block|,
literal|0x4a99a025
block|,
literal|0x1d6efe10
block|,
literal|0x1ab93d1d
block|,
literal|0x0ba5a4df
block|,
literal|0xa186f20f
block|,
literal|0x2868f169
block|,
literal|0xdcb7da83
block|,
literal|0x573906fe
block|,
literal|0xa1e2ce9b
block|,
literal|0x4fcd7f52
block|,
literal|0x50115e01
block|,
literal|0xa70683fa
block|,
literal|0xa002b5c4
block|,
literal|0x0de6d027
block|,
literal|0x9af88c27
block|,
literal|0x773f8641
block|,
literal|0xc3604c06
block|,
literal|0x61a806b5
block|,
literal|0xf0177a28
block|,
literal|0xc0f586e0
block|,
literal|0x006058aa
block|,
literal|0x30dc7d62
block|,
literal|0x11e69ed7
block|,
literal|0x2338ea63
block|,
literal|0x53c2dd94
block|,
literal|0xc2c21634
block|,
literal|0xbbcbee56
block|,
literal|0x90bcb6de
block|,
literal|0xebfc7da1
block|,
literal|0xce591d76
block|,
literal|0x6f05e409
block|,
literal|0x4b7c0188
block|,
literal|0x39720a3d
block|,
literal|0x7c927c24
block|,
literal|0x86e3725f
block|,
literal|0x724d9db9
block|,
literal|0x1ac15bb4
block|,
literal|0xd39eb8fc
block|,
literal|0xed545578
block|,
literal|0x08fca5b5
block|,
literal|0xd83d7cd3
block|,
literal|0x4dad0fc4
block|,
literal|0x1e50ef5e
block|,
literal|0xb161e6f8
block|,
literal|0xa28514d9
block|,
literal|0x6c51133c
block|,
literal|0x6fd5c7e7
block|,
literal|0x56e14ec4
block|,
literal|0x362abfce
block|,
literal|0xddc6c837
block|,
literal|0xd79a3234
block|,
literal|0x92638212
block|,
literal|0x670efa8e
block|,
literal|0x406000e0
block|}
block|,
block|{
literal|0x3a39ce37
block|,
literal|0xd3faf5cf
block|,
literal|0xabc27737
block|,
literal|0x5ac52d1b
block|,
literal|0x5cb0679e
block|,
literal|0x4fa33742
block|,
literal|0xd3822740
block|,
literal|0x99bc9bbe
block|,
literal|0xd5118e9d
block|,
literal|0xbf0f7315
block|,
literal|0xd62d1c7e
block|,
literal|0xc700c47b
block|,
literal|0xb78c1b6b
block|,
literal|0x21a19045
block|,
literal|0xb26eb1be
block|,
literal|0x6a366eb4
block|,
literal|0x5748ab2f
block|,
literal|0xbc946e79
block|,
literal|0xc6a376d2
block|,
literal|0x6549c2c8
block|,
literal|0x530ff8ee
block|,
literal|0x468dde7d
block|,
literal|0xd5730a1d
block|,
literal|0x4cd04dc6
block|,
literal|0x2939bbdb
block|,
literal|0xa9ba4650
block|,
literal|0xac9526e8
block|,
literal|0xbe5ee304
block|,
literal|0xa1fad5f0
block|,
literal|0x6a2d519a
block|,
literal|0x63ef8ce2
block|,
literal|0x9a86ee22
block|,
literal|0xc089c2b8
block|,
literal|0x43242ef6
block|,
literal|0xa51e03aa
block|,
literal|0x9cf2d0a4
block|,
literal|0x83c061ba
block|,
literal|0x9be96a4d
block|,
literal|0x8fe51550
block|,
literal|0xba645bd6
block|,
literal|0x2826a2f9
block|,
literal|0xa73a3ae1
block|,
literal|0x4ba99586
block|,
literal|0xef5562e9
block|,
literal|0xc72fefd3
block|,
literal|0xf752f7da
block|,
literal|0x3f046f69
block|,
literal|0x77fa0a59
block|,
literal|0x80e4a915
block|,
literal|0x87b08601
block|,
literal|0x9b09e6ad
block|,
literal|0x3b3ee593
block|,
literal|0xe990fd5a
block|,
literal|0x9e34d797
block|,
literal|0x2cf0b7d9
block|,
literal|0x022b8b51
block|,
literal|0x96d5ac3a
block|,
literal|0x017da67d
block|,
literal|0xd1cf3ed6
block|,
literal|0x7c7d2d28
block|,
literal|0x1f9f25cf
block|,
literal|0xadf2b89b
block|,
literal|0x5ad6b472
block|,
literal|0x5a88f54c
block|,
literal|0xe029ac71
block|,
literal|0xe019a5e6
block|,
literal|0x47b0acfd
block|,
literal|0xed93fa9b
block|,
literal|0xe8d3c48d
block|,
literal|0x283b57cc
block|,
literal|0xf8d56629
block|,
literal|0x79132e28
block|,
literal|0x785f0191
block|,
literal|0xed756055
block|,
literal|0xf7960e44
block|,
literal|0xe3d35e8c
block|,
literal|0x15056dd4
block|,
literal|0x88f46dba
block|,
literal|0x03a16125
block|,
literal|0x0564f0bd
block|,
literal|0xc3eb9e15
block|,
literal|0x3c9057a2
block|,
literal|0x97271aec
block|,
literal|0xa93a072a
block|,
literal|0x1b3f6d9b
block|,
literal|0x1e6321f5
block|,
literal|0xf59c66fb
block|,
literal|0x26dcf319
block|,
literal|0x7533d928
block|,
literal|0xb155fdf5
block|,
literal|0x03563482
block|,
literal|0x8aba3cbb
block|,
literal|0x28517711
block|,
literal|0xc20ad9f8
block|,
literal|0xabcc5167
block|,
literal|0xccad925f
block|,
literal|0x4de81751
block|,
literal|0x3830dc8e
block|,
literal|0x379d5862
block|,
literal|0x9320f991
block|,
literal|0xea7a90c2
block|,
literal|0xfb3e7bce
block|,
literal|0x5121ce64
block|,
literal|0x774fbe32
block|,
literal|0xa8b6e37e
block|,
literal|0xc3293d46
block|,
literal|0x48de5369
block|,
literal|0x6413e680
block|,
literal|0xa2ae0810
block|,
literal|0xdd6db224
block|,
literal|0x69852dfd
block|,
literal|0x09072166
block|,
literal|0xb39a460a
block|,
literal|0x6445c0dd
block|,
literal|0x586cdecf
block|,
literal|0x1c20c8ae
block|,
literal|0x5bbef7dd
block|,
literal|0x1b588d40
block|,
literal|0xccd2017f
block|,
literal|0x6bb4e3bb
block|,
literal|0xdda26a7e
block|,
literal|0x3a59ff45
block|,
literal|0x3e350a44
block|,
literal|0xbcb4cdd5
block|,
literal|0x72eacea8
block|,
literal|0xfa6484bb
block|,
literal|0x8d6612ae
block|,
literal|0xbf3c6f47
block|,
literal|0xd29be463
block|,
literal|0x542f5d9e
block|,
literal|0xaec2771b
block|,
literal|0xf64e6370
block|,
literal|0x740e0d8d
block|,
literal|0xe75b1357
block|,
literal|0xf8721671
block|,
literal|0xaf537d5d
block|,
literal|0x4040cb08
block|,
literal|0x4eb4e2cc
block|,
literal|0x34d2466a
block|,
literal|0x0115af84
block|,
literal|0xe1b00428
block|,
literal|0x95983a1d
block|,
literal|0x06b89fb4
block|,
literal|0xce6ea048
block|,
literal|0x6f3f3b82
block|,
literal|0x3520ab82
block|,
literal|0x011a1d4b
block|,
literal|0x277227f8
block|,
literal|0x611560b1
block|,
literal|0xe7933fdc
block|,
literal|0xbb3a792b
block|,
literal|0x344525bd
block|,
literal|0xa08839e1
block|,
literal|0x51ce794b
block|,
literal|0x2f32c9b7
block|,
literal|0xa01fbac9
block|,
literal|0xe01cc87e
block|,
literal|0xbcc7d1f6
block|,
literal|0xcf0111c3
block|,
literal|0xa1e8aac7
block|,
literal|0x1a908749
block|,
literal|0xd44fbd9a
block|,
literal|0xd0dadecb
block|,
literal|0xd50ada38
block|,
literal|0x0339c32a
block|,
literal|0xc6913667
block|,
literal|0x8df9317c
block|,
literal|0xe0b12b4f
block|,
literal|0xf79e59b7
block|,
literal|0x43f5bb3a
block|,
literal|0xf2d519ff
block|,
literal|0x27d9459c
block|,
literal|0xbf97222c
block|,
literal|0x15e6fc2a
block|,
literal|0x0f91fc71
block|,
literal|0x9b941525
block|,
literal|0xfae59361
block|,
literal|0xceb69ceb
block|,
literal|0xc2a86459
block|,
literal|0x12baa8d1
block|,
literal|0xb6c1075e
block|,
literal|0xe3056a0c
block|,
literal|0x10d25065
block|,
literal|0xcb03a442
block|,
literal|0xe0ec6e0e
block|,
literal|0x1698db3b
block|,
literal|0x4c98a0be
block|,
literal|0x3278e964
block|,
literal|0x9f1f9532
block|,
literal|0xe0d392df
block|,
literal|0xd3a0342b
block|,
literal|0x8971f21e
block|,
literal|0x1b0a7441
block|,
literal|0x4ba3348c
block|,
literal|0xc5be7120
block|,
literal|0xc37632d8
block|,
literal|0xdf359f8d
block|,
literal|0x9b992f2e
block|,
literal|0xe60b6f47
block|,
literal|0x0fe3f11d
block|,
literal|0xe54cda54
block|,
literal|0x1edad891
block|,
literal|0xce6279cf
block|,
literal|0xcd3e7e6f
block|,
literal|0x1618b166
block|,
literal|0xfd2c1d05
block|,
literal|0x848fd2c5
block|,
literal|0xf6fb2299
block|,
literal|0xf523f357
block|,
literal|0xa6327623
block|,
literal|0x93a83531
block|,
literal|0x56cccd02
block|,
literal|0xacf08162
block|,
literal|0x5a75ebb5
block|,
literal|0x6e163697
block|,
literal|0x88d273cc
block|,
literal|0xde966292
block|,
literal|0x81b949d0
block|,
literal|0x4c50901b
block|,
literal|0x71c65614
block|,
literal|0xe6c6c7bd
block|,
literal|0x327a140a
block|,
literal|0x45e1d006
block|,
literal|0xc3f27b9a
block|,
literal|0xc9aa53fd
block|,
literal|0x62a80f00
block|,
literal|0xbb25bfe2
block|,
literal|0x35bdd2f6
block|,
literal|0x71126905
block|,
literal|0xb2040222
block|,
literal|0xb6cbcf7c
block|,
literal|0xcd769c2b
block|,
literal|0x53113ec0
block|,
literal|0x1640e3d3
block|,
literal|0x38abbd60
block|,
literal|0x2547adf0
block|,
literal|0xba38209c
block|,
literal|0xf746ce76
block|,
literal|0x77afa1c5
block|,
literal|0x20756060
block|,
literal|0x85cbfe4e
block|,
literal|0x8ae88dd8
block|,
literal|0x7aaaf9b0
block|,
literal|0x4cf9aa7e
block|,
literal|0x1948c25c
block|,
literal|0x02fb8a8c
block|,
literal|0x01c36ae4
block|,
literal|0xd6ebe1f9
block|,
literal|0x90d4f869
block|,
literal|0xa65cdea0
block|,
literal|0x3f09252d
block|,
literal|0xc208e69f
block|,
literal|0xb74e6132
block|,
literal|0xce77e25b
block|,
literal|0x578fdfe3
block|,
literal|0x3ac372e6
block|}
block|}
block|,
block|{
literal|0x243f6a88
block|,
literal|0x85a308d3
block|,
literal|0x13198a2e
block|,
literal|0x03707344
block|,
literal|0xa4093822
block|,
literal|0x299f31d0
block|,
literal|0x082efa98
block|,
literal|0xec4e6c89
block|,
literal|0x452821e6
block|,
literal|0x38d01377
block|,
literal|0xbe5466cf
block|,
literal|0x34e90c6c
block|,
literal|0xc0ac29b7
block|,
literal|0xc97c50dd
block|,
literal|0x3f84d5b5
block|,
literal|0xb5470917
block|,
literal|0x9216d5d9
block|,
literal|0x8979fb1b
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|BF_itoa64
index|[
literal|64
operator|+
literal|1
index|]
init|=
literal|"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|BF_atoi64
index|[
literal|0x60
index|]
init|=
block|{
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BF_safe_atoi64
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|{ \ 	tmp = (unsigned char)(src); \ 	if ((unsigned int)(tmp -= 0x20)>= 0x60) return -1; \ 	tmp = BF_atoi64[tmp]; \ 	if (tmp> 63) return -1; \ 	(dst) = tmp; \ }
end_define

begin_function
specifier|static
name|int
name|BF_decode
parameter_list|(
name|BF_word
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|dptr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dst
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|dptr
operator|+
name|size
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sptr
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|src
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|,
name|c4
decl_stmt|;
do|do
block|{
name|BF_safe_atoi64
argument_list|(
name|c1
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
name|BF_safe_atoi64
argument_list|(
name|c2
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
operator|(
name|c1
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|c2
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|>=
name|end
condition|)
break|break;
name|BF_safe_atoi64
argument_list|(
name|c3
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0x0F
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|c3
operator|&
literal|0x3C
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|>=
name|end
condition|)
break|break;
name|BF_safe_atoi64
argument_list|(
name|c4
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
operator|(
operator|(
name|c3
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
name|c4
expr_stmt|;
block|}
do|while
condition|(
name|dptr
operator|<
name|end
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|BF_encode
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|BF_word
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sptr
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
init|=
name|sptr
operator|+
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dptr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dst
decl_stmt|;
name|unsigned
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
do|do
block|{
name|c1
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|BF_itoa64
index|[
name|c1
operator|>>
literal|2
index|]
expr_stmt|;
name|c1
operator|=
operator|(
name|c1
operator|&
literal|0x03
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|sptr
operator|>=
name|end
condition|)
block|{
operator|*
name|dptr
operator|++
operator|=
name|BF_itoa64
index|[
name|c1
index|]
expr_stmt|;
break|break;
block|}
name|c2
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|c1
operator||=
name|c2
operator|>>
literal|4
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|BF_itoa64
index|[
name|c1
index|]
expr_stmt|;
name|c1
operator|=
operator|(
name|c2
operator|&
literal|0x0f
operator|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|sptr
operator|>=
name|end
condition|)
block|{
operator|*
name|dptr
operator|++
operator|=
name|BF_itoa64
index|[
name|c1
index|]
expr_stmt|;
break|break;
block|}
name|c2
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|c1
operator||=
name|c2
operator|>>
literal|6
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|BF_itoa64
index|[
name|c1
index|]
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|BF_itoa64
index|[
name|c2
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
do|while
condition|(
name|sptr
operator|<
name|end
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|BF_swap
parameter_list|(
name|BF_word
modifier|*
name|x
parameter_list|,
name|int
name|count
parameter_list|)
block|{
specifier|static
name|int
name|endianness_check
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|is_little_endian
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|endianness_check
decl_stmt|;
name|BF_word
name|tmp
decl_stmt|;
if|if
condition|(
operator|*
name|is_little_endian
condition|)
do|do
block|{
name|tmp
operator|=
operator|*
name|x
expr_stmt|;
name|tmp
operator|=
operator|(
name|tmp
operator|<<
literal|16
operator|)
operator||
operator|(
name|tmp
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|x
operator|++
operator|=
operator|(
operator|(
name|tmp
operator|&
literal|0x00FF00FF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|tmp
operator|>>
literal|8
operator|)
operator|&
literal|0x00FF00FF
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
block|}
end_function

begin_if
if|#
directive|if
name|BF_SCALE
end_if

begin_comment
comment|/* Architectures which can shift addresses left by 2 bits with no extra cost */
end_comment

begin_define
define|#
directive|define
name|BF_ROUND
parameter_list|(
name|L
parameter_list|,
name|R
parameter_list|,
name|N
parameter_list|)
define|\
value|tmp1 = L& 0xFF; \ 	tmp2 = L>> 8; \ 	tmp2&= 0xFF; \ 	tmp3 = L>> 16; \ 	tmp3&= 0xFF; \ 	tmp4 = L>> 24; \ 	tmp1 = data.ctx.S[3][tmp1]; \ 	tmp2 = data.ctx.S[2][tmp2]; \ 	tmp3 = data.ctx.S[1][tmp3]; \ 	tmp3 += data.ctx.S[0][tmp4]; \ 	tmp3 ^= tmp2; \ 	R ^= data.ctx.P[N + 1]; \ 	tmp3 += tmp1; \ 	R ^= tmp3;
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Architectures with no complicated addressing modes supported */
end_comment

begin_define
define|#
directive|define
name|BF_INDEX
parameter_list|(
name|S
parameter_list|,
name|i
parameter_list|)
define|\
value|(*((BF_word *)(((unsigned char *)S) + (i))))
end_define

begin_define
define|#
directive|define
name|BF_ROUND
parameter_list|(
name|L
parameter_list|,
name|R
parameter_list|,
name|N
parameter_list|)
define|\
value|tmp1 = L& 0xFF; \ 	tmp1<<= 2; \ 	tmp2 = L>> 6; \ 	tmp2&= 0x3FC; \ 	tmp3 = L>> 14; \ 	tmp3&= 0x3FC; \ 	tmp4 = L>> 22; \ 	tmp4&= 0x3FC; \ 	tmp1 = BF_INDEX(data.ctx.S[3], tmp1); \ 	tmp2 = BF_INDEX(data.ctx.S[2], tmp2); \ 	tmp3 = BF_INDEX(data.ctx.S[1], tmp3); \ 	tmp3 += BF_INDEX(data.ctx.S[0], tmp4); \ 	tmp3 ^= tmp2; \ 	R ^= data.ctx.P[N + 1]; \ 	tmp3 += tmp1; \ 	R ^= tmp3;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Encrypt one block, BF_N is hardcoded here.  */
end_comment

begin_define
define|#
directive|define
name|BF_ENCRYPT
define|\
value|L ^= data.ctx.P[0]; \ 	BF_ROUND(L, R, 0); \ 	BF_ROUND(R, L, 1); \ 	BF_ROUND(L, R, 2); \ 	BF_ROUND(R, L, 3); \ 	BF_ROUND(L, R, 4); \ 	BF_ROUND(R, L, 5); \ 	BF_ROUND(L, R, 6); \ 	BF_ROUND(R, L, 7); \ 	BF_ROUND(L, R, 8); \ 	BF_ROUND(R, L, 9); \ 	BF_ROUND(L, R, 10); \ 	BF_ROUND(R, L, 11); \ 	BF_ROUND(L, R, 12); \ 	BF_ROUND(R, L, 13); \ 	BF_ROUND(L, R, 14); \ 	BF_ROUND(R, L, 15); \ 	tmp4 = R; \ 	R = L; \ 	L = tmp4 ^ data.ctx.P[BF_N + 1];
end_define

begin_if
if|#
directive|if
name|BF_ASM
end_if

begin_define
define|#
directive|define
name|BF_body
parameter_list|()
define|\
value|_BF_body_r(&data.ctx);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BF_body
parameter_list|()
define|\
value|L = R = 0; \ 	ptr = data.ctx.P; \ 	do { \ 		ptr += 2; \ 		BF_ENCRYPT; \ 		*(ptr - 2) = L; \ 		*(ptr - 1) = R; \ 	} while (ptr<&data.ctx.P[BF_N + 2]); \ \ 	ptr = data.ctx.S[0]; \ 	do { \ 		ptr += 2; \ 		BF_ENCRYPT; \ 		*(ptr - 2) = L; \ 		*(ptr - 1) = R; \ 	} while (ptr<&data.ctx.S[3][0xFF]);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|BF_set_key
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|BF_key
name|expanded
parameter_list|,
name|BF_key
name|initial
parameter_list|,
name|unsigned
name|char
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|key
decl_stmt|;
name|unsigned
name|int
name|bug
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|BF_word
name|safety
decl_stmt|,
name|sign
decl_stmt|,
name|diff
decl_stmt|,
name|tmp
index|[
literal|2
index|]
decl_stmt|;
comment|/*  * There was a sign extension bug in older revisions of this function.  While  * we would have liked to simply fix the bug and move on, we have to provide  * a backwards compatibility feature (essentially the bug) for some systems and  * a safety measure for some others.  The latter is needed because for certain  * multiple inputs to the buggy algorithm there exist easily found inputs to  * the correct algorithm that produce the same hash.  Thus, we optionally  * deviate from the correct algorithm just enough to avoid such collisions.  * While the bug itself affected the majority of passwords containing  * characters with the 8th bit set (although only a percentage of those in a  * collision-producing way), the anti-collision safety measure affects  * only a subset of passwords containing the '\xff' character (not even all of  * those passwords, just some of them).  This character is not found in valid  * UTF-8 sequences and is rarely used in popular 8-bit character encodings.  * Thus, the safety measure is unlikely to cause much annoyance, and is a  * reasonable tradeoff to use when authenticating against existing hashes that  * are not reliably known to have been computed with the correct algorithm.  *  * We use an approach that tries to minimize side-channel leaks of password  * information - that is, we mostly use fixed-cost bitwise operations instead  * of branches or table lookups.  (One conditional branch based on password  * length remains.  It is not part of the bug aftermath, though, and is  * difficult and possibly unreasonable to avoid given the use of C strings by  * the caller, which results in similar timing leaks anyway.)  *  * For actual implementation, we set an array index in the variable "bug"  * (0 means no bug, 1 means sign extension bug emulation) and a flag in the  * variable "safety" (bit 16 is set when the safety measure is requested).  * Valid combinations of settings are:  *  * Prefix "$2a$": bug = 0, safety = 0x10000  * Prefix "$2x$": bug = 1, safety = 0  * Prefix "$2y$": bug = 0, safety = 0  */
name|bug
operator|=
operator|(
name|unsigned
name|int
operator|)
name|flags
operator|&
literal|1
expr_stmt|;
name|safety
operator|=
operator|(
operator|(
name|BF_word
operator|)
name|flags
operator|&
literal|2
operator|)
operator|<<
literal|15
expr_stmt|;
name|sign
operator|=
name|diff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BF_N
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tmp
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|tmp
index|[
literal|0
index|]
operator|<<=
literal|8
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator||=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ptr
expr_stmt|;
comment|/* correct */
name|tmp
index|[
literal|1
index|]
operator|<<=
literal|8
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator||=
operator|(
name|BF_word_signed
operator|)
operator|(
name|signed
name|char
operator|)
operator|*
name|ptr
expr_stmt|;
comment|/* bug */
comment|/*  * Sign extension in the first char has no effect - nothing to overwrite yet,  * and those extra 24 bits will be fully shifted out of the 32-bit word.  For  * chars 2, 3, 4 in each four-char block, we set bit 7 of "sign" if sign  * extension in tmp[1] occurs.  Once this flag is set, it remains set.  */
if|if
condition|(
name|j
condition|)
name|sign
operator||=
name|tmp
index|[
literal|1
index|]
operator|&
literal|0x80
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
name|ptr
operator|=
name|key
expr_stmt|;
else|else
name|ptr
operator|++
expr_stmt|;
block|}
name|diff
operator||=
name|tmp
index|[
literal|0
index|]
operator|^
name|tmp
index|[
literal|1
index|]
expr_stmt|;
comment|/* Non-zero on any differences */
name|expanded
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|bug
index|]
expr_stmt|;
name|initial
index|[
name|i
index|]
operator|=
name|BF_init_state
operator|.
name|P
index|[
name|i
index|]
operator|^
name|tmp
index|[
name|bug
index|]
expr_stmt|;
block|}
comment|/*  * At this point, "diff" is zero iff the correct and buggy algorithms produced  * exactly the same result.  If so and if "sign" is non-zero, which indicates  * that there was a non-benign sign extension, this means that we have a  * collision between the correctly computed hash for this password and a set of  * passwords that could be supplied to the buggy algorithm.  Our safety measure  * is meant to protect from such many-buggy to one-correct collisions, by  * deviating from the correct algorithm in such cases.  Let's check for this.  */
name|diff
operator||=
name|diff
operator|>>
literal|16
expr_stmt|;
comment|/* still zero iff exact match */
name|diff
operator|&=
literal|0xffff
expr_stmt|;
comment|/* ditto */
name|diff
operator|+=
literal|0xffff
expr_stmt|;
comment|/* bit 16 set iff "diff" was non-zero (on non-match) */
name|sign
operator|<<=
literal|9
expr_stmt|;
comment|/* move the non-benign sign extension flag to bit 16 */
name|sign
operator|&=
operator|~
name|diff
operator|&
name|safety
expr_stmt|;
comment|/* action needed? */
comment|/*  * If we have determined that we need to deviate from the correct algorithm,  * flip bit 16 in initial expanded key.  (The choice of 16 is arbitrary, but  * let's stick to it now.  It came out of the approach we used above, and it's  * not any worse than any other choice we could make.)  *  * It is crucial that we don't do the same to the expanded key used in the main  * Eksblowfish loop.  By doing it to only one of these two, we deviate from a  * state that could be directly specified by a password to the buggy algorithm  * (and to the fully correct one as well, but that's a side-effect).  */
name|initial
index|[
literal|0
index|]
operator|^=
name|sign
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|BF_crypt
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|setting
parameter_list|,
name|char
modifier|*
name|output
parameter_list|,
name|int
name|size
parameter_list|,
name|BF_word
name|min
parameter_list|)
block|{
if|#
directive|if
name|BF_ASM
specifier|extern
name|void
name|_BF_body_r
argument_list|(
name|BF_ctx
operator|*
name|ctx
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|unsigned
name|char
name|flags_by_subtype
index|[
literal|26
index|]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|}
decl_stmt|;
struct|struct
block|{
name|BF_ctx
name|ctx
decl_stmt|;
name|BF_key
name|expanded_key
decl_stmt|;
union|union
block|{
name|BF_word
name|salt
index|[
literal|4
index|]
decl_stmt|;
name|BF_word
name|output
index|[
literal|6
index|]
decl_stmt|;
block|}
name|binary
union|;
block|}
name|data
struct|;
name|BF_word
name|L
decl_stmt|,
name|R
decl_stmt|;
name|BF_word
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|,
name|tmp4
decl_stmt|;
name|BF_word
modifier|*
name|ptr
decl_stmt|;
name|BF_word
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|7
operator|+
literal|22
operator|+
literal|31
operator|+
literal|1
condition|)
block|{
name|__set_errno
argument_list|(
name|ERANGE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|setting
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|setting
index|[
literal|1
index|]
operator|!=
literal|'2'
operator|||
name|setting
index|[
literal|2
index|]
operator|<
literal|'a'
operator|||
name|setting
index|[
literal|2
index|]
operator|>
literal|'z'
operator|||
operator|!
name|flags_by_subtype
index|[
operator|(
name|unsigned
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|setting
index|[
literal|2
index|]
operator|-
literal|'a'
index|]
operator|||
name|setting
index|[
literal|3
index|]
operator|!=
literal|'$'
operator|||
name|setting
index|[
literal|4
index|]
operator|<
literal|'0'
operator|||
name|setting
index|[
literal|4
index|]
operator|>
literal|'3'
operator|||
name|setting
index|[
literal|5
index|]
operator|<
literal|'0'
operator|||
name|setting
index|[
literal|5
index|]
operator|>
literal|'9'
operator|||
operator|(
name|setting
index|[
literal|4
index|]
operator|==
literal|'3'
operator|&&
name|setting
index|[
literal|5
index|]
operator|>
literal|'1'
operator|)
operator|||
name|setting
index|[
literal|6
index|]
operator|!=
literal|'$'
condition|)
block|{
name|__set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|count
operator|=
operator|(
name|BF_word
operator|)
literal|1
operator|<<
operator|(
operator|(
name|setting
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|setting
index|[
literal|5
index|]
operator|-
literal|'0'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|min
operator|||
name|BF_decode
argument_list|(
name|data
operator|.
name|binary
operator|.
name|salt
argument_list|,
operator|&
name|setting
index|[
literal|7
index|]
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|__set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|BF_swap
argument_list|(
name|data
operator|.
name|binary
operator|.
name|salt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|BF_set_key
argument_list|(
name|key
argument_list|,
name|data
operator|.
name|expanded_key
argument_list|,
name|data
operator|.
name|ctx
operator|.
name|P
argument_list|,
name|flags_by_subtype
index|[
operator|(
name|unsigned
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|setting
index|[
literal|2
index|]
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|.
name|ctx
operator|.
name|S
argument_list|,
name|BF_init_state
operator|.
name|S
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|.
name|ctx
operator|.
name|S
argument_list|)
argument_list|)
expr_stmt|;
name|L
operator|=
name|R
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BF_N
operator|+
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|L
operator|^=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
name|i
operator|&
literal|2
index|]
expr_stmt|;
name|R
operator|^=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
operator|(
name|i
operator|&
literal|2
operator|)
operator|+
literal|1
index|]
expr_stmt|;
name|BF_ENCRYPT
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
index|]
operator|=
name|L
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|R
expr_stmt|;
block|}
name|ptr
operator|=
name|data
operator|.
name|ctx
operator|.
name|S
index|[
literal|0
index|]
expr_stmt|;
do|do
block|{
name|ptr
operator|+=
literal|4
expr_stmt|;
name|L
operator|^=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
operator|(
name|BF_N
operator|+
literal|2
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|R
operator|^=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
operator|(
name|BF_N
operator|+
literal|3
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|BF_ENCRYPT
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|4
operator|)
operator|=
name|L
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|3
operator|)
operator|=
name|R
expr_stmt|;
name|L
operator|^=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
operator|(
name|BF_N
operator|+
literal|4
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|R
operator|^=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
operator|(
name|BF_N
operator|+
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|BF_ENCRYPT
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|2
operator|)
operator|=
name|L
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|=
name|R
expr_stmt|;
block|}
do|while
condition|(
name|ptr
operator|<
operator|&
name|data
operator|.
name|ctx
operator|.
name|S
index|[
literal|3
index|]
index|[
literal|0xFF
index|]
condition|)
do|;
do|do
block|{
name|int
name|done
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BF_N
operator|+
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
index|]
operator|^=
name|data
operator|.
name|expanded_key
index|[
name|i
index|]
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
operator|+
literal|1
index|]
operator|^=
name|data
operator|.
name|expanded_key
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|done
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|BF_body
argument_list|()
expr_stmt|;
if|if
condition|(
name|done
condition|)
break|break;
name|done
operator|=
literal|1
expr_stmt|;
name|tmp1
operator|=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
literal|0
index|]
expr_stmt|;
name|tmp2
operator|=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
literal|1
index|]
expr_stmt|;
name|tmp3
operator|=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
literal|2
index|]
expr_stmt|;
name|tmp4
operator|=
name|data
operator|.
name|binary
operator|.
name|salt
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BF_N
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
index|]
operator|^=
name|tmp1
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
operator|+
literal|1
index|]
operator|^=
name|tmp2
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
operator|+
literal|2
index|]
operator|^=
name|tmp3
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
name|i
operator|+
literal|3
index|]
operator|^=
name|tmp4
expr_stmt|;
block|}
name|data
operator|.
name|ctx
operator|.
name|P
index|[
literal|16
index|]
operator|^=
name|tmp1
expr_stmt|;
name|data
operator|.
name|ctx
operator|.
name|P
index|[
literal|17
index|]
operator|^=
name|tmp2
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|L
operator|=
name|BF_magic_w
index|[
name|i
index|]
expr_stmt|;
name|R
operator|=
name|BF_magic_w
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|count
operator|=
literal|64
expr_stmt|;
do|do
block|{
name|BF_ENCRYPT
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
name|data
operator|.
name|binary
operator|.
name|output
index|[
name|i
index|]
operator|=
name|L
expr_stmt|;
name|data
operator|.
name|binary
operator|.
name|output
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|R
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|output
argument_list|,
name|setting
argument_list|,
literal|7
operator|+
literal|22
operator|-
literal|1
argument_list|)
expr_stmt|;
name|output
index|[
literal|7
operator|+
literal|22
operator|-
literal|1
index|]
operator|=
name|BF_itoa64
index|[
operator|(
name|int
operator|)
name|BF_atoi64
index|[
operator|(
name|int
operator|)
name|setting
index|[
literal|7
operator|+
literal|22
operator|-
literal|1
index|]
operator|-
literal|0x20
index|]
operator|&
literal|0x30
index|]
expr_stmt|;
comment|/* This has to be bug-compatible with the original implementation, so  * only encode 23 of the 24 bytes. :-) */
name|BF_swap
argument_list|(
name|data
operator|.
name|binary
operator|.
name|output
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|BF_encode
argument_list|(
operator|&
name|output
index|[
literal|7
operator|+
literal|22
index|]
argument_list|,
name|data
operator|.
name|binary
operator|.
name|output
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|output
index|[
literal|7
operator|+
literal|22
operator|+
literal|31
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_function
name|int
name|_crypt_output_magic
parameter_list|(
specifier|const
name|char
modifier|*
name|setting
parameter_list|,
name|char
modifier|*
name|output
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|3
condition|)
return|return
operator|-
literal|1
return|;
name|output
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|setting
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|setting
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
name|output
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Please preserve the runtime self-test.  It serves two purposes at once:  *  * 1. We really can't afford the risk of producing incompatible hashes e.g.  * when there's something like gcc bug 26587 again, whereas an application or  * library integrating this code might not also integrate our external tests or  * it might not run them after every build.  Even if it does, the miscompile  * might only occur on the production build, but not on a testing build (such  * as because of different optimization settings).  It is painful to recover  * from incorrectly-computed hashes - merely fixing whatever broke is not  * enough.  Thus, a proactive measure like this self-test is needed.  *  * 2. We don't want to leave sensitive data from our actual password hash  * computation on the stack or in registers.  Previous revisions of the code  * would do explicit cleanups, but simply running the self-test after hash  * computation is more reliable.  *  * The performance cost of this quick self-test is around 0.6% at the "$2a$08"  * setting.  */
end_comment

begin_function
name|char
modifier|*
name|_crypt_blowfish_rn
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|setting
parameter_list|,
name|char
modifier|*
name|output
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|test_key
init|=
literal|"8b \xd0\xc1\xd2\xcf\xcc\xd8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|test_setting
init|=
literal|"$2a$00$abcdefghijklmnopqrstuu"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|test_hash
index|[
literal|2
index|]
init|=
block|{
literal|"VUrPmXD6q/nVSSp7pNDhCR9071IfIRe\0\x55"
block|,
comment|/* $2x$ */
literal|"i1D709vfamulimlGcq0qq3UvuUasvEa\0\x55"
block|}
decl_stmt|;
comment|/* $2a$, $2y$ */
name|char
modifier|*
name|retval
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|save_errno
decl_stmt|,
name|ok
decl_stmt|;
struct|struct
block|{
name|char
name|s
index|[
literal|7
operator|+
literal|22
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|o
index|[
literal|7
operator|+
literal|22
operator|+
literal|31
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|buf
struct|;
comment|/* Hash the supplied password */
name|_crypt_output_magic
argument_list|(
name|setting
argument_list|,
name|output
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|retval
operator|=
name|BF_crypt
argument_list|(
name|key
argument_list|,
name|setting
argument_list|,
name|output
argument_list|,
name|size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/*  * Do a quick self-test.  It is important that we make both calls to BF_crypt()  * from the same scope such that they likely use the same stack locations,  * which makes the second call overwrite the first call's sensitive data on the  * stack and makes it more likely that any alignment related issues would be  * detected by the self-test.  */
name|memcpy
argument_list|(
name|buf
operator|.
name|s
argument_list|,
name|test_setting
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|buf
operator|.
name|s
index|[
literal|2
index|]
operator|=
name|setting
index|[
literal|2
index|]
expr_stmt|;
name|memset
argument_list|(
name|buf
operator|.
name|o
argument_list|,
literal|0x55
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|o
index|[
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|o
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|BF_crypt
argument_list|(
name|test_key
argument_list|,
name|buf
operator|.
name|s
argument_list|,
name|buf
operator|.
name|o
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|o
argument_list|)
operator|-
operator|(
literal|1
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|(
name|p
operator|==
name|buf
operator|.
name|o
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|buf
operator|.
name|s
argument_list|,
literal|7
operator|+
literal|22
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
operator|+
operator|(
literal|7
operator|+
literal|22
operator|)
argument_list|,
name|test_hash
index|[
operator|(
name|unsigned
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf
operator|.
name|s
index|[
literal|2
index|]
operator|&
literal|1
index|]
argument_list|,
literal|31
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|k
init|=
literal|"\xff\xa3"
literal|"34"
literal|"\xff\xff\xff\xa3"
literal|"345"
decl_stmt|;
name|BF_key
name|ae
decl_stmt|,
name|ai
decl_stmt|,
name|ye
decl_stmt|,
name|yi
decl_stmt|;
name|BF_set_key
argument_list|(
name|k
argument_list|,
name|ae
argument_list|,
name|ai
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* $2a$ */
name|BF_set_key
argument_list|(
name|k
argument_list|,
name|ye
argument_list|,
name|yi
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* $2y$ */
name|ai
index|[
literal|0
index|]
operator|^=
literal|0x10000
expr_stmt|;
comment|/* undo the safety (for comparison) */
name|ok
operator|=
name|ok
operator|&&
name|ai
index|[
literal|0
index|]
operator|==
literal|0xdb9c59bc
operator|&&
name|ye
index|[
literal|17
index|]
operator|==
literal|0x33343500
operator|&&
operator|!
name|memcmp
argument_list|(
name|ae
argument_list|,
name|ye
argument_list|,
sizeof|sizeof
argument_list|(
name|ae
argument_list|)
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|ai
argument_list|,
name|yi
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__set_errno
argument_list|(
name|save_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|retval
return|;
comment|/* Should not happen */
name|_crypt_output_magic
argument_list|(
name|setting
argument_list|,
name|output
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* pretend we don't support this hash type */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|_crypt_gensalt_blowfish_rn
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|output
parameter_list|,
name|int
name|output_size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|16
operator|||
name|output_size
operator|<
literal|7
operator|+
literal|22
operator|+
literal|1
operator|||
operator|(
name|count
operator|&&
operator|(
name|count
operator|<
literal|4
operator|||
name|count
operator|>
literal|31
operator|)
operator|)
operator|||
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|prefix
index|[
literal|1
index|]
operator|!=
literal|'2'
operator|||
operator|(
name|prefix
index|[
literal|2
index|]
operator|!=
literal|'a'
operator|&&
name|prefix
index|[
literal|2
index|]
operator|!=
literal|'y'
operator|)
condition|)
block|{
if|if
condition|(
name|output_size
operator|>
literal|0
condition|)
name|output
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|__set_errno
argument_list|(
operator|(
name|output_size
operator|<
literal|7
operator|+
literal|22
operator|+
literal|1
operator|)
condition|?
name|ERANGE
else|:
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
name|count
operator|=
literal|5
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
literal|'2'
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
name|prefix
index|[
literal|2
index|]
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|=
literal|'$'
expr_stmt|;
name|output
index|[
literal|4
index|]
operator|=
literal|'0'
operator|+
name|count
operator|/
literal|10
expr_stmt|;
name|output
index|[
literal|5
index|]
operator|=
literal|'0'
operator|+
name|count
operator|%
literal|10
expr_stmt|;
name|output
index|[
literal|6
index|]
operator|=
literal|'$'
expr_stmt|;
name|BF_encode
argument_list|(
operator|&
name|output
index|[
literal|7
index|]
argument_list|,
operator|(
specifier|const
name|BF_word
operator|*
operator|)
name|input
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|output
index|[
literal|7
operator|+
literal|22
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

end_unit

