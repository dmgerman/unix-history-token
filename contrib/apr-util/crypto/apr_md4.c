begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  * This is derived from material copyright RSA Data Security, Inc.  * Their notice is reproduced below in its entirety.  *  * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All  * rights reserved.  *  * License to copy and use this software is granted provided that it  * is identified as the "RSA Data Security, Inc. MD4 Message-Digest  * Algorithm" in all material mentioning or referencing this software  * or this function.  *  * License is also granted to make and use derivative works provided  * that such works are identified as "derived from the RSA Data  * Security, Inc. MD4 Message-Digest Algorithm" in all material  * mentioning or referencing the derived work.  *  * RSA Data Security, Inc. makes no representations concerning either  * the merchantability of this software or the suitability of this  * software for any particular purpose. It is provided "as is"  * without express or implied warranty of any kind.  *  * These notices must be retained in any copies of any part of this  * documentation and/or software.  */
end_comment

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_md4.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Constants for MD4Transform routine.  */
end_comment

begin_define
define|#
directive|define
name|S11
value|3
end_define

begin_define
define|#
directive|define
name|S12
value|7
end_define

begin_define
define|#
directive|define
name|S13
value|11
end_define

begin_define
define|#
directive|define
name|S14
value|19
end_define

begin_define
define|#
directive|define
name|S21
value|3
end_define

begin_define
define|#
directive|define
name|S22
value|5
end_define

begin_define
define|#
directive|define
name|S23
value|9
end_define

begin_define
define|#
directive|define
name|S24
value|13
end_define

begin_define
define|#
directive|define
name|S31
value|3
end_define

begin_define
define|#
directive|define
name|S32
value|9
end_define

begin_define
define|#
directive|define
name|S33
value|11
end_define

begin_define
define|#
directive|define
name|S34
value|15
end_define

begin_function_decl
specifier|static
name|void
name|MD4Transform
parameter_list|(
name|apr_uint32_t
name|state
index|[
literal|4
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|block
index|[
literal|64
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Encode
parameter_list|(
name|unsigned
name|char
modifier|*
name|output
parameter_list|,
specifier|const
name|apr_uint32_t
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Decode
parameter_list|(
name|apr_uint32_t
modifier|*
name|output
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|PADDING
index|[
literal|64
index|]
init|=
block|{
literal|0x80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|APR_CHARSET_EBCDIC
end_if

begin_decl_stmt
specifier|static
name|apr_xlate_t
modifier|*
name|xlate_ebcdic_to_ascii
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used in apr_md4_encode() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F, G and I are basic MD4 functions.  */
end_comment

begin_define
define|#
directive|define
name|F
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x)& (y)) | ((~x)& (z)))
end_define

begin_define
define|#
directive|define
name|G
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x)& (y)) | ((x)& (z)) | ((y)& (z)))
end_define

begin_define
define|#
directive|define
name|H
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|((x) ^ (y) ^ (z))
end_define

begin_comment
comment|/* ROTATE_LEFT rotates x left n bits.  */
end_comment

begin_define
define|#
directive|define
name|ROTATE_LEFT
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)<< (n)) | ((x)>> (32-(n))))
end_define

begin_comment
comment|/* FF, GG and HH are transformations for rounds 1, 2 and 3 */
end_comment

begin_comment
comment|/* Rotation is separate from addition to prevent recomputation */
end_comment

begin_define
define|#
directive|define
name|FF
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|)
value|{ \   (a) += F ((b), (c), (d)) + (x); \   (a) = ROTATE_LEFT ((a), (s)); \   }
end_define

begin_define
define|#
directive|define
name|GG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|)
value|{ \   (a) += G ((b), (c), (d)) + (x) + (apr_uint32_t)0x5a827999; \   (a) = ROTATE_LEFT ((a), (s)); \   }
end_define

begin_define
define|#
directive|define
name|HH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|)
value|{ \   (a) += H ((b), (c), (d)) + (x) + (apr_uint32_t)0x6ed9eba1; \   (a) = ROTATE_LEFT ((a), (s)); \   }
end_define

begin_comment
comment|/* MD4 initialization. Begins an MD4 operation, writing a new context.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md4_init
argument_list|(
argument|apr_md4_ctx_t *context
argument_list|)
end_macro

begin_block
block|{
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|count
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Load magic initialization constants. */
name|context
operator|->
name|state
index|[
literal|0
index|]
operator|=
literal|0x67452301
expr_stmt|;
name|context
operator|->
name|state
index|[
literal|1
index|]
operator|=
literal|0xefcdab89
expr_stmt|;
name|context
operator|->
name|state
index|[
literal|2
index|]
operator|=
literal|0x98badcfe
expr_stmt|;
name|context
operator|->
name|state
index|[
literal|3
index|]
operator|=
literal|0x10325476
expr_stmt|;
if|#
directive|if
name|APR_HAS_XLATE
name|context
operator|->
name|xlate
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_if
if|#
directive|if
name|APR_HAS_XLATE
end_if

begin_comment
comment|/* MD4 translation setup.  Provides the APR translation handle  * to be used for translating the content before calculating the  * digest.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md4_set_xlate
argument_list|(
argument|apr_md4_ctx_t *context
argument_list|,
argument|apr_xlate_t *xlate
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|int
name|is_sb
decl_stmt|;
comment|/* TODO: remove the single-byte-only restriction from this code      */
name|rv
operator|=
name|apr_xlate_sb_get
argument_list|(
name|xlate
argument_list|,
operator|&
name|is_sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|!
name|is_sb
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
name|context
operator|->
name|xlate
operator|=
name|xlate
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_XLATE */
end_comment

begin_comment
comment|/* MD4 block update operation. Continues an MD4 message-digest  * operation, processing another message block, and updating the  * context.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md4_update
argument_list|(
argument|apr_md4_ctx_t *context
argument_list|,
argument|const unsigned char *input
argument_list|,
argument|apr_size_t inputLen
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|partLen
decl_stmt|;
if|#
directive|if
name|APR_HAS_XLATE
name|apr_size_t
name|inbytes_left
decl_stmt|,
name|outbytes_left
decl_stmt|;
endif|#
directive|endif
comment|/* Compute number of bytes mod 64 */
name|idx
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
comment|/* Update number of bits */
if|if
condition|(
operator|(
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|apr_uint32_t
operator|)
name|inputLen
operator|<<
literal|3
operator|)
operator|)
operator|<
operator|(
operator|(
name|apr_uint32_t
operator|)
name|inputLen
operator|<<
literal|3
operator|)
condition|)
name|context
operator|->
name|count
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|context
operator|->
name|count
index|[
literal|1
index|]
operator|+=
operator|(
name|apr_uint32_t
operator|)
name|inputLen
operator|>>
literal|29
expr_stmt|;
name|partLen
operator|=
literal|64
operator|-
name|idx
expr_stmt|;
comment|/* Transform as many times as possible. */
if|#
directive|if
operator|!
name|APR_HAS_XLATE
if|if
condition|(
name|inputLen
operator|>=
name|partLen
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
name|input
argument_list|,
name|partLen
argument_list|)
expr_stmt|;
name|MD4Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partLen
init|;
name|i
operator|+
literal|63
operator|<
name|inputLen
condition|;
name|i
operator|+=
literal|64
control|)
name|MD4Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Buffer remaining input */
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|,
name|inputLen
operator|-
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*APR_HAS_XLATE*/
if|if
condition|(
name|inputLen
operator|>=
name|partLen
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|xlate
condition|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|partLen
expr_stmt|;
name|apr_xlate_conv_buffer
argument_list|(
name|context
operator|->
name|xlate
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|input
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
name|input
argument_list|,
name|partLen
argument_list|)
expr_stmt|;
block|}
name|MD4Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partLen
init|;
name|i
operator|+
literal|63
operator|<
name|inputLen
condition|;
name|i
operator|+=
literal|64
control|)
block|{
if|if
condition|(
name|context
operator|->
name|xlate
condition|)
block|{
name|unsigned
name|char
name|inp_tmp
index|[
literal|64
index|]
decl_stmt|;
name|inbytes_left
operator|=
name|outbytes_left
operator|=
literal|64
expr_stmt|;
name|apr_xlate_conv_buffer
argument_list|(
name|context
operator|->
name|xlate
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|input
index|[
name|i
index|]
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp_tmp
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
name|MD4Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
name|inp_tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MD4Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Buffer remaining input */
if|if
condition|(
name|context
operator|->
name|xlate
condition|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|inputLen
operator|-
name|i
expr_stmt|;
name|apr_xlate_conv_buffer
argument_list|(
name|context
operator|->
name|xlate
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|input
index|[
name|i
index|]
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|,
name|inputLen
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*APR_HAS_XLATE*/
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* MD4 finalization. Ends an MD4 message-digest operation, writing the  * the message digest and zeroizing the context.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md4_final
argument_list|(
argument|unsigned char digest[APR_MD4_DIGESTSIZE]
argument_list|,
argument|apr_md4_ctx_t *context
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|bits
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|padLen
decl_stmt|;
comment|/* Save number of bits */
name|Encode
argument_list|(
name|bits
argument_list|,
name|context
operator|->
name|count
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_XLATE
comment|/* apr_md4_update() should not translate for this final round. */
name|context
operator|->
name|xlate
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/*APR_HAS_XLATE*/
comment|/* Pad out to 56 mod 64. */
name|idx
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
name|padLen
operator|=
operator|(
name|idx
operator|<
literal|56
operator|)
condition|?
operator|(
literal|56
operator|-
name|idx
operator|)
else|:
operator|(
literal|120
operator|-
name|idx
operator|)
expr_stmt|;
name|apr_md4_update
argument_list|(
name|context
argument_list|,
name|PADDING
argument_list|,
name|padLen
argument_list|)
expr_stmt|;
comment|/* Append length (before padding) */
name|apr_md4_update
argument_list|(
name|context
argument_list|,
name|bits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Store state in digest */
name|Encode
argument_list|(
name|digest
argument_list|,
name|context
operator|->
name|state
argument_list|,
name|APR_MD4_DIGESTSIZE
argument_list|)
expr_stmt|;
comment|/* Zeroize sensitive information. */
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* MD4 computation in one step (init, update, final)  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md4
argument_list|(
argument|unsigned char digest[APR_MD4_DIGESTSIZE]
argument_list|,
argument|const unsigned char *input
argument_list|,
argument|apr_size_t inputLen
argument_list|)
end_macro

begin_block
block|{
name|apr_md4_ctx_t
name|ctx
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_md4_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_md4_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|input
argument_list|,
name|inputLen
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|rv
return|;
return|return
name|apr_md4_final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* MD4 basic transformation. Transforms state based on block. */
end_comment

begin_function
specifier|static
name|void
name|MD4Transform
parameter_list|(
name|apr_uint32_t
name|state
index|[
literal|4
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|block
index|[
literal|64
index|]
parameter_list|)
block|{
name|apr_uint32_t
name|a
init|=
name|state
index|[
literal|0
index|]
decl_stmt|,
name|b
init|=
name|state
index|[
literal|1
index|]
decl_stmt|,
name|c
init|=
name|state
index|[
literal|2
index|]
decl_stmt|,
name|d
init|=
name|state
index|[
literal|3
index|]
decl_stmt|,
name|x
index|[
name|APR_MD4_DIGESTSIZE
index|]
decl_stmt|;
name|Decode
argument_list|(
name|x
argument_list|,
name|block
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* Round 1 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S11
argument_list|)
expr_stmt|;
comment|/* 1 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S12
argument_list|)
expr_stmt|;
comment|/* 2 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S13
argument_list|)
expr_stmt|;
comment|/* 3 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S14
argument_list|)
expr_stmt|;
comment|/* 4 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S11
argument_list|)
expr_stmt|;
comment|/* 5 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S12
argument_list|)
expr_stmt|;
comment|/* 6 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S13
argument_list|)
expr_stmt|;
comment|/* 7 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S14
argument_list|)
expr_stmt|;
comment|/* 8 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S11
argument_list|)
expr_stmt|;
comment|/* 9 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S12
argument_list|)
expr_stmt|;
comment|/* 10 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S13
argument_list|)
expr_stmt|;
comment|/* 11 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S14
argument_list|)
expr_stmt|;
comment|/* 12 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S11
argument_list|)
expr_stmt|;
comment|/* 13 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S12
argument_list|)
expr_stmt|;
comment|/* 14 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S13
argument_list|)
expr_stmt|;
comment|/* 15 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S14
argument_list|)
expr_stmt|;
comment|/* 16 */
comment|/* Round 2 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S21
argument_list|)
expr_stmt|;
comment|/* 17 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S22
argument_list|)
expr_stmt|;
comment|/* 18 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S23
argument_list|)
expr_stmt|;
comment|/* 19 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S24
argument_list|)
expr_stmt|;
comment|/* 20 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S21
argument_list|)
expr_stmt|;
comment|/* 21 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S22
argument_list|)
expr_stmt|;
comment|/* 22 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S23
argument_list|)
expr_stmt|;
comment|/* 23 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S24
argument_list|)
expr_stmt|;
comment|/* 24 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S21
argument_list|)
expr_stmt|;
comment|/* 25 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S22
argument_list|)
expr_stmt|;
comment|/* 26 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S23
argument_list|)
expr_stmt|;
comment|/* 27 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S24
argument_list|)
expr_stmt|;
comment|/* 28 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S21
argument_list|)
expr_stmt|;
comment|/* 29 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S22
argument_list|)
expr_stmt|;
comment|/* 30 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S23
argument_list|)
expr_stmt|;
comment|/* 31 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S24
argument_list|)
expr_stmt|;
comment|/* 32 */
comment|/* Round 3 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S31
argument_list|)
expr_stmt|;
comment|/* 33 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S32
argument_list|)
expr_stmt|;
comment|/* 34 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S33
argument_list|)
expr_stmt|;
comment|/* 35 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S34
argument_list|)
expr_stmt|;
comment|/* 36 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S31
argument_list|)
expr_stmt|;
comment|/* 37 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S32
argument_list|)
expr_stmt|;
comment|/* 38 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S33
argument_list|)
expr_stmt|;
comment|/* 39 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S34
argument_list|)
expr_stmt|;
comment|/* 40 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S31
argument_list|)
expr_stmt|;
comment|/* 41 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S32
argument_list|)
expr_stmt|;
comment|/* 42 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S33
argument_list|)
expr_stmt|;
comment|/* 43 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S34
argument_list|)
expr_stmt|;
comment|/* 44 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S31
argument_list|)
expr_stmt|;
comment|/* 45 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S32
argument_list|)
expr_stmt|;
comment|/* 46 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S33
argument_list|)
expr_stmt|;
comment|/* 47 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S34
argument_list|)
expr_stmt|;
comment|/* 48 */
name|state
index|[
literal|0
index|]
operator|+=
name|a
expr_stmt|;
name|state
index|[
literal|1
index|]
operator|+=
name|b
expr_stmt|;
name|state
index|[
literal|2
index|]
operator|+=
name|c
expr_stmt|;
name|state
index|[
literal|3
index|]
operator|+=
name|d
expr_stmt|;
comment|/* Zeroize sensitive information. */
name|memset
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encodes input (apr_uint32_t) into output (unsigned char). Assumes len is  * a multiple of 4.  */
end_comment

begin_function
specifier|static
name|void
name|Encode
parameter_list|(
name|unsigned
name|char
modifier|*
name|output
parameter_list|,
specifier|const
name|apr_uint32_t
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|apr_uint32_t
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|4
control|)
block|{
name|k
operator|=
name|input
index|[
name|i
index|]
expr_stmt|;
name|output
index|[
name|j
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|k
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|k
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|k
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|k
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decodes input (unsigned char) into output (apr_uint32_t). Assumes len is  * a multiple of 4.  */
end_comment

begin_function
specifier|static
name|void
name|Decode
parameter_list|(
name|apr_uint32_t
modifier|*
name|output
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|4
control|)
name|output
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
operator|+
literal|2
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
operator|+
literal|3
index|]
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_CHARSET_EBCDIC
end_if

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_MD4InitEBCDIC
argument_list|(
argument|apr_xlate_t *xlate
argument_list|)
end_macro

begin_block
block|{
name|xlate_ebcdic_to_ascii
operator|=
name|xlate
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

