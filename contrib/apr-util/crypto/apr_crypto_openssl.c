begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_include
include|#
directive|include
file|"apu_errno.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_include
include|#
directive|include
file|"apr_buckets.h"
end_include

begin_include
include|#
directive|include
file|"apr_crypto_internal.h"
end_include

begin_if
if|#
directive|if
name|APU_HAVE_CRYPTO
end_if

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_define
define|#
directive|define
name|LOG_PREFIX
value|"apr_crypto_openssl: "
end_define

begin_struct
struct|struct
name|apr_crypto_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
decl_stmt|;
name|apu_err_t
modifier|*
name|result
decl_stmt|;
name|apr_array_header_t
modifier|*
name|keys
decl_stmt|;
name|apr_crypto_config_t
modifier|*
name|config
decl_stmt|;
name|apr_hash_t
modifier|*
name|types
decl_stmt|;
name|apr_hash_t
modifier|*
name|modes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_crypto_config_t
block|{
name|ENGINE
modifier|*
name|engine
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_crypto_key_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
decl_stmt|;
specifier|const
name|apr_crypto_t
modifier|*
name|f
decl_stmt|;
specifier|const
name|EVP_CIPHER
modifier|*
name|cipher
decl_stmt|;
name|unsigned
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keyLen
decl_stmt|;
name|int
name|doPad
decl_stmt|;
name|int
name|ivSize
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|apr_crypto_block_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
decl_stmt|;
specifier|const
name|apr_crypto_t
modifier|*
name|f
decl_stmt|;
name|EVP_CIPHER_CTX
name|cipherCtx
decl_stmt|;
name|int
name|initialised
decl_stmt|;
name|int
name|ivSize
decl_stmt|;
name|int
name|blockSize
decl_stmt|;
name|int
name|doPad
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|key_3des_192
init|=
name|APR_KEY_3DES_192
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_aes_128
init|=
name|APR_KEY_AES_128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_aes_192
init|=
name|APR_KEY_AES_192
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_aes_256
init|=
name|APR_KEY_AES_256
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mode_ecb
init|=
name|APR_MODE_ECB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mode_cbc
init|=
name|APR_MODE_CBC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Fetch the most recent error from this driver.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_error
parameter_list|(
specifier|const
name|apu_err_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|result
operator|=
name|f
operator|->
name|result
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Shutdown the crypto library and release resources.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|ERR_free_strings
argument_list|()
expr_stmt|;
name|EVP_cleanup
argument_list|()
expr_stmt|;
name|ENGINE_cleanup
argument_list|()
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|crypto_shutdown_helper
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|crypto_shutdown
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * Initialise the crypto library and perform one time initialisation.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
specifier|const
name|apu_err_t
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|CRYPTO_malloc_init
argument_list|()
expr_stmt|;
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
comment|/* SSL_load_error_strings(); */
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
name|ENGINE_load_builtin_engines
argument_list|()
expr_stmt|;
name|ENGINE_register_all_complete
argument_list|()
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|pool
argument_list|,
name|crypto_shutdown_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Clean encryption / decryption context.  * @note After cleanup, a context is free to be reused if necessary.  * @param ctx The block context to use.  * @return Returns APR_ENOTIMPL if not supported.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_cleanup
parameter_list|(
name|apr_crypto_block_t
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|initialised
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|initialised
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|crypto_block_cleanup_helper
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_crypto_block_t
modifier|*
name|block
init|=
operator|(
name|apr_crypto_block_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
name|crypto_block_cleanup
argument_list|(
name|block
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Clean encryption / decryption context.  * @note After cleanup, a context is free to be reused if necessary.  * @param f The context to use.  * @return Returns APR_ENOTIMPL if not supported.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_cleanup
parameter_list|(
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|config
operator|->
name|engine
condition|)
block|{
name|ENGINE_finish
argument_list|(
name|f
operator|->
name|config
operator|->
name|engine
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|f
operator|->
name|config
operator|->
name|engine
argument_list|)
expr_stmt|;
name|f
operator|->
name|config
operator|->
name|engine
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|crypto_cleanup_helper
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_crypto_t
modifier|*
name|f
init|=
operator|(
name|apr_crypto_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
name|crypto_cleanup
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Create a context for supporting encryption. Keys, certificates,  *        algorithms and other parameters will be set per context. More than  *        one context can be created at one time. A cleanup will be automatically  *        registered with the given pool to guarantee a graceful shutdown.  * @param f - context pointer will be written here  * @param provider - provider to use  * @param params - array of key parameters  * @param pool - process pool  * @return APR_ENOENGINE when the engine specified does not exist. APR_EINITENGINE  * if the engine cannot be initialised.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_make
parameter_list|(
name|apr_crypto_t
modifier|*
modifier|*
name|ff
parameter_list|,
specifier|const
name|apr_crypto_driver_t
modifier|*
name|provider
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_crypto_config_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|apr_crypto_t
modifier|*
name|f
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_t
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|engine
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|set
decl_stmt|;
block|}
name|fields
index|[]
init|=
block|{
block|{
literal|"engine"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|klen
decl_stmt|;
name|char
modifier|*
modifier|*
name|elts
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|elt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|params
condition|)
block|{
if|if
condition|(
name|APR_SUCCESS
operator|!=
operator|(
name|status
operator|=
name|apr_tokenize_to_argv
argument_list|(
name|params
argument_list|,
operator|&
name|elts
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
while|while
condition|(
operator|(
name|elt
operator|=
name|elts
index|[
name|i
index|]
operator|)
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|elt
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
for|for
control|(
name|klen
operator|=
name|ptr
operator|-
name|elt
init|;
name|klen
operator|&&
name|apr_isspace
argument_list|(
name|elt
index|[
name|klen
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|klen
control|)
empty_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|klen
operator|=
name|strlen
argument_list|(
name|elt
argument_list|)
init|;
name|klen
operator|&&
name|apr_isspace
argument_list|(
name|elt
index|[
name|klen
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|klen
control|)
empty_stmt|;
block|}
name|elt
index|[
name|klen
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|fields
index|[
name|j
index|]
operator|.
name|field
operator|!=
name|NULL
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|fields
index|[
name|j
index|]
operator|.
name|field
argument_list|,
name|elt
argument_list|)
condition|)
block|{
name|fields
index|[
name|j
index|]
operator|.
name|set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|fields
index|[
name|j
index|]
operator|.
name|value
operator|=
name|ptr
expr_stmt|;
block|}
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
name|engine
operator|=
name|fields
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
operator|*
name|ff
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|f
operator|->
name|provider
operator|=
name|provider
expr_stmt|;
name|config
operator|=
name|f
operator|->
name|config
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|f
operator|->
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apu_err_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|result
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|f
operator|->
name|keys
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_key_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|keys
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|f
operator|->
name|types
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|types
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"3des192"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_3des_192
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"aes128"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_aes_128
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"aes192"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_aes_192
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|types
argument_list|,
literal|"aes256"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|key_aes_256
operator|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|modes
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|modes
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_hash_set
argument_list|(
name|f
operator|->
name|modes
argument_list|,
literal|"ecb"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|mode_ecb
operator|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|f
operator|->
name|modes
argument_list|,
literal|"cbc"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
operator|&
operator|(
name|mode_cbc
operator|)
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|f
argument_list|,
name|crypto_cleanup_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
condition|)
block|{
name|config
operator|->
name|engine
operator|=
name|ENGINE_by_id
argument_list|(
name|engine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|->
name|engine
condition|)
block|{
return|return
name|APR_ENOENGINE
return|;
block|}
if|if
condition|(
operator|!
name|ENGINE_init
argument_list|(
name|config
operator|->
name|engine
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|config
operator|->
name|engine
argument_list|)
expr_stmt|;
name|config
operator|->
name|engine
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_EINITENGINE
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Get a hash table of key types, keyed by the name of the type against  * an integer pointer constant.  *  * @param types - hashtable of key types keyed to constants.  * @param f - encryption context  * @return APR_SUCCESS for success  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_get_block_key_types
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|types
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|types
operator|=
name|f
operator|->
name|types
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Get a hash table of key modes, keyed by the name of the mode against  * an integer pointer constant.  *  * @param modes - hashtable of key modes keyed to constants.  * @param f - encryption context  * @return APR_SUCCESS for success  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_get_block_key_modes
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|modes
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|)
block|{
operator|*
name|modes
operator|=
name|f
operator|->
name|modes
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Create a key from the given passphrase. By default, the PBKDF2  *        algorithm is used to generate the key from the passphrase. It is expected  *        that the same pass phrase will generate the same key, regardless of the  *        backend crypto platform used. The key is cleaned up when the context  *        is cleaned, and may be reused with multiple encryption or decryption  *        operations.  * @note If *key is NULL, a apr_crypto_key_t will be created from a pool. If  *       *key is not NULL, *key must point at a previously created structure.  * @param key The key returned, see note.  * @param ivSize The size of the initialisation vector will be returned, based  *               on whether an IV is relevant for this type of crypto.  * @param pass The passphrase to use.  * @param passLen The passphrase length in bytes  * @param salt The salt to use.  * @param saltLen The salt length in bytes  * @param type 3DES_192, AES_128, AES_192, AES_256.  * @param mode Electronic Code Book / Cipher Block Chaining.  * @param doPad Pad if necessary.  * @param iterations Iteration count  * @param f The context to use.  * @param p The pool to use.  * @return Returns APR_ENOKEY if the pass phrase is missing or empty, or if a backend  *         error occurred while generating the key. APR_ENOCIPHER if the type or mode  *         is not supported by the particular backend. APR_EKEYTYPE if the key type is  *         not known. APR_EPADDING if padding was requested but is not supported.  *         APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_passphrase
parameter_list|(
name|apr_crypto_key_t
modifier|*
modifier|*
name|k
parameter_list|,
name|apr_size_t
modifier|*
name|ivSize
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|,
name|apr_size_t
name|passLen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|salt
parameter_list|,
name|apr_size_t
name|saltLen
parameter_list|,
specifier|const
name|apr_crypto_block_key_type_e
name|type
parameter_list|,
specifier|const
name|apr_crypto_block_key_mode_e
name|mode
parameter_list|,
specifier|const
name|int
name|doPad
parameter_list|,
specifier|const
name|int
name|iterations
parameter_list|,
specifier|const
name|apr_crypto_t
modifier|*
name|f
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|apr_crypto_key_t
modifier|*
name|key
init|=
operator|*
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
operator|*
name|k
operator|=
name|key
operator|=
name|apr_array_push
argument_list|(
name|f
operator|->
name|keys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|key
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|key
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|key
operator|->
name|provider
operator|=
name|f
operator|->
name|provider
expr_stmt|;
comment|/* determine the cipher to be used */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
operator|(
name|APR_KEY_3DES_192
operator|)
case|:
comment|/* A 3DES key */
if|if
condition|(
name|mode
operator|==
name|APR_MODE_CBC
condition|)
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_des_ede3_cbc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_des_ede3_ecb
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|APR_KEY_AES_128
operator|)
case|:
if|if
condition|(
name|mode
operator|==
name|APR_MODE_CBC
condition|)
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_aes_128_cbc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_aes_128_ecb
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|APR_KEY_AES_192
operator|)
case|:
if|if
condition|(
name|mode
operator|==
name|APR_MODE_CBC
condition|)
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_aes_192_cbc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_aes_192_ecb
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|APR_KEY_AES_256
operator|)
case|:
if|if
condition|(
name|mode
operator|==
name|APR_MODE_CBC
condition|)
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_aes_256_cbc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|cipher
operator|=
name|EVP_aes_256_ecb
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|/* unknown key type, give up */
return|return
name|APR_EKEYTYPE
return|;
block|}
comment|/* find the length of the key we need */
name|key
operator|->
name|keyLen
operator|=
name|EVP_CIPHER_key_length
argument_list|(
name|key
operator|->
name|cipher
argument_list|)
expr_stmt|;
comment|/* make space for the key */
name|key
operator|->
name|key
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
name|key
operator|->
name|keyLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|key
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|p
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keyLen
argument_list|)
expr_stmt|;
comment|/* generate the key */
if|if
condition|(
name|PKCS5_PBKDF2_HMAC_SHA1
argument_list|(
name|pass
argument_list|,
name|passLen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|salt
argument_list|,
name|saltLen
argument_list|,
name|iterations
argument_list|,
name|key
operator|->
name|keyLen
argument_list|,
name|key
operator|->
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|APR_ENOKEY
return|;
block|}
name|key
operator|->
name|doPad
operator|=
name|doPad
expr_stmt|;
comment|/* note: openssl incorrectly returns non zero IV size values for ECB      * algorithms, so work around this by ignoring the IV size.      */
if|if
condition|(
name|APR_MODE_ECB
operator|!=
name|mode
condition|)
block|{
name|key
operator|->
name|ivSize
operator|=
name|EVP_CIPHER_iv_length
argument_list|(
name|key
operator|->
name|cipher
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ivSize
condition|)
block|{
operator|*
name|ivSize
operator|=
name|key
operator|->
name|ivSize
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Initialise a context for encrypting arbitrary data using the given key.  * @note If *ctx is NULL, a apr_crypto_block_t will be created from a pool. If  *       *ctx is not NULL, *ctx must point at a previously created structure.  * @param ctx The block context returned, see note.  * @param iv Optional initialisation vector. If the buffer pointed to is NULL,  *           an IV will be created at random, in space allocated from the pool.  *           If the buffer pointed to is not NULL, the IV in the buffer will be  *           used.  * @param key The key structure.  * @param blockSize The block size of the cipher.  * @param p The pool to use.  * @return Returns APR_ENOIV if an initialisation vector is required but not specified.  *         Returns APR_EINIT if the backend failed to initialise the context. Returns  *         APR_ENOTIMPL if not implemented.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|crypto_block_encrypt_init
parameter_list|(
name|apr_crypto_block_t
modifier|*
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|iv
parameter_list|,
specifier|const
name|apr_crypto_key_t
modifier|*
name|key
parameter_list|,
name|apr_size_t
modifier|*
name|blockSize
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|usedIv
decl_stmt|;
name|apr_crypto_config_t
modifier|*
name|config
init|=
name|key
operator|->
name|f
operator|->
name|config
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block
init|=
operator|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
block|{
operator|*
name|ctx
operator|=
name|block
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_block_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|block
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|block
operator|->
name|f
operator|=
name|key
operator|->
name|f
expr_stmt|;
name|block
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|block
operator|->
name|provider
operator|=
name|key
operator|->
name|provider
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
name|crypto_block_cleanup_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* create a new context for encryption */
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|)
expr_stmt|;
name|block
operator|->
name|initialised
operator|=
literal|1
expr_stmt|;
comment|/* generate an IV, if necessary */
name|usedIv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|ivSize
condition|)
block|{
if|if
condition|(
name|iv
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOIV
return|;
block|}
if|if
condition|(
operator|*
name|iv
operator|==
name|NULL
condition|)
block|{
name|usedIv
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
name|key
operator|->
name|ivSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|usedIv
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|p
argument_list|,
name|usedIv
argument_list|,
name|key
operator|->
name|ivSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|RAND_status
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|RAND_bytes
argument_list|(
name|usedIv
argument_list|,
name|key
operator|->
name|ivSize
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
return|return
name|APR_ENOIV
return|;
block|}
operator|*
name|iv
operator|=
name|usedIv
expr_stmt|;
block|}
else|else
block|{
name|usedIv
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|iv
expr_stmt|;
block|}
block|}
comment|/* set up our encryption context */
if|#
directive|if
name|CRYPTO_OPENSSL_CONST_BUFFERS
if|if
condition|(
operator|!
name|EVP_EncryptInit_ex
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|,
name|key
operator|->
name|cipher
argument_list|,
name|config
operator|->
name|engine
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|usedIv
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|EVP_EncryptInit_ex
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|,
name|key
operator|->
name|cipher
argument_list|,
name|config
operator|->
name|engine
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|->
name|key
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|usedIv
argument_list|)
condition|)
block|{
endif|#
directive|endif
return|return
name|APR_EINIT
return|;
block|}
comment|/* Clear up any read padding */
if|if
condition|(
operator|!
name|EVP_CIPHER_CTX_set_padding
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|,
name|key
operator|->
name|doPad
argument_list|)
condition|)
block|{
return|return
name|APR_EPADDING
return|;
block|}
if|if
condition|(
name|blockSize
condition|)
block|{
operator|*
name|blockSize
operator|=
name|EVP_CIPHER_block_size
argument_list|(
name|key
operator|->
name|cipher
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
comment|/**  * @brief Encrypt data provided by in, write it to out.  * @note The number of bytes written will be written to outlen. If  *       out is NULL, outlen will contain the maximum size of the  *       buffer needed to hold the data, including any data  *       generated by apr_crypto_block_encrypt_finish below. If *out points  *       to NULL, a buffer sufficiently large will be created from  *       the pool provided. If *out points to a not-NULL value, this  *       value will be used as a buffer instead.  * @param out Address of a buffer to which data will be written,  *        see note.  * @param outlen Length of the output will be written here.  * @param in Address of the buffer to read.  * @param inlen Length of the buffer to read.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred. Returns APR_ENOTIMPL if  *         not implemented.  */
specifier|static
name|apr_status_t
name|crypto_block_encrypt
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|apr_size_t
name|inlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|outl
init|=
operator|*
name|outlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* are we after the maximum size of the out buffer? */
if|if
condition|(
operator|!
name|out
condition|)
block|{
operator|*
name|outlen
operator|=
name|inlen
operator|+
name|EVP_MAX_BLOCK_LENGTH
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* must we allocate the output buffer from a pool? */
if|if
condition|(
operator|!
operator|*
name|out
condition|)
block|{
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|inlen
operator|+
name|EVP_MAX_BLOCK_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|buffer
argument_list|,
name|inlen
operator|+
name|EVP_MAX_BLOCK_LENGTH
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|buffer
expr_stmt|;
block|}
if|#
directive|if
name|CRYPT_OPENSSL_CONST_BUFFERS
if|if
condition|(
operator|!
name|EVP_EncryptUpdate
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|,
operator|(
operator|*
name|out
operator|)
argument_list|,
operator|&
name|outl
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|EVP_EncryptUpdate
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|,
operator|(
operator|*
name|out
operator|)
argument_list|,
operator|&
name|outl
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|)
condition|)
block|{
endif|#
directive|endif
return|return
name|APR_ECRYPT
return|;
block|}
operator|*
name|outlen
operator|=
name|outl
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/**  * @brief Encrypt final data block, write it to out.  * @note If necessary the final block will be written out after being  *       padded. Typically the final block will be written to the  *       same buffer used by apr_crypto_block_encrypt, offset by the  *       number of bytes returned as actually written by the  *       apr_crypto_block_encrypt() call. After this call, the context  *       is cleaned and can be reused by apr_crypto_block_encrypt_init().  * @param out Address of a buffer to which data will be written. This  *            buffer must already exist, and is usually the same  *            buffer used by apr_evp_crypt(). See note.  * @param outlen Length of the output will be written here.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred.  * @return APR_EPADDING if padding was enabled and the block was incorrectly  *         formatted.  * @return APR_ENOTIMPL if not implemented.  */
specifier|static
name|apr_status_t
name|crypto_block_encrypt_finish
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|outlen
decl_stmt|;
if|if
condition|(
name|EVP_EncryptFinal_ex
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|,
name|out
argument_list|,
operator|&
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|APR_EPADDING
return|;
block|}
operator|*
name|outlen
operator|=
name|len
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/**  * @brief Initialise a context for decrypting arbitrary data using the given key.  * @note If *ctx is NULL, a apr_crypto_block_t will be created from a pool. If  *       *ctx is not NULL, *ctx must point at a previously created structure.  * @param ctx The block context returned, see note.  * @param blockSize The block size of the cipher.  * @param iv Optional initialisation vector. If the buffer pointed to is NULL,  *           an IV will be created at random, in space allocated from the pool.  *           If the buffer is not NULL, the IV in the buffer will be used.  * @param key The key structure.  * @param p The pool to use.  * @return Returns APR_ENOIV if an initialisation vector is required but not specified.  *         Returns APR_EINIT if the backend failed to initialise the context. Returns  *         APR_ENOTIMPL if not implemented.  */
specifier|static
name|apr_status_t
name|crypto_block_decrypt_init
parameter_list|(
name|apr_crypto_block_t
modifier|*
modifier|*
name|ctx
parameter_list|,
name|apr_size_t
modifier|*
name|blockSize
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
specifier|const
name|apr_crypto_key_t
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|apr_crypto_config_t
modifier|*
name|config
init|=
name|key
operator|->
name|f
operator|->
name|config
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block
init|=
operator|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
block|{
operator|*
name|ctx
operator|=
name|block
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_crypto_block_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|block
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|block
operator|->
name|f
operator|=
name|key
operator|->
name|f
expr_stmt|;
name|block
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|block
operator|->
name|provider
operator|=
name|key
operator|->
name|provider
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
name|crypto_block_cleanup_helper
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* create a new context for encryption */
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|)
expr_stmt|;
name|block
operator|->
name|initialised
operator|=
literal|1
expr_stmt|;
comment|/* generate an IV, if necessary */
if|if
condition|(
name|key
operator|->
name|ivSize
condition|)
block|{
if|if
condition|(
name|iv
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOIV
return|;
block|}
block|}
comment|/* set up our encryption context */
if|#
directive|if
name|CRYPTO_OPENSSL_CONST_BUFFERS
if|if
condition|(
operator|!
name|EVP_DecryptInit_ex
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|,
name|key
operator|->
name|cipher
argument_list|,
name|config
operator|->
name|engine
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|iv
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|EVP_DecryptInit_ex
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|,
name|key
operator|->
name|cipher
argument_list|,
name|config
operator|->
name|engine
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|->
name|key
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|iv
argument_list|)
condition|)
block|{
endif|#
directive|endif
return|return
name|APR_EINIT
return|;
block|}
comment|/* Clear up any read padding */
if|if
condition|(
operator|!
name|EVP_CIPHER_CTX_set_padding
argument_list|(
operator|&
name|block
operator|->
name|cipherCtx
argument_list|,
name|key
operator|->
name|doPad
argument_list|)
condition|)
block|{
return|return
name|APR_EPADDING
return|;
block|}
if|if
condition|(
name|blockSize
condition|)
block|{
operator|*
name|blockSize
operator|=
name|EVP_CIPHER_block_size
argument_list|(
name|key
operator|->
name|cipher
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
comment|/**  * @brief Decrypt data provided by in, write it to out.  * @note The number of bytes written will be written to outlen. If  *       out is NULL, outlen will contain the maximum size of the  *       buffer needed to hold the data, including any data  *       generated by apr_crypto_block_decrypt_finish below. If *out points  *       to NULL, a buffer sufficiently large will be created from  *       the pool provided. If *out points to a not-NULL value, this  *       value will be used as a buffer instead.  * @param out Address of a buffer to which data will be written,  *        see note.  * @param outlen Length of the output will be written here.  * @param in Address of the buffer to read.  * @param inlen Length of the buffer to read.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred. Returns APR_ENOTIMPL if  *         not implemented.  */
specifier|static
name|apr_status_t
name|crypto_block_decrypt
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|apr_size_t
name|inlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|outl
init|=
operator|*
name|outlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* are we after the maximum size of the out buffer? */
if|if
condition|(
operator|!
name|out
condition|)
block|{
operator|*
name|outlen
operator|=
name|inlen
operator|+
name|EVP_MAX_BLOCK_LENGTH
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* must we allocate the output buffer from a pool? */
if|if
condition|(
operator|!
operator|(
operator|*
name|out
operator|)
condition|)
block|{
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|inlen
operator|+
name|EVP_MAX_BLOCK_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|apr_crypto_clear
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|buffer
argument_list|,
name|inlen
operator|+
name|EVP_MAX_BLOCK_LENGTH
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|buffer
expr_stmt|;
block|}
if|#
directive|if
name|CRYPT_OPENSSL_CONST_BUFFERS
if|if
condition|(
operator|!
name|EVP_DecryptUpdate
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|,
operator|*
name|out
argument_list|,
operator|&
name|outl
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|EVP_DecryptUpdate
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|,
operator|*
name|out
argument_list|,
operator|&
name|outl
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|,
name|inlen
argument_list|)
condition|)
block|{
endif|#
directive|endif
return|return
name|APR_ECRYPT
return|;
block|}
operator|*
name|outlen
operator|=
name|outl
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/**  * @brief Decrypt final data block, write it to out.  * @note If necessary the final block will be written out after being  *       padded. Typically the final block will be written to the  *       same buffer used by apr_crypto_block_decrypt, offset by the  *       number of bytes returned as actually written by the  *       apr_crypto_block_decrypt() call. After this call, the context  *       is cleaned and can be reused by apr_crypto_block_decrypt_init().  * @param out Address of a buffer to which data will be written. This  *            buffer must already exist, and is usually the same  *            buffer used by apr_evp_crypt(). See note.  * @param outlen Length of the output will be written here.  * @param ctx The block context to use.  * @return APR_ECRYPT if an error occurred.  * @return APR_EPADDING if padding was enabled and the block was incorrectly  *         formatted.  * @return APR_ENOTIMPL if not implemented.  */
specifier|static
name|apr_status_t
name|crypto_block_decrypt_finish
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|apr_size_t
modifier|*
name|outlen
parameter_list|,
name|apr_crypto_block_t
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|outlen
decl_stmt|;
if|if
condition|(
name|EVP_DecryptFinal_ex
argument_list|(
operator|&
name|ctx
operator|->
name|cipherCtx
argument_list|,
name|out
argument_list|,
operator|&
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|APR_EPADDING
return|;
block|}
operator|*
name|outlen
operator|=
name|len
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/**  * OpenSSL module.  */
name|APU_MODULE_DECLARE_DATA
specifier|const
name|apr_crypto_driver_t
name|apr_crypto_openssl_driver
init|=
block|{
literal|"openssl"
block|,
name|crypto_init
block|,
name|crypto_make
block|,
name|crypto_get_block_key_types
block|,
name|crypto_get_block_key_modes
block|,
name|crypto_passphrase
block|,
name|crypto_block_encrypt_init
block|,
name|crypto_block_encrypt
block|,
name|crypto_block_encrypt_finish
block|,
name|crypto_block_decrypt_init
block|,
name|crypto_block_decrypt
block|,
name|crypto_block_decrypt_finish
block|,
name|crypto_block_cleanup
block|,
name|crypto_cleanup
block|,
name|crypto_shutdown
block|,
name|crypto_error
block|}
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

