begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This is work is derived from material Copyright RSA Data Security, Inc.  *  * The RSA copyright statement and Licence for that original material is  * included below. This is followed by the Apache copyright statement and  * licence for the modifications made to that material.  */
end_comment

begin_comment
comment|/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm  */
end_comment

begin_comment
comment|/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All    rights reserved.     License to copy and use this software is granted provided that it    is identified as the "RSA Data Security, Inc. MD5 Message-Digest    Algorithm" in all material mentioning or referencing this software    or this function.     License is also granted to make and use derivative works provided    that such works are identified as "derived from the RSA Data    Security, Inc. MD5 Message-Digest Algorithm" in all material    mentioning or referencing the derived work.     RSA Data Security, Inc. makes no representations concerning either    the merchantability of this software or the suitability of this    software for any particular purpose. It is provided "as is"    without express or implied warranty of any kind.     These notices must be retained in any copies of any part of this    documentation and/or software.  */
end_comment

begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * The apr_md5_encode() routine uses much code obtained from the FreeBSD 3.0  * MD5 crypt() function, which is licenced as follows:  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_md5.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apu_config.h"
end_include

begin_include
include|#
directive|include
file|"apr_sha1.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_CRYPT_H
end_if

begin_include
include|#
directive|include
file|<crypt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_PTHREAD_H
end_if

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Constants for MD5Transform routine.  */
end_comment

begin_define
define|#
directive|define
name|S11
value|7
end_define

begin_define
define|#
directive|define
name|S12
value|12
end_define

begin_define
define|#
directive|define
name|S13
value|17
end_define

begin_define
define|#
directive|define
name|S14
value|22
end_define

begin_define
define|#
directive|define
name|S21
value|5
end_define

begin_define
define|#
directive|define
name|S22
value|9
end_define

begin_define
define|#
directive|define
name|S23
value|14
end_define

begin_define
define|#
directive|define
name|S24
value|20
end_define

begin_define
define|#
directive|define
name|S31
value|4
end_define

begin_define
define|#
directive|define
name|S32
value|11
end_define

begin_define
define|#
directive|define
name|S33
value|16
end_define

begin_define
define|#
directive|define
name|S34
value|23
end_define

begin_define
define|#
directive|define
name|S41
value|6
end_define

begin_define
define|#
directive|define
name|S42
value|10
end_define

begin_define
define|#
directive|define
name|S43
value|15
end_define

begin_define
define|#
directive|define
name|S44
value|21
end_define

begin_function_decl
specifier|static
name|void
name|MD5Transform
parameter_list|(
name|apr_uint32_t
name|state
index|[
literal|4
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|block
index|[
literal|64
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Encode
parameter_list|(
name|unsigned
name|char
modifier|*
name|output
parameter_list|,
specifier|const
name|apr_uint32_t
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Decode
parameter_list|(
name|apr_uint32_t
modifier|*
name|output
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|PADDING
index|[
literal|64
index|]
init|=
block|{
literal|0x80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|APR_CHARSET_EBCDIC
end_if

begin_decl_stmt
specifier|static
name|apr_xlate_t
modifier|*
name|xlate_ebcdic_to_ascii
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used in apr_md5_encode() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DO_XLATE
value|0
end_define

begin_define
define|#
directive|define
name|SKIP_XLATE
value|1
end_define

begin_comment
comment|/* F, G, H and I are basic MD5 functions.  */
end_comment

begin_define
define|#
directive|define
name|F
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x)& (y)) | ((~x)& (z)))
end_define

begin_define
define|#
directive|define
name|G
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x)& (z)) | ((y)& (~z)))
end_define

begin_define
define|#
directive|define
name|H
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|((x) ^ (y) ^ (z))
end_define

begin_define
define|#
directive|define
name|I
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|((y) ^ ((x) | (~z)))
end_define

begin_comment
comment|/* ROTATE_LEFT rotates x left n bits.  */
end_comment

begin_define
define|#
directive|define
name|ROTATE_LEFT
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)<< (n)) | ((x)>> (32-(n))))
end_define

begin_comment
comment|/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.  * Rotation is separate from addition to prevent recomputation.  */
end_comment

begin_define
define|#
directive|define
name|FF
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|,
name|ac
parameter_list|)
value|{ \  (a) += F ((b), (c), (d)) + (x) + (apr_uint32_t)(ac); \  (a) = ROTATE_LEFT ((a), (s)); \  (a) += (b); \   }
end_define

begin_define
define|#
directive|define
name|GG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|,
name|ac
parameter_list|)
value|{ \  (a) += G ((b), (c), (d)) + (x) + (apr_uint32_t)(ac); \  (a) = ROTATE_LEFT ((a), (s)); \  (a) += (b); \   }
end_define

begin_define
define|#
directive|define
name|HH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|,
name|ac
parameter_list|)
value|{ \  (a) += H ((b), (c), (d)) + (x) + (apr_uint32_t)(ac); \  (a) = ROTATE_LEFT ((a), (s)); \  (a) += (b); \   }
end_define

begin_define
define|#
directive|define
name|II
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|x
parameter_list|,
name|s
parameter_list|,
name|ac
parameter_list|)
value|{ \  (a) += I ((b), (c), (d)) + (x) + (apr_uint32_t)(ac); \  (a) = ROTATE_LEFT ((a), (s)); \  (a) += (b); \   }
end_define

begin_comment
comment|/* MD5 initialization. Begins an MD5 operation, writing a new context.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md5_init
argument_list|(
argument|apr_md5_ctx_t *context
argument_list|)
end_macro

begin_block
block|{
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|count
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Load magic initialization constants. */
name|context
operator|->
name|state
index|[
literal|0
index|]
operator|=
literal|0x67452301
expr_stmt|;
name|context
operator|->
name|state
index|[
literal|1
index|]
operator|=
literal|0xefcdab89
expr_stmt|;
name|context
operator|->
name|state
index|[
literal|2
index|]
operator|=
literal|0x98badcfe
expr_stmt|;
name|context
operator|->
name|state
index|[
literal|3
index|]
operator|=
literal|0x10325476
expr_stmt|;
name|context
operator|->
name|xlate
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* MD5 translation setup.  Provides the APR translation handle  * to be used for translating the content before calculating the  * digest.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md5_set_xlate
argument_list|(
argument|apr_md5_ctx_t *context
argument_list|,
argument|apr_xlate_t *xlate
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_HAS_XLATE
name|apr_status_t
name|rv
decl_stmt|;
name|int
name|is_sb
decl_stmt|;
comment|/* TODO: remove the single-byte-only restriction from this code      */
name|rv
operator|=
name|apr_xlate_sb_get
argument_list|(
name|xlate
argument_list|,
operator|&
name|is_sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|!
name|is_sb
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
name|context
operator|->
name|xlate
operator|=
name|xlate
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
comment|/* APR_HAS_XLATE */
block|}
end_block

begin_comment
comment|/* MD5 block update operation. Continues an MD5 message-digest  * operation, processing another message block, and updating the  * context.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|md5_update_buffer
parameter_list|(
name|apr_md5_ctx_t
modifier|*
name|context
parameter_list|,
specifier|const
name|void
modifier|*
name|vinput
parameter_list|,
name|apr_size_t
name|inputLen
parameter_list|,
name|int
name|xlate_buffer
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|vinput
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|partLen
decl_stmt|;
if|#
directive|if
name|APR_HAS_XLATE
name|apr_size_t
name|inbytes_left
decl_stmt|,
name|outbytes_left
decl_stmt|;
endif|#
directive|endif
comment|/* Compute number of bytes mod 64 */
name|idx
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
comment|/* Update number of bits */
if|if
condition|(
operator|(
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|apr_uint32_t
operator|)
name|inputLen
operator|<<
literal|3
operator|)
operator|)
operator|<
operator|(
operator|(
name|apr_uint32_t
operator|)
name|inputLen
operator|<<
literal|3
operator|)
condition|)
name|context
operator|->
name|count
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|context
operator|->
name|count
index|[
literal|1
index|]
operator|+=
operator|(
name|apr_uint32_t
operator|)
name|inputLen
operator|>>
literal|29
expr_stmt|;
name|partLen
operator|=
literal|64
operator|-
name|idx
expr_stmt|;
comment|/* Transform as many times as possible. */
if|#
directive|if
operator|!
name|APR_HAS_XLATE
if|if
condition|(
name|inputLen
operator|>=
name|partLen
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
name|input
argument_list|,
name|partLen
argument_list|)
expr_stmt|;
name|MD5Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partLen
init|;
name|i
operator|+
literal|63
operator|<
name|inputLen
condition|;
name|i
operator|+=
literal|64
control|)
name|MD5Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Buffer remaining input */
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|,
name|inputLen
operator|-
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*APR_HAS_XLATE*/
if|if
condition|(
name|inputLen
operator|>=
name|partLen
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|xlate
operator|&&
operator|(
name|xlate_buffer
operator|==
name|DO_XLATE
operator|)
condition|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|partLen
expr_stmt|;
name|apr_xlate_conv_buffer
argument_list|(
name|context
operator|->
name|xlate
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|input
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
name|input
argument_list|,
name|partLen
argument_list|)
expr_stmt|;
block|}
name|MD5Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partLen
init|;
name|i
operator|+
literal|63
operator|<
name|inputLen
condition|;
name|i
operator|+=
literal|64
control|)
block|{
if|if
condition|(
name|context
operator|->
name|xlate
operator|&&
operator|(
name|xlate_buffer
operator|==
name|DO_XLATE
operator|)
condition|)
block|{
name|unsigned
name|char
name|inp_tmp
index|[
literal|64
index|]
decl_stmt|;
name|inbytes_left
operator|=
name|outbytes_left
operator|=
literal|64
expr_stmt|;
name|apr_xlate_conv_buffer
argument_list|(
name|context
operator|->
name|xlate
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|input
index|[
name|i
index|]
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp_tmp
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
name|MD5Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
name|inp_tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MD5Transform
argument_list|(
name|context
operator|->
name|state
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Buffer remaining input */
if|if
condition|(
name|context
operator|->
name|xlate
operator|&&
operator|(
name|xlate_buffer
operator|==
name|DO_XLATE
operator|)
condition|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|inputLen
operator|-
name|i
expr_stmt|;
name|apr_xlate_conv_buffer
argument_list|(
name|context
operator|->
name|xlate
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|input
index|[
name|i
index|]
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|context
operator|->
name|buffer
index|[
name|idx
index|]
argument_list|,
operator|&
name|input
index|[
name|i
index|]
argument_list|,
name|inputLen
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*APR_HAS_XLATE*/
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* MD5 block update operation. API with the default setting   * for EBCDIC translations  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md5_update
argument_list|(
argument|apr_md5_ctx_t *context
argument_list|,
argument|const void *input
argument_list|,
argument|apr_size_t inputLen
argument_list|)
end_macro

begin_block
block|{
return|return
name|md5_update_buffer
argument_list|(
name|context
argument_list|,
name|input
argument_list|,
name|inputLen
argument_list|,
name|DO_XLATE
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* MD5 finalization. Ends an MD5 message-digest operation, writing the  * the message digest and zeroizing the context.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md5_final
argument_list|(
argument|unsigned char digest[APR_MD5_DIGESTSIZE]
argument_list|,
argument|apr_md5_ctx_t *context
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|bits
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|padLen
decl_stmt|;
comment|/* Save number of bits */
name|Encode
argument_list|(
name|bits
argument_list|,
name|context
operator|->
name|count
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_XLATE
comment|/* apr_md5_update() should not translate for this final round. */
name|context
operator|->
name|xlate
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/*APR_HAS_XLATE*/
comment|/* Pad out to 56 mod 64. */
name|idx
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|context
operator|->
name|count
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
name|padLen
operator|=
operator|(
name|idx
operator|<
literal|56
operator|)
condition|?
operator|(
literal|56
operator|-
name|idx
operator|)
else|:
operator|(
literal|120
operator|-
name|idx
operator|)
expr_stmt|;
name|apr_md5_update
argument_list|(
name|context
argument_list|,
name|PADDING
argument_list|,
name|padLen
argument_list|)
expr_stmt|;
comment|/* Append length (before padding) */
name|apr_md5_update
argument_list|(
name|context
argument_list|,
name|bits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Store state in digest */
name|Encode
argument_list|(
name|digest
argument_list|,
name|context
operator|->
name|state
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|)
expr_stmt|;
comment|/* Zeroize sensitive information. */
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* MD5 in one step (init, update, final)  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md5
argument_list|(
argument|unsigned char digest[APR_MD5_DIGESTSIZE]
argument_list|,
argument|const void *_input
argument_list|,
argument|apr_size_t inputLen
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|_input
decl_stmt|;
name|apr_md5_ctx_t
name|ctx
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_md5_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_md5_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|input
argument_list|,
name|inputLen
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|rv
return|;
return|return
name|apr_md5_final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* MD5 basic transformation. Transforms state based on block. */
end_comment

begin_function
specifier|static
name|void
name|MD5Transform
parameter_list|(
name|apr_uint32_t
name|state
index|[
literal|4
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|block
index|[
literal|64
index|]
parameter_list|)
block|{
name|apr_uint32_t
name|a
init|=
name|state
index|[
literal|0
index|]
decl_stmt|,
name|b
init|=
name|state
index|[
literal|1
index|]
decl_stmt|,
name|c
init|=
name|state
index|[
literal|2
index|]
decl_stmt|,
name|d
init|=
name|state
index|[
literal|3
index|]
decl_stmt|,
name|x
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|Decode
argument_list|(
name|x
argument_list|,
name|block
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* Round 1 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S11
argument_list|,
literal|0xd76aa478
argument_list|)
expr_stmt|;
comment|/* 1 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S12
argument_list|,
literal|0xe8c7b756
argument_list|)
expr_stmt|;
comment|/* 2 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S13
argument_list|,
literal|0x242070db
argument_list|)
expr_stmt|;
comment|/* 3 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S14
argument_list|,
literal|0xc1bdceee
argument_list|)
expr_stmt|;
comment|/* 4 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S11
argument_list|,
literal|0xf57c0faf
argument_list|)
expr_stmt|;
comment|/* 5 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S12
argument_list|,
literal|0x4787c62a
argument_list|)
expr_stmt|;
comment|/* 6 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S13
argument_list|,
literal|0xa8304613
argument_list|)
expr_stmt|;
comment|/* 7 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S14
argument_list|,
literal|0xfd469501
argument_list|)
expr_stmt|;
comment|/* 8 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S11
argument_list|,
literal|0x698098d8
argument_list|)
expr_stmt|;
comment|/* 9 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S12
argument_list|,
literal|0x8b44f7af
argument_list|)
expr_stmt|;
comment|/* 10 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S13
argument_list|,
literal|0xffff5bb1
argument_list|)
expr_stmt|;
comment|/* 11 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S14
argument_list|,
literal|0x895cd7be
argument_list|)
expr_stmt|;
comment|/* 12 */
name|FF
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S11
argument_list|,
literal|0x6b901122
argument_list|)
expr_stmt|;
comment|/* 13 */
name|FF
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S12
argument_list|,
literal|0xfd987193
argument_list|)
expr_stmt|;
comment|/* 14 */
name|FF
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S13
argument_list|,
literal|0xa679438e
argument_list|)
expr_stmt|;
comment|/* 15 */
name|FF
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S14
argument_list|,
literal|0x49b40821
argument_list|)
expr_stmt|;
comment|/* 16 */
comment|/* Round 2 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S21
argument_list|,
literal|0xf61e2562
argument_list|)
expr_stmt|;
comment|/* 17 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S22
argument_list|,
literal|0xc040b340
argument_list|)
expr_stmt|;
comment|/* 18 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S23
argument_list|,
literal|0x265e5a51
argument_list|)
expr_stmt|;
comment|/* 19 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S24
argument_list|,
literal|0xe9b6c7aa
argument_list|)
expr_stmt|;
comment|/* 20 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S21
argument_list|,
literal|0xd62f105d
argument_list|)
expr_stmt|;
comment|/* 21 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S22
argument_list|,
literal|0x2441453
argument_list|)
expr_stmt|;
comment|/* 22 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S23
argument_list|,
literal|0xd8a1e681
argument_list|)
expr_stmt|;
comment|/* 23 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S24
argument_list|,
literal|0xe7d3fbc8
argument_list|)
expr_stmt|;
comment|/* 24 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S21
argument_list|,
literal|0x21e1cde6
argument_list|)
expr_stmt|;
comment|/* 25 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S22
argument_list|,
literal|0xc33707d6
argument_list|)
expr_stmt|;
comment|/* 26 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S23
argument_list|,
literal|0xf4d50d87
argument_list|)
expr_stmt|;
comment|/* 27 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S24
argument_list|,
literal|0x455a14ed
argument_list|)
expr_stmt|;
comment|/* 28 */
name|GG
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S21
argument_list|,
literal|0xa9e3e905
argument_list|)
expr_stmt|;
comment|/* 29 */
name|GG
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S22
argument_list|,
literal|0xfcefa3f8
argument_list|)
expr_stmt|;
comment|/* 30 */
name|GG
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S23
argument_list|,
literal|0x676f02d9
argument_list|)
expr_stmt|;
comment|/* 31 */
name|GG
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S24
argument_list|,
literal|0x8d2a4c8a
argument_list|)
expr_stmt|;
comment|/* 32 */
comment|/* Round 3 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S31
argument_list|,
literal|0xfffa3942
argument_list|)
expr_stmt|;
comment|/* 33 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S32
argument_list|,
literal|0x8771f681
argument_list|)
expr_stmt|;
comment|/* 34 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S33
argument_list|,
literal|0x6d9d6122
argument_list|)
expr_stmt|;
comment|/* 35 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S34
argument_list|,
literal|0xfde5380c
argument_list|)
expr_stmt|;
comment|/* 36 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S31
argument_list|,
literal|0xa4beea44
argument_list|)
expr_stmt|;
comment|/* 37 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S32
argument_list|,
literal|0x4bdecfa9
argument_list|)
expr_stmt|;
comment|/* 38 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S33
argument_list|,
literal|0xf6bb4b60
argument_list|)
expr_stmt|;
comment|/* 39 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S34
argument_list|,
literal|0xbebfbc70
argument_list|)
expr_stmt|;
comment|/* 40 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S31
argument_list|,
literal|0x289b7ec6
argument_list|)
expr_stmt|;
comment|/* 41 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S32
argument_list|,
literal|0xeaa127fa
argument_list|)
expr_stmt|;
comment|/* 42 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S33
argument_list|,
literal|0xd4ef3085
argument_list|)
expr_stmt|;
comment|/* 43 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S34
argument_list|,
literal|0x4881d05
argument_list|)
expr_stmt|;
comment|/* 44 */
name|HH
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S31
argument_list|,
literal|0xd9d4d039
argument_list|)
expr_stmt|;
comment|/* 45 */
name|HH
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S32
argument_list|,
literal|0xe6db99e5
argument_list|)
expr_stmt|;
comment|/* 46 */
name|HH
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S33
argument_list|,
literal|0x1fa27cf8
argument_list|)
expr_stmt|;
comment|/* 47 */
name|HH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S34
argument_list|,
literal|0xc4ac5665
argument_list|)
expr_stmt|;
comment|/* 48 */
comment|/* Round 4 */
name|II
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|,
name|S41
argument_list|,
literal|0xf4292244
argument_list|)
expr_stmt|;
comment|/* 49 */
name|II
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|7
index|]
argument_list|,
name|S42
argument_list|,
literal|0x432aff97
argument_list|)
expr_stmt|;
comment|/* 50 */
name|II
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|14
index|]
argument_list|,
name|S43
argument_list|,
literal|0xab9423a7
argument_list|)
expr_stmt|;
comment|/* 51 */
name|II
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|5
index|]
argument_list|,
name|S44
argument_list|,
literal|0xfc93a039
argument_list|)
expr_stmt|;
comment|/* 52 */
name|II
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|12
index|]
argument_list|,
name|S41
argument_list|,
literal|0x655b59c3
argument_list|)
expr_stmt|;
comment|/* 53 */
name|II
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|3
index|]
argument_list|,
name|S42
argument_list|,
literal|0x8f0ccc92
argument_list|)
expr_stmt|;
comment|/* 54 */
name|II
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|10
index|]
argument_list|,
name|S43
argument_list|,
literal|0xffeff47d
argument_list|)
expr_stmt|;
comment|/* 55 */
name|II
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|S44
argument_list|,
literal|0x85845dd1
argument_list|)
expr_stmt|;
comment|/* 56 */
name|II
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|8
index|]
argument_list|,
name|S41
argument_list|,
literal|0x6fa87e4f
argument_list|)
expr_stmt|;
comment|/* 57 */
name|II
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|15
index|]
argument_list|,
name|S42
argument_list|,
literal|0xfe2ce6e0
argument_list|)
expr_stmt|;
comment|/* 58 */
name|II
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|6
index|]
argument_list|,
name|S43
argument_list|,
literal|0xa3014314
argument_list|)
expr_stmt|;
comment|/* 59 */
name|II
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|13
index|]
argument_list|,
name|S44
argument_list|,
literal|0x4e0811a1
argument_list|)
expr_stmt|;
comment|/* 60 */
name|II
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|x
index|[
literal|4
index|]
argument_list|,
name|S41
argument_list|,
literal|0xf7537e82
argument_list|)
expr_stmt|;
comment|/* 61 */
name|II
argument_list|(
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|x
index|[
literal|11
index|]
argument_list|,
name|S42
argument_list|,
literal|0xbd3af235
argument_list|)
expr_stmt|;
comment|/* 62 */
name|II
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|x
index|[
literal|2
index|]
argument_list|,
name|S43
argument_list|,
literal|0x2ad7d2bb
argument_list|)
expr_stmt|;
comment|/* 63 */
name|II
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|x
index|[
literal|9
index|]
argument_list|,
name|S44
argument_list|,
literal|0xeb86d391
argument_list|)
expr_stmt|;
comment|/* 64 */
name|state
index|[
literal|0
index|]
operator|+=
name|a
expr_stmt|;
name|state
index|[
literal|1
index|]
operator|+=
name|b
expr_stmt|;
name|state
index|[
literal|2
index|]
operator|+=
name|c
expr_stmt|;
name|state
index|[
literal|3
index|]
operator|+=
name|d
expr_stmt|;
comment|/* Zeroize sensitive information. */
name|memset
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encodes input (apr_uint32_t) into output (unsigned char). Assumes len is  * a multiple of 4.  */
end_comment

begin_function
specifier|static
name|void
name|Encode
parameter_list|(
name|unsigned
name|char
modifier|*
name|output
parameter_list|,
specifier|const
name|apr_uint32_t
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|apr_uint32_t
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|4
control|)
block|{
name|k
operator|=
name|input
index|[
name|i
index|]
expr_stmt|;
name|output
index|[
name|j
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|k
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|k
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|k
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|k
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decodes input (unsigned char) into output (apr_uint32_t). Assumes len is  * a multiple of 4.  */
end_comment

begin_function
specifier|static
name|void
name|Decode
parameter_list|(
name|apr_uint32_t
modifier|*
name|output
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|4
control|)
name|output
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
operator|+
literal|2
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|)
name|input
index|[
name|j
operator|+
literal|3
index|]
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_CHARSET_EBCDIC
end_if

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_MD5InitEBCDIC
argument_list|(
argument|apr_xlate_t *xlate
argument_list|)
end_macro

begin_block
block|{
name|xlate_ebcdic_to_ascii
operator|=
name|xlate
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define the Magic String prefix that identifies a password as being  * hashed using our algorithm.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|apr1_id
init|=
literal|"$apr1$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following MD5 password encryption code was largely borrowed from  * the FreeBSD 3.0 /usr/src/lib/libcrypt/crypt.c file, which is  * licenced as stated at the top of this file.  */
end_comment

begin_function
specifier|static
name|void
name|to64
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|v
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|itoa64
index|[]
init|=
comment|/* 0 ... 63 => ASCII - 64 */
literal|"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
name|itoa64
index|[
name|v
operator|&
literal|0x3f
index|]
expr_stmt|;
name|v
operator|>>=
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_md5_encode
argument_list|(
argument|const char *pw
argument_list|,
argument|const char *salt
argument_list|,
argument|char *result
argument_list|,
argument|apr_size_t nbytes
argument_list|)
end_macro

begin_block
block|{
comment|/*      * Minimum size is 8 bytes for salt, plus 1 for the trailing NUL,      * plus 4 for the '$' separators, plus the password hash itself.      * Let's leave a goodly amount of leeway.      */
name|char
name|passwd
index|[
literal|120
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|char
name|final
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|apr_ssize_t
name|sl
decl_stmt|,
name|pl
decl_stmt|,
name|i
decl_stmt|;
name|apr_md5_ctx_t
name|ctx
decl_stmt|,
name|ctx1
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
comment|/*       * Refine the salt first.  It's possible we were given an already-hashed      * string as the salt argument, so extract the actual salt value from it      * if so.  Otherwise just use the string up to the first '$' as the salt.      */
name|sp
operator|=
name|salt
expr_stmt|;
comment|/*      * If it starts with the magic string, then skip that.      */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sp
argument_list|,
name|apr1_id
argument_list|,
name|strlen
argument_list|(
name|apr1_id
argument_list|)
argument_list|)
condition|)
block|{
name|sp
operator|+=
name|strlen
argument_list|(
name|apr1_id
argument_list|)
expr_stmt|;
block|}
comment|/*      * It stops at the first '$' or 8 chars, whichever comes first      */
for|for
control|(
name|ep
operator|=
name|sp
init|;
operator|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|ep
operator|!=
literal|'$'
operator|)
operator|&&
operator|(
name|ep
operator|<
operator|(
name|sp
operator|+
literal|8
operator|)
operator|)
condition|;
name|ep
operator|++
control|)
block|{
continue|continue;
block|}
comment|/*      * Get the length of the true salt      */
name|sl
operator|=
name|ep
operator|-
name|sp
expr_stmt|;
comment|/*      * 'Time to make the doughnuts..'      */
name|apr_md5_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_CHARSET_EBCDIC
name|apr_md5_set_xlate
argument_list|(
operator|&
name|ctx
argument_list|,
name|xlate_ebcdic_to_ascii
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * The password first, since that is what is most unknown      */
name|apr_md5_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|pw
argument_list|,
name|strlen
argument_list|(
name|pw
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Then our magic string      */
name|apr_md5_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|apr1_id
argument_list|,
name|strlen
argument_list|(
name|apr1_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Then the raw salt      */
name|apr_md5_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
comment|/*      * Then just as many characters of the MD5(pw, salt, pw)      */
name|apr_md5_init
argument_list|(
operator|&
name|ctx1
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_CHARSET_EBCDIC
name|apr_md5_set_xlate
argument_list|(
operator|&
name|ctx1
argument_list|,
name|xlate_ebcdic_to_ascii
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|pw
argument_list|,
name|strlen
argument_list|(
name|pw
argument_list|)
argument_list|)
expr_stmt|;
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|pw
argument_list|,
name|strlen
argument_list|(
name|pw
argument_list|)
argument_list|)
expr_stmt|;
name|apr_md5_final
argument_list|(
name|final
argument_list|,
operator|&
name|ctx1
argument_list|)
expr_stmt|;
for|for
control|(
name|pl
operator|=
name|strlen
argument_list|(
name|pw
argument_list|)
init|;
name|pl
operator|>
literal|0
condition|;
name|pl
operator|-=
name|APR_MD5_DIGESTSIZE
control|)
block|{
name|md5_update_buffer
argument_list|(
operator|&
name|ctx
argument_list|,
name|final
argument_list|,
operator|(
name|pl
operator|>
name|APR_MD5_DIGESTSIZE
operator|)
condition|?
name|APR_MD5_DIGESTSIZE
else|:
name|pl
argument_list|,
name|SKIP_XLATE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Don't leave anything around in vm they could use.      */
name|memset
argument_list|(
name|final
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|final
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Then something really weird...      */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|pw
argument_list|)
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|md5_update_buffer
argument_list|(
operator|&
name|ctx
argument_list|,
name|final
argument_list|,
literal|1
argument_list|,
name|SKIP_XLATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_md5_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|pw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Now make the output string.  We know our limitations, so we      * can use the string routines without bounds checking.      */
name|strcpy
argument_list|(
name|passwd
argument_list|,
name|apr1_id
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|passwd
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|passwd
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|apr_md5_final
argument_list|(
name|final
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/*      * And now, just to make sure things don't run too fast..      * On a 60 Mhz Pentium this takes 34 msec, so you would      * need 30 seconds to build a 1000 entry dictionary...      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|apr_md5_init
argument_list|(
operator|&
name|ctx1
argument_list|)
expr_stmt|;
comment|/*           * apr_md5_final clears out ctx1.xlate at the end of each loop,           * so need to to set it each time through           */
if|#
directive|if
name|APR_CHARSET_EBCDIC
name|apr_md5_set_xlate
argument_list|(
operator|&
name|ctx1
argument_list|,
name|xlate_ebcdic_to_ascii
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|pw
argument_list|,
name|strlen
argument_list|(
name|pw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md5_update_buffer
argument_list|(
operator|&
name|ctx1
argument_list|,
name|final
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|,
name|SKIP_XLATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
literal|3
condition|)
block|{
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
literal|7
condition|)
block|{
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|pw
argument_list|,
name|strlen
argument_list|(
name|pw
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|md5_update_buffer
argument_list|(
operator|&
name|ctx1
argument_list|,
name|final
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|,
name|SKIP_XLATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_md5_update
argument_list|(
operator|&
name|ctx1
argument_list|,
name|pw
argument_list|,
name|strlen
argument_list|(
name|pw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|apr_md5_final
argument_list|(
name|final
argument_list|,
operator|&
name|ctx1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|passwd
operator|+
name|strlen
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
name|final
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|final
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator||
name|final
index|[
literal|12
index|]
expr_stmt|;
name|to64
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|l
operator|=
operator|(
name|final
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|final
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|final
index|[
literal|13
index|]
expr_stmt|;
name|to64
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|l
operator|=
operator|(
name|final
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|final
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
name|final
index|[
literal|14
index|]
expr_stmt|;
name|to64
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|l
operator|=
operator|(
name|final
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|final
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
operator||
name|final
index|[
literal|15
index|]
expr_stmt|;
name|to64
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|l
operator|=
operator|(
name|final
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|final
index|[
literal|10
index|]
operator|<<
literal|8
operator|)
operator||
name|final
index|[
literal|5
index|]
expr_stmt|;
name|to64
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|l
operator|=
name|final
index|[
literal|11
index|]
expr_stmt|;
name|to64
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Don't leave anything around in vm they could use.      */
name|memset
argument_list|(
name|final
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|final
argument_list|)
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|result
argument_list|,
name|passwd
argument_list|,
name|nbytes
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BEOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NETWARE
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APU_CRYPT_THREADSAFE
argument_list|)
operator|||
operator|!
name|APR_HAS_THREADS
operator|||
expr|\
name|defined
argument_list|(
name|CRYPT_R_CRYPTD
argument_list|)
operator|||
name|defined
argument_list|(
name|CRYPT_R_STRUCT_CRYPT_DATA
argument_list|)
end_if

begin_define
define|#
directive|define
name|crypt_mutex_lock
parameter_list|()
end_define

begin_define
define|#
directive|define
name|crypt_mutex_unlock
parameter_list|()
end_define

begin_elif
elif|#
directive|elif
name|APR_HAVE_PTHREAD_H
operator|&&
name|defined
argument_list|(
name|PTHREAD_MUTEX_INITIALIZER
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|crypt_mutex
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|crypt_mutex_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|crypt_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|crypt_mutex_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutex_unlock
argument_list|(
operator|&
name|crypt_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|apr_password_validate() is not threadsafe.  rebuild APR without thread support.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Validate a plaintext password against a smashed one.  Uses either  * crypt() (if available) or apr_md5_encode() or apr_sha1_base64(), depending  * upon the format of the smashed input password.  Returns APR_SUCCESS if  * they match, or APR_EMISMATCH if they don't.  If the platform doesn't  * support crypt, then the default check is against a clear text string.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_password_validate
argument_list|(
argument|const char *passwd
argument_list|,
argument|const char *hash
argument_list|)
end_macro

begin_block
block|{
name|char
name|sample
index|[
literal|120
index|]
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BEOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NETWARE
argument_list|)
name|char
modifier|*
name|crypt_pw
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|hash
argument_list|,
name|apr1_id
argument_list|,
name|strlen
argument_list|(
name|apr1_id
argument_list|)
argument_list|)
condition|)
block|{
comment|/*          * The hash was created using our custom algorithm.          */
name|apr_md5_encode
argument_list|(
name|passwd
argument_list|,
name|hash
argument_list|,
name|sample
argument_list|,
sizeof|sizeof
argument_list|(
name|sample
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|hash
argument_list|,
name|APR_SHA1PW_ID
argument_list|,
name|APR_SHA1PW_IDLEN
argument_list|)
condition|)
block|{
name|apr_sha1_base64
argument_list|(
name|passwd
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|passwd
argument_list|)
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * It's not our algorithm, so feed it to crypt() if possible.          */
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|BEOS
argument_list|)
operator|||
name|defined
argument_list|(
name|NETWARE
argument_list|)
name|apr_cpystrn
argument_list|(
name|sample
argument_list|,
name|passwd
argument_list|,
sizeof|sizeof
argument_list|(
name|sample
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|CRYPT_R_CRYPTD
argument_list|)
name|CRYPTD
name|buffer
decl_stmt|;
name|crypt_pw
operator|=
name|crypt_r
argument_list|(
name|passwd
argument_list|,
name|hash
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|sample
argument_list|,
name|crypt_pw
argument_list|,
sizeof|sizeof
argument_list|(
name|sample
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|CRYPT_R_STRUCT_CRYPT_DATA
argument_list|)
name|struct
name|crypt_data
name|buffer
decl_stmt|;
comment|/* having to clear this seems bogus... GNU doc is          * confusing...  user report found from google says          * the crypt_data struct had to be cleared to get          * the same result as plain crypt()          */
name|memset
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|crypt_pw
operator|=
name|crypt_r
argument_list|(
name|passwd
argument_list|,
name|hash
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|sample
argument_list|,
name|crypt_pw
argument_list|,
sizeof|sizeof
argument_list|(
name|sample
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Do a bit of sanity checking since we know that crypt_r()          * should always be used for threaded builds on AIX, and          * problems in configure logic can result in the wrong          * choice being made.          */
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|&&
name|APR_HAS_THREADS
error|#
directive|error
error|Configuration error!  crypt_r() should have been selected!
endif|#
directive|endif
comment|/* Handle thread safety issues by holding a mutex around the          * call to crypt().          */
name|crypt_mutex_lock
argument_list|()
expr_stmt|;
name|crypt_pw
operator|=
name|crypt
argument_list|(
name|passwd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|sample
argument_list|,
name|crypt_pw
argument_list|,
sizeof|sizeof
argument_list|(
name|sample
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|crypt_mutex_unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|strcmp
argument_list|(
name|sample
argument_list|,
name|hash
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|APR_SUCCESS
else|:
name|APR_EMISMATCH
return|;
block|}
end_block

end_unit

