begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * apr_date.c: date parsing utility routines  *     These routines are (hopefully) platform independent.  *   * 27 Oct 1996  Roy Fielding  *     Extracted (with many modifications) from mod_proxy.c and  *     tested with over 50,000 randomly chosen valid date strings  *     and several hundred variations of invalid date strings.  *   */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_CTYPE_H
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"apr_date.h"
end_include

begin_comment
comment|/*  * Compare a string to a mask  * Mask characters (arbitrary maximum is 256 characters, just in case):  *   @ - uppercase letter  *   $ - lowercase letter  *& - hex digit  *   # - digit  *   ~ - digit or space  *   * - swallow remaining characters   *<x> - exact match for any other character  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_date_checkmask
argument_list|(
argument|const char *data
argument_list|,
argument|const char *mask
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|mask
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
operator|(
name|d
operator|==
literal|'\0'
operator|)
return|;
case|case
literal|'*'
case|:
return|return
literal|1
return|;
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|apr_isupper
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|apr_islower
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
operator|!
name|apr_isxdigit
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
operator|(
name|d
operator|!=
literal|' '
operator|)
operator|&&
operator|!
name|apr_isdigit
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
if|if
condition|(
name|mask
index|[
name|i
index|]
operator|!=
name|d
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
return|return
literal|0
return|;
comment|/* We only get here if mask is corrupted (exceeds 256) */
block|}
end_block

begin_comment
comment|/*  * Parses an HTTP date in one of three standard forms:  *  *     Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123  *     Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036  *     Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format  *  * and returns the apr_time_t number of microseconds since 1 Jan 1970 GMT,   * or APR_DATE_BAD if this would be out of range or if the date is invalid.  *  * The restricted HTTP syntax is  *   *     HTTP-date    = rfc1123-date | rfc850-date | asctime-date  *  *     rfc1123-date = wkday "," SP date1 SP time SP "GMT"  *     rfc850-date  = weekday "," SP date2 SP time SP "GMT"  *     asctime-date = wkday SP date3 SP time SP 4DIGIT  *  *     date1        = 2DIGIT SP month SP 4DIGIT  *                    ; day month year (e.g., 02 Jun 1982)  *     date2        = 2DIGIT "-" month "-" 2DIGIT  *                    ; day-month-year (e.g., 02-Jun-82)  *     date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))  *                    ; month day (e.g., Jun  2)  *  *     time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT  *                    ; 00:00:00 - 23:59:59  *  *     wkday        = "Mon" | "Tue" | "Wed"  *                  | "Thu" | "Fri" | "Sat" | "Sun"  *  *     weekday      = "Monday" | "Tuesday" | "Wednesday"  *                  | "Thursday" | "Friday" | "Saturday" | "Sunday"  *  *     month        = "Jan" | "Feb" | "Mar" | "Apr"  *                  | "May" | "Jun" | "Jul" | "Aug"  *                  | "Sep" | "Oct" | "Nov" | "Dec"  *  * However, for the sake of robustness (and Netscapeness), we ignore the  * weekday and anything after the time field (including the timezone).  *  * This routine is intended to be very fast; 10x faster than using sscanf.  *  * Originally from Andrew Daviel<andrew@vancouver-webpages.com>, 29 Jul 96  * but many changes since then.  *  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_time_t
argument_list|)
end_macro

begin_macro
name|apr_date_parse_http
argument_list|(
argument|const char *date
argument_list|)
end_macro

begin_block
block|{
name|apr_time_exp_t
name|ds
decl_stmt|;
name|apr_time_t
name|result
decl_stmt|;
name|int
name|mint
decl_stmt|,
name|mon
decl_stmt|;
specifier|const
name|char
modifier|*
name|monstr
decl_stmt|,
modifier|*
name|timstr
decl_stmt|;
specifier|static
specifier|const
name|int
name|months
index|[
literal|12
index|]
init|=
block|{
operator|(
literal|'J'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'a'
operator|<<
literal|8
operator|)
operator||
literal|'n'
block|,
operator|(
literal|'F'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'e'
operator|<<
literal|8
operator|)
operator||
literal|'b'
block|,
operator|(
literal|'M'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'a'
operator|<<
literal|8
operator|)
operator||
literal|'r'
block|,
operator|(
literal|'A'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'p'
operator|<<
literal|8
operator|)
operator||
literal|'r'
block|,
operator|(
literal|'M'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'a'
operator|<<
literal|8
operator|)
operator||
literal|'y'
block|,
operator|(
literal|'J'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'u'
operator|<<
literal|8
operator|)
operator||
literal|'n'
block|,
operator|(
literal|'J'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'u'
operator|<<
literal|8
operator|)
operator||
literal|'l'
block|,
operator|(
literal|'A'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'u'
operator|<<
literal|8
operator|)
operator||
literal|'g'
block|,
operator|(
literal|'S'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'e'
operator|<<
literal|8
operator|)
operator||
literal|'p'
block|,
operator|(
literal|'O'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'c'
operator|<<
literal|8
operator|)
operator||
literal|'t'
block|,
operator|(
literal|'N'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'o'
operator|<<
literal|8
operator|)
operator||
literal|'v'
block|,
operator|(
literal|'D'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'e'
operator|<<
literal|8
operator|)
operator||
literal|'c'
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|date
condition|)
return|return
name|APR_DATE_BAD
return|;
while|while
condition|(
operator|*
name|date
operator|&&
name|apr_isspace
argument_list|(
operator|*
name|date
argument_list|)
condition|)
comment|/* Find first non-whitespace char */
operator|++
name|date
expr_stmt|;
if|if
condition|(
operator|*
name|date
operator|==
literal|'\0'
condition|)
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
operator|(
name|date
operator|=
name|strchr
argument_list|(
name|date
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* Find space after weekday */
return|return
name|APR_DATE_BAD
return|;
operator|++
name|date
expr_stmt|;
comment|/* Now pointing to first char after space, which should be */
comment|/* start of the actual date information for all 4 formats. */
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"## @$$ #### ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 1123 format with two days */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"##-@$$-## ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 850 format */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"@$$ ~# ##:##:## ####*"
argument_list|)
condition|)
block|{
comment|/* asctime format */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|16
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|17
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|18
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|19
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|date
index|[
literal|4
index|]
operator|==
literal|' '
condition|)
name|ds
operator|.
name|tm_mday
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|+=
operator|(
name|date
index|[
literal|5
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"# @$$ #### ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 1123 format with one day */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|2
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|11
expr_stmt|;
block|}
else|else
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
name|ds
operator|.
name|tm_mday
operator|<=
literal|0
operator|||
name|ds
operator|.
name|tm_mday
operator|>
literal|31
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_hour
operator|=
operator|(
operator|(
name|timstr
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|timstr
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_min
operator|=
operator|(
operator|(
name|timstr
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|timstr
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_sec
operator|=
operator|(
operator|(
name|timstr
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|timstr
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ds
operator|.
name|tm_hour
operator|>
literal|23
operator|)
operator|||
operator|(
name|ds
operator|.
name|tm_min
operator|>
literal|59
operator|)
operator|||
operator|(
name|ds
operator|.
name|tm_sec
operator|>
literal|61
operator|)
condition|)
return|return
name|APR_DATE_BAD
return|;
name|mint
operator|=
operator|(
name|monstr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|monstr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|monstr
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|mon
operator|=
literal|0
init|;
name|mon
operator|<
literal|12
condition|;
name|mon
operator|++
control|)
if|if
condition|(
name|mint
operator|==
name|months
index|[
name|mon
index|]
condition|)
break|break;
if|if
condition|(
name|mon
operator|==
literal|12
condition|)
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
operator|(
name|ds
operator|.
name|tm_mday
operator|==
literal|31
operator|)
operator|&&
operator|(
name|mon
operator|==
literal|3
operator|||
name|mon
operator|==
literal|5
operator|||
name|mon
operator|==
literal|8
operator|||
name|mon
operator|==
literal|10
operator|)
condition|)
return|return
name|APR_DATE_BAD
return|;
comment|/* February gets special check for leapyear */
if|if
condition|(
operator|(
name|mon
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|ds
operator|.
name|tm_mday
operator|>
literal|29
operator|)
operator|||
operator|(
operator|(
name|ds
operator|.
name|tm_mday
operator|==
literal|29
operator|)
operator|&&
operator|(
operator|(
name|ds
operator|.
name|tm_year
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
operator|(
name|ds
operator|.
name|tm_year
operator|%
literal|100
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ds
operator|.
name|tm_year
operator|%
literal|400
operator|)
operator|!=
literal|100
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_mon
operator|=
name|mon
expr_stmt|;
comment|/* ap_mplode_time uses tm_usec and tm_gmtoff fields, but they haven't       * been set yet.       * It should be safe to just zero out these values.      * tm_usec is the number of microseconds into the second.  HTTP only      * cares about second granularity.      * tm_gmtoff is the number of seconds off of GMT the time is.  By      * definition all times going through this function are in GMT, so this      * is zero.       */
name|ds
operator|.
name|tm_usec
operator|=
literal|0
expr_stmt|;
name|ds
operator|.
name|tm_gmtoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apr_time_exp_get
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|ds
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|APR_DATE_BAD
return|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * Parses a string resembling an RFC 822 date.  This is meant to be  * leinent in its parsing of dates.  Hence, this will parse a wider   * range of dates than apr_date_parse_http.  *  * The prominent mailer (or poster, if mailer is unknown) that has  * been seen in the wild is included for the unknown formats.  *  *     Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123  *     Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036  *     Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format  *     Sun, 6 Nov 1994 08:49:37 GMT   ; RFC 822, updated by RFC 1123  *     Sun, 06 Nov 94 08:49:37 GMT    ; RFC 822  *     Sun, 6 Nov 94 08:49:37 GMT     ; RFC 822  *     Sun, 06 Nov 94 08:49 GMT       ; Unknown [drtr@ast.cam.ac.uk]   *     Sun, 6 Nov 94 08:49 GMT        ; Unknown [drtr@ast.cam.ac.uk]  *     Sun, 06 Nov 94 8:49:37 GMT     ; Unknown [Elm 70.85]  *     Sun, 6 Nov 94 8:49:37 GMT      ; Unknown [Elm 70.85]   *     Mon,  7 Jan 2002 07:21:22 GMT  ; Unknown [Postfix]  *     Sun, 06-Nov-1994 08:49:37 GMT  ; RFC 850 with four digit years  *  */
end_comment

begin_define
define|#
directive|define
name|TIMEPARSE
parameter_list|(
name|ds
parameter_list|,
name|hr10
parameter_list|,
name|hr1
parameter_list|,
name|min10
parameter_list|,
name|min1
parameter_list|,
name|sec10
parameter_list|,
name|sec1
parameter_list|)
define|\
value|{                                                       \         ds.tm_hour = ((hr10 - '0') * 10) + (hr1 - '0');     \         ds.tm_min = ((min10 - '0') * 10) + (min1 - '0');    \         ds.tm_sec = ((sec10 - '0') * 10) + (sec1 - '0');    \     }
end_define

begin_define
define|#
directive|define
name|TIMEPARSE_STD
parameter_list|(
name|ds
parameter_list|,
name|timstr
parameter_list|)
define|\
value|{                                                       \         TIMEPARSE(ds, timstr[0],timstr[1],                  \                       timstr[3],timstr[4],                  \                       timstr[6],timstr[7]);                 \     }
end_define

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_time_t
argument_list|)
end_macro

begin_macro
name|apr_date_parse_rfc
argument_list|(
argument|const char *date
argument_list|)
end_macro

begin_block
block|{
name|apr_time_exp_t
name|ds
decl_stmt|;
name|apr_time_t
name|result
decl_stmt|;
name|int
name|mint
decl_stmt|,
name|mon
decl_stmt|;
specifier|const
name|char
modifier|*
name|monstr
decl_stmt|,
modifier|*
name|timstr
decl_stmt|,
modifier|*
name|gmtstr
decl_stmt|;
specifier|static
specifier|const
name|int
name|months
index|[
literal|12
index|]
init|=
block|{
operator|(
literal|'J'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'a'
operator|<<
literal|8
operator|)
operator||
literal|'n'
block|,
operator|(
literal|'F'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'e'
operator|<<
literal|8
operator|)
operator||
literal|'b'
block|,
operator|(
literal|'M'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'a'
operator|<<
literal|8
operator|)
operator||
literal|'r'
block|,
operator|(
literal|'A'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'p'
operator|<<
literal|8
operator|)
operator||
literal|'r'
block|,
operator|(
literal|'M'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'a'
operator|<<
literal|8
operator|)
operator||
literal|'y'
block|,
operator|(
literal|'J'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'u'
operator|<<
literal|8
operator|)
operator||
literal|'n'
block|,
operator|(
literal|'J'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'u'
operator|<<
literal|8
operator|)
operator||
literal|'l'
block|,
operator|(
literal|'A'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'u'
operator|<<
literal|8
operator|)
operator||
literal|'g'
block|,
operator|(
literal|'S'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'e'
operator|<<
literal|8
operator|)
operator||
literal|'p'
block|,
operator|(
literal|'O'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'c'
operator|<<
literal|8
operator|)
operator||
literal|'t'
block|,
operator|(
literal|'N'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'o'
operator|<<
literal|8
operator|)
operator||
literal|'v'
block|,
operator|(
literal|'D'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'e'
operator|<<
literal|8
operator|)
operator||
literal|'c'
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|date
condition|)
return|return
name|APR_DATE_BAD
return|;
comment|/* Not all dates have text days at the beginning. */
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
name|date
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|date
operator|&&
name|apr_isspace
argument_list|(
operator|*
name|date
argument_list|)
condition|)
comment|/* Find first non-whitespace char */
operator|++
name|date
expr_stmt|;
if|if
condition|(
operator|*
name|date
operator|==
literal|'\0'
condition|)
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
operator|(
name|date
operator|=
name|strchr
argument_list|(
name|date
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* Find space after weekday */
return|return
name|APR_DATE_BAD
return|;
operator|++
name|date
expr_stmt|;
comment|/* Now pointing to first char after space, which should be */
block|}
comment|/* start of the actual date information for all 11 formats. */
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"## @$$ #### ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 1123 format */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|12
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|21
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"##-@$$-## ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 850 format  */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|10
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|19
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"@$$ ~# ##:##:## ####*"
argument_list|)
condition|)
block|{
comment|/* asctime format */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|16
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|17
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|18
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|19
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|date
index|[
literal|4
index|]
operator|==
literal|' '
condition|)
name|ds
operator|.
name|tm_mday
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|+=
operator|(
name|date
index|[
literal|5
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|7
expr_stmt|;
name|gmtstr
operator|=
name|NULL
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"# @$$ #### ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 1123 format*/
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|2
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|11
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|20
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"## @$$ ## ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* This is the old RFC 1123 date format - many many years ago, people          * used two-digit years.  Oh, how foolish.          *          * Two-digit day, two-digit year version. */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|10
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|19
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|" # @$$ ## ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* This is the old RFC 1123 date format - many many years ago, people          * used two-digit years.  Oh, how foolish.          *          * Space + one-digit day, two-digit year version.*/
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|10
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|19
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"# @$$ ## ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* This is the old RFC 1123 date format - many many years ago, people          * used two-digit years.  Oh, how foolish.          *          * One-digit day, two-digit year version. */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|2
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|9
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|18
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"## @$$ ## ##:## *"
argument_list|)
condition|)
block|{
comment|/* Loser format.  This is quite bogus.  */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|10
expr_stmt|;
name|gmtstr
operator|=
name|NULL
expr_stmt|;
name|TIMEPARSE
argument_list|(
name|ds
argument_list|,
name|timstr
index|[
literal|0
index|]
argument_list|,
name|timstr
index|[
literal|1
index|]
argument_list|,
name|timstr
index|[
literal|3
index|]
argument_list|,
name|timstr
index|[
literal|4
index|]
argument_list|,
literal|'0'
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"# @$$ ## ##:## *"
argument_list|)
condition|)
block|{
comment|/* Loser format.  This is quite bogus.  */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|2
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|9
expr_stmt|;
name|gmtstr
operator|=
name|NULL
expr_stmt|;
name|TIMEPARSE
argument_list|(
name|ds
argument_list|,
name|timstr
index|[
literal|0
index|]
argument_list|,
name|timstr
index|[
literal|1
index|]
argument_list|,
name|timstr
index|[
literal|3
index|]
argument_list|,
name|timstr
index|[
literal|4
index|]
argument_list|,
literal|'0'
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"## @$$ ## #:##:## *"
argument_list|)
condition|)
block|{
comment|/* Loser format.  This is quite bogus.  */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|9
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|18
expr_stmt|;
name|TIMEPARSE
argument_list|(
name|ds
argument_list|,
literal|'0'
argument_list|,
name|timstr
index|[
literal|1
index|]
argument_list|,
name|timstr
index|[
literal|3
index|]
argument_list|,
name|timstr
index|[
literal|4
index|]
argument_list|,
name|timstr
index|[
literal|6
index|]
argument_list|,
name|timstr
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"# @$$ ## #:##:## *"
argument_list|)
condition|)
block|{
comment|/* Loser format.  This is quite bogus.  */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|70
condition|)
name|ds
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|2
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|8
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|17
expr_stmt|;
name|TIMEPARSE
argument_list|(
name|ds
argument_list|,
literal|'0'
argument_list|,
name|timstr
index|[
literal|1
index|]
argument_list|,
name|timstr
index|[
literal|3
index|]
argument_list|,
name|timstr
index|[
literal|4
index|]
argument_list|,
name|timstr
index|[
literal|6
index|]
argument_list|,
name|timstr
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|" # @$$ #### ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 1123 format with a space instead of a leading zero. */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|12
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|21
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_date_checkmask
argument_list|(
name|date
argument_list|,
literal|"##-@$$-#### ##:##:## *"
argument_list|)
condition|)
block|{
comment|/* RFC 1123 with dashes instead of spaces between date/month/year         * This also looks like RFC 850 with four digit years.         */
name|ds
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|date
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|date
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|date
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ds
operator|.
name|tm_mday
operator|=
operator|(
operator|(
name|date
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
operator|(
name|date
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|monstr
operator|=
name|date
operator|+
literal|3
expr_stmt|;
name|timstr
operator|=
name|date
operator|+
literal|12
expr_stmt|;
name|gmtstr
operator|=
name|date
operator|+
literal|21
expr_stmt|;
name|TIMEPARSE_STD
argument_list|(
name|ds
argument_list|,
name|timstr
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
name|ds
operator|.
name|tm_mday
operator|<=
literal|0
operator|||
name|ds
operator|.
name|tm_mday
operator|>
literal|31
condition|)
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
operator|(
name|ds
operator|.
name|tm_hour
operator|>
literal|23
operator|)
operator|||
operator|(
name|ds
operator|.
name|tm_min
operator|>
literal|59
operator|)
operator|||
operator|(
name|ds
operator|.
name|tm_sec
operator|>
literal|61
operator|)
condition|)
return|return
name|APR_DATE_BAD
return|;
name|mint
operator|=
operator|(
name|monstr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|monstr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|monstr
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|mon
operator|=
literal|0
init|;
name|mon
operator|<
literal|12
condition|;
name|mon
operator|++
control|)
if|if
condition|(
name|mint
operator|==
name|months
index|[
name|mon
index|]
condition|)
break|break;
if|if
condition|(
name|mon
operator|==
literal|12
condition|)
return|return
name|APR_DATE_BAD
return|;
if|if
condition|(
operator|(
name|ds
operator|.
name|tm_mday
operator|==
literal|31
operator|)
operator|&&
operator|(
name|mon
operator|==
literal|3
operator|||
name|mon
operator|==
literal|5
operator|||
name|mon
operator|==
literal|8
operator|||
name|mon
operator|==
literal|10
operator|)
condition|)
return|return
name|APR_DATE_BAD
return|;
comment|/* February gets special check for leapyear */
if|if
condition|(
operator|(
name|mon
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|ds
operator|.
name|tm_mday
operator|>
literal|29
operator|)
operator|||
operator|(
operator|(
name|ds
operator|.
name|tm_mday
operator|==
literal|29
operator|)
operator|&&
operator|(
operator|(
name|ds
operator|.
name|tm_year
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
operator|(
name|ds
operator|.
name|tm_year
operator|%
literal|100
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ds
operator|.
name|tm_year
operator|%
literal|400
operator|)
operator|!=
literal|100
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
name|APR_DATE_BAD
return|;
name|ds
operator|.
name|tm_mon
operator|=
name|mon
expr_stmt|;
comment|/* tm_gmtoff is the number of seconds off of GMT the time is.      *      * We only currently support: [+-]ZZZZ where Z is the offset in      * hours from GMT.      *      * If there is any confusion, tm_gmtoff will remain 0.      */
name|ds
operator|.
name|tm_gmtoff
operator|=
literal|0
expr_stmt|;
comment|/* Do we have a timezone ? */
if|if
condition|(
name|gmtstr
condition|)
block|{
name|int
name|offset
decl_stmt|;
switch|switch
condition|(
operator|*
name|gmtstr
condition|)
block|{
case|case
literal|'-'
case|:
name|offset
operator|=
name|atoi
argument_list|(
name|gmtstr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ds
operator|.
name|tm_gmtoff
operator|-=
operator|(
name|offset
operator|/
literal|100
operator|)
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|ds
operator|.
name|tm_gmtoff
operator|-=
operator|(
name|offset
operator|%
literal|100
operator|)
operator|*
literal|60
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|offset
operator|=
name|atoi
argument_list|(
name|gmtstr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ds
operator|.
name|tm_gmtoff
operator|+=
operator|(
name|offset
operator|/
literal|100
operator|)
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|ds
operator|.
name|tm_gmtoff
operator|+=
operator|(
name|offset
operator|%
literal|100
operator|)
operator|*
literal|60
expr_stmt|;
break|break;
block|}
block|}
comment|/* apr_time_exp_get uses tm_usec field, but it hasn't been set yet.       * It should be safe to just zero out this value.      * tm_usec is the number of microseconds into the second.  HTTP only      * cares about second granularity.      */
name|ds
operator|.
name|tm_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apr_time_exp_gmt_get
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|ds
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|APR_DATE_BAD
return|;
return|return
name|result
return|;
block|}
end_block

end_unit

