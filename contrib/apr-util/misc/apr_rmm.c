begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_rmm.h"
end_include

begin_include
include|#
directive|include
file|"apr_errno.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_comment
comment|/* The RMM region is made up of two doubly-linked-list of blocks; the  * list of used blocks, and the list of free blocks (either list may  * be empty).  The base pointer, rmm->base, points at the beginning of  * the shmem region in use.  Each block is addressable by an  * apr_rmm_off_t value, which represents the offset from the base  * pointer.  The term "address" is used here to mean such a value; an  * "offset from rmm->base".  *  * The RMM region contains exactly one "rmm_hdr_block_t" structure,  * the "header block", which is always stored at the base pointer.  * The firstused field in this structure is the address of the first  * block in the "used blocks" list; the firstfree field is the address  * of the first block in the "free blocks" list.  *  * Each block is prefixed by an "rmm_block_t" structure, followed by  * the caller-usable region represented by the block.  The next and  * prev fields of the structure are zero if the block is at the end or  * beginning of the linked-list respectively, or otherwise hold the  * address of the next and previous blocks in the list.  ("address 0",  * i.e. rmm->base is *not* a valid address for a block, since the  * header block is always stored at that address).  *  * At creation, the RMM region is initialized to hold a single block  * on the free list representing the entire available shm segment  * (minus header block); subsequent allocation and deallocation of  * blocks involves splitting blocks and coalescing adjacent blocks,  * and switching them between the free and used lists as  * appropriate. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rmm_block_t
block|{
name|apr_size_t
name|size
decl_stmt|;
name|apr_rmm_off_t
name|prev
decl_stmt|;
name|apr_rmm_off_t
name|next
decl_stmt|;
block|}
name|rmm_block_t
typedef|;
end_typedef

begin_comment
comment|/* Always at our apr_rmm_off(0):  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rmm_hdr_block_t
block|{
name|apr_size_t
name|abssize
decl_stmt|;
name|apr_rmm_off_t
comment|/* rmm_block_t */
name|firstused
decl_stmt|;
name|apr_rmm_off_t
comment|/* rmm_block_t */
name|firstfree
decl_stmt|;
block|}
name|rmm_hdr_block_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|RMM_HDR_BLOCK_SIZE
value|(APR_ALIGN_DEFAULT(sizeof(rmm_hdr_block_t)))
end_define

begin_define
define|#
directive|define
name|RMM_BLOCK_SIZE
value|(APR_ALIGN_DEFAULT(sizeof(rmm_block_t)))
end_define

begin_struct
struct|struct
name|apr_rmm_t
block|{
name|apr_pool_t
modifier|*
name|p
decl_stmt|;
name|rmm_hdr_block_t
modifier|*
name|base
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|apr_anylock_t
name|lock
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|apr_rmm_off_t
name|find_block_by_offset
parameter_list|(
name|apr_rmm_t
modifier|*
name|rmm
parameter_list|,
name|apr_rmm_off_t
name|next
parameter_list|,
name|apr_rmm_off_t
name|find
parameter_list|,
name|int
name|includes
parameter_list|)
block|{
name|apr_rmm_off_t
name|prev
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|blk
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|next
operator|)
decl_stmt|;
if|if
condition|(
name|find
operator|==
name|next
condition|)
return|return
name|next
return|;
comment|/* Overshot? */
if|if
condition|(
name|find
operator|<
name|next
condition|)
return|return
name|includes
condition|?
name|prev
else|:
literal|0
return|;
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|blk
operator|->
name|next
expr_stmt|;
block|}
return|return
name|includes
condition|?
name|prev
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|apr_rmm_off_t
name|find_block_of_size
parameter_list|(
name|apr_rmm_t
modifier|*
name|rmm
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|apr_rmm_off_t
name|next
init|=
name|rmm
operator|->
name|base
operator|->
name|firstfree
decl_stmt|;
name|apr_rmm_off_t
name|best
init|=
literal|0
decl_stmt|;
name|apr_rmm_off_t
name|bestsize
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|blk
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|next
operator|)
decl_stmt|;
if|if
condition|(
name|blk
operator|->
name|size
operator|==
name|size
condition|)
return|return
name|next
return|;
if|if
condition|(
name|blk
operator|->
name|size
operator|>=
name|size
condition|)
block|{
comment|/* XXX: sub optimal algorithm               * We need the most thorough best-fit logic, since we can              * never grow our rmm, we are SOL when we hit the wall.              */
if|if
condition|(
operator|!
name|bestsize
operator|||
operator|(
name|blk
operator|->
name|size
operator|<
name|bestsize
operator|)
condition|)
block|{
name|bestsize
operator|=
name|blk
operator|->
name|size
expr_stmt|;
name|best
operator|=
name|next
expr_stmt|;
block|}
block|}
name|next
operator|=
name|blk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|bestsize
operator|>
name|RMM_BLOCK_SIZE
operator|+
name|size
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|blk
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|best
operator|)
decl_stmt|;
name|struct
name|rmm_block_t
modifier|*
name|new
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|best
operator|+
name|size
operator|)
decl_stmt|;
name|new
operator|->
name|size
operator|=
name|blk
operator|->
name|size
operator|-
name|size
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|blk
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|best
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|best
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|next
condition|)
block|{
name|blk
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|new
operator|->
name|next
operator|)
expr_stmt|;
name|blk
operator|->
name|prev
operator|=
name|best
operator|+
name|size
expr_stmt|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|move_block
parameter_list|(
name|apr_rmm_t
modifier|*
name|rmm
parameter_list|,
name|apr_rmm_off_t
name|this
parameter_list|,
name|int
name|free
parameter_list|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|blk
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|this
operator|)
decl_stmt|;
comment|/* close the gap */
if|if
condition|(
name|blk
operator|->
name|prev
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|prev
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|prev
operator|)
decl_stmt|;
name|prev
operator|->
name|next
operator|=
name|blk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|free
condition|)
block|{
name|rmm
operator|->
name|base
operator|->
name|firstused
operator|=
name|blk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|rmm
operator|->
name|base
operator|->
name|firstfree
operator|=
name|blk
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blk
operator|->
name|next
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|next
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|next
operator|)
decl_stmt|;
name|next
operator|->
name|prev
operator|=
name|blk
operator|->
name|prev
expr_stmt|;
block|}
comment|/* now find it in the other list, pushing it to the head if required */
if|if
condition|(
name|free
condition|)
block|{
name|blk
operator|->
name|prev
operator|=
name|find_block_by_offset
argument_list|(
name|rmm
argument_list|,
name|rmm
operator|->
name|base
operator|->
name|firstfree
argument_list|,
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blk
operator|->
name|prev
condition|)
block|{
name|blk
operator|->
name|next
operator|=
name|rmm
operator|->
name|base
operator|->
name|firstfree
expr_stmt|;
name|rmm
operator|->
name|base
operator|->
name|firstfree
operator|=
name|this
expr_stmt|;
block|}
block|}
else|else
block|{
name|blk
operator|->
name|prev
operator|=
name|find_block_by_offset
argument_list|(
name|rmm
argument_list|,
name|rmm
operator|->
name|base
operator|->
name|firstused
argument_list|,
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blk
operator|->
name|prev
condition|)
block|{
name|blk
operator|->
name|next
operator|=
name|rmm
operator|->
name|base
operator|->
name|firstused
expr_stmt|;
name|rmm
operator|->
name|base
operator|->
name|firstused
operator|=
name|this
expr_stmt|;
block|}
block|}
comment|/* and open it up */
if|if
condition|(
name|blk
operator|->
name|prev
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|prev
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|prev
operator|)
decl_stmt|;
if|if
condition|(
name|free
operator|&&
operator|(
name|blk
operator|->
name|prev
operator|+
name|prev
operator|->
name|size
operator|==
name|this
operator|)
condition|)
block|{
comment|/* Collapse us into our predecessor */
name|prev
operator|->
name|size
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|this
operator|=
name|blk
operator|->
name|prev
expr_stmt|;
name|blk
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|blk
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|this
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blk
operator|->
name|next
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|next
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|next
operator|)
decl_stmt|;
if|if
condition|(
name|free
operator|&&
operator|(
name|this
operator|+
name|blk
operator|->
name|size
operator|==
name|blk
operator|->
name|next
operator|)
condition|)
block|{
comment|/* Collapse us into our successor */
name|blk
operator|->
name|size
operator|+=
name|next
operator|->
name|size
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|blk
operator|->
name|next
condition|)
block|{
name|next
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|next
operator|)
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|this
expr_stmt|;
block|}
block|}
else|else
block|{
name|next
operator|->
name|prev
operator|=
name|this
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_init
argument_list|(
argument|apr_rmm_t **rmm
argument_list|,
argument|apr_anylock_t *lock
argument_list|,
argument|void *base
argument_list|,
argument|apr_size_t size
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|rmm_block_t
modifier|*
name|blk
decl_stmt|;
name|apr_anylock_t
name|nulllock
decl_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
block|{
name|nulllock
operator|.
name|type
operator|=
name|apr_anylock_none
expr_stmt|;
name|nulllock
operator|.
name|lock
operator|.
name|pm
operator|=
name|NULL
expr_stmt|;
name|lock
operator|=
operator|&
name|nulllock
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|APR_ANYLOCK_LOCK
argument_list|(
name|lock
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|rv
return|;
operator|(
operator|*
name|rmm
operator|)
operator|=
operator|(
name|apr_rmm_t
operator|*
operator|)
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_rmm_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|p
operator|=
name|p
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|=
name|base
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|size
operator|=
name|size
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|lock
operator|=
operator|*
name|lock
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|->
name|abssize
operator|=
name|size
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|->
name|firstused
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|->
name|firstfree
operator|=
name|RMM_HDR_BLOCK_SIZE
expr_stmt|;
name|blk
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|base
operator|+
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|->
name|firstfree
operator|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|size
operator|-
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|->
name|firstfree
expr_stmt|;
name|blk
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|blk
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
name|APR_ANYLOCK_UNLOCK
argument_list|(
name|lock
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_destroy
argument_list|(
argument|apr_rmm_t *rmm
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|rmm_block_t
modifier|*
name|blk
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|APR_ANYLOCK_LOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
comment|/* Blast it all --- no going back :) */
if|if
condition|(
name|rmm
operator|->
name|base
operator|->
name|firstused
condition|)
block|{
name|apr_rmm_off_t
name|this
init|=
name|rmm
operator|->
name|base
operator|->
name|firstused
decl_stmt|;
do|do
block|{
name|blk
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|this
operator|)
expr_stmt|;
name|this
operator|=
name|blk
operator|->
name|next
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|blk
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|this
condition|)
do|;
name|rmm
operator|->
name|base
operator|->
name|firstused
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rmm
operator|->
name|base
operator|->
name|firstfree
condition|)
block|{
name|apr_rmm_off_t
name|this
init|=
name|rmm
operator|->
name|base
operator|->
name|firstfree
decl_stmt|;
do|do
block|{
name|blk
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|this
operator|)
expr_stmt|;
name|this
operator|=
name|blk
operator|->
name|next
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|blk
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|this
condition|)
do|;
name|rmm
operator|->
name|base
operator|->
name|firstfree
operator|=
literal|0
expr_stmt|;
block|}
name|rmm
operator|->
name|base
operator|->
name|abssize
operator|=
literal|0
expr_stmt|;
name|rmm
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_attach
argument_list|(
argument|apr_rmm_t **rmm
argument_list|,
argument|apr_anylock_t *lock
argument_list|,
argument|void *base
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|apr_anylock_t
name|nulllock
decl_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
block|{
name|nulllock
operator|.
name|type
operator|=
name|apr_anylock_none
expr_stmt|;
name|nulllock
operator|.
name|lock
operator|.
name|pm
operator|=
name|NULL
expr_stmt|;
name|lock
operator|=
operator|&
name|nulllock
expr_stmt|;
block|}
comment|/* sanity would be good here */
operator|(
operator|*
name|rmm
operator|)
operator|=
operator|(
name|apr_rmm_t
operator|*
operator|)
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_rmm_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|p
operator|=
name|p
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|=
name|base
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|size
operator|=
operator|(
operator|*
name|rmm
operator|)
operator|->
name|base
operator|->
name|abssize
expr_stmt|;
operator|(
operator|*
name|rmm
operator|)
operator|->
name|lock
operator|=
operator|*
name|lock
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_detach
argument_list|(
argument|apr_rmm_t *rmm
argument_list|)
end_macro

begin_block
block|{
comment|/* A noop until we introduce locked/refcounts */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_rmm_off_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_malloc
argument_list|(
argument|apr_rmm_t *rmm
argument_list|,
argument|apr_size_t reqsize
argument_list|)
end_macro

begin_block
block|{
name|apr_size_t
name|size
decl_stmt|;
name|apr_rmm_off_t
name|this
decl_stmt|;
name|size
operator|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|reqsize
argument_list|)
operator|+
name|RMM_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|reqsize
condition|)
block|{
return|return
literal|0
return|;
block|}
name|APR_ANYLOCK_LOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|this
operator|=
name|find_block_of_size
argument_list|(
name|rmm
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
condition|)
block|{
name|move_block
argument_list|(
name|rmm
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|+=
name|RMM_BLOCK_SIZE
expr_stmt|;
block|}
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_rmm_off_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_calloc
argument_list|(
argument|apr_rmm_t *rmm
argument_list|,
argument|apr_size_t reqsize
argument_list|)
end_macro

begin_block
block|{
name|apr_size_t
name|size
decl_stmt|;
name|apr_rmm_off_t
name|this
decl_stmt|;
name|size
operator|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|reqsize
argument_list|)
operator|+
name|RMM_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|reqsize
condition|)
block|{
return|return
literal|0
return|;
block|}
name|APR_ANYLOCK_LOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|this
operator|=
name|find_block_of_size
argument_list|(
name|rmm
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
condition|)
block|{
name|move_block
argument_list|(
name|rmm
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|+=
name|RMM_BLOCK_SIZE
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|this
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|RMM_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_rmm_off_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_realloc
argument_list|(
argument|apr_rmm_t *rmm
argument_list|,
argument|void *entity
argument_list|,
argument|apr_size_t reqsize
argument_list|)
end_macro

begin_block
block|{
name|apr_rmm_off_t
name|this
decl_stmt|;
name|apr_rmm_off_t
name|old
decl_stmt|;
name|struct
name|rmm_block_t
modifier|*
name|blk
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|,
name|oldsize
decl_stmt|;
if|if
condition|(
operator|!
name|entity
condition|)
block|{
return|return
name|apr_rmm_malloc
argument_list|(
name|rmm
argument_list|,
name|reqsize
argument_list|)
return|;
block|}
name|size
operator|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|reqsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|reqsize
condition|)
block|{
return|return
literal|0
return|;
block|}
name|old
operator|=
name|apr_rmm_offset_get
argument_list|(
name|rmm
argument_list|,
name|entity
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|=
name|apr_rmm_malloc
argument_list|(
name|rmm
argument_list|,
name|size
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|blk
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|old
operator|-
name|RMM_BLOCK_SIZE
operator|)
expr_stmt|;
name|oldsize
operator|=
name|blk
operator|->
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|apr_rmm_addr_get
argument_list|(
name|rmm
argument_list|,
name|this
argument_list|)
argument_list|,
name|apr_rmm_addr_get
argument_list|(
name|rmm
argument_list|,
name|old
argument_list|)
argument_list|,
name|oldsize
operator|<
name|size
condition|?
name|oldsize
else|:
name|size
argument_list|)
expr_stmt|;
name|apr_rmm_free
argument_list|(
name|rmm
argument_list|,
name|old
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_free
argument_list|(
argument|apr_rmm_t *rmm
argument_list|,
argument|apr_rmm_off_t this
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|struct
name|rmm_block_t
modifier|*
name|blk
decl_stmt|;
comment|/* A little sanity check is always healthy, especially here.      * If we really cared, we could make this compile-time      */
if|if
condition|(
name|this
operator|<
name|RMM_HDR_BLOCK_SIZE
operator|+
name|RMM_BLOCK_SIZE
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
name|this
operator|-=
name|RMM_BLOCK_SIZE
expr_stmt|;
name|blk
operator|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|this
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|APR_ANYLOCK_LOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
name|blk
operator|->
name|prev
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|prev
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|prev
operator|)
decl_stmt|;
if|if
condition|(
name|prev
operator|->
name|next
operator|!=
name|this
condition|)
block|{
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rmm
operator|->
name|base
operator|->
name|firstused
operator|!=
name|this
condition|)
block|{
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
block|}
if|if
condition|(
name|blk
operator|->
name|next
condition|)
block|{
name|struct
name|rmm_block_t
modifier|*
name|next
init|=
operator|(
name|rmm_block_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|blk
operator|->
name|next
operator|)
decl_stmt|;
if|if
condition|(
name|next
operator|->
name|prev
operator|!=
name|this
condition|)
block|{
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
block|}
comment|/* Ok, it remained [apparently] sane, so unlink it      */
name|move_block
argument_list|(
name|rmm
argument_list|,
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|APR_ANYLOCK_UNLOCK
argument_list|(
operator|&
name|rmm
operator|->
name|lock
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_rmm_addr_get
argument_list|(
argument|apr_rmm_t *rmm
argument_list|,
argument|apr_rmm_off_t entity
argument_list|)
end_macro

begin_block
block|{
comment|/* debug-sanity checking here would be good      */
return|return
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|+
name|entity
operator|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_rmm_off_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_offset_get
argument_list|(
argument|apr_rmm_t *rmm
argument_list|,
argument|void* entity
argument_list|)
end_macro

begin_block
block|{
comment|/* debug, or always, sanity checking here would be good      * since the primitive is apr_rmm_off_t, I don't mind penalizing      * inverse conversions for safety, unless someone can prove that      * there is no choice in some cases.      */
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|entity
operator|-
operator|(
name|char
operator|*
operator|)
name|rmm
operator|->
name|base
operator|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_rmm_overhead_get
argument_list|(
argument|int n
argument_list|)
end_macro

begin_block
block|{
comment|/* overhead per block is at most APR_ALIGN_DEFAULT(1) wasted bytes      * for alignment overhead, plus the size of the rmm_block_t      * structure. */
return|return
name|RMM_HDR_BLOCK_SIZE
operator|+
name|n
operator|*
operator|(
name|RMM_BLOCK_SIZE
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

