begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_include
include|#
directive|include
file|"apr_reslist.h"
end_include

begin_include
include|#
directive|include
file|"apr_errno.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_thread_mutex.h"
end_include

begin_include
include|#
directive|include
file|"apr_thread_cond.h"
end_include

begin_include
include|#
directive|include
file|"apr_ring.h"
end_include

begin_comment
comment|/**  * A single resource element.  */
end_comment

begin_struct
struct|struct
name|apr_res_t
block|{
name|apr_time_t
name|freed
decl_stmt|;
name|void
modifier|*
name|opaque
decl_stmt|;
name|APR_RING_ENTRY
argument_list|(
argument|apr_res_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|apr_res_t
name|apr_res_t
typedef|;
end_typedef

begin_comment
comment|/**  * A ring of resources representing the list of available resources.  */
end_comment

begin_expr_stmt
name|APR_RING_HEAD
argument_list|(
name|apr_resring_t
argument_list|,
name|apr_res_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|apr_resring_t
name|apr_resring_t
typedef|;
end_typedef

begin_struct
struct|struct
name|apr_reslist_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* the pool used in constructor and destructor calls */
name|int
name|ntotal
decl_stmt|;
comment|/* total number of resources managed by this list */
name|int
name|nidle
decl_stmt|;
comment|/* number of available resources */
name|int
name|min
decl_stmt|;
comment|/* desired minimum number of available resources */
name|int
name|smax
decl_stmt|;
comment|/* soft maximum on the total number of resources */
name|int
name|hmax
decl_stmt|;
comment|/* hard maximum on the total number of resources */
name|apr_interval_time_t
name|ttl
decl_stmt|;
comment|/* TTL when we have too many resources */
name|apr_interval_time_t
name|timeout
decl_stmt|;
comment|/* Timeout for waiting on resource */
name|apr_reslist_constructor
name|constructor
decl_stmt|;
name|apr_reslist_destructor
name|destructor
decl_stmt|;
name|void
modifier|*
name|params
decl_stmt|;
comment|/* opaque data passed to constructor and destructor calls */
name|apr_resring_t
name|avail_list
decl_stmt|;
name|apr_resring_t
name|free_list
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|listlock
decl_stmt|;
name|apr_thread_cond_t
modifier|*
name|avail
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/**  * Grab a resource from the front of the resource list.  * Assumes: that the reslist is locked.  */
end_comment

begin_function
specifier|static
name|apr_res_t
modifier|*
name|pop_resource
parameter_list|(
name|apr_reslist_t
modifier|*
name|reslist
parameter_list|)
block|{
name|apr_res_t
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|APR_RING_FIRST
argument_list|(
operator|&
name|reslist
operator|->
name|avail_list
argument_list|)
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|reslist
operator|->
name|nidle
operator|--
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * Add a resource to the beginning of the list, set the time at which  * it was added to the list.  * Assumes: that the reslist is locked.  */
end_comment

begin_function
specifier|static
name|void
name|push_resource
parameter_list|(
name|apr_reslist_t
modifier|*
name|reslist
parameter_list|,
name|apr_res_t
modifier|*
name|resource
parameter_list|)
block|{
name|APR_RING_INSERT_HEAD
argument_list|(
operator|&
name|reslist
operator|->
name|avail_list
argument_list|,
name|resource
argument_list|,
name|apr_res_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|resource
operator|->
name|freed
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
name|reslist
operator|->
name|nidle
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get an resource container from the free list or create a new one.  */
end_comment

begin_function
specifier|static
name|apr_res_t
modifier|*
name|get_container
parameter_list|(
name|apr_reslist_t
modifier|*
name|reslist
parameter_list|)
block|{
name|apr_res_t
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|APR_RING_EMPTY
argument_list|(
operator|&
name|reslist
operator|->
name|free_list
argument_list|,
name|apr_res_t
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|res
operator|=
name|APR_RING_FIRST
argument_list|(
operator|&
name|reslist
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|apr_pcalloc
argument_list|(
name|reslist
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * Free up a resource container by placing it on the free list.  */
end_comment

begin_function
specifier|static
name|void
name|free_container
parameter_list|(
name|apr_reslist_t
modifier|*
name|reslist
parameter_list|,
name|apr_res_t
modifier|*
name|container
parameter_list|)
block|{
name|APR_RING_INSERT_TAIL
argument_list|(
operator|&
name|reslist
operator|->
name|free_list
argument_list|,
name|container
argument_list|,
name|apr_res_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Create a new resource and return it.  * Assumes: that the reslist is locked.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|create_resource
parameter_list|(
name|apr_reslist_t
modifier|*
name|reslist
parameter_list|,
name|apr_res_t
modifier|*
modifier|*
name|ret_res
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|apr_res_t
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|get_container
argument_list|(
name|reslist
argument_list|)
expr_stmt|;
name|rv
operator|=
name|reslist
operator|->
name|constructor
argument_list|(
operator|&
name|res
operator|->
name|opaque
argument_list|,
name|reslist
operator|->
name|params
argument_list|,
name|reslist
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|ret_res
operator|=
name|res
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/**  * Destroy a single idle resource.  * Assumes: that the reslist is locked.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|destroy_resource
parameter_list|(
name|apr_reslist_t
modifier|*
name|reslist
parameter_list|,
name|apr_res_t
modifier|*
name|res
parameter_list|)
block|{
return|return
name|reslist
operator|->
name|destructor
argument_list|(
name|res
operator|->
name|opaque
argument_list|,
name|reslist
operator|->
name|params
argument_list|,
name|reslist
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|reslist_cleanup
parameter_list|(
name|void
modifier|*
name|data_
parameter_list|)
block|{
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_reslist_t
modifier|*
name|rl
init|=
name|data_
decl_stmt|;
name|apr_res_t
modifier|*
name|res
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_lock
argument_list|(
name|rl
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|rl
operator|->
name|nidle
operator|>
literal|0
condition|)
block|{
name|apr_status_t
name|rv1
decl_stmt|;
name|res
operator|=
name|pop_resource
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|rl
operator|->
name|ntotal
operator|--
expr_stmt|;
name|rv1
operator|=
name|destroy_resource
argument_list|(
name|rl
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv1
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|rv
operator|=
name|rv1
expr_stmt|;
comment|/* loses info in the unlikely event of                         * multiple *different* failures */
block|}
name|free_container
argument_list|(
name|rl
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|rl
operator|->
name|nidle
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rl
operator|->
name|ntotal
operator|==
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|rl
operator|->
name|listlock
argument_list|)
expr_stmt|;
name|apr_thread_mutex_destroy
argument_list|(
name|rl
operator|->
name|listlock
argument_list|)
expr_stmt|;
name|apr_thread_cond_destroy
argument_list|(
name|rl
operator|->
name|avail
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/**  * Perform routine maintenance on the resource list. This call  * may instantiate new resources or expire old resources.  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_maintain
argument_list|(
argument|apr_reslist_t *reslist
argument_list|)
end_macro

begin_block
block|{
name|apr_time_t
name|now
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_res_t
modifier|*
name|res
decl_stmt|;
name|int
name|created_one
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_lock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check if we need to create more resources, and if we are allowed to. */
while|while
condition|(
name|reslist
operator|->
name|nidle
operator|<
name|reslist
operator|->
name|min
operator|&&
name|reslist
operator|->
name|ntotal
operator|<
name|reslist
operator|->
name|hmax
condition|)
block|{
comment|/* Create the resource */
name|rv
operator|=
name|create_resource
argument_list|(
name|reslist
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|free_container
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
comment|/* Add it to the list */
name|push_resource
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
comment|/* Update our counters */
name|reslist
operator|->
name|ntotal
operator|++
expr_stmt|;
comment|/* If someone is waiting on that guy, wake them up. */
if|#
directive|if
name|APR_HAS_THREADS
name|rv
operator|=
name|apr_thread_cond_signal
argument_list|(
name|reslist
operator|->
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
endif|#
directive|endif
name|created_one
operator|++
expr_stmt|;
block|}
comment|/* We don't need to see if we're over the max if we were under it before */
if|if
condition|(
name|created_one
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* Check if we need to expire old resources */
name|now
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
while|while
condition|(
name|reslist
operator|->
name|nidle
operator|>
name|reslist
operator|->
name|smax
operator|&&
name|reslist
operator|->
name|nidle
operator|>
literal|0
condition|)
block|{
comment|/* Peak at the last resource in the list */
name|res
operator|=
name|APR_RING_LAST
argument_list|(
operator|&
name|reslist
operator|->
name|avail_list
argument_list|)
expr_stmt|;
comment|/* See if the oldest entry should be expired */
if|if
condition|(
name|now
operator|-
name|res
operator|->
name|freed
operator|<
name|reslist
operator|->
name|ttl
condition|)
block|{
comment|/* If this entry is too young, none of the others              * will be ready to be expired either, so we are done. */
break|break;
block|}
name|APR_RING_REMOVE
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|reslist
operator|->
name|nidle
operator|--
expr_stmt|;
name|reslist
operator|->
name|ntotal
operator|--
expr_stmt|;
name|rv
operator|=
name|destroy_resource
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|free_container
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
block|}
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_create
argument_list|(
argument|apr_reslist_t **reslist
argument_list|,
argument|int min
argument_list|,
argument|int smax
argument_list|,
argument|int hmax
argument_list|,
argument|apr_interval_time_t ttl
argument_list|,
argument|apr_reslist_constructor con
argument_list|,
argument|apr_reslist_destructor de
argument_list|,
argument|void *params
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|apr_reslist_t
modifier|*
name|rl
decl_stmt|;
comment|/* Do some sanity checks so we don't thrash around in the      * maintenance routine later. */
if|if
condition|(
name|min
operator|<
literal|0
operator|||
name|min
operator|>
name|smax
operator|||
name|min
operator|>
name|hmax
operator|||
name|smax
operator|>
name|hmax
operator|||
name|hmax
operator|==
literal|0
operator|||
name|ttl
operator|<
literal|0
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
if|#
directive|if
operator|!
name|APR_HAS_THREADS
comment|/* There can be only one resource when we have no threads. */
if|if
condition|(
name|min
operator|>
literal|0
condition|)
block|{
name|min
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|smax
operator|>
literal|0
condition|)
block|{
name|smax
operator|=
literal|1
expr_stmt|;
block|}
name|hmax
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|rl
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|rl
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|rl
operator|->
name|min
operator|=
name|min
expr_stmt|;
name|rl
operator|->
name|smax
operator|=
name|smax
expr_stmt|;
name|rl
operator|->
name|hmax
operator|=
name|hmax
expr_stmt|;
name|rl
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|rl
operator|->
name|constructor
operator|=
name|con
expr_stmt|;
name|rl
operator|->
name|destructor
operator|=
name|de
expr_stmt|;
name|rl
operator|->
name|params
operator|=
name|params
expr_stmt|;
name|APR_RING_INIT
argument_list|(
operator|&
name|rl
operator|->
name|avail_list
argument_list|,
name|apr_res_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APR_RING_INIT
argument_list|(
operator|&
name|rl
operator|->
name|free_list
argument_list|,
name|apr_res_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|rl
operator|->
name|listlock
argument_list|,
name|APR_THREAD_MUTEX_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_thread_cond_create
argument_list|(
operator|&
name|rl
operator|->
name|avail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
endif|#
directive|endif
name|rv
operator|=
name|apr_reslist_maintain
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
comment|/* Destroy what we've created so far.          */
name|reslist_cleanup
argument_list|(
name|rl
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|apr_pool_cleanup_register
argument_list|(
name|rl
operator|->
name|pool
argument_list|,
name|rl
argument_list|,
name|reslist_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
operator|*
name|reslist
operator|=
name|rl
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_destroy
argument_list|(
argument|apr_reslist_t *reslist
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_pool_cleanup_run
argument_list|(
name|reslist
operator|->
name|pool
argument_list|,
name|reslist
argument_list|,
name|reslist_cleanup
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_acquire
argument_list|(
argument|apr_reslist_t *reslist
argument_list|,
argument|void **resource
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|apr_res_t
modifier|*
name|res
decl_stmt|;
name|apr_time_t
name|now
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_lock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If there are idle resources on the available list, use      * them right away. */
name|now
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
while|while
condition|(
name|reslist
operator|->
name|nidle
operator|>
literal|0
condition|)
block|{
comment|/* Pop off the first resource */
name|res
operator|=
name|pop_resource
argument_list|(
name|reslist
argument_list|)
expr_stmt|;
if|if
condition|(
name|reslist
operator|->
name|ttl
operator|&&
operator|(
name|now
operator|-
name|res
operator|->
name|freed
operator|>=
name|reslist
operator|->
name|ttl
operator|)
condition|)
block|{
comment|/* this res is expired - kill it */
name|reslist
operator|->
name|ntotal
operator|--
expr_stmt|;
name|rv
operator|=
name|destroy_resource
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|free_container
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
comment|/* FIXME: this might cause unnecessary fails */
block|}
continue|continue;
block|}
operator|*
name|resource
operator|=
name|res
operator|->
name|opaque
expr_stmt|;
name|free_container
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* If we've hit our max, block until we're allowed to create      * a new one, or something becomes free. */
while|while
condition|(
name|reslist
operator|->
name|ntotal
operator|>=
name|reslist
operator|->
name|hmax
operator|&&
name|reslist
operator|->
name|nidle
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|reslist
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_thread_cond_timedwait
argument_list|(
name|reslist
operator|->
name|avail
argument_list|,
name|reslist
operator|->
name|listlock
argument_list|,
name|reslist
operator|->
name|timeout
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
else|else
block|{
name|apr_thread_cond_wait
argument_list|(
name|reslist
operator|->
name|avail
argument_list|,
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
return|return
name|APR_EAGAIN
return|;
endif|#
directive|endif
block|}
comment|/* If we popped out of the loop, first try to see if there      * are new resources available for immediate use. */
if|if
condition|(
name|reslist
operator|->
name|nidle
operator|>
literal|0
condition|)
block|{
name|res
operator|=
name|pop_resource
argument_list|(
name|reslist
argument_list|)
expr_stmt|;
operator|*
name|resource
operator|=
name|res
operator|->
name|opaque
expr_stmt|;
name|free_container
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* Otherwise the reason we dropped out of the loop      * was because there is a new slot available, so create      * a resource to fill the slot and use it. */
else|else
block|{
name|rv
operator|=
name|create_resource
argument_list|(
name|reslist
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
block|{
name|reslist
operator|->
name|ntotal
operator|++
expr_stmt|;
operator|*
name|resource
operator|=
name|res
operator|->
name|opaque
expr_stmt|;
block|}
name|free_container
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_release
argument_list|(
argument|apr_reslist_t *reslist
argument_list|,
argument|void *resource
argument_list|)
end_macro

begin_block
block|{
name|apr_res_t
modifier|*
name|res
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_lock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res
operator|=
name|get_container
argument_list|(
name|reslist
argument_list|)
expr_stmt|;
name|res
operator|->
name|opaque
operator|=
name|resource
expr_stmt|;
name|push_resource
argument_list|(
name|reslist
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_cond_signal
argument_list|(
name|reslist
operator|->
name|avail
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|apr_reslist_maintain
argument_list|(
name|reslist
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_reslist_timeout_set
argument_list|(
argument|apr_reslist_t *reslist
argument_list|,
argument|apr_interval_time_t timeout
argument_list|)
end_macro

begin_block
block|{
name|reslist
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_uint32_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_acquired_count
argument_list|(
argument|apr_reslist_t *reslist
argument_list|)
end_macro

begin_block
block|{
name|apr_uint32_t
name|count
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_lock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|reslist
operator|->
name|ntotal
operator|-
name|reslist
operator|->
name|nidle
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|count
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_reslist_invalidate
argument_list|(
argument|apr_reslist_t *reslist
argument_list|,
argument|void *resource
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|ret
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_lock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|reslist
operator|->
name|destructor
argument_list|(
name|resource
argument_list|,
name|reslist
operator|->
name|params
argument_list|,
name|reslist
operator|->
name|pool
argument_list|)
expr_stmt|;
name|reslist
operator|->
name|ntotal
operator|--
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_cond_signal
argument_list|(
name|reslist
operator|->
name|avail
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|reslist
operator|->
name|listlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_reslist_cleanup_order_set
argument_list|(
argument|apr_reslist_t *rl
argument_list|,
argument|apr_uint32_t mode
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_cleanup_kill
argument_list|(
name|rl
operator|->
name|pool
argument_list|,
name|rl
argument_list|,
name|reslist_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APR_RESLIST_CLEANUP_FIRST
condition|)
name|apr_pool_pre_cleanup_register
argument_list|(
name|rl
operator|->
name|pool
argument_list|,
name|rl
argument_list|,
name|reslist_cleanup
argument_list|)
expr_stmt|;
else|else
name|apr_pool_cleanup_register
argument_list|(
name|rl
operator|->
name|pool
argument_list|,
name|rl
argument_list|,
name|reslist_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

