begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed  * with this work for additional information regarding copyright  * ownership.  The ASF licenses this file to you under the Apache  * License, Version 2.0 (the "License"); you may not use this file  * except in compliance with the License.  You may obtain a copy of  * the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  * implied.  See the License for the specific language governing  * permissions and limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"apr_thread_pool.h"
end_include

begin_include
include|#
directive|include
file|"apr_ring.h"
end_include

begin_include
include|#
directive|include
file|"apr_thread_cond.h"
end_include

begin_include
include|#
directive|include
file|"apr_portable.h"
end_include

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_define
define|#
directive|define
name|TASK_PRIORITY_SEGS
value|4
end_define

begin_define
define|#
directive|define
name|TASK_PRIORITY_SEG
parameter_list|(
name|x
parameter_list|)
value|(((x)->dispatch.priority& 0xFF) / 64)
end_define

begin_typedef
typedef|typedef
struct|struct
name|apr_thread_pool_task
block|{
name|APR_RING_ENTRY
argument_list|(
argument|apr_thread_pool_task
argument_list|)
name|link
expr_stmt|;
name|apr_thread_start_t
name|func
decl_stmt|;
name|void
modifier|*
name|param
decl_stmt|;
name|void
modifier|*
name|owner
decl_stmt|;
union|union
block|{
name|apr_byte_t
name|priority
decl_stmt|;
name|apr_time_t
name|time
decl_stmt|;
block|}
name|dispatch
union|;
block|}
name|apr_thread_pool_task_t
typedef|;
end_typedef

begin_expr_stmt
name|APR_RING_HEAD
argument_list|(
name|apr_thread_pool_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|apr_thread_list_elt
block|{
name|APR_RING_ENTRY
argument_list|(
argument|apr_thread_list_elt
argument_list|)
name|link
expr_stmt|;
name|apr_thread_t
modifier|*
name|thd
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|current_owner
decl_stmt|;
specifier|volatile
enum|enum
block|{
name|TH_RUN
block|,
name|TH_STOP
block|,
name|TH_PROBATION
block|}
name|state
enum|;
block|}
struct|;
end_struct

begin_expr_stmt
name|APR_RING_HEAD
argument_list|(
name|apr_thread_list
argument_list|,
name|apr_thread_list_elt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|apr_thread_pool
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|volatile
name|apr_size_t
name|thd_max
decl_stmt|;
specifier|volatile
name|apr_size_t
name|idle_max
decl_stmt|;
specifier|volatile
name|apr_interval_time_t
name|idle_wait
decl_stmt|;
specifier|volatile
name|apr_size_t
name|thd_cnt
decl_stmt|;
specifier|volatile
name|apr_size_t
name|idle_cnt
decl_stmt|;
specifier|volatile
name|apr_size_t
name|task_cnt
decl_stmt|;
specifier|volatile
name|apr_size_t
name|scheduled_task_cnt
decl_stmt|;
specifier|volatile
name|apr_size_t
name|threshold
decl_stmt|;
specifier|volatile
name|apr_size_t
name|tasks_run
decl_stmt|;
specifier|volatile
name|apr_size_t
name|tasks_high
decl_stmt|;
specifier|volatile
name|apr_size_t
name|thd_high
decl_stmt|;
specifier|volatile
name|apr_size_t
name|thd_timed_out
decl_stmt|;
name|struct
name|apr_thread_pool_tasks
modifier|*
name|tasks
decl_stmt|;
name|struct
name|apr_thread_pool_tasks
modifier|*
name|scheduled_tasks
decl_stmt|;
name|struct
name|apr_thread_list
modifier|*
name|busy_thds
decl_stmt|;
name|struct
name|apr_thread_list
modifier|*
name|idle_thds
decl_stmt|;
name|apr_thread_mutex_t
modifier|*
name|lock
decl_stmt|;
name|apr_thread_cond_t
modifier|*
name|cond
decl_stmt|;
specifier|volatile
name|int
name|terminated
decl_stmt|;
name|struct
name|apr_thread_pool_tasks
modifier|*
name|recycled_tasks
decl_stmt|;
name|struct
name|apr_thread_list
modifier|*
name|recycled_thds
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|task_idx
index|[
name|TASK_PRIORITY_SEGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|apr_status_t
name|thread_pool_construct
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_size_t
name|init_threads
parameter_list|,
name|apr_size_t
name|max_threads
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|me
operator|->
name|thd_max
operator|=
name|max_threads
expr_stmt|;
name|me
operator|->
name|idle_max
operator|=
name|init_threads
expr_stmt|;
name|me
operator|->
name|threshold
operator|=
name|init_threads
operator|/
literal|2
expr_stmt|;
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|me
operator|->
name|lock
argument_list|,
name|APR_THREAD_MUTEX_NESTED
argument_list|,
name|me
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|!=
name|rv
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_thread_cond_create
argument_list|(
operator|&
name|me
operator|->
name|cond
argument_list|,
name|me
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|!=
name|rv
condition|)
block|{
name|apr_thread_mutex_destroy
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|me
operator|->
name|tasks
operator|=
name|apr_palloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|tasks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|me
operator|->
name|tasks
condition|)
block|{
goto|goto
name|CATCH_ENOMEM
goto|;
block|}
name|APR_RING_INIT
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|scheduled_tasks
operator|=
name|apr_palloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|scheduled_tasks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|me
operator|->
name|scheduled_tasks
condition|)
block|{
goto|goto
name|CATCH_ENOMEM
goto|;
block|}
name|APR_RING_INIT
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|recycled_tasks
operator|=
name|apr_palloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|recycled_tasks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|me
operator|->
name|recycled_tasks
condition|)
block|{
goto|goto
name|CATCH_ENOMEM
goto|;
block|}
name|APR_RING_INIT
argument_list|(
name|me
operator|->
name|recycled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|busy_thds
operator|=
name|apr_palloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|busy_thds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|me
operator|->
name|busy_thds
condition|)
block|{
goto|goto
name|CATCH_ENOMEM
goto|;
block|}
name|APR_RING_INIT
argument_list|(
name|me
operator|->
name|busy_thds
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|idle_thds
operator|=
name|apr_palloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|idle_thds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|me
operator|->
name|idle_thds
condition|)
block|{
goto|goto
name|CATCH_ENOMEM
goto|;
block|}
name|APR_RING_INIT
argument_list|(
name|me
operator|->
name|idle_thds
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|recycled_thds
operator|=
name|apr_palloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|recycled_thds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|me
operator|->
name|recycled_thds
condition|)
block|{
goto|goto
name|CATCH_ENOMEM
goto|;
block|}
name|APR_RING_INIT
argument_list|(
name|me
operator|->
name|recycled_thds
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|thd_cnt
operator|=
name|me
operator|->
name|idle_cnt
operator|=
name|me
operator|->
name|task_cnt
operator|=
name|me
operator|->
name|scheduled_task_cnt
operator|=
literal|0
expr_stmt|;
name|me
operator|->
name|tasks_run
operator|=
name|me
operator|->
name|tasks_high
operator|=
name|me
operator|->
name|thd_high
operator|=
name|me
operator|->
name|thd_timed_out
operator|=
literal|0
expr_stmt|;
name|me
operator|->
name|idle_wait
operator|=
literal|0
expr_stmt|;
name|me
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TASK_PRIORITY_SEGS
condition|;
name|i
operator|++
control|)
block|{
name|me
operator|->
name|task_idx
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|FINAL_EXIT
goto|;
name|CATCH_ENOMEM
label|:
name|rv
operator|=
name|APR_ENOMEM
expr_stmt|;
name|apr_thread_mutex_destroy
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_cond_destroy
argument_list|(
name|me
operator|->
name|cond
argument_list|)
expr_stmt|;
name|FINAL_EXIT
label|:
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: This function is not thread safe by itself. Caller should hold the lock  */
end_comment

begin_function
specifier|static
name|apr_thread_pool_task_t
modifier|*
name|pop_task
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|task
init|=
name|NULL
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* check for scheduled tasks */
if|if
condition|(
name|me
operator|->
name|scheduled_task_cnt
operator|>
literal|0
condition|)
block|{
name|task
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task
operator|!=
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if it's time */
if|if
condition|(
name|task
operator|->
name|dispatch
operator|.
name|time
operator|<=
name|apr_time_now
argument_list|()
condition|)
block|{
operator|--
name|me
operator|->
name|scheduled_task_cnt
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|task
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
block|}
comment|/* check for normal tasks if we're not returning a scheduled task */
if|if
condition|(
name|me
operator|->
name|task_cnt
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|task
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|tasks
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task
operator|!=
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|me
operator|->
name|task_cnt
expr_stmt|;
name|seg
operator|=
name|TASK_PRIORITY_SEG
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|==
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
condition|)
block|{
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|=
name|APR_RING_NEXT
argument_list|(
name|task
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|==
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
operator|||
name|TASK_PRIORITY_SEG
argument_list|(
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
argument_list|)
operator|!=
name|seg
condition|)
block|{
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|APR_RING_REMOVE
argument_list|(
name|task
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
end_function

begin_function
specifier|static
name|apr_interval_time_t
name|waiting_time
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|task
init|=
name|NULL
decl_stmt|;
name|task
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task
operator|!=
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|task
operator|->
name|dispatch
operator|.
name|time
operator|-
name|apr_time_now
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: This function is not thread safe by itself. Caller should hold the lock  */
end_comment

begin_function
specifier|static
name|struct
name|apr_thread_list_elt
modifier|*
name|elt_new
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_thread_t
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|apr_thread_list_elt
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|APR_RING_EMPTY
argument_list|(
name|me
operator|->
name|recycled_thds
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|elt
operator|=
name|apr_pcalloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|elt
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|elt
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|recycled_thds
argument_list|)
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|APR_RING_ELEM_INIT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|elt
operator|->
name|thd
operator|=
name|t
expr_stmt|;
name|elt
operator|->
name|current_owner
operator|=
name|NULL
expr_stmt|;
name|elt
operator|->
name|state
operator|=
name|TH_RUN
expr_stmt|;
return|return
name|elt
return|;
block|}
end_function

begin_comment
comment|/*  * The worker thread function. Take a task from the queue and perform it if  * there is any. Otherwise, put itself into the idle thread list and waiting  * for signal to wake up.  * The thread terminate directly by detach and exit when it is asked to stop  * after finishing a task. Otherwise, the thread should be in idle thread list  * and should be joined.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|APR_THREAD_FUNC
name|thread_pool_func
parameter_list|(
name|apr_thread_t
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|apr_thread_pool_t
modifier|*
name|me
init|=
name|param
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|task
init|=
name|NULL
decl_stmt|;
name|apr_interval_time_t
name|wait
decl_stmt|;
name|struct
name|apr_thread_list_elt
modifier|*
name|elt
decl_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|elt
operator|=
name|elt_new
argument_list|(
name|me
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elt
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_exit
argument_list|(
name|t
argument_list|,
name|APR_ENOMEM
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|me
operator|->
name|terminated
operator|&&
name|elt
operator|->
name|state
operator|!=
name|TH_STOP
condition|)
block|{
comment|/* Test if not new element, it is awakened from idle */
if|if
condition|(
name|APR_RING_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
operator|!=
name|elt
condition|)
block|{
operator|--
name|me
operator|->
name|idle_cnt
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|APR_RING_INSERT_TAIL
argument_list|(
name|me
operator|->
name|busy_thds
argument_list|,
name|elt
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|task
operator|=
name|pop_task
argument_list|(
name|me
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|task
operator|&&
operator|!
name|me
operator|->
name|terminated
condition|)
block|{
operator|++
name|me
operator|->
name|tasks_run
expr_stmt|;
name|elt
operator|->
name|current_owner
operator|=
name|task
operator|->
name|owner
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_data_set
argument_list|(
name|task
argument_list|,
literal|"apr_thread_pool_task"
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|task
operator|->
name|func
argument_list|(
name|t
argument_list|,
name|task
operator|->
name|param
argument_list|)
expr_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
name|me
operator|->
name|recycled_tasks
argument_list|,
name|task
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|elt
operator|->
name|current_owner
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TH_STOP
operator|==
name|elt
operator|->
name|state
condition|)
block|{
break|break;
block|}
name|task
operator|=
name|pop_task
argument_list|(
name|me
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|NULL
operator|==
name|elt
operator|->
name|current_owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TH_STOP
operator|!=
name|elt
operator|->
name|state
condition|)
name|APR_RING_REMOVE
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Test if a busy thread been asked to stop, which is not joinable */
if|if
condition|(
operator|(
name|me
operator|->
name|idle_cnt
operator|>=
name|me
operator|->
name|idle_max
operator|&&
operator|!
operator|(
name|me
operator|->
name|scheduled_task_cnt
operator|&&
literal|0
operator|>=
name|me
operator|->
name|idle_max
operator|)
operator|&&
operator|!
name|me
operator|->
name|idle_wait
operator|)
operator|||
name|me
operator|->
name|terminated
operator|||
name|elt
operator|->
name|state
operator|!=
name|TH_RUN
condition|)
block|{
operator|--
name|me
operator|->
name|thd_cnt
expr_stmt|;
if|if
condition|(
operator|(
name|TH_PROBATION
operator|==
name|elt
operator|->
name|state
operator|)
operator|&&
name|me
operator|->
name|idle_wait
condition|)
operator|++
name|me
operator|->
name|thd_timed_out
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
name|me
operator|->
name|recycled_thds
argument_list|,
name|elt
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_detach
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|apr_thread_exit
argument_list|(
name|t
argument_list|,
name|APR_SUCCESS
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* should not be here, safe net */
block|}
comment|/* busy thread become idle */
operator|++
name|me
operator|->
name|idle_cnt
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
name|me
operator|->
name|idle_thds
argument_list|,
name|elt
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/*           * If there is a scheduled task, always scheduled to perform that task.          * Since there is no guarantee that current idle threads are scheduled          * for next scheduled task.          */
if|if
condition|(
name|me
operator|->
name|scheduled_task_cnt
condition|)
name|wait
operator|=
name|waiting_time
argument_list|(
name|me
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|me
operator|->
name|idle_cnt
operator|>
name|me
operator|->
name|idle_max
condition|)
block|{
name|wait
operator|=
name|me
operator|->
name|idle_wait
expr_stmt|;
name|elt
operator|->
name|state
operator|=
name|TH_PROBATION
expr_stmt|;
block|}
else|else
name|wait
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|wait
operator|>=
literal|0
condition|)
block|{
name|apr_thread_cond_timedwait
argument_list|(
name|me
operator|->
name|cond
argument_list|,
name|me
operator|->
name|lock
argument_list|,
name|wait
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_thread_cond_wait
argument_list|(
name|me
operator|->
name|cond
argument_list|,
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* idle thread been asked to stop, will be joined */
operator|--
name|me
operator|->
name|thd_cnt
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_exit
argument_list|(
name|t
argument_list|,
name|APR_SUCCESS
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* should not be here, safe net */
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|thread_pool_cleanup
parameter_list|(
name|void
modifier|*
name|me
parameter_list|)
block|{
name|apr_thread_pool_t
modifier|*
name|_myself
init|=
name|me
decl_stmt|;
name|_myself
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
name|apr_thread_pool_idle_max_set
argument_list|(
name|_myself
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|_myself
operator|->
name|thd_cnt
condition|)
block|{
name|apr_sleep
argument_list|(
literal|20
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* spin lock with 20 ms */
block|}
name|apr_thread_mutex_destroy
argument_list|(
name|_myself
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_cond_destroy
argument_list|(
name|_myself
operator|->
name|cond
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_create
argument_list|(
argument|apr_thread_pool_t ** me
argument_list|,
argument|apr_size_t init_threads
argument_list|,
argument|apr_size_t max_threads
argument_list|,
argument|apr_pool_t * pool
argument_list|)
end_macro

begin_block
block|{
name|apr_thread_t
modifier|*
name|t
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_thread_pool_t
modifier|*
name|tp
decl_stmt|;
operator|*
name|me
operator|=
name|NULL
expr_stmt|;
name|tp
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_thread_pool_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * This pool will be used by different threads. As we cannot ensure that      * our caller won't use the pool without acquiring the mutex, we must      * create a new sub pool.      */
name|rv
operator|=
name|apr_pool_create
argument_list|(
operator|&
name|tp
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|!=
name|rv
condition|)
return|return
name|rv
return|;
name|rv
operator|=
name|thread_pool_construct
argument_list|(
name|tp
argument_list|,
name|init_threads
argument_list|,
name|max_threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|!=
name|rv
condition|)
return|return
name|rv
return|;
name|apr_pool_cleanup_register
argument_list|(
name|tp
operator|->
name|pool
argument_list|,
name|tp
argument_list|,
name|thread_pool_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
while|while
condition|(
name|init_threads
condition|)
block|{
comment|/* Grab the mutex as apr_thread_create() and thread_pool_func() will           * allocate from (*me)->pool. This is dangerous if there are multiple           * initial threads to create.          */
name|apr_thread_mutex_lock
argument_list|(
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_thread_create
argument_list|(
operator|&
name|t
argument_list|,
name|NULL
argument_list|,
name|thread_pool_func
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|pool
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|tp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|!=
name|rv
condition|)
block|{
break|break;
block|}
name|tp
operator|->
name|thd_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|thd_cnt
operator|>
name|tp
operator|->
name|thd_high
condition|)
block|{
name|tp
operator|->
name|thd_high
operator|=
name|tp
operator|->
name|thd_cnt
expr_stmt|;
block|}
operator|--
name|init_threads
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
block|{
operator|*
name|me
operator|=
name|tp
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_destroy
argument_list|(
argument|apr_thread_pool_t * me
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_pool_cleanup_run
argument_list|(
name|me
operator|->
name|pool
argument_list|,
name|me
argument_list|,
name|thread_pool_cleanup
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * NOTE: This function is not thread safe by itself. Caller should hold the lock  */
end_comment

begin_function
specifier|static
name|apr_thread_pool_task_t
modifier|*
name|task_new
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_thread_start_t
name|func
parameter_list|,
name|void
modifier|*
name|param
parameter_list|,
name|apr_byte_t
name|priority
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|apr_time_t
name|time
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|APR_RING_EMPTY
argument_list|(
name|me
operator|->
name|recycled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|t
operator|=
name|apr_pcalloc
argument_list|(
name|me
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|t
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|t
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|recycled_tasks
argument_list|)
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|APR_RING_ELEM_INIT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|t
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|t
operator|->
name|param
operator|=
name|param
expr_stmt|;
name|t
operator|->
name|owner
operator|=
name|owner
expr_stmt|;
if|if
condition|(
name|time
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|dispatch
operator|.
name|time
operator|=
name|apr_time_now
argument_list|()
operator|+
name|time
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|dispatch
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*  * Test it the task is the only one within the priority segment.   * If it is not, return the first element with same or lower priority.   * Otherwise, add the task into the queue and return NULL.  *  * NOTE: This function is not thread safe by itself. Caller should hold the lock  */
end_comment

begin_function
specifier|static
name|apr_thread_pool_task_t
modifier|*
name|add_if_empty
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_thread_pool_task_t
modifier|*
specifier|const
name|t
parameter_list|)
block|{
name|int
name|seg
decl_stmt|;
name|int
name|next
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|t_next
decl_stmt|;
name|seg
operator|=
name|TASK_PRIORITY_SEG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
condition|)
block|{
name|assert
argument_list|(
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
operator|!=
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
argument_list|)
expr_stmt|;
name|t_next
operator|=
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
expr_stmt|;
while|while
condition|(
name|t_next
operator|->
name|dispatch
operator|.
name|priority
operator|>
name|t
operator|->
name|dispatch
operator|.
name|priority
condition|)
block|{
name|t_next
operator|=
name|APR_RING_NEXT
argument_list|(
name|t_next
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
operator|==
name|t_next
condition|)
block|{
return|return
name|t_next
return|;
block|}
block|}
return|return
name|t_next
return|;
block|}
for|for
control|(
name|next
operator|=
name|seg
operator|-
literal|1
init|;
name|next
operator|>=
literal|0
condition|;
name|next
operator|--
control|)
block|{
if|if
condition|(
name|me
operator|->
name|task_idx
index|[
name|next
index|]
condition|)
block|{
name|APR_RING_INSERT_BEFORE
argument_list|(
name|me
operator|->
name|task_idx
index|[
name|next
index|]
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
literal|0
operator|>
name|next
condition|)
block|{
name|APR_RING_INSERT_TAIL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|t
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|=
name|t
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* *   schedule a task to run in "time" microseconds. Find the spot in the ring where *   the time fits. Adjust the short_time so the thread wakes up when the time is reached. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|schedule_task
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_thread_start_t
name|func
parameter_list|,
name|void
modifier|*
name|param
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|apr_interval_time_t
name|time
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|t
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|t_loc
decl_stmt|;
name|apr_thread_t
modifier|*
name|thd
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|t
operator|=
name|task_new
argument_list|(
name|me
argument_list|,
name|func
argument_list|,
name|param
argument_list|,
literal|0
argument_list|,
name|owner
argument_list|,
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|t
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|t_loc
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|t_loc
condition|)
block|{
comment|/* if the time is less than the entry insert ahead of it */
if|if
condition|(
name|t
operator|->
name|dispatch
operator|.
name|time
operator|<
name|t_loc
operator|->
name|dispatch
operator|.
name|time
condition|)
block|{
operator|++
name|me
operator|->
name|scheduled_task_cnt
expr_stmt|;
name|APR_RING_INSERT_BEFORE
argument_list|(
name|t_loc
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|t_loc
operator|=
name|APR_RING_NEXT
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_loc
operator|==
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
condition|)
block|{
operator|++
name|me
operator|->
name|scheduled_task_cnt
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|,
name|t
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* there should be at least one thread for scheduled tasks */
if|if
condition|(
literal|0
operator|==
name|me
operator|->
name|thd_cnt
condition|)
block|{
name|rv
operator|=
name|apr_thread_create
argument_list|(
operator|&
name|thd
argument_list|,
name|NULL
argument_list|,
name|thread_pool_func
argument_list|,
name|me
argument_list|,
name|me
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|==
name|rv
condition|)
block|{
operator|++
name|me
operator|->
name|thd_cnt
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|thd_cnt
operator|>
name|me
operator|->
name|thd_high
condition|)
name|me
operator|->
name|thd_high
operator|=
name|me
operator|->
name|thd_cnt
expr_stmt|;
block|}
block|}
name|apr_thread_cond_signal
argument_list|(
name|me
operator|->
name|cond
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|add_task
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_thread_start_t
name|func
parameter_list|,
name|void
modifier|*
name|param
parameter_list|,
name|apr_byte_t
name|priority
parameter_list|,
name|int
name|push
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|t
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|t_loc
decl_stmt|;
name|apr_thread_t
modifier|*
name|thd
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|t
operator|=
name|task_new
argument_list|(
name|me
argument_list|,
name|func
argument_list|,
name|param
argument_list|,
name|priority
argument_list|,
name|owner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|t
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|t_loc
operator|=
name|add_if_empty
argument_list|(
name|me
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|t_loc
condition|)
block|{
goto|goto
name|FINAL_EXIT
goto|;
block|}
if|if
condition|(
name|push
condition|)
block|{
while|while
condition|(
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
operator|!=
name|t_loc
operator|&&
name|t_loc
operator|->
name|dispatch
operator|.
name|priority
operator|>=
name|t
operator|->
name|dispatch
operator|.
name|priority
condition|)
block|{
name|t_loc
operator|=
name|APR_RING_NEXT
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|APR_RING_INSERT_BEFORE
argument_list|(
name|t_loc
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|push
condition|)
block|{
if|if
condition|(
name|t_loc
operator|==
name|me
operator|->
name|task_idx
index|[
name|TASK_PRIORITY_SEG
argument_list|(
name|t
argument_list|)
index|]
condition|)
block|{
name|me
operator|->
name|task_idx
index|[
name|TASK_PRIORITY_SEG
argument_list|(
name|t
argument_list|)
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
name|FINAL_EXIT
label|:
name|me
operator|->
name|task_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|task_cnt
operator|>
name|me
operator|->
name|tasks_high
condition|)
name|me
operator|->
name|tasks_high
operator|=
name|me
operator|->
name|task_cnt
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|me
operator|->
name|thd_cnt
operator|||
operator|(
literal|0
operator|==
name|me
operator|->
name|idle_cnt
operator|&&
name|me
operator|->
name|thd_cnt
operator|<
name|me
operator|->
name|thd_max
operator|&&
name|me
operator|->
name|task_cnt
operator|>
name|me
operator|->
name|threshold
operator|)
condition|)
block|{
name|rv
operator|=
name|apr_thread_create
argument_list|(
operator|&
name|thd
argument_list|,
name|NULL
argument_list|,
name|thread_pool_func
argument_list|,
name|me
argument_list|,
name|me
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_SUCCESS
operator|==
name|rv
condition|)
block|{
operator|++
name|me
operator|->
name|thd_cnt
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|thd_cnt
operator|>
name|me
operator|->
name|thd_high
condition|)
name|me
operator|->
name|thd_high
operator|=
name|me
operator|->
name|thd_cnt
expr_stmt|;
block|}
block|}
name|apr_thread_cond_signal
argument_list|(
name|me
operator|->
name|cond
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_push
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|apr_thread_start_t func
argument_list|,
argument|void *param
argument_list|,
argument|apr_byte_t priority
argument_list|,
argument|void *owner
argument_list|)
end_macro

begin_block
block|{
return|return
name|add_task
argument_list|(
name|me
argument_list|,
name|func
argument_list|,
name|param
argument_list|,
name|priority
argument_list|,
literal|1
argument_list|,
name|owner
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_schedule
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|apr_thread_start_t func
argument_list|,
argument|void *param
argument_list|,
argument|apr_interval_time_t time
argument_list|,
argument|void *owner
argument_list|)
end_macro

begin_block
block|{
return|return
name|schedule_task
argument_list|(
name|me
argument_list|,
name|func
argument_list|,
name|param
argument_list|,
name|owner
argument_list|,
name|time
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_top
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|apr_thread_start_t func
argument_list|,
argument|void *param
argument_list|,
argument|apr_byte_t priority
argument_list|,
argument|void *owner
argument_list|)
end_macro

begin_block
block|{
return|return
name|add_task
argument_list|(
name|me
argument_list|,
name|func
argument_list|,
name|param
argument_list|,
name|priority
argument_list|,
literal|0
argument_list|,
name|owner
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|apr_status_t
name|remove_scheduled_tasks
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|t_loc
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|next
decl_stmt|;
name|t_loc
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|)
expr_stmt|;
while|while
condition|(
name|t_loc
operator|!=
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|scheduled_tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|next
operator|=
name|APR_RING_NEXT
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* if this is the owner remove it */
if|if
condition|(
name|t_loc
operator|->
name|owner
operator|==
name|owner
condition|)
block|{
operator|--
name|me
operator|->
name|scheduled_task_cnt
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|t_loc
operator|=
name|next
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|remove_tasks
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|apr_thread_pool_task_t
modifier|*
name|t_loc
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|next
decl_stmt|;
name|int
name|seg
decl_stmt|;
name|t_loc
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|tasks
argument_list|)
expr_stmt|;
while|while
condition|(
name|t_loc
operator|!=
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|next
operator|=
name|APR_RING_NEXT
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_loc
operator|->
name|owner
operator|==
name|owner
condition|)
block|{
operator|--
name|me
operator|->
name|task_cnt
expr_stmt|;
name|seg
operator|=
name|TASK_PRIORITY_SEG
argument_list|(
name|t_loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_loc
operator|==
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
condition|)
block|{
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|=
name|APR_RING_NEXT
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|==
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|tasks
argument_list|,
name|apr_thread_pool_task
argument_list|,
name|link
argument_list|)
operator|||
name|TASK_PRIORITY_SEG
argument_list|(
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
argument_list|)
operator|!=
name|seg
condition|)
block|{
name|me
operator|->
name|task_idx
index|[
name|seg
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|APR_RING_REMOVE
argument_list|(
name|t_loc
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|t_loc
operator|=
name|next
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wait_on_busy_threads
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|apr_os_thread_t
modifier|*
name|os_thread
decl_stmt|;
endif|#
directive|endif
name|struct
name|apr_thread_list_elt
modifier|*
name|elt
decl_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|elt
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|busy_thds
argument_list|)
expr_stmt|;
while|while
condition|(
name|elt
operator|!=
name|APR_RING_SENTINEL
argument_list|(
name|me
operator|->
name|busy_thds
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|current_owner
operator|!=
name|owner
condition|)
block|{
name|elt
operator|=
name|APR_RING_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
comment|/* make sure the thread is not the one calling tasks_cancel */
name|apr_os_thread_get
argument_list|(
operator|&
name|os_thread
argument_list|,
name|elt
operator|->
name|thd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* hack for apr win32 bug */
name|assert
argument_list|(
operator|!
name|apr_os_thread_equal
argument_list|(
name|apr_os_thread_current
argument_list|()
argument_list|,
name|os_thread
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|assert
argument_list|(
operator|!
name|apr_os_thread_equal
argument_list|(
name|apr_os_thread_current
argument_list|()
argument_list|,
operator|*
name|os_thread
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
name|elt
operator|->
name|current_owner
operator|==
name|owner
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_sleep
argument_list|(
literal|200
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|APR_RING_FIRST
argument_list|(
name|me
operator|->
name|busy_thds
argument_list|)
expr_stmt|;
block|}
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_tasks_cancel
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|void *owner
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|task_cnt
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|remove_tasks
argument_list|(
name|me
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|scheduled_task_cnt
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|remove_scheduled_tasks
argument_list|(
name|me
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|wait_on_busy_threads
argument_list|(
name|me
argument_list|,
name|owner
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_tasks_count
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|task_cnt
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_scheduled_tasks_count
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|scheduled_task_cnt
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_threads_count
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|thd_cnt
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_busy_count
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|thd_cnt
operator|-
name|me
operator|->
name|idle_cnt
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_idle_count
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|idle_cnt
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_tasks_run_count
argument_list|(
argument|apr_thread_pool_t * me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|tasks_run
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_tasks_high_count
argument_list|(
argument|apr_thread_pool_t * me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|tasks_high
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_threads_high_count
argument_list|(
argument|apr_thread_pool_t * me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|thd_high
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_threads_idle_timeout_count
argument_list|(
argument|apr_thread_pool_t * me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|thd_timed_out
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_idle_max_get
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|idle_max
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_interval_time_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_idle_wait_get
argument_list|(
argument|apr_thread_pool_t * me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|idle_wait
return|;
block|}
end_block

begin_comment
comment|/*  * This function stop extra idle threads to the cnt.  * @return the number of threads stopped  * NOTE: There could be busy threads become idle during this function  */
end_comment

begin_function
specifier|static
name|struct
name|apr_thread_list_elt
modifier|*
name|trim_threads
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_size_t
modifier|*
name|cnt
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|apr_thread_list
modifier|*
name|thds
decl_stmt|;
name|apr_size_t
name|n
decl_stmt|,
name|n_dbg
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|apr_thread_list_elt
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|elt
decl_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle
condition|)
block|{
name|thds
operator|=
name|me
operator|->
name|idle_thds
expr_stmt|;
name|n
operator|=
name|me
operator|->
name|idle_cnt
expr_stmt|;
block|}
else|else
block|{
name|thds
operator|=
name|me
operator|->
name|busy_thds
expr_stmt|;
name|n
operator|=
name|me
operator|->
name|thd_cnt
operator|-
name|me
operator|->
name|idle_cnt
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<=
operator|*
name|cnt
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|cnt
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|-=
operator|*
name|cnt
expr_stmt|;
name|head
operator|=
name|APR_RING_FIRST
argument_list|(
name|thds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|head
operator|=
name|APR_RING_NEXT
argument_list|(
name|head
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|tail
operator|=
name|APR_RING_LAST
argument_list|(
name|thds
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle
condition|)
block|{
name|APR_RING_UNSPLICE
argument_list|(
name|head
argument_list|,
name|tail
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|me
operator|->
name|idle_cnt
operator|=
operator|*
name|cnt
expr_stmt|;
block|}
name|n_dbg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|head
init|;
name|elt
operator|!=
name|tail
condition|;
name|elt
operator|=
name|APR_RING_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
control|)
block|{
name|elt
operator|->
name|state
operator|=
name|TH_STOP
expr_stmt|;
name|n_dbg
operator|++
expr_stmt|;
block|}
name|elt
operator|->
name|state
operator|=
name|TH_STOP
expr_stmt|;
name|n_dbg
operator|++
expr_stmt|;
name|assert
argument_list|(
name|n
operator|==
name|n_dbg
argument_list|)
expr_stmt|;
operator|*
name|cnt
operator|=
name|n
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|APR_RING_PREV
argument_list|(
name|head
argument_list|,
name|link
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|APR_RING_NEXT
argument_list|(
name|tail
argument_list|,
name|link
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_function
specifier|static
name|apr_size_t
name|trim_idle_threads
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_size_t
name|cnt
parameter_list|)
block|{
name|apr_size_t
name|n_dbg
decl_stmt|;
name|struct
name|apr_thread_list_elt
modifier|*
name|elt
decl_stmt|,
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|elt
operator|=
name|trim_threads
argument_list|(
name|me
argument_list|,
operator|&
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|apr_thread_cond_broadcast
argument_list|(
name|me
operator|->
name|cond
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|n_dbg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|head
operator|=
name|elt
operator|)
condition|)
block|{
while|while
condition|(
name|elt
condition|)
block|{
name|tail
operator|=
name|elt
expr_stmt|;
name|apr_thread_join
argument_list|(
operator|&
name|rv
argument_list|,
name|elt
operator|->
name|thd
argument_list|)
expr_stmt|;
name|elt
operator|=
name|APR_RING_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|++
name|n_dbg
expr_stmt|;
block|}
name|apr_thread_mutex_lock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
name|APR_RING_SPLICE_TAIL
argument_list|(
name|me
operator|->
name|recycled_thds
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|apr_thread_list_elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|apr_thread_mutex_unlock
argument_list|(
name|me
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|cnt
operator|==
name|n_dbg
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/* don't join on busy threads for performance reasons, who knows how long will  * the task takes to perform  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|trim_busy_threads
parameter_list|(
name|apr_thread_pool_t
modifier|*
name|me
parameter_list|,
name|apr_size_t
name|cnt
parameter_list|)
block|{
name|trim_threads
argument_list|(
name|me
argument_list|,
operator|&
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_idle_max_set
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|apr_size_t cnt
argument_list|)
end_macro

begin_block
block|{
name|me
operator|->
name|idle_max
operator|=
name|cnt
expr_stmt|;
name|cnt
operator|=
name|trim_idle_threads
argument_list|(
name|me
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_interval_time_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_idle_wait_set
argument_list|(
argument|apr_thread_pool_t * me
argument_list|,
argument|apr_interval_time_t timeout
argument_list|)
end_macro

begin_block
block|{
name|apr_interval_time_t
name|oldtime
decl_stmt|;
name|oldtime
operator|=
name|me
operator|->
name|idle_wait
expr_stmt|;
name|me
operator|->
name|idle_wait
operator|=
name|timeout
expr_stmt|;
return|return
name|oldtime
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_thread_max_get
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|thd_max
return|;
block|}
end_block

begin_comment
comment|/*  * This function stop extra working threads to the new limit.  * NOTE: There could be busy threads become idle during this function  */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_thread_max_set
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|apr_size_t cnt
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|me
operator|->
name|thd_max
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|cnt
operator|||
name|me
operator|->
name|thd_cnt
operator|<=
name|cnt
condition|)
block|{
return|return
literal|0
return|;
block|}
name|n
operator|=
name|me
operator|->
name|thd_cnt
operator|-
name|cnt
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|me
operator|->
name|idle_cnt
condition|)
block|{
name|trim_busy_threads
argument_list|(
name|me
argument_list|,
name|n
operator|-
name|me
operator|->
name|idle_cnt
argument_list|)
expr_stmt|;
name|trim_idle_threads
argument_list|(
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trim_idle_threads
argument_list|(
name|me
argument_list|,
name|me
operator|->
name|idle_cnt
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_threshold_get
argument_list|(
argument|apr_thread_pool_t *me
argument_list|)
end_macro

begin_block
block|{
return|return
name|me
operator|->
name|threshold
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_threshold_set
argument_list|(
argument|apr_thread_pool_t *me
argument_list|,
argument|apr_size_t val
argument_list|)
end_macro

begin_block
block|{
name|apr_size_t
name|ov
decl_stmt|;
name|ov
operator|=
name|me
operator|->
name|threshold
expr_stmt|;
name|me
operator|->
name|threshold
operator|=
name|val
expr_stmt|;
return|return
name|ov
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_thread_pool_task_owner_get
argument_list|(
argument|apr_thread_t *thd
argument_list|,
argument|void **owner
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|apr_thread_pool_task_t
modifier|*
name|task
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|rv
operator|=
name|apr_thread_data_get
argument_list|(
operator|&
name|data
argument_list|,
literal|"apr_thread_pool_task"
argument_list|,
name|thd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|task
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|task
condition|)
block|{
operator|*
name|owner
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_BADARG
return|;
block|}
operator|*
name|owner
operator|=
name|task
operator|->
name|owner
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_THREADS */
end_comment

begin_comment
comment|/* vim: set ts=4 sw=4 et cin tw=80: */
end_comment

end_unit

