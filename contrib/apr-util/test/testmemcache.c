begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"testutil.h"
end_include

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apu.h"
end_include

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_include
include|#
directive|include
file|"apr_memcache.h"
end_include

begin_include
include|#
directive|include
file|"apr_network_io.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for exit() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HOST
value|"localhost"
end_define

begin_define
define|#
directive|define
name|PORT
value|11211
end_define

begin_comment
comment|/* the total number of items to use for set/get testing */
end_comment

begin_define
define|#
directive|define
name|TDATA_SIZE
value|3000
end_define

begin_comment
comment|/* some smaller subset of TDATA_SIZE used for multiget testing */
end_comment

begin_define
define|#
directive|define
name|TDATA_SET
value|100
end_define

begin_comment
comment|/* our custom hash function just returns this all the time */
end_comment

begin_define
define|#
directive|define
name|HASH_FUNC_RESULT
value|510
end_define

begin_comment
comment|/* all keys will be prefixed with this */
end_comment

begin_decl_stmt
specifier|const
name|char
name|prefix
index|[]
init|=
literal|"testmemcache"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text for values we store */
end_comment

begin_decl_stmt
specifier|const
name|char
name|txt
index|[]
init|=
literal|"Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Duis at"
literal|"lacus in ligula hendrerit consectetuer. Vestibulum tristique odio"
literal|"iaculis leo. In massa arcu, ultricies a, laoreet nec, hendrerit non,"
literal|"neque. Nulla sagittis sapien ac risus. Morbi ligula dolor, vestibulum"
literal|"nec, viverra id, placerat dapibus, arcu. Curabitur egestas feugiat"
literal|"tellus. Donec dignissim. Nunc ante. Curabitur id lorem. In mollis"
literal|"tortor sit amet eros auctor dapibus. Proin nulla sem, tristique in,"
literal|"convallis id, iaculis feugiat cras amet."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * this datatype is for our custom server determination function. this might  * be useful if you don't want to rely on simply hashing keys to determine  * where a key belongs, but instead want to write something fancy, or use some  * other kind of configuration data, i.e. a hash plus some data about a   * namespace, or whatever. see my_server_func, and test_memcache_user_funcs  * for the examples.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|someval
decl_stmt|;
name|apr_uint32_t
name|which_server
decl_stmt|;
block|}
name|my_hash_server_baton
typedef|;
end_typedef

begin_comment
comment|/* this could do something fancy and return some hash result.   * for simplicity, just return the same value, so we can test it later on.  * if you wanted to use some external hashing library or functions for  * consistent hashing, for example, this would be a good place to do it.  */
end_comment

begin_function
specifier|static
name|apr_uint32_t
name|my_hash_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|)
block|{
return|return
name|HASH_FUNC_RESULT
return|;
block|}
end_function

begin_comment
comment|/*  * a fancy function to determine which server to use given some kind of data  * and a hash value. this example actually ignores the hash value itself  * and pulls some number from the *baton, which is a struct that has some   * kind of meaningful stuff in it.  */
end_comment

begin_function
specifier|static
name|apr_memcache_server_t
modifier|*
name|my_server_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_memcache_t
modifier|*
name|mc
parameter_list|,
specifier|const
name|apr_uint32_t
name|hash
parameter_list|)
block|{
name|apr_memcache_server_t
modifier|*
name|ms
init|=
name|NULL
decl_stmt|;
name|my_hash_server_baton
modifier|*
name|mhsb
init|=
operator|(
name|my_hash_server_baton
operator|*
operator|)
name|baton
decl_stmt|;
if|if
condition|(
name|mc
operator|->
name|ntotal
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mc
operator|->
name|ntotal
operator|<
name|mhsb
operator|->
name|which_server
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ms
operator|=
name|mc
operator|->
name|live_servers
index|[
name|mhsb
operator|->
name|which_server
operator|-
literal|1
index|]
expr_stmt|;
return|return
name|ms
return|;
block|}
end_function

begin_decl_stmt
name|apr_uint16_t
name|firsttime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|randval
parameter_list|(
name|apr_uint32_t
name|high
parameter_list|)
block|{
name|apr_uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|double
name|d
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|firsttime
operator|==
literal|0
condition|)
block|{
name|srand
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|firsttime
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|=
operator|(
name|double
operator|)
name|rand
argument_list|()
operator|/
operator|(
operator|(
name|double
operator|)
name|RAND_MAX
operator|+
literal|1
operator|)
expr_stmt|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|*
operator|(
name|high
operator|-
literal|0
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|i
operator|>
literal|0
condition|?
name|i
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * general test to make sure we can create the memcache struct and add  * some servers, but not more than we tell it we can add  */
end_comment

begin_function
specifier|static
name|void
name|test_memcache_create
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|apr_uint32_t
name|max_servers
init|=
literal|10
decl_stmt|;
name|apr_uint32_t
name|i
decl_stmt|;
name|apr_uint32_t
name|hash
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
name|max_servers
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|max_servers
condition|;
name|i
operator|++
control|)
block|{
name|apr_port_t
name|port
decl_stmt|;
name|port
operator|=
name|PORT
operator|+
name|i
expr_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|s
operator|=
name|apr_memcache_find_server
argument_list|(
name|memcache
argument_list|,
name|HOST
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ABTS_PTR_EQUAL
argument_list|(
name|tc
argument_list|,
name|server
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_disable_server
argument_list|(
name|memcache
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server disable failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_enable_server
argument_list|(
name|memcache
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server enable failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|hash
operator|=
name|apr_memcache_hash
argument_list|(
name|memcache
argument_list|,
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"hash failed"
argument_list|,
name|hash
operator|>
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|apr_memcache_find_server_hash
argument_list|(
name|memcache
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|ABTS_PTR_NOTNULL
argument_list|(
name|tc
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add should have failed"
argument_list|,
name|rv
operator|!=
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* install our own custom hashing and server selection routines. */
end_comment

begin_function
specifier|static
name|int
name|create_test_hash
parameter_list|(
name|apr_pool_t
modifier|*
name|p
parameter_list|,
name|apr_hash_t
modifier|*
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TDATA_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|k
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|k
operator|=
name|apr_pstrcat
argument_list|(
name|p
argument_list|,
name|prefix
argument_list|,
name|apr_itoa
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|=
name|apr_pstrndup
argument_list|(
name|p
argument_list|,
name|txt
argument_list|,
name|randval
argument_list|(
operator|(
name|apr_uint32_t
operator|)
name|strlen
argument_list|(
name|txt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_memcache_user_funcs
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|found
decl_stmt|;
name|apr_uint32_t
name|max_servers
init|=
literal|10
decl_stmt|;
name|apr_uint32_t
name|hres
decl_stmt|;
name|apr_uint32_t
name|i
decl_stmt|;
name|my_hash_server_baton
modifier|*
name|baton
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|my_hash_server_baton
argument_list|)
argument_list|)
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
name|max_servers
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
comment|/* as noted above, install our custom hash function, and call     * apr_memcache_hash. the return value should be our predefined number,    * and our function just ignores the other args, for simplicity.    */
name|memcache
operator|->
name|hash_func
operator|=
name|my_hash_func
expr_stmt|;
name|hres
operator|=
name|apr_memcache_hash
argument_list|(
name|memcache
argument_list|,
literal|"whatever"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"whatever"
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ABTS_INT_EQUAL
argument_list|(
name|tc
argument_list|,
name|HASH_FUNC_RESULT
argument_list|,
name|hres
argument_list|)
expr_stmt|;
comment|/* add some servers */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|apr_memcache_server_t
modifier|*
name|ms
decl_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|ms
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
comment|/*     * set 'which_server' in our server_baton to find the third server     * which should have the same port.    */
name|baton
operator|->
name|which_server
operator|=
literal|3
expr_stmt|;
name|memcache
operator|->
name|server_func
operator|=
name|my_server_func
expr_stmt|;
name|memcache
operator|->
name|server_baton
operator|=
name|baton
expr_stmt|;
name|found
operator|=
name|apr_memcache_find_server_hash
argument_list|(
name|memcache
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"wrong server found"
argument_list|,
name|found
operator|->
name|port
operator|==
name|baton
operator|->
name|which_server
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* test non data related commands like stats and version */
end_comment

begin_function
specifier|static
name|void
name|test_memcache_meta
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|;
name|apr_memcache_stats_t
modifier|*
name|stats
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_version
argument_list|(
name|server
argument_list|,
name|pool
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|ABTS_PTR_NOTNULL
argument_list|(
name|tc
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_stats
argument_list|(
name|server
argument_list|,
name|p
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|ABTS_PTR_NOTNULL
argument_list|(
name|tc
argument_list|,
name|stats
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
name|stats
operator|->
name|version
argument_list|,
name|result
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/*       * no way to know exactly what will be in most of these, so      * just make sure there is something.      */
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"pid"
argument_list|,
name|stats
operator|->
name|pid
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"time"
argument_list|,
name|stats
operator|->
name|time
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* ABTS_ASSERT(tc, "pointer_size", stats->pointer_size>= 0); */
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"rusage_user"
argument_list|,
name|stats
operator|->
name|rusage_user
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"rusage_system"
argument_list|,
name|stats
operator|->
name|rusage_system
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"curr_items"
argument_list|,
name|stats
operator|->
name|curr_items
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"total_items"
argument_list|,
name|stats
operator|->
name|total_items
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bytes"
argument_list|,
name|stats
operator|->
name|bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"curr_connections"
argument_list|,
name|stats
operator|->
name|curr_connections
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"total_connections"
argument_list|,
name|stats
operator|->
name|total_connections
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"connection_structures"
argument_list|,
name|stats
operator|->
name|connection_structures
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"cmd_get"
argument_list|,
name|stats
operator|->
name|cmd_get
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"cmd_set"
argument_list|,
name|stats
operator|->
name|cmd_set
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get_hits"
argument_list|,
name|stats
operator|->
name|get_hits
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get_misses"
argument_list|,
name|stats
operator|->
name|get_misses
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* ABTS_ASSERT(tc, "evictions", stats->evictions>= 0); */
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bytes_read"
argument_list|,
name|stats
operator|->
name|bytes_read
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bytes_written"
argument_list|,
name|stats
operator|->
name|bytes_written
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"limit_maxbytes"
argument_list|,
name|stats
operator|->
name|limit_maxbytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* ABTS_ASSERT(tc, "threads", stats->threads>= 0); */
block|}
end_function

begin_comment
comment|/* test add and replace calls */
end_comment

begin_function
specifier|static
name|void
name|test_memcache_addreplace
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|;
name|apr_hash_t
modifier|*
name|tdata
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|apr_hash_make
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|create_test_hash
argument_list|(
name|pool
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|p
argument_list|,
name|tdata
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|k
argument_list|,
name|NULL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|key
operator|=
name|k
expr_stmt|;
comment|/* doesn't exist yet, fail */
name|rv
operator|=
name|apr_memcache_replace
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|strlen
argument_list|(
name|v
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"replace should have failed"
argument_list|,
name|rv
operator|!=
name|APR_SUCCESS
argument_list|)
expr_stmt|;
comment|/* doesn't exist yet, succeed */
name|rv
operator|=
name|apr_memcache_add
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|strlen
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
comment|/* exists now, succeed */
name|rv
operator|=
name|apr_memcache_replace
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
literal|"new"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"new"
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"replace failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
comment|/* make sure its different */
name|rv
operator|=
name|apr_memcache_getp
argument_list|(
name|memcache
argument_list|,
name|pool
argument_list|,
name|key
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
name|result
argument_list|,
literal|"new"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* exists now, fail */
name|rv
operator|=
name|apr_memcache_add
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|strlen
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"add should have failed"
argument_list|,
name|rv
operator|!=
name|APR_SUCCESS
argument_list|)
expr_stmt|;
comment|/* clean up */
name|rv
operator|=
name|apr_memcache_delete
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"delete failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* basic tests of the increment and decrement commands */
end_comment

begin_function
specifier|static
name|void
name|test_memcache_incrdecr
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|;
name|apr_uint32_t
name|new
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_uint32_t
name|i
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_set
argument_list|(
name|memcache
argument_list|,
name|prefix
argument_list|,
literal|"271"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"271"
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"set failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|TDATA_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|apr_uint32_t
name|expect
decl_stmt|;
name|rv
operator|=
name|apr_memcache_getp
argument_list|(
name|memcache
argument_list|,
name|pool
argument_list|,
name|prefix
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|expect
operator|=
name|i
operator|+
name|atoi
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_incr
argument_list|(
name|memcache
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"incr failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|ABTS_INT_EQUAL
argument_list|(
name|tc
argument_list|,
name|expect
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_decr
argument_list|(
name|memcache
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"decr failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|ABTS_INT_EQUAL
argument_list|(
name|tc
argument_list|,
name|atoi
argument_list|(
name|result
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|apr_memcache_getp
argument_list|(
name|memcache
argument_list|,
name|pool
argument_list|,
name|prefix
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|ABTS_INT_EQUAL
argument_list|(
name|tc
argument_list|,
literal|271
argument_list|,
name|atoi
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_delete
argument_list|(
name|memcache
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"delete failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* test the multiget functionality */
end_comment

begin_function
specifier|static
name|void
name|test_memcache_multiget
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|;
name|apr_hash_t
modifier|*
name|tdata
decl_stmt|,
modifier|*
name|values
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_uint32_t
name|i
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|values
operator|=
name|apr_hash_make
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|apr_hash_make
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|create_test_hash
argument_list|(
name|pool
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|p
argument_list|,
name|tdata
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|k
argument_list|,
name|NULL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|key
operator|=
name|k
expr_stmt|;
name|rv
operator|=
name|apr_memcache_set
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|strlen
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"set failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|apr_pool_create
argument_list|(
operator|&
name|tmppool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TDATA_SET
condition|;
name|i
operator|++
control|)
name|apr_memcache_add_multget_key
argument_list|(
name|pool
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
name|apr_itoa
argument_list|(
name|pool
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_multgetp
argument_list|(
name|memcache
argument_list|,
name|tmppool
argument_list|,
name|pool
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"multgetp failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"multgetp returned too few results"
argument_list|,
name|apr_hash_count
argument_list|(
name|values
argument_list|)
operator|==
name|TDATA_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|p
argument_list|,
name|tdata
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|k
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|key
operator|=
name|k
expr_stmt|;
name|rv
operator|=
name|apr_memcache_delete
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"delete failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* test setting and getting */
end_comment

begin_function
specifier|static
name|void
name|test_memcache_setget
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|;
name|apr_hash_t
modifier|*
name|tdata
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|rv
operator|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|memcache
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"memcache create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_server_create
argument_list|(
name|pool
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server create failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_add_server
argument_list|(
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"server add failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|create_test_hash
argument_list|(
name|pool
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|p
argument_list|,
name|tdata
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|k
argument_list|,
name|NULL
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|key
operator|=
name|k
expr_stmt|;
name|rv
operator|=
name|apr_memcache_set
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|strlen
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"set failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_memcache_getp
argument_list|(
name|memcache
argument_list|,
name|pool
argument_list|,
name|key
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|apr_memcache_getp
argument_list|(
name|memcache
argument_list|,
name|pool
argument_list|,
literal|"nothere3423"
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"get should have failed"
argument_list|,
name|rv
operator|!=
name|APR_SUCCESS
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|p
argument_list|,
name|tdata
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|k
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|key
operator|=
name|k
expr_stmt|;
name|rv
operator|=
name|apr_memcache_delete
argument_list|(
name|memcache
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"delete failed"
argument_list|,
name|rv
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* use apr_socket stuff to see if there is in fact a memcached server   * running on PORT.   */
end_comment

begin_function
specifier|static
name|apr_status_t
name|check_mc
parameter_list|(
name|void
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|p
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|struct
name|iovec
name|vec
index|[
literal|2
index|]
decl_stmt|;
name|apr_size_t
name|written
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|rv
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|APR_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|sa
argument_list|,
name|HOST
argument_list|,
name|APR_INET
argument_list|,
name|PORT
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_socket_timeout_set
argument_list|(
name|sock
argument_list|,
literal|1
operator|*
name|APR_USEC_PER_SEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_socket_connect
argument_list|(
name|sock
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_socket_timeout_set
argument_list|(
name|sock
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
literal|"version"
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
literal|"version"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
literal|"\r\n"
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
literal|"\r\n"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rv
operator|=
name|apr_socket_sendv
argument_list|(
name|sock
argument_list|,
name|vec
argument_list|,
literal|2
argument_list|,
operator|&
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_socket_recv
argument_list|(
name|sock
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"VERSION"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"VERSION"
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|APR_EGENERAL
expr_stmt|;
block|}
name|apr_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|abts_suite
modifier|*
name|testmemcache
parameter_list|(
name|abts_suite
modifier|*
name|suite
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|suite
operator|=
name|ADD_SUITE
argument_list|(
name|suite
argument_list|)
expr_stmt|;
comment|/* check for a running memcached on the typical port before       * trying to run the tests. succeed if we don't find one.      */
name|rv
operator|=
name|check_mc
argument_list|()
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
block|{
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_user_funcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_meta
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_setget
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_multiget
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_addreplace
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_memcache_incrdecr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abts_log_message
argument_list|(
literal|"Error %d occurred attempting to reach memcached "
literal|"on %s:%d.  Skipping apr_memcache tests..."
argument_list|,
name|rv
argument_list|,
name|HOST
argument_list|,
name|PORT
argument_list|)
expr_stmt|;
block|}
return|return
name|suite
return|;
block|}
end_function

end_unit

