begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"abts.h"
end_include

begin_include
include|#
directive|include
file|"testutil.h"
end_include

begin_include
include|#
directive|include
file|"apr_buckets.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_function
specifier|static
name|void
name|test_create
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
decl_stmt|;
name|ba
operator|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bb
operator|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"new brigade not NULL"
argument_list|,
name|bb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"new brigade is empty"
argument_list|,
name|APR_BRIGADE_EMPTY
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_simple
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
decl_stmt|;
name|apr_bucket
modifier|*
name|fb
decl_stmt|,
modifier|*
name|tb
decl_stmt|;
name|ba
operator|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bb
operator|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|fb
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"first bucket of empty brigade is sentinel"
argument_list|,
name|fb
operator|==
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|=
name|apr_bucket_flush_create
argument_list|(
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_HEAD
argument_list|(
name|bb
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"first bucket of brigade is flush"
argument_list|,
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
operator|==
name|fb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bucket after flush is sentinel"
argument_list|,
name|APR_BUCKET_NEXT
argument_list|(
name|fb
argument_list|)
operator|==
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|=
name|apr_bucket_transient_create
argument_list|(
literal|"aaa"
argument_list|,
literal|3
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BUCKET_INSERT_BEFORE
argument_list|(
name|fb
argument_list|,
name|tb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bucket before flush now transient"
argument_list|,
name|APR_BUCKET_PREV
argument_list|(
name|fb
argument_list|)
operator|==
name|tb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bucket after transient is flush"
argument_list|,
name|APR_BUCKET_NEXT
argument_list|(
name|tb
argument_list|)
operator|==
name|fb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bucket before transient is sentinel"
argument_list|,
name|APR_BUCKET_PREV
argument_list|(
name|tb
argument_list|)
operator|==
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|apr_brigade_cleanup
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"cleaned up brigade was empty"
argument_list|,
name|APR_BRIGADE_EMPTY
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_bucket_brigade
modifier|*
name|make_simple_brigade
parameter_list|(
name|apr_bucket_alloc_t
modifier|*
name|ba
parameter_list|,
specifier|const
name|char
modifier|*
name|first
parameter_list|,
specifier|const
name|char
modifier|*
name|second
parameter_list|)
block|{
name|apr_bucket_brigade
modifier|*
name|bb
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|apr_bucket_transient_create
argument_list|(
name|first
argument_list|,
name|strlen
argument_list|(
name|first
argument_list|)
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|apr_bucket_transient_create
argument_list|(
name|second
argument_list|,
name|strlen
argument_list|(
name|second
argument_list|)
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* tests that 'bb' flattens to string 'expect'. */
end_comment

begin_function
specifier|static
name|void
name|flatten_match
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|ctx
parameter_list|,
name|apr_bucket_brigade
modifier|*
name|bb
parameter_list|,
specifier|const
name|char
modifier|*
name|expect
parameter_list|)
block|{
name|apr_size_t
name|elen
init|=
name|strlen
argument_list|(
name|expect
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|elen
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
name|elen
decl_stmt|;
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s: flatten brigade"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
name|msg
argument_list|,
name|apr_brigade_flatten
argument_list|(
name|bb
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s: length match (%ld not %ld)"
argument_list|,
name|ctx
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|,
operator|(
name|long
operator|)
name|elen
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
name|msg
argument_list|,
name|len
operator|==
name|elen
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s: result match"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
name|expect
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_flatten
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
decl_stmt|;
name|bb
operator|=
name|make_simple_brigade
argument_list|(
name|ba
argument_list|,
literal|"hello, "
argument_list|,
literal|"world"
argument_list|)
expr_stmt|;
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"flatten brigade"
argument_list|,
name|bb
argument_list|,
literal|"hello, world"
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_buckets
parameter_list|(
name|apr_bucket_brigade
modifier|*
name|bb
parameter_list|)
block|{
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
condition|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
control|)
block|{
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_split
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
decl_stmt|,
modifier|*
name|bb2
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|bb
operator|=
name|make_simple_brigade
argument_list|(
name|ba
argument_list|,
literal|"hello, "
argument_list|,
literal|"world"
argument_list|)
expr_stmt|;
comment|/* split at the "world" bucket */
name|e
operator|=
name|APR_BRIGADE_LAST
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb2
operator|=
name|apr_brigade_split
argument_list|(
name|bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"split brigade contains one bucket"
argument_list|,
name|count_buckets
argument_list|(
name|bb2
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"original brigade contains one bucket"
argument_list|,
name|count_buckets
argument_list|(
name|bb
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"match original brigade"
argument_list|,
name|bb
argument_list|,
literal|"hello, "
argument_list|)
expr_stmt|;
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"match split brigade"
argument_list|,
name|bb2
argument_list|,
literal|"world"
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|COUNT
value|3000
end_define

begin_define
define|#
directive|define
name|THESTR
value|"hello"
end_define

begin_function
specifier|static
name|void
name|test_bwrite
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_off_t
name|length
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNT
condition|;
name|n
operator|++
control|)
block|{
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"brigade_write"
argument_list|,
name|apr_brigade_write
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|THESTR
argument_list|,
sizeof|sizeof
name|THESTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"determine brigade length"
argument_list|,
name|apr_brigade_length
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"brigade has correct length"
argument_list|,
name|length
operator|==
operator|(
name|COUNT
operator|*
sizeof|sizeof
name|THESTR
operator|)
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_splitline
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bin
decl_stmt|,
modifier|*
name|bout
decl_stmt|;
name|bin
operator|=
name|make_simple_brigade
argument_list|(
name|ba
argument_list|,
literal|"blah blah blah-"
argument_list|,
literal|"end of line.\nfoo foo foo"
argument_list|)
expr_stmt|;
name|bout
operator|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"split line"
argument_list|,
name|apr_brigade_split_line
argument_list|(
name|bout
argument_list|,
name|bin
argument_list|,
name|APR_BLOCK_READ
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"split line"
argument_list|,
name|bout
argument_list|,
literal|"blah blah blah-end of line.\n"
argument_list|)
expr_stmt|;
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"remainder"
argument_list|,
name|bin
argument_list|,
literal|"foo foo foo"
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test that bucket E has content EDATA of length ELEN. */
end_comment

begin_function
specifier|static
name|void
name|test_bucket_content
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|apr_bucket
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|edata
parameter_list|,
name|apr_size_t
name|elen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|adata
decl_stmt|;
name|apr_size_t
name|alen
decl_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"read from bucket"
argument_list|,
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|adata
argument_list|,
operator|&
name|alen
argument_list|,
name|APR_BLOCK_READ
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"read expected length"
argument_list|,
name|alen
operator|==
name|elen
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
name|edata
argument_list|,
name|adata
argument_list|,
name|elen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_splits
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|str
init|=
literal|"alphabeta"
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bb
operator|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|apr_bucket_immortal_create
argument_list|(
name|str
argument_list|,
literal|9
argument_list|,
name|ba
argument_list|)
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|apr_bucket_transient_create
argument_list|(
name|str
argument_list|,
literal|9
argument_list|,
name|ba
argument_list|)
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|apr_bucket_heap_create
argument_list|(
name|strdup
argument_list|(
name|str
argument_list|)
argument_list|,
literal|9
argument_list|,
name|free
argument_list|,
name|ba
argument_list|)
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|apr_bucket_pool_create
argument_list|(
name|apr_pstrdup
argument_list|(
name|p
argument_list|,
name|str
argument_list|)
argument_list|,
literal|9
argument_list|,
name|p
argument_list|,
name|ba
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"four buckets inserted"
argument_list|,
name|count_buckets
argument_list|(
name|bb
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
comment|/* now split each of the buckets after byte 5 */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"reached end of brigade"
argument_list|,
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"split bucket OK"
argument_list|,
name|apr_bucket_split
argument_list|(
name|e
argument_list|,
literal|5
argument_list|)
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"split OK"
argument_list|,
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"four buckets split into eight"
argument_list|,
name|count_buckets
argument_list|(
name|bb
argument_list|)
operator|==
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"read alpha from bucket"
argument_list|,
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"read 5 bytes"
argument_list|,
name|len
operator|==
literal|5
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
literal|"alpha"
argument_list|,
name|data
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"read beta from bucket"
argument_list|,
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"read 4 bytes"
argument_list|,
name|len
operator|==
literal|4
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
literal|"beta"
argument_list|,
name|data
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* now delete the "alpha" buckets */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|apr_bucket
modifier|*
name|f
decl_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"reached end of brigade"
argument_list|,
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|apr_bucket_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"eight buckets reduced to four"
argument_list|,
name|count_buckets
argument_list|(
name|bb
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"flatten beta brigade"
argument_list|,
name|bb
argument_list|,
literal|"beta"
literal|"beta"
literal|"beta"
literal|"beta"
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TIF_FNAME
value|"testfile.txt"
end_define

begin_function
specifier|static
name|void
name|test_insertfile
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
decl_stmt|;
specifier|const
name|apr_off_t
name|bignum
init|=
operator|(
name|APR_INT64_C
argument_list|(
literal|2
argument_list|)
operator|<<
literal|32
operator|)
operator|+
literal|424242
decl_stmt|;
name|apr_off_t
name|count
decl_stmt|;
name|apr_file_t
modifier|*
name|f
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"open test file"
argument_list|,
name|apr_file_open
argument_list|(
operator|&
name|f
argument_list|,
name|TIF_FNAME
argument_list|,
name|APR_FOPEN_WRITE
operator||
name|APR_FOPEN_TRUNCATE
operator||
name|APR_FOPEN_CREATE
operator||
name|APR_FOPEN_SPARSE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|p
argument_list|)
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_file_trunc
argument_list|(
name|f
argument_list|,
name|bignum
argument_list|)
condition|)
block|{
name|apr_file_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|apr_file_remove
argument_list|(
name|TIF_FNAME
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ABTS_NOT_IMPL
argument_list|(
name|tc
argument_list|,
literal|"Skipped: could not create large file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bb
operator|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|e
operator|=
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|bignum
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"inserted file was not at end of brigade"
argument_list|,
name|e
operator|==
name|APR_BRIGADE_LAST
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check that the total size of inserted buckets is equal to the      * total size of the file. */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
condition|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
control|)
block|{
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"bucket size sane"
argument_list|,
name|e
operator|->
name|length
operator|!=
operator|(
name|apr_size_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|+=
name|e
operator|->
name|length
expr_stmt|;
block|}
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"total size of buckets incorrect"
argument_list|,
name|count
operator|==
name|bignum
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Truncate the file to zero size before close() so that we don't      * actually write out the large file if we are on a non-sparse file      * system - like Mac OS X's HFS.  Otherwise, pity the poor user who      * has to wait for the 8GB file to be written to disk.      */
name|apr_file_trunc
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|apr_file_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
name|apr_file_remove
argument_list|(
name|TIF_FNAME
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a test file named FNAME, and write CONTENTS to it. */
end_comment

begin_function
specifier|static
name|apr_file_t
modifier|*
name|make_test_file
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|f
decl_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"create test file"
argument_list|,
name|apr_file_open
argument_list|(
operator|&
name|f
argument_list|,
name|fname
argument_list|,
name|APR_FOPEN_READ
operator||
name|APR_FOPEN_WRITE
operator||
name|APR_FOPEN_TRUNCATE
operator||
name|APR_FOPEN_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|p
argument_list|)
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"write test file contents"
argument_list|,
name|apr_file_puts
argument_list|(
name|contents
argument_list|,
name|f
argument_list|)
operator|==
name|APR_SUCCESS
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_manyfile
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|make_test_file
argument_list|(
name|tc
argument_list|,
literal|"manyfile.bin"
argument_list|,
literal|"world"
literal|"hello"
literal|"brave"
literal|" ,\n"
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|10
argument_list|,
literal|5
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|17
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* can you tell what it is yet? */
name|flatten_match
argument_list|(
name|tc
argument_list|,
literal|"file seek test"
argument_list|,
name|bb
argument_list|,
literal|"hello, brave world\n"
argument_list|)
expr_stmt|;
name|apr_file_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test for PR 34708, where a file bucket will keep  * duplicating itself on being read() when EOF is reached  * prematurely. */
end_comment

begin_function
specifier|static
name|void
name|test_truncfile
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|f
init|=
name|make_test_file
argument_list|(
name|tc
argument_list|,
literal|"testfile.txt"
argument_list|,
literal|"hello"
argument_list|)
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_brigade_insert_file
argument_list|(
name|bb
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|apr_file_trunc
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"single bucket in brigade"
argument_list|,
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
operator|==
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|apr_bucket_file_enable_mmap
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"read gave APR_EOF"
argument_list|,
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
operator|==
name|APR_EOF
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"read length 0"
argument_list|,
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"still a single bucket in brigade"
argument_list|,
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
operator|==
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|apr_file_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hello
index|[]
init|=
literal|"hello, world"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|test_partition
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|apr_bucket_immortal_create
argument_list|(
name|hello
argument_list|,
name|strlen
argument_list|(
name|hello
argument_list|)
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_HEAD
argument_list|(
name|bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"partition brigade"
argument_list|,
name|apr_brigade_partition
argument_list|(
name|bb
argument_list|,
literal|5
argument_list|,
operator|&
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|test_bucket_content
argument_list|(
name|tc
argument_list|,
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
argument_list|,
literal|"hello"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|test_bucket_content
argument_list|(
name|tc
argument_list|,
name|APR_BRIGADE_LAST
argument_list|(
name|bb
argument_list|)
argument_list|,
literal|", world"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"partition returns APR_INCOMPLETE"
argument_list|,
name|apr_brigade_partition
argument_list|(
name|bb
argument_list|,
literal|8192
argument_list|,
operator|&
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_ASSERT
argument_list|(
name|tc
argument_list|,
literal|"APR_INCOMPLETE partition returned sentinel"
argument_list|,
name|e
operator|==
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_write_split
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb1
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb2
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|apr_bucket_heap_create
argument_list|(
name|hello
argument_list|,
name|strlen
argument_list|(
name|hello
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_HEAD
argument_list|(
name|bb1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|apr_bucket_split
argument_list|(
name|e
argument_list|,
name|strlen
argument_list|(
literal|"hello, "
argument_list|)
argument_list|)
expr_stmt|;
name|bb2
operator|=
name|apr_brigade_split
argument_list|(
name|bb1
argument_list|,
name|APR_BRIGADE_LAST
argument_list|(
name|bb1
argument_list|)
argument_list|)
expr_stmt|;
name|apr_brigade_write
argument_list|(
name|bb1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"foo"
argument_list|,
name|strlen
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|test_bucket_content
argument_list|(
name|tc
argument_list|,
name|APR_BRIGADE_FIRST
argument_list|(
name|bb2
argument_list|)
argument_list|,
literal|"world"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb1
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb2
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_write_putstrs
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_bucket_alloc_t
modifier|*
name|ba
init|=
name|apr_bucket_alloc_create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|bb
init|=
name|apr_brigade_create
argument_list|(
name|p
argument_list|,
name|ba
argument_list|)
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|expect
init|=
literal|"123456789abcdefghij"
decl_stmt|;
name|e
operator|=
name|apr_bucket_heap_create
argument_list|(
literal|"1"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_HEAD
argument_list|(
name|bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|apr_brigade_putstrs
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"2"
argument_list|,
literal|"34"
argument_list|,
literal|"567"
argument_list|,
literal|"8"
argument_list|,
literal|"9a"
argument_list|,
literal|"bcd"
argument_list|,
literal|"e"
argument_list|,
literal|"f"
argument_list|,
literal|"gh"
argument_list|,
literal|"i"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apr_brigade_putstrs
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"j"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"apr_brigade_flatten"
argument_list|,
name|apr_brigade_flatten
argument_list|(
name|bb
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|ABTS_STR_NEQUAL
argument_list|(
name|tc
argument_list|,
name|expect
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|expect
argument_list|)
argument_list|)
expr_stmt|;
name|apr_brigade_destroy
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|apr_bucket_alloc_destroy
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|abts_suite
modifier|*
name|testbuckets
parameter_list|(
name|abts_suite
modifier|*
name|suite
parameter_list|)
block|{
name|suite
operator|=
name|ADD_SUITE
argument_list|(
name|suite
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_simple
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_flatten
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_split
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_bwrite
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_splitline
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_splits
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_insertfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_manyfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_truncfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_partition
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_write_split
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_write_putstrs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|suite
return|;
block|}
end_function

end_unit

