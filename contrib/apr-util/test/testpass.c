begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"apr_errno.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_file_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_thread_pool.h"
end_include

begin_include
include|#
directive|include
file|"apr_md5.h"
end_include

begin_include
include|#
directive|include
file|"apr_sha1.h"
end_include

begin_include
include|#
directive|include
file|"abts.h"
end_include

begin_include
include|#
directive|include
file|"testutil.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|BEOS
argument_list|)
operator|||
name|defined
argument_list|(
name|NETWARE
argument_list|)
end_if

begin_define
define|#
directive|define
name|CRYPT_ALGO_SUPPORTED
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CRYPT_ALGO_SUPPORTED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|__GLIBC_PREREQ
end_if

begin_if
if|#
directive|if
name|__GLIBC_PREREQ
argument_list|(
literal|2
operator|,
literal|7
argument_list|)
end_if

begin_define
define|#
directive|define
name|GLIBCSHA_ALGO_SUPPORTED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CRYPT_ALGO_SUPPORTED
end_if

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
specifier|const
name|char
modifier|*
name|hash
decl_stmt|;
block|}
name|passwords
index|[]
init|=
block|{
comment|/*   passwords and hashes created with Apache's htpasswd utility like this:      htpasswd -c -b passwords pass1 pass1   htpasswd -b passwords pass2 pass2   htpasswd -b passwords pass3 pass3   htpasswd -b passwords pass4 pass4   htpasswd -b passwords pass5 pass5   htpasswd -b passwords pass6 pass6   htpasswd -b passwords pass7 pass7   htpasswd -b passwords pass8 pass8   (insert Perl one-liner to convert to initializer :) )  */
block|{
literal|"pass1"
block|,
literal|"1fWDc9QWYCWrQ"
block|}
block|,
block|{
literal|"pass2"
block|,
literal|"1fiGx3u7QoXaM"
block|}
block|,
block|{
literal|"pass3"
block|,
literal|"1fzijMylTiwCs"
block|}
block|,
block|{
literal|"pass4"
block|,
literal|"nHUYc8U2UOP7s"
block|}
block|,
block|{
literal|"pass5"
block|,
literal|"nHpETGLGPwAmA"
block|}
block|,
block|{
literal|"pass6"
block|,
literal|"nHbsbWmJ3uyhc"
block|}
block|,
block|{
literal|"pass7"
block|,
literal|"nHQ3BbF0Y9vpI"
block|}
block|,
block|{
literal|"pass8"
block|,
literal|"nHZA1rViSldQk"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|num_passwords
init|=
sizeof|sizeof
argument_list|(
name|passwords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|passwords
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|test_crypt
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_passwords
condition|;
name|i
operator|++
control|)
block|{
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"check for valid password"
argument_list|,
name|apr_password_validate
argument_list|(
name|passwords
index|[
name|i
index|]
operator|.
name|password
argument_list|,
name|passwords
index|[
name|i
index|]
operator|.
name|hash
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_function
specifier|static
name|void
modifier|*
name|APR_THREAD_FUNC
name|testing_thread
parameter_list|(
name|apr_thread_t
modifier|*
name|thd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|abts_case
modifier|*
name|tc
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|test_crypt
argument_list|(
name|tc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NUM_THR
value|20
end_define

begin_comment
comment|/* test for threadsafe crypt() */
end_comment

begin_function
specifier|static
name|void
name|test_threadsafe
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_thread_pool_t
modifier|*
name|thrp
decl_stmt|;
name|rv
operator|=
name|apr_thread_pool_create
argument_list|(
operator|&
name|thrp
argument_list|,
name|NUM_THR
operator|/
literal|2
argument_list|,
name|NUM_THR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ABTS_INT_EQUAL
argument_list|(
name|tc
argument_list|,
name|APR_SUCCESS
argument_list|,
name|rv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THR
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator|=
name|apr_thread_pool_push
argument_list|(
name|thrp
argument_list|,
name|testing_thread
argument_list|,
name|tc
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABTS_INT_EQUAL
argument_list|(
name|tc
argument_list|,
name|APR_SUCCESS
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
name|apr_thread_pool_destroy
argument_list|(
name|thrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRYPT_ALGO_SUPPORTED */
end_comment

begin_function
specifier|static
name|void
name|test_shapass
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pass
init|=
literal|"hellojed"
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass2
init|=
literal|"hellojed2"
decl_stmt|;
name|char
name|hash
index|[
literal|100
index|]
decl_stmt|;
name|apr_sha1_base64
argument_list|(
name|pass
argument_list|,
name|strlen
argument_list|(
name|pass
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"SHA1 password validated"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ASSERT_FAILURE
argument_list|(
name|tc
argument_list|,
literal|"wrong SHA1 password should not validate"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass2
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_md5pass
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pass
init|=
literal|"hellojed"
decl_stmt|,
modifier|*
name|salt
init|=
literal|"sardine"
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass2
init|=
literal|"hellojed2"
decl_stmt|;
name|char
name|hash
index|[
literal|100
index|]
decl_stmt|;
name|apr_md5_encode
argument_list|(
name|pass
argument_list|,
name|salt
argument_list|,
name|hash
argument_list|,
sizeof|sizeof
name|hash
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"MD5 password validated"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ASSERT_FAILURE
argument_list|(
name|tc
argument_list|,
literal|"wrong MD5 password should not validate"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass2
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GLIBCSHA_ALGO_SUPPORTED
end_ifdef

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
specifier|const
name|char
modifier|*
name|hash
decl_stmt|;
block|}
name|glibc_sha_pws
index|[]
init|=
block|{
comment|/* SHA256 */
block|{
literal|"secret1"
block|,
literal|"$5$0123456789abcdef$SFX.CooXBS8oXsbAPgU/UyiCodhrLQ19sBgvcA3Zh1D"
block|}
block|,
block|{
literal|"secret2"
block|,
literal|"$5$rounds=100000$0123456789abcdef$dLXfO5m4d.xv8G66kpz2LyL0.Mi5wjLlH0m7rtgyhyB"
block|}
block|,
comment|/* SHA512 */
block|{
literal|"secret3"
block|,
literal|"$6$0123456789abcdef$idOsOfoWwnCQkJm9hd2hxS4NnEs9nBA9poOFXsvtrYSoSHaOToCfyUoZwKe.ZCZnq7D95tGVoi2jxZZMyVwTL1"
block|}
block|,
block|{
literal|"secret4"
block|,
literal|"$6$rounds=100000$0123456789abcdef$ZiAMjbeA.iIGTWxq2oks9Bvz9sfxaoGPgAtpwimPEwFwkSNMTK7lLwABzzldds/n4UgCQ16HqawPrCrePr4YX1"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|test_glibc_shapass
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|glibc_sha_pws
index|[
name|i
index|]
operator|.
name|password
condition|)
block|{
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"check for valid glibc crypt-sha password"
argument_list|,
name|apr_password_validate
argument_list|(
name|glibc_sha_pws
index|[
name|i
index|]
operator|.
name|password
argument_list|,
name|glibc_sha_pws
index|[
name|i
index|]
operator|.
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_bcryptpass
parameter_list|(
name|abts_case
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pass
init|=
literal|"hellojed"
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass2
init|=
literal|"hellojed2"
decl_stmt|;
name|unsigned
name|char
name|salt
index|[]
init|=
literal|"sardine_sardine"
decl_stmt|;
name|char
name|hash
index|[
literal|100
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|hash2
init|=
literal|"$2a$08$qipUJiI9fySUN38hcbz.lucXvAmtgowKOWYtB9y3CXyl6lTknruou"
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass3
init|=
literal|"foobar"
decl_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"bcrypt encode password"
argument_list|,
name|apr_bcrypt_encode
argument_list|(
name|pass
argument_list|,
literal|5
argument_list|,
name|salt
argument_list|,
sizeof|sizeof
argument_list|(
name|salt
argument_list|)
argument_list|,
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"bcrypt password validated"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ASSERT_FAILURE
argument_list|(
name|tc
argument_list|,
literal|"wrong bcrypt password should not validate"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass2
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|apr_assert_success
argument_list|(
name|tc
argument_list|,
literal|"bcrypt password validated"
argument_list|,
name|apr_password_validate
argument_list|(
name|pass3
argument_list|,
name|hash2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|abts_suite
modifier|*
name|testpass
parameter_list|(
name|abts_suite
modifier|*
name|suite
parameter_list|)
block|{
name|suite
operator|=
name|ADD_SUITE
argument_list|(
name|suite
argument_list|)
expr_stmt|;
if|#
directive|if
name|CRYPT_ALGO_SUPPORTED
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_crypt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_threadsafe
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* CRYPT_ALGO_SUPPORTED */
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_shapass
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_md5pass
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_bcryptpass
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GLIBCSHA_ALGO_SUPPORTED
name|abts_run_test
argument_list|(
name|suite
argument_list|,
name|test_glibc_shapass
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|suite
return|;
block|}
end_function

end_unit

