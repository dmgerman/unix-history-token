begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_tables.h"
end_include

begin_include
include|#
directive|include
file|"apr_buckets.h"
end_include

begin_include
include|#
directive|include
file|"apr_errno.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_MEMFUNC
end_define

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_SYS_UIO_H
end_if

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|apr_status_t
name|brigade_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|apr_brigade_cleanup
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_cleanup
argument_list|(
argument|void *data
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket_brigade
modifier|*
name|b
init|=
name|data
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|!
name|APR_BRIGADE_EMPTY
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|apr_bucket_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* We don't need to free(bb) because it's allocated from a pool. */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_destroy
argument_list|(
argument|apr_bucket_brigade *b
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_cleanup_kill
argument_list|(
name|b
operator|->
name|p
argument_list|,
name|b
argument_list|,
name|brigade_cleanup
argument_list|)
expr_stmt|;
return|return
name|apr_brigade_cleanup
argument_list|(
name|b
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_bucket_brigade *
argument_list|)
end_macro

begin_macro
name|apr_brigade_create
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|apr_bucket_alloc_t *list
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket_brigade
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|b
operator|->
name|bucket_alloc
operator|=
name|list
expr_stmt|;
name|APR_RING_INIT
argument_list|(
operator|&
name|b
operator|->
name|list
argument_list|,
name|apr_bucket
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|b
operator|->
name|p
argument_list|,
name|b
argument_list|,
name|brigade_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_bucket_brigade *
argument_list|)
end_macro

begin_macro
name|apr_brigade_split_ex
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_bucket *e
argument_list|,
argument|apr_bucket_brigade *a
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|a
operator|=
name|apr_brigade_create
argument_list|(
name|b
operator|->
name|p
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|APR_BRIGADE_EMPTY
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|apr_brigade_cleanup
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* Return an empty brigade if there is nothing left in       * the first brigade to split off       */
if|if
condition|(
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|f
operator|=
name|APR_RING_LAST
argument_list|(
operator|&
name|b
operator|->
name|list
argument_list|)
expr_stmt|;
name|APR_RING_UNSPLICE
argument_list|(
name|e
argument_list|,
name|f
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APR_RING_SPLICE_HEAD
argument_list|(
operator|&
name|a
operator|->
name|list
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|apr_bucket
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|APR_BRIGADE_CHECK_CONSISTENCY
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|APR_BRIGADE_CHECK_CONSISTENCY
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_bucket_brigade *
argument_list|)
end_macro

begin_macro
name|apr_brigade_split
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_bucket *e
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_brigade_split_ex
argument_list|(
name|b
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_partition
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_off_t point
argument_list|,
argument|apr_bucket **after_point
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_uint64_t
name|point64
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
name|point
operator|<
literal|0
condition|)
block|{
comment|/* this could cause weird (not necessarily SEGV) things to happen */
return|return
name|APR_EINVAL
return|;
block|}
if|if
condition|(
name|point
operator|==
literal|0
condition|)
block|{
operator|*
name|after_point
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/*      * Try to reduce the following casting mess: We know that point will be      * larger equal 0 now and forever and thus that point (apr_off_t) and      * apr_size_t will fit into apr_uint64_t in any case.      */
name|point64
operator|=
operator|(
name|apr_uint64_t
operator|)
name|point
expr_stmt|;
name|APR_BRIGADE_CHECK_CONSISTENCY
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|b
argument_list|)
init|;
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|b
argument_list|)
condition|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
control|)
block|{
comment|/* For an unknown length bucket, while 'point64' is beyond the possible          * size contained in apr_size_t, read and continue...          */
if|if
condition|(
operator|(
name|e
operator|->
name|length
operator|==
call|(
name|apr_size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|&&
operator|(
name|point64
operator|>
operator|(
name|apr_uint64_t
operator|)
name|APR_SIZE_MAX
operator|)
condition|)
block|{
comment|/* point64 is too far out to simply split this bucket,              * we must fix this bucket's size and keep going... */
name|rv
operator|=
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|after_point
operator|=
name|e
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|point64
operator|<
operator|(
name|apr_uint64_t
operator|)
name|e
operator|->
name|length
operator|)
operator|||
operator|(
name|e
operator|->
name|length
operator|==
call|(
name|apr_size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* We already consumed buckets where point64 is beyond              * our interest ( point64> APR_SIZE_MAX ), above.              * Here point falls between 0 and APR_SIZE_MAX              * and is within this bucket, or this bucket's len              * is undefined, so now we are ready to split it.              * First try to split the bucket natively... */
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_bucket_split
argument_list|(
name|e
argument_list|,
operator|(
name|apr_size_t
operator|)
name|point64
argument_list|)
operator|)
operator|!=
name|APR_ENOTIMPL
condition|)
block|{
operator|*
name|after_point
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
comment|/* if the bucket cannot be split, we must read from it,              * changing its type to one that can be split */
name|rv
operator|=
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|after_point
operator|=
name|e
expr_stmt|;
return|return
name|rv
return|;
block|}
comment|/* this assumes that len == e->length, which is okay because e              * might have been morphed by the apr_bucket_read() above, but              * if it was, the length would have been adjusted appropriately */
if|if
condition|(
name|point64
operator|<
operator|(
name|apr_uint64_t
operator|)
name|e
operator|->
name|length
condition|)
block|{
name|rv
operator|=
name|apr_bucket_split
argument_list|(
name|e
argument_list|,
operator|(
name|apr_size_t
operator|)
name|point64
argument_list|)
expr_stmt|;
operator|*
name|after_point
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
if|if
condition|(
name|point64
operator|==
operator|(
name|apr_uint64_t
operator|)
name|e
operator|->
name|length
condition|)
block|{
operator|*
name|after_point
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|point64
operator|-=
operator|(
name|apr_uint64_t
operator|)
name|e
operator|->
name|length
expr_stmt|;
block|}
operator|*
name|after_point
operator|=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|APR_INCOMPLETE
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_length
argument_list|(
argument|apr_bucket_brigade *bb
argument_list|,
argument|int read_all
argument_list|,
argument|apr_off_t *length
argument_list|)
end_macro

begin_block
block|{
name|apr_off_t
name|total
init|=
literal|0
decl_stmt|;
name|apr_bucket
modifier|*
name|bkt
decl_stmt|;
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
for|for
control|(
name|bkt
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|bkt
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
condition|;
name|bkt
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|bkt
argument_list|)
control|)
block|{
if|if
condition|(
name|bkt
operator|->
name|length
operator|==
call|(
name|apr_size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|ignore
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|read_all
condition|)
block|{
name|total
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|apr_bucket_read
argument_list|(
name|bkt
argument_list|,
operator|&
name|ignore
argument_list|,
operator|&
name|len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
break|break;
block|}
block|}
name|total
operator|+=
name|bkt
operator|->
name|length
expr_stmt|;
block|}
operator|*
name|length
operator|=
name|total
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_flatten
argument_list|(
argument|apr_bucket_brigade *bb
argument_list|,
argument|char *c
argument_list|,
argument|apr_size_t *len
argument_list|)
end_macro

begin_block
block|{
name|apr_size_t
name|actual
init|=
literal|0
decl_stmt|;
name|apr_bucket
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bb
argument_list|)
init|;
name|b
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|bb
argument_list|)
condition|;
name|b
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|b
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|str_len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_bucket_read
argument_list|(
name|b
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|str_len
argument_list|,
name|APR_BLOCK_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* If we would overflow. */
if|if
condition|(
name|str_len
operator|+
name|actual
operator|>
operator|*
name|len
condition|)
block|{
name|str_len
operator|=
operator|*
name|len
operator|-
name|actual
expr_stmt|;
block|}
comment|/* XXX: It appears that overflow of the final bucket          * is DISCARDED without any warning to the caller.          *          * No, we only copy the data up to their requested size.  -- jre          */
name|memcpy
argument_list|(
name|c
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|)
expr_stmt|;
name|c
operator|+=
name|str_len
expr_stmt|;
name|actual
operator|+=
name|str_len
expr_stmt|;
comment|/* This could probably be actual == *len, but be safe from stray          * photons. */
if|if
condition|(
name|actual
operator|>=
operator|*
name|len
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|len
operator|=
name|actual
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_pflatten
argument_list|(
argument|apr_bucket_brigade *bb
argument_list|,
argument|char **c
argument_list|,
argument|apr_size_t *len
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|apr_off_t
name|actual
decl_stmt|;
name|apr_size_t
name|total
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_brigade_length
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|,
operator|&
name|actual
argument_list|)
expr_stmt|;
comment|/* XXX: This is dangerous beyond belief.  At least in the      * apr_brigade_flatten case, the user explicitly stated their      * buffer length - so we don't up and palloc 4GB for a single      * file bucket.  This API must grow a useful max boundry,      * either compiled-in or preset via the *len value.      *      * Shouldn't both fn's grow an additional return value for       * the case that the brigade couldn't be flattened into the      * provided or allocated buffer (such as APR_EMOREDATA?)      * Not a failure, simply an advisory result.      */
name|total
operator|=
operator|(
name|apr_size_t
operator|)
name|actual
expr_stmt|;
operator|*
name|c
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_brigade_flatten
argument_list|(
name|bb
argument_list|,
operator|*
name|c
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
operator|*
name|len
operator|=
name|total
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_split_line
argument_list|(
argument|apr_bucket_brigade *bbOut
argument_list|,
argument|apr_bucket_brigade *bbIn
argument_list|,
argument|apr_read_type_e block
argument_list|,
argument|apr_off_t maxbytes
argument_list|)
end_macro

begin_block
block|{
name|apr_off_t
name|readbytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|APR_BRIGADE_EMPTY
argument_list|(
name|bbIn
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|bbIn
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|pos
operator|=
name|memchr
argument_list|(
name|str
argument_list|,
name|APR_ASCII_LF
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* We found a match. */
if|if
condition|(
name|pos
operator|!=
name|NULL
condition|)
block|{
name|apr_bucket_split
argument_list|(
name|e
argument_list|,
name|pos
operator|-
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|APR_BUCKET_REMOVE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bbOut
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|APR_BUCKET_REMOVE
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_BUCKET_IS_METADATA
argument_list|(
name|e
argument_list|)
operator|||
name|len
operator|>
name|APR_BUCKET_BUFF_SIZE
operator|/
literal|4
condition|)
block|{
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bbOut
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|apr_brigade_write
argument_list|(
name|bbOut
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
block|}
name|apr_bucket_destroy
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|readbytes
operator|+=
name|len
expr_stmt|;
comment|/* We didn't find an APR_ASCII_LF within the maximum line length. */
if|if
condition|(
name|readbytes
operator|>=
name|maxbytes
condition|)
block|{
break|break;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_to_iovec
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|struct iovec *vec
argument_list|,
argument|int *nvec
argument_list|)
end_macro

begin_block
block|{
name|int
name|left
init|=
operator|*
name|nvec
decl_stmt|;
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|struct
name|iovec
modifier|*
name|orig
decl_stmt|;
name|apr_size_t
name|iov_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|iov_base
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|orig
operator|=
name|vec
expr_stmt|;
for|for
control|(
name|e
operator|=
name|APR_BRIGADE_FIRST
argument_list|(
name|b
argument_list|)
init|;
name|e
operator|!=
name|APR_BRIGADE_SENTINEL
argument_list|(
name|b
argument_list|)
condition|;
name|e
operator|=
name|APR_BUCKET_NEXT
argument_list|(
name|e
argument_list|)
control|)
block|{
if|if
condition|(
name|left
operator|--
operator|==
literal|0
condition|)
break|break;
name|rv
operator|=
name|apr_bucket_read
argument_list|(
name|e
argument_list|,
operator|&
name|iov_base
argument_list|,
operator|&
name|iov_len
argument_list|,
name|APR_NONBLOCK_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|rv
return|;
comment|/* Set indirectly since types differ: */
name|vec
operator|->
name|iov_len
operator|=
name|iov_len
expr_stmt|;
name|vec
operator|->
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|iov_base
expr_stmt|;
operator|++
name|vec
expr_stmt|;
block|}
operator|*
name|nvec
operator|=
call|(
name|int
call|)
argument_list|(
name|vec
operator|-
name|orig
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_vputstrs
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|va_list va
argument_list|)
end_macro

begin_block
block|{
define|#
directive|define
name|MAX_VECS
value|8
name|struct
name|iovec
name|vec
index|[
name|MAX_VECS
index|]
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|str
init|=
name|va_arg
argument_list|(
name|va
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
break|break;
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|str
expr_stmt|;
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MAX_VECS
condition|)
block|{
name|rv
operator|=
name|apr_brigade_writev
argument_list|(
name|b
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
name|vec
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|rv
return|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|apr_brigade_writev
argument_list|(
name|b
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
name|vec
argument_list|,
name|i
argument_list|)
return|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_putc
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|const char c
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_brigade_write
argument_list|(
name|b
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_write
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|const char *str
argument_list|,
argument|apr_size_t nbyte
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket
modifier|*
name|e
init|=
name|APR_BRIGADE_LAST
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|apr_size_t
name|remaining
init|=
name|APR_BUCKET_BUFF_SIZE
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/*      * If the last bucket is a heap bucket and its buffer is not shared with      * another bucket, we may write into that bucket.      */
if|if
condition|(
operator|!
name|APR_BRIGADE_EMPTY
argument_list|(
name|b
argument_list|)
operator|&&
name|APR_BUCKET_IS_HEAP
argument_list|(
name|e
argument_list|)
operator|&&
operator|(
operator|(
name|apr_bucket_heap
operator|*
operator|)
operator|(
name|e
operator|->
name|data
operator|)
operator|)
operator|->
name|refcount
operator|.
name|refcount
operator|==
literal|1
condition|)
block|{
name|apr_bucket_heap
modifier|*
name|h
init|=
name|e
operator|->
name|data
decl_stmt|;
comment|/* HEAP bucket start offsets are always in-memory, safe to cast */
name|remaining
operator|=
name|h
operator|->
name|alloc_len
operator|-
operator|(
name|e
operator|->
name|length
operator|+
operator|(
name|apr_size_t
operator|)
name|e
operator|->
name|start
operator|)
expr_stmt|;
name|buf
operator|=
name|h
operator|->
name|base
operator|+
name|e
operator|->
name|start
operator|+
name|e
operator|->
name|length
expr_stmt|;
block|}
if|if
condition|(
name|nbyte
operator|>
name|remaining
condition|)
block|{
comment|/* either a buffer bucket exists but is full,           * or no buffer bucket exists and the data is too big          * to buffer.  In either case, we should flush.  */
if|if
condition|(
name|flush
condition|)
block|{
name|e
operator|=
name|apr_bucket_transient_create
argument_list|(
name|str
argument_list|,
name|nbyte
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|flush
argument_list|(
name|b
argument_list|,
name|ctx
argument_list|)
return|;
block|}
else|else
block|{
name|e
operator|=
name|apr_bucket_heap_create
argument_list|(
name|str
argument_list|,
name|nbyte
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|buf
condition|)
block|{
comment|/* we don't have a buffer, but the data is small enough          * that we don't mind making a new buffer */
name|buf
operator|=
name|apr_bucket_alloc
argument_list|(
name|APR_BUCKET_BUFF_SIZE
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|e
operator|=
name|apr_bucket_heap_create
argument_list|(
name|buf
argument_list|,
name|APR_BUCKET_BUFF_SIZE
argument_list|,
name|apr_bucket_free
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* We are writing into the brigade, and                           * allocating more memory than we need.  This                           * ensures that the bucket thinks it is empty just                           * after we create it.  We'll fix the length                           * once we put data in it below.                           */
block|}
comment|/* there is a sufficiently big buffer bucket available now */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
name|e
operator|->
name|length
operator|+=
name|nbyte
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_writev
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|const struct iovec *vec
argument_list|,
argument|apr_size_t nvec
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket
modifier|*
name|e
decl_stmt|;
name|apr_size_t
name|total_len
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Compute the total length of the data to be written.      */
name|total_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|total_len
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* If the data to be written is very large, try to convert      * the iovec to transient buckets rather than copying.      */
if|if
condition|(
name|total_len
operator|>
name|APR_BUCKET_BUFF_SIZE
condition|)
block|{
if|if
condition|(
name|flush
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|apr_bucket_transient_create
argument_list|(
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|flush
argument_list|(
name|b
argument_list|,
name|ctx
argument_list|)
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|apr_bucket_heap_create
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If there is a heap bucket at the end of the brigade      * already, and its refcount is 1, copy into the existing bucket.      */
name|e
operator|=
name|APR_BRIGADE_LAST
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|APR_BRIGADE_EMPTY
argument_list|(
name|b
argument_list|)
operator|&&
name|APR_BUCKET_IS_HEAP
argument_list|(
name|e
argument_list|)
operator|&&
operator|(
operator|(
name|apr_bucket_heap
operator|*
operator|)
operator|(
name|e
operator|->
name|data
operator|)
operator|)
operator|->
name|refcount
operator|.
name|refcount
operator|==
literal|1
condition|)
block|{
name|apr_bucket_heap
modifier|*
name|h
init|=
name|e
operator|->
name|data
decl_stmt|;
name|apr_size_t
name|remaining
init|=
name|h
operator|->
name|alloc_len
operator|-
operator|(
name|e
operator|->
name|length
operator|+
operator|(
name|apr_size_t
operator|)
name|e
operator|->
name|start
operator|)
decl_stmt|;
name|buf
operator|=
name|h
operator|->
name|base
operator|+
name|e
operator|->
name|start
operator|+
name|e
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|remaining
operator|>=
name|total_len
condition|)
block|{
comment|/* Simple case: all the data will fit in the              * existing heap bucket              */
for|for
control|(
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|len
init|=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
block|}
name|e
operator|->
name|length
operator|+=
name|total_len
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
else|else
block|{
comment|/* More complicated case: not all of the data              * will fit in the existing heap bucket.  The              * total data size is<= APR_BUCKET_BUFF_SIZE,              * so we'll need only one additional bucket.              */
specifier|const
name|char
modifier|*
name|start_buf
init|=
name|buf
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|len
init|=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|remaining
condition|)
block|{
break|break;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|remaining
operator|-=
name|len
expr_stmt|;
block|}
name|e
operator|->
name|length
operator|+=
operator|(
name|buf
operator|-
name|start_buf
operator|)
expr_stmt|;
name|total_len
operator|-=
operator|(
name|buf
operator|-
name|start_buf
operator|)
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|apr_status_t
name|rv
init|=
name|flush
argument_list|(
name|b
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
block|}
comment|/* Now fall through into the case below to              * allocate another heap bucket and copy the              * rest of the array.  (Note that i is not              * reset to zero here; it holds the index              * of the first vector element to be              * written to the new bucket.)              */
block|}
block|}
comment|/* Allocate a new heap bucket, and copy the data into it.      * The checks above ensure that the amount of data to be      * written here is no larger than APR_BUCKET_BUFF_SIZE.      */
name|buf
operator|=
name|apr_bucket_alloc
argument_list|(
name|APR_BUCKET_BUFF_SIZE
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
name|e
operator|=
name|apr_bucket_heap_create
argument_list|(
name|buf
argument_list|,
name|APR_BUCKET_BUFF_SIZE
argument_list|,
name|apr_bucket_free
argument_list|,
name|b
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|len
init|=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
block|}
name|e
operator|->
name|length
operator|=
name|total_len
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_puts
argument_list|(
argument|apr_bucket_brigade *bb
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|const char *str
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_brigade_write
argument_list|(
name|bb
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE_NONSTD
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_putstrs
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|va
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_brigade_vputstrs
argument_list|(
name|b
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_block

begin_macro
name|APU_DECLARE_NONSTD
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_printf
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|const char *fmt
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_brigade_vprintf
argument_list|(
name|b
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_block

begin_struct
struct|struct
name|brigade_vprintf_data_t
block|{
name|apr_vformatter_buff_t
name|vbuff
decl_stmt|;
name|apr_bucket_brigade
modifier|*
name|b
decl_stmt|;
comment|/* associated brigade */
name|apr_brigade_flush
modifier|*
name|flusher
decl_stmt|;
comment|/* flushing function */
name|void
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|cbuff
decl_stmt|;
comment|/* buffer to flush from */
block|}
struct|;
end_struct

begin_function
specifier|static
name|apr_status_t
name|brigade_flush
parameter_list|(
name|apr_vformatter_buff_t
modifier|*
name|buff
parameter_list|)
block|{
comment|/* callback function passed to ap_vformatter to be      * called when vformatter needs to buff and      * buff.curpos> buff.endpos      */
comment|/* "downcast," have really passed a brigade_vprintf_data_t* */
name|struct
name|brigade_vprintf_data_t
modifier|*
name|vd
init|=
operator|(
expr|struct
name|brigade_vprintf_data_t
operator|*
operator|)
name|buff
decl_stmt|;
name|apr_status_t
name|res
init|=
name|APR_SUCCESS
decl_stmt|;
name|res
operator|=
name|apr_brigade_write
argument_list|(
name|vd
operator|->
name|b
argument_list|,
operator|*
name|vd
operator|->
name|flusher
argument_list|,
name|vd
operator|->
name|ctx
argument_list|,
name|vd
operator|->
name|cbuff
argument_list|,
name|APR_BUCKET_BUFF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|vd
operator|->
name|vbuff
operator|.
name|curpos
operator|=
name|vd
operator|->
name|cbuff
expr_stmt|;
name|vd
operator|->
name|vbuff
operator|.
name|endpos
operator|=
name|vd
operator|->
name|cbuff
operator|+
name|APR_BUCKET_BUFF_SIZE
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_brigade_vprintf
argument_list|(
argument|apr_bucket_brigade *b
argument_list|,
argument|apr_brigade_flush flush
argument_list|,
argument|void *ctx
argument_list|,
argument|const char *fmt
argument_list|,
argument|va_list va
argument_list|)
end_macro

begin_block
block|{
comment|/* the cast, in order of appearance */
name|struct
name|brigade_vprintf_data_t
name|vd
decl_stmt|;
name|char
name|buf
index|[
name|APR_BUCKET_BUFF_SIZE
index|]
decl_stmt|;
name|int
name|written
decl_stmt|;
name|vd
operator|.
name|vbuff
operator|.
name|curpos
operator|=
name|buf
expr_stmt|;
name|vd
operator|.
name|vbuff
operator|.
name|endpos
operator|=
name|buf
operator|+
name|APR_BUCKET_BUFF_SIZE
expr_stmt|;
name|vd
operator|.
name|b
operator|=
name|b
expr_stmt|;
name|vd
operator|.
name|flusher
operator|=
operator|&
name|flush
expr_stmt|;
name|vd
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|vd
operator|.
name|cbuff
operator|=
name|buf
expr_stmt|;
name|written
operator|=
name|apr_vformatter
argument_list|(
name|brigade_flush
argument_list|,
operator|&
name|vd
operator|.
name|vbuff
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* write out what remains in the buffer */
return|return
name|apr_brigade_write
argument_list|(
name|b
argument_list|,
name|flush
argument_list|,
name|ctx
argument_list|,
name|buf
argument_list|,
name|vd
operator|.
name|vbuff
operator|.
name|curpos
operator|-
name|buf
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* A "safe" maximum bucket size, 1Gb */
end_comment

begin_define
define|#
directive|define
name|MAX_BUCKET_SIZE
value|(0x40000000)
end_define

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_bucket *
argument_list|)
end_macro

begin_macro
name|apr_brigade_insert_file
argument_list|(
argument|apr_bucket_brigade *bb
argument_list|,
argument|apr_file_t *f
argument_list|,
argument|apr_off_t start
argument_list|,
argument|apr_off_t length
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|apr_bucket
modifier|*
name|e
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
operator|||
name|length
operator|<
name|MAX_BUCKET_SIZE
condition|)
block|{
name|e
operator|=
name|apr_bucket_file_create
argument_list|(
name|f
argument_list|,
name|start
argument_list|,
operator|(
name|apr_size_t
operator|)
name|length
argument_list|,
name|p
argument_list|,
name|bb
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Several buckets are needed. */
name|e
operator|=
name|apr_bucket_file_create
argument_list|(
name|f
argument_list|,
name|start
argument_list|,
name|MAX_BUCKET_SIZE
argument_list|,
name|p
argument_list|,
name|bb
operator|->
name|bucket_alloc
argument_list|)
expr_stmt|;
while|while
condition|(
name|length
operator|>
name|MAX_BUCKET_SIZE
condition|)
block|{
name|apr_bucket
modifier|*
name|ce
decl_stmt|;
name|apr_bucket_copy
argument_list|(
name|e
argument_list|,
operator|&
name|ce
argument_list|)
expr_stmt|;
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|ce
argument_list|)
expr_stmt|;
name|e
operator|->
name|start
operator|+=
name|MAX_BUCKET_SIZE
expr_stmt|;
name|length
operator|-=
name|MAX_BUCKET_SIZE
expr_stmt|;
block|}
name|e
operator|->
name|length
operator|=
operator|(
name|apr_size_t
operator|)
name|length
expr_stmt|;
comment|/* Resize just the last bucket */
block|}
name|APR_BRIGADE_INSERT_TAIL
argument_list|(
name|bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_block

end_unit

