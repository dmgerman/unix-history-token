begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Work with executable files, for GDB.     Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1997, 1998              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xcoffsolib.h"
end_include

begin_decl_stmt
name|struct
name|vmap
modifier|*
name|map_vmap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*file_changed_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_to_section_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exec_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_section_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exec_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bfdsec_to_vmap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ignore
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_exec_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_exec
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target vector for executable files.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|exec_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Binary File Descriptor handle for the executable file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|exec_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to open exec and core files read-only or read-write.  */
end_comment

begin_decl_stmt
name|int
name|write_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text start and end addresses (KLUDGE) if needed */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NEED_TEXT_START_END
end_ifndef

begin_define
define|#
directive|define
name|NEED_TEXT_START_END
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|CORE_ADDR
name|text_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|text_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vmap
modifier|*
name|vmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|exec_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|int
name|need_symtab_cleanup
init|=
literal|0
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nxt
decl_stmt|;
for|for
control|(
name|nxt
operator|=
name|vmap
init|;
name|nxt
operator|!=
name|NULL
condition|;
control|)
block|{
name|vp
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|vp
operator|->
name|nxt
expr_stmt|;
comment|/* if there is an objfile associated with this bfd, 	 free_objfile() will do proper cleanup of objfile *and* bfd. */
if|if
condition|(
name|vp
operator|->
name|objfile
condition|)
block|{
name|free_objfile
argument_list|(
name|vp
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|need_symtab_cleanup
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|bfd
operator|!=
name|exec_bfd
condition|)
comment|/* FIXME-leak: We should be freeing vp->name too, I think.  */
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|vp
operator|->
name|bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|vp
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This routine is #if 0'd in symfile.c.  What should we 	 be doing here?  Should we just free everything in 	 vp->objfile->symtabs?  Should free_objfile do that? 	 FIXME-as-well: free_objfile already free'd vp->name, so it isn't 	 valid here.  */
name|free_named_symtabs
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vmap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|exec_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|exec_ops
operator|.
name|to_sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|exec_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|exec_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Process the first arg in ARGS as the new exec file.      This function is intended to be behave essentially the same     as exec_file_command, except that the latter will detect when     a target is being debugged, and will ask the user whether it     should be shut down first.  (If the answer is "no", then the     new file is ignored.)      This file is used by exec_file_command, to do the work of opening     and processing the exec file after any prompting has happened.      And, it is used by child_attach, when the attach command was     given a pid but not a exec pathname, and the attach command could     figure out the pathname from the pid.  (In this case, we shouldn't     ask the user whether the current target should be shut down --     we're supplying the exec pathname late for good reason.) */
end_comment

begin_function
name|void
name|exec_file_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Remove any previous exec file.  */
name|unpush_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|args
condition|)
block|{
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
comment|/* Scan through the args and pick up the first non option arg 	 as the filename.  */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|argv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
operator|)
condition|;
name|argv
operator|++
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no exec file name was specified"
argument_list|)
expr_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|write_files
condition|?
name|O_RDWR
operator||
name|O_BINARY
else|:
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|exename
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|exename
argument_list|,
name|filename
argument_list|)
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|exename
argument_list|,
name|write_files
condition|?
name|O_RDWR
operator||
name|O_BINARY
else|:
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|scratch_chan
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|error
argument_list|(
literal|"\"%s\": could not open as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At this point, scratch_pathname and exec_bfd->name both point to the 	 same malloc'd string.  However exec_close() will attempt to free it 	 via the exec_bfd->name pointer, so we need to make another copy and 	 leave exec_bfd as the new owner of the original copy. */
name|scratch_pathname
operator|=
name|strdup
argument_list|(
name|scratch_pathname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|exec_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* Make sure to close exec_bfd, or else "run" might try to use 	     it.  */
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME - This should only be run for RS6000, but the ifdef is a poor 	 way to accomplish.  */
ifdef|#
directive|ifdef
name|IBM6000_TARGET
comment|/* Setup initial vmap. */
name|map_vmap
argument_list|(
name|exec_bfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmap
operator|==
name|NULL
condition|)
block|{
comment|/* Make sure to close exec_bfd, or else "run" might try to use 	     it.  */
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't find the file sections: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IBM6000_TARGET */
if|if
condition|(
name|build_section_table
argument_list|(
name|exec_bfd
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
block|{
comment|/* Make sure to close exec_bfd, or else "run" might try to use 	     it.  */
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't find the file sections: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* text_end is sometimes used for where to put call dummies.  A 	 few ports use these for other purposes too.  */
if|if
condition|(
name|NEED_TEXT_START_END
condition|)
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
comment|/* Set text_start to the lowest address of the start of any 	     readonly code section and set text_end to the highest 	     address of the end of any readonly code section.  */
comment|/* FIXME: The comment above does not match the code.  The 	     code checks for sections with are either code *or* 	     readonly.  */
name|text_start
operator|=
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
name|text_end
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
condition|)
block|{
if|if
condition|(
name|text_start
operator|>
name|p
operator|->
name|addr
condition|)
name|text_start
operator|=
name|p
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|text_end
operator|<
name|p
operator|->
name|endaddr
condition|)
name|text_end
operator|=
name|p
operator|->
name|endaddr
expr_stmt|;
block|}
block|}
name|validate_files
argument_list|()
expr_stmt|;
name|set_gdbarch_from_file
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"No executable file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Process the first arg in ARGS as the new exec file.      Note that we have to explicitly ignore additional args, since we can     be called from file_command(), which also calls symbol_file_command()     which can take multiple args. */
end_comment

begin_function
name|void
name|exec_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|exec_file_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set both the exec file and the symbol file, in one command.      What a novelty.  Why did GDB go through four major releases before this    command was added?  */
end_comment

begin_function
specifier|static
name|void
name|file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* FIXME, if we lose on reading the symbol file, we should revert      the exec file, but that's rough.  */
name|exec_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_changed_hook
condition|)
name|file_changed_hook
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Locate all mappable sections of a BFD file.     table_pp_char is a char * to get it through bfd_map_over_sections;    we cast it back to its proper type.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_section_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|table_pp_char
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|table_pp_char
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
modifier|*
name|table_pp
init|=
operator|(
expr|struct
name|section_table
operator|*
operator|*
operator|)
name|table_pp_char
decl_stmt|;
name|flagword
name|aflag
decl_stmt|;
name|aflag
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aflag
operator|&
name|SEC_ALLOC
operator|)
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
condition|)
return|return;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|the_bfd_section
operator|=
name|asect
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|endaddr
operator|=
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Builds a section table, given args BFD, SECTABLE_PTR, SECEND_PTR.    Returns 0 if OK, 1 on error.  */
end_comment

begin_function
name|int
name|build_section_table
parameter_list|(
name|some_bfd
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|bfd
modifier|*
name|some_bfd
decl_stmt|;
name|struct
name|section_table
modifier|*
modifier|*
name|start
decl_stmt|,
decl|*
modifier|*
name|end
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|count
decl_stmt|;
name|count
operator|=
name|bfd_count_sections
argument_list|(
name|some_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|start
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
operator|*
name|start
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|*
name|start
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|some_bfd
argument_list|,
name|add_to_section_table
argument_list|,
operator|(
name|char
operator|*
operator|)
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|>
operator|*
name|start
operator|+
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We could realloc the table, but it probably loses for most files.  */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|void
name|bfdsec_to_vmap
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|arg3
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|sect
decl_stmt|;
name|PTR
name|arg3
decl_stmt|;
block|{
name|struct
name|vmap_and_bfd
modifier|*
name|vmap_bfd
init|=
operator|(
expr|struct
name|vmap_and_bfd
operator|*
operator|)
name|arg3
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|vmap_bfd
operator|->
name|pvmap
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|STREQ
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|vp
operator|->
name|tstart
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tend
operator|=
name|vp
operator|->
name|tstart
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tvma
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|toffs
operator|=
name|sect
operator|->
name|filepos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|vp
operator|->
name|dstart
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|dend
operator|=
name|vp
operator|->
name|dstart
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|dvma
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
comment|/* Silently ignore other types of sections. (FIXME?)  */
block|}
end_function

begin_comment
comment|/* Make a vmap for ABFD which might be a member of the archive ARCH.    Return the new vmap.  */
end_comment

begin_function
name|struct
name|vmap
modifier|*
name|map_vmap
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|arch
decl_stmt|;
block|{
name|struct
name|vmap_and_bfd
name|vmap_bfd
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vmap
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|nxt
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
name|vp
operator|->
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|arch
condition|?
name|arch
else|:
name|abfd
argument_list|)
expr_stmt|;
name|vp
operator|->
name|member
operator|=
name|arch
condition|?
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
else|:
literal|""
expr_stmt|;
name|vmap_bfd
operator|.
name|pbfd
operator|=
name|arch
expr_stmt|;
name|vmap_bfd
operator|.
name|pvmap
operator|=
name|vp
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|bfdsec_to_vmap
argument_list|,
operator|&
name|vmap_bfd
argument_list|)
expr_stmt|;
comment|/* Find the end of the list and append. */
for|for
control|(
name|vpp
operator|=
operator|&
name|vmap
init|;
operator|*
name|vpp
condition|;
name|vpp
operator|=
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|nxt
control|)
empty_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
name|vp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write the exec file.     Args are address within a BFD file, address within gdb address-space,    length, and a flag indicating whether to read or write.     Result is a length:  	0:    We cannot handle this address and length.> 0:  We have handled N bytes starting at this address. 	      (If N == length, we did it all.)  We might be able 	      to handle more bytes beyond this length, but no 	      promises.< 0:  We cannot handle this address, but if somebody 	      else handles (-N) bytes, we can start from there.      The same routine is used to handle both core and exec files;     we just tail-call it with more arguments to select between them.  */
end_comment

begin_function
name|int
name|xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|boolean
name|res
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|nextsectaddr
decl_stmt|,
name|memend
decl_stmt|;
name|boolean
argument_list|(
argument|*xfer_fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
expr_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
block|{
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|memaddr
argument_list|,
name|section
argument_list|)
condition|)
name|memaddr
operator|=
name|overlay_mapped_address
argument_list|(
name|memaddr
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|memend
operator|=
name|memaddr
operator|+
name|len
expr_stmt|;
name|xfer_fn
operator|=
name|write
condition|?
name|bfd_set_section_contents
else|:
name|bfd_get_section_contents
expr_stmt|;
name|nextsectaddr
operator|=
name|memend
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Stu's implementation */
comment|/* If a section has been specified, try to use it.  Note that we cannot use the    specified section directly.  This is because it usually comes from the    symbol file, which may be different from the exec or core file.  Instead, we    have to lookup the specified section by name in the bfd associated with    to_sections.  */
block|if (target_memory_bfd_section)     {       asection *s;       bfd *abfd;       asection *target_section;       bfd *target_bfd;        s = target_memory_bfd_section;       abfd = s->owner;        target_bfd = target->to_sections->bfd;       target_section = bfd_get_section_by_name (target_bfd, bfd_section_name (abfd, s));        if (target_section) 	{ 	  bfd_vma sec_addr; 	  bfd_size_type sec_size;  	  sec_addr = bfd_section_vma (target_bfd, target_section); 	  sec_size = target_section->_raw_size;
comment|/* Make sure the requested memory starts inside the section.  */
block|if (memaddr>= sec_addr&& memaddr< sec_addr + sec_size) 	    {
comment|/* Cut back length in case request overflows the end of the section. */
block|len = min (len, sec_addr + sec_size - memaddr);  	      res = xfer_fn (target_bfd, target_section, myaddr, memaddr - sec_addr, len);  	      return res ? len : 0; 	    } 	}     }
endif|#
directive|endif
comment|/* 0, Stu's implementation */
for|for
control|(
name|p
operator|=
name|target
operator|->
name|to_sections
init|;
name|p
operator|<
name|target
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section
operator|&&
name|p
operator|->
name|the_bfd_section
operator|&&
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* not the section we need */
if|if
condition|(
name|memaddr
operator|>=
name|p
operator|->
name|addr
condition|)
if|if
condition|(
name|memend
operator|<=
name|p
operator|->
name|endaddr
condition|)
block|{
comment|/* Entire transfer is within this section.  */
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
literal|0
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|p
operator|->
name|endaddr
condition|)
block|{
comment|/* This section ends before the transfer starts.  */
continue|continue;
block|}
else|else
block|{
comment|/* This section overlaps the transfer.  Just do half.  */
name|len
operator|=
name|p
operator|->
name|endaddr
operator|-
name|memaddr
expr_stmt|;
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
literal|0
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
else|else
name|nextsectaddr
operator|=
name|min
argument_list|(
name|nextsectaddr
argument_list|,
name|p
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextsectaddr
operator|>=
name|memend
condition|)
return|return
literal|0
return|;
comment|/* We can't help */
else|else
return|return
operator|-
operator|(
name|nextsectaddr
operator|-
name|memaddr
operator|)
return|;
comment|/* Next boundary where we can help */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIXME
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|REG_STACK_SEGMENT
end_ifdef

begin_comment
comment|/* MOVE TO BFD... */
end_comment

begin_comment
comment|/* Pyramids and AM29000s have an extra segment in the virtual address space        for the (control) stack of register-window frames.  The AM29000 folk        call it the "register stack" rather than the "memory stack".  */
end_comment

begin_elseif
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|reg_stack_start
operator|&&
name|memaddr
operator|<
name|reg_stack_end
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|reg_stack_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|reg_stack_start
operator|+
name|reg_stack_offset
expr_stmt|;
name|wanna_xfer
operator|=
name|coredata
expr_stmt|;
block|}
end_elseif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REG_STACK_SEGMENT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIXME */
end_comment

begin_escape
end_escape

begin_function
name|void
name|print_section_info
parameter_list|(
name|t
parameter_list|,
name|abfd
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t`%s', "
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"file type %s.\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tEntry point: "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|t
operator|->
name|to_sections
init|;
name|p
operator|<
name|t
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* FIXME-32x64 need a print_address_numeric with field width */
name|printf_filtered
argument_list|(
literal|"\t%s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|addr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|endaddr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|" @ %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|the_bfd_section
operator|->
name|filepos
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is %s"
argument_list|,
name|bfd_section_name
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bfd
operator|!=
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|p
operator|->
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|print_section_info
argument_list|(
name|t
argument_list|,
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmap
condition|)
block|{
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\tMapping info for file `%s'.\n"
argument_list|,
name|vmap
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\t  %8.8s   %8.8s   %8.8s   %8.8s %8.8s %s\n"
argument_list|,
literal|"tstart"
argument_list|,
literal|"tend"
argument_list|,
literal|"dstart"
argument_list|,
literal|"dend"
argument_list|,
literal|"section"
argument_list|,
literal|"file(member)"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vmap
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
name|printf_unfiltered
argument_list|(
literal|"\t0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x %s%s%s%s\n"
argument_list|,
name|vp
operator|->
name|tstart
argument_list|,
name|vp
operator|->
name|tend
argument_list|,
name|vp
operator|->
name|dstart
argument_list|,
name|vp
operator|->
name|dend
argument_list|,
name|vp
operator|->
name|name
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|"("
else|:
literal|""
argument_list|,
name|vp
operator|->
name|member
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_section_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|unsigned
name|seclen
decl_stmt|;
name|unsigned
name|long
name|secaddr
decl_stmt|;
name|char
name|secprint
index|[
literal|100
index|]
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Must specify section name and its virtual address"
argument_list|)
expr_stmt|;
comment|/* Parse out section name */
for|for
control|(
name|secname
operator|=
name|args
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|;
name|args
operator|++
control|)
empty_stmt|;
name|seclen
operator|=
name|args
operator|-
name|secname
expr_stmt|;
comment|/* Parse out new virtual address */
name|secaddr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|secname
argument_list|,
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|seclen
argument_list|)
operator|&&
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
index|[
name|seclen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|offset
operator|=
name|secaddr
operator|-
name|p
operator|->
name|addr
expr_stmt|;
name|p
operator|->
name|addr
operator|+=
name|offset
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|exec_files_info
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|seclen
operator|>=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
condition|)
name|seclen
operator|=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|secprint
argument_list|,
name|secname
argument_list|,
name|seclen
argument_list|)
expr_stmt|;
name|secprint
index|[
name|seclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Section %s not found"
argument_list|,
name|secprint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls    breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|addr
parameter_list|,
name|contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill in the exec file target vector.  Very few entries need to be    defined.  */
end_comment

begin_function
name|void
name|init_exec_ops
parameter_list|()
block|{
name|exec_ops
operator|.
name|to_shortname
operator|=
literal|"exec"
expr_stmt|;
name|exec_ops
operator|.
name|to_longname
operator|=
literal|"Local exec file"
expr_stmt|;
name|exec_ops
operator|.
name|to_doc
operator|=
literal|"Use an executable file as a target.\n\ Specify the filename of the executable file."
expr_stmt|;
name|exec_ops
operator|.
name|to_open
operator|=
name|exec_file_command
expr_stmt|;
name|exec_ops
operator|.
name|to_close
operator|=
name|exec_close
expr_stmt|;
name|exec_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|exec_ops
operator|.
name|to_require_attach
operator|=
name|find_default_require_attach
expr_stmt|;
name|exec_ops
operator|.
name|to_require_detach
operator|=
name|find_default_require_detach
expr_stmt|;
name|exec_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_memory
expr_stmt|;
name|exec_ops
operator|.
name|to_files_info
operator|=
name|exec_files_info
expr_stmt|;
name|exec_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|exec_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
name|exec_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|exec_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|find_default_clone_and_follow_inferior
expr_stmt|;
name|exec_ops
operator|.
name|to_stratum
operator|=
name|file_stratum
expr_stmt|;
name|exec_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|exec_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_exec
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|init_exec_ops
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dbx_commands
condition|)
block|{
name|c
operator|=
name|add_cmd
argument_list|(
literal|"file"
argument_list|,
name|class_files
argument_list|,
name|file_command
argument_list|,
literal|"Use FILE as program to be debugged.\n\ It is read for its symbols, for getting the contents of pure memory,\n\ and it is the program executed when you use the `run' command.\n\ If FILE cannot be found as specified, your execution directory path\n\ ($PATH) is searched for a command of that name.\n\ No arg means to have no executable file and no symbols."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
block|}
name|c
operator|=
name|add_cmd
argument_list|(
literal|"exec-file"
argument_list|,
name|class_files
argument_list|,
name|exec_file_command
argument_list|,
literal|"Use FILE as program for getting contents of pure memory.\n\ If FILE cannot be found as specified, your execution directory path\n\ is searched for a command of that name.\n\ No arg means have no executable file."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"section"
argument_list|,
name|class_files
argument_list|,
name|set_section_command
argument_list|,
literal|"Change the base address of section SECTION of the exec file to ADDR.\n\ This can be used if the exec file does not contain section addresses,\n\ (such as in the a.out format), or when the addresses specified in the\n\ file itself are wrong.  Each section must be changed separately.  The\n\ ``info files'' command lists all the sections and their addresses."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"write"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_files
argument_list|,
literal|"Set writing into executable and core files."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

