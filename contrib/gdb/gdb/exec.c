begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Work with executable files, for GDB.     Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xcoffsolib.h"
end_include

begin_function_decl
name|struct
name|vmap
modifier|*
name|map_vmap
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|file_changed_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|add_to_section_table
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|sec_ptr
parameter_list|,
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exec_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_section_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exec_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bfdsec_to_vmap
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|sec_ptr
parameter_list|,
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_exec_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_exec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The target vector for executable files.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|exec_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Binary File Descriptor handle for the executable file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|exec_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to open exec and core files read-only or read-write.  */
end_comment

begin_decl_stmt
name|int
name|write_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text start and end addresses (KLUDGE) if needed */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NEED_TEXT_START_END
end_ifndef

begin_define
define|#
directive|define
name|NEED_TEXT_START_END
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|CORE_ADDR
name|text_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|text_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vmap
modifier|*
name|vmap
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|exec_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|exec_file_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|exec_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|int
name|need_symtab_cleanup
init|=
literal|0
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nxt
decl_stmt|;
for|for
control|(
name|nxt
operator|=
name|vmap
init|;
name|nxt
operator|!=
name|NULL
condition|;
control|)
block|{
name|vp
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|vp
operator|->
name|nxt
expr_stmt|;
comment|/* if there is an objfile associated with this bfd,          free_objfile() will do proper cleanup of objfile *and* bfd. */
if|if
condition|(
name|vp
operator|->
name|objfile
condition|)
block|{
name|free_objfile
argument_list|(
name|vp
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|need_symtab_cleanup
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|bfd
operator|!=
name|exec_bfd
condition|)
comment|/* FIXME-leak: We should be freeing vp->name too, I think.  */
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|vp
operator|->
name|bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|vp
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: This routine is #if 0'd in symfile.c.  What should we          be doing here?  Should we just free everything in          vp->objfile->symtabs?  Should free_objfile do that?          FIXME-as-well: free_objfile already free'd vp->name, so it isn't          valid here.  */
name|free_named_symtabs
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vmap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|exec_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|exec_ops
operator|.
name|to_sections
condition|)
block|{
name|xfree
argument_list|(
name|exec_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|exec_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|exec_file_clear
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Remove exec file.  */
name|unpush_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"No executable file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Process the first arg in ARGS as the new exec file.     This function is intended to be behave essentially the same    as exec_file_command, except that the latter will detect when    a target is being debugged, and will ask the user whether it    should be shut down first.  (If the answer is "no", then the    new file is ignored.)     This file is used by exec_file_command, to do the work of opening    and processing the exec file after any prompting has happened.     And, it is used by child_attach, when the attach command was    given a pid but not a exec pathname, and the attach command could    figure out the pathname from the pid.  (In this case, we shouldn't    ask the user whether the current target should be shut down --    we're supplying the exec pathname late for good reason.)        ARGS is assumed to be the filename. */
end_comment

begin_function
name|void
name|exec_file_attach
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Remove any previous exec file.  */
name|unpush_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
operator|!
name|filename
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"No executable file now.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|write_files
condition|?
name|O_RDWR
operator||
name|O_BINARY
else|:
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|exename
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|exename
argument_list|,
name|filename
argument_list|)
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|exename
argument_list|,
name|write_files
condition|?
name|O_RDWR
operator||
name|O_BINARY
else|:
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|error
argument_list|(
literal|"\"%s\": could not open as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At this point, scratch_pathname and exec_bfd->name both point to the          same malloc'd string.  However exec_close() will attempt to free it          via the exec_bfd->name pointer, so we need to make another copy and          leave exec_bfd as the new owner of the original copy. */
name|scratch_pathname
operator|=
name|xstrdup
argument_list|(
name|scratch_pathname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|exec_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* Make sure to close exec_bfd, or else "run" might try to use 	     it.  */
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME - This should only be run for RS6000, but the ifdef is a poor          way to accomplish.  */
ifdef|#
directive|ifdef
name|IBM6000_TARGET
comment|/* Setup initial vmap. */
name|map_vmap
argument_list|(
name|exec_bfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmap
operator|==
name|NULL
condition|)
block|{
comment|/* Make sure to close exec_bfd, or else "run" might try to use 	     it.  */
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't find the file sections: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IBM6000_TARGET */
if|if
condition|(
name|build_section_table
argument_list|(
name|exec_bfd
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
block|{
comment|/* Make sure to close exec_bfd, or else "run" might try to use 	     it.  */
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't find the file sections: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* text_end is sometimes used for where to put call dummies.  A          few ports use these for other purposes too.  */
if|if
condition|(
name|NEED_TEXT_START_END
condition|)
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
comment|/* Set text_start to the lowest address of the start of any 	     readonly code section and set text_end to the highest 	     address of the end of any readonly code section.  */
comment|/* FIXME: The comment above does not match the code.  The 	     code checks for sections with are either code *or* 	     readonly.  */
name|text_start
operator|=
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
name|text_end
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
condition|)
block|{
if|if
condition|(
name|text_start
operator|>
name|p
operator|->
name|addr
condition|)
name|text_start
operator|=
name|p
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|text_end
operator|<
name|p
operator|->
name|endaddr
condition|)
name|text_end
operator|=
name|p
operator|->
name|endaddr
expr_stmt|;
block|}
block|}
name|validate_files
argument_list|()
expr_stmt|;
name|set_gdbarch_from_file
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Process the first arg in ARGS as the new exec file.     Note that we have to explicitly ignore additional args, since we can    be called from file_command(), which also calls symbol_file_command()    which can take multiple args.        If ARGS is NULL, we just want to close the exec file. */
end_comment

begin_function
specifier|static
name|void
name|exec_file_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
comment|/* Scan through the args and pick up the first non option arg          as the filename.  */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|argv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
operator|)
condition|;
name|argv
operator|++
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No executable file name was specified"
argument_list|)
expr_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exec_file_attach
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|exec_file_attach
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set both the exec file and the symbol file, in one command.      What a novelty.  Why did GDB go through four major releases before this    command was added?  */
end_comment

begin_function
specifier|static
name|void
name|file_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME, if we lose on reading the symbol file, we should revert      the exec file, but that's rough.  */
name|exec_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_changed_hook
condition|)
name|file_changed_hook
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Locate all mappable sections of a BFD file.     table_pp_char is a char * to get it through bfd_map_over_sections;    we cast it back to its proper type.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_section_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|,
name|PTR
name|table_pp_char
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
modifier|*
name|table_pp
init|=
operator|(
expr|struct
name|section_table
operator|*
operator|*
operator|)
name|table_pp_char
decl_stmt|;
name|flagword
name|aflag
decl_stmt|;
name|aflag
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aflag
operator|&
name|SEC_ALLOC
operator|)
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
condition|)
return|return;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|the_bfd_section
operator|=
name|asect
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|endaddr
operator|=
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Builds a section table, given args BFD, SECTABLE_PTR, SECEND_PTR.    Returns 0 if OK, 1 on error.  */
end_comment

begin_function
name|int
name|build_section_table
parameter_list|(
name|bfd
modifier|*
name|some_bfd
parameter_list|,
name|struct
name|section_table
modifier|*
modifier|*
name|start
parameter_list|,
name|struct
name|section_table
modifier|*
modifier|*
name|end
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
name|count
operator|=
name|bfd_count_sections
argument_list|(
name|some_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|start
condition|)
name|xfree
argument_list|(
operator|*
name|start
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|*
name|start
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|some_bfd
argument_list|,
name|add_to_section_table
argument_list|,
operator|(
name|char
operator|*
operator|)
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|>
operator|*
name|start
operator|+
name|count
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
comment|/* We could realloc the table, but it probably loses for most files.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|bfdsec_to_vmap
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|sect
parameter_list|,
name|PTR
name|arg3
parameter_list|)
block|{
name|struct
name|vmap_and_bfd
modifier|*
name|vmap_bfd
init|=
operator|(
expr|struct
name|vmap_and_bfd
operator|*
operator|)
name|arg3
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|vmap_bfd
operator|->
name|pvmap
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|STREQ
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|vp
operator|->
name|tstart
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tend
operator|=
name|vp
operator|->
name|tstart
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tvma
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|toffs
operator|=
name|sect
operator|->
name|filepos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|vp
operator|->
name|dstart
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|dend
operator|=
name|vp
operator|->
name|dstart
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|vp
operator|->
name|dvma
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
comment|/* Silently ignore other types of sections. (FIXME?)  */
block|}
end_function

begin_comment
comment|/* Make a vmap for ABFD which might be a member of the archive ARCH.    Return the new vmap.  */
end_comment

begin_function
name|struct
name|vmap
modifier|*
name|map_vmap
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|arch
parameter_list|)
block|{
name|struct
name|vmap_and_bfd
name|vmap_bfd
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vmap
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|nxt
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
name|vp
operator|->
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|arch
condition|?
name|arch
else|:
name|abfd
argument_list|)
expr_stmt|;
name|vp
operator|->
name|member
operator|=
name|arch
condition|?
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
else|:
literal|""
expr_stmt|;
name|vmap_bfd
operator|.
name|pbfd
operator|=
name|arch
expr_stmt|;
name|vmap_bfd
operator|.
name|pvmap
operator|=
name|vp
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|bfdsec_to_vmap
argument_list|,
operator|&
name|vmap_bfd
argument_list|)
expr_stmt|;
comment|/* Find the end of the list and append. */
for|for
control|(
name|vpp
operator|=
operator|&
name|vmap
init|;
operator|*
name|vpp
condition|;
name|vpp
operator|=
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|nxt
control|)
empty_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
name|vp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write the exec file.     Args are address within a BFD file, address within gdb address-space,    length, and a flag indicating whether to read or write.     Result is a length:     0:    We cannot handle this address and length.> 0:  We have handled N bytes starting at this address.    (If N == length, we did it all.)  We might be able    to handle more bytes beyond this length, but no    promises.< 0:  We cannot handle this address, but if somebody    else handles (-N) bytes, we can start from there.     The same routine is used to handle both core and exec files;    we just tail-call it with more arguments to select between them.  */
end_comment

begin_function
name|int
name|xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|boolean
name|res
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|nextsectaddr
decl_stmt|,
name|memend
decl_stmt|;
name|boolean
function_decl|(
modifier|*
name|xfer_fn
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|sec_ptr
parameter_list|,
name|PTR
parameter_list|,
name|file_ptr
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
name|asection
modifier|*
name|section
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
block|{
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|memaddr
argument_list|,
name|section
argument_list|)
condition|)
name|memaddr
operator|=
name|overlay_mapped_address
argument_list|(
name|memaddr
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|memend
operator|=
name|memaddr
operator|+
name|len
expr_stmt|;
name|xfer_fn
operator|=
name|write
condition|?
name|bfd_set_section_contents
else|:
name|bfd_get_section_contents
expr_stmt|;
name|nextsectaddr
operator|=
name|memend
expr_stmt|;
for|for
control|(
name|p
operator|=
name|target
operator|->
name|to_sections
init|;
name|p
operator|<
name|target
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section
operator|&&
name|p
operator|->
name|the_bfd_section
operator|&&
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* not the section we need */
if|if
condition|(
name|memaddr
operator|>=
name|p
operator|->
name|addr
condition|)
if|if
condition|(
name|memend
operator|<=
name|p
operator|->
name|endaddr
condition|)
block|{
comment|/* Entire transfer is within this section.  */
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
literal|0
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|p
operator|->
name|endaddr
condition|)
block|{
comment|/* This section ends before the transfer starts.  */
continue|continue;
block|}
else|else
block|{
comment|/* This section overlaps the transfer.  Just do half.  */
name|len
operator|=
name|p
operator|->
name|endaddr
operator|-
name|memaddr
expr_stmt|;
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
literal|0
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
else|else
name|nextsectaddr
operator|=
name|min
argument_list|(
name|nextsectaddr
argument_list|,
name|p
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextsectaddr
operator|>=
name|memend
condition|)
return|return
literal|0
return|;
comment|/* We can't help */
else|else
return|return
operator|-
operator|(
name|nextsectaddr
operator|-
name|memaddr
operator|)
return|;
comment|/* Next boundary where we can help */
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_section_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t`%s', "
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"file type %s.\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tEntry point: "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|t
operator|->
name|to_sections
init|;
name|p
operator|<
name|t
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* FIXME-32x64 need a print_address_numeric with field width */
name|printf_filtered
argument_list|(
literal|"\t%s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|addr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|endaddr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|" @ %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|the_bfd_section
operator|->
name|filepos
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is %s"
argument_list|,
name|bfd_section_name
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bfd
operator|!=
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|p
operator|->
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
name|print_section_info
argument_list|(
name|t
argument_list|,
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmap
condition|)
block|{
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\tMapping info for file `%s'.\n"
argument_list|,
name|vmap
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\t  %*s   %*s   %*s   %*s %8.8s %s\n"
argument_list|,
name|strlen_paddr
argument_list|()
argument_list|,
literal|"tstart"
argument_list|,
name|strlen_paddr
argument_list|()
argument_list|,
literal|"tend"
argument_list|,
name|strlen_paddr
argument_list|()
argument_list|,
literal|"dstart"
argument_list|,
name|strlen_paddr
argument_list|()
argument_list|,
literal|"dend"
argument_list|,
literal|"section"
argument_list|,
literal|"file(member)"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vmap
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
name|printf_unfiltered
argument_list|(
literal|"\t0x%s 0x%s 0x%s 0x%s %s%s%s%s\n"
argument_list|,
name|paddr
argument_list|(
name|vp
operator|->
name|tstart
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|vp
operator|->
name|tend
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|vp
operator|->
name|dstart
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|vp
operator|->
name|dend
argument_list|)
argument_list|,
name|vp
operator|->
name|name
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|"("
else|:
literal|""
argument_list|,
name|vp
operator|->
name|member
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* msnyder 5/21/99:    exec_set_section_offsets sets the offsets of all the sections    in the exec objfile.  */
end_comment

begin_function
name|void
name|exec_set_section_offsets
parameter_list|(
name|bfd_signed_vma
name|text_off
parameter_list|,
name|bfd_signed_vma
name|data_off
parameter_list|,
name|bfd_signed_vma
name|bss_off
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
name|sect
decl_stmt|;
for|for
control|(
name|sect
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|sect
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|sect
operator|++
control|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|exec_bfd
argument_list|,
name|sect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|sect
operator|->
name|addr
operator|+=
name|text_off
expr_stmt|;
name|sect
operator|->
name|endaddr
operator|+=
name|text_off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
name|sect
operator|->
name|addr
operator|+=
name|data_off
expr_stmt|;
name|sect
operator|->
name|endaddr
operator|+=
name|data_off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_ALLOC
condition|)
block|{
name|sect
operator|->
name|addr
operator|+=
name|bss_off
expr_stmt|;
name|sect
operator|->
name|endaddr
operator|+=
name|bss_off
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_section_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|unsigned
name|seclen
decl_stmt|;
name|unsigned
name|long
name|secaddr
decl_stmt|;
name|char
name|secprint
index|[
literal|100
index|]
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Must specify section name and its virtual address"
argument_list|)
expr_stmt|;
comment|/* Parse out section name */
for|for
control|(
name|secname
operator|=
name|args
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|;
name|args
operator|++
control|)
empty_stmt|;
name|seclen
operator|=
name|args
operator|-
name|secname
expr_stmt|;
comment|/* Parse out new virtual address */
name|secaddr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|secname
argument_list|,
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|seclen
argument_list|)
operator|&&
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|the_bfd_section
argument_list|)
index|[
name|seclen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|offset
operator|=
name|secaddr
operator|-
name|p
operator|->
name|addr
expr_stmt|;
name|p
operator|->
name|addr
operator|+=
name|offset
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|exec_files_info
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|seclen
operator|>=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
condition|)
name|seclen
operator|=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|secprint
argument_list|,
name|secname
argument_list|,
name|seclen
argument_list|)
expr_stmt|;
name|secprint
index|[
name|seclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Section %s not found"
argument_list|,
name|secprint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls    breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find mapped memory. */
end_comment

begin_function
specifier|extern
name|void
name|exec_set_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|exec_ops
operator|.
name|to_find_memory_regions
operator|=
name|func
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|char
modifier|*
name|exec_make_note_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Fill in the exec file target vector.  Very few entries need to be    defined.  */
end_comment

begin_function
specifier|static
name|void
name|init_exec_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|exec_ops
operator|.
name|to_shortname
operator|=
literal|"exec"
expr_stmt|;
name|exec_ops
operator|.
name|to_longname
operator|=
literal|"Local exec file"
expr_stmt|;
name|exec_ops
operator|.
name|to_doc
operator|=
literal|"Use an executable file as a target.\n\ Specify the filename of the executable file."
expr_stmt|;
name|exec_ops
operator|.
name|to_open
operator|=
name|exec_open
expr_stmt|;
name|exec_ops
operator|.
name|to_close
operator|=
name|exec_close
expr_stmt|;
name|exec_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|exec_ops
operator|.
name|to_require_attach
operator|=
name|find_default_require_attach
expr_stmt|;
name|exec_ops
operator|.
name|to_require_detach
operator|=
name|find_default_require_detach
expr_stmt|;
name|exec_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_memory
expr_stmt|;
name|exec_ops
operator|.
name|to_files_info
operator|=
name|exec_files_info
expr_stmt|;
name|exec_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|exec_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
name|exec_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|exec_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|find_default_clone_and_follow_inferior
expr_stmt|;
name|exec_ops
operator|.
name|to_stratum
operator|=
name|file_stratum
expr_stmt|;
name|exec_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|exec_ops
operator|.
name|to_make_corefile_notes
operator|=
name|exec_make_note_section
expr_stmt|;
name|exec_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_exec
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|init_exec_ops
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dbx_commands
condition|)
block|{
name|c
operator|=
name|add_cmd
argument_list|(
literal|"file"
argument_list|,
name|class_files
argument_list|,
name|file_command
argument_list|,
literal|"Use FILE as program to be debugged.\n\ It is read for its symbols, for getting the contents of pure memory,\n\ and it is the program executed when you use the `run' command.\n\ If FILE cannot be found as specified, your execution directory path\n\ ($PATH) is searched for a command of that name.\n\ No arg means to have no executable file and no symbols."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
block|}
name|c
operator|=
name|add_cmd
argument_list|(
literal|"exec-file"
argument_list|,
name|class_files
argument_list|,
name|exec_file_command
argument_list|,
literal|"Use FILE as program for getting contents of pure memory.\n\ If FILE cannot be found as specified, your execution directory path\n\ is searched for a command of that name.\n\ No arg means have no executable file."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"section"
argument_list|,
name|class_files
argument_list|,
name|set_section_command
argument_list|,
literal|"Change the base address of section SECTION of the exec file to ADDR.\n\ This can be used if the exec file does not contain section addresses,\n\ (such as in the a.out format), or when the addresses specified in the\n\ file itself are wrong.  Each section must be changed separately.  The\n\ ``info files'' command lists all the sections and their addresses."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"write"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_files
argument_list|,
literal|"Set writing into executable and core files."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|exec_make_note_section
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|int
modifier|*
name|note_size
parameter_list|)
block|{
name|error
argument_list|(
literal|"Can't create a corefile"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

