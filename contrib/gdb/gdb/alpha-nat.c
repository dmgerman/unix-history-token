begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level Alpha interface, for GDB when running native.    Copyright 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"alpha-tdep.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<asm/reg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/ptrace.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<alpha/coreregs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|fetch_osf_core_registers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetch_elf_core_registers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Extract the register values out of the core file and store    them where `read_register' will find them.     CORE_REG_SECT points to the register values themselves, read into memory.    CORE_REG_SIZE is the size of that area.    WHICH says which set of registers we are handling (0 = int, 2 = float    on machines where they are discontiguous).    REG_ADDR is the offset from u.u_ar0 to the register values relative to    core_reg_sect.  This is used with old-fashioned core files to    locate the registers in a large upage-plus-stack ".reg" section.    Original upage address X is at location core_reg_sect+x+reg_addr.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_osf_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|bad_reg
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Table to map a gdb regnum to an index in the core register      section.  The floating point register values are garbage in      OSF/1.2 core files.  OSF5 uses different names for the register      enum list, need to handle two cases.  The actual values are the      same.  */
specifier|static
name|int
specifier|const
name|core_reg_mapping
index|[
name|ALPHA_NUM_REGS
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|NCF_REGS
define|#
directive|define
name|EFL
value|NCF_REGS
name|CF_V0
block|,
name|CF_T0
block|,
name|CF_T1
block|,
name|CF_T2
block|,
name|CF_T3
block|,
name|CF_T4
block|,
name|CF_T5
block|,
name|CF_T6
block|,
name|CF_T7
block|,
name|CF_S0
block|,
name|CF_S1
block|,
name|CF_S2
block|,
name|CF_S3
block|,
name|CF_S4
block|,
name|CF_S5
block|,
name|CF_S6
block|,
name|CF_A0
block|,
name|CF_A1
block|,
name|CF_A2
block|,
name|CF_A3
block|,
name|CF_A4
block|,
name|CF_A5
block|,
name|CF_T8
block|,
name|CF_T9
block|,
name|CF_T10
block|,
name|CF_T11
block|,
name|CF_RA
block|,
name|CF_T12
block|,
name|CF_AT
block|,
name|CF_GP
block|,
name|CF_SP
block|,
operator|-
literal|1
block|,
name|EFL
operator|+
literal|0
block|,
name|EFL
operator|+
literal|1
block|,
name|EFL
operator|+
literal|2
block|,
name|EFL
operator|+
literal|3
block|,
name|EFL
operator|+
literal|4
block|,
name|EFL
operator|+
literal|5
block|,
name|EFL
operator|+
literal|6
block|,
name|EFL
operator|+
literal|7
block|,
name|EFL
operator|+
literal|8
block|,
name|EFL
operator|+
literal|9
block|,
name|EFL
operator|+
literal|10
block|,
name|EFL
operator|+
literal|11
block|,
name|EFL
operator|+
literal|12
block|,
name|EFL
operator|+
literal|13
block|,
name|EFL
operator|+
literal|14
block|,
name|EFL
operator|+
literal|15
block|,
name|EFL
operator|+
literal|16
block|,
name|EFL
operator|+
literal|17
block|,
name|EFL
operator|+
literal|18
block|,
name|EFL
operator|+
literal|19
block|,
name|EFL
operator|+
literal|20
block|,
name|EFL
operator|+
literal|21
block|,
name|EFL
operator|+
literal|22
block|,
name|EFL
operator|+
literal|23
block|,
name|EFL
operator|+
literal|24
block|,
name|EFL
operator|+
literal|25
block|,
name|EFL
operator|+
literal|26
block|,
name|EFL
operator|+
literal|27
block|,
name|EFL
operator|+
literal|28
block|,
name|EFL
operator|+
literal|29
block|,
name|EFL
operator|+
literal|30
block|,
name|EFL
operator|+
literal|31
block|,
name|CF_PC
block|,
operator|-
literal|1
else|#
directive|else
define|#
directive|define
name|EFL
value|(EF_SIZE / 8)
name|EF_V0
block|,
name|EF_T0
block|,
name|EF_T1
block|,
name|EF_T2
block|,
name|EF_T3
block|,
name|EF_T4
block|,
name|EF_T5
block|,
name|EF_T6
block|,
name|EF_T7
block|,
name|EF_S0
block|,
name|EF_S1
block|,
name|EF_S2
block|,
name|EF_S3
block|,
name|EF_S4
block|,
name|EF_S5
block|,
name|EF_S6
block|,
name|EF_A0
block|,
name|EF_A1
block|,
name|EF_A2
block|,
name|EF_A3
block|,
name|EF_A4
block|,
name|EF_A5
block|,
name|EF_T8
block|,
name|EF_T9
block|,
name|EF_T10
block|,
name|EF_T11
block|,
name|EF_RA
block|,
name|EF_T12
block|,
name|EF_AT
block|,
name|EF_GP
block|,
name|EF_SP
block|,
operator|-
literal|1
block|,
name|EFL
operator|+
literal|0
block|,
name|EFL
operator|+
literal|1
block|,
name|EFL
operator|+
literal|2
block|,
name|EFL
operator|+
literal|3
block|,
name|EFL
operator|+
literal|4
block|,
name|EFL
operator|+
literal|5
block|,
name|EFL
operator|+
literal|6
block|,
name|EFL
operator|+
literal|7
block|,
name|EFL
operator|+
literal|8
block|,
name|EFL
operator|+
literal|9
block|,
name|EFL
operator|+
literal|10
block|,
name|EFL
operator|+
literal|11
block|,
name|EFL
operator|+
literal|12
block|,
name|EFL
operator|+
literal|13
block|,
name|EFL
operator|+
literal|14
block|,
name|EFL
operator|+
literal|15
block|,
name|EFL
operator|+
literal|16
block|,
name|EFL
operator|+
literal|17
block|,
name|EFL
operator|+
literal|18
block|,
name|EFL
operator|+
literal|19
block|,
name|EFL
operator|+
literal|20
block|,
name|EFL
operator|+
literal|21
block|,
name|EFL
operator|+
literal|22
block|,
name|EFL
operator|+
literal|23
block|,
name|EFL
operator|+
literal|24
block|,
name|EFL
operator|+
literal|25
block|,
name|EFL
operator|+
literal|26
block|,
name|EFL
operator|+
literal|27
block|,
name|EFL
operator|+
literal|28
block|,
name|EFL
operator|+
literal|29
block|,
name|EFL
operator|+
literal|30
block|,
name|EFL
operator|+
literal|31
block|,
name|EF_PC
block|,
operator|-
literal|1
endif|#
directive|endif
block|}
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|ALPHA_NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
literal|8
operator|*
name|core_reg_mapping
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
operator|||
name|addr
operator|>=
name|core_reg_size
condition|)
block|{
comment|/* ??? UNIQUE is a new addition.  Don't generate an error.  */
if|if
condition|(
name|regno
operator|==
name|ALPHA_UNIQUE_REGNUM
condition|)
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bad_reg
operator|<
literal|0
condition|)
name|bad_reg
operator|=
name|regno
expr_stmt|;
block|}
else|else
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|core_reg_sect
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad_reg
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Register %s not found in core file."
argument_list|,
name|REGISTER_NAME
argument_list|(
name|bad_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_elf_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
if|if
condition|(
name|core_reg_size
operator|<
literal|32
operator|*
literal|8
condition|)
block|{
name|error
argument_list|(
literal|"Core file register section too small (%u bytes)."
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
comment|/* integer registers */
comment|/* PC is in slot 32; UNIQUE is in slot 33, if present.  */
name|alpha_supply_int_regs
argument_list|(
operator|-
literal|1
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_sect
operator|+
literal|31
operator|*
literal|8
argument_list|,
operator|(
name|core_reg_size
operator|>=
literal|33
operator|*
literal|8
condition|?
name|core_reg_sect
operator|+
literal|32
operator|*
literal|8
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* floating-point registers */
comment|/* FPCR is in slot 32.  */
name|alpha_supply_fp_regs
argument_list|(
operator|-
literal|1
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_sect
operator|+
literal|31
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Map gdb internal register number to a ptrace ``address''.    These ``addresses'' are defined in<sys/ptrace.h>, with    the exception of ALPHA_UNIQUE_PTRACE_ADDR.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ALPHA_UNIQUE_PTRACE_ADDR
end_ifndef

begin_define
define|#
directive|define
name|ALPHA_UNIQUE_PTRACE_ADDR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|CORE_ADDR
name|register_addr
parameter_list|(
name|int
name|regno
parameter_list|,
name|CORE_ADDR
name|blockend
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
return|return
name|PC
return|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_UNIQUE_REGNUM
condition|)
return|return
name|ALPHA_UNIQUE_PTRACE_ADDR
return|;
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
return|return
name|GPR_BASE
operator|+
name|regno
return|;
else|else
return|return
name|FPR_BASE
operator|+
name|regno
operator|-
name|FP0_REGNUM
return|;
block|}
end_function

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROC_FS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GREGSET_T
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* Locate the UNIQUE value within the gregset_t.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ALPHA_REGSET_UNIQUE
end_ifndef

begin_define
define|#
directive|define
name|ALPHA_REGSET_UNIQUE
parameter_list|(
name|ptr
parameter_list|)
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * See the comment in m68k-tdep.c regarding the utility of these functions.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|gregsetp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|unique
init|=
name|ALPHA_REGSET_UNIQUE
argument_list|(
name|gregsetp
argument_list|)
decl_stmt|;
comment|/* PC is in slot 32.  */
name|alpha_supply_int_regs
argument_list|(
operator|-
literal|1
argument_list|,
name|regp
argument_list|,
name|regp
operator|+
literal|31
argument_list|,
name|unique
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|gregsetp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|unique
init|=
name|ALPHA_REGSET_UNIQUE
argument_list|(
name|gregsetp
argument_list|)
decl_stmt|;
comment|/* PC is in slot 32.  */
name|alpha_fill_int_regs
argument_list|(
name|regno
argument_list|,
name|regp
argument_list|,
name|regp
operator|+
literal|31
argument_list|,
name|unique
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Now we do the same thing for floating-point registers.  * Again, see the comments in m68k-tdep.c.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|fpregsetp
argument_list|)
decl_stmt|;
comment|/* FPCR is in slot 32.  */
name|alpha_supply_fp_regs
argument_list|(
operator|-
literal|1
argument_list|,
name|regp
argument_list|,
name|regp
operator|+
literal|31
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|fpregsetp
argument_list|)
decl_stmt|;
comment|/* FPCR is in slot 32.  */
name|alpha_fill_fp_regs
argument_list|(
name|regno
argument_list|,
name|regp
argument_list|,
name|regp
operator|+
literal|31
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle alpha core file formats. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|alpha_osf_core_fns
init|=
block|{
comment|/* This really is bfd_target_unknown_flavour.  */
name|bfd_target_unknown_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_osf_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|alpha_elf_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_elf_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_alpha
parameter_list|(
name|void
parameter_list|)
block|{
name|add_core_fns
argument_list|(
operator|&
name|alpha_osf_core_fns
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|alpha_elf_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

