begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level Alpha interface, for GDB when running native.    Copyright 1993, 1995, 1996, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<asm/reg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/ptrace.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<alpha/coreregs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|fetch_osf_core_registers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetch_elf_core_registers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Size of elements in jmpbuf */
end_comment

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|8
end_define

begin_comment
comment|/* The definition for JB_PC in machine/reg.h is wrong.    And we can't get at the correct definition in setjmp.h as it is    not always available (eg. if _POSIX_SOURCE is defined which is the    default). As the defintion is unlikely to change (see comment    in<setjmp.h>, define the correct value here.  */
end_comment

begin_undef
undef|#
directive|undef
name|JB_PC
end_undef

begin_define
define|#
directive|define
name|JB_PC
value|2
end_define

begin_comment
comment|/* Figure out where the longjmp will land.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|raw_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|raw_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extract the register values out of the core file and store    them where `read_register' will find them.     CORE_REG_SECT points to the register values themselves, read into memory.    CORE_REG_SIZE is the size of that area.    WHICH says which set of registers we are handling (0 = int, 2 = float    on machines where they are discontiguous).    REG_ADDR is the offset from u.u_ar0 to the register values relative to    core_reg_sect.  This is used with old-fashioned core files to    locate the registers in a large upage-plus-stack ".reg" section.    Original upage address X is at location core_reg_sect+x+reg_addr.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_osf_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|;
name|int
name|bad_reg
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Table to map a gdb regnum to an index in the core register      section.  The floating point register values are garbage in      OSF/1.2 core files.  OSF5 uses different names for the register      enum list, need to handle two cases.  The actual values are the      same.  */
specifier|static
name|int
name|core_reg_mapping
index|[
name|NUM_REGS
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|NCF_REGS
define|#
directive|define
name|EFL
value|NCF_REGS
name|CF_V0
block|,
name|CF_T0
block|,
name|CF_T1
block|,
name|CF_T2
block|,
name|CF_T3
block|,
name|CF_T4
block|,
name|CF_T5
block|,
name|CF_T6
block|,
name|CF_T7
block|,
name|CF_S0
block|,
name|CF_S1
block|,
name|CF_S2
block|,
name|CF_S3
block|,
name|CF_S4
block|,
name|CF_S5
block|,
name|CF_S6
block|,
name|CF_A0
block|,
name|CF_A1
block|,
name|CF_A2
block|,
name|CF_A3
block|,
name|CF_A4
block|,
name|CF_A5
block|,
name|CF_T8
block|,
name|CF_T9
block|,
name|CF_T10
block|,
name|CF_T11
block|,
name|CF_RA
block|,
name|CF_T12
block|,
name|CF_AT
block|,
name|CF_GP
block|,
name|CF_SP
block|,
operator|-
literal|1
block|,
name|EFL
operator|+
literal|0
block|,
name|EFL
operator|+
literal|1
block|,
name|EFL
operator|+
literal|2
block|,
name|EFL
operator|+
literal|3
block|,
name|EFL
operator|+
literal|4
block|,
name|EFL
operator|+
literal|5
block|,
name|EFL
operator|+
literal|6
block|,
name|EFL
operator|+
literal|7
block|,
name|EFL
operator|+
literal|8
block|,
name|EFL
operator|+
literal|9
block|,
name|EFL
operator|+
literal|10
block|,
name|EFL
operator|+
literal|11
block|,
name|EFL
operator|+
literal|12
block|,
name|EFL
operator|+
literal|13
block|,
name|EFL
operator|+
literal|14
block|,
name|EFL
operator|+
literal|15
block|,
name|EFL
operator|+
literal|16
block|,
name|EFL
operator|+
literal|17
block|,
name|EFL
operator|+
literal|18
block|,
name|EFL
operator|+
literal|19
block|,
name|EFL
operator|+
literal|20
block|,
name|EFL
operator|+
literal|21
block|,
name|EFL
operator|+
literal|22
block|,
name|EFL
operator|+
literal|23
block|,
name|EFL
operator|+
literal|24
block|,
name|EFL
operator|+
literal|25
block|,
name|EFL
operator|+
literal|26
block|,
name|EFL
operator|+
literal|27
block|,
name|EFL
operator|+
literal|28
block|,
name|EFL
operator|+
literal|29
block|,
name|EFL
operator|+
literal|30
block|,
name|EFL
operator|+
literal|31
block|,
name|CF_PC
block|,
operator|-
literal|1
else|#
directive|else
define|#
directive|define
name|EFL
value|(EF_SIZE / 8)
name|EF_V0
block|,
name|EF_T0
block|,
name|EF_T1
block|,
name|EF_T2
block|,
name|EF_T3
block|,
name|EF_T4
block|,
name|EF_T5
block|,
name|EF_T6
block|,
name|EF_T7
block|,
name|EF_S0
block|,
name|EF_S1
block|,
name|EF_S2
block|,
name|EF_S3
block|,
name|EF_S4
block|,
name|EF_S5
block|,
name|EF_S6
block|,
name|EF_A0
block|,
name|EF_A1
block|,
name|EF_A2
block|,
name|EF_A3
block|,
name|EF_A4
block|,
name|EF_A5
block|,
name|EF_T8
block|,
name|EF_T9
block|,
name|EF_T10
block|,
name|EF_T11
block|,
name|EF_RA
block|,
name|EF_T12
block|,
name|EF_AT
block|,
name|EF_GP
block|,
name|EF_SP
block|,
operator|-
literal|1
block|,
name|EFL
operator|+
literal|0
block|,
name|EFL
operator|+
literal|1
block|,
name|EFL
operator|+
literal|2
block|,
name|EFL
operator|+
literal|3
block|,
name|EFL
operator|+
literal|4
block|,
name|EFL
operator|+
literal|5
block|,
name|EFL
operator|+
literal|6
block|,
name|EFL
operator|+
literal|7
block|,
name|EFL
operator|+
literal|8
block|,
name|EFL
operator|+
literal|9
block|,
name|EFL
operator|+
literal|10
block|,
name|EFL
operator|+
literal|11
block|,
name|EFL
operator|+
literal|12
block|,
name|EFL
operator|+
literal|13
block|,
name|EFL
operator|+
literal|14
block|,
name|EFL
operator|+
literal|15
block|,
name|EFL
operator|+
literal|16
block|,
name|EFL
operator|+
literal|17
block|,
name|EFL
operator|+
literal|18
block|,
name|EFL
operator|+
literal|19
block|,
name|EFL
operator|+
literal|20
block|,
name|EFL
operator|+
literal|21
block|,
name|EFL
operator|+
literal|22
block|,
name|EFL
operator|+
literal|23
block|,
name|EFL
operator|+
literal|24
block|,
name|EFL
operator|+
literal|25
block|,
name|EFL
operator|+
literal|26
block|,
name|EFL
operator|+
literal|27
block|,
name|EFL
operator|+
literal|28
block|,
name|EFL
operator|+
literal|29
block|,
name|EFL
operator|+
literal|30
block|,
name|EFL
operator|+
literal|31
block|,
name|EF_PC
block|,
operator|-
literal|1
endif|#
directive|endif
block|}
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
literal|8
operator|*
name|core_reg_mapping
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
operator|||
name|addr
operator|>=
name|core_reg_size
condition|)
block|{
if|if
condition|(
name|bad_reg
operator|<
literal|0
condition|)
name|bad_reg
operator|=
name|regno
expr_stmt|;
block|}
else|else
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|core_reg_sect
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad_reg
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Register %s not found in core file."
argument_list|,
name|REGISTER_NAME
argument_list|(
name|bad_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_elf_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
if|if
condition|(
name|core_reg_size
operator|<
literal|32
operator|*
literal|8
condition|)
block|{
name|error
argument_list|(
literal|"Core file register section too small (%u bytes)."
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|which
operator|==
literal|2
condition|)
block|{
comment|/* The FPU Registers.  */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|core_reg_sect
argument_list|,
literal|31
operator|*
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|31
argument_list|)
index|]
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|register_valid
index|[
name|FP0_REGNUM
index|]
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The General Registers.  */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|V0_REGNUM
argument_list|)
index|]
argument_list|,
name|core_reg_sect
argument_list|,
literal|31
operator|*
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
name|core_reg_sect
operator|+
literal|31
operator|*
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ZERO_REGNUM
argument_list|)
index|]
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|register_valid
index|[
name|V0_REGNUM
index|]
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|register_valid
index|[
name|PC_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Map gdb internal register number to a ptrace ``address''.    These ``addresses'' are defined in<sys/ptrace.h> */
end_comment

begin_define
define|#
directive|define
name|REGISTER_PTRACE_ADDR
parameter_list|(
name|regno
parameter_list|)
define|\
value|(regno< FP0_REGNUM ? 	GPR_BASE + (regno) \   : regno == PC_REGNUM ?	PC	\   : regno>= FP0_REGNUM ?	FPR_BASE + ((regno) - FP0_REGNUM) \   : 0)
end_define

begin_comment
comment|/* Return the ptrace ``address'' of register REGNO. */
end_comment

begin_function
name|CORE_ADDR
name|register_addr
parameter_list|(
name|int
name|regno
parameter_list|,
name|CORE_ADDR
name|blockend
parameter_list|)
block|{
return|return
name|REGISTER_PTRACE_ADDR
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROC_FS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GREGSET_T
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/*  * See the comment in m68k-tdep.c regarding the utility of these functions.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|gregsetp
argument_list|)
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|31
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|31
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill inaccessible registers with zero.  */
name|supply_register
argument_list|(
name|ZERO_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|gregsetp
argument_list|)
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|31
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
literal|31
operator|)
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Now we do the same thing for floating-point registers.  * Again, see the comments in m68k-tdep.c.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|fpregsetp
argument_list|)
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
operator|+
name|FP0_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|long
modifier|*
name|regp
init|=
name|ALPHA_REGSET_BASE
argument_list|(
name|fpregsetp
argument_list|)
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|regi
operator|-
name|FP0_REGNUM
operator|)
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle alpha core file formats. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|alpha_osf_core_fns
init|=
block|{
comment|/* This really is bfd_target_unknown_flavour.  */
name|bfd_target_unknown_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_osf_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|alpha_elf_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_elf_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_alpha
parameter_list|(
name|void
parameter_list|)
block|{
name|add_core_fns
argument_list|(
operator|&
name|alpha_osf_core_fns
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|alpha_elf_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

