begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interface GDB to Mach 3.0 operating systems.    (Most) Mach 3.0 related routines live in this file.     Copyright (C) 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Author: Jukka Virtanen<jtv@hut.fi>  *	   Computing Centre  *         Helsinki University of Technology  *         Finland  *  * Thanks to my friends who helped with ideas and testing:  *  *	Johannes Helander, Antti Louko, Tero Mononen,  *	jvh@cs.hut.fi	   alo@hut.fi   tmo@cs.hut.fi  *  *      Tero Kivinen       and          Eamonn McManus  *	kivinen@cs.hut.fi               emcmanus@gr.osf.org  *	  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<mach.h>
end_include

begin_include
include|#
directive|include
file|<servers/netname.h>
end_include

begin_include
include|#
directive|include
file|<servers/machid.h>
end_include

begin_include
include|#
directive|include
file|<mach/message.h>
end_include

begin_include
include|#
directive|include
file|<mach/notify.h>
end_include

begin_include
include|#
directive|include
file|<mach_error.h>
end_include

begin_include
include|#
directive|include
file|<mach/exception.h>
end_include

begin_include
include|#
directive|include
file|<mach/vm_attributes.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<servers/machid_lib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MACH_TYPE_TASK
value|1
end_define

begin_define
define|#
directive|define
name|MACH_TYPE_THREAD
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Included only for signal names and NSIG  *  * note: There are many problems in signal handling with  *       gdb in Mach 3.0 in general.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|SIG_UNKNOWN
value|0
end_define

begin_comment
comment|/* Exception that has no matching unix signal */
end_comment

begin_include
include|#
directive|include
file|<cthreads.h>
end_include

begin_comment
comment|/* This is what a cproc looks like.  This is here partly because    cthread_internals.h is not a header we can just #include, partly with    an eye towards perhaps getting this to work with cross-debugging    someday.  Best solution is if CMU publishes a real interface to this    stuff.  */
end_comment

begin_define
define|#
directive|define
name|CPROC_NEXT_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|CPROC_NEXT_SIZE
value|(TARGET_PTR_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_INCARNATION_OFFSET
value|(CPROC_NEXT_OFFSET + CPROC_NEXT_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_INCARNATION_SIZE
value|(sizeof (cthread_t))
end_define

begin_define
define|#
directive|define
name|CPROC_LIST_OFFSET
value|(CPROC_INCARNATION_OFFSET + CPROC_INCARNATION_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_LIST_SIZE
value|(TARGET_PTR_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_WAIT_OFFSET
value|(CPROC_LIST_OFFSET + CPROC_LIST_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_WAIT_SIZE
value|(TARGET_PTR_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_REPLY_OFFSET
value|(CPROC_WAIT_OFFSET + CPROC_WAIT_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_REPLY_SIZE
value|(sizeof (mach_port_t))
end_define

begin_define
define|#
directive|define
name|CPROC_CONTEXT_OFFSET
value|(CPROC_REPLY_OFFSET + CPROC_REPLY_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_CONTEXT_SIZE
value|(TARGET_INT_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_LOCK_OFFSET
value|(CPROC_CONTEXT_OFFSET + CPROC_CONTEXT_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_LOCK_SIZE
value|(sizeof (spin_lock_t))
end_define

begin_define
define|#
directive|define
name|CPROC_STATE_OFFSET
value|(CPROC_LOCK_OFFSET + CPROC_LOCK_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_STATE_SIZE
value|(TARGET_INT_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_WIRED_OFFSET
value|(CPROC_STATE_OFFSET + CPROC_STATE_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_WIRED_SIZE
value|(sizeof (mach_port_t))
end_define

begin_define
define|#
directive|define
name|CPROC_BUSY_OFFSET
value|(CPROC_WIRED_OFFSET + CPROC_WIRED_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_BUSY_SIZE
value|(TARGET_INT_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_MSG_OFFSET
value|(CPROC_BUSY_OFFSET + CPROC_BUSY_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_MSG_SIZE
value|(sizeof (mach_msg_header_t))
end_define

begin_define
define|#
directive|define
name|CPROC_BASE_OFFSET
value|(CPROC_MSG_OFFSET + CPROC_MSG_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_BASE_SIZE
value|(TARGET_INT_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_SIZE_OFFSET
value|(CPROC_BASE_OFFSET + CPROC_BASE_SIZE)
end_define

begin_define
define|#
directive|define
name|CPROC_SIZE_SIZE
value|(TARGET_INT_BIT / HOST_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CPROC_SIZE
value|(CPROC_SIZE_OFFSET + CPROC_SIZE_SIZE)
end_define

begin_comment
comment|/* Values for the state field in the cproc.  */
end_comment

begin_define
define|#
directive|define
name|CPROC_RUNNING
value|0
end_define

begin_define
define|#
directive|define
name|CPROC_SWITCHING
value|1
end_define

begin_define
define|#
directive|define
name|CPROC_BLOCKED
value|2
end_define

begin_define
define|#
directive|define
name|CPROC_CONDWAIT
value|4
end_define

begin_comment
comment|/* For cproc and kernel thread mapping */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gdb_thread
block|{
name|mach_port_t
name|name
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|boolean_t
name|in_emulator
decl_stmt|;
name|int
name|slotid
decl_stmt|;
comment|/* This is for the mthreads list.  It points to the cproc list.      Perhaps the two lists should be merged (or perhaps it was a mistake      to make them both use a struct gdb_thread).  */
name|struct
name|gdb_thread
modifier|*
name|cproc
decl_stmt|;
comment|/* These are for the cproc list, which is linked through the next field      of the struct gdb_thread.  */
name|char
name|raw_cproc
index|[
name|CPROC_SIZE
index|]
decl_stmt|;
comment|/* The cthread which is pointed to by the incarnation field from the      cproc.  This points to the copy we've read into GDB.  */
name|cthread_t
name|cthread
decl_stmt|;
comment|/* Point back to the mthreads list.  */
name|int
name|reverse_map
decl_stmt|;
name|struct
name|gdb_thread
modifier|*
name|next
decl_stmt|;
block|}
typedef|*
name|gdb_thread_t
typedef|;
end_typedef

begin_comment
comment|/*   * Actions for Mach exceptions.  *  * sigmap field maps the exception to corresponding Unix signal.  *  * I do not know how to map the exception to unix signal  * if SIG_UNKNOWN is specified.  */
end_comment

begin_struct
struct|struct
name|exception_list
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|boolean_t
name|forward
decl_stmt|;
name|boolean_t
name|print
decl_stmt|;
name|int
name|sigmap
decl_stmt|;
block|}
name|exception_map
index|[]
init|=
block|{
block|{
literal|"not_mach3_exception"
block|,
name|FALSE
block|,
name|TRUE
block|,
name|SIG_UNKNOWN
block|}
block|,
block|{
literal|"EXC_BAD_ACCESS"
block|,
name|FALSE
block|,
name|TRUE
block|,
name|SIGSEGV
block|}
block|,
block|{
literal|"EXC_BAD_INSTRUCTION"
block|,
name|FALSE
block|,
name|TRUE
block|,
name|SIGILL
block|}
block|,
block|{
literal|"EXC_ARITHMETIC"
block|,
name|FALSE
block|,
name|TRUE
block|,
name|SIGFPE
block|}
block|,
block|{
literal|"EXC_EMULATION"
block|,
name|FALSE
block|,
name|TRUE
block|,
name|SIGEMT
block|}
block|,
comment|/* ??? */
block|{
literal|"EXC_SOFTWARE"
block|,
name|FALSE
block|,
name|TRUE
block|,
name|SIG_UNKNOWN
block|}
block|,
block|{
literal|"EXC_BREAKPOINT"
block|,
name|FALSE
block|,
name|FALSE
block|,
name|SIGTRAP
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Mach exception table size */
end_comment

begin_decl_stmt
name|int
name|max_exception
init|=
sizeof|sizeof
argument_list|(
name|exception_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|exception_list
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_EXCEPTION
value|max_exception
end_define

begin_decl_stmt
name|WAITTYPE
name|wait_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If you define this, intercepted bsd server calls will be  * dumped while waiting the inferior to EXEC the correct  * program  */
end_comment

begin_comment
comment|/* #define DUMP_SYSCALL		/* debugging interceptor */
end_comment

begin_comment
comment|/* xx_debug() outputs messages if this is nonzero.  * If> 1, DUMP_SYSCALL will dump message contents.  */
end_comment

begin_decl_stmt
name|int
name|debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "Temporary" debug stuff */
end_comment

begin_function
name|void
name|xx_debug
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|warning
argument_list|(
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is in libmach.a */
end_comment

begin_decl_stmt
specifier|extern
name|mach_port_t
name|name_server_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set in catch_exception_raise */
end_comment

begin_decl_stmt
name|int
name|stop_exception
decl_stmt|,
name|stop_code
decl_stmt|,
name|stop_subcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopped_in_exception
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread that was the active thread when we stopped */
end_comment

begin_decl_stmt
name|thread_t
name|stop_thread
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when task is attached or created */
end_comment

begin_decl_stmt
name|boolean_t
name|emulator_present
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|task_t
name|inferior_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|thread_t
name|current_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exception ports for inferior task */
end_comment

begin_decl_stmt
name|mach_port_t
name|inferior_exception_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mach_port_t
name|inferior_old_exception_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* task exceptions and notifications */
end_comment

begin_decl_stmt
name|mach_port_t
name|inferior_wait_port_set
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mach_port_t
name|our_notify_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is "inferior_wait_port_set" when not single stepping, and  *         "singlestepped_thread_port" when we are single stepping.  *   * This is protected by a cleanup function: discard_single_step()  */
end_comment

begin_decl_stmt
name|mach_port_t
name|currently_waiting_for
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A port for external messages to gdb.  * External in the meaning that they do not come  * from the inferior_task, but rather from external  * tasks.  *  * As a debugging feature:  * A debugger debugging another debugger can stop the  * inferior debugger by the following command sequence  * (without running external programs)  *  *    (top-gdb) set stop_inferior_gdb ()  *    (top-gdb) continue  */
end_comment

begin_decl_stmt
name|mach_port_t
name|our_message_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For single stepping */
end_comment

begin_decl_stmt
name|mach_port_t
name|thread_exception_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mach_port_t
name|thread_saved_exception_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mach_port_t
name|singlestepped_thread_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For machid calls */
end_comment

begin_decl_stmt
name|mach_port_t
name|mid_server
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mach_port_t
name|mid_auth
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If gdb thinks the inferior task is not suspended, it  * must take suspend/abort the threads when it reads the state.  */
end_comment

begin_decl_stmt
name|int
name|must_suspend_thread
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When single stepping, we switch the port that mach_really_wait() listens to.  * This cleanup is a guard to prevent the port set from being left to  * the singlestepped_thread_port when error() is called.  *  This is nonzero only when we are single stepping.  */
end_comment

begin_define
define|#
directive|define
name|NULL_CLEANUP
value|(struct cleanup *)0
end_define

begin_decl_stmt
name|struct
name|cleanup
modifier|*
name|cleanup_step
init|=
name|NULL_CLEANUP
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|m3_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|m3_kill_inferior
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|MACH_TYPE_EXCEPTION_PORT
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain of ports to remember requested notifications. */
end_comment

begin_struct
struct|struct
name|port_chain
block|{
name|struct
name|port_chain
modifier|*
name|next
decl_stmt|;
name|mach_port_t
name|port
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|mid
decl_stmt|;
comment|/* Now only valid with MACH_TYPE_THREAD and */
comment|/*  MACH_TYPE_THREAD */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|port_chain
modifier|*
name|port_chain_t
typedef|;
end_typedef

begin_comment
comment|/* Room for chain nodes comes from pchain_obstack */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|pchain_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|port_chain_obstack
init|=
operator|&
name|pchain_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For thread handling */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|Cproc_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|cproc_obstack
init|=
operator|&
name|Cproc_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the list of notified ports */
end_comment

begin_decl_stmt
name|port_chain_t
name|notify_chain
init|=
operator|(
name|port_chain_t
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|port_chain_t
name|port_chain_insert
parameter_list|(
name|list
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|port_chain_t
name|list
decl_stmt|;
name|mach_port_t
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|port_chain_t
name|new
decl_stmt|;
name|int
name|mid
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|list
return|;
if|if
condition|(
name|type
operator|==
name|MACH_TYPE_TASK
operator|||
name|type
operator|==
name|MACH_TYPE_THREAD
condition|)
block|{
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|mid_server
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Machid server port invalid, can not map port 0x%x to MID"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mid
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|machid_mach_register
argument_list|(
name|mid_server
argument_list|,
name|mid_auth
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
operator|&
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Can not map name (0x%x) to MID with machid"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mid
operator|=
name|name
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
operator|(
name|port_chain_t
operator|)
name|obstack_alloc
argument_list|(
name|port_chain_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|port_chain
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|new
operator|->
name|port
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|mid
operator|=
name|mid
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|port_chain_t
name|port_chain_delete
parameter_list|(
name|list
parameter_list|,
name|elem
parameter_list|)
name|port_chain_t
name|list
decl_stmt|;
name|mach_port_t
name|elem
decl_stmt|;
block|{
if|if
condition|(
name|list
condition|)
if|if
condition|(
name|list
operator|->
name|port
operator|==
name|elem
condition|)
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
else|else
while|while
condition|(
name|list
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|next
operator|->
name|port
operator|==
name|elem
condition|)
name|list
operator|->
name|next
operator|=
name|list
operator|->
name|next
operator|->
name|next
expr_stmt|;
comment|/* GCd with obstack_free() */
else|else
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
name|port_chain_destroy
parameter_list|(
name|ostack
parameter_list|)
name|struct
name|obstack
modifier|*
name|ostack
decl_stmt|;
block|{
name|obstack_free
argument_list|(
name|ostack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|ostack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|port_chain_t
name|port_chain_member
parameter_list|(
name|list
parameter_list|,
name|elem
parameter_list|)
name|port_chain_t
name|list
decl_stmt|;
name|mach_port_t
name|elem
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|port
operator|==
name|elem
condition|)
return|return
name|list
return|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|port_chain_t
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|map_port_name_to_mid
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|mach_port_t
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|port_chain_t
name|elem
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|elem
operator|=
name|port_chain_member
argument_list|(
name|notify_chain
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|&&
operator|(
name|elem
operator|->
name|type
operator|==
name|type
operator|)
condition|)
return|return
name|elem
operator|->
name|mid
return|;
if|if
condition|(
name|elem
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|mid_server
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Machid server port invalid, can not map port 0x%x to mid"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|int
name|mid
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|ret
operator|=
name|machid_mach_register
argument_list|(
name|mid_server
argument_list|,
name|mid_auth
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
operator|&
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Can not map name (0x%x) to mid with machid"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mid
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Guard for currently_waiting_for and singlestepped_thread_port */
end_comment

begin_function
specifier|static
name|void
name|discard_single_step
parameter_list|(
name|thread
parameter_list|)
name|thread_t
name|thread
decl_stmt|;
block|{
name|currently_waiting_for
operator|=
name|inferior_wait_port_set
expr_stmt|;
name|cleanup_step
operator|=
name|NULL_CLEANUP
expr_stmt|;
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|thread
argument_list|)
operator|&&
name|MACH_PORT_VALID
argument_list|(
name|singlestepped_thread_port
argument_list|)
condition|)
name|setup_single_step
argument_list|(
name|thread
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|setup_single_step
argument_list|(
argument|thread
argument_list|,
argument|start_step
argument_list|)
end_macro

begin_decl_stmt
name|thread_t
name|thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|start_step
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|thread
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid thread supplied to setup_single_step"
argument_list|)
expr_stmt|;
else|else
block|{
name|mach_port_t
name|teport
decl_stmt|;
comment|/* Get the current thread exception port */
name|ret
operator|=
name|thread_get_exception_port
argument_list|(
name|thread
argument_list|,
operator|&
name|teport
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Getting thread's exception port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_step
condition|)
block|{
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|singlestepped_thread_port
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Singlestepped_thread_port (0x%x) is still valid?"
argument_list|,
name|singlestepped_thread_port
argument_list|)
expr_stmt|;
name|singlestepped_thread_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
comment|/* If we are already stepping this thread */
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|teport
argument_list|)
operator|&&
name|teport
operator|==
name|thread_exception_port
condition|)
block|{
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|teport
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Could not deallocate thread exception port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|thread_set_exception_port
argument_list|(
name|thread
argument_list|,
name|thread_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Setting exception port for thread"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Insert thread exception port to wait port set */
block|ret = mach_port_move_member (mach_task_self(),  					   thread_exception_port, 					   inferior_wait_port_set); 	      CHK ("Moving thread exception port to inferior_wait_port_set", 		   ret);
endif|#
directive|endif
name|thread_saved_exception_port
operator|=
name|teport
expr_stmt|;
block|}
name|thread_trace
argument_list|(
name|thread
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|singlestepped_thread_port
operator|=
name|thread_exception_port
expr_stmt|;
name|currently_waiting_for
operator|=
name|singlestepped_thread_port
expr_stmt|;
name|cleanup_step
operator|=
name|make_cleanup
argument_list|(
name|discard_single_step
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|teport
argument_list|)
condition|)
name|error
argument_list|(
literal|"Single stepped thread had an invalid exception port?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|teport
operator|!=
name|thread_exception_port
condition|)
name|error
argument_list|(
literal|"Single stepped thread had an unknown exception port?"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|teport
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Couldn't deallocate thread exception port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Remove thread exception port from wait port set */
block|ret = mach_port_move_member (mach_task_self(),  				       thread_exception_port, 				       MACH_PORT_NULL); 	  CHK ("Removing thread exception port from inferior_wait_port_set", 	       ret);
endif|#
directive|endif
comment|/* Restore thread's old exception port */
name|ret
operator|=
name|thread_set_exception_port
argument_list|(
name|thread
argument_list|,
name|thread_saved_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Restoring stepped thread's exception port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|thread_saved_exception_port
argument_list|)
condition|)
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread_saved_exception_port
argument_list|)
expr_stmt|;
name|thread_trace
argument_list|(
name|thread
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|singlestepped_thread_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|currently_waiting_for
operator|=
name|inferior_wait_port_set
expr_stmt|;
if|if
condition|(
name|cleanup_step
condition|)
name|discard_cleanups
argument_list|(
name|cleanup_step
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|request_notify
argument_list|(
argument|name
argument_list|,
argument|variant
argument_list|,
argument|type
argument_list|)
name|mach_port_t
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|mach_msg_id_t
name|variant
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|mach_port_t
name|previous_port_dummy
init|=
name|MACH_PORT_NULL
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
name|port_chain_member
argument_list|(
name|notify_chain
argument_list|,
name|name
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|mach_port_request_notification
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|name
argument_list|,
name|variant
argument_list|,
literal|1
argument_list|,
name|our_notify_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND_ONCE
argument_list|,
operator|&
name|previous_port_dummy
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Serious: request_notify failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|previous_port_dummy
argument_list|)
expr_stmt|;
name|notify_chain
operator|=
name|port_chain_insert
argument_list|(
name|notify_chain
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|reverse_msg_bits
argument_list|(
argument|msgp
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|mach_msg_header_t
modifier|*
name|msgp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rbits
decl_stmt|,
name|lbits
decl_stmt|;
name|rbits
operator|=
name|MACH_MSGH_BITS_REMOTE
argument_list|(
name|msgp
operator|->
name|msgh_bits
argument_list|)
expr_stmt|;
name|lbits
operator|=
name|type
expr_stmt|;
name|msgp
operator|->
name|msgh_bits
operator|=
operator|(
name|msgp
operator|->
name|msgh_bits
operator|&
operator|~
name|MACH_MSGH_BITS_PORTS_MASK
operator|)
operator||
name|MACH_MSGH_BITS
argument_list|(
name|lbits
argument_list|,
name|rbits
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* On the third day He said:     	Let this be global 	and then it was global.     When creating the inferior fork, the    child code in inflow.c sets the name of the    bootstrap_port in its address space to this    variable.     The name is transferred to our address space    with mach3_read_inferior().     Thou shalt not do this with    task_get_bootstrap_port() in this task, since    the name in the inferior task is different than    the one we get.     For blessed are the meek, as they shall inherit    the address space.  */
end_comment

begin_decl_stmt
name|mach_port_t
name|original_server_port_name
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called from inferior after FORK but before EXEC */
end_comment

begin_function
specifier|static
name|void
name|m3_trace_me
parameter_list|()
block|{
name|kern_return_t
name|ret
decl_stmt|;
comment|/* Get the NAME of the bootstrap port in this task      so that GDB can read it */
name|ret
operator|=
name|task_get_bootstrap_port
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|&
name|original_server_port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|original_server_port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Suspend this task to let the parent change my ports.      Resumed by the debugger */
name|ret
operator|=
name|task_suspend
argument_list|(
name|mach_task_self
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Intercept system calls to Unix server.  * After EXEC_COUNTER calls to exec(), return.  *  * Pre-assertion:  Child is suspended. (Not verified)  * Post-condition: Child is suspended after EXEC_COUNTER exec() calls.  */
end_comment

begin_function
name|void
name|intercept_exec_calls
parameter_list|(
name|exec_counter
parameter_list|)
name|int
name|exec_counter
decl_stmt|;
block|{
name|int
name|terminal_initted
init|=
literal|0
decl_stmt|;
struct|struct
name|syscall_msg_t
block|{
name|mach_msg_header_t
name|header
decl_stmt|;
name|mach_msg_type_t
name|type
decl_stmt|;
name|char
name|room
index|[
literal|2000
index|]
decl_stmt|;
comment|/* Enuff space */
block|}
struct|;
name|struct
name|syscall_msg_t
name|syscall_in
decl_stmt|,
name|syscall_out
decl_stmt|;
name|mach_port_t
name|fake_server
decl_stmt|;
name|mach_port_t
name|original_server_send
decl_stmt|;
name|mach_port_t
name|original_exec_reply
decl_stmt|;
name|mach_port_t
name|exec_reply
decl_stmt|;
name|mach_port_t
name|exec_reply_send
decl_stmt|;
name|mach_msg_type_name_t
name|acquired
decl_stmt|;
name|mach_port_t
name|emulator_server_port_name
decl_stmt|;
name|struct
name|task_basic_info
name|info
decl_stmt|;
name|mach_msg_type_number_t
name|info_count
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
name|exec_counter
operator|<=
literal|0
condition|)
return|return;
comment|/* We are already set up in the correct program */
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|fake_server
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"create inferior_fake_server port failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Wait for inferior_task to suspend itself */
while|while
condition|(
literal|1
condition|)
block|{
name|info_count
operator|=
sizeof|sizeof
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_info
argument_list|(
name|inferior_task
argument_list|,
name|TASK_BASIC_INFO
argument_list|,
operator|(
name|task_info_t
operator|)
operator|&
name|info
argument_list|,
operator|&
name|info_count
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Task info"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|suspend_count
condition|)
break|break;
comment|/* Note that the definition of the parameter was undefined        * at the time of this writing, so I just use an `ad hoc' value.        */
operator|(
name|void
operator|)
name|swtch_pri
argument_list|(
literal|42
argument_list|)
expr_stmt|;
comment|/* Universal Priority Value */
block|}
comment|/* Read the inferior's bootstrap port name */
if|if
condition|(
operator|!
name|mach3_read_inferior
argument_list|(
operator|&
name|original_server_port_name
argument_list|,
operator|&
name|original_server_port_name
argument_list|,
sizeof|sizeof
argument_list|(
name|original_server_port_name
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read inferior task bootstrap port name"
argument_list|)
expr_stmt|;
comment|/* @@ BUG: If more than 1 send right GDB will FAIL!!! */
comment|/*      Should get refs, and set them back when restoring */
comment|/* Steal the original bsd server send right from inferior */
name|ret
operator|=
name|mach_port_extract_right
argument_list|(
name|inferior_task
argument_list|,
name|original_server_port_name
argument_list|,
name|MACH_MSG_TYPE_MOVE_SEND
argument_list|,
operator|&
name|original_server_send
argument_list|,
operator|&
name|acquired
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_extract_right (bsd server send)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|acquired
operator|!=
name|MACH_MSG_TYPE_PORT_SEND
condition|)
name|error
argument_list|(
literal|"Incorrect right extracted, send right to bsd server excpected"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_insert_right
argument_list|(
name|inferior_task
argument_list|,
name|original_server_port_name
argument_list|,
name|fake_server
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_insert_right (fake server send)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|xx_debug
argument_list|(
literal|"inferior task bsd server ports set up \nfs %x, ospn %x, oss %x\n"
argument_list|,
name|fake_server
argument_list|,
name|original_server_port_name
argument_list|,
name|original_server_send
argument_list|)
expr_stmt|;
comment|/* A receive right to the reply generated by unix server exec() request */
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|exec_reply
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"create intercepted_reply_port port failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Pass this send right to Unix server so it replies to us after exec() */
name|ret
operator|=
name|mach_port_extract_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|exec_reply
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND_ONCE
argument_list|,
operator|&
name|exec_reply_send
argument_list|,
operator|&
name|acquired
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_extract_right (exec_reply)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|acquired
operator|!=
name|MACH_MSG_TYPE_PORT_SEND_ONCE
condition|)
name|error
argument_list|(
literal|"Incorrect right extracted, send once excpected for exec reply"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|fake_server
argument_list|,
name|inferior_wait_port_set
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Moving fake syscall port to inferior_wait_port_set"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|xx_debug
argument_list|(
literal|"syscall fake server set up, resuming inferior\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_resume
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_resume (startup)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Read requests from the inferior.      Pass directly through everything else except exec() calls.    */
while|while
condition|(
name|exec_counter
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|mach_msg
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|,
comment|/* header */
name|MACH_RCV_MSG
argument_list|,
comment|/* options */
literal|0
argument_list|,
comment|/* send size */
sizeof|sizeof
argument_list|(
expr|struct
name|syscall_msg_t
argument_list|)
argument_list|,
comment|/* receive size */
name|inferior_wait_port_set
argument_list|,
comment|/* receive_name */
name|MACH_MSG_TIMEOUT_NONE
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_msg (intercepted sycall)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_SYSCALL
name|print_msg
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASSERT : msgh_local_port == fake_server */
if|if
condition|(
name|notify_server
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|,
operator|&
name|syscall_out
operator|.
name|header
argument_list|)
condition|)
name|error
argument_list|(
literal|"received a notify while intercepting syscalls"
argument_list|)
expr_stmt|;
if|if
condition|(
name|syscall_in
operator|.
name|header
operator|.
name|msgh_id
operator|==
name|MIG_EXEC_SYSCALL_ID
condition|)
block|{
name|xx_debug
argument_list|(
literal|"Received EXEC SYSCALL, counter = %d\n"
argument_list|,
name|exec_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_counter
operator|==
literal|1
condition|)
block|{
name|original_exec_reply
operator|=
name|syscall_in
operator|.
name|header
operator|.
name|msgh_remote_port
expr_stmt|;
name|syscall_in
operator|.
name|header
operator|.
name|msgh_remote_port
operator|=
name|exec_reply_send
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|terminal_initted
condition|)
block|{
comment|/* Now that the child has exec'd we know it has already set its 		 process group.  On POSIX systems, tcsetpgrp will fail with 		 EPERM if we try it before the child's setpgid.  */
comment|/* Set up the "saved terminal modes" of the inferior 		 based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|1
expr_stmt|;
block|}
name|exec_counter
operator|--
expr_stmt|;
block|}
name|syscall_in
operator|.
name|header
operator|.
name|msgh_local_port
operator|=
name|syscall_in
operator|.
name|header
operator|.
name|msgh_remote_port
expr_stmt|;
name|syscall_in
operator|.
name|header
operator|.
name|msgh_remote_port
operator|=
name|original_server_send
expr_stmt|;
name|reverse_msg_bits
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|,
name|MACH_MSG_TYPE_COPY_SEND
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_msg_send
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Forwarded syscall"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|fake_server
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Moving fake syscall out of inferior_wait_port_set"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|exec_reply
argument_list|,
name|inferior_wait_port_set
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Moving exec_reply to inferior_wait_port_set"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_msg
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|,
comment|/* header */
name|MACH_RCV_MSG
argument_list|,
comment|/* options */
literal|0
argument_list|,
comment|/* send size */
sizeof|sizeof
argument_list|(
expr|struct
name|syscall_msg_t
argument_list|)
argument_list|,
comment|/* receive size */
name|inferior_wait_port_set
argument_list|,
comment|/* receive_name */
name|MACH_MSG_TIMEOUT_NONE
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_msg (exec reply)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_suspend
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Suspending inferior after last exec"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|must_suspend_thread
operator|=
literal|0
expr_stmt|;
name|xx_debug
argument_list|(
literal|"Received exec reply from bsd server, suspended inferior task\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_SYSCALL
name|print_msg
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Message should appear as if it came from the unix server */
name|syscall_in
operator|.
name|header
operator|.
name|msgh_local_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
comment|/*  and go to the inferior task original reply port */
name|syscall_in
operator|.
name|header
operator|.
name|msgh_remote_port
operator|=
name|original_exec_reply
expr_stmt|;
name|reverse_msg_bits
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|,
name|MACH_MSG_TYPE_MOVE_SEND_ONCE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_msg_send
argument_list|(
operator|&
name|syscall_in
operator|.
name|header
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Forwarding exec reply to inferior"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Garbage collect */
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|inferior_task
argument_list|,
name|original_server_port_name
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"deallocating fake server send right"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_insert_right
argument_list|(
name|inferior_task
argument_list|,
name|original_server_port_name
argument_list|,
name|original_server_send
argument_list|,
name|MACH_MSG_TYPE_MOVE_SEND
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Restoring the original bsd server send right"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|fake_server
argument_list|)
expr_stmt|;
name|fake_server
operator|=
name|MACH_PORT_DEAD
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_destroy (fake_server)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|exec_reply
argument_list|)
expr_stmt|;
name|exec_reply
operator|=
name|MACH_PORT_DEAD
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_destroy (exec_reply)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|xx_debug
argument_list|(
literal|"Done with exec call interception\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|consume_send_rights
parameter_list|(
name|thread_list
parameter_list|,
name|thread_count
parameter_list|)
name|thread_array_t
name|thread_list
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|thread_count
condition|)
return|return;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
comment|/* Since thread kill command kills threads, don't check ret */
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread_list
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* suspend/abort/resume a thread. */
end_comment

begin_macro
name|setup_thread
argument_list|(
argument|thread
argument_list|,
argument|what
argument_list|)
end_macro

begin_decl_stmt
name|mach_port_t
name|thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
name|what
condition|)
block|{
name|ret
operator|=
name|thread_suspend
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"setup_thread thread_suspend"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_abort
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"setup_thread thread_abort"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|thread_resume
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"setup_thread thread_resume"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|map_slot_to_mid
parameter_list|(
name|slot
parameter_list|,
name|threads
parameter_list|,
name|thread_count
parameter_list|)
name|int
name|slot
decl_stmt|;
name|thread_array_t
name|threads
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|deallocate
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|mid
decl_stmt|;
if|if
condition|(
operator|!
name|threads
condition|)
block|{
name|deallocate
operator|++
expr_stmt|;
name|ret
operator|=
name|task_threads
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|threads
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Can not select a thread from a dead task"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
operator|||
name|slot
operator|>=
name|thread_count
condition|)
block|{
if|if
condition|(
name|deallocate
condition|)
block|{
name|consume_send_rights
argument_list|(
name|threads
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|threads
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"invalid slot number"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
operator|(
name|slot
operator|+
literal|1
operator|)
return|;
block|}
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|threads
index|[
name|slot
index|]
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|deallocate
condition|)
block|{
name|consume_send_rights
argument_list|(
name|threads
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|threads
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_thread_id
parameter_list|(
name|arg
parameter_list|,
name|thread_count
parameter_list|,
name|slots
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
name|int
name|slots
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|arg
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|' '
operator|||
operator|*
name|arg
operator|==
literal|'\t'
operator|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg
condition|)
return|return
literal|0
return|;
comment|/* Currently parse MID and @SLOTNUMBER */
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'@'
condition|)
block|{
name|mid
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"valid thread mid expected"
argument_list|)
expr_stmt|;
return|return
name|mid
return|;
block|}
name|arg
operator|++
expr_stmt|;
name|slot
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"invalid slot number"
argument_list|)
expr_stmt|;
comment|/* If you want slot numbers to remain slot numbers, set slots.    *    * Well, since 0 is reserved, return the ordinal number    * of the thread rather than the slot number. Awk, this    * counts as a kludge.    */
if|if
condition|(
name|slots
condition|)
return|return
operator|-
operator|(
name|slot
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|thread_count
operator|&&
name|slot
operator|>=
name|thread_count
condition|)
return|return
operator|-
operator|(
name|slot
operator|+
literal|1
operator|)
return|;
name|mid
operator|=
name|map_slot_to_mid
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
name|mid
return|;
block|}
end_function

begin_comment
comment|/* THREAD_ID 0 is special; it selects the first kernel  * thread from the list (i.e. SLOTNUMBER 0)  * This is used when starting the program with 'run' or when attaching.  *  * If FLAG is 0 the context is not changed, and the registers, frame, etc  * will continue to describe the old thread.  *  * If FLAG is nonzero, really select the thread.  * If FLAG is 2, the THREAD_ID is a slotnumber instead of a mid.  *   */
end_comment

begin_function
name|kern_return_t
name|select_thread
parameter_list|(
name|task
parameter_list|,
name|thread_id
parameter_list|,
name|flag
parameter_list|)
name|mach_port_t
name|task
decl_stmt|;
name|int
name|thread_id
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|thread_array_t
name|thread_list
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|index
decl_stmt|;
name|thread_t
name|new_thread
init|=
name|MACH_PORT_NULL
decl_stmt|;
if|if
condition|(
name|thread_id
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't select cprocs without kernel thread"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_threads
argument_list|(
name|task
argument_list|,
operator|&
name|thread_list
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Can not select a thread from a dead task"
argument_list|)
expr_stmt|;
name|m3_kill_inferior
argument_list|()
expr_stmt|;
return|return
name|KERN_FAILURE
return|;
block|}
if|if
condition|(
name|thread_count
operator|==
literal|0
condition|)
block|{
comment|/* The task can not do anything anymore, but it still        * exists as a container for memory and ports.        */
name|registers_changed
argument_list|()
expr_stmt|;
name|warning
argument_list|(
literal|"Task %d has no threads"
argument_list|,
name|map_port_name_to_mid
argument_list|(
name|task
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|KERN_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|thread_id
operator|||
name|flag
operator|==
literal|2
condition|)
block|{
comment|/* First thread or a slotnumber */
if|if
condition|(
operator|!
name|thread_id
condition|)
name|new_thread
operator|=
name|thread_list
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|thread_id
operator|<
name|thread_count
condition|)
name|new_thread
operator|=
name|thread_list
index|[
name|thread_id
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No such thread slot number : %d"
argument_list|,
name|thread_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|thread_id
operator|==
name|map_port_name_to_mid
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
condition|)
block|{
name|new_thread
operator|=
name|thread_list
index|[
name|index
index|]
expr_stmt|;
name|index
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"No thread with mid %d"
argument_list|,
name|thread_id
argument_list|)
expr_stmt|;
block|}
comment|/* Notify when the selected thread dies */
name|request_notify
argument_list|(
name|new_thread
argument_list|,
name|MACH_NOTIFY_DEAD_NAME
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"vm_deallocate"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
name|current_thread
operator|=
name|new_thread
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
block|if (MACH_PORT_VALID (current_thread)) 	{
comment|/* Store the gdb's view of the thread we are deselecting 	   * 	   * @@ I think gdb updates registers immediately when they are 	   * changed, so don't do this. 	   */
block|ret = thread_abort (current_thread); 	  CHK ("Could not abort system calls when saving state of old thread", 	       ret); 	  target_prepare_to_store (); 	  target_store_registers (-1); 	}
endif|#
directive|endif
name|registers_changed
argument_list|()
expr_stmt|;
name|current_thread
operator|=
name|new_thread
expr_stmt|;
name|ret
operator|=
name|thread_abort
argument_list|(
name|current_thread
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Could not abort system calls when selecting a thread"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Switch to use thread named NEW_THREAD.  * Return it's MID  */
end_comment

begin_function
name|int
name|switch_to_thread
parameter_list|(
name|new_thread
parameter_list|)
name|thread_t
name|new_thread
decl_stmt|;
block|{
name|thread_t
name|saved_thread
init|=
name|current_thread
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|new_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Can't map thread name 0x%x to mid"
argument_list|,
name|new_thread
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
name|mid
argument_list|,
literal|1
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|current_thread
condition|)
name|current_thread
operator|=
name|saved_thread
expr_stmt|;
name|error
argument_list|(
literal|"Could not select thread %d"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
block|}
return|return
name|mid
return|;
block|}
end_function

begin_comment
comment|/* Do this in gdb after doing FORK but before STARTUP_INFERIOR.  * Note that the registers are not yet valid in the inferior task.  */
end_comment

begin_function
specifier|static
name|void
name|m3_trace_him
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|push_target
argument_list|(
operator|&
name|m3_ops
argument_list|)
expr_stmt|;
name|inferior_task
operator|=
name|task_by_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|inferior_task
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can not map Unix pid %d to Mach task"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
comment|/* Clean up previous notifications and create new ones */
name|setup_notify_port
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* When notification appears, the inferior task has died */
name|request_notify
argument_list|(
name|inferior_task
argument_list|,
name|MACH_NOTIFY_DEAD_NAME
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
expr_stmt|;
name|emulator_present
operator|=
name|have_emulator_p
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
comment|/* By default, select the first thread,    * If task has no threads, gives a warning    * Does not fetch registers, since they are not yet valid.    */
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inferior_exception_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|setup_exception_port
argument_list|()
expr_stmt|;
name|xx_debug
argument_list|(
literal|"Now the debugged task is created\n"
argument_list|)
expr_stmt|;
comment|/* One trap to exec the shell, one to exec the program being debugged.  */
name|intercept_exec_calls
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|setup_exception_port
argument_list|()
end_macro

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|inferior_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_allocate"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* add send right */
name|ret
operator|=
name|mach_port_insert_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inferior_exception_port
argument_list|,
name|inferior_exception_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_insert_right"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inferior_exception_port
argument_list|,
name|inferior_wait_port_set
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_move_member"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_get_special_port
argument_list|(
name|inferior_task
argument_list|,
name|TASK_EXCEPTION_PORT
argument_list|,
operator|&
name|inferior_old_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_get_special_port(old exc)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_set_special_port
argument_list|(
name|inferior_task
argument_list|,
name|TASK_EXCEPTION_PORT
argument_list|,
name|inferior_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_set_special_port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inferior_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mack_port_deallocate"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* When notify appears, the inferior_task's exception    * port has been destroyed.    *    * Not used, since the dead_name_notification already    * appears when task dies.    *    */
block|request_notify (inferior_exception_port, 		  MACH_NOTIFY_NO_SENDERS, 		  MACH_TYPE_EXCEPTION_PORT);
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Nonzero if gdb is waiting for a message */
end_comment

begin_decl_stmt
name|int
name|mach_really_waiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait for the inferior to stop for some reason.    - Loop on notifications until inferior_task dies.    - Loop on exceptions until stopped_in_exception comes true.      (e.g. we receive a single step trace trap)    - a message arrives to gdb's message port     There is no other way to exit this loop.     Returns the inferior_pid for rest of gdb.    Side effects: Set *OURSTATUS.  */
end_comment

begin_function
name|int
name|mach_really_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|w
decl_stmt|;
struct|struct
name|msg
block|{
name|mach_msg_header_t
name|header
decl_stmt|;
name|mach_msg_type_t
name|foo
decl_stmt|;
name|int
name|data
index|[
literal|8000
index|]
decl_stmt|;
block|}
name|in_msg
struct|,
name|out_msg
struct|;
comment|/* Either notify (death), exception or message can stop the inferior */
name|stopped_in_exception
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|QUIT
expr_stmt|;
name|stop_exception
operator|=
name|stop_code
operator|=
name|stop_subcode
operator|=
operator|-
literal|1
expr_stmt|;
name|stop_thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|mach_really_waiting
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|mach_msg
argument_list|(
operator|&
name|in_msg
operator|.
name|header
argument_list|,
comment|/* header */
name|MACH_RCV_MSG
argument_list|,
comment|/* options */
literal|0
argument_list|,
comment|/* send size */
sizeof|sizeof
argument_list|(
expr|struct
name|msg
argument_list|)
argument_list|,
comment|/* receive size */
name|currently_waiting_for
argument_list|,
comment|/* receive name */
name|MACH_MSG_TIMEOUT_NONE
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
name|mach_really_waiting
operator|=
literal|0
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_msg (receive)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Check if we received a notify of the childs' death */
if|if
condition|(
name|notify_server
argument_list|(
operator|&
name|in_msg
operator|.
name|header
argument_list|,
operator|&
name|out_msg
operator|.
name|header
argument_list|)
condition|)
block|{
comment|/* If inferior_task is null then the inferior has 	     gone away and we want to return to command level. 	     Otherwise it was just an informative message and we 	     need to look to see if there are any more. */
if|if
condition|(
name|inferior_task
operator|!=
name|MACH_PORT_NULL
condition|)
continue|continue;
else|else
block|{
comment|/* Collect Unix exit status for gdb */
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This mess is here to check that the rest of 	       * gdb knows that the inferior died. It also 	       * tries to hack around the fact that Mach 3.0 (mk69) 	       * unix server (ux28) does not always know what 	       * has happened to it's children when mach-magic 	       * is applied on them. 	       */
if|if
condition|(
operator|(
operator|!
name|WIFEXITED
argument_list|(
name|w
argument_list|)
operator|&&
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
operator|)
operator|||
operator|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|>
literal|0377
operator|)
condition|)
block|{
name|WSETEXIT
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Using exit value 0 for terminated task"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|w
argument_list|)
decl_stmt|;
comment|/* Signals cause problems. Warn the user. */
if|if
condition|(
name|sig
operator|!=
name|SIGKILL
condition|)
comment|/* Bad luck if garbage matches this */
name|warning
argument_list|(
literal|"The terminating signal stuff may be nonsense"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sig
operator|>
name|NSIG
condition|)
block|{
name|WSETEXIT
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Using exit value 0 for terminated task"
argument_list|)
expr_stmt|;
block|}
block|}
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|w
argument_list|)
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
block|}
comment|/* Hmm. Check for exception, as it was not a notification. 	 exc_server() does an upcall to catch_exception_raise() 	 if this rpc is an exception. Further actions are decided 	 there.        */
if|if
condition|(
operator|!
name|exc_server
argument_list|(
operator|&
name|in_msg
operator|.
name|header
argument_list|,
operator|&
name|out_msg
operator|.
name|header
argument_list|)
condition|)
block|{
comment|/* Not an exception, check for message. 	   * 	   * Messages don't come from the inferior, or if they 	   * do they better be asynchronous or it will hang. 	   */
if|if
condition|(
name|gdb_message_server
argument_list|(
operator|&
name|in_msg
operator|.
name|header
argument_list|)
condition|)
continue|continue;
name|error
argument_list|(
literal|"Unrecognized message received in mach_really_wait"
argument_list|)
expr_stmt|;
block|}
comment|/* Send the reply of the exception rpc to the suspended task */
name|ret
operator|=
name|mach_msg_send
argument_list|(
operator|&
name|out_msg
operator|.
name|header
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_msg_send (exc reply)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopped_in_exception
condition|)
block|{
comment|/* Get unix state. May be changed in mach3_exception_actions() */
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mach3_exception_actions
argument_list|(
operator|&
name|w
argument_list|,
name|FALSE
argument_list|,
literal|"Task"
argument_list|)
expr_stmt|;
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|w
argument_list|)
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called by macro DO_QUIT() in utils.c(quit).  * This is called just before calling error() to return to command level  */
end_comment

begin_function
name|void
name|mach3_quit
parameter_list|()
block|{
name|int
name|mid
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
name|mach_really_waiting
condition|)
block|{
name|ret
operator|=
name|task_suspend
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Could not suspend task for interrupt: %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|mach_really_waiting
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|must_suspend_thread
operator|=
literal|0
expr_stmt|;
name|mach_really_waiting
operator|=
literal|0
expr_stmt|;
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Selecting first existing kernel thread"
argument_list|)
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
block|}
name|current_thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
comment|/* Force setup */
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
name|mid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* bogus bogus bogus.  It is NOT OK to quit out of target_wait.  */
end_comment

begin_comment
comment|/* If ^C is typed when we are waiting for a message  * and your Unix server is able to notice that we   * should quit now.  *  * Called by REQUEST_QUIT() from utils.c(request_quit)  */
end_comment

begin_endif
unit|void mach3_request_quit () {   if (mach_really_waiting)     immediate_quit = 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Gdb message server.  * Currently implemented is the STOP message, that causes  * gdb to return to the command level like ^C had been typed from terminal.  */
end_comment

begin_function
name|int
name|gdb_message_server
parameter_list|(
name|InP
parameter_list|)
name|mach_msg_header_t
modifier|*
name|InP
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|mid
decl_stmt|;
if|if
condition|(
name|InP
operator|->
name|msgh_local_port
operator|==
name|our_message_port
condition|)
block|{
comment|/* A message coming to our_message_port. Check validity */
switch|switch
condition|(
name|InP
operator|->
name|msgh_id
condition|)
block|{
case|case
name|GDB_MESSAGE_ID_STOP
case|:
name|ret
operator|=
name|task_suspend
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Could not suspend task for stop message: %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* QUIT in mach_really_wait() loop. */
name|request_quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Invalid message id %d received, ignored."
argument_list|,
name|InP
operator|->
name|msgh_id
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
comment|/* Message not handled by this server */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NOTE: This is not an RPC call. It is a simpleroutine.  *  * This is not called from this gdb code.  *  * It may be called by another debugger to cause this  * debugger to enter command level:  *  *            (gdb) set stop_inferior_gdb ()  *            (gdb) continue  *  * External program "stop-gdb" implements this also.  */
end_comment

begin_function
name|void
name|stop_inferior_gdb
parameter_list|()
block|{
name|kern_return_t
name|ret
decl_stmt|;
comment|/* Code generated by mig, with minor cleanups :-)    *    * simpleroutine stop_inferior_gdb (our_message_port : mach_port_t);    */
typedef|typedef
struct|struct
block|{
name|mach_msg_header_t
name|Head
decl_stmt|;
block|}
name|Request
typedef|;
name|Request
name|Mess
decl_stmt|;
specifier|register
name|Request
modifier|*
name|InP
init|=
operator|&
name|Mess
decl_stmt|;
name|InP
operator|->
name|Head
operator|.
name|msgh_bits
operator|=
name|MACH_MSGH_BITS
argument_list|(
name|MACH_MSG_TYPE_COPY_SEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* msgh_size passed as argument */
name|InP
operator|->
name|Head
operator|.
name|msgh_remote_port
operator|=
name|our_message_port
expr_stmt|;
name|InP
operator|->
name|Head
operator|.
name|msgh_local_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|InP
operator|->
name|Head
operator|.
name|msgh_seqno
operator|=
literal|0
expr_stmt|;
name|InP
operator|->
name|Head
operator|.
name|msgh_id
operator|=
name|GDB_MESSAGE_ID_STOP
expr_stmt|;
name|ret
operator|=
name|mach_msg
argument_list|(
operator|&
name|InP
operator|->
name|Head
argument_list|,
name|MACH_SEND_MSG
operator||
name|MACH_MSG_OPTION_NONE
argument_list|,
sizeof|sizeof
argument_list|(
name|Request
argument_list|)
argument_list|,
literal|0
argument_list|,
name|MACH_PORT_NULL
argument_list|,
name|MACH_MSG_TIMEOUT_NONE
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|THREAD_ALLOWED_TO_BREAK
end_ifdef

begin_comment
comment|/*  * Return 1 if the MID specifies the thread that caused the  * last exception.  *  Since catch_exception_raise() selects the thread causing  * the last exception to current_thread, we just check that  * it is selected and the last exception was a breakpoint.  */
end_comment

begin_function
name|int
name|mach_thread_for_breakpoint
parameter_list|(
name|mid
parameter_list|)
name|int
name|mid
decl_stmt|;
block|{
name|int
name|cmid
init|=
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
decl_stmt|;
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
block|{
name|mid
operator|=
name|map_slot_to_mid
argument_list|(
operator|-
operator|(
name|mid
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Don't stop, no such slot */
block|}
if|if
condition|(
operator|!
name|mid
operator|||
name|cmid
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
comment|/* stop */
return|return
name|cmid
operator|==
name|mid
operator|&&
name|stop_exception
operator|==
name|EXC_BREAKPOINT
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* THREAD_ALLOWED_TO_BREAK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|THREAD_PARSE_ID
end_ifdef

begin_comment
comment|/*  * Map a thread id string (MID or a @SLOTNUMBER)  * to a thread-id.  *  *   0  matches all threads.  *   Otherwise the meaning is defined only in this file.  *   (mach_thread_for_breakpoint uses it)  *  * @@ This allows non-existent MIDs to be specified.  *    It now also allows non-existent slots to be  *    specified. (Slot numbers stored are negative,  *    and the magnitude is one greater than the actual  *    slot index. (Since 0 is reserved))  */
end_comment

begin_function
name|int
name|mach_thread_parse_id
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|mid
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"thread id excpected"
argument_list|)
expr_stmt|;
name|mid
operator|=
name|parse_thread_id
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|mid
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* THREAD_PARSE_ID */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|THREAD_OUTPUT_ID
end_ifdef

begin_function
name|char
modifier|*
name|mach_thread_output_id
parameter_list|(
name|mid
parameter_list|)
name|int
name|mid
decl_stmt|;
block|{
specifier|static
name|char
name|foobar
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|mid
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|foobar
argument_list|,
literal|"mid %d"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|foobar
argument_list|,
literal|"@%d"
argument_list|,
operator|-
operator|(
name|mid
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|foobar
argument_list|,
literal|"*any thread*"
argument_list|)
expr_stmt|;
return|return
name|foobar
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* THREAD_OUTPUT_ID */
end_comment

begin_comment
comment|/* Called with hook PREPARE_TO_PROCEED() from infrun.c.  *  * If we have switched threads and stopped at breakpoint return 1 otherwise 0.  *  *  if SELECT_IT is nonzero, reselect the thread that was active when  *  we stopped at a breakpoint.  *  */
end_comment

begin_macro
name|mach3_prepare_to_proceed
argument_list|(
argument|select_it
argument_list|)
end_macro

begin_decl_stmt
name|int
name|select_it
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|stop_thread
operator|&&
name|stop_thread
operator|!=
name|current_thread
operator|&&
name|stop_exception
operator|==
name|EXC_BREAKPOINT
condition|)
block|{
name|int
name|mid
decl_stmt|;
if|if
condition|(
operator|!
name|select_it
condition|)
return|return
literal|1
return|;
name|mid
operator|=
name|switch_to_thread
argument_list|(
name|stop_thread
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* this stuff here is an upcall via libmach/excServer.c     and mach_really_wait which does the actual upcall.     The code will pass the exception to the inferior if:       - The task that signaled is not the inferior task        (e.g. when debugging another debugger)       - The user has explicitely requested to pass on the exceptions.        (e.g to the default unix exception handler, which maps 	exceptions to signals, or the user has her own exception handler)       - If the thread that signaled is being single-stepped and it        has set it's own exception port and the exception is not        EXC_BREAKPOINT. (Maybe this is not desirable?)  */
end_comment

begin_function
name|kern_return_t
name|catch_exception_raise
parameter_list|(
name|port
parameter_list|,
name|thread
parameter_list|,
name|task
parameter_list|,
name|exception
parameter_list|,
name|code
parameter_list|,
name|subcode
parameter_list|)
name|mach_port_t
name|port
decl_stmt|;
name|thread_t
name|thread
decl_stmt|;
name|task_t
name|task
decl_stmt|;
name|int
name|exception
decl_stmt|,
name|code
decl_stmt|,
name|subcode
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|boolean_t
name|signal_thread
decl_stmt|;
name|int
name|mid
init|=
name|map_port_name_to_mid
argument_list|(
name|thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|thread
argument_list|)
condition|)
block|{
comment|/* If the exception was sent and thread dies before we 	 receive it, THREAD will be MACH_PORT_DEAD        */
name|current_thread
operator|=
name|thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|error
argument_list|(
literal|"Received exception from nonexistent thread"
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the task died in transit.    * @@ Isn't the thread also invalid in such case?    */
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|current_thread
operator|=
name|thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|error
argument_list|(
literal|"Received exception from nonexistent task"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|<
literal|0
operator|||
name|exception
operator|>
name|MAX_EXCEPTION
condition|)
name|fatal
argument_list|(
literal|"catch_exception_raise: unknown exception code %d thread %d"
argument_list|,
name|exception
argument_list|,
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|inferior_task
argument_list|)
condition|)
name|error
argument_list|(
literal|"got an exception, but inferior_task is null or dead"
argument_list|)
expr_stmt|;
name|stop_exception
operator|=
name|exception
expr_stmt|;
name|stop_code
operator|=
name|code
expr_stmt|;
name|stop_subcode
operator|=
name|subcode
expr_stmt|;
name|stop_thread
operator|=
name|thread
expr_stmt|;
name|signal_thread
operator|=
name|exception
operator|!=
name|EXC_BREAKPOINT
operator|&&
name|port
operator|==
name|singlestepped_thread_port
operator|&&
name|MACH_PORT_VALID
argument_list|(
name|thread_saved_exception_port
argument_list|)
expr_stmt|;
comment|/* If it was not our inferior or if we want to forward    * the exception to the inferior's handler, do it here    *    * Note: If you have forwarded EXC_BREAKPOINT I trust you know why.    */
if|if
condition|(
name|task
operator|!=
name|inferior_task
operator|||
name|signal_thread
operator|||
name|exception_map
index|[
name|exception
index|]
operator|.
name|forward
condition|)
block|{
name|mach_port_t
name|eport
init|=
name|inferior_old_exception_port
decl_stmt|;
if|if
condition|(
name|signal_thread
condition|)
block|{
comment|/* 	    GDB now forwards the exeption to thread's original handler, 	    since the user propably knows what he is doing. 	    Give a message, though. 	   */
name|mach3_exception_actions
argument_list|(
operator|(
name|WAITTYPE
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
literal|"Thread"
argument_list|)
expr_stmt|;
name|eport
operator|=
name|thread_saved_exception_port
expr_stmt|;
block|}
comment|/* Send the exception to the original handler */
name|ret
operator|=
name|exception_raise
argument_list|(
name|eport
argument_list|,
name|thread
argument_list|,
name|task
argument_list|,
name|exception
argument_list|,
name|code
argument_list|,
name|subcode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|task
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread
argument_list|)
expr_stmt|;
comment|/* If we come here, we don't want to trace any more, since we        * will never stop for tracing anyway.        */
name|discard_single_step
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|/* Do not stop the inferior */
return|return
name|ret
return|;
block|}
comment|/* Now gdb handles the exception */
name|stopped_in_exception
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
name|task_suspend
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Error suspending inferior after exception"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|must_suspend_thread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_thread
operator|!=
name|thread
condition|)
block|{
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|singlestepped_thread_port
argument_list|)
condition|)
comment|/* Cleanup discards single stepping */
name|error
argument_list|(
literal|"Exception from thread %d while singlestepping thread %d"
argument_list|,
name|mid
argument_list|,
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then select the thread that caused the exception */
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
name|mid
argument_list|,
literal|0
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|error
argument_list|(
literal|"Could not select thread %d causing exception"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Gdb selected thread %d"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
block|}
comment|/* If we receive an exception that is not breakpoint    * exception, we interrupt the single step and return to    * debugger. Trace condition is cleared.    */
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|singlestepped_thread_port
argument_list|)
condition|)
block|{
if|if
condition|(
name|stop_exception
operator|!=
name|EXC_BREAKPOINT
condition|)
name|warning
argument_list|(
literal|"Single step interrupted by exception"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|==
name|singlestepped_thread_port
condition|)
block|{
comment|/* Single step exception occurred, remove trace bit 	   * and return to gdb. 	   */
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|current_thread
argument_list|)
condition|)
name|error
argument_list|(
literal|"Single stepped thread is not valid"
argument_list|)
expr_stmt|;
comment|/* Resume threads, but leave the task suspended */
name|resume_all_threads
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"Breakpoint while single stepping?"
argument_list|)
expr_stmt|;
name|discard_single_step
argument_list|(
name|current_thread
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|task
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|port_valid
parameter_list|(
name|port
parameter_list|,
name|mask
parameter_list|)
name|mach_port_t
name|port
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|mach_port_type_t
name|type
decl_stmt|;
name|ret
operator|=
name|mach_port_type
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|port
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
operator|||
operator|(
name|type
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* @@ No vm read cache implemented yet */
end_comment

begin_decl_stmt
name|boolean_t
name|vm_read_cache_valid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read inferior task's LEN bytes from ADDR and copy it to MYADDR  * in gdb's address space.  *  * Return 0 on failure; number of bytes read otherwise.  */
end_comment

begin_function
name|int
name|mach3_read_inferior
parameter_list|(
name|addr
parameter_list|,
name|myaddr
parameter_list|,
name|length
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|vm_address_t
name|low_address
init|=
operator|(
name|vm_address_t
operator|)
name|trunc_page
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|vm_size_t
name|aligned_length
init|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|addr
operator|+
name|length
argument_list|)
operator|-
name|low_address
decl_stmt|;
name|pointer_t
name|copied_memory
decl_stmt|;
name|int
name|copy_count
decl_stmt|;
comment|/* Get memory from inferior with page aligned addresses */
name|ret
operator|=
name|vm_read
argument_list|(
name|inferior_task
argument_list|,
name|low_address
argument_list|,
name|aligned_length
argument_list|,
operator|&
name|copied_memory
argument_list|,
operator|&
name|copy_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
comment|/* the problem is that the inferior might be killed for whatever reason        * before we go to mach_really_wait. This is one place that ought to        * catch many of those errors.        * @@ A better fix would be to make all external events to GDB        * to arrive via a SINGLE port set. (Including user input!)        */
if|if
condition|(
operator|!
name|port_valid
argument_list|(
name|inferior_task
argument_list|,
name|MACH_PORT_TYPE_SEND
argument_list|)
condition|)
block|{
name|m3_kill_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Inferior killed (task port invalid)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OSF
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* valprint.c gives nicer format if this does not 	     screw it. Eamonn seems to like this, so I enable 	     it if OSF is defined... 	   */
name|warning
argument_list|(
literal|"[read inferior %x failed: %s]"
argument_list|,
name|addr
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
operator|-
name|low_address
operator|+
name|copied_memory
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|copied_memory
argument_list|,
name|copy_count
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach3_read_inferior vm_deallocate failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|CHK_GOTO_OUT
parameter_list|(
name|str
parameter_list|,
name|ret
parameter_list|)
define|\
value|do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHK_GOTO_OUT
parameter_list|(
name|str
parameter_list|,
name|ret
parameter_list|)
define|\
value|do if (ret != KERN_SUCCESS) { errstr = str; goto out; } while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|vm_region_list
block|{
name|struct
name|vm_region_list
modifier|*
name|next
decl_stmt|;
name|vm_prot_t
name|protection
decl_stmt|;
name|vm_address_t
name|start
decl_stmt|;
name|vm_size_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack
name|region_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write inferior task's LEN bytes from ADDR and copy it to MYADDR  * in gdb's address space.  */
end_comment

begin_function
name|int
name|mach3_write_inferior
parameter_list|(
name|addr
parameter_list|,
name|myaddr
parameter_list|,
name|length
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|vm_address_t
name|low_address
init|=
operator|(
name|vm_address_t
operator|)
name|trunc_page
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|vm_size_t
name|aligned_length
init|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|addr
operator|+
name|length
argument_list|)
operator|-
name|low_address
decl_stmt|;
name|pointer_t
name|copied_memory
decl_stmt|;
name|int
name|copy_count
decl_stmt|;
name|int
name|deallocate
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|errstr
init|=
literal|"Bug in mach3_write_inferior"
decl_stmt|;
name|struct
name|vm_region_list
modifier|*
name|region_element
decl_stmt|;
name|struct
name|vm_region_list
modifier|*
name|region_head
init|=
operator|(
expr|struct
name|vm_region_list
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Get memory from inferior with page aligned addresses */
name|ret
operator|=
name|vm_read
argument_list|(
name|inferior_task
argument_list|,
name|low_address
argument_list|,
name|aligned_length
argument_list|,
operator|&
name|copied_memory
argument_list|,
operator|&
name|copy_count
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"mach3_write_inferior vm_read failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|deallocate
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|-
name|low_address
operator|+
name|copied_memory
argument_list|,
name|myaddr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|region_obstack
argument_list|)
expr_stmt|;
comment|/* Do writes atomically.    * First check for holes and unwritable memory.    */
block|{
name|vm_size_t
name|remaining_length
init|=
name|aligned_length
decl_stmt|;
name|vm_address_t
name|region_address
init|=
name|low_address
decl_stmt|;
name|struct
name|vm_region_list
modifier|*
name|scan
decl_stmt|;
while|while
condition|(
name|region_address
operator|<
name|low_address
operator|+
name|aligned_length
condition|)
block|{
name|vm_prot_t
name|protection
decl_stmt|;
name|vm_prot_t
name|max_protection
decl_stmt|;
name|vm_inherit_t
name|inheritance
decl_stmt|;
name|boolean_t
name|shared
decl_stmt|;
name|mach_port_t
name|object_name
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
name|vm_size_t
name|region_length
init|=
name|remaining_length
decl_stmt|;
name|vm_address_t
name|old_address
init|=
name|region_address
decl_stmt|;
name|ret
operator|=
name|vm_region
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|region_address
argument_list|,
operator|&
name|region_length
argument_list|,
operator|&
name|protection
argument_list|,
operator|&
name|max_protection
argument_list|,
operator|&
name|inheritance
argument_list|,
operator|&
name|shared
argument_list|,
operator|&
name|object_name
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_region failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Check for holes in memory */
if|if
condition|(
name|old_address
operator|!=
name|region_address
condition|)
block|{
name|warning
argument_list|(
literal|"No memory at 0x%x. Nothing written"
argument_list|,
name|old_address
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KERN_SUCCESS
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|max_protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Memory at address 0x%x is unwritable. Nothing written"
argument_list|,
name|old_address
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KERN_SUCCESS
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Chain the regions for later use */
name|region_element
operator|=
operator|(
expr|struct
name|vm_region_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|region_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_region_list
argument_list|)
argument_list|)
expr_stmt|;
name|region_element
operator|->
name|protection
operator|=
name|protection
expr_stmt|;
name|region_element
operator|->
name|start
operator|=
name|region_address
expr_stmt|;
name|region_element
operator|->
name|length
operator|=
name|region_length
expr_stmt|;
comment|/* Chain the regions along with protections */
name|region_element
operator|->
name|next
operator|=
name|region_head
expr_stmt|;
name|region_head
operator|=
name|region_element
expr_stmt|;
name|region_address
operator|+=
name|region_length
expr_stmt|;
name|remaining_length
operator|=
name|remaining_length
operator|-
name|region_length
expr_stmt|;
block|}
comment|/* If things fail after this, we give up.      * Somebody is messing up inferior_task's mappings.      */
comment|/* Enable writes to the chained vm regions */
for|for
control|(
name|scan
operator|=
name|region_head
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|boolean_t
name|protection_changed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scan
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
name|ret
operator|=
name|vm_protect
argument_list|(
name|inferior_task
argument_list|,
name|scan
operator|->
name|start
argument_list|,
name|scan
operator|->
name|length
argument_list|,
name|FALSE
argument_list|,
name|scan
operator|->
name|protection
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_protect: enable write failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|vm_write
argument_list|(
name|inferior_task
argument_list|,
name|low_address
argument_list|,
name|copied_memory
argument_list|,
name|aligned_length
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_write failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Set up the original region protections, if they were changed */
for|for
control|(
name|scan
operator|=
name|region_head
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|boolean_t
name|protection_changed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scan
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
name|ret
operator|=
name|vm_protect
argument_list|(
name|inferior_task
argument_list|,
name|scan
operator|->
name|start
argument_list|,
name|scan
operator|->
name|length
argument_list|,
name|FALSE
argument_list|,
name|scan
operator|->
name|protection
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_protect: enable write failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|deallocate
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|region_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|copied_memory
argument_list|,
name|copy_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"%s %s"
argument_list|,
name|errstr
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Return 0 on failure, number of bytes handled otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|m3_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* IGNORED */
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|write
condition|)
name|result
operator|=
name|mach3_write_inferior
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|mach3_read_inferior
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|translate_state
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TH_STATE_RUNNING
case|:
return|return
operator|(
literal|"R"
operator|)
return|;
case|case
name|TH_STATE_STOPPED
case|:
return|return
operator|(
literal|"S"
operator|)
return|;
case|case
name|TH_STATE_WAITING
case|:
return|return
operator|(
literal|"W"
operator|)
return|;
case|case
name|TH_STATE_UNINTERRUPTIBLE
case|:
return|return
operator|(
literal|"U"
operator|)
return|;
case|case
name|TH_STATE_HALTED
case|:
return|return
operator|(
literal|"H"
operator|)
return|;
default|default:
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|translate_cstate
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|CPROC_RUNNING
case|:
return|return
literal|"R"
return|;
case|case
name|CPROC_SWITCHING
case|:
return|return
literal|"S"
return|;
case|case
name|CPROC_BLOCKED
case|:
return|return
literal|"B"
return|;
case|case
name|CPROC_CONDWAIT
case|:
return|return
literal|"C"
return|;
case|case
name|CPROC_CONDWAIT
operator||
name|CPROC_SWITCHING
case|:
return|return
literal|"CS"
return|;
default|default:
return|return
literal|"?"
return|;
block|}
block|}
end_function

begin_comment
comment|/* type == MACH_MSG_TYPE_COPY_SEND || type == MACH_MSG_TYPE_MAKE_SEND */
end_comment

begin_function
name|mach_port_t
comment|/* no mach_port_name_t found in include files. */
name|map_inferior_port_name
parameter_list|(
name|inferior_name
parameter_list|,
name|type
parameter_list|)
name|mach_port_t
name|inferior_name
decl_stmt|;
name|mach_msg_type_name_t
name|type
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|mach_msg_type_name_t
name|acquired
decl_stmt|;
name|mach_port_t
name|iport
decl_stmt|;
name|ret
operator|=
name|mach_port_extract_right
argument_list|(
name|inferior_task
argument_list|,
name|inferior_name
argument_list|,
name|type
argument_list|,
operator|&
name|iport
argument_list|,
operator|&
name|acquired
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mach_port_extract_right (map_inferior_port_name)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|acquired
operator|!=
name|MACH_MSG_TYPE_PORT_SEND
condition|)
name|error
argument_list|(
literal|"Incorrect right extracted, (map_inferior_port_name)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|iport
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Deallocating mapped port (map_inferior_port_name)"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|iport
return|;
block|}
end_function

begin_comment
comment|/*  * Naming convention:  *  Always return user defined name if found.  *  _K == A kernel thread with no matching CPROC  *  _C == A cproc with no current cthread  *  _t == A cthread with no user defined name  *  * The digits that follow the _names are the SLOT number of the  * kernel thread if there is such a thing, otherwise just a negation  * of the sequential number of such cprocs.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|buf
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|get_thread_name
parameter_list|(
name|one_cproc
parameter_list|,
name|id
parameter_list|)
name|gdb_thread_t
name|one_cproc
decl_stmt|;
name|int
name|id
decl_stmt|;
block|{
if|if
condition|(
name|one_cproc
condition|)
if|if
condition|(
name|one_cproc
operator|->
name|cthread
operator|==
name|NULL
condition|)
block|{
comment|/* cproc not mapped to any cthread */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_C%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|one_cproc
operator|->
name|cthread
operator|->
name|name
condition|)
block|{
comment|/* cproc and cthread, but no name */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_t%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|one_cproc
operator|->
name|cthread
operator|->
name|name
operator|)
return|;
else|else
block|{
if|if
condition|(
name|id
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"Inconsistency in thread name id %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Kernel thread without cproc */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_K%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|fetch_thread_info
parameter_list|(
name|task
parameter_list|,
name|mthreads_out
parameter_list|)
name|mach_port_t
name|task
decl_stmt|;
name|gdb_thread_t
modifier|*
name|mthreads_out
decl_stmt|;
comment|/* out */
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|thread_array_t
name|th_table
decl_stmt|;
name|int
name|th_count
decl_stmt|;
name|gdb_thread_t
name|mthreads
init|=
name|NULL
decl_stmt|;
name|int
name|index
decl_stmt|;
name|ret
operator|=
name|task_threads
argument_list|(
name|task
argument_list|,
operator|&
name|th_table
argument_list|,
operator|&
name|th_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Error getting inferior's thread list:%s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|m3_kill_inferior
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|mthreads
operator|=
operator|(
name|gdb_thread_t
operator|)
name|obstack_alloc
argument_list|(
name|cproc_obstack
argument_list|,
name|th_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gdb_thread
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|th_count
condition|;
name|index
operator|++
control|)
block|{
name|thread_t
name|saved_thread
init|=
name|MACH_PORT_NULL
decl_stmt|;
name|int
name|mid
decl_stmt|;
if|if
condition|(
name|must_suspend_thread
condition|)
name|setup_thread
argument_list|(
name|th_table
index|[
name|index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|th_table
index|[
name|index
index|]
operator|!=
name|current_thread
condition|)
block|{
name|saved_thread
operator|=
name|current_thread
expr_stmt|;
name|mid
operator|=
name|switch_to_thread
argument_list|(
name|th_table
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|mthreads
index|[
name|index
index|]
operator|.
name|name
operator|=
name|th_table
index|[
name|index
index|]
expr_stmt|;
name|mthreads
index|[
name|index
index|]
operator|.
name|cproc
operator|=
name|NULL
expr_stmt|;
comment|/* map_cprocs_to_kernel_threads() */
name|mthreads
index|[
name|index
index|]
operator|.
name|in_emulator
operator|=
name|FALSE
expr_stmt|;
name|mthreads
index|[
name|index
index|]
operator|.
name|slotid
operator|=
name|index
expr_stmt|;
name|mthreads
index|[
name|index
index|]
operator|.
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|mthreads
index|[
name|index
index|]
operator|.
name|fp
operator|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
expr_stmt|;
name|mthreads
index|[
name|index
index|]
operator|.
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|saved_thread
argument_list|)
condition|)
name|mid
operator|=
name|switch_to_thread
argument_list|(
name|saved_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_suspend_thread
condition|)
name|setup_thread
argument_list|(
name|th_table
index|[
name|index
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|consume_send_rights
argument_list|(
name|th_table
argument_list|,
name|th_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|th_table
argument_list|,
operator|(
name|th_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Error trying to deallocate thread list : %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|mthreads_out
operator|=
name|mthreads
expr_stmt|;
return|return
name|th_count
return|;
block|}
end_function

begin_comment
comment|/*  * Current emulator always saves the USP on top of  * emulator stack below struct emul_stack_top stuff.  */
end_comment

begin_function
name|CORE_ADDR
name|fetch_usp_from_emulator_stack
parameter_list|(
name|sp
parameter_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
block|{
name|CORE_ADDR
name|stack_pointer
decl_stmt|;
name|sp
operator|=
operator|(
name|sp
operator|&
operator|~
operator|(
name|EMULATOR_STACK_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|EMULATOR_STACK_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|emul_stack_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|mach3_read_inferior
argument_list|(
name|sp
argument_list|,
operator|&
name|stack_pointer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Can't read user sp from emulator stack address 0x%x"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|stack_pointer
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MK67
end_ifdef

begin_comment
comment|/* get_emulation_vector() interface was changed after mk67 */
end_comment

begin_define
define|#
directive|define
name|EMUL_VECTOR_COUNT
value|400
end_define

begin_comment
comment|/* Value does not matter too much */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MK67 */
end_comment

begin_comment
comment|/* Check if the emulator exists at task's address space.  */
end_comment

begin_function
name|boolean_t
name|have_emulator_p
parameter_list|(
name|task
parameter_list|)
name|task_t
name|task
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
ifndef|#
directive|ifndef
name|EMUL_VECTOR_COUNT
name|vm_offset_t
modifier|*
name|emulation_vector
decl_stmt|;
name|int
name|n
decl_stmt|;
else|#
directive|else
name|vm_offset_t
name|emulation_vector
index|[
name|EMUL_VECTOR_COUNT
index|]
decl_stmt|;
name|int
name|n
init|=
name|EMUL_VECTOR_COUNT
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|int
name|vector_start
decl_stmt|;
name|ret
operator|=
name|task_get_emulation_vector
argument_list|(
name|task
argument_list|,
operator|&
name|vector_start
argument_list|,
ifndef|#
directive|ifndef
name|EMUL_VECTOR_COUNT
operator|&
name|emulation_vector
argument_list|,
else|#
directive|else
name|emulation_vector
argument_list|,
endif|#
directive|endif
operator|&
name|n
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_get_emulation_vector"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|xx_debug
argument_list|(
literal|"%d vectors from %d at 0x%08x\n"
argument_list|,
name|n
argument_list|,
name|vector_start
argument_list|,
name|emulation_vector
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|entry
init|=
name|emulation_vector
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|EMULATOR_BASE
operator|<=
name|entry
operator|&&
name|entry
operator|<=
name|EMULATOR_END
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|entry
condition|)
block|{
specifier|static
name|boolean_t
name|informed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|informed
condition|)
block|{
name|warning
argument_list|(
literal|"Emulation vector address 0x08%x outside emulator space"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|informed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Map cprocs to kernel threads and vice versa.  */
end_comment

begin_function
name|void
name|map_cprocs_to_kernel_threads
parameter_list|(
name|cprocs
parameter_list|,
name|mthreads
parameter_list|,
name|thread_count
parameter_list|)
name|gdb_thread_t
name|cprocs
decl_stmt|;
name|gdb_thread_t
name|mthreads
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
name|gdb_thread_t
name|scan
decl_stmt|;
name|boolean_t
name|all_mapped
init|=
name|TRUE
decl_stmt|;
name|LONGEST
name|stack_base
decl_stmt|;
name|LONGEST
name|stack_size
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|cprocs
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
comment|/* Default to: no kernel thread for this cproc */
name|scan
operator|->
name|reverse_map
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Check if the cproc is found by its stack */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
name|stack_base
operator|=
name|extract_signed_integer
argument_list|(
name|scan
operator|->
name|raw_cproc
operator|+
name|CPROC_BASE_OFFSET
argument_list|,
name|CPROC_BASE_SIZE
argument_list|)
expr_stmt|;
name|stack_size
operator|=
name|extract_signed_integer
argument_list|(
name|scan
operator|->
name|raw_cproc
operator|+
name|CPROC_SIZE_OFFSET
argument_list|,
name|CPROC_SIZE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mthreads
operator|+
name|index
operator|)
operator|->
name|sp
operator|>
name|stack_base
operator|&&
operator|(
name|mthreads
operator|+
name|index
operator|)
operator|->
name|sp
operator|<=
name|stack_base
operator|+
name|stack_size
condition|)
block|{
operator|(
name|mthreads
operator|+
name|index
operator|)
operator|->
name|cproc
operator|=
name|scan
expr_stmt|;
name|scan
operator|->
name|reverse_map
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
name|all_mapped
operator|&=
operator|(
name|scan
operator|->
name|reverse_map
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Check for threads that are currently in the emulator.    * If so, they have a different stack, and the still unmapped    * cprocs may well get mapped to these threads.    *     * If:    *  - cproc stack does not match any kernel thread stack pointer    *  - there is at least one extra kernel thread    *    that has no cproc mapped above.    *  - some kernel thread stack pointer points to emulator space    *  then we find the user stack pointer saved in the emulator    *  stack, and try to map that to the cprocs.    *    * Also set in_emulator for kernel threads.    */
if|if
condition|(
name|emulator_present
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
name|CORE_ADDR
name|emul_sp
decl_stmt|;
name|CORE_ADDR
name|usp
decl_stmt|;
name|gdb_thread_t
name|mthread
init|=
operator|(
name|mthreads
operator|+
name|index
operator|)
decl_stmt|;
name|emul_sp
operator|=
name|mthread
operator|->
name|sp
expr_stmt|;
if|if
condition|(
name|mthread
operator|->
name|cproc
operator|==
name|NULL
operator|&&
name|EMULATOR_BASE
operator|<=
name|emul_sp
operator|&&
name|emul_sp
operator|<=
name|EMULATOR_END
condition|)
block|{
name|mthread
operator|->
name|in_emulator
operator|=
name|emulator_present
expr_stmt|;
if|if
condition|(
operator|!
name|all_mapped
operator|&&
name|cprocs
condition|)
block|{
name|usp
operator|=
name|fetch_usp_from_emulator_stack
argument_list|(
name|emul_sp
argument_list|)
expr_stmt|;
comment|/* @@ Could be more accurate */
if|if
condition|(
operator|!
name|usp
condition|)
name|error
argument_list|(
literal|"Zero stack pointer read from emulator?"
argument_list|)
expr_stmt|;
comment|/* Try to match this stack pointer to the cprocs that 		   * don't yet have a kernel thread. 		   */
for|for
control|(
name|scan
operator|=
name|cprocs
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
comment|/* Check is this unmapped CPROC stack contains 		       * the user stack pointer saved in the 		       * emulator. 		       */
if|if
condition|(
name|scan
operator|->
name|reverse_map
operator|==
operator|-
literal|1
condition|)
block|{
name|stack_base
operator|=
name|extract_signed_integer
argument_list|(
name|scan
operator|->
name|raw_cproc
operator|+
name|CPROC_BASE_OFFSET
argument_list|,
name|CPROC_BASE_SIZE
argument_list|)
expr_stmt|;
name|stack_size
operator|=
name|extract_signed_integer
argument_list|(
name|scan
operator|->
name|raw_cproc
operator|+
name|CPROC_SIZE_OFFSET
argument_list|,
name|CPROC_SIZE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|usp
operator|>
name|stack_base
operator|&&
name|usp
operator|<=
name|stack_base
operator|+
name|stack_size
condition|)
block|{
name|mthread
operator|->
name|cproc
operator|=
name|scan
expr_stmt|;
name|scan
operator|->
name|reverse_map
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Format of the thread_list command  *  * 	             slot mid sel   name  emul ks susp  cstate wired   address  */
end_comment

begin_define
define|#
directive|define
name|TL_FORMAT
value|"%-2.2s %5d%c %-10.10s %1.1s%s%-5.5s %-2.2s %-5.5s "
end_define

begin_define
define|#
directive|define
name|TL_HEADER
value|"\n@    MID  Name        KState CState   Where\n"
end_define

begin_function
name|void
name|print_tl_address
parameter_list|(
name|stream
parameter_list|,
name|pc
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format
argument_list|()
argument_list|,
name|pc
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|addressprint
decl_stmt|;
specifier|extern
name|int
name|asm_demangle
decl_stmt|;
name|int
name|store
init|=
name|addressprint
decl_stmt|;
name|addressprint
operator|=
literal|0
expr_stmt|;
name|print_address_symbolic
argument_list|(
name|pc
argument_list|,
name|stream
argument_list|,
name|asm_demangle
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|addressprint
operator|=
name|store
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For thread names, but also for gdb_message_port external name */
end_comment

begin_define
define|#
directive|define
name|MAX_NAME_LEN
value|50
end_define

begin_comment
comment|/* Returns the address of variable NAME or 0 if not found */
end_comment

begin_function
name|CORE_ADDR
name|lookup_address_of_variable
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|symaddr
init|=
literal|0
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|symaddr
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symaddr
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|&&
name|msymbol
operator|->
name|type
operator|==
name|mst_data
condition|)
name|symaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
return|return
name|symaddr
return|;
block|}
end_function

begin_function
specifier|static
name|gdb_thread_t
name|get_cprocs
parameter_list|()
block|{
name|gdb_thread_t
name|cproc_head
decl_stmt|;
name|gdb_thread_t
name|cproc_copy
decl_stmt|;
name|CORE_ADDR
name|their_cprocs
decl_stmt|;
name|char
modifier|*
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|cthread_t
name|cthread
decl_stmt|;
name|CORE_ADDR
name|symaddr
decl_stmt|;
name|symaddr
operator|=
name|lookup_address_of_variable
argument_list|(
literal|"cproc_list"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symaddr
condition|)
block|{
comment|/* cproc_list is not in a file compiled with debugging 	 symbols, but don't give up yet */
name|symaddr
operator|=
name|lookup_address_of_variable
argument_list|(
literal|"cprocs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symaddr
condition|)
block|{
specifier|static
name|int
name|informed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|informed
condition|)
block|{
name|informed
operator|++
expr_stmt|;
name|warning
argument_list|(
literal|"Your program is loaded with an old threads library."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB does not know the old form of threads"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"so things may not work."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Stripped or no -lthreads loaded or "cproc_list" is in wrong segment. */
if|if
condition|(
operator|!
name|symaddr
condition|)
return|return
name|NULL
return|;
comment|/* Get the address of the first cproc in the task */
if|if
condition|(
operator|!
name|mach3_read_inferior
argument_list|(
name|symaddr
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read cproc master list at address (0x%x)."
argument_list|,
name|symaddr
argument_list|)
expr_stmt|;
name|their_cprocs
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
comment|/* Scan the CPROCs in the task.      CPROCs are chained with LIST field, not NEXT field, which      chains mutexes, condition variables and queues */
name|cproc_head
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|their_cprocs
operator|!=
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
block|{
name|CORE_ADDR
name|cproc_copy_incarnation
decl_stmt|;
name|cproc_copy
operator|=
operator|(
name|gdb_thread_t
operator|)
name|obstack_alloc
argument_list|(
name|cproc_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gdb_thread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mach3_read_inferior
argument_list|(
name|their_cprocs
argument_list|,
operator|&
name|cproc_copy
operator|->
name|raw_cproc
index|[
literal|0
index|]
argument_list|,
name|CPROC_SIZE
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read next cproc at 0x%x."
argument_list|,
name|their_cprocs
argument_list|)
expr_stmt|;
name|their_cprocs
operator|=
name|extract_address
argument_list|(
name|cproc_copy
operator|->
name|raw_cproc
operator|+
name|CPROC_LIST_OFFSET
argument_list|,
name|CPROC_LIST_SIZE
argument_list|)
expr_stmt|;
name|cproc_copy_incarnation
operator|=
name|extract_address
argument_list|(
name|cproc_copy
operator|->
name|raw_cproc
operator|+
name|CPROC_INCARNATION_OFFSET
argument_list|,
name|CPROC_INCARNATION_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cproc_copy_incarnation
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
name|cproc_copy
operator|->
name|cthread
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* This CPROC has an attached CTHREAD. Get its name */
name|cthread
operator|=
operator|(
name|cthread_t
operator|)
name|obstack_alloc
argument_list|(
name|cproc_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cthread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mach3_read_inferior
argument_list|(
name|cproc_copy_incarnation
argument_list|,
name|cthread
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cthread
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read next thread at 0x%x."
argument_list|,
name|cproc_copy_incarnation
argument_list|)
expr_stmt|;
name|cproc_copy
operator|->
name|cthread
operator|=
name|cthread
expr_stmt|;
if|if
condition|(
name|cthread
operator|->
name|name
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|cproc_obstack
argument_list|,
name|MAX_NAME_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mach3_read_inferior
argument_list|(
name|cthread
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|MAX_NAME_LEN
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read next thread's name at 0x%x."
argument_list|,
name|cthread
operator|->
name|name
argument_list|)
expr_stmt|;
name|cthread
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
block|}
comment|/* insert in front */
name|cproc_copy
operator|->
name|next
operator|=
name|cproc_head
expr_stmt|;
name|cproc_head
operator|=
name|cproc_copy
expr_stmt|;
block|}
return|return
name|cproc_head
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FETCH_CPROC_STATE
end_ifndef

begin_comment
comment|/*  * Check if your machine does not grok the way this routine  * fetches the FP,PC and SP of a cproc that is not  * currently attached to any kernel thread (e.g. its cproc.context  * field points to the place in stack where the context  * is saved).  *  * If it doesn't, define your own routine.  */
end_comment

begin_define
define|#
directive|define
name|FETCH_CPROC_STATE
parameter_list|(
name|mth
parameter_list|)
value|mach3_cproc_state (mth)
end_define

begin_function
name|int
name|mach3_cproc_state
parameter_list|(
name|mthread
parameter_list|)
name|gdb_thread_t
name|mthread
decl_stmt|;
block|{
name|int
name|context
decl_stmt|;
if|if
condition|(
operator|!
name|mthread
operator|||
operator|!
name|mthread
operator|->
name|cproc
condition|)
return|return
operator|-
literal|1
return|;
name|context
operator|=
name|extract_signed_integer
argument_list|(
name|mthread
operator|->
name|cproc
operator|->
name|raw_cproc
operator|+
name|CPROC_CONTEXT_OFFSET
argument_list|,
name|CPROC_CONTEXT_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|mthread
operator|->
name|sp
operator|=
name|context
operator|+
name|MACHINE_CPROC_SP_OFFSET
expr_stmt|;
if|if
condition|(
name|mach3_read_inferior
argument_list|(
name|context
operator|+
name|MACHINE_CPROC_PC_OFFSET
argument_list|,
operator|&
name|mthread
operator|->
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Can't read cproc pc from inferior"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mach3_read_inferior
argument_list|(
name|context
operator|+
name|MACHINE_CPROC_FP_OFFSET
argument_list|,
operator|&
name|mthread
operator|->
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Can't read cproc fp from inferior"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FETCH_CPROC_STATE */
end_comment

begin_escape
end_escape

begin_function
name|void
name|thread_list_command
parameter_list|()
block|{
name|thread_basic_info_data_t
name|ths
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
name|gdb_thread_t
name|cprocs
decl_stmt|;
name|gdb_thread_t
name|scan
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|selected
decl_stmt|;
name|char
modifier|*
name|wired
decl_stmt|;
name|int
name|infoCnt
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|mach_port_t
name|mid_or_port
decl_stmt|;
name|gdb_thread_t
name|their_threads
decl_stmt|;
name|gdb_thread_t
name|kthread
decl_stmt|;
name|int
name|neworder
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"There are %d kernel threads in task %d.\n"
decl_stmt|;
name|int
name|tmid
init|=
name|map_port_name_to_mid
argument_list|(
name|inferior_task
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
name|thread_count
operator|=
name|fetch_thread_info
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|their_threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_count
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|thread_count
operator|==
literal|1
condition|)
name|fmt
operator|=
literal|"There is %d kernel thread in task %d.\n"
expr_stmt|;
name|printf_filtered
argument_list|(
name|fmt
argument_list|,
name|thread_count
argument_list|,
name|tmid
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|TL_HEADER
argument_list|)
expr_stmt|;
name|cprocs
operator|=
name|get_cprocs
argument_list|()
expr_stmt|;
name|map_cprocs_to_kernel_threads
argument_list|(
name|cprocs
argument_list|,
name|their_threads
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|cprocs
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|int
name|mid
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|char
name|slot
index|[
literal|3
index|]
decl_stmt|;
name|int
name|cproc_state
init|=
name|extract_signed_integer
argument_list|(
name|scan
operator|->
name|raw_cproc
operator|+
name|CPROC_STATE_OFFSET
argument_list|,
name|CPROC_STATE_SIZE
argument_list|)
decl_stmt|;
name|selected
operator|=
literal|' '
expr_stmt|;
comment|/* a wired cproc? */
name|wired
operator|=
operator|(
name|extract_address
argument_list|(
name|scan
operator|->
name|raw_cproc
operator|+
name|CPROC_WIRED_OFFSET
argument_list|,
name|CPROC_WIRED_SIZE
argument_list|)
condition|?
literal|"wired"
else|:
literal|""
operator|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|reverse_map
operator|!=
operator|-
literal|1
condition|)
name|kthread
operator|=
operator|(
name|their_threads
operator|+
name|scan
operator|->
name|reverse_map
operator|)
expr_stmt|;
else|else
name|kthread
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kthread
condition|)
block|{
comment|/* These cprocs have a kernel thread */
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|kthread
operator|->
name|name
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
name|infoCnt
operator|=
name|THREAD_BASIC_INFO_COUNT
expr_stmt|;
name|ret
operator|=
name|thread_info
argument_list|(
name|kthread
operator|->
name|name
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|ths
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to get basic info on thread %d : %s"
argument_list|,
name|mid
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Who is the first to have more than 100 threads */
name|sprintf
argument_list|(
name|slot
argument_list|,
literal|"%d"
argument_list|,
name|kthread
operator|->
name|slotid
operator|%
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|kthread
operator|->
name|name
operator|==
name|current_thread
condition|)
name|selected
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
name|ths
operator|.
name|suspend_count
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ths
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|'\000'
expr_stmt|;
if|#
directive|if
literal|0
block|if (ths.flags& TH_FLAGS_SWAPPED) 	    strcat (buf, "S");
endif|#
directive|endif
if|if
condition|(
name|ths
operator|.
name|flags
operator|&
name|TH_FLAGS_IDLE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|TL_FORMAT
argument_list|,
name|slot
argument_list|,
name|mid
argument_list|,
name|selected
argument_list|,
name|get_thread_name
argument_list|(
name|scan
argument_list|,
name|kthread
operator|->
name|slotid
argument_list|)
argument_list|,
name|kthread
operator|->
name|in_emulator
condition|?
literal|"E"
else|:
literal|""
argument_list|,
name|translate_state
argument_list|(
name|ths
operator|.
name|run_state
argument_list|)
argument_list|,
name|buf
argument_list|,
name|translate_cstate
argument_list|(
name|cproc_state
argument_list|)
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|print_tl_address
argument_list|(
name|gdb_stdout
argument_list|,
name|kthread
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* These cprocs don't have a kernel thread. 	   * find out the calling frame with  	   * FETCH_CPROC_STATE. 	   */
name|struct
name|gdb_thread
name|state
decl_stmt|;
if|#
directive|if
literal|0
comment|/* jtv -> emcmanus: why do you want this here? */
block|if (scan->incarnation == NULL) 	    continue;
comment|/* EMcM */
endif|#
directive|endif
name|printf_filtered
argument_list|(
name|TL_FORMAT
argument_list|,
literal|"-"
argument_list|,
operator|-
name|neworder
argument_list|,
comment|/* Pseudo MID */
name|selected
argument_list|,
name|get_thread_name
argument_list|(
name|scan
argument_list|,
operator|-
name|neworder
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|"-"
argument_list|,
comment|/* kernel state */
literal|""
argument_list|,
name|translate_cstate
argument_list|(
name|cproc_state
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|state
operator|.
name|cproc
operator|=
name|scan
expr_stmt|;
if|if
condition|(
name|FETCH_CPROC_STATE
argument_list|(
operator|&
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|puts_filtered
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
else|else
name|print_tl_address
argument_list|(
name|gdb_stdout
argument_list|,
name|state
operator|.
name|pc
argument_list|)
expr_stmt|;
name|neworder
operator|++
expr_stmt|;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Scan for kernel threads without cprocs */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|their_threads
index|[
name|index
index|]
operator|.
name|cproc
condition|)
block|{
name|int
name|mid
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|char
name|slot
index|[
literal|3
index|]
decl_stmt|;
name|mach_port_t
name|name
init|=
name|their_threads
index|[
name|index
index|]
operator|.
name|name
decl_stmt|;
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|name
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
name|infoCnt
operator|=
name|THREAD_BASIC_INFO_COUNT
expr_stmt|;
name|ret
operator|=
name|thread_info
argument_list|(
name|name
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|ths
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to get basic info on thread %d : %s"
argument_list|,
name|mid
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sprintf
argument_list|(
name|slot
argument_list|,
literal|"%d"
argument_list|,
name|index
operator|%
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|current_thread
condition|)
name|selected
operator|=
literal|'*'
expr_stmt|;
else|else
name|selected
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|ths
operator|.
name|suspend_count
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ths
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|'\000'
expr_stmt|;
if|#
directive|if
literal|0
block|if (ths.flags& TH_FLAGS_SWAPPED) 	    strcat (buf, "S");
endif|#
directive|endif
if|if
condition|(
name|ths
operator|.
name|flags
operator|&
name|TH_FLAGS_IDLE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|TL_FORMAT
argument_list|,
name|slot
argument_list|,
name|mid
argument_list|,
name|selected
argument_list|,
name|get_thread_name
argument_list|(
name|NULL
argument_list|,
name|index
argument_list|)
argument_list|,
name|their_threads
index|[
name|index
index|]
operator|.
name|in_emulator
condition|?
literal|"E"
else|:
literal|""
argument_list|,
name|translate_state
argument_list|(
name|ths
operator|.
name|run_state
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|""
argument_list|,
comment|/* No cproc state */
literal|""
argument_list|)
expr_stmt|;
comment|/* Can't be wired */
name|print_tl_address
argument_list|(
name|gdb_stdout
argument_list|,
name|their_threads
index|[
name|index
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_free
argument_list|(
name|cproc_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|cproc_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|thread_select_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|mid
decl_stmt|;
name|thread_array_t
name|thread_list
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|is_slot
init|=
literal|0
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"MID or @SLOTNUMBER to specify a thread to select"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'@'
condition|)
block|{
name|is_slot
operator|++
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
name|mid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|is_slot
operator|||
operator|*
name|args
operator|!=
literal|'0'
condition|)
comment|/* Rudimentary checks */
name|error
argument_list|(
literal|"You must select threads by MID or @SLOTNUMBER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
name|mid
argument_list|,
name|is_slot
condition|?
literal|2
else|:
literal|1
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
return|return;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Thread %d selected\n"
argument_list|,
name|is_slot
condition|?
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
else|:
name|mid
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|thread_trace
argument_list|(
argument|thread
argument_list|,
argument|set
argument_list|)
end_macro

begin_decl_stmt
name|mach_port_t
name|thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|set
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flavor
init|=
name|TRACE_FLAVOR
decl_stmt|;
name|unsigned
name|int
name|stateCnt
init|=
name|TRACE_FLAVOR_SIZE
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|thread_state_data_t
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|thread
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"thread_trace: invalid thread"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|must_suspend_thread
condition|)
name|setup_thread
argument_list|(
name|thread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_get_state
argument_list|(
name|thread
argument_list|,
name|flavor
argument_list|,
name|state
argument_list|,
operator|&
name|stateCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"thread_trace: error reading thread state"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|TRACE_SET
argument_list|(
name|thread
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TRACE_CLEAR
argument_list|(
name|thread
argument_list|,
name|state
argument_list|)
condition|)
block|{
if|if
condition|(
name|must_suspend_thread
condition|)
name|setup_thread
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ret
operator|=
name|thread_set_state
argument_list|(
name|thread
argument_list|,
name|flavor
argument_list|,
name|state
argument_list|,
name|stateCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"thread_trace: error writing thread state"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_suspend_thread
condition|)
name|setup_thread
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|FLUSH_INFERIOR_CACHE
end_ifdef

begin_comment
comment|/* When over-writing code on some machines the I-Cache must be flushed    explicitly, because it is not kept coherent by the lazy hardware.    This definitely includes breakpoints, for instance, or else we    end up looping in mysterious Bpt traps */
end_comment

begin_macro
name|flush_inferior_icache
argument_list|(
argument|pc
argument_list|,
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vm_machine_attribute_val_t
name|flush
init|=
name|MATTR_VAL_ICACHE_FLUSH
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|ret
operator|=
name|vm_machine_attribute
argument_list|(
name|inferior_task
argument_list|,
name|pc
argument_list|,
name|amount
argument_list|,
name|MATTR_CACHE
argument_list|,
operator|&
name|flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Error flushing inferior's cache : %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|FLUSH_INFERIOR_CACHE
end_endif

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|suspend_all_threads
argument_list|(
argument|from_tty
argument_list|)
name|int
name|from_tty
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|thread_array_t
name|thread_list
decl_stmt|;
name|int
name|thread_count
decl_stmt|,
name|index
decl_stmt|;
name|int
name|infoCnt
decl_stmt|;
name|thread_basic_info_data_t
name|th_info
decl_stmt|;
name|ret
operator|=
name|task_threads
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|thread_list
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"Could not suspend inferior threads."
argument_list|)
expr_stmt|;
name|m3_kill_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
name|int
name|mid
decl_stmt|;
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_suspend
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Error trying to suspend thread %d : %s"
argument_list|,
name|mid
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|infoCnt
operator|=
name|THREAD_BASIC_INFO_COUNT
expr_stmt|;
name|ret
operator|=
name|thread_info
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|th_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"suspend can't get thread info"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Thread %d suspend count is %d"
argument_list|,
name|mid
argument_list|,
name|th_info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
block|}
block|}
name|consume_send_rights
argument_list|(
name|thread_list
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Error trying to deallocate thread list"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|thread_suspend_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|mach_port_t
name|saved_thread
decl_stmt|;
name|int
name|infoCnt
decl_stmt|;
name|thread_basic_info_data_t
name|th_info
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|suspend_all_threads
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
name|saved_thread
operator|=
name|current_thread
expr_stmt|;
name|mid
operator|=
name|parse_thread_id
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"You can suspend only existing kernel threads with MID or @SLOTNUMBER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
name|mid
argument_list|,
literal|0
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|current_thread
condition|)
name|current_thread
operator|=
name|saved_thread
expr_stmt|;
name|error
argument_list|(
literal|"Could not select thread %d"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|thread_suspend
argument_list|(
name|current_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"thread_suspend failed : %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|infoCnt
operator|=
name|THREAD_BASIC_INFO_COUNT
expr_stmt|;
name|ret
operator|=
name|thread_info
argument_list|(
name|current_thread
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|th_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"suspend can't get thread info"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Thread %d suspend count is %d"
argument_list|,
name|mid
argument_list|,
name|th_info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|saved_thread
expr_stmt|;
block|}
end_function

begin_macro
name|resume_all_threads
argument_list|(
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|thread_array_t
name|thread_list
decl_stmt|;
name|int
name|thread_count
decl_stmt|,
name|index
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|infoCnt
decl_stmt|;
name|thread_basic_info_data_t
name|th_info
decl_stmt|;
name|ret
operator|=
name|task_threads
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|thread_list
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|m3_kill_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"task_threads"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
name|infoCnt
operator|=
name|THREAD_BASIC_INFO_COUNT
expr_stmt|;
name|ret
operator|=
name|thread_info
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|th_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"resume_all can't get thread info"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|th_info
operator|.
name|suspend_count
condition|)
block|{
if|if
condition|(
name|mid
operator|!=
operator|-
literal|1
operator|&&
name|from_tty
condition|)
name|warning
argument_list|(
literal|"Thread %d is not suspended"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ret
operator|=
name|thread_resume
argument_list|(
name|thread_list
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Error trying to resume thread %d : %s"
argument_list|,
name|mid
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mid
operator|!=
operator|-
literal|1
operator|&&
name|from_tty
condition|)
name|warning
argument_list|(
literal|"Thread %d suspend count is %d"
argument_list|,
name|mid
argument_list|,
operator|--
name|th_info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
block|}
name|consume_send_rights
argument_list|(
name|thread_list
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Error trying to deallocate thread list"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|thread_resume_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|mid
decl_stmt|;
name|mach_port_t
name|saved_thread
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|thread_basic_info_data_t
name|th_info
decl_stmt|;
name|int
name|infoCnt
init|=
name|THREAD_BASIC_INFO_COUNT
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|resume_all_threads
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
name|saved_thread
operator|=
name|current_thread
expr_stmt|;
name|mid
operator|=
name|parse_thread_id
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"You can resume only existing kernel threads with MID or @SLOTNUMBER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
name|mid
argument_list|,
literal|0
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|current_thread
condition|)
name|current_thread
operator|=
name|saved_thread
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|thread_info
argument_list|(
name|current_thread
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|th_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"resume can't get thread info"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|th_info
operator|.
name|suspend_count
condition|)
block|{
name|warning
argument_list|(
literal|"Thread %d is not suspended"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|thread_resume
argument_list|(
name|current_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"thread_resume failed : %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|th_info
operator|.
name|suspend_count
operator|--
expr_stmt|;
name|warning
argument_list|(
literal|"Thread %d suspend count is %d"
argument_list|,
name|mid
argument_list|,
name|th_info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|current_thread
operator|=
name|saved_thread
expr_stmt|;
block|}
end_function

begin_function
name|void
name|thread_kill_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|mid
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|int
name|thread_count
decl_stmt|;
name|thread_array_t
name|thread_table
decl_stmt|;
name|int
name|index
decl_stmt|;
name|mach_port_t
name|thread_to_kill
init|=
name|MACH_PORT_NULL
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"thread mid to kill from the inferior task"
argument_list|)
expr_stmt|;
name|mid
operator|=
name|parse_thread_id
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"You can kill only existing kernel threads with MID or @SLOTNUMBER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
condition|)
block|{
name|ret
operator|=
name|machid_mach_port
argument_list|(
name|mid_server
argument_list|,
name|mid_auth
argument_list|,
name|mid
argument_list|,
operator|&
name|thread_to_kill
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"thread_kill_command: machid_mach_port map failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|current_thread
argument_list|,
name|MACH_TYPE_THREAD
argument_list|)
expr_stmt|;
comment|/* Don't allow gdb to kill *any* thread in the system. Use mkill program for that */
name|ret
operator|=
name|task_threads
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|thread_table
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Error getting inferior's thread list"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_to_kill
operator|==
name|current_thread
condition|)
block|{
name|ret
operator|=
name|thread_terminate
argument_list|(
name|thread_to_kill
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Thread could not be terminated"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Last thread was killed, use \"kill\" command to kill task"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|thread_table
index|[
name|index
index|]
operator|==
name|thread_to_kill
condition|)
block|{
name|ret
operator|=
name|thread_terminate
argument_list|(
name|thread_to_kill
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Thread could not be terminated"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thread_count
operator|>
literal|1
condition|)
name|consume_send_rights
argument_list|(
name|thread_table
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_table
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Error trying to deallocate thread list"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Thread %d killed"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Task specific commands; add more if you like */
end_comment

begin_function
name|void
name|task_resume_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|task_basic_info_data_t
name|ta_info
decl_stmt|;
name|int
name|infoCnt
init|=
name|TASK_BASIC_INFO_COUNT
decl_stmt|;
name|int
name|mid
init|=
name|map_port_name_to_mid
argument_list|(
name|inferior_task
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
comment|/* Would be trivial to change, but is it desirable? */
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Currently gdb can resume only it's inferior task"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_info
argument_list|(
name|inferior_task
argument_list|,
name|TASK_BASIC_INFO
argument_list|,
operator|(
name|task_info_t
operator|)
operator|&
name|ta_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_resume_command: task_info failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta_info
operator|.
name|suspend_count
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Inferior task %d is not suspended"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ta_info
operator|.
name|suspend_count
operator|==
literal|1
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Suspend count is now 1. Do you know what you are doing? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Task not resumed"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_resume
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_resume_command: task_resume"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta_info
operator|.
name|suspend_count
operator|==
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Inferior task %d is no longer suspended"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|must_suspend_thread
operator|=
literal|1
expr_stmt|;
comment|/* @@ This is not complete: Registers change all the time when not 	 suspended! */
name|registers_changed
argument_list|()
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"Inferior task %d suspend count is now %d"
argument_list|,
name|mid
argument_list|,
name|ta_info
operator|.
name|suspend_count
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|task_suspend_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|task_basic_info_data_t
name|ta_info
decl_stmt|;
name|int
name|infoCnt
init|=
name|TASK_BASIC_INFO_COUNT
decl_stmt|;
name|int
name|mid
init|=
name|map_port_name_to_mid
argument_list|(
name|inferior_task
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
comment|/* Would be trivial to change, but is it desirable? */
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Currently gdb can suspend only it's inferior task"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_suspend
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_suspend_command: task_suspend"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|must_suspend_thread
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|task_info
argument_list|(
name|inferior_task
argument_list|,
name|TASK_BASIC_INFO
argument_list|,
operator|(
name|task_info_t
operator|)
operator|&
name|ta_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_suspend_command: task_info failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Inferior task %d suspend count is now %d"
argument_list|,
name|mid
argument_list|,
name|ta_info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_size
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
specifier|static
name|char
name|size
index|[
literal|30
index|]
decl_stmt|;
name|int
name|zz
init|=
name|bytes
operator|/
literal|1024
decl_stmt|;
if|if
condition|(
name|zz
operator|/
literal|1024
condition|)
name|sprintf
argument_list|(
name|size
argument_list|,
literal|"%-2.1f M"
argument_list|,
operator|(
operator|(
name|float
operator|)
name|bytes
operator|)
operator|/
operator|(
literal|1024.0
operator|*
literal|1024.0
operator|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|size
argument_list|,
literal|"%d K"
argument_list|,
name|zz
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Does this require the target task to be suspended?? I don't think so. */
end_comment

begin_function
name|void
name|task_info_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|mid
init|=
operator|-
literal|5
decl_stmt|;
name|mach_port_t
name|task
decl_stmt|;
name|kern_return_t
name|ret
decl_stmt|;
name|task_basic_info_data_t
name|ta_info
decl_stmt|;
name|int
name|infoCnt
init|=
name|TASK_BASIC_INFO_COUNT
decl_stmt|;
name|int
name|page_size
init|=
name|round_page
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|thread_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|inferior_task
argument_list|)
condition|)
name|mid
operator|=
name|map_port_name_to_mid
argument_list|(
name|inferior_task
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
expr_stmt|;
name|task
operator|=
name|inferior_task
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|int
name|tmid
init|=
name|atoi
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmid
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid mid %d for task info"
argument_list|,
name|tmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmid
operator|!=
name|mid
condition|)
block|{
name|mid
operator|=
name|tmid
expr_stmt|;
name|ret
operator|=
name|machid_mach_port
argument_list|(
name|mid_server
argument_list|,
name|mid_auth
argument_list|,
name|tmid
argument_list|,
operator|&
name|task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_info_command: machid_mach_port map failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"You have to give the task MID as an argument"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|task_info
argument_list|(
name|task
argument_list|,
name|TASK_BASIC_INFO
argument_list|,
operator|(
name|task_info_t
operator|)
operator|&
name|ta_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_info_command: task_info failed"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nTask info for task %d:\n\n"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Suspend count : %d\n"
argument_list|,
name|ta_info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Base priority : %d\n"
argument_list|,
name|ta_info
operator|.
name|base_priority
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Virtual size  : %s\n"
argument_list|,
name|get_size
argument_list|(
name|ta_info
operator|.
name|virtual_size
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Resident size : %s\n"
argument_list|,
name|get_size
argument_list|(
name|ta_info
operator|.
name|resident_size
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|thread_array_t
name|thread_list
decl_stmt|;
name|ret
operator|=
name|task_threads
argument_list|(
name|task
argument_list|,
operator|&
name|thread_list
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_info_command: task_threads"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Thread count  : %d\n"
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
name|consume_send_rights
argument_list|(
name|thread_list
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
operator|(
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Error trying to deallocate thread list"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_emulator_p
argument_list|(
name|task
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|" Emulator at   : 0x%x..0x%x\n"
argument_list|,
name|EMULATOR_BASE
argument_list|,
name|EMULATOR_END
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" No emulator.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_count
operator|&&
name|task
operator|==
name|inferior_task
condition|)
name|printf_filtered
argument_list|(
literal|"\nUse the \"thread list\" command to see the threads\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* You may either FORWARD the exception to the inferior, or KEEP  * it and return to GDB command level.  *  * exception mid [ forward | keep ]  */
end_comment

begin_function
specifier|static
name|void
name|exception_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|scan
init|=
name|args
decl_stmt|;
name|int
name|exception
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"exception number action"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
condition|)
name|scan
operator|++
expr_stmt|;
if|if
condition|(
literal|'0'
operator|<=
operator|*
name|scan
operator|&&
operator|*
name|scan
operator|<=
literal|'9'
condition|)
while|while
condition|(
literal|'0'
operator|<=
operator|*
name|scan
operator|&&
operator|*
name|scan
operator|<=
literal|'9'
condition|)
name|scan
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"exception number action"
argument_list|)
expr_stmt|;
name|exception
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|exception
operator|<=
literal|0
operator|||
name|exception
operator|>
name|MAX_EXCEPTION
condition|)
name|error
argument_list|(
literal|"Allowed exception numbers are in range 1..%d"
argument_list|,
name|MAX_EXCEPTION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scan
operator|!=
literal|' '
operator|&&
operator|*
name|scan
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"exception number must be followed by a space"
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
condition|)
name|scan
operator|++
expr_stmt|;
name|args
operator|=
name|scan
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|scan
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|len
condition|)
name|error
argument_list|(
literal|"exception number action"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"forward"
argument_list|,
name|len
argument_list|)
condition|)
name|exception_map
index|[
name|exception
index|]
operator|.
name|forward
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"keep"
argument_list|,
name|len
argument_list|)
condition|)
name|exception_map
index|[
name|exception
index|]
operator|.
name|forward
operator|=
name|FALSE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"exception action is either \"keep\" or \"forward\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_exception_info
parameter_list|(
name|exception
parameter_list|)
name|int
name|exception
decl_stmt|;
block|{
name|boolean_t
name|forward
init|=
name|exception_map
index|[
name|exception
index|]
operator|.
name|forward
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t(%d): "
argument_list|,
name|exception_map
index|[
name|exception
index|]
operator|.
name|name
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forward
condition|)
if|if
condition|(
name|exception_map
index|[
name|exception
index|]
operator|.
name|sigmap
operator|!=
name|SIG_UNKNOWN
condition|)
name|printf_filtered
argument_list|(
literal|"keep and handle as signal %d\n"
argument_list|,
name|exception_map
index|[
name|exception
index|]
operator|.
name|sigmap
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"keep and handle as unknown signal %d\n"
argument_list|,
name|exception_map
index|[
name|exception
index|]
operator|.
name|sigmap
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"forward exception to inferior\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exception_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|exception
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
for|for
control|(
name|exception
operator|=
literal|1
init|;
name|exception
operator|<=
name|MAX_EXCEPTION
condition|;
name|exception
operator|++
control|)
name|print_exception_info
argument_list|(
name|exception
argument_list|)
expr_stmt|;
else|else
block|{
name|exception
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|exception
operator|<=
literal|0
operator|||
name|exception
operator|>
name|MAX_EXCEPTION
condition|)
name|error
argument_list|(
literal|"Invalid exception number, values from 1 to %d allowed"
argument_list|,
name|MAX_EXCEPTION
argument_list|)
expr_stmt|;
name|print_exception_info
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check for actions for mach exceptions.  */
end_comment

begin_macro
name|mach3_exception_actions
argument_list|(
argument|w
argument_list|,
argument|force_print_only
argument_list|,
argument|who
argument_list|)
end_macro

begin_decl_stmt
name|WAITTYPE
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|force_print_only
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|who
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|boolean_t
name|force_print
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|force_print_only
operator|||
name|exception_map
index|[
name|stop_exception
index|]
operator|.
name|sigmap
operator|==
name|SIG_UNKNOWN
condition|)
name|force_print
operator|=
name|TRUE
expr_stmt|;
else|else
name|WSETSTOP
argument_list|(
operator|*
name|w
argument_list|,
name|exception_map
index|[
name|stop_exception
index|]
operator|.
name|sigmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|exception_map
index|[
name|stop_exception
index|]
operator|.
name|print
operator|||
name|force_print
condition|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n%s received %s exception : "
argument_list|,
name|who
argument_list|,
name|exception_map
index|[
name|stop_exception
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stop_exception
condition|)
block|{
case|case
name|EXC_BAD_ACCESS
case|:
name|printf_filtered
argument_list|(
literal|"referencing address 0x%x : %s\n"
argument_list|,
name|stop_subcode
argument_list|,
name|mach_error_string
argument_list|(
name|stop_code
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_BAD_INSTRUCTION
case|:
name|printf_filtered
argument_list|(
literal|"illegal or undefined instruction. code %d subcode %d\n"
argument_list|,
name|stop_code
argument_list|,
name|stop_subcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_ARITHMETIC
case|:
name|printf_filtered
argument_list|(
literal|"code %d\n"
argument_list|,
name|stop_code
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_EMULATION
case|:
name|printf_filtered
argument_list|(
literal|"code %d subcode %d\n"
argument_list|,
name|stop_code
argument_list|,
name|stop_subcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_SOFTWARE
case|:
name|printf_filtered
argument_list|(
literal|"%s specific, code 0x%x\n"
argument_list|,
name|stop_code
operator|<
literal|0xffff
condition|?
literal|"hardware"
else|:
literal|"os emulation"
argument_list|,
name|stop_code
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_BREAKPOINT
case|:
name|printf_filtered
argument_list|(
literal|"type %d (machine dependent)\n"
argument_list|,
name|stop_code
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"Unknown exception"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|setup_notify_port
argument_list|(
argument|create_new
argument_list|)
end_macro

begin_decl_stmt
name|int
name|create_new
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
name|MACH_PORT_VALID
argument_list|(
name|our_notify_port
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|our_notify_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Could not destroy our_notify_port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|our_notify_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|notify_chain
operator|=
operator|(
name|port_chain_t
operator|)
name|NULL
expr_stmt|;
name|port_chain_destroy
argument_list|(
name|port_chain_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|create_new
condition|)
block|{
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|our_notify_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"Creating notify port %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|our_notify_port
argument_list|,
name|inferior_wait_port_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"initial move member %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Register our message port to the net name server  *  * Currently used only by the external stop-gdb program  * since ^C does not work if you would like to enter  * gdb command level while debugging your program.  *  * NOTE: If the message port is sometimes used for other  * purposes also, the NAME must not be a guessable one.  * Then, there should be a way to change it.  */
end_comment

begin_decl_stmt
name|char
name|registered_name
index|[
name|MAX_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|message_port_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|registered_name
index|[
literal|0
index|]
condition|)
name|printf_filtered
argument_list|(
literal|"gdb's message port name: '%s'\n"
argument_list|,
name|registered_name
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"gdb's message port is not currently registered\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gdb_register_port
parameter_list|(
name|name
parameter_list|,
name|port
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|mach_port_t
name|port
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
specifier|static
name|int
name|already_signed
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|port
argument_list|)
operator|||
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
block|{
name|warning
argument_list|(
literal|"Invalid registration request"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|already_signed
condition|)
block|{
name|ret
operator|=
name|mach_port_insert_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|our_message_port
argument_list|,
name|our_message_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Failed to create a signature to our_message_port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|already_signed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|already_signed
operator|>
literal|1
condition|)
block|{
name|ret
operator|=
name|netname_check_out
argument_list|(
name|name_server_port
argument_list|,
name|registered_name
argument_list|,
name|our_message_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Failed to check out gdb's message port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|registered_name
index|[
literal|0
index|]
operator|=
literal|'\000'
expr_stmt|;
name|already_signed
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|netname_check_in
argument_list|(
name|name_server_port
argument_list|,
comment|/* Name server port */
name|name
argument_list|,
comment|/* Name of service */
name|our_message_port
argument_list|,
comment|/* Signature */
name|port
argument_list|)
expr_stmt|;
comment|/* Creates a new send right */
name|CHK
argument_list|(
literal|"Failed to check in the port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|MAX_NAME_LEN
operator|&&
operator|*
operator|(
name|name
operator|+
name|len
operator|)
condition|)
block|{
name|registered_name
index|[
name|len
index|]
operator|=
operator|*
operator|(
name|name
operator|+
name|len
operator|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|registered_name
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|already_signed
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmd_thread_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmd_task_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|thread_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"thread\" must be followed by the name of a thread command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|cmd_thread_list
argument_list|,
literal|"thread "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|task_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"task\" must be followed by the name of a task command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|cmd_task_list
argument_list|,
literal|"task "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|add_mach_specific_commands
argument_list|()
end_macro

begin_block
block|{
comment|/* Thread handling commands */
comment|/* FIXME: Move our thread support into the generic thread.c stuff so we      can share that code.  */
name|add_prefix_cmd
argument_list|(
literal|"mthread"
argument_list|,
name|class_stack
argument_list|,
name|thread_command
argument_list|,
literal|"Generic command for handling Mach threads in the debugged task."
argument_list|,
operator|&
name|cmd_thread_list
argument_list|,
literal|"thread "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"th"
argument_list|,
literal|"mthread"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"select"
argument_list|,
name|class_stack
argument_list|,
name|thread_select_command
argument_list|,
literal|"Select and print MID of the selected thread"
argument_list|,
operator|&
name|cmd_thread_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"list"
argument_list|,
name|class_stack
argument_list|,
name|thread_list_command
argument_list|,
literal|"List info of task's threads. Selected thread is marked with '*'"
argument_list|,
operator|&
name|cmd_thread_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"suspend"
argument_list|,
name|class_run
argument_list|,
name|thread_suspend_command
argument_list|,
literal|"Suspend one or all of the threads in the selected task."
argument_list|,
operator|&
name|cmd_thread_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"resume"
argument_list|,
name|class_run
argument_list|,
name|thread_resume_command
argument_list|,
literal|"Resume one or all of the threads in the selected task."
argument_list|,
operator|&
name|cmd_thread_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"kill"
argument_list|,
name|class_run
argument_list|,
name|thread_kill_command
argument_list|,
literal|"Kill the specified thread MID from inferior task."
argument_list|,
operator|&
name|cmd_thread_list
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The rest of this support (condition_thread) was not merged.  It probably      should not be merged in this form, but instead added to the generic GDB      thread support.  */
block|add_cmd ("break", class_breakpoint, condition_thread, 	   "Breakpoint N will only be effective for thread MID or @SLOT\n\ 	    If MID/@SLOT is omitted allow all threads to break at breakpoint",&cmd_thread_list);
endif|#
directive|endif
comment|/* Thread command shorthands (for backward compatibility) */
name|add_alias_cmd
argument_list|(
literal|"ts"
argument_list|,
literal|"mthread select"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"tl"
argument_list|,
literal|"mthread list"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* task handling commands */
name|add_prefix_cmd
argument_list|(
literal|"task"
argument_list|,
name|class_stack
argument_list|,
name|task_command
argument_list|,
literal|"Generic command for handling debugged task."
argument_list|,
operator|&
name|cmd_task_list
argument_list|,
literal|"task "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ta"
argument_list|,
literal|"task"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"suspend"
argument_list|,
name|class_run
argument_list|,
name|task_suspend_command
argument_list|,
literal|"Suspend the inferior task."
argument_list|,
operator|&
name|cmd_task_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"resume"
argument_list|,
name|class_run
argument_list|,
name|task_resume_command
argument_list|,
literal|"Resume the inferior task."
argument_list|,
operator|&
name|cmd_task_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"info"
argument_list|,
name|no_class
argument_list|,
name|task_info_command
argument_list|,
literal|"Print information about the specified task."
argument_list|,
operator|&
name|cmd_task_list
argument_list|)
expr_stmt|;
comment|/* Print my message port name */
name|add_info
argument_list|(
literal|"message-port"
argument_list|,
name|message_port_info
argument_list|,
literal|"Returns the name of gdb's message port in the netnameserver"
argument_list|)
expr_stmt|;
comment|/* Exception commands */
name|add_info
argument_list|(
literal|"exceptions"
argument_list|,
name|exception_info
argument_list|,
literal|"What debugger does when program gets various exceptions.\n\ Specify an exception number as argument to print info on that\n\ exception only."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"exception"
argument_list|,
name|class_run
argument_list|,
name|exception_command
argument_list|,
literal|"Specify how to handle an exception.\n\ Args are exception number followed by \"forward\" or \"keep\".\n\ `Forward' means forward the exception to the program's normal exception\n\ handler.\n\ `Keep' means reenter debugger if this exception happens, and GDB maps\n\ the exception to some signal (see info exception)\n\ Normally \"keep\" is used to return to GDB on exception."
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|kern_return_t
name|do_mach_notify_dead_name
parameter_list|(
name|notify
parameter_list|,
name|name
parameter_list|)
name|mach_port_t
name|notify
decl_stmt|;
name|mach_port_t
name|name
decl_stmt|;
block|{
name|kern_return_t
name|kr
init|=
name|KERN_SUCCESS
decl_stmt|;
comment|/* Find the thing that notified */
name|port_chain_t
name|element
init|=
name|port_chain_member
argument_list|(
name|notify_chain
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* Take name of from unreceived dead name notification list */
name|notify_chain
operator|=
name|port_chain_delete
argument_list|(
name|notify_chain
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|element
condition|)
name|error
argument_list|(
literal|"Received a dead name notify from unchained port (0x%x)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|element
operator|->
name|type
condition|)
block|{
case|case
name|MACH_TYPE_THREAD
case|:
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|current_thread
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nCurrent thread %d died"
argument_list|,
name|element
operator|->
name|mid
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"\nThread %d died"
argument_list|,
name|element
operator|->
name|mid
argument_list|)
expr_stmt|;
break|break;
case|case
name|MACH_TYPE_TASK
case|:
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|inferior_task
condition|)
name|printf_filtered
argument_list|(
literal|"Task %d died, but it was not the selected task"
argument_list|,
name|element
operator|->
name|mid
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Current task %d died"
argument_list|,
name|element
operator|->
name|mid
argument_list|)
expr_stmt|;
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|inferior_task
operator|=
name|MACH_PORT_NULL
expr_stmt|;
if|if
condition|(
name|notify_chain
condition|)
name|warning
argument_list|(
literal|"There were still unreceived dead_name_notifications???"
argument_list|)
expr_stmt|;
comment|/* Destroy the old notifications */
name|setup_notify_port
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x"
argument_list|,
name|name
argument_list|,
name|element
operator|->
name|type
argument_list|,
name|element
operator|->
name|mid
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_function
name|kern_return_t
name|do_mach_notify_msg_accepted
parameter_list|(
name|notify
parameter_list|,
name|name
parameter_list|)
name|mach_port_t
name|notify
decl_stmt|;
name|mach_port_t
name|name
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"do_mach_notify_msg_accepted : notify %x, name %x"
argument_list|,
name|notify
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_function
name|kern_return_t
name|do_mach_notify_no_senders
parameter_list|(
name|notify
parameter_list|,
name|mscount
parameter_list|)
name|mach_port_t
name|notify
decl_stmt|;
name|mach_port_mscount_t
name|mscount
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"do_mach_notify_no_senders : notify %x, mscount %x"
argument_list|,
name|notify
argument_list|,
name|mscount
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_function
name|kern_return_t
name|do_mach_notify_port_deleted
parameter_list|(
name|notify
parameter_list|,
name|name
parameter_list|)
name|mach_port_t
name|notify
decl_stmt|;
name|mach_port_t
name|name
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"do_mach_notify_port_deleted : notify %x, name %x"
argument_list|,
name|notify
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_function
name|kern_return_t
name|do_mach_notify_port_destroyed
parameter_list|(
name|notify
parameter_list|,
name|rights
parameter_list|)
name|mach_port_t
name|notify
decl_stmt|;
name|mach_port_t
name|rights
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"do_mach_notify_port_destroyed : notify %x, rights %x"
argument_list|,
name|notify
argument_list|,
name|rights
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_function
name|kern_return_t
name|do_mach_notify_send_once
parameter_list|(
name|notify
parameter_list|)
name|mach_port_t
name|notify
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DUMP_SYSCALL
comment|/* MANY of these are generated. */
name|warning
argument_list|(
literal|"do_mach_notify_send_once : notify %x"
argument_list|,
name|notify
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Kills the inferior. It's gone when you call this */
end_comment

begin_function
specifier|static
name|void
name|kill_inferior_fast
parameter_list|()
block|{
name|WAITTYPE
name|w
decl_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
operator|||
name|inferior_pid
operator|==
literal|1
condition|)
return|return;
comment|/* kill() it, since the Unix server does not otherwise notice when    * killed with task_terminate().    */
if|if
condition|(
name|inferior_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|inferior_pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
comment|/* It's propably terminate already */
operator|(
name|void
operator|)
name|task_terminate
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|inferior_task
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|current_thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setup_notify_port
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|m3_kill_inferior
parameter_list|()
block|{
name|kill_inferior_fast
argument_list|()
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|m3_mourn_inferior
parameter_list|()
block|{
name|unpush_target
argument_list|(
operator|&
name|m3_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fork an inferior process, and start debugging it.  */
end_comment

begin_function
specifier|static
name|void
name|m3_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|m3_trace_me
argument_list|,
name|m3_trace_him
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach"    commands.  */
end_comment

begin_function
specifier|static
name|int
name|m3_can_run
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mach 3.0 does not need ptrace for anything  * Make sure nobody uses it on mach.  */
end_comment

begin_macro
name|ptrace
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
literal|"Lose, Lose! Somebody called ptrace\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|m3_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signal
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|thread_basic_info_data_t
name|th_info
decl_stmt|;
name|unsigned
name|int
name|infoCnt
init|=
name|THREAD_BASIC_INFO_COUNT
decl_stmt|;
comment|/* There is no point in single stepping when current_thread        * is dead.        */
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|current_thread
argument_list|)
condition|)
name|error
argument_list|(
literal|"No thread selected; can not single step"
argument_list|)
expr_stmt|;
comment|/* If current_thread is suspended, tracing it would never return.        */
name|ret
operator|=
name|thread_info
argument_list|(
name|current_thread
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|th_info
argument_list|,
operator|&
name|infoCnt
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"child_resume: can't get thread info"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|th_info
operator|.
name|suspend_count
condition|)
name|error
argument_list|(
literal|"Can't trace a suspended thread. Use \"thread resume\" command to resume it"
argument_list|)
expr_stmt|;
block|}
name|vm_read_cache_valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|signal
operator|&&
name|inferior_pid
operator|>
literal|0
condition|)
comment|/* Do not signal, if attached by MID */
name|kill
argument_list|(
name|inferior_pid
argument_list|,
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|suspend_all_threads
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setup_single_step
argument_list|(
name|current_thread
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_resume
argument_list|(
name|current_thread
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"thread_resume"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|task_resume
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|KERN_FAILURE
condition|)
name|warning
argument_list|(
literal|"Task was not suspended"
argument_list|)
expr_stmt|;
else|else
name|CHK
argument_list|(
literal|"Resuming task"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* HACK HACK This is needed by the multiserver system HACK HACK */
while|while
condition|(
operator|(
name|ret
operator|=
name|task_resume
argument_list|(
name|inferior_task
argument_list|)
operator|)
operator|==
name|KERN_SUCCESS
condition|)
comment|/* make sure it really runs */
empty_stmt|;
comment|/* HACK HACK This is needed by the multiserver system HACK HACK */
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Start debugging the process with the given task */
end_comment

begin_function
name|void
name|task_attach
parameter_list|(
name|tid
parameter_list|)
name|task_t
name|tid
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|inferior_task
operator|=
name|tid
expr_stmt|;
name|ret
operator|=
name|task_suspend
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_attach: task_suspend"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|must_suspend_thread
operator|=
literal|0
expr_stmt|;
name|setup_notify_port
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|request_notify
argument_list|(
name|inferior_task
argument_list|,
name|MACH_NOTIFY_DEAD_NAME
argument_list|,
name|MACH_TYPE_TASK
argument_list|)
expr_stmt|;
name|setup_exception_port
argument_list|()
expr_stmt|;
name|emulator_present
operator|=
name|have_emulator_p
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Well, we can call error also here and leave the  * target stack inconsistent. Sigh.  * Fix this sometime (the only way to fail here is that  * the task has no threads at all, which is rare, but  * possible; or if the target task has died, which is also  * possible, but unlikely, since it has been suspended.  * (Someone must have killed it))  */
end_comment

begin_function
name|void
name|attach_to_thread
parameter_list|()
block|{
if|if
condition|(
name|select_thread
argument_list|(
name|inferior_task
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|error
argument_list|(
literal|"Could not select any threads to attach to"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|mid_attach
argument_list|(
argument|mid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|ret
operator|=
name|machid_mach_port
argument_list|(
name|mid_server
argument_list|,
name|mid_auth
argument_list|,
name|mid
argument_list|,
operator|&
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"mid_attach: machid_mach_port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|task_attach
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
return|return
name|mid
return|;
block|}
end_block

begin_comment
comment|/*   * Start debugging the process whose unix process-id is PID.  * A negative "pid" value is legal and signifies a mach_id not a unix pid.  *  * Prevent (possible unwanted) dangerous operations by enabled users  * like "atta 0" or "atta foo" (equal to the previous :-) and  * "atta pidself". Anyway, the latter is allowed by specifying a MID.  */
end_comment

begin_function
specifier|static
name|int
name|m3_do_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"MID=0, Debugging the master unix server does not compute"
argument_list|)
expr_stmt|;
comment|/* Foo. This assumes gdb has a unix pid */
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
name|error
argument_list|(
literal|"I will debug myself only by mid. (Gdb would suspend itself!)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|mid_attach
argument_list|(
operator|-
operator|(
name|pid
operator|)
argument_list|)
expr_stmt|;
comment|/* inferior_pid will be NEGATIVE! */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
name|inferior_task
operator|=
name|task_by_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|inferior_task
argument_list|)
condition|)
name|error
argument_list|(
literal|"Cannot map Unix pid %d to Mach task port"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|task_attach
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|m3_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program `%s', %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|m3_do_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|m3_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|deallocate_inferior_ports
parameter_list|()
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|thread_array_t
name|thread_list
decl_stmt|;
name|int
name|thread_count
decl_stmt|,
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|MACH_PORT_VALID
argument_list|(
name|inferior_task
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|task_threads
argument_list|(
name|inferior_task
argument_list|,
operator|&
name|thread_list
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"deallocate_inferior_ports: task_threads"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get rid of send rights to task threads */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|thread_count
condition|;
name|index
operator|++
control|)
block|{
name|int
name|rights
decl_stmt|;
name|ret
operator|=
name|mach_port_get_refs
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread_list
index|[
name|index
index|]
argument_list|,
name|MACH_PORT_RIGHT_SEND
argument_list|,
operator|&
name|rights
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"deallocate_inferior_ports: get refs"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|rights
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|mach_port_mod_refs
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread_list
index|[
name|index
index|]
argument_list|,
name|MACH_PORT_RIGHT_SEND
argument_list|,
operator|-
name|rights
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"deallocate_inferior_ports: mod refs"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|mach_port_mod_refs
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inferior_exception_port
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"deallocate_inferior_ports: cannot get rid of exception port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inferior_task
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"deallocate_task_port: deallocating inferior_task"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|inferior_task
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop debugging the process whose number is PID    and continue it with signal number SIGNAL.    SIGNAL = 0 means just continue it.  */
end_comment

begin_function
specifier|static
name|void
name|m3_do_detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|MACH_ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
name|current_thread
operator|!=
name|MACH_PORT_NULL
condition|)
block|{
comment|/* Store the gdb's view of the thread we are deselecting        * before we detach.        * @@ I am really not sure if this is ever needeed.        */
name|target_prepare_to_store
argument_list|()
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|task_set_special_port
argument_list|(
name|inferior_task
argument_list|,
name|TASK_EXCEPTION_PORT
argument_list|,
name|inferior_old_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"task_set_special_port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Discard all requested notifications */
name|setup_notify_port
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_breakpoints
argument_list|()
condition|)
name|warning
argument_list|(
literal|"Could not remove breakpoints when detaching"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
operator|&&
name|inferior_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|inferior_pid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
comment|/* the task might be dead by now */
operator|(
name|void
operator|)
name|task_resume
argument_list|(
name|inferior_task
argument_list|)
expr_stmt|;
name|deallocate_inferior_ports
argument_list|()
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via fork.  */
end_comment

begin_function
specifier|static
name|void
name|m3_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|m3_do_detach
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|m3_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|m3_prepare_to_store
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|m3_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
comment|/* FIXME: should print MID and all that crap.  */
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|m3_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DUMP_SYSCALL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|STR
parameter_list|(
name|x
parameter_list|)
value|#x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STR
parameter_list|(
name|x
parameter_list|)
value|"x"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|bsd1_names
index|[]
init|=
block|{
literal|"execve"
block|,
literal|"fork"
block|,
literal|"take_signal"
block|,
literal|"sigreturn"
block|,
literal|"getrusage"
block|,
literal|"chdir"
block|,
literal|"chroot"
block|,
literal|"open"
block|,
literal|"creat"
block|,
literal|"mknod"
block|,
literal|"link"
block|,
literal|"symlink"
block|,
literal|"unlink"
block|,
literal|"access"
block|,
literal|"stat"
block|,
literal|"readlink"
block|,
literal|"chmod"
block|,
literal|"chown"
block|,
literal|"utimes"
block|,
literal|"truncate"
block|,
literal|"rename"
block|,
literal|"mkdir"
block|,
literal|"rmdir"
block|,
literal|"xutimes"
block|,
literal|"mount"
block|,
literal|"umount"
block|,
literal|"acct"
block|,
literal|"setquota"
block|,
literal|"write_short"
block|,
literal|"write_long"
block|,
literal|"send_short"
block|,
literal|"send_long"
block|,
literal|"sendto_short"
block|,
literal|"sendto_long"
block|,
literal|"select"
block|,
literal|"task_by_pid"
block|,
literal|"recvfrom_short"
block|,
literal|"recvfrom_long"
block|,
literal|"setgroups"
block|,
literal|"setrlimit"
block|,
literal|"sigvec"
block|,
literal|"sigstack"
block|,
literal|"settimeofday"
block|,
literal|"adjtime"
block|,
literal|"setitimer"
block|,
literal|"sethostname"
block|,
literal|"bind"
block|,
literal|"accept"
block|,
literal|"connect"
block|,
literal|"setsockopt"
block|,
literal|"getsockopt"
block|,
literal|"getsockname"
block|,
literal|"getpeername"
block|,
literal|"init_process"
block|,
literal|"table_set"
block|,
literal|"table_get"
block|,
literal|"pioctl"
block|,
literal|"emulator_error"
block|,
literal|"readwrite"
block|,
literal|"share_wakeup"
block|,
literal|0
block|,
literal|"maprw_request_it"
block|,
literal|"maprw_release_it"
block|,
literal|"maprw_remap"
block|,
literal|"pid_by_task"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsd1_nnames
init|=
sizeof|sizeof
argument_list|(
name|bsd1_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bsd1_names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|name_str
parameter_list|(
name|name
parameter_list|,
name|buf
parameter_list|)
name|int
name|name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|MACH_MSG_TYPE_BOOLEAN
case|:
return|return
literal|"boolean"
return|;
case|case
name|MACH_MSG_TYPE_INTEGER_16
case|:
return|return
literal|"short"
return|;
case|case
name|MACH_MSG_TYPE_INTEGER_32
case|:
return|return
literal|"long"
return|;
case|case
name|MACH_MSG_TYPE_CHAR
case|:
return|return
literal|"char"
return|;
case|case
name|MACH_MSG_TYPE_BYTE
case|:
return|return
literal|"byte"
return|;
case|case
name|MACH_MSG_TYPE_REAL
case|:
return|return
literal|"real"
return|;
case|case
name|MACH_MSG_TYPE_STRING
case|:
return|return
literal|"string"
return|;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|id_str
parameter_list|(
name|id
parameter_list|,
name|buf
parameter_list|)
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|id
operator|>=
literal|101000
operator|&&
name|id
operator|<
literal|101000
operator|+
name|bsd1_nnames
condition|)
block|{
if|if
condition|(
name|p
operator|=
name|bsd1_names
index|[
name|id
operator|-
literal|101000
index|]
condition|)
return|return
name|p
return|;
block|}
if|if
condition|(
name|id
operator|==
literal|102000
condition|)
return|return
literal|"psignal_retry"
return|;
if|if
condition|(
name|id
operator|==
literal|100000
condition|)
return|return
literal|"syscall"
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_macro
name|print_msg
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|mach_msg_header_t
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fmt_x
init|=
literal|"%20s : 0x%08x\n"
decl_stmt|;
name|char
modifier|*
name|fmt_d
init|=
literal|"%20s : %10d\n"
decl_stmt|;
name|char
modifier|*
name|fmt_s
init|=
literal|"%20s : %s\n"
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|pr
parameter_list|(
name|fmt
parameter_list|,
name|h
parameter_list|,
name|x
parameter_list|)
value|printf_filtered(fmt,STR(x),(h).x)
name|pr
argument_list|(
name|fmt_x
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|msgh_bits
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fmt_d
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|msgh_size
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fmt_x
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|msgh_remote_port
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fmt_x
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|msgh_local_port
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fmt_d
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|,
name|msgh_kind
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|fmt_s
argument_list|,
name|STR
argument_list|(
name|msgh_id
argument_list|)
argument_list|,
name|id_str
argument_list|(
name|mp
operator|->
name|msgh_id
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mp
expr_stmt|;
name|ep
operator|=
name|p
operator|+
name|mp
operator|->
name|msgh_size
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|ep
condition|;
name|p
operator|+=
name|plen
control|)
block|{
name|mach_msg_type_t
modifier|*
name|tp
decl_stmt|;
name|mach_msg_type_long_t
modifier|*
name|tlp
decl_stmt|;
name|int
name|name
decl_stmt|,
name|size
decl_stmt|,
name|number
decl_stmt|;
name|tp
operator|=
operator|(
name|mach_msg_type_t
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|msgt_longform
condition|)
block|{
name|tlp
operator|=
operator|(
name|mach_msg_type_long_t
operator|*
operator|)
name|tp
expr_stmt|;
name|name
operator|=
name|tlp
operator|->
name|msgtl_name
expr_stmt|;
name|size
operator|=
name|tlp
operator|->
name|msgtl_size
expr_stmt|;
name|number
operator|=
name|tlp
operator|->
name|msgtl_number
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tlp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|tp
operator|->
name|msgt_name
expr_stmt|;
name|size
operator|=
name|tp
operator|->
name|msgt_size
expr_stmt|;
name|number
operator|=
name|tp
operator|->
name|msgt_number
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n"
argument_list|,
name|name_str
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
argument_list|,
name|size
argument_list|,
name|number
argument_list|,
name|tp
operator|->
name|msgt_inline
argument_list|,
name|tp
operator|->
name|msgt_longform
argument_list|,
name|tp
operator|->
name|msgt_deallocate
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p
operator|+
name|plen
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|msgt_inline
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|size
operator|*
name|number
operator|/
literal|8
expr_stmt|;
name|l
operator|=
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|plen
operator|+=
name|l
expr_stmt|;
name|print_data
argument_list|(
name|dp
argument_list|,
name|size
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plen
operator|+=
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"plen=%d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|print_data
argument_list|(
argument|p
argument_list|,
argument|size
argument_list|,
argument|number
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|short
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number
condition|;
name|i
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|" %02x"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number
condition|;
name|i
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|" %04x"
argument_list|,
name|sp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number
condition|;
name|i
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|" %08x"
argument_list|,
name|ip
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DUMP_SYSCALL
end_endif

begin_function
specifier|static
name|void
name|m3_stop
parameter_list|()
block|{
name|error
argument_list|(
literal|"to_stop target function not implemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|m3_ops
init|=
block|{
literal|"mach"
block|,
comment|/* to_shortname */
literal|"Mach child process"
block|,
comment|/* to_longname */
literal|"Mach child process (started by the \"run\" command)."
block|,
comment|/* to_doc */
name|m3_open
block|,
comment|/* to_open */
literal|0
block|,
comment|/* to_close */
name|m3_attach
block|,
comment|/* to_attach */
name|m3_detach
block|,
comment|/* to_detach */
name|m3_resume
block|,
comment|/* to_resume */
name|mach_really_wait
block|,
comment|/* to_wait */
name|fetch_inferior_registers
block|,
comment|/* to_fetch_registers */
name|store_inferior_registers
block|,
comment|/* to_store_registers */
name|m3_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|m3_xfer_memory
block|,
comment|/* to_xfer_memory */
name|m3_files_info
block|,
comment|/* to_files_info */
name|memory_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|memory_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|terminal_init_inferior
block|,
comment|/* to_terminal_init */
name|terminal_inferior
block|,
comment|/* to_terminal_inferior */
name|terminal_ours_for_output
block|,
comment|/* to_terminal_ours_for_output */
name|terminal_ours
block|,
comment|/* to_terminal_ours */
name|child_terminal_info
block|,
comment|/* to_terminal_info */
name|m3_kill_inferior
block|,
comment|/* to_kill */
literal|0
block|,
comment|/* to_load */
literal|0
block|,
comment|/* to_lookup_symbol */
name|m3_create_inferior
block|,
comment|/* to_create_inferior */
name|m3_mourn_inferior
block|,
comment|/* to_mourn_inferior */
name|m3_can_run
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
name|m3_stop
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
literal|0
block|,
comment|/* sections */
literal|0
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_m3_nat
parameter_list|()
block|{
name|kern_return_t
name|ret
decl_stmt|;
name|add_target
argument_list|(
operator|&
name|m3_ops
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_PORT_SET
argument_list|,
operator|&
name|inferior_wait_port_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"initial port set %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mach_really_wait now waits for this */
name|currently_waiting_for
operator|=
name|inferior_wait_port_set
expr_stmt|;
name|ret
operator|=
name|netname_look_up
argument_list|(
name|name_server_port
argument_list|,
name|hostname
argument_list|,
literal|"MachID"
argument_list|,
operator|&
name|mid_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|mid_server
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|warning
argument_list|(
literal|"initialize machid: netname_lookup_up(MachID) : %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Some (most?) features disabled..."
argument_list|)
expr_stmt|;
block|}
name|mid_auth
operator|=
name|mach_privileged_host_port
argument_list|()
expr_stmt|;
if|if
condition|(
name|mid_auth
operator|==
name|MACH_PORT_NULL
condition|)
name|mid_auth
operator|=
name|mach_task_self
argument_list|()
expr_stmt|;
name|obstack_init
argument_list|(
name|port_chain_obstack
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|thread_exception_port
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Creating thread_exception_port for single stepping"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach_port_insert_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread_exception_port
argument_list|,
name|thread_exception_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|"Inserting send right to thread_exception_port"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Allocate message port */
name|ret
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|our_message_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Creating message port %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
name|MAX_NAME_LEN
index|]
decl_stmt|;
name|ret
operator|=
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|our_message_port
argument_list|,
name|inferior_wait_port_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"message move member %s"
argument_list|,
name|mach_error_string
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @@@@ No way to change message port name currently */
comment|/* Foo. This assumes gdb has a unix pid */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"gdb-%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|gdb_register_port
argument_list|(
name|buf
argument_list|,
name|our_message_port
argument_list|)
expr_stmt|;
block|}
comment|/* Heap for thread commands */
name|obstack_init
argument_list|(
name|cproc_obstack
argument_list|)
expr_stmt|;
name|add_mach_specific_commands
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

