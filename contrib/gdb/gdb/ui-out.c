begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output generating routines for GDB.    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Cygnus Solutions.    Written by Fernando Nasser for Cygnus.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_comment
comment|/* For language.h */
end_comment

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Convenience macro for allocting typesafe memory. */
end_comment

begin_undef
undef|#
directive|undef
name|XMALLOC
end_undef

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|(TYPE*) xmalloc (sizeof (TYPE))
end_define

begin_comment
comment|/* table header structures */
end_comment

begin_struct
struct|struct
name|ui_out_hdr
block|{
name|int
name|colno
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|char
modifier|*
name|col_name
decl_stmt|;
name|char
modifier|*
name|colhdr
decl_stmt|;
name|struct
name|ui_out_hdr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maintain a stack so that the info applicable to the inner most list    is always available.  Stack/nested level 0 is reserved for the    top-level result. */
end_comment

begin_enum
enum|enum
block|{
name|MAX_UI_OUT_LEVELS
init|=
literal|5
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ui_out_level
block|{
comment|/* Count each field; the first element is for non-list fields */
name|int
name|field_count
decl_stmt|;
comment|/* The type of this level. */
name|enum
name|ui_out_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Tables are special.  Maintain a separate structure that tracks    their state.  At present an output can only contain a single table    but that restriction might eventually be lifted.  */
end_comment

begin_struct
struct|struct
name|ui_out_table
block|{
comment|/* If on, a table is being generated.  */
name|int
name|flag
decl_stmt|;
comment|/* If on, the body of a table is being generated.  If off, the table      header is being generated.  */
name|int
name|body_flag
decl_stmt|;
comment|/* The level at which each entry of the table is to be found.  A row      (a tuple) is made up of entries.  Consequently ENTRY_LEVEL is one      above that of the table.  */
name|int
name|entry_level
decl_stmt|;
comment|/* Number of table columns (as specified in the table_begin call).  */
name|int
name|columns
decl_stmt|;
comment|/* String identifying the table (as specified in the table_begin      call).  */
name|char
modifier|*
name|id
decl_stmt|;
comment|/* Points to the first table header (if any).  */
name|struct
name|ui_out_hdr
modifier|*
name|header_first
decl_stmt|;
comment|/* Points to the last table header (if any).  */
name|struct
name|ui_out_hdr
modifier|*
name|header_last
decl_stmt|;
comment|/* Points to header of NEXT column to format.  */
name|struct
name|ui_out_hdr
modifier|*
name|header_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ui_out structure */
end_comment

begin_comment
comment|/* Any change here requires a corresponding one in the initialization    of the default uiout, which is statically initialized */
end_comment

begin_struct
struct|struct
name|ui_out
block|{
name|int
name|flags
decl_stmt|;
comment|/* specific implementation of ui-out */
name|struct
name|ui_out_impl
modifier|*
name|impl
decl_stmt|;
name|struct
name|ui_out_data
modifier|*
name|data
decl_stmt|;
comment|/* Sub structure tracking the ui-out depth.  */
name|int
name|level
decl_stmt|;
name|struct
name|ui_out_level
name|levels
index|[
name|MAX_UI_OUT_LEVELS
index|]
decl_stmt|;
comment|/* A table, if any.  At present only a single table is supported.  */
name|struct
name|ui_out_table
name|table
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The current (inner most) level. */
end_comment

begin_function
specifier|static
name|struct
name|ui_out_level
modifier|*
name|current_level
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
return|return
operator|&
name|uiout
operator|->
name|levels
index|[
name|uiout
operator|->
name|level
index|]
return|;
block|}
end_function

begin_comment
comment|/* Create a new level, of TYPE.  Return the new level's index. */
end_comment

begin_function
specifier|static
name|int
name|push_level
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|ui_out_level
modifier|*
name|current
decl_stmt|;
comment|/* We had better not overflow the buffer. */
name|uiout
operator|->
name|level
operator|++
expr_stmt|;
name|gdb_assert
argument_list|(
name|uiout
operator|->
name|level
operator|>=
literal|0
operator|&&
name|uiout
operator|->
name|level
operator|<
name|MAX_UI_OUT_LEVELS
argument_list|)
expr_stmt|;
name|current
operator|=
name|current_level
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|current
operator|->
name|field_count
operator|=
literal|0
expr_stmt|;
name|current
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|uiout
operator|->
name|level
return|;
block|}
end_function

begin_comment
comment|/* Discard the current level, return the discarded level's index.    TYPE is the type of the level being discarded. */
end_comment

begin_function
specifier|static
name|int
name|pop_level
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|)
block|{
comment|/* We had better not underflow the buffer. */
name|gdb_assert
argument_list|(
name|uiout
operator|->
name|level
operator|>
literal|0
operator|&&
name|uiout
operator|->
name|level
operator|<
name|MAX_UI_OUT_LEVELS
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|current_level
argument_list|(
name|uiout
argument_list|)
operator|->
name|type
operator|==
name|type
argument_list|)
expr_stmt|;
name|uiout
operator|->
name|level
operator|--
expr_stmt|;
return|return
name|uiout
operator|->
name|level
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* These are the default implementation functions */
end_comment

begin_function_decl
specifier|static
name|void
name|default_table_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|nbrofcols
parameter_list|,
name|int
name|nr_rows
parameter_list|,
specifier|const
name|char
modifier|*
name|tblid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_table_body
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_table_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_table_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|alig
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_field_int
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|alig
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_field_skip
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|alig
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_field_string
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_field_fmt
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_spaces
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|numspaces
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_text
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_message
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|verbosity
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_wrap_hint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|char
modifier|*
name|identstring
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_flush
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is the default ui-out implementation functions vector */
end_comment

begin_decl_stmt
name|struct
name|ui_out_impl
name|default_ui_out_impl
init|=
block|{
name|default_table_begin
block|,
name|default_table_body
block|,
name|default_table_end
block|,
name|default_table_header
block|,
name|default_begin
block|,
name|default_end
block|,
name|default_field_int
block|,
name|default_field_skip
block|,
name|default_field_string
block|,
name|default_field_fmt
block|,
name|default_spaces
block|,
name|default_text
block|,
name|default_message
block|,
name|default_wrap_hint
block|,
name|default_flush
block|,
literal|0
block|,
comment|/* Does not need MI hacks.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default ui_out */
end_comment

begin_decl_stmt
name|struct
name|ui_out
name|def_uiout
init|=
block|{
literal|0
block|,
comment|/* flags */
operator|&
name|default_ui_out_impl
block|,
comment|/* impl */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to current ui_out */
end_comment

begin_comment
comment|/* FIXME: This should not be a global, but something passed down from main.c    or top.c */
end_comment

begin_decl_stmt
name|struct
name|ui_out
modifier|*
name|uiout
init|=
operator|&
name|def_uiout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the interfaces to implementation functions */
end_comment

begin_function_decl
specifier|static
name|void
name|uo_table_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|nbrofcols
parameter_list|,
name|int
name|nr_rows
parameter_list|,
specifier|const
name|char
modifier|*
name|tblid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_table_body
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_table_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_table_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_field_int
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_field_skip
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_field_string
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_field_fmt
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_spaces
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|numspaces
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_text
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_message
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|verbosity
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_wrap_hint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|char
modifier|*
name|identstring
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uo_flush
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_ui_out
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|append_header_to_list
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_next_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
modifier|*
name|colno
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|alignment
parameter_list|,
name|char
modifier|*
modifier|*
name|colhdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_header_list
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verify_field
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
modifier|*
name|fldno
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|align
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_ui_out_state
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* exported functions (ui_out API) */
end_comment

begin_comment
comment|/* Mark beginning of a table */
end_comment

begin_function
name|void
name|ui_out_table_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|nbrofcols
parameter_list|,
name|int
name|nr_rows
parameter_list|,
specifier|const
name|char
modifier|*
name|tblid
parameter_list|)
block|{
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tables cannot be nested; table_begin found before \ previous table_end."
argument_list|)
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|flag
operator|=
literal|1
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|body_flag
operator|=
literal|0
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|entry_level
operator|=
name|uiout
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|columns
operator|=
name|nbrofcols
expr_stmt|;
if|if
condition|(
name|tblid
operator|!=
name|NULL
condition|)
name|uiout
operator|->
name|table
operator|.
name|id
operator|=
name|xstrdup
argument_list|(
name|tblid
argument_list|)
expr_stmt|;
else|else
name|uiout
operator|->
name|table
operator|.
name|id
operator|=
name|NULL
expr_stmt|;
name|clear_header_list
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|uo_table_begin
argument_list|(
name|uiout
argument_list|,
name|nbrofcols
argument_list|,
name|nr_rows
argument_list|,
name|uiout
operator|->
name|table
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_table_body
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|table
operator|.
name|flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"table_body outside a table is not valid; it must be \ after a table_begin and before a table_end."
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|body_flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"extra table_body call not allowed; there must be \ only one table_body after a table_begin and before a table_end."
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|colno
operator|!=
name|uiout
operator|->
name|table
operator|.
name|columns
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"number of headers differ from number of table \ columns."
argument_list|)
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|body_flag
operator|=
literal|1
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_first
expr_stmt|;
name|uo_table_body
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_table_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|table
operator|.
name|flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"misplaced table_end or missing table_begin."
argument_list|)
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|entry_level
operator|=
literal|0
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|body_flag
operator|=
literal|0
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|uo_table_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|id
condition|)
name|xfree
argument_list|(
name|uiout
operator|->
name|table
operator|.
name|id
argument_list|)
expr_stmt|;
name|clear_header_list
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_table_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|table
operator|.
name|flag
operator|||
name|uiout
operator|->
name|table
operator|.
name|body_flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"table header must be specified after table_begin \ and before table_body."
argument_list|)
expr_stmt|;
name|append_header_to_list
argument_list|(
name|uiout
argument_list|,
name|width
argument_list|,
name|alignment
argument_list|,
name|col_name
argument_list|,
name|colhdr
argument_list|)
expr_stmt|;
name|uo_table_header
argument_list|(
name|uiout
argument_list|,
name|width
argument_list|,
name|alignment
argument_list|,
name|col_name
argument_list|,
name|colhdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|int
name|new_level
decl_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|flag
operator|&&
operator|!
name|uiout
operator|->
name|table
operator|.
name|body_flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"table header or table_body expected; lists must be \ specified after table_body."
argument_list|)
expr_stmt|;
comment|/* Be careful to verify the ``field'' before the new tuple/list is      pushed onto the stack.  That way the containing list/table/row is      verified and not the newly created tuple/list.  This verification      is needed (at least) for the case where a table row entry      contains either a tuple/list.  For that case bookkeeping such as      updating the column count or advancing to the next heading still      needs to be performed.  */
block|{
name|int
name|fldno
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|align
decl_stmt|;
name|verify_field
argument_list|(
name|uiout
argument_list|,
operator|&
name|fldno
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
block|}
name|new_level
operator|=
name|push_level
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If the push puts us at the same level as a table row entry, we've      got a new table row.  Put the header pointer back to the start.  */
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|body_flag
operator|&&
name|uiout
operator|->
name|table
operator|.
name|entry_level
operator|==
name|new_level
condition|)
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_first
expr_stmt|;
name|uo_begin
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|,
name|new_level
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_list_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ui_out_begin
argument_list|(
name|uiout
argument_list|,
name|ui_out_type_list
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_tuple_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ui_out_begin
argument_list|(
name|uiout
argument_list|,
name|ui_out_type_tuple
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|)
block|{
name|int
name|old_level
init|=
name|pop_level
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|uo_end
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|,
name|old_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_list_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
name|ui_out_end
argument_list|(
name|uiout
argument_list|,
name|ui_out_type_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_tuple_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
name|ui_out_end
argument_list|(
name|uiout
argument_list|,
name|ui_out_type_tuple
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|ui_out_end_cleanup_data
block|{
name|struct
name|ui_out
modifier|*
name|uiout
decl_stmt|;
name|enum
name|ui_out_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|do_cleanup_end
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ui_out_end_cleanup_data
modifier|*
name|end_cleanup_data
init|=
name|data
decl_stmt|;
name|ui_out_end
argument_list|(
name|end_cleanup_data
operator|->
name|uiout
argument_list|,
name|end_cleanup_data
operator|->
name|type
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|end_cleanup_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_out_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|)
block|{
name|struct
name|ui_out_end_cleanup_data
modifier|*
name|end_cleanup_data
decl_stmt|;
name|end_cleanup_data
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|ui_out_end_cleanup_data
argument_list|)
expr_stmt|;
name|end_cleanup_data
operator|->
name|uiout
operator|=
name|uiout
expr_stmt|;
name|end_cleanup_data
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|make_cleanup
argument_list|(
name|do_cleanup_end
argument_list|,
name|end_cleanup_data
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_out_begin_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ui_out_begin
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|make_cleanup_ui_out_end
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_out_tuple_begin_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|make_cleanup_ui_out_end
argument_list|(
name|uiout
argument_list|,
name|ui_out_type_tuple
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_out_list_begin_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|make_cleanup_ui_out_end
argument_list|(
name|uiout
argument_list|,
name|ui_out_type_list
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ui_out_field_int
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|fldno
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|align
decl_stmt|;
name|struct
name|ui_out_level
modifier|*
name|current
init|=
name|current_level
argument_list|(
name|uiout
argument_list|)
decl_stmt|;
name|verify_field
argument_list|(
name|uiout
argument_list|,
operator|&
name|fldno
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
name|uo_field_int
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_field_core_addr
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|char
name|addstr
index|[
literal|20
index|]
decl_stmt|;
comment|/* FIXME-32x64: need a print_address_numeric with field width */
comment|/* print_address_numeric (address, 1, local_stream); */
name|strcpy
argument_list|(
name|addstr
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|address
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|fldname
argument_list|,
name|addstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_field_stream
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|struct
name|ui_stream
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|length
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|ui_file_xstrdup
argument_list|(
name|buf
operator|->
name|stream
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanup
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|fldname
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
name|fldname
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|buf
operator|->
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* used to ommit a field */
end_comment

begin_function
name|void
name|ui_out_field_skip
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|)
block|{
name|int
name|fldno
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|align
decl_stmt|;
name|verify_field
argument_list|(
name|uiout
argument_list|,
operator|&
name|fldno
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
name|uo_field_skip
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_field_string
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|fldno
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|align
decl_stmt|;
name|verify_field
argument_list|(
name|uiout
argument_list|,
operator|&
name|fldno
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
name|uo_field_string
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|ui_out_field_fmt
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|fldno
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* will not align, but has to call anyway */
name|verify_field
argument_list|(
name|uiout
argument_list|,
operator|&
name|fldno
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|uo_field_fmt
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_spaces
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|numspaces
parameter_list|)
block|{
name|uo_spaces
argument_list|(
name|uiout
argument_list|,
name|numspaces
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_text
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|uo_text
argument_list|(
name|uiout
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_message
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|verbosity
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|uo_message
argument_list|(
name|uiout
argument_list|,
name|verbosity
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ui_stream
modifier|*
name|ui_out_stream_new
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
name|struct
name|ui_stream
modifier|*
name|tempbuf
decl_stmt|;
name|tempbuf
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|ui_stream
argument_list|)
expr_stmt|;
name|tempbuf
operator|->
name|uiout
operator|=
name|uiout
expr_stmt|;
name|tempbuf
operator|->
name|stream
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
return|return
name|tempbuf
return|;
block|}
end_function

begin_function
name|void
name|ui_out_stream_delete
parameter_list|(
name|struct
name|ui_stream
modifier|*
name|buf
parameter_list|)
block|{
name|ui_file_delete
argument_list|(
name|buf
operator|->
name|stream
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_stream_delete
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|ui_out_stream_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_out_stream_delete
parameter_list|(
name|struct
name|ui_stream
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_stream_delete
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ui_out_wrap_hint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|char
modifier|*
name|identstring
parameter_list|)
block|{
name|uo_wrap_hint
argument_list|(
name|uiout
argument_list|,
name|identstring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ui_out_flush
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
name|uo_flush
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set the flags specified by the mask given */
end_comment

begin_function
name|int
name|ui_out_set_flags
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|oldflags
init|=
name|uiout
operator|->
name|flags
decl_stmt|;
name|uiout
operator|->
name|flags
operator||=
name|mask
expr_stmt|;
return|return
name|oldflags
return|;
block|}
end_function

begin_comment
comment|/* clear the flags specified by the mask given */
end_comment

begin_function
name|int
name|ui_out_clear_flags
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|oldflags
init|=
name|uiout
operator|->
name|flags
decl_stmt|;
name|uiout
operator|->
name|flags
operator|&=
operator|~
name|mask
expr_stmt|;
return|return
name|oldflags
return|;
block|}
end_function

begin_comment
comment|/* test the flags against the mask given */
end_comment

begin_function
name|int
name|ui_out_test_flags
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
return|return
operator|(
name|uiout
operator|->
name|flags
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/* obtain the current verbosity level (as stablished by the    'set verbositylevel' command */
end_comment

begin_function
name|int
name|ui_out_get_verblvl
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
comment|/* FIXME: not implemented yet */
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void ui_out_result_begin (struct ui_out *uiout, char *class) { }  void ui_out_result_end (struct ui_out *uiout) { }  void ui_out_info_begin (struct ui_out *uiout, char *class) { }  void ui_out_info_end (struct ui_out *uiout) { }  void ui_out_notify_begin (struct ui_out *uiout, char *class) { }  void ui_out_notify_end (struct ui_out *uiout) { }  void ui_out_error_begin (struct ui_out *uiout, char *class) { }  void ui_out_error_end (struct ui_out *uiout) { }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void gdb_error (ui_out * uiout, int severity, char *format,...) {   va_list args; }  void gdb_query (struct ui_out *uiout, int qflags, char *qprompt) { }
endif|#
directive|endif
end_endif

begin_function
name|int
name|ui_out_is_mi_like_p
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
return|return
name|uiout
operator|->
name|impl
operator|->
name|is_mi_like_p
return|;
block|}
end_function

begin_comment
comment|/* default gdb-out hook functions */
end_comment

begin_function
specifier|static
name|void
name|default_table_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|nbrofcols
parameter_list|,
name|int
name|nr_rows
parameter_list|,
specifier|const
name|char
modifier|*
name|tblid
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_table_body
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_table_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_table_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_field_int
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|int
name|value
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_field_skip
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_field_string
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_field_fmt
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_spaces
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|numspaces
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_text
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_message
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|verbosity
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_wrap_hint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|char
modifier|*
name|identstring
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|default_flush
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Interface to the implementation functions */
end_comment

begin_function
name|void
name|uo_table_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|nbrofcols
parameter_list|,
name|int
name|nr_rows
parameter_list|,
specifier|const
name|char
modifier|*
name|tblid
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|table_begin
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|table_begin
argument_list|(
name|uiout
argument_list|,
name|nbrofcols
argument_list|,
name|nr_rows
argument_list|,
name|tblid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_table_body
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|table_body
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|table_body
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_table_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|table_end
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|table_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_table_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|table_header
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|table_header
argument_list|(
name|uiout
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|col_name
argument_list|,
name|colhdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_begin
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|uiout
operator|->
name|impl
operator|->
name|begin
operator|==
name|NULL
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|begin
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|,
name|level
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_end
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|enum
name|ui_out_type
name|type
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|uiout
operator|->
name|impl
operator|->
name|end
operator|==
name|NULL
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|end
argument_list|(
name|uiout
argument_list|,
name|type
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_field_int
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|field_int
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|field_int
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_field_skip
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|field_skip
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|field_skip
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_field_string
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|field_string
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|field_string
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_field_fmt
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|fldno
parameter_list|,
name|int
name|width
parameter_list|,
name|enum
name|ui_align
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|fldname
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|field_fmt
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|field_fmt
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
name|fldname
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_spaces
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|numspaces
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|spaces
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|spaces
argument_list|(
name|uiout
argument_list|,
name|numspaces
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_text
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|text
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|text
argument_list|(
name|uiout
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_message
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|verbosity
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|message
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|message
argument_list|(
name|uiout
argument_list|,
name|verbosity
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_wrap_hint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|char
modifier|*
name|identstring
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|wrap_hint
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|wrap_hint
argument_list|(
name|uiout
argument_list|,
name|identstring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uo_flush
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|impl
operator|->
name|flush
condition|)
return|return;
name|uiout
operator|->
name|impl
operator|->
name|flush
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* local functions */
end_comment

begin_comment
comment|/* list of column headers manipulation routines */
end_comment

begin_function
specifier|static
name|void
name|clear_header_list
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
while|while
condition|(
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|!=
name|NULL
condition|)
block|{
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_first
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|colhdr
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|colhdr
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|uiout
operator|->
name|table
operator|.
name|header_next
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_last
operator|=
name|NULL
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_header_to_list
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|col_name
parameter_list|,
specifier|const
name|char
modifier|*
name|colhdr
parameter_list|)
block|{
name|struct
name|ui_out_hdr
modifier|*
name|temphdr
decl_stmt|;
name|temphdr
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|ui_out_hdr
argument_list|)
expr_stmt|;
name|temphdr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|temphdr
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
comment|/* we have to copy the column title as the original may be an automatic */
if|if
condition|(
name|colhdr
operator|!=
name|NULL
condition|)
name|temphdr
operator|->
name|colhdr
operator|=
name|xstrdup
argument_list|(
name|colhdr
argument_list|)
expr_stmt|;
else|else
name|temphdr
operator|->
name|colhdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|col_name
operator|!=
name|NULL
condition|)
name|temphdr
operator|->
name|col_name
operator|=
name|xstrdup
argument_list|(
name|colhdr
argument_list|)
expr_stmt|;
else|else
name|temphdr
operator|->
name|col_name
operator|=
name|xstrdup
argument_list|(
name|colhdr
argument_list|)
expr_stmt|;
name|temphdr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|==
name|NULL
condition|)
block|{
name|temphdr
operator|->
name|colno
operator|=
literal|1
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|=
name|temphdr
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_last
operator|=
name|temphdr
expr_stmt|;
block|}
else|else
block|{
name|temphdr
operator|->
name|colno
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_last
operator|->
name|colno
operator|+
literal|1
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_last
operator|->
name|next
operator|=
name|temphdr
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_last
operator|=
name|temphdr
expr_stmt|;
block|}
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract the format information for the NEXT header and and advance    the header pointer.  Return 0 if there was no next header.  */
end_comment

begin_function
specifier|static
name|int
name|get_next_header
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
modifier|*
name|colno
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|alignment
parameter_list|,
name|char
modifier|*
modifier|*
name|colhdr
parameter_list|)
block|{
comment|/* There may be no headers at all or we may have used all columns.  */
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
operator|*
name|colno
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|colno
expr_stmt|;
operator|*
name|width
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|width
expr_stmt|;
operator|*
name|alignment
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|alignment
expr_stmt|;
operator|*
name|colhdr
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|colhdr
expr_stmt|;
comment|/* Advance the header pointer to the next entry.  */
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|->
name|next
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Verify that the field/tuple/list is correctly positioned.  Return    the field number and corresponding alignment (if    available/applicable).  */
end_comment

begin_function
specifier|static
name|void
name|verify_field
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
modifier|*
name|fldno
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
modifier|*
name|align
parameter_list|)
block|{
name|struct
name|ui_out_level
modifier|*
name|current
init|=
name|current_level
argument_list|(
name|uiout
argument_list|)
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|flag
condition|)
block|{
if|if
condition|(
operator|!
name|uiout
operator|->
name|table
operator|.
name|body_flag
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"table_body missing; table fields must be \ specified after table_body and inside a list."
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2001-12-08: There was a check here to ensure 	 that this code was only executed when uiout->level was 	 greater than zero.  That no longer applies - this code is run 	 before each table row tuple is started and at that point the 	 level is zero.  */
block|}
name|current
operator|->
name|field_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|uiout
operator|->
name|table
operator|.
name|body_flag
operator|&&
name|uiout
operator|->
name|table
operator|.
name|entry_level
operator|==
name|uiout
operator|->
name|level
operator|&&
name|get_next_header
argument_list|(
name|uiout
argument_list|,
name|fldno
argument_list|,
name|width
argument_list|,
name|align
argument_list|,
operator|&
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|fldno
operator|!=
name|current
operator|->
name|field_count
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"ui-out internal error in handling headers."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|width
operator|=
literal|0
expr_stmt|;
operator|*
name|align
operator|=
name|ui_noalign
expr_stmt|;
operator|*
name|fldno
operator|=
name|current
operator|->
name|field_count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* access to ui_out format private members */
end_comment

begin_function
name|void
name|ui_out_get_field_separator
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Access to ui-out members data */
end_comment

begin_function
name|struct
name|ui_out_data
modifier|*
name|ui_out_data
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|)
block|{
return|return
name|uiout
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* initalize private members at startup */
end_comment

begin_function
name|struct
name|ui_out
modifier|*
name|ui_out_new
parameter_list|(
name|struct
name|ui_out_impl
modifier|*
name|impl
parameter_list|,
name|struct
name|ui_out_data
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ui_out
modifier|*
name|uiout
init|=
name|XMALLOC
argument_list|(
expr|struct
name|ui_out
argument_list|)
decl_stmt|;
name|uiout
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|uiout
operator|->
name|impl
operator|=
name|impl
expr_stmt|;
name|uiout
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|body_flag
operator|=
literal|0
expr_stmt|;
name|uiout
operator|->
name|level
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|uiout
operator|->
name|levels
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uiout
operator|->
name|levels
argument_list|)
argument_list|)
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_first
operator|=
name|NULL
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_last
operator|=
name|NULL
expr_stmt|;
name|uiout
operator|->
name|table
operator|.
name|header_next
operator|=
name|NULL
expr_stmt|;
return|return
name|uiout
return|;
block|}
end_function

begin_comment
comment|/* standard gdb initialization hook */
end_comment

begin_function
name|void
name|_initialize_ui_out
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* nothing needs to be done */
block|}
end_function

end_unit

