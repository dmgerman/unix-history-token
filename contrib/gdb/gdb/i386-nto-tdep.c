begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i386-nto-tdep.c - i386 specific functionality for QNX Neutrino.     Copyright 2003 Free Software Foundation, Inc.     Contributed by QNX Software Systems Ltd.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"nto-tdep.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|X86_CPU_FXSR
end_ifndef

begin_define
define|#
directive|define
name|X86_CPU_FXSR
value|(1L<< 12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Why 13?  Look in our /usr/include/x86/context.h header at the    x86_cpu_registers structure and you'll see an 'exx' junk register    that is just filler.  Don't ask me, ask the kernel guys.  */
end_comment

begin_define
define|#
directive|define
name|NUM_GPREGS
value|13
end_define

begin_comment
comment|/* Map a GDB register number to an offset in the reg structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
operator|(
literal|7
operator|*
literal|4
operator|)
block|,
comment|/* eax */
operator|(
literal|6
operator|*
literal|4
operator|)
block|,
comment|/* ecx */
operator|(
literal|5
operator|*
literal|4
operator|)
block|,
comment|/* edx */
operator|(
literal|4
operator|*
literal|4
operator|)
block|,
comment|/* ebx */
operator|(
literal|11
operator|*
literal|4
operator|)
block|,
comment|/* esp */
operator|(
literal|2
operator|*
literal|4
operator|)
block|,
comment|/* epb */
operator|(
literal|1
operator|*
literal|4
operator|)
block|,
comment|/* esi */
operator|(
literal|0
operator|*
literal|4
operator|)
block|,
comment|/* edi */
operator|(
literal|8
operator|*
literal|4
operator|)
block|,
comment|/* eip */
operator|(
literal|10
operator|*
literal|4
operator|)
block|,
comment|/* eflags */
operator|(
literal|9
operator|*
literal|4
operator|)
block|,
comment|/* cs */
operator|(
literal|12
operator|*
literal|4
operator|)
block|,
comment|/* ss */
operator|(
operator|-
literal|1
operator|*
literal|4
operator|)
comment|/* filler */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a gdb regno, return the offset into Neutrino's register structure    or -1 if register is unknown.  */
end_comment

begin_function
specifier|static
name|int
name|nto_reg_offset
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NUM_GPREGS
operator|)
condition|?
name|regmap
index|[
name|regno
index|]
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386nto_supply_gregset
parameter_list|(
name|char
modifier|*
name|gpregs
parameter_list|)
block|{
name|unsigned
name|regno
decl_stmt|;
name|int
name|empty
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FP0_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|offset
init|=
name|nto_reg_offset
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|empty
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|regno
argument_list|,
name|gpregs
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|i386nto_supply_fpregset
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|)
block|{
if|if
condition|(
name|nto_cpuinfo_valid
operator|&&
name|nto_cpuinfo_flags
operator||
name|X86_CPU_FXSR
condition|)
name|i387_supply_fxsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
else|else
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386nto_supply_regset
parameter_list|(
name|int
name|regset
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|regset
condition|)
block|{
case|case
name|NTO_REG_GENERAL
case|:
comment|/* QNX has different ordering of GP regs than GDB.  */
name|i386nto_supply_gregset
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTO_REG_FLOAT
case|:
name|i386nto_supply_fpregset
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|i386nto_regset_id
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
return|return
name|NTO_REG_END
return|;
elseif|else
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
return|return
name|NTO_REG_GENERAL
return|;
elseif|else
if|if
condition|(
name|regno
operator|<
name|FPC_REGNUM
condition|)
return|return
name|NTO_REG_FLOAT
return|;
return|return
operator|-
literal|1
return|;
comment|/* Error.  */
block|}
end_function

begin_function
specifier|static
name|int
name|i386nto_register_area
parameter_list|(
name|int
name|regno
parameter_list|,
name|int
name|regset
parameter_list|,
name|unsigned
modifier|*
name|off
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regset
operator|==
name|NTO_REG_GENERAL
condition|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
return|return
name|NUM_GPREGS
operator|*
literal|4
return|;
operator|*
name|off
operator|=
name|nto_reg_offset
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|off
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
literal|4
return|;
block|}
elseif|else
if|if
condition|(
name|regset
operator|==
name|NTO_REG_FLOAT
condition|)
block|{
name|unsigned
name|off_adjust
decl_stmt|,
name|regsize
decl_stmt|,
name|regset_size
decl_stmt|;
if|if
condition|(
name|nto_cpuinfo_valid
operator|&&
name|nto_cpuinfo_flags
operator||
name|X86_CPU_FXSR
condition|)
block|{
name|off_adjust
operator|=
literal|32
expr_stmt|;
name|regsize
operator|=
literal|16
expr_stmt|;
name|regset_size
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
name|off_adjust
operator|=
literal|28
expr_stmt|;
name|regsize
operator|=
literal|10
expr_stmt|;
name|regset_size
operator|=
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
return|return
name|regset_size
return|;
operator|*
name|off
operator|=
operator|(
name|regno
operator|-
name|FP0_REGNUM
operator|)
operator|*
name|regsize
operator|+
name|off_adjust
expr_stmt|;
return|return
literal|10
return|;
comment|/* Why 10 instead of regsize?  GDB only stores 10 bytes per FP          register so if we're sending a register back to the target,          we only want pdebug to write 10 bytes so as not to clobber          the reserved 6 bytes in the fxsave structure.  */
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i386nto_regset_fill
parameter_list|(
name|int
name|regset
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|regset
operator|==
name|NTO_REG_GENERAL
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_GPREGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|offset
init|=
name|nto_reg_offset
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|data
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regset
operator|==
name|NTO_REG_FLOAT
condition|)
block|{
if|if
condition|(
name|nto_cpuinfo_valid
operator|&&
name|nto_cpuinfo_flags
operator||
name|X86_CPU_FXSR
condition|)
name|i387_fill_fxsave
argument_list|(
name|data
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|i387_fill_fsave
argument_list|(
name|data
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|i386nto_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|8
expr_stmt|;
comment|/* The actual size is 20 bytes, but 				   only 8 bytes are used.  */
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|20
expr_stmt|;
comment|/* The actual size is 552 bytes, but 				   only 20 bytes are used.  */
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|12
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i386nto_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|name
operator|&&
name|strcmp
argument_list|(
literal|"__signalstub"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|I386_NTO_SIGCONTEXT_OFFSET
value|136
end_define

begin_comment
comment|/* Assuming NEXT_FRAME is a frame following a QNX Neutrino sigtramp    routine, return the address of the associated sigcontext structure.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386nto_sigcontext_addr
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|SP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|sp
operator|+
name|I386_NTO_SIGCONTEXT_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_i386nto_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|current_nto_target
operator|.
name|nto_regset_id
operator|=
name|i386nto_regset_id
expr_stmt|;
name|current_nto_target
operator|.
name|nto_supply_gregset
operator|=
name|i386nto_supply_gregset
expr_stmt|;
name|current_nto_target
operator|.
name|nto_supply_fpregset
operator|=
name|i386nto_supply_fpregset
expr_stmt|;
name|current_nto_target
operator|.
name|nto_supply_altregset
operator|=
name|nto_dummy_supply_regset
expr_stmt|;
name|current_nto_target
operator|.
name|nto_supply_regset
operator|=
name|i386nto_supply_regset
expr_stmt|;
name|current_nto_target
operator|.
name|nto_register_area
operator|=
name|i386nto_register_area
expr_stmt|;
name|current_nto_target
operator|.
name|nto_regset_fill
operator|=
name|i386nto_regset_fill
expr_stmt|;
name|current_nto_target
operator|.
name|nto_fetch_link_map_offsets
operator|=
name|i386nto_svr4_fetch_link_map_offsets
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386nto_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* NTO uses ELF.  */
name|i386_elf_init_abi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
comment|/* Neutrino rewinds to look more normal.  Need to override the i386      default which is [unfortunately] to decrement the PC.  */
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NTO has shared libraries.  */
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|in_plt_section
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|find_solib_trampoline_target
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|i386nto_pc_in_sigtramp
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|sigcontext_addr
operator|=
name|i386nto_sigcontext_addr
expr_stmt|;
name|tdep
operator|->
name|sc_pc_offset
operator|=
literal|56
expr_stmt|;
name|tdep
operator|->
name|sc_sp_offset
operator|=
literal|68
expr_stmt|;
comment|/* Setjmp()'s return PC saved in EDX (5).  */
name|tdep
operator|->
name|jb_pc_offset
operator|=
literal|20
expr_stmt|;
comment|/* 5x32 bit ints in.  */
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|i386nto_svr4_fetch_link_map_offsets
argument_list|)
expr_stmt|;
comment|/* Our loader handles solib relocations slightly differently than svr4.  */
name|TARGET_SO_RELOCATE_SECTION_ADDRESSES
operator|=
name|nto_relocate_section_addresses
expr_stmt|;
comment|/* Supply a nice function to find our solibs.  */
name|TARGET_SO_FIND_AND_OPEN_SOLIB
operator|=
name|nto_find_and_open_solib
expr_stmt|;
name|init_i386nto_ops
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_i386nto_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_QNXNTO
argument_list|,
name|i386nto_init_abi
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

