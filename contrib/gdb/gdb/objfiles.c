begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB routines for manipulating objfiles.     Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Cygnus Support, using pieces from other GDB modules.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains support routines for creating, manipulating, and    destroying objfile structures. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"bcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|objfile_alloc_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|objfile_free_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Externally visible variables that are owned by this module.    See declarations in objfile.h for more info. */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|object_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all objfiles */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|current_objfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For symbol file being read in */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|symfile_objfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main symbol table loaded from */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|rt_common_objfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For runtime common symbols */
end_comment

begin_comment
comment|/* Locate all mappable sections of a BFD file.     objfile_p_char is a char * to get it through    bfd_map_over_sections; we cast it back to its proper type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_KEEP_SECTION
end_ifndef

begin_define
define|#
directive|define
name|TARGET_KEEP_SECTION
parameter_list|(
name|ASECT
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called via bfd_map_over_sections to build up the section table that    the objfile references.  The objfile contains pointers to the start    of the table (objfile->sections) and to the first location after    the end of the table (objfile->sections_end). */
end_comment

begin_function
specifier|static
name|void
name|add_to_objfile_sections
parameter_list|(
name|struct
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|objfile_p_char
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|objfile_p_char
decl_stmt|;
name|struct
name|obj_section
name|section
decl_stmt|;
name|flagword
name|aflag
decl_stmt|;
name|aflag
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aflag
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|!
operator|(
name|TARGET_KEEP_SECTION
argument_list|(
name|asect
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
condition|)
return|return;
name|section
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|section
operator|.
name|objfile
operator|=
name|objfile
expr_stmt|;
name|section
operator|.
name|the_bfd_section
operator|=
name|asect
expr_stmt|;
name|section
operator|.
name|ovly_mapped
operator|=
literal|0
expr_stmt|;
name|section
operator|.
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|section
operator|.
name|endaddr
operator|=
name|section
operator|.
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|section
argument_list|,
sizeof|sizeof
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections_end
operator|=
operator|(
expr|struct
name|obj_section
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|objfile
operator|->
name|sections_end
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Builds a section table for OBJFILE.    Returns 0 if OK, 1 on error (in which case bfd_error contains the    error).     Note that while we are building the table, which goes into the    psymbol obstack, we hijack the sections_end pointer to instead hold    a count of the number of sections.  When bfd_map_over_sections    returns, this count is used to compute the pointer to the end of    the sections table, which then overwrites the count.     Also note that the OFFSET and OVLY_MAPPED in each table entry    are initialized to zero.     Also note that if anything else writes to the psymbol obstack while    we are building the table, we're pretty much hosed. */
end_comment

begin_function
name|int
name|build_objfile_section_table
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* objfile->sections can be already set when reading a mapped symbol      file.  I believe that we do need to rebuild the section table in      this case (we rebuild other things derived from the bfd), but we      can't free the old one (it's in the objfile_obstack).  So we just      waste some memory.  */
name|objfile
operator|->
name|sections_end
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|add_to_objfile_sections
argument_list|,
operator|(
name|char
operator|*
operator|)
name|objfile
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections
operator|=
operator|(
expr|struct
name|obj_section
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections_end
operator|=
name|objfile
operator|->
name|sections
operator|+
operator|(
name|unsigned
name|long
operator|)
name|objfile
operator|->
name|sections_end
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an initialized bfd (ABFD) and some flag bits    allocate a new objfile struct, fill it in as best we can, link it    into the list of all known objfiles, and return a pointer to the    new objfile struct.     The FLAGS word contains various bits (OBJF_*) that can be taken as    requests for specific operations.  Other bits like OBJF_SHARED are    simply copied through to the new objfile flags member. */
end_comment

begin_comment
comment|/* NOTE: carlton/2003-02-04: This function is called with args NULL, 0    by jv-lang.c, to create an artificial objfile used to hold    information about dynamically-loaded Java classes.  Unfortunately,    that branch of this function doesn't get tested very frequently, so    it's prone to breakage.  (E.g. at one time the name was set to NULL    in that situation, which broke a loop over all names in the dynamic    library loader.)  If you change this function, please try to leave    things in a consistent state even if abfd is NULL.  */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|allocate_objfile
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
name|struct
name|objfile
modifier|*
name|last_one
init|=
name|NULL
decl_stmt|;
comment|/* If we don't support mapped symbol files, didn't ask for the file to be      mapped, or failed to open the mapped file for some reason, then revert      back to an unmapped objfile. */
if|if
condition|(
name|objfile
operator|==
name|NULL
condition|)
block|{
name|objfile
operator|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|psymbol_cache
operator|=
name|bcache_xmalloc
argument_list|()
expr_stmt|;
name|objfile
operator|->
name|macro_cache
operator|=
name|bcache_xmalloc
argument_list|()
expr_stmt|;
comment|/* We could use obstack_specify_allocation here instead, but 	 gdb_obstack.h specifies the alloc/dealloc functions.  */
name|obstack_init
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|terminate_minimal_symbol_table
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
name|objfile_alloc_data
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Update the per-objfile information that comes from the bfd, ensuring      that any data that is reference is saved in the per-objfile data      region. */
name|objfile
operator|->
name|obfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|!=
name|NULL
condition|)
block|{
name|objfile
operator|->
name|name
operator|=
name|mstrsave
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Build section table.  */
if|if
condition|(
name|build_objfile_section_table
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|objfile
operator|->
name|name
operator|=
name|mstrsave
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
literal|"<<anonymous objfile>>"
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the section indexes for this objfile, so that we can      later detect if they are used w/o being properly assigned to. */
name|objfile
operator|->
name|sect_index_text
operator|=
operator|-
literal|1
expr_stmt|;
name|objfile
operator|->
name|sect_index_data
operator|=
operator|-
literal|1
expr_stmt|;
name|objfile
operator|->
name|sect_index_bss
operator|=
operator|-
literal|1
expr_stmt|;
name|objfile
operator|->
name|sect_index_rodata
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We don't yet have a C++-specific namespace symtab.  */
name|objfile
operator|->
name|cp_namespace_symtab
operator|=
name|NULL
expr_stmt|;
comment|/* Add this file onto the tail of the linked list of other such files. */
name|objfile
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|object_files
operator|==
name|NULL
condition|)
name|object_files
operator|=
name|objfile
expr_stmt|;
else|else
block|{
for|for
control|(
name|last_one
operator|=
name|object_files
init|;
name|last_one
operator|->
name|next
condition|;
name|last_one
operator|=
name|last_one
operator|->
name|next
control|)
empty_stmt|;
name|last_one
operator|->
name|next
operator|=
name|objfile
expr_stmt|;
block|}
comment|/* Save passed in flag bits. */
name|objfile
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
return|return
operator|(
name|objfile
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize entry point information for this objfile. */
end_comment

begin_function
name|void
name|init_entry_point_info
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Save startup file's range of PC addresses to help blockframe.c      decide where the bottom of the stack is.  */
if|if
condition|(
name|bfd_get_file_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Executable file -- record its entry point so we'll recognize          the startup file because it contains the entry point.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|bfd_get_start_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Examination of non-executable.o files.  Short-circuit this stuff.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|INVALID_ENTRY_POINT
expr_stmt|;
block|}
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get current entry point address.  */
end_comment

begin_function
name|CORE_ADDR
name|entry_point_address
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|symfile_objfile
condition|?
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create the terminating entry of OBJFILE's minimal symbol table.    If OBJFILE->msymbols is zero, allocate a single entry from    OBJFILE->objfile_obstack; otherwise, just initialize    OBJFILE->msymbols[OBJFILE->minimal_symbol_count].  */
end_comment

begin_function
name|void
name|terminate_minimal_symbol_table
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|objfile
operator|->
name|msymbols
condition|)
name|objfile
operator|->
name|msymbols
operator|=
operator|(
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|msymbols
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
init|=
operator|&
name|objfile
operator|->
name|msymbols
index|[
name|objfile
operator|->
name|minimal_symbol_count
index|]
decl_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't rely on these enumeration values being 0's.  */
name|MSYMBOL_TYPE
argument_list|(
name|m
argument_list|)
operator|=
name|mst_unknown
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
name|m
argument_list|,
name|language_unknown
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put one object file before a specified on in the global list.    This can be used to make sure an object file is destroyed before    another when using ALL_OBJFILES_SAFE to free all objfiles. */
end_comment

begin_function
name|void
name|put_objfile_before
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|objfile
modifier|*
name|before_this
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
modifier|*
name|objp
decl_stmt|;
name|unlink_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
for|for
control|(
name|objp
operator|=
operator|&
name|object_files
init|;
operator|*
name|objp
operator|!=
name|NULL
condition|;
name|objp
operator|=
operator|&
operator|(
operator|(
operator|*
name|objp
operator|)
operator|->
name|next
operator|)
control|)
block|{
if|if
condition|(
operator|*
name|objp
operator|==
name|before_this
condition|)
block|{
name|objfile
operator|->
name|next
operator|=
operator|*
name|objp
expr_stmt|;
operator|*
name|objp
operator|=
name|objfile
expr_stmt|;
return|return;
block|}
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"put_objfile_before: before objfile not in list"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put OBJFILE at the front of the list.  */
end_comment

begin_function
name|void
name|objfile_to_front
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
modifier|*
name|objp
decl_stmt|;
for|for
control|(
name|objp
operator|=
operator|&
name|object_files
init|;
operator|*
name|objp
operator|!=
name|NULL
condition|;
name|objp
operator|=
operator|&
operator|(
operator|(
operator|*
name|objp
operator|)
operator|->
name|next
operator|)
control|)
block|{
if|if
condition|(
operator|*
name|objp
operator|==
name|objfile
condition|)
block|{
comment|/* Unhook it from where it is.  */
operator|*
name|objp
operator|=
name|objfile
operator|->
name|next
expr_stmt|;
comment|/* Put it in the front.  */
name|objfile
operator|->
name|next
operator|=
name|object_files
expr_stmt|;
name|object_files
operator|=
name|objfile
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Unlink OBJFILE from the list of known objfiles, if it is found in the    list.     It is not a bug, or error, to call this function if OBJFILE is not known    to be in the current list.  This is done in the case of mapped objfiles,    for example, just to ensure that the mapped objfile doesn't appear twice    in the list.  Since the list is threaded, linking in a mapped objfile    twice would create a circular list.     If OBJFILE turns out to be in the list, we zap it's NEXT pointer after    unlinking it, just to ensure that we have completely severed any linkages    between the OBJFILE and the list. */
end_comment

begin_function
name|void
name|unlink_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
modifier|*
name|objpp
decl_stmt|;
for|for
control|(
name|objpp
operator|=
operator|&
name|object_files
init|;
operator|*
name|objpp
operator|!=
name|NULL
condition|;
name|objpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|objpp
operator|)
operator|->
name|next
operator|)
control|)
block|{
if|if
condition|(
operator|*
name|objpp
operator|==
name|objfile
condition|)
block|{
operator|*
name|objpp
operator|=
operator|(
operator|*
name|objpp
operator|)
operator|->
name|next
expr_stmt|;
name|objfile
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unlink_objfile: objfile already unlinked"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destroy an objfile and all the symtabs and psymtabs under it.  Note    that as much as possible is allocated on the objfile_obstack     so that the memory can be efficiently freed.     Things which we do NOT free because they are not in malloc'd memory    or not in memory specific to the objfile include:     objfile -> sf     FIXME:  If the objfile is using reusable symbol information (via mmalloc),    then we need to take into account the fact that more than one process    may be using the symbol information at the same time (when mmalloc is    extended to support cooperative locking).  When more than one process    is using the mapped symbol info, we need to be more careful about when    we free objects in the reusable area. */
end_comment

begin_function
name|void
name|free_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|objfile
operator|->
name|separate_debug_objfile
condition|)
block|{
name|free_objfile
argument_list|(
name|objfile
operator|->
name|separate_debug_objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|separate_debug_objfile_backlink
condition|)
block|{
comment|/* We freed the separate debug file, make sure the base objfile 	 doesn't reference it.  */
name|objfile
operator|->
name|separate_debug_objfile_backlink
operator|->
name|separate_debug_objfile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* First do any symbol file specific actions required when we are      finished with a particular symbol file.  Note that if the objfile      is using reusable symbol information (via mmalloc) then each of      these routines is responsible for doing the correct thing, either      freeing things which are valid only during this particular gdb      execution, or leaving them to be reused during the next one. */
if|if
condition|(
name|objfile
operator|->
name|sf
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_finish
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We always close the bfd. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Remove it from the chain of all objfiles. */
name|unlink_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* If we are going to free the runtime common objfile, mark it      as unallocated.  */
if|if
condition|(
name|objfile
operator|==
name|rt_common_objfile
condition|)
name|rt_common_objfile
operator|=
name|NULL
expr_stmt|;
comment|/* Before the symbol table code was redone to make it easier to      selectively load and remove information particular to a specific      linkage unit, gdb used to do these things whenever the monolithic      symbol table was blown away.  How much still needs to be done      is unknown, but we play it safe for now and keep each action until      it is shown to be no longer needed. */
comment|/* I *think* all our callers call clear_symtab_users.  If so, no need      to call this here.  */
name|clear_pc_function_cache
argument_list|()
expr_stmt|;
comment|/* The last thing we do is free the objfile struct itself. */
name|objfile_free_data
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* Free the obstacks for non-reusable objfiles */
name|bcache_xfree
argument_list|(
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
name|bcache_xfree
argument_list|(
name|objfile
operator|->
name|macro_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|demangled_names_hash
condition|)
name|htab_delete
argument_list|(
name|objfile
operator|->
name|demangled_names_hash
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|objfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_objfile_cleanup
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|free_objfile
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|obj
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_objfile_cleanup
argument_list|,
name|obj
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free all the object files at once and clean up their users.  */
end_comment

begin_function
name|void
name|free_all_objfiles
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_OBJFILES_SAFE
argument_list|(
argument|objfile
argument_list|,
argument|temp
argument_list|)
block|{
name|free_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate OBJFILE to NEW_OFFSETS.  There should be OBJFILE->NUM_SECTIONS    entries in new_offsets.  */
end_comment

begin_function
name|void
name|objfile_relocate
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|new_offsets
parameter_list|)
block|{
name|struct
name|section_offsets
modifier|*
name|delta
init|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
operator|)
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
block|{
name|delta
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|ANOFFSET
argument_list|(
name|new_offsets
argument_list|,
name|i
argument_list|)
operator|-
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|something_changed
condition|)
return|return;
block|}
comment|/* OK, get all the symtabs.  */
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|ALL_OBJFILE_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First the line table.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|nitems
condition|;
operator|++
name|i
control|)
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
block|}
comment|/* Don't relocate a shared blockvector more than once.  */
if|if
condition|(
operator|!
name|s
operator|->
name|primary
condition|)
continue|continue;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The RS6000 code from which this was taken skipped 	         any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN. 	         But I'm leaving out that test, on the theory that 	         they can't possibly pass the tests below.  */
if|if
condition|(
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_STATIC
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_INDIRECT
operator|)
operator|&&
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MIPS_EFI_SYMBOL_NAME
comment|/* Relocate Extra Function Info for ecoff.  */
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_CONST
operator|&&
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|LABEL_DOMAIN
operator|&&
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
operator|==
literal|0
condition|)
name|ecoff_relocate_efi
argument_list|(
name|sym
argument_list|,
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|{
name|struct
name|partial_symtab
modifier|*
name|p
decl_stmt|;
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|p
argument_list|)
block|{
name|p
operator|->
name|textlow
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|texthigh
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
init|;
name|psym
operator|<
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
condition|;
name|psym
operator|++
control|)
block|{
name|fixup_psymbol_section
argument_list|(
operator|*
name|psym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_SECTION
argument_list|(
operator|*
name|psym
argument_list|)
operator|>=
literal|0
condition|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|*
name|psym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
operator|*
name|psym
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
init|;
name|psym
operator|<
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
condition|;
name|psym
operator|++
control|)
block|{
name|fixup_psymbol_section
argument_list|(
operator|*
name|psym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_SECTION
argument_list|(
operator|*
name|psym
argument_list|)
operator|>=
literal|0
condition|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|*
name|psym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
operator|*
name|psym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|ALL_OBJFILE_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msym
argument_list|)
if|if
condition|(
name|SYMBOL_SECTION
argument_list|(
name|msym
argument_list|)
operator|>=
literal|0
condition|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Relocating different sections by different amounts may cause the symbols      to be out of order.  */
name|msymbols_sort
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
operator|(
name|objfile
operator|->
name|section_offsets
operator|)
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|ANOFFSET
argument_list|(
name|new_offsets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|!=
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
block|{
comment|/* Relocate ei.entry_point with its section offset, use SECT_OFF_TEXT 	 only as a fallback.  */
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|find_pc_section
argument_list|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|the_bfd_section
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|int
name|idx
init|=
name|s
operator|->
name|the_bfd_section
operator|->
name|index
decl_stmt|;
name|s
operator|->
name|addr
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|!=
name|INVALID_ENTRY_LOWPC
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|!=
name|INVALID_ENTRY_LOWPC
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_highpc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|!=
name|INVALID_ENTRY_LOWPC
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Relocate breakpoints as necessary, after things are relocated. */
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Many places in gdb want to test just to see if we have any partial    symbols available.  This function returns zero if none are currently    available, nonzero otherwise. */
end_comment

begin_function
name|int
name|have_partial_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofp
argument_list|)
block|{
if|if
condition|(
name|ofp
operator|->
name|psymtabs
operator|!=
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Many places in gdb want to test just to see if we have any full    symbols available.  This function returns zero if none are currently    available, nonzero otherwise. */
end_comment

begin_function
name|int
name|have_full_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofp
argument_list|)
block|{
if|if
condition|(
name|ofp
operator|->
name|symtabs
operator|!=
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This operations deletes all objfile entries that represent solibs that    weren't explicitly loaded by the user, via e.g., the add-symbol-file    command.  */
end_comment

begin_function
name|void
name|objfile_purge_solibs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objf
decl_stmt|;
name|struct
name|objfile
modifier|*
name|temp
decl_stmt|;
name|ALL_OBJFILES_SAFE
argument_list|(
argument|objf
argument_list|,
argument|temp
argument_list|)
block|{
comment|/* We assume that the solib package has been purged already, or will        be soon.      */
if|if
condition|(
operator|!
operator|(
name|objf
operator|->
name|flags
operator|&
name|OBJF_USERLOADED
operator|)
operator|&&
operator|(
name|objf
operator|->
name|flags
operator|&
name|OBJF_SHARED
operator|)
condition|)
name|free_objfile
argument_list|(
name|objf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Many places in gdb want to test just to see if we have any minimal    symbols available.  This function returns zero if none are currently    available, nonzero otherwise. */
end_comment

begin_function
name|int
name|have_minimal_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofp
argument_list|)
block|{
if|if
condition|(
name|ofp
operator|->
name|minimal_symbol_count
operator|>
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns a section whose range includes PC and SECTION, or NULL if    none found.  Note the distinction between the return type, struct    obj_section (which is defined in gdb), and the input type "struct    bfd_section" (which is a bfd-defined data type).  The obj_section    contains a pointer to the "struct bfd_section".  */
end_comment

begin_function
name|struct
name|obj_section
modifier|*
name|find_pc_sect_section
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
if|if
condition|(
operator|(
name|section
operator|==
literal|0
operator|||
name|section
operator|==
name|s
operator|->
name|the_bfd_section
operator|)
operator|&&
name|s
operator|->
name|addr
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|s
operator|->
name|endaddr
condition|)
return|return
operator|(
name|s
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a section whose range includes PC or NULL if none found.     Backward compatibility, no section.  */
end_comment

begin_function
name|struct
name|obj_section
modifier|*
name|find_pc_section
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_section
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* In SVR4, we recognize a trampoline by it's section name.     That is, if the pc is in a section named ".plt" then we are in    a trampoline.  */
end_comment

begin_function
name|int
name|in_plt_section
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|the_bfd_section
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|s
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if NAME is in the import list of OBJFILE.  Else    return zero.  */
end_comment

begin_function
name|int
name|is_in_import_list
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|objfile
operator|||
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|import_list_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|objfile
operator|->
name|import_list
index|[
name|i
index|]
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
name|objfile
operator|->
name|import_list
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep a registry of per-objfile data-pointers required by other GDB    modules.  */
end_comment

begin_struct
struct|struct
name|objfile_data
block|{
name|unsigned
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|objfile_data_registration
block|{
name|struct
name|objfile_data
modifier|*
name|data
decl_stmt|;
name|struct
name|objfile_data_registration
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|objfile_data_registry
block|{
name|struct
name|objfile_data_registration
modifier|*
name|registrations
decl_stmt|;
name|unsigned
name|num_registrations
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|objfile_data_registry
name|objfile_data_registry
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|objfile_data
modifier|*
name|register_objfile_data
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile_data_registration
modifier|*
modifier|*
name|curr
decl_stmt|;
comment|/* Append new registration.  */
for|for
control|(
name|curr
operator|=
operator|&
name|objfile_data_registry
operator|.
name|registrations
init|;
operator|*
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
operator|&
operator|(
operator|*
name|curr
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|curr
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|objfile_data_registration
argument_list|)
expr_stmt|;
operator|(
operator|*
name|curr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|curr
operator|)
operator|->
name|data
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|objfile_data
argument_list|)
expr_stmt|;
operator|(
operator|*
name|curr
operator|)
operator|->
name|data
operator|->
name|index
operator|=
name|objfile_data_registry
operator|.
name|num_registrations
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|curr
operator|)
operator|->
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|objfile_alloc_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|objfile
operator|->
name|data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|num_data
operator|=
name|objfile_data_registry
operator|.
name|num_registrations
expr_stmt|;
name|objfile
operator|->
name|data
operator|=
name|XCALLOC
argument_list|(
name|objfile
operator|->
name|num_data
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|objfile_free_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|objfile
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|objfile
operator|->
name|data
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_objfile_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|objfile
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|objfile
operator|->
name|num_data
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_objfile_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
specifier|const
name|struct
name|objfile_data
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|data
operator|->
name|index
operator|<
name|objfile
operator|->
name|num_data
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|data
index|[
name|data
operator|->
name|index
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|objfile_data
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
specifier|const
name|struct
name|objfile_data
modifier|*
name|data
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|data
operator|->
name|index
operator|<
name|objfile
operator|->
name|num_data
argument_list|)
expr_stmt|;
return|return
name|objfile
operator|->
name|data
index|[
name|data
operator|->
name|index
index|]
return|;
block|}
end_function

end_unit

