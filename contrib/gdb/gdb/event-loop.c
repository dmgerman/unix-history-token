begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Event loop machinery for GDB, the GNU debugger.    Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Elena Zannoni<ezannoni@cygnus.com> of Cygnus Solutions.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POLL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_POLL_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|gdb_event
name|gdb_event
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
name|event_handler_func
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Event for the GDB event system.  Events are queued by calling    async_queue_event and serviced later on by gdb_do_one_event. An    event can be, for instance, a file descriptor becoming ready to be    read. Servicing an event simply means that the procedure PROC will    be called.  We have 2 queues, one for file handlers that we listen    to in the event loop, and one for the file handlers+events that are    ready. The procedure PROC associated with each event is always the    same (handle_file_event).  Its duty is to invoke the handler    associated with the file descriptor whose state change generated    the event, plus doing other cleanups and such. */
end_comment

begin_struct
struct|struct
name|gdb_event
block|{
name|event_handler_func
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call to service this event. */
name|int
name|fd
decl_stmt|;
comment|/* File descriptor that is ready. */
name|struct
name|gdb_event
modifier|*
name|next_event
decl_stmt|;
comment|/* Next in list of events or NULL. */
block|}
struct|;
end_struct

begin_comment
comment|/* Information about each file descriptor we register with the event    loop. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file_handler
block|{
name|int
name|fd
decl_stmt|;
comment|/* File descriptor. */
name|int
name|mask
decl_stmt|;
comment|/* Events we want to monitor: POLLIN, etc. */
name|int
name|ready_mask
decl_stmt|;
comment|/* Events that have been seen since 				   the last time. */
name|handler_func
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when fd is ready. */
name|gdb_client_data
name|client_data
decl_stmt|;
comment|/* Argument to pass to proc. */
name|int
name|error
decl_stmt|;
comment|/* Was an error detected on this fd? */
name|struct
name|file_handler
modifier|*
name|next_file
decl_stmt|;
comment|/* Next registered file descriptor. */
block|}
name|file_handler
typedef|;
end_typedef

begin_comment
comment|/* PROC is a function to be invoked when the READY flag is set. This    happens when there has been a signal and the corresponding signal    handler has 'triggered' this async_signal_handler for    execution. The actual work to be done in response to a signal will    be carried out by PROC at a later time, within process_event. This    provides a deferred execution of signal handlers.    Async_init_signals takes care of setting up such an    asyn_signal_handler for each interesting signal. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|async_signal_handler
block|{
name|int
name|ready
decl_stmt|;
comment|/* If ready, call this handler from the main event loop,  				   using invoke_async_handler. */
name|struct
name|async_signal_handler
modifier|*
name|next_handler
decl_stmt|;
comment|/* Ptr to next handler */
name|sig_handler_func
modifier|*
name|proc
decl_stmt|;
comment|/* Function to call to do the work */
name|gdb_client_data
name|client_data
decl_stmt|;
comment|/* Argument to async_handler_func */
block|}
name|async_signal_handler
typedef|;
end_typedef

begin_comment
comment|/* Event queue:      - the first event in the queue is the head of the queue.     It will be the next to be serviced.    - the last event in the queue      Events can be inserted at the front of the queue or at the end of    the queue.  Events will be extracted from the queue for processing    starting from the head.  Therefore, events inserted at the head of    the queue will be processed in a last in first out fashion, while    those inserted at the tail of the queue will be processed in a first    in first out manner.  All the fields are NULL if the queue is    empty. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|gdb_event
modifier|*
name|first_event
decl_stmt|;
comment|/* First pending event */
name|gdb_event
modifier|*
name|last_event
decl_stmt|;
comment|/* Last pending event */
block|}
name|event_queue
struct|;
end_struct

begin_comment
comment|/* Gdb_notifier is just a list of file descriptors gdb is interested in.    These are the input file descriptor, and the target file    descriptor. We have two flavors of the notifier, one for platforms    that have the POLL function, the other for those that don't, and    only support SELECT. Each of the elements in the gdb_notifier list is    basically a description of what kind of events gdb is interested    in, for each fd. */
end_comment

begin_comment
comment|/* As of 1999-04-30 only the input file descriptor is registered with the    event loop. */
end_comment

begin_comment
comment|/* Do we use poll or select ? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL
end_ifdef

begin_define
define|#
directive|define
name|USE_POLL
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_POLL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_POLL */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|use_poll
init|=
name|USE_POLL
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
comment|/* Ptr to head of file handler list. */
name|file_handler
modifier|*
name|first_file_handler
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POLL
comment|/* Ptr to array of pollfd structures. */
name|struct
name|pollfd
modifier|*
name|poll_fds
decl_stmt|;
comment|/* Timeout in milliseconds for calls to poll(). */
name|int
name|poll_timeout
decl_stmt|;
endif|#
directive|endif
comment|/* Masks to be used in the next call to select.        Bits are set in response to calls to create_file_handler. */
name|fd_set
name|check_masks
index|[
literal|3
index|]
decl_stmt|;
comment|/* What file descriptors were found ready by select. */
name|fd_set
name|ready_masks
index|[
literal|3
index|]
decl_stmt|;
comment|/* Number of file descriptors to monitor. (for poll) */
comment|/* Number of valid bits (highest fd value + 1). (for select) */
name|int
name|num_fds
decl_stmt|;
comment|/* Time structure for calls to select(). */
name|struct
name|timeval
name|select_timeout
decl_stmt|;
comment|/* Flag to tell whether the timeout should be used. */
name|int
name|timeout_valid
decl_stmt|;
block|}
name|gdb_notifier
struct|;
end_struct

begin_comment
comment|/* Structure associated with a timer. PROC will be executed at the    first occasion after WHEN. */
end_comment

begin_struct
struct|struct
name|gdb_timer
block|{
name|struct
name|timeval
name|when
decl_stmt|;
name|int
name|timer_id
decl_stmt|;
name|struct
name|gdb_timer
modifier|*
name|next
decl_stmt|;
name|timer_handler_func
modifier|*
name|proc
decl_stmt|;
comment|/* Function to call to do the work */
name|gdb_client_data
name|client_data
decl_stmt|;
comment|/* Argument to async_handler_func */
block|}
name|gdb_timer
struct|;
end_struct

begin_comment
comment|/* List of currently active timers. It is sorted in order of    increasing timers. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* Pointer to first in timer list. */
name|struct
name|gdb_timer
modifier|*
name|first_timer
decl_stmt|;
comment|/* Id of the last timer created. */
name|int
name|num_timers
decl_stmt|;
block|}
name|timer_list
struct|;
end_struct

begin_comment
comment|/* All the async_signal_handlers gdb is interested in are kept onto    this list. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* Pointer to first in handler list. */
name|async_signal_handler
modifier|*
name|first_handler
decl_stmt|;
comment|/* Pointer to last in handler list. */
name|async_signal_handler
modifier|*
name|last_handler
decl_stmt|;
block|}
name|sighandler_list
struct|;
end_struct

begin_comment
comment|/* Are any of the handlers ready?  Check this variable using    check_async_ready. This is used by process_event, to determine    whether or not to invoke the invoke_async_signal_handler    function. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_handler_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|create_file_handler
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|mask
parameter_list|,
name|handler_func
modifier|*
name|proc
parameter_list|,
name|gdb_client_data
name|client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invoke_async_signal_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_file_event
parameter_list|(
name|int
name|event_file_desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdb_wait_for_event
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_async_ready
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_queue_event
parameter_list|(
name|gdb_event
modifier|*
name|event_ptr
parameter_list|,
name|queue_position
name|position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdb_event
modifier|*
name|create_file_event
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_event
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_timer_event
parameter_list|(
name|int
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|poll_timers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Insert an event object into the gdb event queue at     the specified position.    POSITION can be head or tail, with values TAIL, HEAD.    EVENT_PTR points to the event to be inserted into the queue.    The caller must allocate memory for the event. It is freed    after the event has ben handled.    Events in the queue will be processed head to tail, therefore,    events inserted at the head of the queue will be processed    as last in first out. Event appended at the tail of the queue    will be processed first in first out. */
end_comment

begin_function
specifier|static
name|void
name|async_queue_event
parameter_list|(
name|gdb_event
modifier|*
name|event_ptr
parameter_list|,
name|queue_position
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|==
name|TAIL
condition|)
block|{
comment|/* The event will become the new last_event. */
name|event_ptr
operator|->
name|next_event
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|event_queue
operator|.
name|first_event
operator|==
name|NULL
condition|)
name|event_queue
operator|.
name|first_event
operator|=
name|event_ptr
expr_stmt|;
else|else
name|event_queue
operator|.
name|last_event
operator|->
name|next_event
operator|=
name|event_ptr
expr_stmt|;
name|event_queue
operator|.
name|last_event
operator|=
name|event_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|HEAD
condition|)
block|{
comment|/* The event becomes the new first_event. */
name|event_ptr
operator|->
name|next_event
operator|=
name|event_queue
operator|.
name|first_event
expr_stmt|;
if|if
condition|(
name|event_queue
operator|.
name|first_event
operator|==
name|NULL
condition|)
name|event_queue
operator|.
name|last_event
operator|=
name|event_ptr
expr_stmt|;
name|event_queue
operator|.
name|first_event
operator|=
name|event_ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a file event, to be enqueued in the event queue for    processing. The procedure associated to this event is always    handle_file_event, which will in turn invoke the one that was    associated to FD when it was registered with the event loop. */
end_comment

begin_function
specifier|static
name|gdb_event
modifier|*
name|create_file_event
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|gdb_event
modifier|*
name|file_event_ptr
decl_stmt|;
name|file_event_ptr
operator|=
operator|(
name|gdb_event
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdb_event
argument_list|)
argument_list|)
expr_stmt|;
name|file_event_ptr
operator|->
name|proc
operator|=
name|handle_file_event
expr_stmt|;
name|file_event_ptr
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
return|return
operator|(
name|file_event_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process one event.    The event can be the next one to be serviced in the event queue,    or an asynchronous event handler can be invoked in response to    the reception of a signal.    If an event was processed (either way), 1 is returned otherwise    0 is returned.       Scan the queue from head to tail, processing therefore the high    priority events first, by invoking the associated event handler    procedure. */
end_comment

begin_function
specifier|static
name|int
name|process_event
parameter_list|(
name|void
parameter_list|)
block|{
name|gdb_event
modifier|*
name|event_ptr
decl_stmt|,
modifier|*
name|prev_ptr
decl_stmt|;
name|event_handler_func
modifier|*
name|proc
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* First let's see if there are any asynchronous event handlers that      are ready. These would be the result of invoking any of the      signal handlers. */
if|if
condition|(
name|check_async_ready
argument_list|()
condition|)
block|{
name|invoke_async_signal_handler
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Look in the event queue to find an event that is ready      to be processed. */
for|for
control|(
name|event_ptr
operator|=
name|event_queue
operator|.
name|first_event
init|;
name|event_ptr
operator|!=
name|NULL
condition|;
name|event_ptr
operator|=
name|event_ptr
operator|->
name|next_event
control|)
block|{
comment|/* Call the handler for the event. */
name|proc
operator|=
name|event_ptr
operator|->
name|proc
expr_stmt|;
name|fd
operator|=
name|event_ptr
operator|->
name|fd
expr_stmt|;
comment|/* Let's get rid of the event from the event queue.  We need to          do this now because while processing the event, the proc          function could end up calling 'error' and therefore jump out          to the caller of this function, gdb_do_one_event. In that          case, we would have on the event queue an event wich has been          processed, but not deleted. */
if|if
condition|(
name|event_queue
operator|.
name|first_event
operator|==
name|event_ptr
condition|)
block|{
name|event_queue
operator|.
name|first_event
operator|=
name|event_ptr
operator|->
name|next_event
expr_stmt|;
if|if
condition|(
name|event_ptr
operator|->
name|next_event
operator|==
name|NULL
condition|)
name|event_queue
operator|.
name|last_event
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|prev_ptr
operator|=
name|event_queue
operator|.
name|first_event
expr_stmt|;
while|while
condition|(
name|prev_ptr
operator|->
name|next_event
operator|!=
name|event_ptr
condition|)
name|prev_ptr
operator|=
name|prev_ptr
operator|->
name|next_event
expr_stmt|;
name|prev_ptr
operator|->
name|next_event
operator|=
name|event_ptr
operator|->
name|next_event
expr_stmt|;
if|if
condition|(
name|event_ptr
operator|->
name|next_event
operator|==
name|NULL
condition|)
name|event_queue
operator|.
name|last_event
operator|=
name|prev_ptr
expr_stmt|;
block|}
name|xfree
argument_list|(
name|event_ptr
argument_list|)
expr_stmt|;
comment|/* Now call the procedure associated with the event. */
call|(
modifier|*
name|proc
call|)
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* this is the case if there are no event on the event queue. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process one high level event.  If nothing is ready at this time,    wait for something to happen (via gdb_wait_for_event), then process    it.  Returns>0 if something was done otherwise returns<0 (this    can happen if there are no event sources to wait for).  If an error    occurs catch_errors() which calls this function returns zero. */
end_comment

begin_function
name|int
name|gdb_do_one_event
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* Any events already waiting in the queue? */
if|if
condition|(
name|process_event
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Are any timers that are ready? If so, put an event on the queue. */
name|poll_timers
argument_list|()
expr_stmt|;
comment|/* Wait for a new event.  If gdb_wait_for_event returns -1,      we should get out because this means that there are no      event sources left. This will make the event loop stop,      and the application exit. */
if|if
condition|(
name|gdb_wait_for_event
argument_list|()
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* Handle any new events occurred while waiting. */
if|if
condition|(
name|process_event
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* If gdb_wait_for_event has returned 1, it means that one      event has been handled. We break out of the loop. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Start up the event loop. This is the entry point to the event loop    from the command loop. */
end_comment

begin_function
name|void
name|start_event_loop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Loop until there is nothing to do. This is the entry point to the      event loop engine. gdb_do_one_event, called via catch_errors()      will process one event for each invocation.  It blocks waits for      an event and then processes it.>0 when an event is processed, 0      when catch_errors() caught an error and<0 when there are no      longer any event sources registered. */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|gdb_result
decl_stmt|;
name|gdb_result
operator|=
name|catch_errors
argument_list|(
name|gdb_do_one_event
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdb_result
operator|<
literal|0
condition|)
break|break;
comment|/* If we long-jumped out of do_one_event, we probably          didn't get around to resetting the prompt, which leaves          readline in a messed-up state.  Reset it here. */
if|if
condition|(
name|gdb_result
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: this should really be a call to a hook that is 	     interface specific, because interfaces can display the 	     prompt in their own way. */
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This call looks bizarre, but it is required.  If the user 	     entered a command that caused an error, 	     after_char_processing_hook won't be called from 	     rl_callback_read_char_wrapper.  Using a cleanup there 	     won't work, since we want this function to be called 	     after a new prompt is printed.  */
if|if
condition|(
name|after_char_processing_hook
condition|)
call|(
modifier|*
name|after_char_processing_hook
call|)
argument_list|()
expr_stmt|;
comment|/* Maybe better to set a flag to be checked somewhere as to 	     whether display the prompt or not. */
block|}
block|}
comment|/* We are done with the event loop. There are no more event sources      to listen to.  So we exit GDB. */
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrapper function for create_file_handler, so that the caller    doesn't have to know implementation details about the use of poll    vs. select. */
end_comment

begin_function
name|void
name|add_file_handler
parameter_list|(
name|int
name|fd
parameter_list|,
name|handler_func
modifier|*
name|proc
parameter_list|,
name|gdb_client_data
name|client_data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|struct
name|pollfd
name|fds
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
comment|/* Check to see if poll () is usable. If not, we'll switch to          use select. This can happen on systems like          m68k-motorola-sys, `poll' cannot be used to wait for `stdin'.          On m68k-motorola-sysv, tty's are not stream-based and not          `poll'able. */
name|fds
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|fds
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
operator|&
name|fds
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|fds
operator|.
name|revents
operator|&
name|POLLNVAL
operator|)
condition|)
name|use_poll
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|create_file_handler
argument_list|(
name|fd
argument_list|,
name|POLLIN
argument_list|,
name|proc
argument_list|,
name|client_data
argument_list|)
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|create_file_handler
argument_list|(
name|fd
argument_list|,
name|GDB_READABLE
operator||
name|GDB_EXCEPTION
argument_list|,
name|proc
argument_list|,
name|client_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a file handler/descriptor to the list of descriptors we are    interested in.      FD is the file descriptor for the file/stream to be listened to.      For the poll case, MASK is a combination (OR) of    POLLIN, POLLRDNORM, POLLRDBAND, POLLPRI, POLLOUT, POLLWRNORM,    POLLWRBAND: these are the events we are interested in. If any of them     occurs, proc should be called.    For the select case, MASK is a combination of READABLE, WRITABLE, EXCEPTION.    PROC is the procedure that will be called when an event occurs for    FD.  CLIENT_DATA is the argument to pass to PROC. */
end_comment

begin_function
specifier|static
name|void
name|create_file_handler
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|mask
parameter_list|,
name|handler_func
modifier|*
name|proc
parameter_list|,
name|gdb_client_data
name|client_data
parameter_list|)
block|{
name|file_handler
modifier|*
name|file_ptr
decl_stmt|;
comment|/* Do we already have a file handler for this file? (We may be      changing its associated procedure). */
for|for
control|(
name|file_ptr
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
init|;
name|file_ptr
operator|!=
name|NULL
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|file_ptr
operator|->
name|fd
operator|==
name|fd
condition|)
break|break;
block|}
comment|/* It is a new file descriptor. Add it to the list. Otherwise, just      change the data associated with it. */
if|if
condition|(
name|file_ptr
operator|==
name|NULL
condition|)
block|{
name|file_ptr
operator|=
operator|(
name|file_handler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_handler
argument_list|)
argument_list|)
expr_stmt|;
name|file_ptr
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|file_ptr
operator|->
name|ready_mask
operator|=
literal|0
expr_stmt|;
name|file_ptr
operator|->
name|next_file
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
expr_stmt|;
name|gdb_notifier
operator|.
name|first_file_handler
operator|=
name|file_ptr
expr_stmt|;
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|gdb_notifier
operator|.
name|num_fds
operator|++
expr_stmt|;
if|if
condition|(
name|gdb_notifier
operator|.
name|poll_fds
condition|)
name|gdb_notifier
operator|.
name|poll_fds
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xrealloc
argument_list|(
name|gdb_notifier
operator|.
name|poll_fds
argument_list|,
operator|(
name|gdb_notifier
operator|.
name|num_fds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|gdb_notifier
operator|.
name|poll_fds
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|gdb_notifier
operator|.
name|num_fds
operator|-
literal|1
operator|)
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|gdb_notifier
operator|.
name|num_fds
operator|-
literal|1
operator|)
operator|->
name|events
operator|=
name|mask
expr_stmt|;
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|gdb_notifier
operator|.
name|num_fds
operator|-
literal|1
operator|)
operator|->
name|revents
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|&
name|GDB_READABLE
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|GDB_WRITABLE
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|GDB_EXCEPTION
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdb_notifier
operator|.
name|num_fds
operator|<=
name|fd
condition|)
name|gdb_notifier
operator|.
name|num_fds
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|file_ptr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|file_ptr
operator|->
name|client_data
operator|=
name|client_data
expr_stmt|;
name|file_ptr
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the file descriptor FD from the list of monitored fd's:     i.e. we don't care anymore about events on the FD. */
end_comment

begin_function
name|void
name|delete_file_handler
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|file_handler
modifier|*
name|file_ptr
decl_stmt|,
modifier|*
name|prev_ptr
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POLL
name|int
name|j
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|new_poll_fds
decl_stmt|;
endif|#
directive|endif
comment|/* Find the entry for the given file. */
for|for
control|(
name|file_ptr
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
init|;
name|file_ptr
operator|!=
name|NULL
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|file_ptr
operator|->
name|fd
operator|==
name|fd
condition|)
break|break;
block|}
if|if
condition|(
name|file_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
comment|/* Create a new poll_fds array by copying every fd's information but the          one we want to get rid of. */
name|new_poll_fds
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|gdb_notifier
operator|.
name|num_fds
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|gdb_notifier
operator|.
name|num_fds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|fd
operator|!=
name|fd
condition|)
block|{
operator|(
name|new_poll_fds
operator|+
name|j
operator|)
operator|->
name|fd
operator|=
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|fd
expr_stmt|;
operator|(
name|new_poll_fds
operator|+
name|j
operator|)
operator|->
name|events
operator|=
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|events
expr_stmt|;
operator|(
name|new_poll_fds
operator|+
name|j
operator|)
operator|->
name|revents
operator|=
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|revents
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|xfree
argument_list|(
name|gdb_notifier
operator|.
name|poll_fds
argument_list|)
expr_stmt|;
name|gdb_notifier
operator|.
name|poll_fds
operator|=
name|new_poll_fds
expr_stmt|;
name|gdb_notifier
operator|.
name|num_fds
operator|--
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
else|else
block|{
if|if
condition|(
name|file_ptr
operator|->
name|mask
operator|&
name|GDB_READABLE
condition|)
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_ptr
operator|->
name|mask
operator|&
name|GDB_WRITABLE
condition|)
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_ptr
operator|->
name|mask
operator|&
name|GDB_EXCEPTION
condition|)
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Find current max fd. */
if|if
condition|(
operator|(
name|fd
operator|+
literal|1
operator|)
operator|==
name|gdb_notifier
operator|.
name|num_fds
condition|)
block|{
name|gdb_notifier
operator|.
name|num_fds
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|gdb_notifier
operator|.
name|num_fds
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
operator|-
literal|1
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|0
index|]
argument_list|)
operator|||
name|FD_ISSET
argument_list|(
name|i
operator|-
literal|1
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|1
index|]
argument_list|)
operator|||
name|FD_ISSET
argument_list|(
name|i
operator|-
literal|1
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|2
index|]
argument_list|)
condition|)
break|break;
block|}
name|gdb_notifier
operator|.
name|num_fds
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Deactivate the file descriptor, by clearing its mask,       so that it will not fire again. */
name|file_ptr
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
comment|/* Get rid of the file handler in the file handler list. */
if|if
condition|(
name|file_ptr
operator|==
name|gdb_notifier
operator|.
name|first_file_handler
condition|)
name|gdb_notifier
operator|.
name|first_file_handler
operator|=
name|file_ptr
operator|->
name|next_file
expr_stmt|;
else|else
block|{
for|for
control|(
name|prev_ptr
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
init|;
name|prev_ptr
operator|->
name|next_file
operator|!=
name|file_ptr
condition|;
name|prev_ptr
operator|=
name|prev_ptr
operator|->
name|next_file
control|)
empty_stmt|;
name|prev_ptr
operator|->
name|next_file
operator|=
name|file_ptr
operator|->
name|next_file
expr_stmt|;
block|}
name|xfree
argument_list|(
name|file_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the given event by calling the procedure associated to the    corresponding file handler.  Called by process_event indirectly,    through event_ptr->proc.  EVENT_FILE_DESC is file descriptor of the    event in the front of the event queue. */
end_comment

begin_function
specifier|static
name|void
name|handle_file_event
parameter_list|(
name|int
name|event_file_desc
parameter_list|)
block|{
name|file_handler
modifier|*
name|file_ptr
decl_stmt|;
name|int
name|mask
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POLL
name|int
name|error_mask
decl_stmt|;
name|int
name|error_mask_returned
decl_stmt|;
endif|#
directive|endif
comment|/* Search the file handler list to find one that matches the fd in      the event. */
for|for
control|(
name|file_ptr
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
init|;
name|file_ptr
operator|!=
name|NULL
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|file_ptr
operator|->
name|fd
operator|==
name|event_file_desc
condition|)
block|{
comment|/* With poll, the ready_mask could have any of three events 	     set to 1: POLLHUP, POLLERR, POLLNVAL. These events cannot 	     be used in the requested event mask (events), but they 	     can be returned in the return mask (revents). We need to 	     check for those event too, and add them to the mask which 	     will be passed to the handler. */
comment|/* See if the desired events (mask) match the received 	     events (ready_mask). */
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|error_mask
operator|=
name|POLLHUP
operator||
name|POLLERR
operator||
name|POLLNVAL
expr_stmt|;
name|mask
operator|=
operator|(
name|file_ptr
operator|->
name|ready_mask
operator|&
name|file_ptr
operator|->
name|mask
operator|)
operator||
operator|(
name|file_ptr
operator|->
name|ready_mask
operator|&
name|error_mask
operator|)
expr_stmt|;
name|error_mask_returned
operator|=
name|mask
operator|&
name|error_mask
expr_stmt|;
if|if
condition|(
name|error_mask_returned
operator|!=
literal|0
condition|)
block|{
comment|/* Work in progress. We may need to tell somebody what 		     kind of error we had. */
if|if
condition|(
name|error_mask_returned
operator|&
name|POLLHUP
condition|)
name|printf_unfiltered
argument_list|(
literal|"Hangup detected on fd %d\n"
argument_list|,
name|file_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_mask_returned
operator|&
name|POLLERR
condition|)
name|printf_unfiltered
argument_list|(
literal|"Error detected on fd %d\n"
argument_list|,
name|file_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_mask_returned
operator|&
name|POLLNVAL
condition|)
name|printf_unfiltered
argument_list|(
literal|"Invalid or non-`poll'able fd %d\n"
argument_list|,
name|file_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file_ptr
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|file_ptr
operator|->
name|error
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
else|else
block|{
if|if
condition|(
name|file_ptr
operator|->
name|ready_mask
operator|&
name|GDB_EXCEPTION
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Exception condition detected on fd %d\n"
argument_list|,
name|file_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file_ptr
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|file_ptr
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|file_ptr
operator|->
name|ready_mask
operator|&
name|file_ptr
operator|->
name|mask
expr_stmt|;
block|}
comment|/* Clear the received events for next time around. */
name|file_ptr
operator|->
name|ready_mask
operator|=
literal|0
expr_stmt|;
comment|/* If there was a match, then call the handler. */
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
call|(
modifier|*
name|file_ptr
operator|->
name|proc
call|)
argument_list|(
name|file_ptr
operator|->
name|error
argument_list|,
name|file_ptr
operator|->
name|client_data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called by gdb_do_one_event to wait for new events on the     monitored file descriptors. Queue file events as they are     detected by the poll.     If there are no events, this function will block in the     call to poll.    Return -1 if there are no files descriptors to monitor,     otherwise return 0. */
end_comment

begin_function
specifier|static
name|int
name|gdb_wait_for_event
parameter_list|(
name|void
parameter_list|)
block|{
name|file_handler
modifier|*
name|file_ptr
decl_stmt|;
name|gdb_event
modifier|*
name|file_event_ptr
decl_stmt|;
name|int
name|num_found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make sure all output is done before getting another event. */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdb_notifier
operator|.
name|num_fds
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|num_found
operator|=
name|poll
argument_list|(
name|gdb_notifier
operator|.
name|poll_fds
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gdb_notifier
operator|.
name|num_fds
argument_list|,
name|gdb_notifier
operator|.
name|timeout_valid
condition|?
name|gdb_notifier
operator|.
name|poll_timeout
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't print anything if we get out of poll because of a          signal. */
if|if
condition|(
name|num_found
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|perror_with_name
argument_list|(
literal|"Poll"
argument_list|)
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
else|else
block|{
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|0
index|]
operator|=
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|0
index|]
expr_stmt|;
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|1
index|]
operator|=
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|1
index|]
expr_stmt|;
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|2
index|]
operator|=
name|gdb_notifier
operator|.
name|check_masks
index|[
literal|2
index|]
expr_stmt|;
name|num_found
operator|=
name|select
argument_list|(
name|gdb_notifier
operator|.
name|num_fds
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|0
index|]
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|1
index|]
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|2
index|]
argument_list|,
name|gdb_notifier
operator|.
name|timeout_valid
condition|?
operator|&
name|gdb_notifier
operator|.
name|select_timeout
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* Clear the masks after an error from select. */
if|if
condition|(
name|num_found
operator|==
operator|-
literal|1
condition|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Dont print anything is we got a signal, let gdb handle it. */
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|perror_with_name
argument_list|(
literal|"Select"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enqueue all detected file events. */
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|gdb_notifier
operator|.
name|num_fds
operator|)
operator|&&
operator|(
name|num_found
operator|>
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|revents
condition|)
name|num_found
operator|--
expr_stmt|;
else|else
continue|continue;
for|for
control|(
name|file_ptr
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
init|;
name|file_ptr
operator|!=
name|NULL
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|file_ptr
operator|->
name|fd
operator|==
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|fd
condition|)
break|break;
block|}
if|if
condition|(
name|file_ptr
condition|)
block|{
comment|/* Enqueue an event only if this is still a new event for 	         this fd. */
if|if
condition|(
name|file_ptr
operator|->
name|ready_mask
operator|==
literal|0
condition|)
block|{
name|file_event_ptr
operator|=
name|create_file_event
argument_list|(
name|file_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|async_queue_event
argument_list|(
name|file_event_ptr
argument_list|,
name|TAIL
argument_list|)
expr_stmt|;
block|}
block|}
name|file_ptr
operator|->
name|ready_mask
operator|=
operator|(
name|gdb_notifier
operator|.
name|poll_fds
operator|+
name|i
operator|)
operator|->
name|revents
expr_stmt|;
block|}
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
else|else
block|{
for|for
control|(
name|file_ptr
operator|=
name|gdb_notifier
operator|.
name|first_file_handler
init|;
operator|(
name|file_ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|num_found
operator|>
literal|0
operator|)
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|file_ptr
operator|->
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|0
index|]
argument_list|)
condition|)
name|mask
operator||=
name|GDB_READABLE
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|file_ptr
operator|->
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|1
index|]
argument_list|)
condition|)
name|mask
operator||=
name|GDB_WRITABLE
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|file_ptr
operator|->
name|fd
argument_list|,
operator|&
name|gdb_notifier
operator|.
name|ready_masks
index|[
literal|2
index|]
argument_list|)
condition|)
name|mask
operator||=
name|GDB_EXCEPTION
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
continue|continue;
else|else
name|num_found
operator|--
expr_stmt|;
comment|/* Enqueue an event only if this is still a new event for 	     this fd. */
if|if
condition|(
name|file_ptr
operator|->
name|ready_mask
operator|==
literal|0
condition|)
block|{
name|file_event_ptr
operator|=
name|create_file_event
argument_list|(
name|file_ptr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|async_queue_event
argument_list|(
name|file_event_ptr
argument_list|,
name|TAIL
argument_list|)
expr_stmt|;
block|}
name|file_ptr
operator|->
name|ready_mask
operator|=
name|mask
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an asynchronous handler, allocating memory for it.     Return a pointer to the newly created handler.    This pointer will be used to invoke the handler by     invoke_async_signal_handler.    PROC is the function to call with CLIENT_DATA argument     whenever the handler is invoked. */
end_comment

begin_function
name|async_signal_handler
modifier|*
name|create_async_signal_handler
parameter_list|(
name|sig_handler_func
modifier|*
name|proc
parameter_list|,
name|gdb_client_data
name|client_data
parameter_list|)
block|{
name|async_signal_handler
modifier|*
name|async_handler_ptr
decl_stmt|;
name|async_handler_ptr
operator|=
operator|(
name|async_signal_handler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|async_signal_handler
argument_list|)
argument_list|)
expr_stmt|;
name|async_handler_ptr
operator|->
name|ready
operator|=
literal|0
expr_stmt|;
name|async_handler_ptr
operator|->
name|next_handler
operator|=
name|NULL
expr_stmt|;
name|async_handler_ptr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|async_handler_ptr
operator|->
name|client_data
operator|=
name|client_data
expr_stmt|;
if|if
condition|(
name|sighandler_list
operator|.
name|first_handler
operator|==
name|NULL
condition|)
name|sighandler_list
operator|.
name|first_handler
operator|=
name|async_handler_ptr
expr_stmt|;
else|else
name|sighandler_list
operator|.
name|last_handler
operator|->
name|next_handler
operator|=
name|async_handler_ptr
expr_stmt|;
name|sighandler_list
operator|.
name|last_handler
operator|=
name|async_handler_ptr
expr_stmt|;
return|return
name|async_handler_ptr
return|;
block|}
end_function

begin_comment
comment|/* Mark the handler (ASYNC_HANDLER_PTR) as ready. This information will    be used when the handlers are invoked, after we have waited for    some event.  The caller of this function is the interrupt handler    associated with a signal. */
end_comment

begin_function
name|void
name|mark_async_signal_handler
parameter_list|(
name|async_signal_handler
modifier|*
name|async_handler_ptr
parameter_list|)
block|{
operator|(
operator|(
name|async_signal_handler
operator|*
operator|)
name|async_handler_ptr
operator|)
operator|->
name|ready
operator|=
literal|1
expr_stmt|;
name|async_handler_ready
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call all the handlers that are ready. */
end_comment

begin_function
specifier|static
name|void
name|invoke_async_signal_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|async_signal_handler
modifier|*
name|async_handler_ptr
decl_stmt|;
if|if
condition|(
name|async_handler_ready
operator|==
literal|0
condition|)
return|return;
name|async_handler_ready
operator|=
literal|0
expr_stmt|;
comment|/* Invoke ready handlers. */
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|async_handler_ptr
operator|=
name|sighandler_list
operator|.
name|first_handler
init|;
name|async_handler_ptr
operator|!=
name|NULL
condition|;
name|async_handler_ptr
operator|=
name|async_handler_ptr
operator|->
name|next_handler
control|)
block|{
if|if
condition|(
name|async_handler_ptr
operator|->
name|ready
condition|)
break|break;
block|}
if|if
condition|(
name|async_handler_ptr
operator|==
name|NULL
condition|)
break|break;
name|async_handler_ptr
operator|->
name|ready
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|async_handler_ptr
operator|->
name|proc
call|)
argument_list|(
name|async_handler_ptr
operator|->
name|client_data
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).     Free the space allocated for it.  */
end_comment

begin_function
name|void
name|delete_async_signal_handler
parameter_list|(
name|async_signal_handler
modifier|*
modifier|*
name|async_handler_ptr
parameter_list|)
block|{
name|async_signal_handler
modifier|*
name|prev_ptr
decl_stmt|;
if|if
condition|(
name|sighandler_list
operator|.
name|first_handler
operator|==
operator|(
operator|*
name|async_handler_ptr
operator|)
condition|)
block|{
name|sighandler_list
operator|.
name|first_handler
operator|=
operator|(
operator|*
name|async_handler_ptr
operator|)
operator|->
name|next_handler
expr_stmt|;
if|if
condition|(
name|sighandler_list
operator|.
name|first_handler
operator|==
name|NULL
condition|)
name|sighandler_list
operator|.
name|last_handler
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|prev_ptr
operator|=
name|sighandler_list
operator|.
name|first_handler
expr_stmt|;
while|while
condition|(
name|prev_ptr
operator|->
name|next_handler
operator|!=
operator|(
operator|*
name|async_handler_ptr
operator|)
operator|&&
name|prev_ptr
condition|)
name|prev_ptr
operator|=
name|prev_ptr
operator|->
name|next_handler
expr_stmt|;
name|prev_ptr
operator|->
name|next_handler
operator|=
operator|(
operator|*
name|async_handler_ptr
operator|)
operator|->
name|next_handler
expr_stmt|;
if|if
condition|(
name|sighandler_list
operator|.
name|last_handler
operator|==
operator|(
operator|*
name|async_handler_ptr
operator|)
condition|)
name|sighandler_list
operator|.
name|last_handler
operator|=
name|prev_ptr
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
operator|*
name|async_handler_ptr
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|async_handler_ptr
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is it necessary to call invoke_async_signal_handler? */
end_comment

begin_function
specifier|static
name|int
name|check_async_ready
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|async_handler_ready
return|;
block|}
end_function

begin_comment
comment|/* Create a timer that will expire in MILLISECONDS from now. When the    timer is ready, PROC will be executed. At creation, the timer is    aded to the timers queue.  This queue is kept sorted in order of    increasing timers. Return a handle to the timer struct. */
end_comment

begin_function
name|int
name|create_timer
parameter_list|(
name|int
name|milliseconds
parameter_list|,
name|timer_handler_func
modifier|*
name|proc
parameter_list|,
name|gdb_client_data
name|client_data
parameter_list|)
block|{
name|struct
name|gdb_timer
modifier|*
name|timer_ptr
decl_stmt|,
modifier|*
name|timer_index
decl_stmt|,
modifier|*
name|prev_timer
decl_stmt|;
name|struct
name|timeval
name|time_now
decl_stmt|,
name|delta
decl_stmt|;
comment|/* compute seconds */
name|delta
operator|.
name|tv_sec
operator|=
name|milliseconds
operator|/
literal|1000
expr_stmt|;
comment|/* compute microseconds */
name|delta
operator|.
name|tv_usec
operator|=
operator|(
name|milliseconds
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timer_ptr
operator|=
operator|(
expr|struct
name|gdb_timer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdb_timer
argument_list|)
argument_list|)
expr_stmt|;
name|timer_ptr
operator|->
name|when
operator|.
name|tv_sec
operator|=
name|time_now
operator|.
name|tv_sec
operator|+
name|delta
operator|.
name|tv_sec
expr_stmt|;
name|timer_ptr
operator|->
name|when
operator|.
name|tv_usec
operator|=
name|time_now
operator|.
name|tv_usec
operator|+
name|delta
operator|.
name|tv_usec
expr_stmt|;
comment|/* carry? */
if|if
condition|(
name|timer_ptr
operator|->
name|when
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|timer_ptr
operator|->
name|when
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
name|timer_ptr
operator|->
name|when
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
name|timer_ptr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|timer_ptr
operator|->
name|client_data
operator|=
name|client_data
expr_stmt|;
name|timer_list
operator|.
name|num_timers
operator|++
expr_stmt|;
name|timer_ptr
operator|->
name|timer_id
operator|=
name|timer_list
operator|.
name|num_timers
expr_stmt|;
comment|/* Now add the timer to the timer queue, making sure it is sorted in      increasing order of expiration. */
for|for
control|(
name|timer_index
operator|=
name|timer_list
operator|.
name|first_timer
init|;
name|timer_index
operator|!=
name|NULL
condition|;
name|timer_index
operator|=
name|timer_index
operator|->
name|next
control|)
block|{
comment|/* If the seconds field is greater or if it is the same, but the          microsecond field is greater. */
if|if
condition|(
operator|(
name|timer_index
operator|->
name|when
operator|.
name|tv_sec
operator|>
name|timer_ptr
operator|->
name|when
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|timer_index
operator|->
name|when
operator|.
name|tv_sec
operator|==
name|timer_ptr
operator|->
name|when
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|timer_index
operator|->
name|when
operator|.
name|tv_usec
operator|>
name|timer_ptr
operator|->
name|when
operator|.
name|tv_usec
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|timer_index
operator|==
name|timer_list
operator|.
name|first_timer
condition|)
block|{
name|timer_ptr
operator|->
name|next
operator|=
name|timer_list
operator|.
name|first_timer
expr_stmt|;
name|timer_list
operator|.
name|first_timer
operator|=
name|timer_ptr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prev_timer
operator|=
name|timer_list
operator|.
name|first_timer
init|;
name|prev_timer
operator|->
name|next
operator|!=
name|timer_index
condition|;
name|prev_timer
operator|=
name|prev_timer
operator|->
name|next
control|)
empty_stmt|;
name|prev_timer
operator|->
name|next
operator|=
name|timer_ptr
expr_stmt|;
name|timer_ptr
operator|->
name|next
operator|=
name|timer_index
expr_stmt|;
block|}
name|gdb_notifier
operator|.
name|timeout_valid
operator|=
literal|0
expr_stmt|;
return|return
name|timer_ptr
operator|->
name|timer_id
return|;
block|}
end_function

begin_comment
comment|/* There is a chance that the creator of the timer wants to get rid of    it before it expires. */
end_comment

begin_function
name|void
name|delete_timer
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|gdb_timer
modifier|*
name|timer_ptr
decl_stmt|,
modifier|*
name|prev_timer
init|=
name|NULL
decl_stmt|;
comment|/* Find the entry for the given timer. */
for|for
control|(
name|timer_ptr
operator|=
name|timer_list
operator|.
name|first_timer
init|;
name|timer_ptr
operator|!=
name|NULL
condition|;
name|timer_ptr
operator|=
name|timer_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|timer_ptr
operator|->
name|timer_id
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|timer_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Get rid of the timer in the timer list. */
if|if
condition|(
name|timer_ptr
operator|==
name|timer_list
operator|.
name|first_timer
condition|)
name|timer_list
operator|.
name|first_timer
operator|=
name|timer_ptr
operator|->
name|next
expr_stmt|;
else|else
block|{
for|for
control|(
name|prev_timer
operator|=
name|timer_list
operator|.
name|first_timer
init|;
name|prev_timer
operator|->
name|next
operator|!=
name|timer_ptr
condition|;
name|prev_timer
operator|=
name|prev_timer
operator|->
name|next
control|)
empty_stmt|;
name|prev_timer
operator|->
name|next
operator|=
name|timer_ptr
operator|->
name|next
expr_stmt|;
block|}
name|xfree
argument_list|(
name|timer_ptr
argument_list|)
expr_stmt|;
name|gdb_notifier
operator|.
name|timeout_valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When a timer event is put on the event queue, it will be handled by    this function.  Just call the assiciated procedure and delete the    timer event from the event queue. Repeat this for each timer that    has expired. */
end_comment

begin_function
specifier|static
name|void
name|handle_timer_event
parameter_list|(
name|int
name|dummy
parameter_list|)
block|{
name|struct
name|timeval
name|time_now
decl_stmt|;
name|struct
name|gdb_timer
modifier|*
name|timer_ptr
decl_stmt|,
modifier|*
name|saved_timer
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timer_ptr
operator|=
name|timer_list
operator|.
name|first_timer
expr_stmt|;
while|while
condition|(
name|timer_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|timer_ptr
operator|->
name|when
operator|.
name|tv_sec
operator|>
name|time_now
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|timer_ptr
operator|->
name|when
operator|.
name|tv_sec
operator|==
name|time_now
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|timer_ptr
operator|->
name|when
operator|.
name|tv_usec
operator|>
name|time_now
operator|.
name|tv_usec
operator|)
operator|)
condition|)
break|break;
comment|/* Get rid of the timer from the beginning of the list. */
name|timer_list
operator|.
name|first_timer
operator|=
name|timer_ptr
operator|->
name|next
expr_stmt|;
name|saved_timer
operator|=
name|timer_ptr
expr_stmt|;
name|timer_ptr
operator|=
name|timer_ptr
operator|->
name|next
expr_stmt|;
comment|/* Call the procedure associated with that timer. */
call|(
modifier|*
name|saved_timer
operator|->
name|proc
call|)
argument_list|(
name|saved_timer
operator|->
name|client_data
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|saved_timer
argument_list|)
expr_stmt|;
block|}
name|gdb_notifier
operator|.
name|timeout_valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether any timers in the timers queue are ready. If at least    one timer is ready, stick an event onto the event queue.  Even in    case more than one timer is ready, one event is enough, because the    handle_timer_event() will go through the timers list and call the    procedures associated with all that have expired. Update the    timeout for the select() or poll() as well. */
end_comment

begin_function
specifier|static
name|void
name|poll_timers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|time_now
decl_stmt|,
name|delta
decl_stmt|;
name|gdb_event
modifier|*
name|event_ptr
decl_stmt|;
if|if
condition|(
name|timer_list
operator|.
name|first_timer
operator|!=
name|NULL
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delta
operator|.
name|tv_sec
operator|=
name|timer_list
operator|.
name|first_timer
operator|->
name|when
operator|.
name|tv_sec
operator|-
name|time_now
operator|.
name|tv_sec
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|timer_list
operator|.
name|first_timer
operator|->
name|when
operator|.
name|tv_usec
operator|-
name|time_now
operator|.
name|tv_usec
expr_stmt|;
comment|/* borrow? */
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
comment|/* Oops it expired already. Tell select / poll to return          immediately. (Cannot simply test if delta.tv_sec is negative          because time_t might be unsigned.)  */
if|if
condition|(
name|timer_list
operator|.
name|first_timer
operator|->
name|when
operator|.
name|tv_sec
operator|<
name|time_now
operator|.
name|tv_sec
operator|||
operator|(
name|timer_list
operator|.
name|first_timer
operator|->
name|when
operator|.
name|tv_sec
operator|==
name|time_now
operator|.
name|tv_sec
operator|&&
name|timer_list
operator|.
name|first_timer
operator|->
name|when
operator|.
name|tv_usec
operator|<
name|time_now
operator|.
name|tv_usec
operator|)
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|delta
operator|.
name|tv_usec
operator|==
literal|0
condition|)
block|{
name|event_ptr
operator|=
operator|(
name|gdb_event
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdb_event
argument_list|)
argument_list|)
expr_stmt|;
name|event_ptr
operator|->
name|proc
operator|=
name|handle_timer_event
expr_stmt|;
name|event_ptr
operator|->
name|fd
operator|=
name|timer_list
operator|.
name|first_timer
operator|->
name|timer_id
expr_stmt|;
name|async_queue_event
argument_list|(
name|event_ptr
argument_list|,
name|TAIL
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to update the timeout for select/ poll, because we          don't want to sit there while this timer is expiring. */
if|if
condition|(
name|use_poll
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|gdb_notifier
operator|.
name|poll_timeout
operator|=
name|delta
operator|.
name|tv_sec
operator|*
literal|1000
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"use_poll without HAVE_POLL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
block|}
else|else
block|{
name|gdb_notifier
operator|.
name|select_timeout
operator|.
name|tv_sec
operator|=
name|delta
operator|.
name|tv_sec
expr_stmt|;
name|gdb_notifier
operator|.
name|select_timeout
operator|.
name|tv_usec
operator|=
name|delta
operator|.
name|tv_usec
expr_stmt|;
block|}
name|gdb_notifier
operator|.
name|timeout_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|gdb_notifier
operator|.
name|timeout_valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

