begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the Mitsubishi m32r for GDB, the GNU debugger.    Copyright 1996, Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Function: m32r_use_struct_convention    Return nonzero if call_function should allocate stack space for a    struct return? */
end_comment

begin_function
name|int
name|m32r_use_struct_convention
parameter_list|(
name|gcc_p
parameter_list|,
name|type
parameter_list|)
name|int
name|gcc_p
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_find_saved_regs    Return the frame_saved_regs structure for the frame.    Doesn't really work for dummy frames, but it does pass back    an empty frame_saved_regs, so I guess that's better than total failure */
end_comment

begin_function
name|void
name|m32r_frame_find_saved_regs
parameter_list|(
name|fi
parameter_list|,
name|regaddr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|regaddr
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|regaddr
argument_list|,
operator|&
name|fi
operator|->
name|fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn this on if you want to see just how much instruction decoding    if being done, its quite a lot    */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|static void dump_insn(char * commnt,CORE_ADDR pc, int insn) {   printf_filtered("  %s %08x %08x ", 		  commnt,(unsigned int)pc,(unsigned int) insn);   (*tm_print_insn)(pc,&tm_print_insn_info);   printf_filtered("\n"); }
define|#
directive|define
name|insn_debug
parameter_list|(
name|args
parameter_list|)
value|{ printf_filtered args; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dump_insn
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|{}
end_define

begin_define
define|#
directive|define
name|insn_debug
parameter_list|(
name|args
parameter_list|)
value|{}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFAULT_SEARCH_LIMIT
value|44
end_define

begin_comment
comment|/* Function: scan_prologue    This function decodes the target function prologue to determine    1) the size of the stack frame, and 2) which registers are saved on it.    It saves the offsets of saved regs in the frame_saved_regs argument,    and returns the frame size.  */
end_comment

begin_comment
comment|/*   The sequence it currently generates is:    	if (varargs function) { ddi sp,#n } 	push registers 	if (additional stack<= 256) {	addi sp,#-stack	} 	else if (additional stack< 65k) { add3 sp,sp,#-stack  	} else if (additional stack) { 	seth sp,#(stack& 0xffff0000) 	or3 sp,sp,#(stack& 0x0000ffff) 	sub sp,r4 	} 	if (frame pointer) { 		mv sp,fp 	}  These instructions are scheduled like everything else, so you should stop at the first branch instruction.   */
end_comment

begin_comment
comment|/* This is required by skip prologue and by m32r_init_extra_frame_info.     The results of decoding a prologue should be cached because this    thrashing is getting nuts.    I am thinking of making a container class with two indexes, name and    address. It may be better to extend the symbol table.    */
end_comment

begin_function
specifier|static
name|void
name|decode_prologue
parameter_list|(
name|start_pc
parameter_list|,
name|scan_limit
parameter_list|,
name|pl_endptr
parameter_list|,
name|framelength
parameter_list|,
name|fi
parameter_list|,
name|fsr
parameter_list|)
name|CORE_ADDR
name|start_pc
decl_stmt|;
name|CORE_ADDR
name|scan_limit
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pl_endptr
decl_stmt|;
comment|/* var parameter */
name|unsigned
name|long
modifier|*
name|framelength
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
name|unsigned
name|long
name|framesize
decl_stmt|;
name|int
name|insn
decl_stmt|;
name|int
name|op1
decl_stmt|;
name|int
name|maybe_one_more
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|after_prologue
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|after_stack_adjust
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|current_pc
decl_stmt|;
name|framesize
operator|=
literal|0
expr_stmt|;
name|after_prologue
operator|=
literal|0
expr_stmt|;
name|insn_debug
argument_list|(
operator|(
literal|"rd prolog l(%d)\n"
operator|,
name|scan_limit
operator|-
name|current_pc
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|start_pc
init|;
name|current_pc
operator|<
name|scan_limit
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_insn
argument_list|(
literal|"insn-1"
argument_list|,
name|current_pc
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* MTZ */
comment|/* If this is a 32 bit instruction, we dont want to examine its 	 immediate data as though it were an instruction */
if|if
condition|(
name|current_pc
operator|&
literal|0x02
condition|)
block|{
comment|/* Clear the parallel execution bit from 16 bit instruction */
if|if
condition|(
name|maybe_one_more
condition|)
block|{
comment|/* The last instruction was a branch, usually terminates 		 the series, but if this is a parallel instruction, 		 it may be a stack framing instruction */
if|if
condition|(
operator|!
operator|(
name|insn
operator|&
literal|0x8000
operator|)
condition|)
block|{
name|insn_debug
argument_list|(
operator|(
literal|"Really done"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* nope, we are really done */
block|}
block|}
name|insn
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* decode this instruction further */
block|}
else|else
block|{
if|if
condition|(
name|maybe_one_more
condition|)
break|break;
comment|/* This isnt the one more */
if|if
condition|(
name|insn
operator|&
literal|0x8000
condition|)
block|{
name|insn_debug
argument_list|(
operator|(
literal|"32 bit insn\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_pc
operator|==
name|scan_limit
condition|)
name|scan_limit
operator|+=
literal|2
expr_stmt|;
comment|/* extend the search */
name|current_pc
operator|+=
literal|2
expr_stmt|;
comment|/* skip the immediate data */
if|if
condition|(
name|insn
operator|==
literal|0x8faf
condition|)
comment|/* add3 sp, sp, xxxx */
comment|/* add 16 bit sign-extended offset */
block|{
name|insn_debug
argument_list|(
operator|(
literal|"stack increment\n"
operator|)
argument_list|)
expr_stmt|;
name|framesize
operator|+=
operator|-
operator|(
operator|(
name|short
operator|)
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|==
literal|0xe4
operator|)
operator|&&
comment|/* ld24 r4, xxxxxx; sub sp, r4 */
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0x0f24
condition|)
block|{
comment|/* subtract 24 bit sign-extended negative-offset */
name|dump_insn
argument_list|(
literal|"insn-2"
argument_list|,
name|current_pc
operator|+
literal|2
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|-
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_insn
argument_list|(
literal|"insn-3(l4)"
argument_list|,
name|current_pc
operator|-
literal|2
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0x00800000
condition|)
comment|/* sign extend */
name|insn
operator||=
literal|0xff000000
expr_stmt|;
comment|/* negative */
else|else
name|insn
operator|&=
literal|0x00ffffff
expr_stmt|;
comment|/* positive */
name|framesize
operator|+=
name|insn
expr_stmt|;
block|}
block|}
name|after_prologue
operator|=
name|current_pc
expr_stmt|;
continue|continue;
block|}
block|}
name|op1
operator|=
name|insn
operator|&
literal|0xf000
expr_stmt|;
comment|/* isolate just the first nibble */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf0ff
operator|)
operator|==
literal|0x207f
condition|)
block|{
comment|/* st reg, @-sp */
name|int
name|regno
decl_stmt|;
name|insn_debug
argument_list|(
operator|(
literal|"push\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No, PUSH FP is not an indication that we will use a frame pointer. */
block|if (((insn& 0xffff) == 0x2d7f)&& fi)  	    fi->using_frame_pointer = 1;
endif|#
directive|endif
name|framesize
operator|+=
literal|4
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Why should we increase the scan limit, just because we did a push?     And if there is a reason, surely we would only want to do it if we    had already reached the scan limit... */
block|if (current_pc == scan_limit) 	    scan_limit += 2;
endif|#
directive|endif
name|regno
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
if|if
condition|(
name|fsr
condition|)
comment|/* save_regs offset */
name|fsr
operator|->
name|regs
index|[
name|regno
index|]
operator|=
name|framesize
expr_stmt|;
name|after_prologue
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|==
literal|0x4f
condition|)
comment|/* addi sp, xx */
comment|/* add 8 bit sign-extended offset */
block|{
name|int
name|stack_adjust
init|=
call|(
name|char
call|)
argument_list|(
name|insn
operator|&
literal|0xff
argument_list|)
decl_stmt|;
comment|/* there are probably two of these stack adjustments: 	     1) A negative one in the prologue, and 	     2) A positive one in the epilogue. 	     We are only interested in the first one.  */
if|if
condition|(
name|stack_adjust
operator|<
literal|0
condition|)
block|{
name|framesize
operator|-=
name|stack_adjust
expr_stmt|;
name|after_prologue
operator|=
literal|0
expr_stmt|;
comment|/* A frameless function may have no "mv fp, sp". 		 In that case, this is the end of the prologue.  */
name|after_stack_adjust
operator|=
name|current_pc
operator|+
literal|2
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|insn
operator|==
literal|0x1d8f
condition|)
block|{
comment|/* mv fp, sp */
if|if
condition|(
name|fi
condition|)
name|fi
operator|->
name|using_frame_pointer
operator|=
literal|1
expr_stmt|;
comment|/* fp is now valid */
name|insn_debug
argument_list|(
operator|(
literal|"done fp found\n"
operator|)
argument_list|)
expr_stmt|;
name|after_prologue
operator|=
name|current_pc
operator|+
literal|2
expr_stmt|;
break|break;
comment|/* end of stack adjustments */
block|}
if|if
condition|(
name|insn
operator|==
literal|0x7000
condition|)
comment|/* Nop looks like a branch, continue explicitly */
block|{
name|insn_debug
argument_list|(
operator|(
literal|"nop\n"
operator|)
argument_list|)
expr_stmt|;
name|after_prologue
operator|=
name|current_pc
operator|+
literal|2
expr_stmt|;
continue|continue;
comment|/* nop occurs between pushes */
block|}
comment|/* End of prolog if any of these are branch instructions */
if|if
condition|(
operator|(
name|op1
operator|==
literal|0x7000
operator|)
operator|||
operator|(
name|op1
operator|==
literal|0xb000
operator|)
operator|||
operator|(
name|op1
operator|==
literal|0x7000
operator|)
condition|)
block|{
name|after_prologue
operator|=
name|current_pc
expr_stmt|;
name|insn_debug
argument_list|(
operator|(
literal|"Done: branch\n"
operator|)
argument_list|)
expr_stmt|;
name|maybe_one_more
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Some of the branch instructions are mixed with other types */
if|if
condition|(
name|op1
operator|==
literal|0x1000
condition|)
block|{
name|int
name|subop
init|=
name|insn
operator|&
literal|0x0ff0
decl_stmt|;
if|if
condition|(
operator|(
name|subop
operator|==
literal|0x0ec0
operator|)
operator|||
operator|(
name|subop
operator|==
literal|0x0fc0
operator|)
condition|)
block|{
name|insn_debug
argument_list|(
operator|(
literal|"done: jmp\n"
operator|)
argument_list|)
expr_stmt|;
name|after_prologue
operator|=
name|current_pc
expr_stmt|;
name|maybe_one_more
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* jmp , jl */
block|}
block|}
block|}
if|if
condition|(
name|current_pc
operator|>=
name|scan_limit
condition|)
block|{
if|if
condition|(
name|pl_endptr
condition|)
if|#
directive|if
literal|1
if|if
condition|(
name|after_stack_adjust
operator|!=
literal|0
condition|)
comment|/* We did not find a "mv fp,sp", but we DID find 	     a stack_adjust.  Is it safe to use that as the 	     end of the prologue?  I just don't know. */
block|{
operator|*
name|pl_endptr
operator|=
name|after_stack_adjust
expr_stmt|;
if|if
condition|(
name|framelength
condition|)
operator|*
name|framelength
operator|=
name|framesize
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* We reached the end of the loop without finding the end 	 of the prologue.  No way to win -- we should report failure.   	 The way we do that is to return the original start_pc. 	 GDB will set a breakpoint at the start of the function (etc.) */
operator|*
name|pl_endptr
operator|=
name|start_pc
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|after_prologue
operator|==
literal|0
condition|)
name|after_prologue
operator|=
name|current_pc
expr_stmt|;
name|insn_debug
argument_list|(
operator|(
literal|" framesize %d, firstline %08x\n"
operator|,
name|framesize
operator|,
name|after_prologue
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|framelength
condition|)
operator|*
name|framelength
operator|=
name|framesize
expr_stmt|;
if|if
condition|(
name|pl_endptr
condition|)
operator|*
name|pl_endptr
operator|=
name|after_prologue
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  decode_prologue */
end_comment

begin_comment
comment|/* Function: skip_prologue    Find end of function prologue */
end_comment

begin_function
name|CORE_ADDR
name|m32r_skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
comment|/* See what the symbol table says */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|&&
name|sal
operator|.
name|end
operator|<=
name|func_end
condition|)
block|{
name|insn_debug
argument_list|(
operator|(
literal|"BP after prologue %08x\n"
operator|,
name|sal
operator|.
name|end
operator|)
argument_list|)
expr_stmt|;
name|func_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
block|}
else|else
comment|/* Either there's no line info, or the line after the prologue is after 	   the end of the function.  In this case, there probably isn't a 	   prologue.  */
block|{
name|insn_debug
argument_list|(
operator|(
literal|"No line info, line(%x) sal_end(%x) funcend(%x)\n"
operator|,
name|sal
operator|.
name|line
operator|,
name|sal
operator|.
name|end
operator|,
name|func_end
operator|)
argument_list|)
expr_stmt|;
name|func_end
operator|=
name|min
argument_list|(
name|func_end
argument_list|,
name|func_addr
operator|+
name|DEFAULT_SEARCH_LIMIT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|func_end
operator|=
name|pc
operator|+
name|DEFAULT_SEARCH_LIMIT
expr_stmt|;
name|decode_prologue
argument_list|(
name|pc
argument_list|,
name|func_end
argument_list|,
operator|&
name|sal
operator|.
name|end
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|sal
operator|.
name|end
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|m32r_scan_prologue
parameter_list|(
name|fi
parameter_list|,
name|fsr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
name|unsigned
name|long
name|framesize
decl_stmt|;
comment|/* this code essentially duplicates skip_prologue,       but we need the start address below.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
if|if
condition|(
name|prologue_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|prologue_start
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|48
expr_stmt|;
comment|/* We're in the boondocks:  					      allow for 16 pushes, an add,  					      and "mv fp,sp" */
block|}
if|#
directive|if
literal|0
block|prologue_end = min (prologue_end, fi->pc);
endif|#
directive|endif
name|insn_debug
argument_list|(
operator|(
literal|"fipc(%08x) start(%08x) end(%08x)\n"
operator|,
name|fi
operator|->
name|pc
operator|,
name|prologue_start
operator|,
name|prologue_end
operator|)
argument_list|)
expr_stmt|;
name|prologue_end
operator|=
name|min
argument_list|(
name|prologue_end
argument_list|,
name|prologue_start
operator|+
name|DEFAULT_SEARCH_LIMIT
argument_list|)
expr_stmt|;
name|decode_prologue
argument_list|(
name|prologue_start
argument_list|,
name|prologue_end
argument_list|,
operator|&
name|prologue_end
argument_list|,
operator|&
name|framesize
argument_list|,
name|fi
argument_list|,
name|fsr
argument_list|)
expr_stmt|;
return|return
name|framesize
return|;
block|}
end_function

begin_comment
comment|/* Function: init_extra_frame_info    This function actually figures out the frame address for a given pc and    sp.  This is tricky on the m32r because we sometimes don't use an explicit    frame pointer, and the previous stack pointer isn't necessarily recorded    on the stack.  The only reliable way to get this info is to    examine the prologue.  */
end_comment

begin_function
name|void
name|m32r_init_extra_frame_info
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|fi
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|,
literal|'\000'
argument_list|,
sizeof|sizeof
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
block|{
comment|/* We need to setup fi->frame here because run_stack_dummy gets it wrong 	 by assuming it's always FP.  */
name|fi
operator|->
name|frame
operator|=
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|fi
operator|->
name|using_frame_pointer
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
name|m32r_scan_prologue
argument_list|(
name|fi
argument_list|,
operator|&
name|fi
operator|->
name|fsr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
if|if
condition|(
name|fi
operator|->
name|using_frame_pointer
condition|)
block|{
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
elseif|else
comment|/* fi->next means this is not the innermost frame */
if|if
condition|(
name|fi
operator|->
name|using_frame_pointer
condition|)
comment|/* we have an FP */
if|if
condition|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|FP_REGNUM
index|]
operator|!=
literal|0
condition|)
comment|/* caller saved our FP */
name|fi
operator|->
name|frame
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|FP_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
operator|-
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: mn10300_virtual_frame_pointer    Return the register that the function uses for a frame pointer,     plus any necessary offset to be applied to the register before    any frame pointer offsets.  */
end_comment

begin_function
name|void
name|m32r_virtual_frame_pointer
parameter_list|(
name|pc
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|long
modifier|*
name|reg
decl_stmt|;
name|long
modifier|*
name|offset
decl_stmt|;
block|{
name|struct
name|frame_info
name|fi
decl_stmt|;
comment|/* Set up a dummy frame_info. */
name|fi
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|fi
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|fi
operator|.
name|frame
operator|=
literal|0
expr_stmt|;
name|fi
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
comment|/* Analyze the prolog and fill in the extra info.  */
name|m32r_init_extra_frame_info
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
comment|/* Results will tell us which type of frame it uses.  */
if|if
condition|(
name|fi
operator|.
name|using_frame_pointer
condition|)
block|{
operator|*
name|reg
operator|=
name|FP_REGNUM
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|reg
operator|=
name|SP_REGNUM
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: find_callers_reg    Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing    we might want to do here is to check REGNUM against the clobber mask, and    somehow flag it as invalid if it isn't saved on the stack somewhere.  This    would provide a graceful failure mode when trying to get the value of    caller-saves registers for an inner frame.  */
end_comment

begin_function
name|CORE_ADDR
name|m32r_find_callers_reg
parameter_list|(
name|fi
parameter_list|,
name|regnum
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|regnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_chain    Given a GDB frame, determine the address of the calling function's frame.    This will be used to create a new GDB frame struct, and then    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.    For m32r, we save the frame size when we initialize the frame_info.  */
end_comment

begin_function
name|CORE_ADDR
name|m32r_frame_chain
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|CORE_ADDR
name|fn_start
decl_stmt|,
name|callers_pc
decl_stmt|,
name|fp
decl_stmt|;
comment|/* is this a dummy frame? */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|fi
operator|->
name|frame
return|;
comment|/* dummy frame same as caller's frame */
comment|/* is caller-of-this a dummy frame? */
name|callers_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* find out who called us: */
name|fp
operator|=
name|m32r_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|FP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|callers_pc
argument_list|,
name|fp
argument_list|,
name|fp
argument_list|)
condition|)
return|return
name|fp
return|;
comment|/* dummy frame's frame may bear no relation to ours */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|fn_start
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|fn_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* in _start fn, don't chain further */
if|if
condition|(
name|fi
operator|->
name|framesize
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"cannot determine frame size @ %08x , pc(%08x)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fi
operator|->
name|frame
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insn_debug
argument_list|(
operator|(
literal|"m32rx frame %08x\n"
operator|,
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
operator|)
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
return|;
block|}
end_function

begin_comment
comment|/* Function: push_return_address (pc)    Set up the return address for the inferior function call.    Necessary for targets that don't actually execute a JSR/BSR instruction     (ie. when using an empty CALL_DUMMY) */
end_comment

begin_function
name|CORE_ADDR
name|m32r_push_return_address
parameter_list|(
name|pc
parameter_list|,
name|sp
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
block|{
name|write_register
argument_list|(
name|RP_REGNUM
argument_list|,
name|CALL_DUMMY_ADDRESS
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Function: pop_frame    Discard from the stack the innermost frame,    restoring all saved registers.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|m32r_pop_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
name|generic_pop_dummy_frame
argument_list|()
expr_stmt|;
else|else
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_register
argument_list|(
name|PSW_REGNUM
argument_list|)
operator|&
literal|0x80
condition|)
name|write_register
argument_list|(
name|SPU_REGNUM
argument_list|,
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|write_register
argument_list|(
name|SPI_REGNUM
argument_list|,
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_saved_pc    Find the caller of this frame.  We do this by seeing if RP_REGNUM is saved    in the stack anywhere, otherwise we get it from the registers. */
end_comment

begin_function
name|CORE_ADDR
name|m32r_frame_saved_pc
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|PC_REGNUM
argument_list|)
return|;
else|else
return|return
name|m32r_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|RP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: push_arguments    Setup the function arguments for calling a function in the inferior.     On the Mitsubishi M32R architecture, there are four registers (R0 to R3)    which are dedicated for passing function arguments.  Up to the first     four arguments (depending on size) may go into these registers.    The rest go on the stack.     Arguments that are smaller than 4 bytes will still take up a whole    register or a whole 32-bit word on the stack, and will be    right-justified in the register or the stack word.  This includes    chars, shorts, and small aggregate types.      Arguments of 8 bytes size are split between two registers, if     available.  If only one register is available, the argument will     be split between the register and the stack.  Otherwise it is    passed entirely on the stack.  Aggregate types with sizes between    4 and 8 bytes are passed entirely on the stack, and are left-justified    within the double-word (as opposed to aggregates smaller than 4 bytes    which are right-justified).     Aggregates of greater than 8 bytes are first copied onto the stack,     and then a pointer to the copy is passed in the place of the normal    argument (either in a register if available, or on the stack).     Functions that must return an aggregate type can return it in the     normal return value registers (R0 and R1) if its size is 8 bytes or    less.  For larger return values, the caller must allocate space for     the callee to copy the return value to.  A pointer to this space is    passed as an implicit first argument, always in R0. */
end_comment

begin_function
name|CORE_ADDR
name|m32r_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|unsigned
name|char
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
name|int
name|stack_offset
decl_stmt|,
name|stack_alloc
decl_stmt|;
name|int
name|argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
name|valbuf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|odd_sized_struct
decl_stmt|;
comment|/* first force sp to a 4-byte alignment */
name|sp
operator|=
name|sp
operator|&
operator|~
literal|3
expr_stmt|;
name|argreg
operator|=
name|ARG0_REGNUM
expr_stmt|;
comment|/* The "struct return pointer" pseudo-argument goes in R0 */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Now make sure there's space on the stack */
for|for
control|(
name|argnum
operator|=
literal|0
operator|,
name|stack_alloc
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
name|stack_alloc
operator|+=
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|sp
operator|-=
name|stack_alloc
expr_stmt|;
comment|/* make room on stack for args */
comment|/* Now load as many as possible of the first arguments into      registers, and push the rest onto the stack.  There are 16 bytes      in four registers available.  Loop thru args from first to last.  */
name|argreg
operator|=
name|ARG0_REGNUM
expr_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
operator|,
name|stack_offset
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|valbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
block|{
comment|/* value gets right-justified in the register or stack word */
name|memcpy
argument_list|(
name|valbuf
operator|+
operator|(
literal|4
operator|-
name|len
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|valbuf
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
operator|(
name|len
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|odd_sized_struct
operator|=
literal|1
expr_stmt|;
comment|/* such structs go entirely on stack */
else|else
name|odd_sized_struct
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|argreg
operator|>
name|ARGLAST_REGNUM
operator|||
name|odd_sized_struct
condition|)
block|{
comment|/* must go on the stack */
name|write_memory
argument_list|(
name|sp
operator|+
name|stack_offset
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|stack_offset
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* NOTE WELL!!!!!  This is not an "else if" clause!!!              That's because some *&^%$ things get passed on the stack              AND in the registers!   */
if|if
condition|(
name|argreg
operator|<=
name|ARGLAST_REGNUM
condition|)
block|{
comment|/* there's room in a register */
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|argreg
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
comment|/* Store the value 4 bytes at a time.  This means that things              larger than 4 bytes may go partly in registers and partly              on the stack.  */
name|len
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|argreg
argument_list|)
expr_stmt|;
name|val
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|argreg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Function: fix_call_dummy     If there is real CALL_DUMMY code (eg. on the stack), this function    has the responsability to insert the address of the actual code that    is the target of the target function call.  */
end_comment

begin_function
name|void
name|m32r_fix_call_dummy
parameter_list|(
name|dummy
parameter_list|,
name|pc
parameter_list|,
name|fun
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|,
name|type
parameter_list|,
name|gcc_p
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fun
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
block|{
comment|/* ld24 r8,<(imm24) fun> */
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|dummy
operator|)
operator|=
operator|(
name|fun
operator|&
literal|0x00ffffff
operator|)
operator||
literal|0xe8000000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: get_saved_register    Just call the generic_get_saved_register function.  */
end_comment

begin_function
name|void
name|get_saved_register
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lval
parameter_list|)
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
modifier|*
name|optimized
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lval
decl_stmt|;
block|{
name|generic_get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
name|optimized
argument_list|,
name|addrp
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: m32r_write_sp    Because SP is really a read-only register that mirrors either SPU or SPI,    we must actually write one of those two as well, depending on PSW. */
end_comment

begin_function
name|void
name|m32r_write_sp
parameter_list|(
name|val
parameter_list|)
name|CORE_ADDR
name|val
decl_stmt|;
block|{
name|unsigned
name|long
name|psw
init|=
name|read_register
argument_list|(
name|PSW_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|psw
operator|&
literal|0x80
condition|)
comment|/* stack mode: user or interrupt */
name|write_register
argument_list|(
name|SPU_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|write_register
argument_list|(
name|SPI_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_m32r_tdep
parameter_list|()
block|{
name|tm_print_insn
operator|=
name|print_insn_m32r
expr_stmt|;
block|}
end_function

end_unit

