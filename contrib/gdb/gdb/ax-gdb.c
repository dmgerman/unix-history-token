begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB-specific functions for operating on agent expressions    Copyright 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $Id: ax-gdb.c,v 1.8 1998/12/03 05:34:24 cagney Exp $ */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"ax.h"
end_include

begin_include
include|#
directive|include
file|"ax-gdb.h"
end_include

begin_comment
comment|/* Probably the best way to read this file is to start with the types    and enums in ax-gdb.h, and then look at gen_expr, towards the    bottom; that's the main function that looks at the GDB expressions    and calls everything else to generate code.     I'm beginning to wonder whether it wouldn't be nicer to internally    generate trees, with types, and then spit out the bytecode in    linear form afterwards; we could generate fewer `swap', `ext', and    `zero_ext' bytecodes that way; it would make good constant folding    easier, too.  But at the moment, I think we should be willing to    pay for the simplicity of this code with less-than-optimal bytecode    strings.     Remember, "GBD" stands for "Great Britain, Dammit!"  So be careful.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_comment
comment|/* There's a standard order to the arguments of these functions:    union exp_element ** --- pointer into expression    struct agent_expr * --- agent expression buffer to generate code into    struct axs_value * --- describes value left on top of stack  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value
modifier|*
name|const_var_ref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
name|var
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|value
modifier|*
name|const_expr
name|PARAMS
argument_list|(
operator|(
expr|union
name|exp_element
operator|*
operator|*
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|value
modifier|*
name|maybe_const_expr
name|PARAMS
argument_list|(
operator|(
expr|union
name|exp_element
operator|*
operator|*
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_traced_pop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|axs_value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_sign_extend
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_extend
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_fetch
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_left_shift
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_frame_args_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_frame_locals_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_offset
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
name|int
name|offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_sym_offset
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|symbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_var_ref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
expr|struct
name|symbol
operator|*
name|var
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_int_literal
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
name|LONGEST
name|k
operator|,
expr|struct
name|type
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|require_rvalue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_usual_unary
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_wider_than
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
name|type1
operator|,
expr|struct
name|type
operator|*
name|type2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|max_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
name|type1
operator|,
expr|struct
name|type
operator|*
name|type2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_conversion
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|type
operator|*
name|from
operator|,
expr|struct
name|type
operator|*
name|to
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_nontrivial_conversion
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
name|from
operator|,
expr|struct
name|type
operator|*
name|to
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_usual_arithmetic
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value1
operator|,
expr|struct
name|axs_value
operator|*
name|value2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_integral_promotions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_cast
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
expr|struct
name|type
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_scale
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|enum
name|agent_op
name|op
operator|,
expr|struct
name|type
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_add
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
expr|struct
name|axs_value
operator|*
name|value1
operator|,
expr|struct
name|axs_value
operator|*
name|value2
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_sub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
expr|struct
name|axs_value
operator|*
name|value1
operator|,
expr|struct
name|axs_value
operator|*
name|value2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_binop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
expr|struct
name|axs_value
operator|*
name|value1
operator|,
expr|struct
name|axs_value
operator|*
name|value2
operator|,
expr|enum
name|agent_op
name|op
operator|,
expr|enum
name|agent_op
name|op_unsigned
operator|,
name|int
name|may_carry
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_logical_not
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_complement
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_deref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|axs_value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_address_of
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
operator|,
expr|struct
name|axs_value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_field
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
name|type
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_bitfield_ref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
expr|struct
name|type
operator|*
name|type
operator|,
name|int
name|start
operator|,
name|int
name|end
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_struct_ref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|,
name|char
operator|*
name|field
operator|,
name|char
operator|*
name|operator_name
operator|,
name|char
operator|*
name|operand_name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_repeat
name|PARAMS
argument_list|(
operator|(
expr|union
name|exp_element
operator|*
operator|*
name|pc
operator|,
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_sizeof
name|PARAMS
argument_list|(
operator|(
expr|union
name|exp_element
operator|*
operator|*
name|pc
operator|,
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_expr
name|PARAMS
argument_list|(
operator|(
expr|union
name|exp_element
operator|*
operator|*
name|pc
operator|,
expr|struct
name|agent_expr
operator|*
name|ax
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_axs_value
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
name|f
operator|,
expr|struct
name|axs_value
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|agent_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|exp
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Detecting constant expressions.  */
end_comment

begin_comment
comment|/* If the variable reference at *PC is a constant, return its value.    Otherwise, return zero.     Hey, Wally!  How can a variable reference be a constant?     Well, Beav, this function really handles the OP_VAR_VALUE operator,    not specifically variable references.  GDB uses OP_VAR_VALUE to    refer to any kind of symbolic reference: function names, enum    elements, and goto labels are all handled through the OP_VAR_VALUE    operator, even though they're constants.  It makes sense given the    situation.     Gee, Wally, don'cha wonder sometimes if data representations that    subvert commonly accepted definitions of terms in favor of heavily    context-specific interpretations are really just a tool of the    programming hegemony to preserve their power and exclude the    proletariat?  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|const_var_ref
parameter_list|(
name|var
parameter_list|)
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
operator|(
name|LONGEST
operator|)
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
case|case
name|LOC_LABEL
case|:
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
operator|(
name|LONGEST
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* If the expression starting at *PC has a constant value, return it.    Otherwise, return zero.  If we return a value, then *PC will be    advanced to the end of it.  If we return zero, *PC could be    anywhere.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|const_expr
parameter_list|(
name|pc
parameter_list|)
name|union
name|exp_element
modifier|*
modifier|*
name|pc
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
init|=
operator|(
operator|*
name|pc
operator|)
operator|->
name|opcode
decl_stmt|;
name|struct
name|value
modifier|*
name|v1
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_LONG
case|:
block|{
name|struct
name|type
modifier|*
name|type
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|1
index|]
operator|.
name|type
decl_stmt|;
name|LONGEST
name|k
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|2
index|]
operator|.
name|longconst
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|k
argument_list|)
return|;
block|}
case|case
name|OP_VAR_VALUE
case|:
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|const_var_ref
argument_list|(
operator|(
operator|*
name|pc
operator|)
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/* We could add more operators in here.  */
case|case
name|UNOP_NEG
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|v1
operator|=
name|const_expr
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
condition|)
return|return
name|value_neg
argument_list|(
name|v1
argument_list|)
return|;
else|else
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like const_expr, but guarantee also that *PC is undisturbed if the    expression is not constant.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|maybe_const_expr
parameter_list|(
name|pc
parameter_list|)
name|union
name|exp_element
modifier|*
modifier|*
name|pc
decl_stmt|;
block|{
name|union
name|exp_element
modifier|*
name|tentative_pc
init|=
operator|*
name|pc
decl_stmt|;
name|struct
name|value
modifier|*
name|v
init|=
name|const_expr
argument_list|(
operator|&
name|tentative_pc
argument_list|)
decl_stmt|;
comment|/* If we got a value, then update the real PC.  */
if|if
condition|(
name|v
condition|)
operator|*
name|pc
operator|=
name|tentative_pc
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: general assumptions */
end_comment

begin_comment
comment|/* Here are a few general assumptions made throughout the code; if you    want to make a change that contradicts one of these, then you'd    better scan things pretty thoroughly.     - We assume that all values occupy one stack element.  For example,      sometimes we'll swap to get at the left argument to a binary      operator.  If we decide that void values should occupy no stack      elements, or that synthetic arrays (whose size is determined at      run time, created by the `@' operator) should occupy two stack      elements (address and length), then this will cause trouble.     - We assume the stack elements are infinitely wide, and that we      don't have to worry what happens if the user requests an      operation that is wider than the actual interpreter's stack.      That is, it's up to the interpreter to handle directly all the      integer widths the user has access to.  (Woe betide the language      with bignums!)     - We don't support side effects.  Thus, we don't have to worry about      GCC's generalized lvalues, function calls, etc.     - We don't support floating point.  Many places where we switch on      some type don't bother to include cases for floating point; there      may be even more subtle ways this assumption exists.  For      example, the arguments to % must be integers.     - We assume all subexpressions have a static, unchanging type.  If      we tried to support convenience variables, this would be a      problem.     - All values on the stack should always be fully zero- or      sign-extended.       (I wasn't sure whether to choose this or its opposite --- that      only addresses are assumed extended --- but it turns out that      neither convention completely eliminates spurious extend      operations (if everything is always extended, then you have to      extend after add, because it could overflow; if nothing is      extended, then you end up producing extends whenever you change      sizes), and this is simpler.)  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: the `trace' kludge  */
end_comment

begin_comment
comment|/* The compiler in this file is a general-purpose mechanism for    translating GDB expressions into bytecode.  One ought to be able to    find a million and one uses for it.     However, at the moment it is HOPELESSLY BRAIN-DAMAGED for the sake    of expediency.  Let he who is without sin cast the first stone.     For the data tracing facility, we need to insert `trace' bytecodes    before each data fetch; this records all the memory that the    expression touches in the course of evaluation, so that memory will    be available when the user later tries to evaluate the expression    in GDB.     This should be done (I think) in a post-processing pass, that walks    an arbitrary agent expression and inserts `trace' operations at the    appropriate points.  But it's much faster to just hack them    directly into the code.  And since we're in a crunch, that's what    I've done.     Setting the flag trace_kludge to non-zero enables the code that    emits the trace bytecodes at the appropriate points.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trace_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trace the lvalue on the stack, if it needs it.  In either case, pop    the value.  Useful on the left side of a comma, and at the end of    an expression being used for tracing.  */
end_comment

begin_function
specifier|static
name|void
name|gen_traced_pop
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|trace_kludge
condition|)
switch|switch
condition|(
name|value
operator|->
name|kind
condition|)
block|{
case|case
name|axs_rvalue
case|:
comment|/* We don't trace rvalues, just the lvalues necessary to            produce them.  So just dispose of this value.  */
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_pop
argument_list|)
expr_stmt|;
break|break;
case|case
name|axs_lvalue_memory
case|:
block|{
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|value
operator|->
name|type
argument_list|)
decl_stmt|;
comment|/* There's no point in trying to use a trace_quick bytecode 	     here, since "trace_quick SIZE pop" is three bytes, whereas 	     "const8 SIZE trace" is also three bytes, does the same 	     thing, and the simplest code which generates that will also 	     work correctly for objects with large sizes.  */
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_trace
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|axs_lvalue_register
case|:
comment|/* We need to mention the register somewhere in the bytecode, 	   so ax_reqs will pick it up and add it to the mask of 	   registers used.  */
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|u
operator|.
name|reg
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_pop
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
comment|/* If we're not tracing, just pop the value.  */
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_pop
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: helper functions */
end_comment

begin_comment
comment|/* Assume that the lower bits of the top of the stack is a value of    type TYPE, and the upper bits are zero.  Sign-extend if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|gen_sign_extend
parameter_list|(
name|ax
parameter_list|,
name|type
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
comment|/* Do we need to sign-extend this?  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|ax_ext
argument_list|(
name|ax
argument_list|,
name|type
operator|->
name|length
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assume the lower bits of the top of the stack hold a value of type    TYPE, and the upper bits are garbage.  Sign-extend or truncate as    needed.  */
end_comment

begin_function
specifier|static
name|void
name|gen_extend
parameter_list|(
name|ax
parameter_list|,
name|type
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|int
name|bits
init|=
name|type
operator|->
name|length
operator|*
name|TARGET_CHAR_BIT
decl_stmt|;
comment|/* I just had to.  */
operator|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|ax_zero_ext
else|:
name|ax_ext
operator|)
operator|(
name|ax
operator|,
name|bits
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assume that the top of the stack contains a value of type "pointer    to TYPE"; generate code to fetch its value.  Note that TYPE is the    target type, not the pointer type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_fetch
parameter_list|(
name|ax
parameter_list|,
name|type
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|trace_kludge
condition|)
block|{
comment|/* Record the area of memory we're about to fetch.  */
name|ax_trace_quick
argument_list|(
name|ax
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
operator|->
name|code
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
comment|/* It's a scalar value, so we know how to dereference it.  How          many bytes long is it?  */
switch|switch
condition|(
name|type
operator|->
name|length
condition|)
block|{
case|case
literal|8
operator|/
name|TARGET_CHAR_BIT
case|:
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_ref8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
operator|/
name|TARGET_CHAR_BIT
case|:
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_ref16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
operator|/
name|TARGET_CHAR_BIT
case|:
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_ref32
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
operator|/
name|TARGET_CHAR_BIT
case|:
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_ref64
argument_list|)
expr_stmt|;
break|break;
comment|/* Either our caller shouldn't have asked us to dereference 	     that pointer (other code's fault), or we're not 	     implementing something we should be (this code's fault). 	     In any case, it's a bug the user shouldn't see.  */
default|default:
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_fetch): strange size"
argument_list|)
expr_stmt|;
block|}
name|gen_sign_extend
argument_list|(
name|ax
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Either our caller shouldn't have asked us to dereference that 	 pointer (other code's fault), or we're not implementing 	 something we should be (this code's fault).  In any case, 	 it's a bug the user shouldn't see.  */
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_fetch): bad type code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to left shift the top of the stack by DISTANCE bits, or    right shift it by -DISTANCE bits if DISTANCE< 0.  This generates    unsigned (logical) right shifts.  */
end_comment

begin_function
specifier|static
name|void
name|gen_left_shift
parameter_list|(
name|ax
parameter_list|,
name|distance
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|int
name|distance
decl_stmt|;
block|{
if|if
condition|(
name|distance
operator|>
literal|0
condition|)
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_lsh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|distance
operator|<
literal|0
condition|)
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
operator|-
name|distance
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_rsh_unsigned
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: symbol references */
end_comment

begin_comment
comment|/* Generate code to push the base address of the argument portion of    the top stack frame.  */
end_comment

begin_function
specifier|static
name|void
name|gen_frame_args_address
parameter_list|(
name|ax
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
block|{
name|long
name|frame_reg
decl_stmt|,
name|frame_offset
decl_stmt|;
name|TARGET_VIRTUAL_FRAME_POINTER
argument_list|(
name|ax
operator|->
name|scope
argument_list|,
operator|&
name|frame_reg
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|frame_reg
argument_list|)
expr_stmt|;
name|gen_offset
argument_list|(
name|ax
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to push the base address of the locals portion of the    top stack frame.  */
end_comment

begin_function
specifier|static
name|void
name|gen_frame_locals_address
parameter_list|(
name|ax
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
block|{
name|long
name|frame_reg
decl_stmt|,
name|frame_offset
decl_stmt|;
name|TARGET_VIRTUAL_FRAME_POINTER
argument_list|(
name|ax
operator|->
name|scope
argument_list|,
operator|&
name|frame_reg
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|frame_reg
argument_list|)
expr_stmt|;
name|gen_offset
argument_list|(
name|ax
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to add OFFSET to the top of the stack.  Try to    generate short and readable code.  We use this for getting to    variables on the stack, and structure members.  If we were    programming in ML, it would be clearer why these are the same    thing.  */
end_comment

begin_function
specifier|static
name|void
name|gen_offset
parameter_list|(
name|ax
parameter_list|,
name|offset
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
comment|/* It would suffice to simply push the offset and add it, but this      makes it easier to read positive and negative offsets in the      bytecode.  */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_add
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_sub
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In many cases, a symbol's value is the offset from some other    address (stack frame, base register, etc.)  Generate code to add    VAR's value to the top of the stack.  */
end_comment

begin_function
specifier|static
name|void
name|gen_sym_offset
parameter_list|(
name|ax
parameter_list|,
name|var
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
block|{
name|gen_offset
argument_list|(
name|ax
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code for a variable reference to AX.  The variable is the    symbol VAR.  Set VALUE to describe the result.  */
end_comment

begin_function
specifier|static
name|void
name|gen_var_ref
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|var
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
block|{
comment|/* Dereference any typedefs. */
name|value
operator|->
name|type
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I'm imitating the code in read_var_value.  */
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
comment|/* A constant, like an enum value.  */
name|ax_const_l
argument_list|(
name|ax
argument_list|,
operator|(
name|LONGEST
operator|)
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
break|break;
case|case
name|LOC_LABEL
case|:
comment|/* A goto label, being used as a value.  */
name|ax_const_l
argument_list|(
name|ax
argument_list|,
operator|(
name|LONGEST
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_var_ref): LOC_CONST_BYTES symbols are not supported"
argument_list|)
expr_stmt|;
comment|/* Variable at a fixed location in memory.  Easy.  */
case|case
name|LOC_STATIC
case|:
comment|/* Push the address of the variable.  */
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
comment|/* var lives in argument area of frame */
name|gen_frame_args_address
argument_list|(
name|ax
argument_list|)
expr_stmt|;
name|gen_sym_offset
argument_list|(
name|ax
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
comment|/* As above, but the frame slot really 				   holds the address of the variable.  */
name|gen_frame_args_address
argument_list|(
name|ax
argument_list|)
expr_stmt|;
name|gen_sym_offset
argument_list|(
name|ax
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Don't assume any particular pointer size.  */
name|gen_fetch
argument_list|(
name|ax
argument_list|,
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
comment|/* var lives in locals area of frame */
case|case
name|LOC_LOCAL_ARG
case|:
name|gen_frame_locals_address
argument_list|(
name|ax
argument_list|)
expr_stmt|;
name|gen_sym_offset
argument_list|(
name|ax
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
comment|/* relative to some base register */
case|case
name|LOC_BASEREG_ARG
case|:
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|gen_sym_offset
argument_list|(
name|ax
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|error
argument_list|(
literal|"Cannot compute value of typedef `%s'."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
comment|/* Don't generate any code at all; in the process of treating          this as an lvalue or rvalue, the caller will generate the          right code.  */
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_register
expr_stmt|;
name|value
operator|->
name|u
operator|.
name|reg
operator|=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
comment|/* A lot like LOC_REF_ARG, but the pointer lives directly in a 	 register, not on the stack.  Simpler than LOC_REGISTER and 	 LOC_REGPARM, because it's just like any other case where the 	 thing has a real address.  */
case|case
name|LOC_REGPARM_ADDR
case|:
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
init|=
name|lookup_minimal_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msym
condition|)
name|error
argument_list|(
literal|"Couldn't resolve symbol `%s'."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Push the address of the variable.  */
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
block|}
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|error
argument_list|(
literal|"The variable `%s' has been optimized out."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Cannot find value of botched symbol `%s'."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: literals */
end_comment

begin_function
specifier|static
name|void
name|gen_int_literal
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|k
parameter_list|,
name|type
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
name|LONGEST
name|k
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: unary conversions, casts */
end_comment

begin_comment
comment|/* Take what's on the top of the stack (as described by VALUE), and    try to make an rvalue out of it.  Signal an error if we can't do    that.  */
end_comment

begin_function
specifier|static
name|void
name|require_rvalue
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|value
operator|->
name|kind
condition|)
block|{
case|case
name|axs_rvalue
case|:
comment|/* It's already an rvalue.  */
break|break;
case|case
name|axs_lvalue_memory
case|:
comment|/* The top of stack is the address of the object.  Dereference.  */
name|gen_fetch
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|axs_lvalue_register
case|:
comment|/* There's nothing on the stack, but value->u.reg is the          register number containing the value.  	 When we add floating-point support, this is going to have to 	 change.  What about SPARC register pairs, for example?  */
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|u
operator|.
name|reg
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assume the top of the stack is described by VALUE, and perform the    usual unary conversions.  This is motivated by ANSI 6.2.2, but of    course GDB expressions are not ANSI; they're the mishmash union of    a bunch of languages.  Rah.     NOTE!  This function promises to produce an rvalue only when the    incoming value is of an appropriate type.  In other words, the    consumer of the value this function produces may assume the value    is an rvalue only after checking its type.     The immediate issue is that if the user tries to use a structure or    union as an operand of, say, the `+' operator, we don't want to try    to convert that structure to an rvalue; require_rvalue will bomb on    structs and unions.  Rather, we want to simply pass the struct    lvalue through unchanged, and let `+' raise an error.  */
end_comment

begin_function
specifier|static
name|void
name|gen_usual_unary
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
comment|/* We don't have to generate any code for the usual integral      conversions, since values are always represented as full-width on      the stack.  Should we tweak the type?  */
comment|/* Some types require special handling.  */
switch|switch
condition|(
name|value
operator|->
name|type
operator|->
name|code
condition|)
block|{
comment|/* Functions get converted to a pointer to the function.  */
case|case
name|TYPE_CODE_FUNC
case|:
name|value
operator|->
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|value
operator|->
name|type
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
comment|/* Should always be true, but just in case.  */
break|break;
comment|/* Arrays get converted to a pointer to their first element, and 	 are no longer an lvalue.  */
case|case
name|TYPE_CODE_ARRAY
case|:
block|{
name|struct
name|type
modifier|*
name|elements
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|value
operator|->
name|type
argument_list|)
decl_stmt|;
name|value
operator|->
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|elements
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
comment|/* We don't need to generate any code; the address of the array 	   is also the address of its first element.  */
block|}
break|break;
comment|/* Don't try to convert structures and unions to rvalues.  Let the        consumer signal an error.  */
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
return|return;
comment|/* If the value is an enum, call it an integer.  */
case|case
name|TYPE_CODE_ENUM
case|:
name|value
operator|->
name|type
operator|=
name|builtin_type_int
expr_stmt|;
break|break;
block|}
comment|/* If the value is an lvalue, dereference it.  */
name|require_rvalue
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff the type TYPE1 is considered "wider" than the    type TYPE2, according to the rules described in gen_usual_arithmetic.  */
end_comment

begin_function
specifier|static
name|int
name|type_wider_than
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
decl|*
name|type2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
operator|||
operator|(
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type1
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type2
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the "wider" of the two types TYPE1 and TYPE2.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|max_type
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
decl|*
name|type2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|type_wider_than
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|?
name|type1
else|:
name|type2
return|;
block|}
end_block

begin_comment
comment|/* Generate code to convert a scalar value of type FROM to type TO.  */
end_comment

begin_function
specifier|static
name|void
name|gen_conversion
parameter_list|(
name|ax
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|type
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
comment|/* Perhaps there is a more graceful way to state these rules.  */
comment|/* If we're converting to a narrower type, then we need to clear out      the upper bits.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|to
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|from
argument_list|)
condition|)
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* If the two values have equal width, but different signednesses,      then we need to extend.  */
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|to
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|from
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|to
argument_list|)
condition|)
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* If we're converting to a wider type, and becoming unsigned, then      we need to zero out any possible sign bits.  */
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|to
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|to
argument_list|)
condition|)
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return non-zero iff the type FROM will require any bytecodes to be    emitted to be converted to the type TO.  */
end_comment

begin_function
specifier|static
name|int
name|is_nontrivial_conversion
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|struct
name|type
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|agent_expr
modifier|*
name|ax
init|=
name|new_agent_expr
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|nontrivial
decl_stmt|;
comment|/* Actually generate the code, and see if anything came out.  At the      moment, it would be trivial to replicate the code in      gen_conversion here, but in the future, when we're supporting      floating point and the like, it may not be.  Doing things this      way allows this function to be independent of the logic in      gen_conversion.  */
name|gen_conversion
argument_list|(
name|ax
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|nontrivial
operator|=
name|ax
operator|->
name|len
operator|>
literal|0
expr_stmt|;
name|free_agent_expr
argument_list|(
name|ax
argument_list|)
expr_stmt|;
return|return
name|nontrivial
return|;
block|}
end_block

begin_comment
comment|/* Generate code to perform the "usual arithmetic conversions" (ANSI C    6.2.1.5) for the two operands of an arithmetic operator.  This    effectively finds a "least upper bound" type for the two arguments,    and promotes each argument to that type.  *VALUE1 and *VALUE2    describe the values as they are passed in, and as they are left.  */
end_comment

begin_function
specifier|static
name|void
name|gen_usual_arithmetic
parameter_list|(
name|ax
parameter_list|,
name|value1
parameter_list|,
name|value2
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value1
decl_stmt|,
decl|*
name|value2
decl_stmt|;
end_function

begin_block
block|{
comment|/* Do the usual binary conversions.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value1
operator|->
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|value2
operator|->
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* The ANSI integral promotions seem to work this way: Order the 	 integer types by size, and then by signedness: an n-bit 	 unsigned type is considered "wider" than an n-bit signed 	 type.  Promote to the "wider" of the two types, and always 	 promote at least to int.  */
name|struct
name|type
modifier|*
name|target
init|=
name|max_type
argument_list|(
name|builtin_type_int
argument_list|,
name|max_type
argument_list|(
name|value1
operator|->
name|type
argument_list|,
name|value2
operator|->
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Deal with value2, on the top of the stack.  */
name|gen_conversion
argument_list|(
name|ax
argument_list|,
name|value2
operator|->
name|type
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Deal with value1, not on the top of the stack.  Don't          generate the `swap' instructions if we're not actually going          to do anything.  */
if|if
condition|(
name|is_nontrivial_conversion
argument_list|(
name|value1
operator|->
name|type
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_swap
argument_list|)
expr_stmt|;
name|gen_conversion
argument_list|(
name|ax
argument_list|,
name|value1
operator|->
name|type
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_swap
argument_list|)
expr_stmt|;
block|}
name|value1
operator|->
name|type
operator|=
name|value2
operator|->
name|type
operator|=
name|target
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Generate code to perform the integral promotions (ANSI 6.2.1.1) on    the value on the top of the stack, as described by VALUE.  Assume    the value has integral type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_integral_promotions
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|type_wider_than
argument_list|(
name|value
operator|->
name|type
argument_list|,
name|builtin_type_int
argument_list|)
condition|)
block|{
name|gen_conversion
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|type
argument_list|,
name|builtin_type_int
argument_list|)
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|type_wider_than
argument_list|(
name|value
operator|->
name|type
argument_list|,
name|builtin_type_unsigned_int
argument_list|)
condition|)
block|{
name|gen_conversion
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|type
argument_list|,
name|builtin_type_unsigned_int
argument_list|)
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|builtin_type_unsigned_int
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code for a cast to TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_cast
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
comment|/* GCC does allow casts to yield lvalues, so this should be fixed      before merging these changes into the trunk.  */
name|require_rvalue
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Dereference typedefs. */
name|type
operator|=
name|check_typedef
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|->
name|code
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
comment|/* It's implementation-defined, and I'll bet this is what GCC          does.  */
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_FUNC
case|:
name|error
argument_list|(
literal|"Illegal type cast: intended type must be scalar."
argument_list|)
expr_stmt|;
case|case
name|TYPE_CODE_ENUM
case|:
comment|/* We don't have to worry about the size of the value, because          all our integral values are fully sign-extended, and when          casting pointers we can do anything we like.  Is there any          way for us to actually know what GCC actually does with a          cast like this?  */
name|value
operator|->
name|type
operator|=
name|type
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_INT
case|:
name|gen_conversion
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
comment|/* We could pop the value, and rely on everyone else to check 	 the type and notice that this value doesn't occupy a stack 	 slot.  But for now, leave the value on the stack, and 	 preserve the "value == stack element" assumption.  */
break|break;
default|default:
name|error
argument_list|(
literal|"Casts to requested type are not yet implemented."
argument_list|)
expr_stmt|;
block|}
name|value
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: arithmetic */
end_comment

begin_comment
comment|/* Scale the integer on the top of the stack by the size of the target    of the pointer type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_scale
parameter_list|(
name|ax
parameter_list|,
name|op
parameter_list|,
name|type
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|enum
name|agent_op
name|op
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|element
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|->
name|length
operator|!=
literal|1
condition|)
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|element
operator|->
name|length
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code for an addition; non-trivial because we deal with    pointer arithmetic.  We set VALUE to describe the result value; we    assume VALUE1 and VALUE2 describe the two operands, and that    they've undergone the usual binary conversions.  Used by both    BINOP_ADD and BINOP_SUBSCRIPT.  NAME is used in error messages.  */
end_comment

begin_function
specifier|static
name|void
name|gen_add
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|value1
parameter_list|,
name|value2
parameter_list|,
name|name
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|,
decl|*
name|value1
decl_stmt|,
modifier|*
name|value2
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Is it INT+PTR?  */
if|if
condition|(
name|value1
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
operator|&&
name|value2
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
comment|/* Swap the values and proceed normally.  */
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_swap
argument_list|)
expr_stmt|;
name|gen_scale
argument_list|(
name|ax
argument_list|,
name|aop_mul
argument_list|,
name|value2
operator|->
name|type
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_add
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value2
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Catch overflow.  */
name|value
operator|->
name|type
operator|=
name|value2
operator|->
name|type
expr_stmt|;
block|}
comment|/* Is it PTR+INT?  */
elseif|else
if|if
condition|(
name|value1
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_PTR
operator|&&
name|value2
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|gen_scale
argument_list|(
name|ax
argument_list|,
name|aop_mul
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_add
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Catch overflow.  */
name|value
operator|->
name|type
operator|=
name|value1
operator|->
name|type
expr_stmt|;
block|}
comment|/* Must be number + number; the usual binary conversions will have      brought them both to the same width.  */
elseif|else
if|if
condition|(
name|value1
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
operator|&&
name|value2
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_add
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Catch overflow.  */
name|value
operator|->
name|type
operator|=
name|value1
operator|->
name|type
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Illegal combination of types in %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Generate code for an addition; non-trivial because we have to deal    with pointer arithmetic.  We set VALUE to describe the result    value; we assume VALUE1 and VALUE2 describe the two operands, and    that they've undergone the usual binary conversions.  */
end_comment

begin_function
specifier|static
name|void
name|gen_sub
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|value1
parameter_list|,
name|value2
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|,
decl|*
name|value1
decl_stmt|,
modifier|*
name|value2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|type
modifier|*
name|element
decl_stmt|;
if|if
condition|(
name|value1
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
comment|/* Is it PTR - INT?  */
if|if
condition|(
name|value2
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|gen_scale
argument_list|(
name|ax
argument_list|,
name|aop_mul
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_sub
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Catch overflow.  */
name|value
operator|->
name|type
operator|=
name|value1
operator|->
name|type
expr_stmt|;
block|}
comment|/* Is it PTR - PTR?  Strictly speaking, the types ought to 	 match, but this is what the normal GDB expression evaluator 	 tests for.  */
elseif|else
if|if
condition|(
name|value2
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_PTR
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|value1
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|value2
operator|->
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_sub
argument_list|)
expr_stmt|;
name|gen_scale
argument_list|(
name|ax
argument_list|,
name|aop_div_unsigned
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|builtin_type_long
expr_stmt|;
comment|/* FIXME --- should be ptrdiff_t */
block|}
else|else
name|error
argument_list|(
literal|"\ First argument of `-' is a pointer, but second argument is neither\n\ an integer nor a pointer of the same type."
argument_list|)
expr_stmt|;
block|}
comment|/* Must be number + number.  */
elseif|else
if|if
condition|(
name|value1
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
operator|&&
name|value2
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_sub
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Catch overflow.  */
name|value
operator|->
name|type
operator|=
name|value1
operator|->
name|type
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Illegal combination of types in subtraction."
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Generate code for a binary operator that doesn't do pointer magic.    We set VALUE to describe the result value; we assume VALUE1 and    VALUE2 describe the two operands, and that they've undergone the    usual binary conversions.  MAY_CARRY should be non-zero iff the    result needs to be extended.  NAME is the English name of the    operator, used in error messages */
end_comment

begin_function
specifier|static
name|void
name|gen_binop
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|value1
parameter_list|,
name|value2
parameter_list|,
name|op
parameter_list|,
name|op_unsigned
parameter_list|,
name|may_carry
parameter_list|,
name|name
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|,
decl|*
name|value1
decl_stmt|,
modifier|*
name|value2
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|agent_op
name|op
decl_stmt|,
name|op_unsigned
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|may_carry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* We only handle INT op INT.  */
if|if
condition|(
operator|(
name|value1
operator|->
name|type
operator|->
name|code
operator|!=
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
name|value2
operator|->
name|type
operator|->
name|code
operator|!=
name|TYPE_CODE_INT
operator|)
condition|)
name|error
argument_list|(
literal|"Illegal combination of types in %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|value1
operator|->
name|type
argument_list|)
condition|?
name|op_unsigned
else|:
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_carry
condition|)
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value1
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* catch overflow */
name|value
operator|->
name|type
operator|=
name|value1
operator|->
name|type
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|gen_logical_not
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|value
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
name|error
argument_list|(
literal|"Illegal type of operand to `!'."
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_log_not
argument_list|)
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_complement
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Illegal type of operand to `~'."
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_integral_promotions
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_bit_not
argument_list|)
expr_stmt|;
name|gen_extend
argument_list|(
name|ax
argument_list|,
name|value
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: *& . -> @ sizeof */
end_comment

begin_comment
comment|/* Dereference the value on the top of the stack.  */
end_comment

begin_function
specifier|static
name|void
name|gen_deref
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
comment|/* The caller should check the type, because several operators use      this, and we don't know what error message to generate.  */
if|if
condition|(
name|value
operator|->
name|type
operator|->
name|code
operator|!=
name|TYPE_CODE_PTR
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_deref): expected a pointer"
argument_list|)
expr_stmt|;
comment|/* We've got an rvalue now, which is a pointer.  We want to yield an      lvalue, whose address is exactly that pointer.  So we don't      actually emit any code; we just change the type from "Pointer to      T" to "T", and mark the value as an lvalue in memory.  Leave it      to the consumer to actually dereference it.  */
name|value
operator|->
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|value
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
operator|(
operator|(
name|value
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_FUNC
operator|)
condition|?
name|axs_rvalue
else|:
name|axs_lvalue_memory
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce the address of the lvalue on the top of the stack.  */
end_comment

begin_function
specifier|static
name|void
name|gen_address_of
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
comment|/* Special case for taking the address of a function.  The ANSI      standard describes this as a special case, too, so this      arrangement is not without motivation.  */
if|if
condition|(
name|value
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_FUNC
condition|)
comment|/* The value's already an rvalue on the stack, so we just need to        change the type.  */
name|value
operator|->
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|value
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|value
operator|->
name|kind
condition|)
block|{
case|case
name|axs_rvalue
case|:
name|error
argument_list|(
literal|"Operand of `&' is an rvalue, which has no address."
argument_list|)
expr_stmt|;
case|case
name|axs_lvalue_register
case|:
name|error
argument_list|(
literal|"Operand of `&' is in a register, and has no address."
argument_list|)
expr_stmt|;
case|case
name|axs_lvalue_memory
case|:
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|value
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* A lot of this stuff will have to change to support C++.  But we're    not going to deal with that at the moment.  */
end_comment

begin_comment
comment|/* Find the field in the structure type TYPE named NAME, and return    its index in TYPE's field array.  */
end_comment

begin_function
specifier|static
name|int
name|find_field
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure this isn't C++.  */
if|if
condition|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (find_field): derived classes supported"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|this_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_name
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
name|this_name
argument_list|)
condition|)
return|return
name|i
return|;
if|if
condition|(
name|this_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (find_field): anonymous unions not supported"
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Couldn't find member named `%s' in struct/union `%s'"
argument_list|,
name|name
argument_list|,
name|type
operator|->
name|tag_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate code to push the value of a bitfield of a structure whose    address is on the top of the stack.  START and END give the    starting and one-past-ending *bit* numbers of the field within the    structure.  */
end_comment

begin_function
specifier|static
name|void
name|gen_bitfield_ref
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
comment|/* Note that ops[i] fetches 8<< i bits.  */
specifier|static
name|enum
name|agent_op
name|ops
index|[]
init|=
block|{
name|aop_ref8
block|,
name|aop_ref16
block|,
name|aop_ref32
block|,
name|aop_ref64
block|}
decl_stmt|;
specifier|static
name|int
name|num_ops
init|=
operator|(
sizeof|sizeof
argument_list|(
name|ops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
comment|/* We don't want to touch any byte that the bitfield doesn't      actually occupy; we shouldn't make any accesses we're not      explicitly permitted to.  We rely here on the fact that the      bytecode `ref' operators work on unaligned addresses.       It takes some fancy footwork to get the stack to work the way      we'd like.  Say we're retrieving a bitfield that requires three      fetches.  Initially, the stack just contains the address: 		addr      For the first fetch, we duplicate the address 		addr addr      then add the byte offset, do the fetch, and shift and mask as      needed, yielding a fragment of the value, properly aligned for      the final bitwise or:                 addr frag1      then we swap, and repeat the process:                 frag1 addr                    --- address on top 		frag1 addr addr               --- duplicate it                 frag1 addr frag2              --- get second fragment                 frag1 frag2 addr              --- swap again                 frag1 frag2 frag3             --- get third fragment      Notice that, since the third fragment is the last one, we don't      bother duplicating the address this time.  Now we have all the      fragments on the stack, and we can simply `or' them together,      yielding the final value of the bitfield.  */
comment|/* The first and one-after-last bits in the field, but rounded down      and up to byte boundaries.  */
name|int
name|bound_start
init|=
operator|(
name|start
operator|/
name|TARGET_CHAR_BIT
operator|)
operator|*
name|TARGET_CHAR_BIT
decl_stmt|;
name|int
name|bound_end
init|=
operator|(
operator|(
operator|(
name|end
operator|+
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|TARGET_CHAR_BIT
operator|)
operator|*
name|TARGET_CHAR_BIT
operator|)
decl_stmt|;
comment|/* current bit offset within the structure */
name|int
name|offset
decl_stmt|;
comment|/* The index in ops of the opcode we're considering.  */
name|int
name|op
decl_stmt|;
comment|/* The number of fragments we generated in the process.  Probably      equal to the number of `one' bits in bytesize, but who cares?  */
name|int
name|fragment_count
decl_stmt|;
comment|/* Dereference any typedefs. */
name|type
operator|=
name|check_typedef
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Can we fetch the number of bits requested at all?  */
if|if
condition|(
operator|(
name|end
operator|-
name|start
operator|)
operator|>
operator|(
operator|(
literal|1
operator|<<
name|num_ops
operator|)
operator|*
literal|8
operator|)
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_bitfield_ref): bitfield too wide"
argument_list|)
expr_stmt|;
comment|/* Note that we know here that we only need to try each opcode once.      That may not be true on machines with weird byte sizes.  */
name|offset
operator|=
name|bound_start
expr_stmt|;
name|fragment_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|op
operator|=
name|num_ops
operator|-
literal|1
init|;
name|op
operator|>=
literal|0
condition|;
name|op
operator|--
control|)
block|{
comment|/* number of bits that ops[op] would fetch */
name|int
name|op_size
init|=
literal|8
operator|<<
name|op
decl_stmt|;
comment|/* The stack at this point, from bottom to top, contains zero or 	 more fragments, then the address.  */
comment|/* Does this fetch fit within the bitfield?  */
if|if
condition|(
name|offset
operator|+
name|op_size
operator|<=
name|bound_end
condition|)
block|{
comment|/* Is this the last fragment?  */
name|int
name|last_frag
init|=
operator|(
name|offset
operator|+
name|op_size
operator|==
name|bound_end
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|last_frag
condition|)
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_dup
argument_list|)
expr_stmt|;
comment|/* keep a copy of the address */
comment|/* Add the offset.  */
name|gen_offset
argument_list|(
name|ax
argument_list|,
name|offset
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_kludge
condition|)
block|{
comment|/* Record the area of memory we're about to fetch.  */
name|ax_trace_quick
argument_list|(
name|ax
argument_list|,
name|op_size
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
block|}
comment|/* Perform the fetch.  */
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|ops
index|[
name|op
index|]
argument_list|)
expr_stmt|;
comment|/* Shift the bits we have to their proper position. 	     gen_left_shift will generate right shifts when the operand 	     is negative.               A big-endian field diagram to ponder:               byte 0  byte 1  byte 2  byte 3  byte 4  byte 5  byte 6  byte 7              +------++------++------++------++------++------++------++------+              xxxxAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCxxxxxxxxxxx                              ^               ^               ^    ^              bit number      16              32              48   53 	     These are bit numbers as supplied by GDB.  Note that the 	     bit numbers run from right to left once you've fetched the 	     value!               A little-endian field diagram to ponder:               byte 7  byte 6  byte 5  byte 4  byte 3  byte 2  byte 1  byte 0              +------++------++------++------++------++------++------++------+              xxxxxxxxxxxAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCxxxx                             ^               ^               ^           ^   ^              bit number     48              32              16          4   0               In both cases, the most significant end is on the left              (i.e. normal numeric writing order), which means that you              don't go crazy thinking about `left' and `right' shifts.               We don't have to worry about masking yet:              - If they contain garbage off the least significant end, then we                must be looking at the low end of the field, and the right                shift will wipe them out.              - If they contain garbage off the most significant end, then we                must be looking at the most significant end of the word, and                the sign/zero extension will wipe them out.              - If we're in the interior of the word, then there is no garbage                on either end, because the ref operators zero-extend.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
name|gen_left_shift
argument_list|(
name|ax
argument_list|,
name|end
operator|-
operator|(
name|offset
operator|+
name|op_size
operator|)
argument_list|)
expr_stmt|;
else|else
name|gen_left_shift
argument_list|(
name|ax
argument_list|,
name|offset
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_frag
condition|)
comment|/* Bring the copy of the address up to the top.  */
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_swap
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|op_size
expr_stmt|;
name|fragment_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Generate enough bitwise `or' operations to combine all the      fragments we left on the stack.  */
while|while
condition|(
name|fragment_count
operator|--
operator|>
literal|1
condition|)
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_bit_or
argument_list|)
expr_stmt|;
comment|/* Sign- or zero-extend the value as appropriate.  */
operator|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|ax_zero_ext
else|:
name|ax_ext
operator|)
operator|(
name|ax
operator|,
name|end
operator|-
name|start
operator|)
operator|)
expr_stmt|;
comment|/* This is *not* an lvalue.  Ugh.  */
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to reference the member named FIELD of a structure or    union.  The top of the stack, as described by VALUE, should have    type (pointer to a)* struct/union.  OPERATOR_NAME is the name of    the operator being compiled, and OPERAND_NAME is the kind of thing    it operates on; we use them in error messages.  */
end_comment

begin_function
specifier|static
name|void
name|gen_struct_ref
parameter_list|(
name|ax
parameter_list|,
name|value
parameter_list|,
name|field
parameter_list|,
name|operator_name
parameter_list|,
name|operand_name
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|operator_name
decl_stmt|;
name|char
modifier|*
name|operand_name
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Follow pointers until we reach a non-pointer.  These aren't the C      semantics, but they're what the normal GDB evaluator does, so we      should at least be consistent.  */
while|while
condition|(
name|value
operator|->
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_deref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|value
operator|->
name|type
expr_stmt|;
comment|/* This must yield a structure or a union.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"The left operand of `%s' is not a %s."
argument_list|,
name|operator_name
argument_list|,
name|operand_name
argument_list|)
expr_stmt|;
comment|/* And it must be in memory; we don't deal with structure rvalues,      or structures living in registers.  */
if|if
condition|(
name|value
operator|->
name|kind
operator|!=
name|axs_lvalue_memory
condition|)
name|error
argument_list|(
literal|"Structure does not live in memory."
argument_list|)
expr_stmt|;
name|i
operator|=
name|find_field
argument_list|(
name|type
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* Is this a bitfield?  */
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|gen_bitfield_ref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|+
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gen_offset
argument_list|(
name|ax
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code for GDB's magical `repeat' operator.      LVALUE @ INT creates an array INT elements long, and whose elements    have the same type as LVALUE, located in memory so that LVALUE is    its first element.  For example, argv[0]@argc gives you the array    of command-line arguments.     Unfortunately, because we have to know the types before we actually    have a value for the expression, we can't implement this perfectly    without changing the type system, having values that occupy two    stack slots, doing weird things with sizeof, etc.  So we require    the right operand to be a constant expression.  */
end_comment

begin_function
specifier|static
name|void
name|gen_repeat
parameter_list|(
name|pc
parameter_list|,
name|ax
parameter_list|,
name|value
parameter_list|)
name|union
name|exp_element
modifier|*
modifier|*
name|pc
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|axs_value
name|value1
decl_stmt|;
comment|/* We don't want to turn this into an rvalue, so no conversions      here.  */
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value1
operator|.
name|kind
operator|!=
name|axs_lvalue_memory
condition|)
name|error
argument_list|(
literal|"Left operand of `@' must be an object in memory."
argument_list|)
expr_stmt|;
comment|/* Evaluate the length; it had better be a constant.  */
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|const_expr
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
name|error
argument_list|(
literal|"Right operand of `@' must be a constant, in agent expressions."
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|type
operator|->
name|code
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Right operand of `@' must be an integer."
argument_list|)
expr_stmt|;
name|length
operator|=
name|value_as_long
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Right operand of `@' must be positive."
argument_list|)
expr_stmt|;
comment|/* The top of the stack is already the address of the object, so        all we need to do is frob the type of the lvalue.  */
block|{
comment|/* FIXME-type-allocation: need a way to free this type when we are 	 done with it.  */
name|struct
name|type
modifier|*
name|range
init|=
name|create_range_type
argument_list|(
literal|0
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|array
init|=
name|create_array_type
argument_list|(
literal|0
argument_list|,
name|value1
operator|.
name|type
argument_list|,
name|range
argument_list|)
decl_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|array
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Emit code for the `sizeof' operator.    *PC should point at the start of the operand expression; we advance it    to the first instruction after the operand.  */
end_comment

begin_function
specifier|static
name|void
name|gen_sizeof
parameter_list|(
name|pc
parameter_list|,
name|ax
parameter_list|,
name|value
parameter_list|)
name|union
name|exp_element
modifier|*
modifier|*
name|pc
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
comment|/* We don't care about the value of the operand expression; we only      care about its type.  However, in the current arrangement, the      only way to find an expression's type is to generate code for it.      So we generate code for the operand, and then throw it away,      replacing it with code that simply pushes its size.  */
name|int
name|start
init|=
name|ax
operator|->
name|len
decl_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Throw away the code we just generated.  */
name|ax
operator|->
name|len
operator|=
name|start
expr_stmt|;
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|value
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generating bytecode from GDB expressions: general recursive thingy  */
end_comment

begin_comment
comment|/* A gen_expr function written by a Gen-X'er guy.    Append code for the subexpression of EXPR starting at *POS_P to AX.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expr
parameter_list|(
name|pc
parameter_list|,
name|ax
parameter_list|,
name|value
parameter_list|)
name|union
name|exp_element
modifier|*
modifier|*
name|pc
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
comment|/* Used to hold the descriptions of operand expressions.  */
name|struct
name|axs_value
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|enum
name|exp_opcode
name|op
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|0
index|]
operator|.
name|opcode
decl_stmt|;
comment|/* If we're looking at a constant expression, just push its value.  */
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|maybe_const_expr
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|value_as_long
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_rvalue
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Otherwise, go ahead and generate code for it.  */
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* Binary arithmetic operators.  */
case|case
name|BINOP_ADD
case|:
case|case
name|BINOP_SUB
case|:
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_SUBSCRIPT
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|gen_usual_arithmetic
argument_list|(
name|ax
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|gen_add
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
literal|"addition"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|gen_sub
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|gen_binop
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
name|aop_mul
argument_list|,
name|aop_mul
argument_list|,
literal|1
argument_list|,
literal|"multiplication"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|gen_binop
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
name|aop_div_signed
argument_list|,
name|aop_div_unsigned
argument_list|,
literal|1
argument_list|,
literal|"division"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|gen_binop
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
name|aop_rem_signed
argument_list|,
name|aop_rem_unsigned
argument_list|,
literal|1
argument_list|,
literal|"remainder"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUBSCRIPT
case|:
name|gen_add
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
literal|"array subscripting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
name|error
argument_list|(
literal|"Illegal combination of types in array subscripting."
argument_list|)
expr_stmt|;
name|gen_deref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|gen_binop
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
name|aop_bit_and
argument_list|,
name|aop_bit_and
argument_list|,
literal|0
argument_list|,
literal|"bitwise and"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|gen_binop
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
name|aop_bit_or
argument_list|,
name|aop_bit_or
argument_list|,
literal|0
argument_list|,
literal|"bitwise or"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|gen_binop
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|,
name|aop_bit_xor
argument_list|,
name|aop_bit_xor
argument_list|,
literal|0
argument_list|,
literal|"bitwise exclusive-or"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We should only list operators in the outer case statement              that we actually handle in the inner case statement.  */
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_expr): op case sets don't match"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Note that we need to be a little subtle about generating code 	 for comma.  In C, we can do some optimizations here because 	 we know the left operand is only being evaluated for effect. 	 However, if the tracing kludge is in effect, then we always 	 need to evaluate the left hand side fully, so that all the 	 variables it mentions get traced.  */
case|case
name|BINOP_COMMA
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
comment|/* Don't just dispose of the left operand.  We might be tracing, 	 in which case we want to emit code to trace it if it's an 	 lvalue.  */
name|gen_traced_pop
argument_list|(
name|ax
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* It's the consumer's responsibility to trace the right operand.  */
break|break;
case|case
name|OP_LONG
case|:
comment|/* some integer constant */
block|{
name|struct
name|type
modifier|*
name|type
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|1
index|]
operator|.
name|type
decl_stmt|;
name|LONGEST
name|k
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|2
index|]
operator|.
name|longconst
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|4
expr_stmt|;
name|gen_int_literal
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
name|k
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_VAR_VALUE
case|:
name|gen_var_ref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|(
operator|*
name|pc
operator|)
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_REGISTER
case|:
block|{
name|int
name|reg
init|=
call|(
name|int
call|)
argument_list|(
operator|*
name|pc
argument_list|)
index|[
literal|1
index|]
operator|.
name|longconst
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|3
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_register
expr_stmt|;
name|value
operator|->
name|u
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_INTERNALVAR
case|:
name|error
argument_list|(
literal|"GDB agent expressions cannot use convenience variables."
argument_list|)
expr_stmt|;
comment|/* Weirdo operator: see comments for gen_repeat for details.  */
case|case
name|BINOP_REPEAT
case|:
comment|/* Note that gen_repeat handles its own argument evaluation.  */
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_repeat
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_CAST
case|:
block|{
name|struct
name|type
modifier|*
name|type
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|1
index|]
operator|.
name|type
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|3
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_cast
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNOP_MEMVAL
case|:
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
operator|(
operator|*
name|pc
operator|)
index|[
literal|1
index|]
operator|.
name|type
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|3
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* I'm not sure I understand UNOP_MEMVAL entirely.  I think 	   it's just a hack for dealing with minsyms; you take some 	   integer constant, pretend it's the address of an lvalue of 	   the given type, and dereference it.  */
if|if
condition|(
name|value
operator|->
name|kind
operator|!=
name|axs_rvalue
condition|)
comment|/* This would be weird.  */
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_expr): OP_MEMVAL operand isn't an rvalue???"
argument_list|)
expr_stmt|;
name|value
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
block|}
break|break;
case|case
name|UNOP_NEG
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
comment|/* -FOO is equivalent to 0 - FOO.  */
name|gen_int_literal
argument_list|(
name|ax
argument_list|,
operator|&
name|value1
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|,
name|builtin_type_int
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
operator|&
name|value1
argument_list|)
expr_stmt|;
comment|/* shouldn't do much */
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|gen_usual_arithmetic
argument_list|(
name|ax
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|gen_sub
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
operator|&
name|value1
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_LOGICAL_NOT
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_logical_not
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_COMPLEMENT
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_complement
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_usual_unary
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
name|error
argument_list|(
literal|"Argument of unary `*' is not a pointer."
argument_list|)
expr_stmt|;
name|gen_deref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_ADDR
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gen_address_of
argument_list|(
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_SIZEOF
case|:
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
comment|/* Notice that gen_sizeof handles its own operand, unlike most 	 of the other unary operator functions.  This is because we 	 have to throw away the code we generate.  */
name|gen_sizeof
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
block|{
name|int
name|length
init|=
operator|(
operator|*
name|pc
operator|)
index|[
literal|1
index|]
operator|.
name|longconst
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|&
operator|(
operator|*
name|pc
operator|)
index|[
literal|2
index|]
operator|.
name|string
decl_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gen_expr
argument_list|(
name|pc
argument_list|,
name|ax
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
condition|)
name|gen_struct_ref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
name|name
argument_list|,
literal|"."
argument_list|,
literal|"structure or union"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_PTR
condition|)
name|gen_struct_ref
argument_list|(
name|ax
argument_list|,
name|value
argument_list|,
name|name
argument_list|,
literal|"->"
argument_list|,
literal|"pointer to a structure or union"
argument_list|)
expr_stmt|;
else|else
comment|/* If this `if' chain doesn't handle it, then the case list              shouldn't mention it, and we shouldn't be here.  */
name|error
argument_list|(
literal|"GDB bug: ax-gdb.c (gen_expr): unhandled struct case"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_TYPE
case|:
name|error
argument_list|(
literal|"Attempt to use a type name as an expression."
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Unsupported operator in expression."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not used */
end_comment

begin_comment
comment|/* Generating bytecode from GDB expressions: driver */
end_comment

begin_comment
comment|/* Given a GDB expression EXPR, produce a string of agent bytecode    which computes its value.  Return the agent expression, and set    *VALUE to describe its type, and whether it's an lvalue or rvalue.  */
end_comment

begin_comment
unit|struct agent_expr * expr_to_agent (expr, value)      struct expression *expr;      struct axs_value *value; {   struct cleanup *old_chain = 0;   struct agent_expr *ax = new_agent_expr ();   union exp_element *pc;    old_chain = make_cleanup ((make_cleanup_func) free_agent_expr, ax);    pc = expr->elts;   trace_kludge = 0;   gen_expr (&pc, ax, value);
comment|/* We have successfully built the agent expr, so cancel the cleanup      request.  If we add more cleanups that we always want done, this      will have to get more complicated.  */
end_comment

begin_comment
unit|discard_cleanups (old_chain);   return ax; }
comment|/* Given a GDB expression EXPR denoting an lvalue in memory, produce a    string of agent bytecode which will leave its address and size on    the top of stack.  Return the agent expression.     Not sure this function is useful at all.  */
end_comment

begin_comment
unit|struct agent_expr * expr_to_address_and_size (expr)      struct expression *expr; {   struct axs_value value;   struct agent_expr *ax = expr_to_agent (expr,&value);
comment|/* Complain if the result is not a memory lvalue.  */
end_comment

begin_comment
unit|if (value.kind != axs_lvalue_memory)     {       free_agent_expr (ax);       error ("Expression does not denote an object in memory.");     }
comment|/* Push the object's size on the stack.  */
end_comment

begin_endif
unit|ax_const_l (ax, TYPE_LENGTH (value.type));    return ax; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Given a GDB expression EXPR, return bytecode to trace its value.    The result will use the `trace' and `trace_quick' bytecodes to    record the value of all memory touched by the expression.  The    caller can then use the ax_reqs function to discover which    registers it relies upon.  */
end_comment

begin_function
name|struct
name|agent_expr
modifier|*
name|gen_trace_for_expr
parameter_list|(
name|scope
parameter_list|,
name|expr
parameter_list|)
name|CORE_ADDR
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|ax
init|=
name|new_agent_expr
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|union
name|exp_element
modifier|*
name|pc
decl_stmt|;
name|struct
name|axs_value
name|value
decl_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_agent_expr
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|pc
operator|=
name|expr
operator|->
name|elts
expr_stmt|;
name|trace_kludge
operator|=
literal|1
expr_stmt|;
name|gen_expr
argument_list|(
operator|&
name|pc
argument_list|,
name|ax
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Make sure we record the final object, and get rid of it.  */
name|gen_traced_pop
argument_list|(
name|ax
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Oh, and terminate.  */
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_end
argument_list|)
expr_stmt|;
comment|/* We have successfully built the agent expr, so cancel the cleanup      request.  If we add more cleanups that we always want done, this      will have to get more complicated.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|ax
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The "agent" command, for testing: compile and disassemble an expression.  */
end_comment

begin_function
specifier|static
name|void
name|print_axs_value
parameter_list|(
name|f
parameter_list|,
name|value
parameter_list|)
name|GDB_FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|axs_value
modifier|*
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|value
operator|->
name|kind
condition|)
block|{
case|case
name|axs_rvalue
case|:
name|fputs_filtered
argument_list|(
literal|"rvalue"
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|axs_lvalue_memory
case|:
name|fputs_filtered
argument_list|(
literal|"memory lvalue"
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|axs_lvalue_register
case|:
name|fprintf_filtered
argument_list|(
name|f
argument_list|,
literal|"register %d lvalue"
argument_list|,
name|value
operator|->
name|u
operator|.
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs_filtered
argument_list|(
literal|" : "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|value
operator|->
name|type
argument_list|,
literal|""
argument_list|,
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|agent_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|agent
decl_stmt|;
name|struct
name|agent_reqs
name|reqs
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
comment|/* need current scope */
comment|/* We don't deal with overlay debugging at the moment.  We need to      think more carefully about this.  If you copy this code into      another command, change the error message; the user shouldn't      have to know anything about agent expressions.  */
if|if
condition|(
name|overlay_debugging
condition|)
name|error
argument_list|(
literal|"GDB can't do agent expression translation with overlays."
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"expression to translate"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|agent
operator|=
name|gen_trace_for_expr
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_agent_expr
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|ax_print
argument_list|(
name|gdb_stdout
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|ax_reqs
argument_list|(
name|agent
argument_list|,
operator|&
name|reqs
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization code.  */
end_comment

begin_decl_stmt
name|void
name|_initialize_ax_gdb
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_ax_gdb
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_cmd
argument_list|(
literal|"agent"
argument_list|,
name|class_maintenance
argument_list|,
name|agent_command
argument_list|,
literal|"Translate an expression into remote agent bytecode."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

