begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 386 target-dependent stuff.     Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"dummy-frame.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2-frame.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"regset.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_comment
comment|/* Names of the registers.  The first 10 registers match the register    numbering scheme used by GCC for stabs and DWARF.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|i386_register_names
index|[]
init|=
block|{
literal|"eax"
block|,
literal|"ecx"
block|,
literal|"edx"
block|,
literal|"ebx"
block|,
literal|"esp"
block|,
literal|"ebp"
block|,
literal|"esi"
block|,
literal|"edi"
block|,
literal|"eip"
block|,
literal|"eflags"
block|,
literal|"cs"
block|,
literal|"ss"
block|,
literal|"ds"
block|,
literal|"es"
block|,
literal|"fs"
block|,
literal|"gs"
block|,
literal|"st0"
block|,
literal|"st1"
block|,
literal|"st2"
block|,
literal|"st3"
block|,
literal|"st4"
block|,
literal|"st5"
block|,
literal|"st6"
block|,
literal|"st7"
block|,
literal|"fctrl"
block|,
literal|"fstat"
block|,
literal|"ftag"
block|,
literal|"fiseg"
block|,
literal|"fioff"
block|,
literal|"foseg"
block|,
literal|"fooff"
block|,
literal|"fop"
block|,
literal|"xmm0"
block|,
literal|"xmm1"
block|,
literal|"xmm2"
block|,
literal|"xmm3"
block|,
literal|"xmm4"
block|,
literal|"xmm5"
block|,
literal|"xmm6"
block|,
literal|"xmm7"
block|,
literal|"mxcsr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|i386_num_register_names
init|=
name|ARRAY_SIZE
argument_list|(
name|i386_register_names
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MMX registers.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|i386_mmx_names
index|[]
init|=
block|{
literal|"mm0"
block|,
literal|"mm1"
block|,
literal|"mm2"
block|,
literal|"mm3"
block|,
literal|"mm4"
block|,
literal|"mm5"
block|,
literal|"mm6"
block|,
literal|"mm7"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|i386_num_mmx_regs
init|=
name|ARRAY_SIZE
argument_list|(
name|i386_mmx_names
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i386_mmx_regnum_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|int
name|mm0_regnum
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|mm0_regnum
decl_stmt|;
if|if
condition|(
name|mm0_regnum
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|regnum
operator|>=
name|mm0_regnum
operator|&&
name|regnum
operator|<
name|mm0_regnum
operator|+
name|i386_num_mmx_regs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SSE register?  */
end_comment

begin_function
specifier|static
name|int
name|i386_sse_regnum_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
define|#
directive|define
name|I387_NUM_XMM_REGS
value|tdep->num_xmm_regs
if|if
condition|(
name|I387_NUM_XMM_REGS
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|I387_XMM0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<
name|I387_MXCSR_REGNUM
operator|)
return|;
undef|#
directive|undef
name|I387_ST0_REGNUM
undef|#
directive|undef
name|I387_NUM_XMM_REGS
block|}
end_function

begin_function
specifier|static
name|int
name|i386_mxcsr_regnum_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
define|#
directive|define
name|I387_NUM_XMM_REGS
value|tdep->num_xmm_regs
if|if
condition|(
name|I387_NUM_XMM_REGS
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|regnum
operator|==
name|I387_MXCSR_REGNUM
operator|)
return|;
undef|#
directive|undef
name|I387_ST0_REGNUM
undef|#
directive|undef
name|I387_NUM_XMM_REGS
block|}
end_function

begin_define
define|#
directive|define
name|I387_ST0_REGNUM
value|(gdbarch_tdep (current_gdbarch)->st0_regnum)
end_define

begin_define
define|#
directive|define
name|I387_MM0_REGNUM
value|(gdbarch_tdep (current_gdbarch)->mm0_regnum)
end_define

begin_define
define|#
directive|define
name|I387_NUM_XMM_REGS
value|(gdbarch_tdep (current_gdbarch)->num_xmm_regs)
end_define

begin_comment
comment|/* FP register?  */
end_comment

begin_function
name|int
name|i386_fp_regnum_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|I387_ST0_REGNUM
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|I387_ST0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<
name|I387_FCTRL_REGNUM
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i386_fpc_regnum_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|I387_ST0_REGNUM
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|I387_FCTRL_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<
name|I387_XMM0_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register REG.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_register_name
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|i386_mmx_regnum_p
argument_list|(
name|current_gdbarch
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|i386_mmx_names
index|[
name|reg
operator|-
name|I387_MM0_REGNUM
index|]
return|;
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<
name|i386_num_register_names
condition|)
return|return
name|i386_register_names
index|[
name|reg
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Convert stabs register number REG to the appropriate register    number used by GDB.  */
end_comment

begin_function
specifier|static
name|int
name|i386_stab_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* This implements what GCC calls the "default" register map.  */
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|7
condition|)
block|{
comment|/* General-purpose registers.  */
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|12
operator|&&
name|reg
operator|<=
literal|19
condition|)
block|{
comment|/* Floating-point registers.  */
return|return
name|reg
operator|-
literal|12
operator|+
name|I387_ST0_REGNUM
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|21
operator|&&
name|reg
operator|<=
literal|28
condition|)
block|{
comment|/* SSE registers.  */
return|return
name|reg
operator|-
literal|21
operator|+
name|I387_XMM0_REGNUM
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|29
operator|&&
name|reg
operator|<=
literal|36
condition|)
block|{
comment|/* MMX registers.  */
return|return
name|reg
operator|-
literal|29
operator|+
name|I387_MM0_REGNUM
return|;
block|}
comment|/* This will hopefully provoke a warning.  */
return|return
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Convert DWARF register number REG to the appropriate register    number used by GDB.  */
end_comment

begin_function
specifier|static
name|int
name|i386_dwarf_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* The DWARF register numbering includes %eip and %eflags, and      numbers the floating point registers differently.  */
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|9
condition|)
block|{
comment|/* General-purpose registers.  */
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|11
operator|&&
name|reg
operator|<=
literal|18
condition|)
block|{
comment|/* Floating-point registers.  */
return|return
name|reg
operator|-
literal|11
operator|+
name|I387_ST0_REGNUM
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|21
condition|)
block|{
comment|/* The SSE and MMX registers have identical numbers as in stabs.  */
return|return
name|i386_stab_reg_to_regnum
argument_list|(
name|reg
argument_list|)
return|;
block|}
comment|/* This will hopefully provoke a warning.  */
return|return
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|I387_ST0_REGNUM
end_undef

begin_undef
undef|#
directive|undef
name|I387_MM0_REGNUM
end_undef

begin_undef
undef|#
directive|undef
name|I387_NUM_XMM_REGS
end_undef

begin_escape
end_escape

begin_comment
comment|/* This is the variable that is set with "set disassembly-flavor", and    its legitimate values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|att_flavor
index|[]
init|=
literal|"att"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|intel_flavor
index|[]
init|=
literal|"intel"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|valid_flavors
index|[]
init|=
block|{
name|att_flavor
block|,
name|intel_flavor
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|disassembly_flavor
init|=
name|att_flavor
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Use the program counter to determine the contents and size of a    breakpoint instruction.  Return a pointer to a string of bytes that    encode a breakpoint instruction, store the length of the string in    *LEN and optionally adjust *PC to point to the correct memory    location for inserting the breakpoint.     On the i386 we have a single breakpoint that fits in a single byte    and can be inserted anywhere.     This function is 64-bit safe.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|i386_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
block|{
literal|0xcc
block|}
decl_stmt|;
comment|/* int 3 */
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|break_insn
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|I386_REGNO_TO_SYMMETRY
end_ifdef

begin_error
error|#
directive|error
literal|"The Sequent Symmetry is no longer supported."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi    and %esp "belong" to the calling function.  Therefore these    registers should be saved if they're going to be modified.  */
end_comment

begin_comment
comment|/* The maximum number of saved registers.  This should include all    registers mentioned above, and %eip.  */
end_comment

begin_define
define|#
directive|define
name|I386_NUM_SAVED_REGS
value|I386_NUM_GREGS
end_define

begin_struct
struct|struct
name|i386_frame_cache
block|{
comment|/* Base address.  */
name|CORE_ADDR
name|base
decl_stmt|;
name|CORE_ADDR
name|sp_offset
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* Saved registers.  */
name|CORE_ADDR
name|saved_regs
index|[
name|I386_NUM_SAVED_REGS
index|]
decl_stmt|;
name|CORE_ADDR
name|saved_sp
decl_stmt|;
name|int
name|pc_in_eax
decl_stmt|;
comment|/* Stack space reserved for local variables.  */
name|long
name|locals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate and initialize a frame cache.  */
end_comment

begin_function
specifier|static
name|struct
name|i386_frame_cache
modifier|*
name|i386_alloc_frame_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|i386_frame_cache
argument_list|)
expr_stmt|;
comment|/* Base address.  */
name|cache
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sp_offset
operator|=
operator|-
literal|4
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
comment|/* Saved registers.  We initialize these to -1 since zero is a valid      offset (that's where %ebp is supposed to be stored).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_SAVED_REGS
condition|;
name|i
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|cache
operator|->
name|saved_sp
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|pc_in_eax
operator|=
literal|0
expr_stmt|;
comment|/* Frameless until proven otherwise.  */
name|cache
operator|->
name|locals
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_comment
comment|/* If the instruction at PC is a jump, return the address of its    target.  Otherwise, return PC.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_follow_jump
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|long
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|data16
init|=
literal|0
decl_stmt|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x66
condition|)
block|{
name|data16
operator|=
literal|1
expr_stmt|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|0xe9
case|:
comment|/* Relative jump: if data16 == 0, disp32, else disp16.  */
if|if
condition|(
name|data16
condition|)
block|{
name|delta
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Include the size of the jmp instruction (including the              0x66 prefix).  */
name|delta
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Include the size of the jmp instruction.  */
name|delta
operator|+=
literal|5
expr_stmt|;
block|}
break|break;
case|case
literal|0xeb
case|:
comment|/* Relative jump, disp8 (ignore data16).  */
name|delta
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
name|data16
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|delta
operator|+=
name|data16
operator|+
literal|2
expr_stmt|;
break|break;
block|}
return|return
name|pc
operator|+
name|delta
return|;
block|}
end_function

begin_comment
comment|/* Check whether PC points at a prologue for a function returning a    structure or union.  If so, it updates CACHE and returns the    address of the first instruction after the code sequence that    removes the "hidden" argument from the stack or CURRENT_PC,    whichever is smaller.  Otherwise, return PC.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_analyze_struct_return
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|i386_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
comment|/* Functions that return a structure or union start with:          popl %eax             0x58         xchgl %eax, (%esp)    0x87 0x04 0x24      or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00       (the System V compiler puts out the second `xchg' instruction,      and the assembler doesn't try to optimize it, so the 'sib' form      gets generated).  This sequence is used to get the address of the      return buffer for a function that returns a structure.  */
specifier|static
name|unsigned
name|char
name|proto1
index|[
literal|3
index|]
init|=
block|{
literal|0x87
block|,
literal|0x04
block|,
literal|0x24
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto2
index|[
literal|4
index|]
init|=
block|{
literal|0x87
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x00
block|}
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
if|if
condition|(
name|current_pc
operator|<=
name|pc
condition|)
return|return
name|pc
return|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|0x58
condition|)
comment|/* popl %eax */
return|return
name|pc
return|;
name|read_memory
argument_list|(
name|pc
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto1
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto2
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|pc
return|;
if|if
condition|(
name|current_pc
operator|==
name|pc
condition|)
block|{
name|cache
operator|->
name|sp_offset
operator|+=
literal|4
expr_stmt|;
return|return
name|current_pc
return|;
block|}
if|if
condition|(
name|current_pc
operator|==
name|pc
operator|+
literal|1
condition|)
block|{
name|cache
operator|->
name|pc_in_eax
operator|=
literal|1
expr_stmt|;
return|return
name|current_pc
return|;
block|}
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
name|proto1
index|[
literal|1
index|]
condition|)
return|return
name|pc
operator|+
literal|4
return|;
else|else
return|return
name|pc
operator|+
literal|5
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|i386_skip_probe
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* A function may start with          pushl constant         call _probe 	addl $4, %esp 	         followed by          pushl %ebp       etc.  */
name|unsigned
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x68
operator|||
name|op
operator|==
literal|0x6a
condition|)
block|{
name|int
name|delta
decl_stmt|;
comment|/* Skip past the `pushl' instruction; it has either a one-byte or a 	 four-byte operand, depending on the opcode.  */
if|if
condition|(
name|op
operator|==
literal|0x68
condition|)
name|delta
operator|=
literal|5
expr_stmt|;
else|else
name|delta
operator|=
literal|2
expr_stmt|;
comment|/* Read the following 8 bytes, which should be `call _probe' (6 	 bytes) followed by `addl $4,%esp' (2 bytes).  */
name|read_memory
argument_list|(
name|pc
operator|+
name|delta
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0xe8
operator|&&
name|buf
index|[
literal|6
index|]
operator|==
literal|0xc4
operator|&&
name|buf
index|[
literal|7
index|]
operator|==
literal|0x4
condition|)
name|pc
operator|+=
name|delta
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Check whether PC points at a code that sets up a new stack frame.    If so, it updates CACHE and returns the address of the first    instruction after the sequence that sets removes the "hidden"    argument from the stack or CURRENT_PC, whichever is smaller.    Otherwise, return PC.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_analyze_frame_setup
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|i386_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_pc
operator|<=
name|pc
condition|)
return|return
name|current_pc
return|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushl %ebp */
block|{
comment|/* Take into account that we've executed the `pushl %ebp' that 	 starts this instruction sequence.  */
name|cache
operator|->
name|saved_regs
index|[
name|I386_EBP_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sp_offset
operator|+=
literal|4
expr_stmt|;
comment|/* If that's all, return now.  */
if|if
condition|(
name|current_pc
operator|<=
name|pc
operator|+
literal|1
condition|)
return|return
name|current_pc
return|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for some special instructions that might be migrated 	 by GCC into the prologue.  We check for  	    xorl %ebx, %ebx 	    xorl %ecx, %ecx 	    xorl %edx, %edx 	    xorl %eax, %eax  	 and the equivalent  	    subl %ebx, %ebx 	    subl %ecx, %ecx 	    subl %edx, %edx 	    subl %eax, %eax  	 Because of the symmetry, there are actually two ways to 	 encode these instructions; with opcode bytes 0x29 and 0x2b 	 for `subl' and opcode bytes 0x31 and 0x33 for `xorl'.  	 Make sure we only skip these instructions if we later see the 	 `movl %esp, %ebp' that actually sets up the frame.  */
while|while
condition|(
name|op
operator|==
literal|0x29
operator|||
name|op
operator|==
literal|0x2b
operator|||
name|op
operator|==
literal|0x31
operator|||
name|op
operator|==
literal|0x33
condition|)
block|{
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|skip
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|0xdb
case|:
comment|/* %ebx */
case|case
literal|0xc9
case|:
comment|/* %ecx */
case|case
literal|0xd2
case|:
comment|/* %edx */
case|case
literal|0xc0
case|:
comment|/* %eax */
name|skip
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|pc
operator|+
literal|1
return|;
block|}
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|skip
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check for `movl %esp, %ebp' -- can be written in two ways.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|0x8b
case|:
if|if
condition|(
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|skip
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0xec
condition|)
return|return
name|pc
operator|+
literal|1
return|;
break|break;
case|case
literal|0x89
case|:
if|if
condition|(
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|skip
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0xe5
condition|)
return|return
name|pc
operator|+
literal|1
return|;
break|break;
default|default:
return|return
name|pc
operator|+
literal|1
return|;
block|}
comment|/* OK, we actually have a frame.  We just don't know how large 	 it is yet.  Set its size to zero.  We'll adjust it if 	 necessary.  We also now commit to skipping the special 	 instructions mentioned before.  */
name|cache
operator|->
name|locals
operator|=
literal|0
expr_stmt|;
name|pc
operator|+=
name|skip
expr_stmt|;
comment|/* If that's all, return now.  */
if|if
condition|(
name|current_pc
operator|<=
name|pc
operator|+
literal|3
condition|)
return|return
name|current_pc
return|;
comment|/* Check for stack adjustment   	    subl $XXX, %esp  	 NOTE: You can't subtract a 16 bit immediate from a 32 bit 	 reg, so we don't have to worry about a data16 prefix.  */
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
comment|/* `subl' with 8 bit immediate.  */
if|if
condition|(
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0xec
condition|)
comment|/* Some instruction starting with 0x83 other than `subl'.  */
return|return
name|pc
operator|+
literal|3
return|;
comment|/* `subl' with signed byte immediate (though it wouldn't make 	     sense to be negative).  */
name|cache
operator|->
name|locals
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|pc
operator|+
literal|6
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
block|{
comment|/* Maybe it is `subl' with a 32 bit immedediate.  */
if|if
condition|(
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0xec
condition|)
comment|/* Some instruction starting with 0x81 other than `subl'.  */
return|return
name|pc
operator|+
literal|3
return|;
comment|/* It is `subl' with a 32 bit immediate.  */
name|cache
operator|->
name|locals
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|pc
operator|+
literal|9
return|;
block|}
else|else
block|{
comment|/* Some instruction other than `subl'.  */
return|return
name|pc
operator|+
literal|3
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
comment|/* enter $XXX */
block|{
name|cache
operator|->
name|locals
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|pc
operator|+
literal|4
return|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Check whether PC points at code that saves registers on the stack.    If so, it updates CACHE and returns the address of the first    instruction after the register saves or CURRENT_PC, whichever is    smaller.  Otherwise, return PC.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_analyze_register_saves
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|i386_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
name|CORE_ADDR
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|locals
operator|>
literal|0
condition|)
name|offset
operator|-=
name|cache
operator|->
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|pc
operator|<
name|current_pc
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|offset
operator|-=
literal|4
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|op
operator|-
literal|0x50
index|]
operator|=
name|offset
expr_stmt|;
name|cache
operator|->
name|sp_offset
operator|+=
literal|4
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Do a full analysis of the prologue at PC and update CACHE    accordingly.  Bail out early if CURRENT_PC is reached.  Return the    address where the analysis stopped.     We handle these cases:     The startup sequence can be at the start of the function, or the    function can start with a branch to startup code at the end.     %ebp can be set up with either the 'enter' instruction, or "pushl    %ebp, movl %esp, %ebp" (`enter' is too slow to be useful, but was    once used in the System V compiler).     Local space is allocated just below the saved %ebp by either the    'enter' instruction, or by "subl $<size>, %esp".  'enter' has a 16    bit unsigned argument for space to allocate, and the 'addl'    instruction could have either a signed byte, or 32 bit immediate.     Next, the registers used by this function are pushed.  With the    System V compiler they will always be in the order: %edi, %esi,    %ebx (and sometimes a harmless bug causes it to also save but not    restore %eax); however, the code below is willing to see the pushes    in any order, and will handle up to 8 of them.      If the setup sequence is at the end of the function, then the next    instruction will be a branch back to the start.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_analyze_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|i386_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
name|pc
operator|=
name|i386_follow_jump
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|i386_analyze_struct_return
argument_list|(
name|pc
argument_list|,
name|current_pc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|pc
operator|=
name|i386_skip_probe
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|i386_analyze_frame_setup
argument_list|(
name|pc
argument_list|,
name|current_pc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
return|return
name|i386_analyze_register_saves
argument_list|(
name|pc
argument_list|,
name|current_pc
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return PC of first real instruction.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_skip_prologue
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|pic_pat
index|[
literal|6
index|]
init|=
block|{
literal|0xe8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* call 0x0 */
literal|0x5b
block|,
comment|/* popl %ebx */
block|}
decl_stmt|;
name|struct
name|i386_frame_cache
name|cache
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cache
operator|.
name|locals
operator|=
operator|-
literal|1
expr_stmt|;
name|pc
operator|=
name|i386_analyze_prologue
argument_list|(
name|start_pc
argument_list|,
literal|0xffffffff
argument_list|,
operator|&
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|.
name|locals
operator|<
literal|0
condition|)
return|return
name|start_pc
return|;
comment|/* Found valid frame setup.  */
comment|/* The native cc on SVR4 in -K PIC mode inserts the following code      to get the address of the global offset table (GOT) into register      %ebx:          call	0x0 	popl    %ebx         movl    %ebx,x(%ebp)    (optional)         addl    y,%ebx       This code is with the rest of the prologue (at the end of the      function), so we have to skip it to get to the first real      instruction at the start of the function.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pic_pat
index|[
name|i
index|]
operator|!=
name|op
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|6
condition|)
block|{
name|int
name|delta
init|=
literal|6
decl_stmt|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x89
condition|)
comment|/* movl %ebx, x(%ebp) */
block|{
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|delta
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x5d
condition|)
comment|/* One byte offset from %ebp.  */
name|delta
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x9d
condition|)
comment|/* Four byte offset from %ebp.  */
name|delta
operator|+=
literal|6
expr_stmt|;
else|else
comment|/* Unexpected instruction.  */
name|delta
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* addl y,%ebx */
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|op
operator|==
literal|0x81
operator|&&
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
name|delta
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
literal|0xc3
condition|)
empty_stmt|;
block|{
name|pc
operator|+=
name|delta
operator|+
literal|6
expr_stmt|;
block|}
block|}
return|return
name|i386_follow_jump
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is 64-bit safe.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|PC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|extract_typed_address
argument_list|(
name|buf
argument_list|,
name|builtin_type_void_func_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Normal frames.  */
end_comment

begin_function
specifier|static
name|struct
name|i386_frame_cache
modifier|*
name|i386_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|i386_alloc_frame_cache
argument_list|()
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
comment|/* In principle, for normal frames, %ebp holds the frame pointer,      which holds the base address for the current stack frame.      However, for functions that don't need it, the frame pointer is      optional.  For these "frameless" functions the frame pointer is      actually the frame pointer of the calling frame.  Signal      trampolines are just a special case of a "frameless" function.      They (usually) share their frame pointer with the frame that was      in progress when the signal occurred.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|I386_EBP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|base
operator|==
literal|0
condition|)
return|return
name|cache
return|;
comment|/* For normal frames, %eip is stored at 4(%ebp).  */
name|cache
operator|->
name|saved_regs
index|[
name|I386_EIP_REGNUM
index|]
operator|=
literal|4
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|pc
operator|!=
literal|0
condition|)
name|i386_analyze_prologue
argument_list|(
name|cache
operator|->
name|pc
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|locals
operator|<
literal|0
condition|)
block|{
comment|/* We didn't find a valid frame, which means that CACHE->base 	 currently holds the frame pointer for our calling frame.  If 	 we're at the start of a function, or somewhere half-way its 	 prologue, the function's frame probably hasn't been fully 	 setup yet.  Try to reconstruct the base address for the stack 	 frame by looking at the stack pointer.  For truly "frameless" 	 functions this might work too.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|I386_ESP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
operator|+
name|cache
operator|->
name|sp_offset
expr_stmt|;
block|}
comment|/* Now that we have the base address for the stack frame we can      calculate the value of %esp in the calling frame.  */
name|cache
operator|->
name|saved_sp
operator|=
name|cache
operator|->
name|base
operator|+
literal|8
expr_stmt|;
comment|/* Adjust all the saved registers such that they contain addresses      instead of offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_SAVED_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|+=
name|cache
operator|->
name|base
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
init|=
name|i386_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* This marks the outermost frame.  */
if|if
condition|(
name|cache
operator|->
name|base
operator|==
literal|0
condition|)
return|return;
comment|/* See the end of i386_push_dummy_call.  */
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
operator|+
literal|8
argument_list|,
name|cache
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
init|=
name|i386_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* The System V ABI says that:       "The flags register contains the system flags, such as the      direction flag and the carry flag.  The direction flag must be      set to the forward (that is, zero) direction before entry and      upon exit from a function.  Other user flags have no specified      role in the standard calling sequence and are not preserved."       To guarantee the "upon exit" part of that statement we fake a      saved flags register that has its direction flag cleared.       Note that GCC doesn't seem to rely on the fact that the direction      flag is cleared after a function return; it always explicitly      clears the flag before operations where it matters.       FIXME: kettenis/20030316: I'm not quite sure whether this is the      right thing to do.  The way we fake the flags register here makes      it impossible to change it.  */
if|if
condition|(
name|regnum
operator|==
name|I386_EFLAGS_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
name|ULONGEST
name|val
decl_stmt|;
comment|/* Clear the direction flag.  */
name|val
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|I386_EFLAGS_REGNUM
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|10
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|regnum
operator|==
name|I386_EIP_REGNUM
operator|&&
name|cache
operator|->
name|pc_in_eax
condition|)
block|{
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|I386_EAX_REGNUM
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regnum
operator|==
name|I386_ESP_REGNUM
operator|&&
name|cache
operator|->
name|saved_sp
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Store the value.  */
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|4
argument_list|,
name|cache
operator|->
name|saved_sp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|regnum
operator|<
name|I386_NUM_SAVED_REGS
operator|&&
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
operator|*
name|addrp
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|i386_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|i386_frame_this_id
block|,
name|i386_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|i386_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|i386_frame_unwind
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Signal trampolines.  */
end_comment

begin_function
specifier|static
name|struct
name|i386_frame_cache
modifier|*
name|i386_sigtramp_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|i386_alloc_frame_cache
argument_list|()
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|I386_ESP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
operator|-
literal|4
expr_stmt|;
name|addr
operator|=
name|tdep
operator|->
name|sigcontext_addr
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|sc_reg_offset
condition|)
block|{
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|sc_num_regs
operator|<=
name|I386_NUM_SAVED_REGS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tdep
operator|->
name|sc_num_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tdep
operator|->
name|sc_reg_offset
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
name|addr
operator|+
name|tdep
operator|->
name|sc_reg_offset
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|cache
operator|->
name|saved_regs
index|[
name|I386_EIP_REGNUM
index|]
operator|=
name|addr
operator|+
name|tdep
operator|->
name|sc_pc_offset
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|I386_ESP_REGNUM
index|]
operator|=
name|addr
operator|+
name|tdep
operator|->
name|sc_sp_offset
expr_stmt|;
block|}
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_sigtramp_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
init|=
name|i386_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* See the end of i386_push_dummy_call.  */
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
operator|+
literal|8
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_sigtramp_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
comment|/* Make sure we've initialized the cache.  */
name|i386_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
expr_stmt|;
name|i386_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|i386_sigtramp_frame_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|i386_sigtramp_frame_this_id
block|,
name|i386_sigtramp_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|i386_sigtramp_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* We shouldn't even bother to try if the OSABI didn't register      a sigcontext_addr handler.  */
if|if
condition|(
operator|!
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|sigcontext_addr
condition|)
return|return
name|NULL
return|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|i386_sigtramp_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|i386_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|i386_frame_cache
modifier|*
name|cache
init|=
name|i386_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|cache
operator|->
name|base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|i386_frame_base
init|=
block|{
operator|&
name|i386_frame_unwind
block|,
name|i386_frame_base_address
block|,
name|i386_frame_base_address
block|,
name|i386_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|frame_id
name|i386_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|I386_EBP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* See the end of i386_push_dummy_call.  */
return|return
name|frame_id_build
argument_list|(
name|fp
operator|+
literal|8
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Figure out where the longjmp will land.  Slurp the args out of the    stack.  We expect the first arg to be a pointer to the jmp_buf    structure from which we extract the address that we will land at.    This address is copied into PC.  This routine returns non-zero on    success.     This function is 64-bit safe.  */
end_comment

begin_function
specifier|static
name|int
name|i386_get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|,
name|jb_addr
decl_stmt|;
name|int
name|jb_pc_offset
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|jb_pc_offset
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_func_ptr
argument_list|)
decl_stmt|;
comment|/* If JB_PC_OFFSET is -1, we have no way to find out where the      longjmp will land.  */
if|if
condition|(
name|jb_pc_offset
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Don't use I386_ESP_REGNUM here, since this function is also used      for AMD64.  */
name|regcache_cooked_read
argument_list|(
name|current_regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|extract_typed_address
argument_list|(
name|buf
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
operator|+
name|len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|jb_addr
operator|=
name|extract_typed_address
argument_list|(
name|buf
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|jb_pc_offset
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_typed_address
argument_list|(
name|buf
argument_list|,
name|builtin_type_void_func_ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|i386_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Push arguments in reverse order.  */
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The System V ABI says that:  	 "An argument's size is increased, if necessary, to make it a 	 multiple of [32-bit] words.  This may require tail padding, 	 depending on the size of the argument."  	 This makes sure the stack says word-aligned.  */
name|sp
operator|-=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Push value address.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|sp
operator|-=
literal|4
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Store return address.  */
name|sp
operator|-=
literal|4
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Finally, update the stack pointer...  */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|I386_ESP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* ...and fake a frame pointer.  */
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|I386_EBP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* MarkK wrote: This "+ 8" is all over the place:      (i386_frame_this_id, i386_sigtramp_frame_this_id,      i386_unwind_dummy_id).  It's there, since all frame unwinders for      a given target have to agree (within a certain margin) on the      defenition of the stack address of a frame.  Otherwise      frame_id_inner() won't work correctly.  Since DWARF2/GCC uses the      stack address *before* the function call as a frame's CFA.  On      the i386, when %ebp is used as a frame pointer, the offset      between the contents %ebp and the CFA as defined by GCC.  */
return|return
name|sp
operator|+
literal|8
return|;
block|}
end_function

begin_comment
comment|/* These registers are used for returning integers (and on some    targets also for returning `struct' and `union' values when their    size and alignment match an integer type).  */
end_comment

begin_define
define|#
directive|define
name|LOW_RETURN_REGNUM
value|I386_EAX_REGNUM
end_define

begin_comment
comment|/* %eax */
end_comment

begin_define
define|#
directive|define
name|HIGH_RETURN_REGNUM
value|I386_EDX_REGNUM
end_define

begin_comment
comment|/* %edx */
end_comment

begin_comment
comment|/* Read, for architecture GDBARCH, a function return value of TYPE    from REGCACHE, and copy that into VALBUF.  */
end_comment

begin_function
specifier|static
name|void
name|i386_extract_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|I386_MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|tdep
operator|->
name|st0_regnum
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot find floating-point return value."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|valbuf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Floating-point return values can be found in %st(0).  Convert 	 its contents to the desired type.  This is probably not 	 exactly how it would happen on the target itself, but it is 	 the best we can do.  */
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|I386_ST0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|buf
argument_list|,
name|builtin_type_i387_ext
argument_list|,
name|valbuf
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|low_size
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|LOW_RETURN_REGNUM
argument_list|)
decl_stmt|;
name|int
name|high_size
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|HIGH_RETURN_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|low_size
condition|)
block|{
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|LOW_RETURN_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
operator|(
name|low_size
operator|+
name|high_size
operator|)
condition|)
block|{
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|LOW_RETURN_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|,
name|low_size
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|HIGH_RETURN_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valbuf
operator|+
name|low_size
argument_list|,
name|buf
argument_list|,
name|len
operator|-
name|low_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot extract return value of %d bytes long."
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write, for architecture GDBARCH, a function return value of TYPE    from VALBUF into REGCACHE.  */
end_comment

begin_function
specifier|static
name|void
name|i386_store_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
specifier|const
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Define I387_ST0_REGNUM such that we use the proper definitions      for the architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|I386_ST0_REGNUM
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|ULONGEST
name|fstat
decl_stmt|;
name|char
name|buf
index|[
name|I386_MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|tdep
operator|->
name|st0_regnum
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot set floating-point return value."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Returning floating-point values is a bit tricky.  Apart from          storing the return value in %st(0), we have to simulate the          state of the FPU at function return point.  */
comment|/* Convert the value found in VALBUF to the extended 	 floating-point format used by the FPU.  This is probably 	 not exactly how it would happen on the target itself, but 	 it is the best we can do.  */
name|convert_typed_floating
argument_list|(
name|valbuf
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|builtin_type_i387_ext
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|I386_ST0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Set the top of the floating-point register stack to 7.  The          actual value doesn't really matter, but 7 is what a normal          function return would end up with if the program started out          with a freshly initialized FPU.  */
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|,
operator|&
name|fstat
argument_list|)
expr_stmt|;
name|fstat
operator||=
operator|(
literal|7
operator|<<
literal|11
operator|)
expr_stmt|;
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* Mark %st(1) through %st(7) as empty.  Since we set the top of          the floating-point register stack to 7, the appropriate value          for the tag word is 0x3fff.  */
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FTAG_REGNUM
argument_list|,
literal|0x3fff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|low_size
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|LOW_RETURN_REGNUM
argument_list|)
decl_stmt|;
name|int
name|high_size
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|HIGH_RETURN_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|low_size
condition|)
name|regcache_raw_write_part
argument_list|(
name|regcache
argument_list|,
name|LOW_RETURN_REGNUM
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|<=
operator|(
name|low_size
operator|+
name|high_size
operator|)
condition|)
block|{
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|LOW_RETURN_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_raw_write_part
argument_list|(
name|regcache
argument_list|,
name|HIGH_RETURN_REGNUM
argument_list|,
literal|0
argument_list|,
name|len
operator|-
name|low_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|valbuf
operator|+
name|low_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot store return value of %d bytes long."
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the variable that is set with "set struct-convention", and    its legitimate values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|default_struct_convention
index|[]
init|=
literal|"default"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcc_struct_convention
index|[]
init|=
literal|"pcc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|reg_struct_convention
index|[]
init|=
literal|"reg"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|valid_conventions
index|[]
init|=
block|{
name|default_struct_convention
block|,
name|pcc_struct_convention
block|,
name|reg_struct_convention
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|struct_convention
init|=
name|default_struct_convention
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return non-zero if TYPE, which is assumed to be a structure or    union type, should be returned in registers for architecture    GDBARCH.  */
end_comment

begin_function
specifier|static
name|int
name|i386_reg_struct_return_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_convention
operator|==
name|pcc_struct_convention
operator|||
operator|(
name|struct_convention
operator|==
name|default_struct_convention
operator|&&
name|tdep
operator|->
name|struct_return
operator|==
name|pcc_struct_return
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|len
operator|==
literal|1
operator|||
name|len
operator|==
literal|2
operator|||
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine, for architecture GDBARCH, how a return value of TYPE    should be returned.  If it is supposed to be returned in registers,    and READBUF is non-zero, read the appropriate value from REGCACHE,    and copy it into READBUF.  If WRITEBUF is non-zero, write the value    from WRITEBUF into REGCACHE.  */
end_comment

begin_function
specifier|static
name|enum
name|return_value_convention
name|i386_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
operator|!
name|i386_reg_struct_return_p
argument_list|(
name|gdbarch
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
comment|/* This special case is for structures consisting of a single      `float' or `double' member.  These structures are returned in      %st(0).  For these structures, we call ourselves recursively,      changing TYPE into the type of the first member of the structure.      Since that should work for all structures that have only one      member, we don't bother to check the member's type here.  */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i386_return_value
argument_list|(
name|gdbarch
argument_list|,
name|type
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|)
return|;
block|}
if|if
condition|(
name|readbuf
condition|)
name|i386_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|type
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|writebuf
condition|)
name|i386_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|type
argument_list|,
name|regcache
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REGNUM.  Perhaps %esi and %edi should go here, but    potentially they could be used for things other than address.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|i386_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|==
name|I386_EIP_REGNUM
operator|||
name|regnum
operator|==
name|I386_EBP_REGNUM
operator|||
name|regnum
operator|==
name|I386_ESP_REGNUM
condition|)
return|return
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
return|;
if|if
condition|(
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
condition|)
return|return
name|builtin_type_i387_ext
return|;
if|if
condition|(
name|i386_sse_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
condition|)
return|return
name|builtin_type_vec128i
return|;
if|if
condition|(
name|i386_mmx_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
condition|)
return|return
name|builtin_type_vec64i
return|;
return|return
name|builtin_type_int
return|;
block|}
end_function

begin_comment
comment|/* Map a cooked register onto a raw register or memory.  For the i386,    the MMX registers need to be mapped onto floating point registers.  */
end_comment

begin_function
specifier|static
name|int
name|i386_mmx_regnum_to_fp_regnum
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|get_regcache_arch
argument_list|(
name|regcache
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|mmxreg
decl_stmt|,
name|fpreg
decl_stmt|;
name|ULONGEST
name|fstat
decl_stmt|;
name|int
name|tos
decl_stmt|;
comment|/* Define I387_ST0_REGNUM such that we use the proper definitions      for REGCACHE's architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
name|mmxreg
operator|=
name|regnum
operator|-
name|tdep
operator|->
name|mm0_regnum
expr_stmt|;
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|,
operator|&
name|fstat
argument_list|)
expr_stmt|;
name|tos
operator|=
operator|(
name|fstat
operator|>>
literal|11
operator|)
operator|&
literal|0x7
expr_stmt|;
name|fpreg
operator|=
operator|(
name|mmxreg
operator|+
name|tos
operator|)
operator|%
literal|8
expr_stmt|;
return|return
operator|(
name|I387_ST0_REGNUM
operator|+
name|fpreg
operator|)
return|;
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

begin_function
specifier|static
name|void
name|i386_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|i386_mmx_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
condition|)
block|{
name|char
name|mmx_buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|fpnum
init|=
name|i386_mmx_regnum_to_fp_regnum
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
comment|/* Extract (always little endian).  */
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|fpnum
argument_list|,
name|mmx_buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|mmx_buf
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|i386_mmx_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
condition|)
block|{
name|char
name|mmx_buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|fpnum
init|=
name|i386_mmx_regnum_to_fp_regnum
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
comment|/* Read ...  */
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|fpnum
argument_list|,
name|mmx_buf
argument_list|)
expr_stmt|;
comment|/* ... Modify ... (always little endian).  */
name|memcpy
argument_list|(
name|mmx_buf
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... Write.  */
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|fpnum
argument_list|,
name|mmx_buf
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register number of the register allocated by GCC after    REGNUM, or -1 if there is no such register.  */
end_comment

begin_function
specifier|static
name|int
name|i386_next_regnum
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* GCC allocates the registers in the order:       %eax, %edx, %ecx, %ebx, %esi, %edi, %ebp, %esp, ...       Since storing a variable in %esp doesn't make any sense we return      -1 for %ebp and for %esp itself.  */
specifier|static
name|int
name|next_regnum
index|[]
init|=
block|{
name|I386_EDX_REGNUM
block|,
comment|/* Slot for %eax.  */
name|I386_EBX_REGNUM
block|,
comment|/* Slot for %ecx.  */
name|I386_ECX_REGNUM
block|,
comment|/* Slot for %edx.  */
name|I386_ESI_REGNUM
block|,
comment|/* Slot for %ebx.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Slots for %esp and %ebp.  */
name|I386_EDI_REGNUM
block|,
comment|/* Slot for %esi.  */
name|I386_EBP_REGNUM
comment|/* Slot for %edi.  */
block|}
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
sizeof|sizeof
argument_list|(
name|next_regnum
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|next_regnum
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|next_regnum
index|[
name|regnum
index|]
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if a value of type TYPE stored in register REGNUM    needs any special handling.  */
end_comment

begin_function
specifier|static
name|int
name|i386_convert_register_p
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Values may be spread across multiple registers.  Most debugging      formats aren't expressive enough to specify the locations, so      some heuristics is involved.  Right now we only handle types that      have a length that is a multiple of the word size, since GCC      doesn't seem to put any other types into registers.  */
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|len
operator|%
literal|4
operator|==
literal|0
condition|)
block|{
name|int
name|last_regnum
init|=
name|regnum
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|4
condition|)
block|{
name|last_regnum
operator|=
name|i386_next_regnum
argument_list|(
name|last_regnum
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|last_regnum
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
block|}
return|return
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a value of type TYPE from register REGNUM in frame FRAME, and    return its contents in TO.  */
end_comment

begin_function
specifier|static
name|void
name|i386_register_to_value
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|to
decl_stmt|;
comment|/* FIXME: kettenis/20030609: What should we do if REGNUM isn't      available in FRAME (i.e. if it wasn't saved)?  */
if|if
condition|(
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|i387_register_to_value
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|type
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read a value spread accross multiple registers.  */
name|gdb_assert
argument_list|(
name|len
operator|>
literal|4
operator|&&
name|len
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|i386_next_regnum
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the contents FROM of a value of type TYPE into register    REGNUM in frame FRAME.  */
end_comment

begin_function
specifier|static
name|void
name|i386_value_to_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|from
decl_stmt|;
if|if
condition|(
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|i387_value_to_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|type
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write a value spread accross multiple registers.  */
name|gdb_assert
argument_list|(
name|len
operator|>
literal|4
operator|&&
name|len
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|i386_next_regnum
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Supply register REGNUM from the general-purpose register set REGSET    to register cache REGCACHE.  If REGNUM is -1, do this for all    registers in REGSET.  */
end_comment

begin_function
name|void
name|i386_supply_gregset
parameter_list|(
specifier|const
name|struct
name|regset
modifier|*
name|regset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|regset
operator|->
name|descr
decl_stmt|;
specifier|const
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
name|tdep
operator|->
name|sizeof_gregset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tdep
operator|->
name|gregset_num_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
operator|)
operator|&&
name|tdep
operator|->
name|gregset_reg_offset
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|tdep
operator|->
name|gregset_reg_offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Supply register REGNUM from the floating-point register set REGSET    to register cache REGCACHE.  If REGNUM is -1, do this for all    registers in REGSET.  */
end_comment

begin_function
specifier|static
name|void
name|i386_supply_fpregset
parameter_list|(
specifier|const
name|struct
name|regset
modifier|*
name|regset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fpregs
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|regset
operator|->
name|descr
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|I387_SIZEOF_FXSAVE
condition|)
block|{
name|i387_supply_fxsave
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdb_assert
argument_list|(
name|len
operator|==
name|tdep
operator|->
name|sizeof_fpregset
argument_list|)
expr_stmt|;
name|i387_supply_fsave
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the appropriate register set for the core section identified    by SECT_NAME and SECT_SIZE.  */
end_comment

begin_function
specifier|const
name|struct
name|regset
modifier|*
name|i386_regset_from_core_section
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|size_t
name|sect_size
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|==
name|tdep
operator|->
name|sizeof_gregset
condition|)
block|{
if|if
condition|(
name|tdep
operator|->
name|gregset
operator|==
name|NULL
condition|)
block|{
name|tdep
operator|->
name|gregset
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|regset
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|gregset
operator|->
name|descr
operator|=
name|tdep
expr_stmt|;
name|tdep
operator|->
name|gregset
operator|->
name|supply_regset
operator|=
name|i386_supply_gregset
expr_stmt|;
block|}
return|return
name|tdep
operator|->
name|gregset
return|;
block|}
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg2"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|==
name|tdep
operator|->
name|sizeof_fpregset
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg-xfp"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|==
name|I387_SIZEOF_FXSAVE
operator|)
condition|)
block|{
if|if
condition|(
name|tdep
operator|->
name|fpregset
operator|==
name|NULL
condition|)
block|{
name|tdep
operator|->
name|fpregset
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|regset
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|->
name|descr
operator|=
name|tdep
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|->
name|supply_regset
operator|=
name|i386_supply_fpregset
expr_stmt|;
block|}
return|return
name|tdep
operator|->
name|fpregset
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
end_ifdef

begin_comment
comment|/* SunPRO encodes the static variables.  This is not related to C++    mangling, it is done for C too.  */
end_comment

begin_function
name|char
modifier|*
name|sunpro_static_transform_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|IS_STATIC_TRANSFORM_NAME
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* For file-local statics there will be a period, a bunch of          junk (the contents of which match a string given in the          N_OPT), a period and the name.  For function-local statics          there will be a bunch of junk (which seems to change the          second character from 'A' to 'B'), a period, the name of the          function, and the name.  So just skip everything before the          last period.  */
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_TRANSFORM_NAME */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Stuff for WIN32 PE style DLL's but is pretty generic really.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_pe_skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|&&
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
operator|==
literal|0x25ff
condition|)
comment|/* jmp *(dest) */
block|{
name|unsigned
name|long
name|indirect
init|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|indsym
init|=
name|indirect
condition|?
name|lookup_minimal_symbol_by_pc
argument_list|(
name|indirect
argument_list|)
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|indsym
condition|?
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|indsym
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|symname
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"__imp_"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"_imp_"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|name
condition|?
literal|1
else|:
name|read_memory_unsigned_integer
argument_list|(
name|indirect
argument_list|,
literal|4
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Not a trampoline.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if PC and NAME show that we are in a signal    trampoline.  */
end_comment

begin_function
specifier|static
name|int
name|i386_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|name
operator|&&
name|strcmp
argument_list|(
literal|"_sigtramp"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have two flavours of disassembly.  The machinery on this page    deals with switching between those.  */
end_comment

begin_function
specifier|static
name|int
name|i386_print_insn
parameter_list|(
name|bfd_vma
name|pc
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|disassembly_flavor
operator|==
name|att_flavor
operator|||
name|disassembly_flavor
operator|==
name|intel_flavor
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/20020915: Until disassembler_options is properly      constified, cast to prevent a compiler warning.  */
name|info
operator|->
name|disassembler_options
operator|=
operator|(
name|char
operator|*
operator|)
name|disassembly_flavor
expr_stmt|;
name|info
operator|->
name|mach
operator|=
name|gdbarch_bfd_arch_info
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|mach
expr_stmt|;
return|return
name|print_insn_i386
argument_list|(
name|pc
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* There are a few i386 architecture variants that differ only    slightly from the generic i386 target.  For now, we don't give them    their own source file, but include them here.  As a consequence,    they'll always be included.  */
end_comment

begin_comment
comment|/* System V Release 4 (SVR4).  */
end_comment

begin_function
specifier|static
name|int
name|i386_svr4_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* UnixWare uses _sigacthandler.  The origin of the other symbols is      currently unknown.  */
return|return
operator|(
name|name
operator|&&
operator|(
name|strcmp
argument_list|(
literal|"_sigreturn"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"_sigacthandler"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"sigvechandler"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming NEXT_FRAME is for a frame following a SVR4 sigtramp    routine, return the address of the associated sigcontext (ucontext)    structure.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_svr4_sigcontext_addr
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|I386_ESP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|read_memory_unsigned_integer
argument_list|(
name|sp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DJGPP.  */
end_comment

begin_function
specifier|static
name|int
name|i386_go32_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* DJGPP doesn't have any special frames for signal handlers.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic ELF.  */
end_comment

begin_function
name|void
name|i386_elf_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* We typically use stabs-in-ELF with the DWARF register numbering.  */
name|set_gdbarch_stab_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|i386_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* System V Release 4 (SVR4).  */
end_comment

begin_function
name|void
name|i386_svr4_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* System V Release 4 uses ELF.  */
name|i386_elf_init_abi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
comment|/* System V Release 4 has shared libraries.  */
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|in_plt_section
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|find_solib_trampoline_target
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|i386_svr4_pc_in_sigtramp
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|sigcontext_addr
operator|=
name|i386_svr4_sigcontext_addr
expr_stmt|;
name|tdep
operator|->
name|sc_pc_offset
operator|=
literal|36
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|sc_sp_offset
operator|=
literal|36
operator|+
literal|17
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|jb_pc_offset
operator|=
literal|20
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DJGPP.  */
end_comment

begin_function
specifier|static
name|void
name|i386_go32_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|i386_go32_pc_in_sigtramp
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|jb_pc_offset
operator|=
literal|36
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NetWare.  */
end_comment

begin_function
specifier|static
name|void
name|i386_nw_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|tdep
operator|->
name|jb_pc_offset
operator|=
literal|24
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* i386 register groups.  In addition to the normal groups, add "mmx"    and "sse".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reggroup
modifier|*
name|i386_sse_reggroup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|reggroup
modifier|*
name|i386_mmx_reggroup
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|i386_init_reggroups
parameter_list|(
name|void
parameter_list|)
block|{
name|i386_sse_reggroup
operator|=
name|reggroup_new
argument_list|(
literal|"sse"
argument_list|,
name|USER_REGGROUP
argument_list|)
expr_stmt|;
name|i386_mmx_reggroup
operator|=
name|reggroup_new
argument_list|(
literal|"mmx"
argument_list|,
name|USER_REGGROUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_add_reggroups
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|i386_sse_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|i386_mmx_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|general_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|float_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|all_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|save_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|restore_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|vector_reggroup
argument_list|)
expr_stmt|;
name|reggroup_add
argument_list|(
name|gdbarch
argument_list|,
name|system_reggroup
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i386_register_reggroup_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|reggroup
modifier|*
name|group
parameter_list|)
block|{
name|int
name|sse_regnum_p
init|=
operator|(
name|i386_sse_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
operator|||
name|i386_mxcsr_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
operator|)
decl_stmt|;
name|int
name|fp_regnum_p
init|=
operator|(
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
operator|||
name|i386_fpc_regnum_p
argument_list|(
name|regnum
argument_list|)
operator|)
decl_stmt|;
name|int
name|mmx_regnum_p
init|=
operator|(
name|i386_mmx_regnum_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|group
operator|==
name|i386_mmx_reggroup
condition|)
return|return
name|mmx_regnum_p
return|;
if|if
condition|(
name|group
operator|==
name|i386_sse_reggroup
condition|)
return|return
name|sse_regnum_p
return|;
if|if
condition|(
name|group
operator|==
name|vector_reggroup
condition|)
return|return
operator|(
name|mmx_regnum_p
operator|||
name|sse_regnum_p
operator|)
return|;
if|if
condition|(
name|group
operator|==
name|float_reggroup
condition|)
return|return
name|fp_regnum_p
return|;
if|if
condition|(
name|group
operator|==
name|general_reggroup
condition|)
return|return
operator|(
operator|!
name|fp_regnum_p
operator|&&
operator|!
name|mmx_regnum_p
operator|&&
operator|!
name|sse_regnum_p
operator|)
return|;
return|return
name|default_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|group
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the ARGIth function argument for the current function.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_fetch_pointer_argument
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|argi
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CORE_ADDR
name|sp
init|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I386_ESP_REGNUM
argument_list|)
decl_stmt|;
return|return
name|read_memory_unsigned_integer
argument_list|(
name|sp
operator|+
operator|(
literal|4
operator|*
operator|(
name|argi
operator|+
literal|1
operator|)
operator|)
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|i386_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
comment|/* If there is already a candidate, use it.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
comment|/* Allocate space for the new architecture.  */
name|tdep
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
comment|/* General-purpose registers.  */
name|tdep
operator|->
name|gregset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|gregset_reg_offset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|gregset_num_regs
operator|=
name|I386_NUM_GREGS
expr_stmt|;
name|tdep
operator|->
name|sizeof_gregset
operator|=
literal|0
expr_stmt|;
comment|/* Floating-point registers.  */
name|tdep
operator|->
name|fpregset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sizeof_fpregset
operator|=
name|I387_SIZEOF_FSAVE
expr_stmt|;
comment|/* The default settings include the FPU registers, the MMX registers      and the SSE registers.  This can be overidden for a specific ABI      by adjusting the members `st0_regnum', `mm0_regnum' and      `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers      will show up in the output of "info all-registers".  Ideally we      should try to autodetect whether they are available, such that we      can prevent "info all-registers" from displaying registers that      aren't available.       NOTE: kevinb/2003-07-13: ... if it's a choice between printing      [the SSE registers] always (even when they don't exist) or never      showing them to the user (even when they do exist), I prefer the      former over the latter.  */
name|tdep
operator|->
name|st0_regnum
operator|=
name|I386_ST0_REGNUM
expr_stmt|;
comment|/* The MMX registers are implemented as pseudo-registers.  Put off      caclulating the register number for %mm0 until we know the number      of raw registers.  */
name|tdep
operator|->
name|mm0_regnum
operator|=
literal|0
expr_stmt|;
comment|/* I386_NUM_XREGS includes %mxcsr, so substract one.  */
name|tdep
operator|->
name|num_xmm_regs
operator|=
name|I386_NUM_XREGS
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|jb_pc_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|struct_return
operator|=
name|pcc_struct_return
expr_stmt|;
name|tdep
operator|->
name|sigtramp_start
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|sigtramp_end
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|sigcontext_addr
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sc_reg_offset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sc_pc_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|sc_sp_offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The format used for `long double' on almost all i386 targets is      the i387 extended floating-point format.  In fact, of all targets      in the GCC 2.95 tree, only OSF/1 does it different, and insists      on having a `long double' that's not `long' at all.  */
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_i387_ext
argument_list|)
expr_stmt|;
comment|/* Although the i387 extended floating-point has only 80 significant      bits, a `long double' actually takes up 96, probably to enforce      alignment.  */
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|96
argument_list|)
expr_stmt|;
comment|/* The default ABI includes general-purpose registers,       floating-point registers, and the SSE registers.  */
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|I386_SSE_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|i386_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|i386_register_type
argument_list|)
expr_stmt|;
comment|/* Register numbers of various important registers.  */
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|I386_ESP_REGNUM
argument_list|)
expr_stmt|;
comment|/* %esp */
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|I386_EIP_REGNUM
argument_list|)
expr_stmt|;
comment|/* %eip */
name|set_gdbarch_ps_regnum
argument_list|(
name|gdbarch
argument_list|,
name|I386_EFLAGS_REGNUM
argument_list|)
expr_stmt|;
comment|/* %eflags */
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|I386_ST0_REGNUM
argument_list|)
expr_stmt|;
comment|/* %st(0) */
comment|/* Use the "default" register numbering scheme for stabs and COFF.  */
name|set_gdbarch_stab_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|i386_stab_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_sdb_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|i386_stab_reg_to_regnum
argument_list|)
expr_stmt|;
comment|/* Use the DWARF register numbering scheme for DWARF and DWARF 2.  */
name|set_gdbarch_dwarf_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|i386_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf2_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|i386_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
comment|/* We don't define ECOFF_REG_TO_REGNUM, since ECOFF doesn't seem to      be in use on any of the supported i386 targets.  */
name|set_gdbarch_print_float_info
argument_list|(
name|gdbarch
argument_list|,
name|i387_print_float_info
argument_list|)
expr_stmt|;
name|set_gdbarch_get_longjmp_target
argument_list|(
name|gdbarch
argument_list|,
name|i386_get_longjmp_target
argument_list|)
expr_stmt|;
comment|/* Call dummy code.  */
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|i386_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_register_p
argument_list|(
name|gdbarch
argument_list|,
name|i386_convert_register_p
argument_list|)
expr_stmt|;
name|set_gdbarch_register_to_value
argument_list|(
name|gdbarch
argument_list|,
name|i386_register_to_value
argument_list|)
expr_stmt|;
name|set_gdbarch_value_to_register
argument_list|(
name|gdbarch
argument_list|,
name|i386_value_to_register
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|i386_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|i386_skip_prologue
argument_list|)
expr_stmt|;
comment|/* Stack grows downward.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|i386_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|i386_pc_in_sigtramp
argument_list|)
expr_stmt|;
comment|/* Wire in the MMX registers.  */
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|i386_num_mmx_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|i386_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|i386_pseudo_register_write
argument_list|)
expr_stmt|;
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|i386_print_insn
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|i386_unwind_dummy_id
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|i386_unwind_pc
argument_list|)
expr_stmt|;
comment|/* Add the i386 register groups.  */
name|i386_add_reggroups
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
name|set_gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|i386_register_reggroup_p
argument_list|)
expr_stmt|;
comment|/* Helper for function argument information.  */
name|set_gdbarch_fetch_pointer_argument
argument_list|(
name|gdbarch
argument_list|,
name|i386_fetch_pointer_argument
argument_list|)
expr_stmt|;
comment|/* Hook in the DWARF CFI frame unwinder.  */
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|i386_frame_base
argument_list|)
expr_stmt|;
comment|/* Hook in ABI-specific overrides, if they have been registered.  */
name|gdbarch_init_osabi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|i386_sigtramp_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|i386_frame_sniffer
argument_list|)
expr_stmt|;
comment|/* If we have a register mapping, enable the generic core file      support, unless it has already been enabled.  */
if|if
condition|(
name|tdep
operator|->
name|gregset_reg_offset
operator|&&
operator|!
name|gdbarch_regset_from_core_section_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
name|set_gdbarch_regset_from_core_section
argument_list|(
name|gdbarch
argument_list|,
name|i386_regset_from_core_section
argument_list|)
expr_stmt|;
comment|/* Unless support for MMX has been disabled, make %mm0 the first      pseudo-register.  */
if|if
condition|(
name|tdep
operator|->
name|mm0_regnum
operator|==
literal|0
condition|)
name|tdep
operator|->
name|mm0_regnum
operator|=
name|gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|gdb_osabi
name|i386_coff_osabi_sniffer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"coff-go32-exe"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"coff-go32"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|GDB_OSABI_GO32
return|;
return|return
name|GDB_OSABI_UNKNOWN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|gdb_osabi
name|i386_nlm_osabi_sniffer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
name|GDB_OSABI_NETWARE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide a prototype to silence -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_i386_tdep
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_i386_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|register_gdbarch_init
argument_list|(
name|bfd_arch_i386
argument_list|,
name|i386_gdbarch_init
argument_list|)
expr_stmt|;
comment|/* Add the variable that controls the disassembly flavor.  */
block|{
name|struct
name|cmd_list_element
modifier|*
name|new_cmd
decl_stmt|;
name|new_cmd
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembly-flavor"
argument_list|,
name|no_class
argument_list|,
name|valid_flavors
argument_list|,
operator|&
name|disassembly_flavor
argument_list|,
literal|"\ Set the disassembly flavor, the valid values are \"att\" and \"intel\", \ and the default value is \"att\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_cmd
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
comment|/* Add the variable that controls the convention for returning      structs.  */
block|{
name|struct
name|cmd_list_element
modifier|*
name|new_cmd
decl_stmt|;
name|new_cmd
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"struct-convention"
argument_list|,
name|no_class
argument_list|,
name|valid_conventions
argument_list|,
operator|&
name|struct_convention
argument_list|,
literal|"\ Set the convention for returning small structs, valid values \ are \"default\", \"pcc\" and \"reg\", and the default value is \"default\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_cmd
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
name|gdbarch_register_osabi_sniffer
argument_list|(
name|bfd_arch_i386
argument_list|,
name|bfd_target_coff_flavour
argument_list|,
name|i386_coff_osabi_sniffer
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi_sniffer
argument_list|(
name|bfd_arch_i386
argument_list|,
name|bfd_target_nlm_flavour
argument_list|,
name|i386_nlm_osabi_sniffer
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_SVR4
argument_list|,
name|i386_svr4_init_abi
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_GO32
argument_list|,
name|i386_go32_init_abi
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_NETWARE
argument_list|,
name|i386_nw_init_abi
argument_list|)
expr_stmt|;
comment|/* Initialize the i386 specific register groups.  */
name|i386_init_reggroups
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

