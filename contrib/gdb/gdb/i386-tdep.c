begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 386 target-dependent stuff.    Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_undef
undef|#
directive|undef
name|XMALLOC
end_undef

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|((TYPE*) xmalloc (sizeof (TYPE)))
end_define

begin_comment
comment|/* Names of the registers.  The first 10 registers match the register    numbering scheme used by GCC for stabs and DWARF.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|i386_register_names
index|[]
init|=
block|{
literal|"eax"
block|,
literal|"ecx"
block|,
literal|"edx"
block|,
literal|"ebx"
block|,
literal|"esp"
block|,
literal|"ebp"
block|,
literal|"esi"
block|,
literal|"edi"
block|,
literal|"eip"
block|,
literal|"eflags"
block|,
literal|"cs"
block|,
literal|"ss"
block|,
literal|"ds"
block|,
literal|"es"
block|,
literal|"fs"
block|,
literal|"gs"
block|,
literal|"st0"
block|,
literal|"st1"
block|,
literal|"st2"
block|,
literal|"st3"
block|,
literal|"st4"
block|,
literal|"st5"
block|,
literal|"st6"
block|,
literal|"st7"
block|,
literal|"fctrl"
block|,
literal|"fstat"
block|,
literal|"ftag"
block|,
literal|"fiseg"
block|,
literal|"fioff"
block|,
literal|"foseg"
block|,
literal|"fooff"
block|,
literal|"fop"
block|,
literal|"xmm0"
block|,
literal|"xmm1"
block|,
literal|"xmm2"
block|,
literal|"xmm3"
block|,
literal|"xmm4"
block|,
literal|"xmm5"
block|,
literal|"xmm6"
block|,
literal|"xmm7"
block|,
literal|"mxcsr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i386_register_offset[i] is the offset into the register file of the    start of register number i.  We initialize this from    i386_register_size.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i386_register_offset
index|[
name|MAX_NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i386_register_size[i] is the number of bytes of storage in GDB's    register array occupied by register i.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i386_register_size
index|[
name|MAX_NUM_REGS
index|]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the name of register REG.  */
end_comment

begin_function
name|char
modifier|*
name|i386_register_name
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|reg
operator|>=
sizeof|sizeof
argument_list|(
name|i386_register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|i386_register_names
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|i386_register_names
index|[
name|reg
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the offset into the register array of the start of register    number REG.  */
end_comment

begin_function
name|int
name|i386_register_byte
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
name|i386_register_offset
index|[
name|reg
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes of storage in GDB's register array    occupied by register REG.  */
end_comment

begin_function
name|int
name|i386_register_raw_size
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
name|i386_register_size
index|[
name|reg
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the size in bytes of the virtual type of register REG.  */
end_comment

begin_function
name|int
name|i386_register_virtual_size
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
name|TYPE_LENGTH
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert stabs register number REG to the appropriate register    number used by GDB.  */
end_comment

begin_function
name|int
name|i386_stab_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* This implements what GCC calls the "default" register map.  */
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|7
condition|)
block|{
comment|/* General registers.  */
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|12
operator|&&
name|reg
operator|<=
literal|19
condition|)
block|{
comment|/* Floating-point registers.  */
return|return
name|reg
operator|-
literal|12
operator|+
name|FP0_REGNUM
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|21
operator|&&
name|reg
operator|<=
literal|28
condition|)
block|{
comment|/* SSE registers.  */
return|return
name|reg
operator|-
literal|21
operator|+
name|XMM0_REGNUM
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|29
operator|&&
name|reg
operator|<=
literal|36
condition|)
block|{
comment|/* MMX registers.  */
comment|/* FIXME: kettenis/2001-07-28: Should we have the MMX registers          as pseudo-registers?  */
return|return
name|reg
operator|-
literal|29
operator|+
name|FP0_REGNUM
return|;
block|}
comment|/* This will hopefully provoke a warning.  */
return|return
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Convert Dwarf register number REG to the appropriate register    number used by GDB.  */
end_comment

begin_function
name|int
name|i386_dwarf_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* The DWARF register numbering includes %eip and %eflags, and      numbers the floating point registers differently.  */
if|if
condition|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<=
literal|9
condition|)
block|{
comment|/* General registers.  */
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|11
operator|&&
name|reg
operator|<=
literal|18
condition|)
block|{
comment|/* Floating-point registers.  */
return|return
name|reg
operator|-
literal|11
operator|+
name|FP0_REGNUM
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
literal|21
condition|)
block|{
comment|/* The SSE and MMX registers have identical numbers as in stabs.  */
return|return
name|i386_stab_reg_to_regnum
argument_list|(
name|reg
argument_list|)
return|;
block|}
comment|/* This will hopefully provoke a warning.  */
return|return
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the variable that is set with "set disassembly-flavor", and    its legitimate values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|att_flavor
index|[]
init|=
literal|"att"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|intel_flavor
index|[]
init|=
literal|"intel"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|valid_flavors
index|[]
init|=
block|{
name|att_flavor
block|,
name|intel_flavor
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|disassembly_flavor
init|=
name|att_flavor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stdio style buffering was used to minimize calls to ptrace, but    this buffering did not take into account that the code section    being accessed may not be an even number of buffers long (even if    the buffer is only sizeof(int) long).  In cases where the code    section size happened to be a non-integral number of buffers long,    attempting to read the last buffer would fail.  Simply using    target_read_memory and ignoring errors, rather than read_memory, is    not the correct solution, since legitimate access errors would then    be totally ignored.  To properly handle this situation and continue    to use buffering would require that this code be able to determine    the minimum code section size granularity (not the alignment of the    section itself, since the actual failing case that pointed out this    problem had a section alignment of 4 but was not a multiple of 4    bytes long), on a target by target basis, and then adjust it's    buffer size accordingly.  This is messy, but potentially feasible.    It probably needs the bfd library's help and support.  For now, the    buffer size is set to 1.  (FIXME -fnf) */
end_comment

begin_define
define|#
directive|define
name|CODESTREAM_BUFSIZ
value|1
end_define

begin_comment
comment|/* Was sizeof(int), see note above.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|codestream_buf
index|[
name|CODESTREAM_BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codestream_tell
parameter_list|()
value|(codestream_addr + codestream_off)
end_define

begin_define
define|#
directive|define
name|codestream_peek
parameter_list|()
define|\
value|(codestream_cnt == 0 ? \    codestream_fill(1) : codestream_buf[codestream_off])
end_define

begin_define
define|#
directive|define
name|codestream_get
parameter_list|()
define|\
value|(codestream_cnt-- == 0 ? \    codestream_fill(0) : codestream_buf[codestream_off++])
end_define

begin_function
specifier|static
name|unsigned
name|char
name|codestream_fill
parameter_list|(
name|int
name|peek_flag
parameter_list|)
block|{
name|codestream_addr
operator|=
name|codestream_next_addr
expr_stmt|;
name|codestream_next_addr
operator|+=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_off
operator|=
literal|0
expr_stmt|;
name|codestream_cnt
operator|=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|read_memory
argument_list|(
name|codestream_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|codestream_buf
argument_list|,
name|CODESTREAM_BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_flag
condition|)
return|return
operator|(
name|codestream_peek
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_seek
parameter_list|(
name|CORE_ADDR
name|place
parameter_list|)
block|{
name|codestream_next_addr
operator|=
name|place
operator|/
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_next_addr
operator|*=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_cnt
operator|=
literal|0
expr_stmt|;
name|codestream_fill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|codestream_tell
argument_list|()
operator|!=
name|place
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_read
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If the next instruction is a jump, move to its target.  */
end_comment

begin_function
specifier|static
name|void
name|i386_follow_jump
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|int
name|data16
decl_stmt|;
name|CORE_ADDR
name|pos
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|codestream_peek
argument_list|()
operator|==
literal|0x66
condition|)
block|{
name|codestream_get
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0xe9
case|:
comment|/* Relative jump: if data16 == 0, disp32, else disp16.  */
if|if
condition|(
name|data16
condition|)
block|{
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Include the size of the jmp instruction (including the              0x66 prefix).  */
name|pos
operator|+=
name|delta
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|delta
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|delta
operator|+
literal|5
expr_stmt|;
block|}
break|break;
case|case
literal|0xeb
case|:
comment|/* Relative jump, disp8 (ignore data16).  */
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Sign-extend it.  */
name|delta
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|delta
operator|+
literal|2
expr_stmt|;
break|break;
block|}
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find& return the amount a local space allocated, and advance the    codestream to the first register push (if any).     If the entry sequence doesn't make sense, return -1, and leave    codestream pointer at a random spot.  */
end_comment

begin_function
specifier|static
name|long
name|i386_get_frame_setup
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|codestream_seek
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x58
condition|)
comment|/* popl %eax */
block|{
comment|/* This function must start with  	    popl %eax             0x58             xchgl %eax, (%esp)    0x87 0x04 0x24          or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00  	 (the System V compiler puts out the second `xchg' 	 instruction, and the assembler doesn't try to optimize it, so 	 the 'sib' form gets generated).  This sequence is used to get 	 the address of the return buffer for a function that returns 	 a structure.  */
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto1
index|[
literal|3
index|]
init|=
block|{
literal|0x87
block|,
literal|0x04
block|,
literal|0x24
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto2
index|[
literal|4
index|]
init|=
block|{
literal|0x87
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x00
block|}
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto1
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto2
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|4
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* Update next opcode.  */
block|}
if|if
condition|(
name|op
operator|==
literal|0x68
operator|||
name|op
operator|==
literal|0x6a
condition|)
block|{
comment|/* This function may start with              pushl constant             call _probe 	    addl $4, %esp 	    	 followed by              pushl %ebp  	 etc.  */
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
comment|/* Skip past the `pushl' instruction; it has either a one-byte           or a four-byte operand, depending on the opcode.  */
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x68
condition|)
name|pos
operator|+=
literal|4
expr_stmt|;
else|else
name|pos
operator|+=
literal|1
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|/* Read the following 8 bytes, which should be "call _probe" (6          bytes) followed by "addl $4,%esp" (2 bytes).  */
name|codestream_read
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0xe8
operator|&&
name|buf
index|[
literal|6
index|]
operator|==
literal|0xc4
operator|&&
name|buf
index|[
literal|7
index|]
operator|==
literal|0x4
condition|)
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* Update next opcode.  */
block|}
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushl %ebp */
block|{
comment|/* Check for "movl %esp, %ebp" -- can be written in two ways.  */
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0x8b
case|:
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|0x89
case|:
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xe5
condition|)
return|return
operator|-
literal|1
return|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check for stack adjustment              subl $XXX, %esp  	 NOTE: You can't subtract a 16 bit immediate from a 32 bit 	 reg, so we don't have to worry about a data16 prefix.  */
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
comment|/* `subl' with 8 bit immediate.  */
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
comment|/* Some instruction starting with 0x83 other than `subl'.  */
block|{
name|codestream_seek
argument_list|(
name|codestream_tell
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* `subl' with signed byte immediate (though it wouldn't 	     make sense to be negative).  */
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Maybe it is `subl' with a 32 bit immedediate.  */
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
comment|/* Some instruction starting with 0x81 other than `subl'.  */
block|{
name|codestream_seek
argument_list|(
name|codestream_tell
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* It is `subl' with a 32 bit immediate.  */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* `enter' with 16 bit unsigned immediate.  */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* Flush final byte of enter instruction.  */
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the chain-pointer for FRAME.  In the case of the i386, the    frame's nominal address is the address of a 4-byte word containing    the calling frame's address.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|frame
operator|->
name|frame
return|;
if|if
condition|(
operator|!
name|inside_entry_file
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
condition|)
return|return
name|read_memory_unsigned_integer
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the function invocation represented by FRAME does    not have a from on the stack associated with it.  If it does not,    return non-zero, otherwise return zero.  */
end_comment

begin_function
name|int
name|i386_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
literal|0
return|;
return|return
name|frameless_look_for_prologue
argument_list|(
name|frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the saved program counter for FRAME.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
comment|/* FIXME: kettenis/2001-05-09: Conditionalizing the next bit of code      on SIGCONTEXT_PC_OFFSET and I386V4_SIGTRAMP_SAVED_PC should be      considered a temporary hack.  I plan to come up with something      better when we go multi-arch.  */
if|#
directive|if
name|defined
argument_list|(
name|SIGCONTEXT_PC_OFFSET
argument_list|)
operator|||
name|defined
argument_list|(
name|I386V4_SIGTRAMP_SAVED_PC
argument_list|)
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|sigtramp_saved_pc
argument_list|(
name|frame
argument_list|)
return|;
endif|#
directive|endif
return|return
name|read_memory_unsigned_integer
argument_list|(
name|frame
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|i386go32_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
name|read_memory_unsigned_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of args passed to a frame.    Can return -1, meaning no way to tell.  */
end_comment

begin_function
name|int
name|i386_frame_num_args
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|#
directive|if
literal|1
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* This loses because not only might the compiler not be popping the      args right after the function call, it might be popping args from      both this call and a previous one, and we would say there are      more args than there really are.  */
name|int
name|retpc
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|pfi
decl_stmt|;
comment|/* On the i386, the instruction following the call could be:      popl %ecx        -  one arg      addl $imm, %esp  -  imm/4 args; imm may be 8 or 32 bits      anything else    -  zero args.  */
name|int
name|frameless
decl_stmt|;
name|frameless
operator|=
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|frameless
condition|)
comment|/* In the absence of a frame pointer, GDB doesn't get correct        values for nameless arguments.  Return -1, so it doesn't print        any nameless arguments.  */
return|return
operator|-
literal|1
return|;
name|pfi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfi
operator|==
literal|0
condition|)
block|{
comment|/* NOTE: This can happen if we are looking at the frame for          main, because FRAME_CHAIN_VALID won't let us go into start.          If we have debugging symbols, that's not really a big deal;          it just means it will only show as many arguments to main as          are declared.  */
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|retpc
operator|=
name|pfi
operator|->
name|pc
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x59
condition|)
comment|/* pop %ecx */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0xc4
condition|)
comment|/* addl $<signed imm 8 bits>, %esp */
return|return
operator|(
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|/
literal|4
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
comment|/* `add' with 32 bit immediate.  */
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0xc4
condition|)
comment|/* addl $<imm 32>, %esp */
return|return
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|2
argument_list|,
literal|4
argument_list|)
operator|/
literal|4
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Parse the first few instructions the function to see what registers    were stored.        We handle these cases:     The startup sequence can be at the start of the function, or the    function can start with a branch to startup code at the end.     %ebp can be set up with either the 'enter' instruction, or "pushl    %ebp, movl %esp, %ebp" (`enter' is too slow to be useful, but was    once used in the System V compiler).     Local space is allocated just below the saved %ebp by either the    'enter' instruction, or by "subl $<size>, %esp".  'enter' has a 16    bit unsigned argument for space to allocate, and the 'addl'    instruction could have either a signed byte, or 32 bit immediate.     Next, the registers used by this function are pushed.  With the    System V compiler they will always be in the order: %edi, %esi,    %ebx (and sometimes a harmless bug causes it to also save but not    restore %eax); however, the code below is willing to see the pushes    in any order, and will handle up to 8 of them.      If the setup sequence is at the end of the function, then the next    instruction will be a branch back to the start.  */
end_comment

begin_function
name|void
name|i386_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fip
parameter_list|)
block|{
name|long
name|locals
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|CORE_ADDR
name|dummy_bottom
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fip
operator|->
name|saved_regs
condition|)
return|return;
name|frame_saved_regs_zalloc
argument_list|(
name|fip
argument_list|)
expr_stmt|;
comment|/* If the frame is the end of a dummy, compute where the beginning      would be.  */
name|dummy_bottom
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|REGISTER_BYTES
operator|-
name|CALL_DUMMY_LENGTH
expr_stmt|;
comment|/* Check if the PC points in the stack, in a dummy frame.  */
if|if
condition|(
name|dummy_bottom
operator|<=
name|fip
operator|->
name|pc
operator|&&
name|fip
operator|->
name|pc
operator|<=
name|fip
operator|->
name|frame
condition|)
block|{
comment|/* All registers were saved by push_call_dummy.  */
name|addr
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fip
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
block|}
return|return;
block|}
name|pc
operator|=
name|get_pc_function_start
argument_list|(
name|fip
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
literal|0
condition|)
name|locals
operator|=
name|i386_get_frame_setup
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|>=
literal|0
condition|)
block|{
name|addr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
ifdef|#
directive|ifdef
name|I386_REGNO_TO_SYMMETRY
comment|/* Dynix uses different internal numbering.  Ick.  */
name|fip
operator|->
name|saved_regs
index|[
name|I386_REGNO_TO_SYMMETRY
argument_list|(
name|op
operator|-
literal|0x50
argument_list|)
index|]
operator|=
name|addr
expr_stmt|;
else|#
directive|else
name|fip
operator|->
name|saved_regs
index|[
name|op
operator|-
literal|0x50
index|]
operator|=
name|addr
expr_stmt|;
endif|#
directive|endif
name|addr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|fip
operator|->
name|saved_regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
name|fip
operator|->
name|saved_regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return PC of first real instruction.  */
end_comment

begin_function
name|int
name|i386_skip_prologue
parameter_list|(
name|int
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pic_pat
index|[
literal|6
index|]
init|=
block|{
literal|0xe8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* call   0x0 */
literal|0x5b
block|,
comment|/* popl   %ebx */
block|}
decl_stmt|;
name|CORE_ADDR
name|pos
decl_stmt|;
if|if
condition|(
name|i386_get_frame_setup
argument_list|(
name|pc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pc
operator|)
return|;
comment|/* Found valid frame setup -- codestream now points to start of push      instructions for saving registers.  */
comment|/* Skip over register saves.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
comment|/* Break if not `pushl' instrunction.  */
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|codestream_get
argument_list|()
expr_stmt|;
block|}
comment|/* The native cc on SVR4 in -K PIC mode inserts the following code      to get the address of the global offset table (GOT) into register      %ebx               call	0x0 	popl    %ebx         movl    %ebx,x(%ebp)    (optional)         addl    y,%ebx       This code is with the rest of the prologue (at the end of the      function), so we have to skip it to get to the first real      instruction at the start of the function.  */
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|pic_pat
index|[
name|i
index|]
operator|!=
name|op
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|6
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|long
name|delta
init|=
literal|6
decl_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x89
condition|)
comment|/* movl %ebx, x(%ebp) */
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x5d
condition|)
comment|/* One byte offset from %ebp.  */
block|{
name|delta
operator|+=
literal|3
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x9d
condition|)
comment|/* Four byte offset from %ebp.  */
block|{
name|delta
operator|+=
literal|6
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Unexpected instruction.  */
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
comment|/* addl y,%ebx */
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|op
operator|==
literal|0x81
operator|&&
name|codestream_get
argument_list|()
operator|==
literal|0xc3
condition|)
block|{
name|pos
operator|+=
name|delta
operator|+
literal|6
expr_stmt|;
block|}
block|}
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
return|return
operator|(
name|codestream_tell
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i386_push_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_bytes
argument_list|(
name|sp
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the (relative) function address into the call sequence    stored at DYMMY.  */
end_comment

begin_function
name|void
name|i386_fix_call_dummy
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fun
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|gcc_p
parameter_list|)
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|,
name|delta
decl_stmt|,
name|loc
decl_stmt|;
name|loc
operator|=
call|(
name|int
call|)
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|-
name|CALL_DUMMY_LENGTH
argument_list|)
expr_stmt|;
name|from
operator|=
name|loc
operator|+
literal|5
expr_stmt|;
name|to
operator|=
call|(
name|int
call|)
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|delta
operator|=
name|to
operator|-
name|from
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dummy
operator|)
operator|+
literal|1
operator|)
operator|=
operator|(
name|delta
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dummy
operator|)
operator|+
literal|2
operator|)
operator|=
operator|(
operator|(
name|delta
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dummy
operator|)
operator|+
literal|3
operator|)
operator|=
operator|(
operator|(
name|delta
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dummy
operator|)
operator|+
literal|4
operator|)
operator|=
operator|(
operator|(
name|delta
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|fp
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|i386_frame_init_saved_regs
argument_list|(
name|frame
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|fp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_comment
comment|/* FIXME: Multi-arching does not set JB_PC and JB_ELEMENT_SIZE yet.      Fill in with dummy value to enable compilation.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|JB_PC
end_ifndef

begin_define
define|#
directive|define
name|JB_PC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JB_PC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|JB_ELEMENT_SIZE
end_ifndef

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JB_ELEMENT_SIZE */
end_comment

begin_comment
comment|/* Figure out where the longjmp will land.  Slurp the args out of the    stack.  We expect the first arg to be a pointer to the jmp_buf    structure from which we extract the pc (JB_PC) that we will land    at.  The pc is copied into PC.  This routine returns true on    success.  */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|,
name|jb_addr
decl_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
argument_list|,
comment|/* Offset of first arg on stack.  */
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
name|jb_addr
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET */
end_comment

begin_escape
end_escape

begin_function
name|CORE_ADDR
name|i386_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|sp
operator|=
name|default_push_arguments
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|sp
operator|-=
literal|4
expr_stmt|;
name|store_address
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_function
name|void
name|i386_store_struct_return
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
comment|/* Do nothing.  Everything was already done by i386_push_arguments.  */
block|}
end_function

begin_comment
comment|/* These registers are used for returning integers (and on some    targets also for returning `struct' and `union' values when their    size and alignment match an integer type).  */
end_comment

begin_define
define|#
directive|define
name|LOW_RETURN_REGNUM
value|0
end_define

begin_comment
comment|/* %eax */
end_comment

begin_define
define|#
directive|define
name|HIGH_RETURN_REGNUM
value|2
end_define

begin_comment
comment|/* %edx */
end_comment

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state, a    function return value of TYPE, and copy that, in virtual format,    into VALBUF.  */
end_comment

begin_function
name|void
name|i386_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|i386_extract_return_value
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regbuf
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|NUM_FREGS
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot find floating-point return value."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|valbuf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Floating-point return values can be found in %st(0).  Convert 	 its contents to the desired type.  This is probably not 	 exactly how it would happen on the target itself, but it is 	 the best we can do.  */
name|convert_typed_floating
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|builtin_type_i387_ext
argument_list|,
name|valbuf
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|low_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
decl_stmt|;
name|int
name|high_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|HIGH_RETURN_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|low_size
condition|)
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|<=
operator|(
name|low_size
operator|+
name|high_size
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
index|]
argument_list|,
name|low_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
operator|+
name|low_size
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|HIGH_RETURN_REGNUM
argument_list|)
index|]
argument_list|,
name|len
operator|-
name|low_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot extract return value of %d bytes long."
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write into the appropriate registers a function return value stored    in VALBUF of type TYPE, given in virtual format.  */
end_comment

begin_function
name|void
name|i386_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|i386_store_return_value
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|unsigned
name|int
name|fstat
decl_stmt|;
name|char
name|buf
index|[
name|FPU_REG_RAW_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|NUM_FREGS
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot set floating-point return value."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Returning floating-point values is a bit tricky.  Apart from          storing the return value in %st(0), we have to simulate the          state of the FPU at function return point.  */
comment|/* Convert the value found in VALBUF to the extended 	 floating-point format used by the FPU.  This is probably 	 not exactly how it would happen on the target itself, but 	 it is the best we can do.  */
name|convert_typed_floating
argument_list|(
name|valbuf
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|builtin_type_i387_ext
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
name|buf
argument_list|,
name|FPU_REG_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* Set the top of the floating-point register stack to 7.  The          actual value doesn't really matter, but 7 is what a normal          function return would end up with if the program started out          with a freshly initialized FPU.  */
name|fstat
operator|=
name|read_register
argument_list|(
name|FSTAT_REGNUM
argument_list|)
expr_stmt|;
name|fstat
operator||=
operator|(
literal|7
operator|<<
literal|11
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|FSTAT_REGNUM
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* Mark %st(1) through %st(7) as empty.  Since we set the top of          the floating-point register stack to 7, the appropriate value          for the tag word is 0x3fff.  */
name|write_register
argument_list|(
name|FTAG_REGNUM
argument_list|,
literal|0x3fff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|low_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
decl_stmt|;
name|int
name|high_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|HIGH_RETURN_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|low_size
condition|)
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|<=
operator|(
name|low_size
operator|+
name|high_size
operator|)
condition|)
block|{
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|low_size
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|HIGH_RETURN_REGNUM
argument_list|)
argument_list|,
name|valbuf
operator|+
name|low_size
argument_list|,
name|len
operator|-
name|low_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot store return value of %d bytes long."
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state    the address in which a function should return its structure value,    as a CORE_ADDR.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_extract_struct_value_address
parameter_list|(
name|char
modifier|*
name|regbuf
parameter_list|)
block|{
return|return
name|extract_address
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|LOW_RETURN_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REGNUM.  Perhaps %esi and %edi should go here, but    potentially they could be used for things other than address.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|i386_register_virtual_type
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
operator|||
name|regnum
operator|==
name|FP_REGNUM
operator|||
name|regnum
operator|==
name|SP_REGNUM
condition|)
return|return
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
return|;
if|if
condition|(
name|IS_FP_REGNUM
argument_list|(
name|regnum
argument_list|)
condition|)
return|return
name|builtin_type_i387_ext
return|;
if|if
condition|(
name|IS_SSE_REGNUM
argument_list|(
name|regnum
argument_list|)
condition|)
return|return
name|builtin_type_v4sf
return|;
return|return
name|builtin_type_int
return|;
block|}
end_function

begin_comment
comment|/* Return true iff register REGNUM's virtual format is different from    its raw format.  Note that this definition assumes that the host    supports IEEE 32-bit floats, since it doesn't say that SSE    registers need conversion.  Even if we can't find a counterexample,    this is still sloppy.  */
end_comment

begin_function
name|int
name|i386_register_convertible
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|IS_FP_REGNUM
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert data from raw format for register REGNUM in buffer FROM to    virtual format with type TYPE in buffer TO.  */
end_comment

begin_function
name|void
name|i386_register_convert_to_virtual
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|IS_FP_REGNUM
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only support floating-point values.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FLT
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot convert floating-point register value "
literal|"to non-floating-point type."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert to TYPE.  This should be a no-op if TYPE is equivalent to      the extended floating-point format used by the FPU.  */
name|convert_typed_floating
argument_list|(
name|from
argument_list|,
name|builtin_type_i387_ext
argument_list|,
name|to
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert data from virtual format with type TYPE in buffer FROM to    raw format for register REGNUM in buffer TO.  */
end_comment

begin_function
name|void
name|i386_register_convert_to_raw
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|IS_FP_REGNUM
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only support floating-point values.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FLT
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot convert non-floating-point type "
literal|"to floating-point register value."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert from TYPE.  This should be a no-op if TYPE is equivalent      to the extended floating-point format used by the FPU.  */
name|convert_typed_floating
argument_list|(
name|from
argument_list|,
name|type
argument_list|,
name|to
argument_list|,
name|builtin_type_i387_ext
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|I386V4_SIGTRAMP_SAVED_PC
end_ifdef

begin_comment
comment|/* Get saved user PC for sigtramp from the pushed ucontext on the    stack for all three variants of SVR4 sigtramps.  */
end_comment

begin_function
name|CORE_ADDR
name|i386v4_sigtramp_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|saved_pc_offset
init|=
literal|4
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"_sigreturn"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|132
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"_sigacthandler"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|80
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"sigvechandler"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|120
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|next
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
name|saved_pc_offset
argument_list|,
literal|4
argument_list|)
return|;
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
name|saved_pc_offset
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I386V4_SIGTRAMP_SAVED_PC */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
end_ifdef

begin_comment
comment|/* SunPRO encodes the static variables.  This is not related to C++    mangling, it is done for C too.  */
end_comment

begin_function
name|char
modifier|*
name|sunpro_static_transform_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|IS_STATIC_TRANSFORM_NAME
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* For file-local statics there will be a period, a bunch of          junk (the contents of which match a string given in the          N_OPT), a period and the name.  For function-local statics          there will be a bunch of junk (which seems to change the          second character from 'A' to 'B'), a period, the name of the          function, and the name.  So just skip everything before the          last period.  */
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_TRANSFORM_NAME */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Stuff for WIN32 PE style DLL's but is pretty generic really.  */
end_comment

begin_function
name|CORE_ADDR
name|skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|&&
name|read_memory_unsigned_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
operator|==
literal|0x25ff
condition|)
comment|/* jmp *(dest) */
block|{
name|unsigned
name|long
name|indirect
init|=
name|read_memory_unsigned_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|indsym
init|=
name|indirect
condition|?
name|lookup_minimal_symbol_by_pc
argument_list|(
name|indirect
argument_list|)
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|indsym
condition|?
name|SYMBOL_NAME
argument_list|(
name|indsym
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|symname
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"__imp_"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"_imp_"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|name
condition|?
literal|1
else|:
name|read_memory_unsigned_integer
argument_list|(
name|indirect
argument_list|,
literal|4
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Not a trampoline.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have two flavours of disassembly.  The machinery on this page    deals with switching between those.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_print_insn_i386
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|disassembly_flavor
operator|==
name|att_flavor
condition|)
return|return
name|print_insn_i386_att
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
elseif|else
if|if
condition|(
name|disassembly_flavor
operator|==
name|intel_flavor
condition|)
return|return
name|print_insn_i386_intel
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
comment|/* Never reached -- disassembly_flavour is always either att_flavor      or intel_flavor.  */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|process_note_abi_tag_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|int
modifier|*
name|os_ident_ptr
init|=
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|sect_size
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|sect_size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.ABI-tag"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|name_length
decl_stmt|,
name|data_length
decl_stmt|,
name|note_type
decl_stmt|;
name|char
modifier|*
name|note
init|=
name|alloca
argument_list|(
name|sect_size
argument_list|)
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|sect_size
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|data_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|4
argument_list|)
expr_stmt|;
name|note_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|==
literal|4
operator|&&
name|data_length
operator|==
literal|16
operator|&&
name|note_type
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|note
operator|+
literal|12
argument_list|,
literal|"GNU"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|os_number
init|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|16
argument_list|)
decl_stmt|;
comment|/* The case numbers are from abi-tags in glibc.  */
switch|switch
condition|(
name|os_number
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|os_ident_ptr
operator|=
name|ELFOSABI_LINUX
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|os_ident_ptr
operator|=
name|ELFOSABI_HURD
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|os_ident_ptr
operator|=
name|ELFOSABI_SOLARIS
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"process_note_abi_sections: "
literal|"unknown OS number %d"
argument_list|,
name|os_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|struct
name|gdbarch
modifier|*
name|i386_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|int
name|os_ident
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|abfd
operator|!=
name|NULL
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|os_ident
operator|=
name|elf_elfheader
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
expr_stmt|;
comment|/* If os_ident is 0, it is not necessarily the case that we're          on a SYSV system.  (ELFOSABI_NONE is defined to be 0.)          GNU/Linux uses a note section to record OS/ABI info, but          leaves e_ident[EI_OSABI] zero.  So we have to check for note          sections too.  */
if|if
condition|(
name|os_ident
operator|==
name|ELFOSABI_NONE
condition|)
name|bfd_map_over_sections
argument_list|(
name|info
operator|.
name|abfd
argument_list|,
name|process_note_abi_tag_sections
argument_list|,
operator|&
name|os_ident
argument_list|)
expr_stmt|;
comment|/* If that didn't help us, revert to some non-standard checks.  */
if|if
condition|(
name|os_ident
operator|==
name|ELFOSABI_NONE
condition|)
block|{
comment|/* FreeBSD folks are naughty; they stored the string 	     "FreeBSD" in the padding of the e_ident field of the ELF 	     header.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|elf_elfheader
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
literal|8
index|]
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
condition|)
name|os_ident
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
block|}
block|}
else|else
name|os_ident
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
init|;
name|arches
operator|!=
name|NULL
condition|;
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
operator|->
name|next
argument_list|,
operator|&
name|info
argument_list|)
control|)
block|{
name|tdep
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|&&
name|tdep
operator|->
name|os_ident
operator|==
name|os_ident
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
block|}
comment|/* Allocate space for the new architecture.  */
name|tdep
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|os_ident
operator|=
name|os_ident
expr_stmt|;
comment|/* FIXME: kettenis/2001-11-24: Although not all IA-32 processors      have the SSE registers, it's easier to set the default to 8.  */
name|tdep
operator|->
name|num_xmm_regs
operator|=
literal|8
expr_stmt|;
name|set_gdbarch_use_generic_dummy_frames
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call dummy code.  */
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|ON_STACK
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_stack_adjust_p
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_get_saved_register
argument_list|(
name|gdbarch
argument_list|,
name|generic_get_saved_register
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|i386_push_arguments
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_on_stack
argument_list|)
expr_stmt|;
comment|/* NOTE: tm-i386nw.h and tm-i386v4.h override this.  */
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
comment|/* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-linux.h,      tm-ptx.h, tm-symmetry.h currently override this.  Sigh.  */
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|NUM_GREGS
operator|+
name|NUM_FREGS
operator|+
name|NUM_SSE_REGS
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_comment
comment|/* Provide a prototype to silence -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_i386_tdep
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_i386_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|register_gdbarch_init
argument_list|(
name|bfd_arch_i386
argument_list|,
name|i386_gdbarch_init
argument_list|)
expr_stmt|;
comment|/* Initialize the table saying where each register starts in the      register file.  */
block|{
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|i386_register_offset
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|i386_register_size
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|tm_print_insn
operator|=
name|gdb_print_insn_i386
expr_stmt|;
name|tm_print_insn_info
operator|.
name|mach
operator|=
name|bfd_lookup_arch
argument_list|(
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|)
operator|->
name|mach
expr_stmt|;
comment|/* Add the variable that controls the disassembly flavor.  */
block|{
name|struct
name|cmd_list_element
modifier|*
name|new_cmd
decl_stmt|;
name|new_cmd
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembly-flavor"
argument_list|,
name|no_class
argument_list|,
name|valid_flavors
argument_list|,
operator|&
name|disassembly_flavor
argument_list|,
literal|"\ Set the disassembly flavor, the valid values are \"att\" and \"intel\", \ and the default value is \"att\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_cmd
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

