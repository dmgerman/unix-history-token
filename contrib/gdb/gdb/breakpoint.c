begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Everything about breakpoints, for GDB.    Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|catch_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_delete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_delete_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_once_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_once_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disable_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_breakpoint_numbers
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|breakpoint
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breakpoint_re_set_one
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_gnu_4_16_catch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|get_catch_sals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|watch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_use_hardware_watchpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mention
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab_and_line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_duplicates
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|describe_other_breakpoints
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breakpoints_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breakpoint_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bpstat
name|bpstat_alloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|,
name|bpstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breakpoint_cond_eval
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup_executing_breakpoints
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|commands_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|condition_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_breakpoint_count
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct breakpoint * create_temp_exception_breakpoint PARAMS ((CORE_ADDR));
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|mark_inserted
block|,
name|mark_uninserted
block|}
name|insertion_state_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|remove_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|,
name|insertion_state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_it_normal
name|PARAMS
argument_list|(
operator|(
name|bpstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|enum
name|exception_event_kind
name|kind
decl_stmt|;
name|int
name|enable
decl_stmt|;
block|}
name|args_for_catchpoint_enable
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|watchpoint_check
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cover_target_enable_exception_callback
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_it_done
name|PARAMS
argument_list|(
operator|(
name|bpstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_it_noop
name|PARAMS
argument_list|(
operator|(
name|bpstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maintenance_info_breakpoints
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|create_longjmp_breakpoint
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hw_breakpoint_used_count
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hw_watchpoint_used_count
name|PARAMS
argument_list|(
operator|(
expr|enum
name|bptype
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|watch_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rwatch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|awatch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_enable_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|,
expr|enum
name|bpdisp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|awatch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_enable_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|,
expr|enum
name|bpdisp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If FALSE, gdb will not use hardware support for watchpoints, even    if such is available. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|can_use_hw_watchpoints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|delete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_breakpoint
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_breakpoint_count
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print machine addresses? */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GET_LONGJMP_TARGET
argument_list|)
operator|||
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|internal_breakpoint_number
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Are we executing breakpoint commands?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_breakpoint_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Walk the following statement or block through all breakpoints.    ALL_BREAKPOINTS_SAFE does so even if the statment deletes the current    breakpoint.  */
end_comment

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS
parameter_list|(
name|b
parameter_list|)
value|for (b = breakpoint_chain; b; b = b->next)
end_define

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS_SAFE
parameter_list|(
name|b
parameter_list|,
name|tmp
parameter_list|)
define|\
value|for (b = breakpoint_chain;	\ 	     b? (tmp=b->next, 1): 0;	\ 	     b = tmp)
end_define

begin_comment
comment|/* True if SHIFT_INST_REGS defined, false otherwise.  */
end_comment

begin_decl_stmt
name|int
name|must_shift_inst_regs
init|=
if|#
directive|if
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if breakpoint hit counts should be displayed in breakpoint info.  */
end_comment

begin_decl_stmt
name|int
name|show_breakpoint_hit_counts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all breakpoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last breakpoint made.  */
end_comment

begin_decl_stmt
name|int
name|breakpoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to current exception event record */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|exception_event_record
modifier|*
name|current_exception_event
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicator of whether exception catchpoints should be nuked    between runs of a program */
end_comment

begin_decl_stmt
name|int
name|exception_catchpoints_are_fragile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicator of when exception catchpoints set-up should be    reinitialized -- e.g. when program is re-run */
end_comment

begin_decl_stmt
name|int
name|exception_support_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function returns a pointer to the string representation of the    pathname of the dynamically-linked library that has just been    loaded.     This function must be used only when SOLIB_HAVE_LOAD_EVENT is TRUE,    or undefined results are guaranteed.     This string's contents are only valid immediately after the    inferior has stopped in the dynamic linker hook, and becomes    invalid as soon as the inferior is continued.  Clients should make    a copy of this string if they wish to continue the inferior and    then access the string.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_LOADED_LIBRARY_PATHNAME
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_LOADED_LIBRARY_PATHNAME
parameter_list|(
name|pid
parameter_list|)
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function returns a pointer to the string representation of the    pathname of the dynamically-linked library that has just been    unloaded.     This function must be used only when SOLIB_HAVE_UNLOAD_EVENT is    TRUE, or undefined results are guaranteed.     This string's contents are only valid immediately after the    inferior has stopped in the dynamic linker hook, and becomes    invalid as soon as the inferior is continued.  Clients should make    a copy of this string if they wish to continue the inferior and    then access the string.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
parameter_list|(
name|pid
parameter_list|)
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called by the "catch load" command.  It allows the    debugger to be notified by the dynamic linker when a specified    library file (or any library file, if filename is NULL) is loaded.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_CREATE_CATCH_LOAD_HOOK
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_CREATE_CATCH_LOAD_HOOK
parameter_list|(
name|pid
parameter_list|,
name|tempflag
parameter_list|,
name|filename
parameter_list|,
name|cond_string
parameter_list|)
define|\
value|error ("catch of library loads not yet implemented on this platform")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called by the "catch unload" command.  It allows    the debugger to be notified by the dynamic linker when a specified    library file (or any library file, if filename is NULL) is    unloaded.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_CREATE_CATCH_UNLOAD_HOOK
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_CREATE_CATCH_UNLOAD_HOOK
parameter_list|(
name|pid
parameter_list|,
name|tempflag
parameter_list|,
name|filename
parameter_list|,
name|cond_string
parameter_list|)
define|\
value|error ("catch of library unloads not yet implemented on this platform")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set breakpoint count to NUM.  */
end_comment

begin_function
name|void
name|set_breakpoint_count
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|breakpoint_count
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"bpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in run_command to zero the hit count when a new run starts. */
end_comment

begin_function
name|void
name|clear_breakpoint_hit_counts
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|hit_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default address, symtab and line to put a breakpoint at    for "break" command with no arg.    if default_breakpoint_valid is zero, the other three are    not valid, and "break" with no arg is an error.     This set by print_stack_frame, which calls set_default_breakpoint.  */
end_comment

begin_decl_stmt
name|int
name|default_breakpoint_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|default_breakpoint_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|default_breakpoint_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_breakpoint_line
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* *PP is a string denoting a breakpoint.  Get the number of the breakpoint.    Advance *PP after the string and any trailing whitespace.     Currently the string can either be a number or "$" followed by the name    of a convenience variable.  Making it an expression wouldn't work well    for map_breakpoint_numbers (e.g. "4 + 5 + 6").  */
end_comment

begin_function
specifier|static
name|int
name|get_number
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Empty line means refer to the last breakpoint.  */
return|return
name|breakpoint_count
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
comment|/* Make a copy of the name, so we can null-terminate it 	 to pass to lookup_internalvar().  */
name|char
modifier|*
name|varname
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|++
name|p
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
name|p
operator|++
expr_stmt|;
name|varname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|varname
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
name|varname
index|[
name|p
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|varname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variables used to specify breakpoints must have integer values."
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|pp
condition|)
comment|/* There is no number here.  (e.g. "cond a == b").  */
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|atoi
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
name|error
argument_list|(
literal|"breakpoint number expected"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* condition N EXP -- set break condition of breakpoint N to EXP.  */
end_comment

begin_function
specifier|static
name|void
name|condition_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Breakpoint %d now unconditional.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|p
expr_stmt|;
comment|/* I don't know if it matters whether this is the string the user 	       typed in or the decompiled expression.  */
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of expression"
argument_list|)
expr_stmt|;
block|}
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|commands_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
comment|/* If we allowed this, we would have problems with when to      free the storage, if we change the commands currently      being read from.  */
if|if
condition|(
name|executing_breakpoint_commands
condition|)
name|error
argument_list|(
literal|"Can't use the \"commands\" command among a breakpoint's commands."
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"Unexpected extra arguments following breakpoint number."
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Type commands for when breakpoint %d is hit, one per line."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|l
operator|=
name|read_command_lines
argument_list|(
name|tmpbuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|b
operator|->
name|commands
argument_list|)
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|l
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like target_read_memory() but if breakpoints are inserted, return    the shadow contents instead of the breakpoints themselves.     Read "memory data" from whatever target or inferior we have.     Returns zero if successful, errno value if not.  EIO is used    for address out of bounds.  If breakpoints are inserted, returns    shadow contents, not the breakpoints themselves.  From breakpoint.c.  */
end_comment

begin_function
name|int
name|read_memory_nobpt
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|CORE_ADDR
name|bp_addr
init|=
literal|0
decl_stmt|;
name|int
name|bp_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|bp_addr
argument_list|,
operator|&
name|bp_size
argument_list|)
operator|==
name|NULL
condition|)
comment|/* No breakpoints on this machine. */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_none
condition|)
name|warning
argument_list|(
literal|"attempted to read through apparently deleted breakpoint #%d?\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* memory breakpoint? */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
continue|continue;
comment|/* bp in memory? */
if|if
condition|(
operator|!
name|b
operator|->
name|inserted
condition|)
continue|continue;
comment|/* Addresses and length of the part of the breakpoint that 	 we need to copy.  */
comment|/* XXXX The m68k, sh and h8300 have different local and remote 	 breakpoint values.  BREAKPOINT_FROM_PC still manages to 	 correctly determine the breakpoints memory address and size 	 for these targets. */
name|bp_addr
operator|=
name|b
operator|->
name|address
expr_stmt|;
name|bp_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|bp_addr
argument_list|,
operator|&
name|bp_size
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|bp_size
operator|==
literal|0
condition|)
comment|/* bp isn't valid */
continue|continue;
if|if
condition|(
name|bp_addr
operator|+
name|bp_size
operator|<=
name|memaddr
condition|)
comment|/* The breakpoint is entirely before the chunk of memory we 	   are reading.  */
continue|continue;
if|if
condition|(
name|bp_addr
operator|>=
name|memaddr
operator|+
name|len
condition|)
comment|/* The breakpoint is entirely after the chunk of memory we are 	   reading. */
continue|continue;
comment|/* Copy the breakpoint from the shadow contents, and recurse for 	 the things before and after.  */
block|{
comment|/* Offset within shadow_contents.  */
name|int
name|bptoffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bp_addr
operator|<
name|memaddr
condition|)
block|{
comment|/* Only copy the second part of the breakpoint.  */
name|bp_size
operator|-=
name|memaddr
operator|-
name|bp_addr
expr_stmt|;
name|bptoffset
operator|=
name|memaddr
operator|-
name|bp_addr
expr_stmt|;
name|bp_addr
operator|=
name|memaddr
expr_stmt|;
block|}
if|if
condition|(
name|bp_addr
operator|+
name|bp_size
operator|>
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Only copy the first part of the breakpoint.  */
name|bp_size
operator|-=
operator|(
name|bp_addr
operator|+
name|bp_size
operator|)
operator|-
operator|(
name|memaddr
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|myaddr
operator|+
name|bp_addr
operator|-
name|memaddr
argument_list|,
name|b
operator|->
name|shadow_contents
operator|+
name|bptoffset
argument_list|,
name|bp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp_addr
operator|>
name|memaddr
condition|)
block|{
comment|/* Copy the section of memory before the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|bp_addr
operator|-
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|bp_addr
operator|+
name|bp_size
operator|<
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Copy the section of memory after the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|bp_addr
operator|+
name|bp_size
argument_list|,
name|myaddr
operator|+
name|bp_addr
operator|+
name|bp_size
operator|-
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
operator|-
operator|(
name|bp_addr
operator|+
name|bp_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/* Nothing overlaps.  Just call read_memory_noerr.  */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* insert_breakpoints is used when starting or continuing the program.    remove_breakpoints is used when the program stops.    Both return zero if successful,    or an `errno' value if could not write the inferior.  */
end_comment

begin_function
name|int
name|insert_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|disabled_breaks
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error inserting catchpoint %d:\n"
decl_stmt|;
specifier|static
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
index|]
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_throw
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|&&
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|call_disabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check to see if breakpoint is in an overlay section; 		 if so, we should set the breakpoint at the LMA address. 		 Only if the section is currently mapped should we ALSO 		 set a break at the VMA address. */
if|if
condition|(
name|overlay_debugging
operator|&&
name|b
operator|->
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
comment|/* This would be the time to check val, to see if the 		     breakpoint write to the load address succeeded.   		     However, this might be an ordinary occurrance, eg. if  		     the unmapped overlay is in ROM.  */
name|val
operator|=
literal|0
expr_stmt|;
comment|/* in case unmapped address failed */
if|if
condition|(
name|section_is_mapped
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ordinary (non-overlay) address */
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
block|{
comment|/* Can't set the breakpoint.  */
if|#
directive|if
name|defined
argument_list|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|)
if|if
condition|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|(
name|b
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* See also: disable_breakpoints_in_shlibs. */
name|val
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|shlib_disabled
expr_stmt|;
if|if
condition|(
operator|!
name|disabled_breaks
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Temporarily disabling shared library breakpoints:\n"
argument_list|)
expr_stmt|;
block|}
name|disabled_breaks
operator|=
literal|1
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ONE_PROCESS_WRITETEXT
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memory_error
argument_list|(
name|val
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* which bombs us out */
block|}
block|}
else|else
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|&&
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|call_disabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
comment|/* If we get here, we must have a callback mechanism for exception             events -- with g++ style embedded label support, we insert             ordinary breakpoints and not catchpoints. */
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Format possible error message */
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
comment|/* Couldn't set breakpoint for some reason */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert catchpoint %d; disabling it\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
block|}
else|else
block|{
comment|/* Bp set, now make sure callbacks are enabled */
name|int
name|val
decl_stmt|;
name|args_for_catchpoint_enable
name|args
decl_stmt|;
name|args
operator|.
name|kind
operator|=
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
condition|?
name|EX_EVENT_CATCH
else|:
name|EX_EVENT_THROW
expr_stmt|;
name|args
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|catch_errors
argument_list|(
name|cover_target_enable_exception_callback
argument_list|,
operator|&
name|args
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|val
operator|!=
operator|-
literal|1
condition|)
block|{
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check if something went wrong; val == 0 can be ignored */
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* something went wrong */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert catchpoint %d; disabling it\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|saved_frame
decl_stmt|;
name|int
name|saved_level
decl_stmt|,
name|within_current_scope
decl_stmt|;
name|value_ptr
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
comment|/* Save the current frame and level so we can restore it after 	     evaluating the watchpoint expression on its own frame.  */
name|saved_frame
operator|=
name|selected_frame
expr_stmt|;
name|saved_level
operator|=
name|selected_frame_level
expr_stmt|;
comment|/* Determine if the watchpoint is within scope.  */
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|==
name|NULL
condition|)
name|within_current_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
comment|/* There might be no current frame at this moment if we are 		 resuming from a step over a breakpoint. 		 Set up current frame before trying to find the watchpoint 		 frame.  */
name|get_current_frame
argument_list|()
expr_stmt|;
name|fi
operator|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|b
operator|->
name|watchpoint_frame
argument_list|)
expr_stmt|;
name|within_current_scope
operator|=
operator|(
name|fi
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|within_current_scope
condition|)
name|select_frame
argument_list|(
name|fi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* Evaluate the expression and cut the chain of values 		 produced off from the value chain.  */
name|v
operator|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
name|value_release_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|b
operator|->
name|val_chain
operator|=
name|v
expr_stmt|;
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
comment|/* Look at each value on the value chain.  */
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
comment|/* If it's a memory location, then we must watch it.  */
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|int
name|addr
decl_stmt|,
name|len
decl_stmt|,
name|type
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
name|type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
name|type
operator|=
literal|2
expr_stmt|;
name|val
operator|=
name|target_insert_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Failure to insert a watchpoint on any memory value in the 		 value chain brings us here.  */
if|if
condition|(
operator|!
name|b
operator|->
name|inserted
condition|)
name|warning
argument_list|(
literal|"Hardware watchpoint %d: Could not insert watchpoint\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\ Hardware watchpoint %d deleted because the program has left the block in\n\ which its expression is valid.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
block|}
comment|/* Restore the frame and level.  */
if|if
condition|(
operator|(
name|saved_frame
operator|!=
name|selected_frame
operator|)
operator|||
operator|(
name|saved_level
operator|!=
name|selected_frame_level
operator|)
condition|)
name|select_and_print_frame
argument_list|(
name|saved_frame
argument_list|,
name|saved_level
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_catch_fork
case|:
name|val
operator|=
name|target_insert_fork_catchpoint
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_vfork
case|:
name|val
operator|=
name|target_insert_vfork_catchpoint
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
name|val
operator|=
name|target_insert_exec_catchpoint
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert catchpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|disabled_breaks
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|remove_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_uninserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|reattach_breakpoints
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|saved_inferior_pid
init|=
name|inferior_pid
decl_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Because remove_breakpoint will use this global. */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_inserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
block|}
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|update_breakpoints_after_exec
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|temp
decl_stmt|;
comment|/* Doing this first prevents the badness of having delete_breakpoint()      write a breakpoint's current "shadow contents" to lift the bp.  That      shadow is NOT valid after an exec()! */
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
comment|/* Solib breakpoints must be explicitly reset after an exec(). */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_shlib_event
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Step-resume breakpoints are meaningless after an exec(). */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_step_resume
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ditto the sigtramp handler breakpoints. */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_through_sigtramp
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ditto the exception-handling catchpoints. */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Don't delete an exec catchpoint, because else the inferior          won't stop when it ought!           Similarly, we probably ought to keep vfork catchpoints, 'cause          on this target, we may not be able to stop when the vfork is seen,          but only when the subsequent exec is seen.  (And because deleting          fork catchpoints here but not vfork catchpoints will seem mysterious          to users, keep those too.)           ??rehrauer: Let's hope that merely clearing out this catchpoint's          target address field, if any, is sufficient to have it be reset          automagically.  Certainly on HP-UX that's true. */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
condition|)
block|{
name|b
operator|->
name|address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* bp_finish is a special case.  The only way we ought to be able          to see one of these when an exec() has happened, is if the user          caught a vfork, and then said "finish".  Ordinarily a finish just          carries them to the call-site of the current callee, by setting          a temporary bp there and resuming.  But in this case, the finish          will carry them entirely through the vfork& exec.           We don't want to allow a bp_finish to remain inserted now.  But          we can't safely delete it, 'cause finish_command has a handle to          the bp on a bpstat, and will later want to delete it.  There's a          chance (and I've seen it happen) that if we delete the bp_finish          here, that its storage will get reused by the time finish_command          gets 'round to deleting the "use to be a bp_finish" breakpoint.          We really must allow finish_command to delete a bp_finish.           In the absense of a general solution for the "how do we know it's          safe to delete something others may have handles to?" problem, what          we'll do here is just uninsert the bp_finish, and let finish_command          delete it.           (We know the bp_finish is "doomed" in the sense that it's momentary,          and will be deleted as soon as finish_command sees the inferior stopped.          So it doesn't matter that the bp's address is probably bogus in the          new a.out, unlike e.g., the solib breakpoints.)  */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_finish
condition|)
block|{
continue|continue;
block|}
comment|/* Without a symbolic address, we have little hope of the          pre-exec() address meaning the same thing in the post-exec()          a.out. */
if|if
condition|(
name|b
operator|->
name|addr_string
operator|==
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this breakpoint has survived the above battery of checks, then          it must have a symbolic address.  Be sure that it gets reevaluated          to a target address, rather than reusing the old evaluation.  */
name|b
operator|->
name|address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|detach_breakpoints
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|saved_inferior_pid
init|=
name|inferior_pid
decl_stmt|;
if|if
condition|(
name|pid
operator|==
name|inferior_pid
condition|)
name|error
argument_list|(
literal|"Cannot detach breakpoints of inferior_pid"
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Because remove_breakpoint will use this global. */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_inserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
block|}
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_breakpoint
parameter_list|(
name|b
parameter_list|,
name|is
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|insertion_state_t
name|is
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_none
condition|)
name|warning
argument_list|(
literal|"attempted to remove apparently deleted breakpoint #%d?\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_throw
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|val
operator|=
name|target_remove_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check to see if breakpoint is in an overlay section; 	     if so, we should remove the breakpoint at the LMA address. 	     If that is not equal to the raw address, then we should  	     presumable remove the breakpoint there as well.  */
if|if
condition|(
name|overlay_debugging
operator|&&
name|b
operator|->
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
comment|/* This would be the time to check val, to see if the 		 shadow breakpoint write to the load address succeeded.   		 However, this might be an ordinary occurrance, eg. if  		 the unmapped overlay is in ROM.  */
name|val
operator|=
literal|0
expr_stmt|;
comment|/* in case unmapped address failed */
if|if
condition|(
name|section_is_mapped
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ordinary (non-overlay) address */
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|value_ptr
name|v
decl_stmt|,
name|n
decl_stmt|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
comment|/* Walk down the saved value chain.  */
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
comment|/* For each memory reference remove the watchpoint 	     at that address.  */
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|int
name|addr
decl_stmt|,
name|len
decl_stmt|,
name|type
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
name|type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
name|type
operator|=
literal|2
expr_stmt|;
name|val
operator|=
name|target_remove_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Failure to remove any of the hardware watchpoints comes here.  */
if|if
condition|(
operator|(
name|is
operator|==
name|mark_uninserted
operator|)
operator|&&
operator|(
name|b
operator|->
name|inserted
operator|)
condition|)
name|warning
argument_list|(
literal|"Hardware watchpoint %d: Could not remove watchpoint\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Free the saved value chain.  We will construct a new one 	 the next time the watchpoint is inserted.  */
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|n
control|)
block|{
name|n
operator|=
name|v
operator|->
name|next
expr_stmt|;
name|value_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|val_chain
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_catch_fork
case|:
name|val
operator|=
name|target_remove_fork_catchpoint
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_vfork
case|:
name|val
operator|=
name|target_remove_vfork_catchpoint
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
name|val
operator|=
name|target_remove_exec_catchpoint
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|&&
name|b
operator|->
name|inserted
comment|/* sometimes previous insert doesn't happen */
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints.  */
end_comment

begin_function
name|void
name|mark_breakpoints_out
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints and delete any breakpoints    which should go away between runs of the program.     Plus other such housekeeping that has to be done for breakpoints    between runs.     Note: this function gets called at the end of a run (by generic_mourn_inferior)    and when a run begins (by init_wait_for_inferior). */
end_comment

begin_function
name|void
name|breakpoint_init_inferior
parameter_list|(
name|context
parameter_list|)
name|enum
name|inf_context
name|context
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
specifier|static
name|int
name|warning_needed
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_call_dummy
case|:
case|case
name|bp_watchpoint_scope
case|:
comment|/* If the call dummy breakpoint is at the entry point it will 	     cause problems when the inferior is rerun, so we better 	     get rid of it.   	     Also get rid of scope breakpoints.  */
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
comment|/* Likewise for watchpoints on local expressions.  */
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Likewise for exception catchpoints in dynamic-linked          executables where required */
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|&&
name|exception_catchpoints_are_fragile
condition|)
block|{
name|warning_needed
operator|=
literal|1
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|exception_catchpoints_are_fragile
condition|)
name|exception_support_initialized
operator|=
literal|0
expr_stmt|;
comment|/* Don't issue the warning unless it's really needed... */
if|if
condition|(
name|warning_needed
operator|&&
operator|(
name|context
operator|!=
name|inf_exited
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Exception catchpoints from last run were deleted, you must reinsert them explicitly"
argument_list|)
expr_stmt|;
name|warning_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* breakpoint_here_p (PC) returns 1 if an enabled breakpoint exists at PC.    When continuing from a location with a breakpoint,    we actually single step once before calling insert_breakpoints.  */
end_comment

begin_function
name|int
name|breakpoint_here_p
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|call_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* bp is enabled and matches pc */
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* breakpoint_inserted_here_p (PC) is just like breakpoint_here_p(), but it    only returns true if there is actually a breakpoint inserted at PC.  */
end_comment

begin_function
name|int
name|breakpoint_inserted_here_p
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|inserted
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* bp is inserted and matches pc */
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FRAME is a dummy frame.  We can't use PC_IN_CALL_DUMMY    because figuring out the saved SP would take too much time, at least using    get_saved_register on the 68k.  This means that for this function to    work right a port must use the bp_call_dummy breakpoint.  */
end_comment

begin_function
name|int
name|frame_in_dummy
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CALL_DUMMY
ifdef|#
directive|ifdef
name|USE_GENERIC_DUMMY_FRAMES
return|return
name|generic_pc_in_call_dummy
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
return|;
else|#
directive|else
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
specifier|static
name|ULONGEST
name|dummy
index|[]
init|=
name|CALL_DUMMY
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_call_dummy
operator|&&
name|b
operator|->
name|frame
operator|==
name|frame
operator|->
name|frame
comment|/* We need to check the PC as well as the frame on the sparc, 	     for signals.exp in the testsuite.  */
operator|&&
operator|(
name|frame
operator|->
name|pc
operator|>=
operator|(
name|b
operator|->
name|address
operator|-
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|REGISTER_SIZE
operator|)
operator|)
operator|&&
name|frame
operator|->
name|pc
operator|<=
name|b
operator|->
name|address
condition|)
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* GENERIC_DUMMY_FRAMES */
endif|#
directive|endif
comment|/* CALL_DUMMY */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* breakpoint_match_thread (PC, PID) returns true if the breakpoint at PC    is valid for process/thread PID.  */
end_comment

begin_function
name|int
name|breakpoint_thread_match
parameter_list|(
name|pc
parameter_list|,
name|pid
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|call_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
operator|&&
operator|(
name|b
operator|->
name|thread
operator|==
operator|-
literal|1
operator|||
name|b
operator|->
name|thread
operator|==
name|thread
operator|)
condition|)
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|b
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* bpstat stuff.  External routines' interfaces are documented    in breakpoint.h.  */
end_comment

begin_function
name|int
name|ep_is_catchpoint
parameter_list|(
name|ep
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|ep
decl_stmt|;
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_unload
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
comment|/* ??rehrauer: Add more kinds here, as are implemented... */
return|;
block|}
end_function

begin_function
name|int
name|ep_is_shlib_catchpoint
parameter_list|(
name|ep
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|ep
decl_stmt|;
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_unload
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ep_is_exception_catchpoint
parameter_list|(
name|ep
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|ep
decl_stmt|;
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear a bpstat so that it says we are not at any breakpoint.    Also free any storage that is part of a bpstat.  */
end_comment

begin_function
name|void
name|bpstat_clear
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|bpstat
name|p
decl_stmt|;
name|bpstat
name|q
decl_stmt|;
if|if
condition|(
name|bsp
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|*
name|bsp
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|old_val
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|p
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
operator|*
name|bsp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a copy of a bpstat.  Like "bs1 = bs2" but all storage that    is part of the bpstat is copied as well.  */
end_comment

begin_function
name|bpstat
name|bpstat_copy
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
name|bpstat
name|p
init|=
name|NULL
decl_stmt|;
name|bpstat
name|tmp
decl_stmt|;
name|bpstat
name|retval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
return|return
name|bs
return|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|tmp
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|bs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* This is the first thing in the chain.  */
name|retval
operator|=
name|tmp
expr_stmt|;
else|else
name|p
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Find the bpstat associated with this breakpoint */
end_comment

begin_function
name|bpstat
name|bpstat_find_breakpoint
parameter_list|(
name|bsp
parameter_list|,
name|breakpoint
parameter_list|)
name|bpstat
name|bsp
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
block|{
if|if
condition|(
name|bsp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|bsp
operator|!=
name|NULL
condition|;
name|bsp
operator|=
name|bsp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bsp
operator|->
name|breakpoint_at
operator|==
name|breakpoint
condition|)
return|return
name|bsp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find a step_resume breakpoint associated with this bpstat.    (If there are multiple step_resume bp's on the list, this function    will arbitrarily pick one.)     It is an error to use this function if BPSTAT doesn't contain a    step_resume breakpoint.     See wait_for_inferior's use of this function.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|bpstat_find_step_resume_breakpoint
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
name|bsp
decl_stmt|;
block|{
if|if
condition|(
name|bsp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error (bpstat_find_step_resume_breakpoint)"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bsp
operator|!=
name|NULL
condition|;
name|bsp
operator|=
name|bsp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bsp
operator|->
name|breakpoint_at
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bsp
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_step_resume
operator|)
condition|)
return|return
name|bsp
operator|->
name|breakpoint_at
return|;
block|}
name|error
argument_list|(
literal|"Internal error (no step_resume breakpoint found)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the breakpoint number of the first breakpoint we are stopped    at.  *BSP upon return is a bpstat which points to the remaining    breakpoints stopped at (but which is not guaranteed to be good for    anything but further calls to bpstat_num).    Return 0 if passed a bpstat which does not indicate any breakpoints.  */
end_comment

begin_function
name|int
name|bpstat_num
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|bsp
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* No more breakpoint values */
else|else
block|{
name|b
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|breakpoint_at
expr_stmt|;
operator|*
name|bsp
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* breakpoint that's been deleted since */
else|else
return|return
name|b
operator|->
name|number
return|;
comment|/* We have its number */
block|}
block|}
end_function

begin_comment
comment|/* Modify BS so that the actions will not be performed.  */
end_comment

begin_function
name|void
name|bpstat_clear_actions
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Stub for cleaning up our state if we error-out of a breakpoint command */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|cleanup_executing_breakpoints
parameter_list|(
name|ignore
parameter_list|)
name|PTR
name|ignore
decl_stmt|;
block|{
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute all the commands associated with all the breakpoints at this    location.  Any of these commands could cause the process to proceed    beyond this point, etc.  We look out for such changes by checking    the global "breakpoint_proceeded" after each command.  */
end_comment

begin_function
name|void
name|bpstat_do_actions
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|bpstat
name|bs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
comment|/* Avoid endless recursion if a `source' command is contained      in bs->commands.  */
if|if
condition|(
name|executing_breakpoint_commands
condition|)
return|return;
name|executing_breakpoint_commands
operator|=
literal|1
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|cleanup_executing_breakpoints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top
label|:
comment|/* Note that (as of this writing), our callers all appear to      be passing us the address of global stop_bpstat.  And, if      our calls to execute_control_command cause the inferior to      proceed, that global (and hence, *bsp) will change.       We must be careful to not touch *bsp unless the inferior      has not proceeded. */
comment|/* This pointer will iterate over the list of bpstat's. */
name|bs
operator|=
operator|*
name|bsp
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|cmd
operator|=
name|bs
operator|->
name|commands
expr_stmt|;
while|while
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
name|execute_control_command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_proceeded
condition|)
break|break;
else|else
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|breakpoint_proceeded
condition|)
comment|/* The inferior is proceeded by the command; bomb out now. 	   The bpstat chain has been blown away by wait_for_inferior. 	   But since execution has stopped again, there is a new bpstat 	   to look at, so start over.  */
goto|goto
name|top
goto|;
else|else
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
block|}
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the normal print_it function for a bpstat.  In the future,    much of this logic could (should?) be moved to bpstat_stop_status,    by having it set different print_it functions.     Current scheme: When we stop, bpstat_print() is called.    It loops through the bpstat list of things causing this stop,    calling the print_it function for each one. The default    print_it function, used for breakpoints, is print_it_normal().    (Also see print_it_noop() and print_it_done()).        Return values from this routine (used by bpstat_print() to    decide what to do):    1: Means we printed something, and we do *not* desire that       something to be followed by a location.    0: Means we printed something, and we *do*  desire that       something to be followed by a location.    -1: Means we printed nothing.  */
end_comment

begin_function
specifier|static
name|int
name|print_it_normal
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
comment|/* bs->breakpoint_at can be NULL if it was a momentary breakpoint      which has since been deleted.  */
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
operator|||
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_breakpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_load
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_unload
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_catch_throw
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ep_is_shlib_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d ("
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_load
condition|)
name|printf_filtered
argument_list|(
literal|"loaded"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_unload
condition|)
name|printf_filtered
argument_list|(
literal|"unloaded"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_fork
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_vfork
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d ("
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_fork
condition|)
name|printf_filtered
argument_list|(
literal|"forked"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_vfork
condition|)
name|printf_filtered
argument_list|(
literal|"vforked"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" process %d), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|forked_inferior_pid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_exec
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exec'd %s), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|exec_pathname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_catch
condition|)
block|{
if|if
condition|(
name|current_exception_event
operator|&&
operator|(
name|CURRENT_EXCEPTION_KIND
operator|==
name|EX_EVENT_CATCH
operator|)
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exception caught), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"throw location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_THROW_PC
operator|&&
name|CURRENT_EXCEPTION_THROW_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_THROW_FILE
argument_list|,
name|CURRENT_EXCEPTION_THROW_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", catch location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_CATCH_PC
operator|&&
name|CURRENT_EXCEPTION_CATCH_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_CATCH_FILE
argument_list|,
name|CURRENT_EXCEPTION_CATCH_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* don't bother to print location frame info */
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
comment|/* really throw, some other bpstat will handle it */
block|}
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_catch_throw
condition|)
block|{
if|if
condition|(
name|current_exception_event
operator|&&
operator|(
name|CURRENT_EXCEPTION_KIND
operator|==
name|EX_EVENT_THROW
operator|)
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exception thrown), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"throw location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_THROW_PC
operator|&&
name|CURRENT_EXCEPTION_THROW_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_THROW_FILE
argument_list|,
name|CURRENT_EXCEPTION_THROW_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", catch location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_CATCH_PC
operator|&&
name|CURRENT_EXCEPTION_CATCH_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_CATCH_FILE
argument_list|,
name|CURRENT_EXCEPTION_CATCH_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* don't bother to print location frame info */
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
comment|/* really catch, some other bpstat willhandle it */
block|}
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_breakpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
comment|/* I think the user probably only wants to see one breakpoint 	 number, not all of them.  */
name|annotate_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nBreakpoint %d, "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
condition|)
block|{
name|annotate_watchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nOld value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|old_val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nNew value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
comment|/* More than one watchpoint may have been triggered.  */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
block|{
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nValue = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* We can't deal with it.  Maybe another member of the bpstat chain can.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a message indicating what happened.    This is called from normal_stop().    The input to this routine is the head of the bpstat list - a list    of the eventpoints that caused this stop.    This routine calls the "print_it" routine(s) associated    with these eventpoints. This will print (for example)    the "Breakpoint n," part of the output.    The return value of this routine is one of:     -1: Means we printed nothing    0: Means we printed something, and expect subsequent       code to print the location. An example is        "Breakpoint 1, " which should be followed by       the location.    1 : Means we printed something, but there is no need        to also print the location part of the message.        An example is the catch/throw messages, which        don't require a location appended to the end.  */
end_comment

begin_function
name|int
name|bpstat_print
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
call|(
modifier|*
name|bs
operator|->
name|print_it
call|)
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Maybe another breakpoint in the chain caused us to stop.      (Currently all watchpoints go on the bpstat whether hit or      not.  That probably could (should) be changed, provided care is taken      with respect to bpstat_explains_signal).  */
if|if
condition|(
name|bs
operator|->
name|next
condition|)
return|return
name|bpstat_print
argument_list|(
name|bs
operator|->
name|next
argument_list|)
return|;
comment|/* We reached the end of the chain without printing anything.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the expression EXP and return 1 if value is zero.    This is used inside a catch_errors to evaluate the breakpoint condition.     The argument is a "struct expression *" that has been cast to char * to     make it pass through catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_cond_eval
parameter_list|(
name|exp
parameter_list|)
name|PTR
name|exp
decl_stmt|;
block|{
name|value_ptr
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|!
name|value_true
argument_list|(
name|evaluate_expression
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new bpstat and chain it to the current one.  */
end_comment

begin_function
specifier|static
name|bpstat
name|bpstat_alloc
parameter_list|(
name|b
parameter_list|,
name|cbs
parameter_list|)
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|bpstat
name|cbs
decl_stmt|;
comment|/* Current "bs" value */
block|{
name|bpstat
name|bs
decl_stmt|;
name|bs
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|cbs
operator|->
name|next
operator|=
name|bs
expr_stmt|;
name|bs
operator|->
name|breakpoint_at
operator|=
name|b
expr_stmt|;
comment|/* If the condition is false, etc., don't do the commands.  */
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|print_it
operator|=
name|print_it_normal
expr_stmt|;
return|return
name|bs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Possible return values for watchpoint_check (this can't be an enum    because of check_errors).  */
end_comment

begin_comment
comment|/* The watchpoint has been deleted.  */
end_comment

begin_define
define|#
directive|define
name|WP_DELETED
value|1
end_define

begin_comment
comment|/* The value has changed.  */
end_comment

begin_define
define|#
directive|define
name|WP_VALUE_CHANGED
value|2
end_define

begin_comment
comment|/* The value has not changed.  */
end_comment

begin_define
define|#
directive|define
name|WP_VALUE_NOT_CHANGED
value|3
end_define

begin_define
define|#
directive|define
name|BP_TEMPFLAG
value|1
end_define

begin_define
define|#
directive|define
name|BP_HARDWAREFLAG
value|2
end_define

begin_comment
comment|/* Check watchpoint condition.  */
end_comment

begin_function
specifier|static
name|int
name|watchpoint_check
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|bpstat
name|bs
init|=
operator|(
name|bpstat
operator|)
name|p
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fr
decl_stmt|;
name|int
name|within_current_scope
decl_stmt|;
name|b
operator|=
name|bs
operator|->
name|breakpoint_at
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|==
name|NULL
condition|)
name|within_current_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* There is no current frame at this moment.  If we're going to have 	 any chance of handling watchpoints on local variables, we'll need 	 the frame chain (so we can determine if we're in scope).  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|fr
operator|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|b
operator|->
name|watchpoint_frame
argument_list|)
expr_stmt|;
name|within_current_scope
operator|=
operator|(
name|fr
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|within_current_scope
condition|)
comment|/* If we end up stopping, the current frame will get selected 	   in normal_stop.  So this call to select_frame won't affect 	   the user.  */
name|select_frame
argument_list|(
name|fr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* We use value_{,free_to_}mark because it could be a          *long* time before we return to the command level and 	 call free_all_values.  We can't call free_all_values because 	 we might be in the middle of evaluating a function call.  */
name|value_ptr
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|value_ptr
name|new_val
init|=
name|evaluate_expression
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value_equal
argument_list|(
name|b
operator|->
name|val
argument_list|,
name|new_val
argument_list|)
condition|)
block|{
name|release_value
argument_list|(
name|new_val
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|b
operator|->
name|val
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|new_val
expr_stmt|;
comment|/* We will stop here */
return|return
name|WP_VALUE_CHANGED
return|;
block|}
else|else
block|{
comment|/* Nothing changed, don't do anything.  */
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
comment|/* We won't stop here */
return|return
name|WP_VALUE_NOT_CHANGED
return|;
block|}
block|}
else|else
block|{
comment|/* This seems like the only logical thing to do because 	 if we temporarily ignored the watchpoint, then when 	 we reenter the block in which it is valid it contains 	 garbage (in the case of a function, it may have two 	 garbage values, one before and one after the prologue). 	 So we can't even detect the first assignment to it and 	 watch after that (since the garbage may or may not equal 	 the first value assigned).  */
name|printf_filtered
argument_list|(
literal|"\ Watchpoint %d deleted because the program has left the block in\n\ which its expression is valid.\n"
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
return|return
name|WP_DELETED
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is used when everything which needs to be printed has    already been printed.  But we still want to print the frame.  */
end_comment

begin_comment
comment|/* Background: When we stop, bpstat_print() is called.    It loops through the bpstat list of things causing this stop,    calling the print_it function for each one. The default    print_it function, used for breakpoints, is print_it_normal().    Also see print_it_noop() and print_it_done() are the other     two possibilities. See comments in bpstat_print() and    in header of print_it_normal() for more detail.  */
end_comment

begin_function
specifier|static
name|int
name|print_it_done
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is used when nothing should be printed for this bpstat entry.  */
end_comment

begin_comment
comment|/* Background: When we stop, bpstat_print() is called.    It loops through the bpstat list of things causing this stop,    calling the print_it function for each one. The default    print_it function, used for breakpoints, is print_it_normal().    Also see print_it_noop() and print_it_done() are the other     two possibilities. See comments in bpstat_print() and    in header of print_it_normal() for more detail.  */
end_comment

begin_function
specifier|static
name|int
name|print_it_noop
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a bpstat associated with having just stopped at address *PC    and frame address CORE_ADDRESS.  Update *PC to point at the    breakpoint (if we hit a breakpoint).  NOT_A_BREAKPOINT is nonzero    if this is known to not be a real breakpoint (it could still be a    watchpoint, though).  */
end_comment

begin_comment
comment|/* Determine whether we stopped at a breakpoint, etc, or whether we    don't understand this stop.  Result is a chain of bpstat's such that:  	if we don't understand the stop, the result is a null pointer.  	if we understand why we stopped, the result is not null.  	Each element of the chain refers to a particular breakpoint or 	watchpoint at which we have stopped.  (We may have stopped for 	several reasons concurrently.)  	Each element of the chain has valid next, breakpoint_at, 	commands, FIXME??? fields.  */
end_comment

begin_function
name|bpstat
name|bpstat_stop_status
parameter_list|(
name|pc
parameter_list|,
name|not_a_breakpoint
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
name|int
name|not_a_breakpoint
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|CORE_ADDR
name|bp_addr
decl_stmt|;
comment|/* True if we've hit a breakpoint (as opposed to a watchpoint).  */
name|int
name|real_breakpoint
init|=
literal|0
decl_stmt|;
comment|/* Root of the chain of bpstat's */
name|struct
name|bpstats
name|root_bs
index|[
literal|1
index|]
decl_stmt|;
comment|/* Pointer to the last thing in the chain currently.  */
name|bpstat
name|bs
init|=
name|root_bs
decl_stmt|;
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error evaluating expression for watchpoint %d\n"
decl_stmt|;
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
comment|/* slop */
index|]
decl_stmt|;
comment|/* Get the address where the breakpoint would have been.  */
name|bp_addr
operator|=
operator|*
name|pc
operator|-
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|disabled
operator|||
name|b
operator|->
name|enable
operator|==
name|shlib_disabled
operator|||
name|b
operator|->
name|enable
operator|==
name|call_disabled
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_throw
condition|)
comment|/* a non-watchpoint bp */
if|if
condition|(
name|b
operator|->
name|address
operator|!=
name|bp_addr
operator|||
comment|/* address doesn't match or */
operator|(
name|overlay_debugging
operator|&&
comment|/* overlay doesn't match */
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|b
operator|->
name|section
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|address
operator|!=
operator|(
operator|*
name|pc
operator|-
name|DECR_PC_AFTER_HW_BREAK
operator|)
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|not_a_breakpoint
condition|)
continue|continue;
comment|/* Is this a catchpoint of a load or unload?  If so, did we          get a load or unload of the specified library?  If not,          ignore it. */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_HAVE_LOAD_EVENT
argument_list|)
operator|&&
operator|(
operator|!
name|SOLIB_HAVE_LOAD_EVENT
argument_list|(
name|inferior_pid
argument_list|)
operator|||
operator|(
operator|(
name|b
operator|->
name|dll_pathname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|dll_pathname
argument_list|,
name|SOLIB_LOADED_LIBRARY_PATHNAME
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_unload
operator|)
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_HAVE_UNLOAD_EVENT
argument_list|)
operator|&&
operator|(
operator|!
name|SOLIB_HAVE_UNLOAD_EVENT
argument_list|(
name|inferior_pid
argument_list|)
operator|||
operator|(
operator|(
name|b
operator|->
name|dll_pathname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|dll_pathname
argument_list|,
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
operator|&&
operator|!
name|target_has_forked
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|b
operator|->
name|forked_inferior_pid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|)
operator|&&
operator|!
name|target_has_vforked
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|b
operator|->
name|forked_inferior_pid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|&&
operator|!
name|target_has_execd
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|b
operator|->
name|exec_pathname
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|&&
operator|!
operator|(
name|current_exception_event
operator|=
name|target_get_current_exception_event
argument_list|()
operator|)
condition|)
continue|continue;
comment|/* Come here if it's a watchpoint, or if the break address matches */
name|bs
operator|=
name|bpstat_alloc
argument_list|(
name|b
argument_list|,
name|bs
argument_list|)
expr_stmt|;
comment|/* Alloc a bpstat to explain stop */
comment|/* Watchpoints may change this, if not found to have triggered. */
name|bs
operator|->
name|stop
operator|=
literal|1
expr_stmt|;
name|bs
operator|->
name|print
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
condition|)
block|{
switch|switch
condition|(
name|catch_errors
argument_list|(
name|watchpoint_check
argument_list|,
name|bs
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
case|case
name|WP_DELETED
case|:
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_CHANGED
case|:
comment|/* Stop.  */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
break|break;
case|case
name|WP_VALUE_NOT_CHANGED
case|:
comment|/* Don't stop.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
comment|/* Don't consider this a hit.  */
operator|--
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
continue|continue;
default|default:
comment|/* Can't happen.  */
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* Error from catch_errors.  */
name|printf_filtered
argument_list|(
literal|"Watchpoint %d deleted.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|target_stopped_data_address
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|CORE_ADDR
name|vaddr
decl_stmt|;
name|vaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|vaddr
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
switch|switch
condition|(
name|catch_errors
argument_list|(
name|watchpoint_check
argument_list|,
name|bs
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
case|case
name|WP_DELETED
case|:
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_CHANGED
case|:
case|case
name|WP_VALUE_NOT_CHANGED
case|:
comment|/* Stop.  */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Can't happen.  */
case|case
literal|0
case|:
comment|/* Error from catch_errors.  */
name|printf_filtered
argument_list|(
literal|"Watchpoint %d deleted.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|del_at_next_stop
expr_stmt|;
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* By definition, an encountered breakpoint is a triggered              breakpoint. */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
name|real_breakpoint
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|frame
operator|&&
name|b
operator|->
name|frame
operator|!=
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|frame
operator|&&
operator|(
name|b
operator|->
name|type
operator|==
name|bp_step_resume
operator|&&
operator|(
name|INNER_THAN
argument_list|(
name|get_current_frame
argument_list|()
operator|->
name|frame
argument_list|,
name|b
operator|->
name|frame
argument_list|)
operator|)
operator|)
condition|)
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|value_is_zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
comment|/* Need to select the frame, with all that implies 		 so that the conditions will have the right context.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value_is_zero
operator|=
name|catch_errors
argument_list|(
name|breakpoint_cond_eval
argument_list|,
operator|(
name|b
operator|->
name|cond
operator|)
argument_list|,
literal|"Error in testing breakpoint condition:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* FIXME-someday, should give breakpoint # */
name|free_all_values
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
operator|&&
name|value_is_zero
condition|)
block|{
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
comment|/* Don't consider this a hit.  */
operator|--
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|ignore_count
operator|>
literal|0
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|--
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We will stop here */
if|if
condition|(
name|b
operator|->
name|disposition
operator|==
name|disable
condition|)
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|bs
operator|->
name|commands
operator|=
name|b
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|silent
condition|)
name|bs
operator|->
name|print
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|commands
operator|&&
operator|(
name|STREQ
argument_list|(
literal|"silent"
argument_list|,
name|bs
operator|->
name|commands
operator|->
name|line
argument_list|)
operator|||
operator|(
name|xdb_commands
operator|&&
name|STREQ
argument_list|(
literal|"Q"
argument_list|,
name|bs
operator|->
name|commands
operator|->
name|line
argument_list|)
operator|)
operator|)
condition|)
block|{
name|bs
operator|->
name|commands
operator|=
name|bs
operator|->
name|commands
operator|->
name|next
expr_stmt|;
name|bs
operator|->
name|print
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Print nothing for this entry if we dont stop or if we dont print.  */
if|if
condition|(
name|bs
operator|->
name|stop
operator|==
literal|0
operator|||
name|bs
operator|->
name|print
operator|==
literal|0
condition|)
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
block|}
name|bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Terminate the chain */
name|bs
operator|=
name|root_bs
operator|->
name|next
expr_stmt|;
comment|/* Re-grab the head of the chain */
if|if
condition|(
name|real_breakpoint
operator|&&
name|bs
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
if|if
condition|(
name|DECR_PC_AFTER_HW_BREAK
operator|!=
literal|0
condition|)
block|{
operator|*
name|pc
operator|=
operator|*
name|pc
operator|-
name|DECR_PC_AFTER_HW_BREAK
expr_stmt|;
name|write_pc
argument_list|(
operator|*
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|must_shift_inst_regs
condition|)
block|{
operator|*
name|pc
operator|=
name|bp_addr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
name|SHIFT_INST_REGS
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* No SHIFT_INST_REGS.  */
name|write_pc
argument_list|(
name|bp_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No SHIFT_INST_REGS.  */
block|}
block|}
block|}
comment|/* The value of a hardware watchpoint hasn't changed, but the      intermediate memory locations we are watching may have.  */
if|if
condition|(
name|bs
operator|&&
operator|!
name|bs
operator|->
name|stop
operator|&&
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
condition|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
return|return
name|bs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell what to do about this bpstat.  */
end_comment

begin_function
name|struct
name|bpstat_what
name|bpstat_what
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
comment|/* Classify each bpstat as one of the following.  */
enum|enum
name|class
block|{
comment|/* This bpstat element has no effect on the main_action.  */
name|no_effect
init|=
literal|0
block|,
comment|/* There was a watchpoint, stop but don't print.  */
name|wp_silent
block|,
comment|/* There was a watchpoint, stop and print.  */
name|wp_noisy
block|,
comment|/* There was a breakpoint but we're not stopping.  */
name|bp_nostop
block|,
comment|/* There was a breakpoint, stop but don't print.  */
name|bp_silent
block|,
comment|/* There was a breakpoint, stop and print.  */
name|bp_noisy
block|,
comment|/* We hit the longjmp breakpoint.  */
name|long_jump
block|,
comment|/* We hit the longjmp_resume breakpoint.  */
name|long_resume
block|,
comment|/* We hit the step_resume breakpoint.  */
name|step_resume
block|,
comment|/* We hit the through_sigtramp breakpoint.  */
name|through_sig
block|,
comment|/* We hit the shared library event breakpoint.  */
name|shlib_event
block|,
comment|/* We caught a shared library event.  */
name|catch_shlib_event
block|,
comment|/* This is just used to count how many enums there are.  */
name|class_last
block|}
enum|;
comment|/* Here is the table which drives this routine.  So that we can      format it pretty, we define some abbreviations for the      enum bpstat_what codes.  */
define|#
directive|define
name|kc
value|BPSTAT_WHAT_KEEP_CHECKING
define|#
directive|define
name|ss
value|BPSTAT_WHAT_STOP_SILENT
define|#
directive|define
name|sn
value|BPSTAT_WHAT_STOP_NOISY
define|#
directive|define
name|sgl
value|BPSTAT_WHAT_SINGLE
define|#
directive|define
name|slr
value|BPSTAT_WHAT_SET_LONGJMP_RESUME
define|#
directive|define
name|clr
value|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
define|#
directive|define
name|clrs
value|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
define|#
directive|define
name|sr
value|BPSTAT_WHAT_STEP_RESUME
define|#
directive|define
name|ts
value|BPSTAT_WHAT_THROUGH_SIGTRAMP
define|#
directive|define
name|shl
value|BPSTAT_WHAT_CHECK_SHLIBS
define|#
directive|define
name|shlr
value|BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
comment|/* "Can't happen."  Might want to print an error message.    abort() is not out of the question, but chances are GDB is just    a bit confused, not unusable.  */
define|#
directive|define
name|err
value|BPSTAT_WHAT_STOP_NOISY
comment|/* Given an old action and a class, come up with a new action.  */
comment|/* One interesting property of this table is that wp_silent is the same      as bp_silent and wp_noisy is the same as bp_noisy.  That is because      after stopping, the check for whether to step over a breakpoint      (BPSTAT_WHAT_SINGLE type stuff) is handled in proceed() without      reference to how we stopped.  We retain separate wp_silent and bp_silent      codes in case we want to change that someday.  */
comment|/* step_resume entries: a step resume breakpoint overrides another      breakpoint of signal handling (see comment in wait_for_inferior      at first IN_SIGTRAMP where we set the step_resume breakpoint).  */
comment|/* We handle the through_sigtramp_breakpoint the same way; having both      one of those and a step_resume_breakpoint is probably very rare (?).  */
specifier|static
specifier|const
name|enum
name|bpstat_what_main_action
name|table
index|[
operator|(
name|int
operator|)
name|class_last
index|]
index|[
operator|(
name|int
operator|)
name|BPSTAT_WHAT_LAST
index|]
init|=
block|{
comment|/*                              old action */
comment|/*       kc    ss    sn    sgl    slr   clr    clrs   sr    ts   shl   shlr          */
comment|/*no_effect*/
block|{
name|kc
block|,
name|ss
block|,
name|sn
block|,
name|sgl
block|,
name|slr
block|,
name|clr
block|,
name|clrs
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*wp_silent*/
block|{
name|ss
block|,
name|ss
block|,
name|sn
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*wp_noisy*/
block|{
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*bp_nostop*/
block|{
name|sgl
block|,
name|ss
block|,
name|sn
block|,
name|sgl
block|,
name|slr
block|,
name|clrs
block|,
name|clrs
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*bp_silent*/
block|{
name|ss
block|,
name|ss
block|,
name|sn
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*bp_noisy*/
block|{
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*long_jump*/
block|{
name|slr
block|,
name|ss
block|,
name|sn
block|,
name|slr
block|,
name|err
block|,
name|err
block|,
name|err
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*long_resume*/
block|{
name|clr
block|,
name|ss
block|,
name|sn
block|,
name|clrs
block|,
name|err
block|,
name|err
block|,
name|err
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*step_resume*/
block|{
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*through_sig*/
block|{
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*shlib*/
block|{
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*catch_shlib*/
block|{
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|ts
block|,
name|shlr
block|,
name|shlr
block|}
block|}
decl_stmt|;
undef|#
directive|undef
name|kc
undef|#
directive|undef
name|ss
undef|#
directive|undef
name|sn
undef|#
directive|undef
name|sgl
undef|#
directive|undef
name|slr
undef|#
directive|undef
name|clr
undef|#
directive|undef
name|clrs
undef|#
directive|undef
name|err
undef|#
directive|undef
name|sr
undef|#
directive|undef
name|ts
undef|#
directive|undef
name|shl
undef|#
directive|undef
name|shlr
name|enum
name|bpstat_what_main_action
name|current_action
init|=
name|BPSTAT_WHAT_KEEP_CHECKING
decl_stmt|;
name|struct
name|bpstat_what
name|retval
decl_stmt|;
name|retval
operator|.
name|call_dummy
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|enum
name|class
name|bs_class
init|=
name|no_effect
decl_stmt|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
condition|)
comment|/* I suspect this can happen if it was a momentary breakpoint 	   which has since been deleted.  */
continue|continue;
switch|switch
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
continue|continue;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|bp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
block|}
else|else
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|wp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|wp_silent
expr_stmt|;
block|}
else|else
comment|/* There was a watchpoint, but we're not stopping.  This requires 	       no further action.  */
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_longjmp
case|:
name|bs_class
operator|=
name|long_jump
expr_stmt|;
break|break;
case|case
name|bp_longjmp_resume
case|:
name|bs_class
operator|=
name|long_resume
expr_stmt|;
break|break;
case|case
name|bp_step_resume
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
name|bs_class
operator|=
name|step_resume
expr_stmt|;
block|}
else|else
comment|/* It is for the wrong frame.  */
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_through_sigtramp
case|:
name|bs_class
operator|=
name|through_sig
expr_stmt|;
break|break;
case|case
name|bp_watchpoint_scope
case|:
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_shlib_event
case|:
name|bs_class
operator|=
name|shlib_event
expr_stmt|;
break|break;
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
comment|/* Only if this catchpoint triggered should we cause the              step-out-of-dld behaviour.  Otherwise, we ignore this              catchpoint.  */
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
name|bs_class
operator|=
name|catch_shlib_event
expr_stmt|;
else|else
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|bp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
block|}
else|else
comment|/* There was a catchpoint, but we're not stopping.  This requires                no further action.  */
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
if|if
condition|(
operator|!
name|bs
operator|->
name|stop
operator|||
name|CURRENT_EXCEPTION_KIND
operator|!=
name|EX_EVENT_CATCH
condition|)
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
name|bs_class
operator|=
name|bs
operator|->
name|print
condition|?
name|bp_noisy
else|:
name|bp_silent
expr_stmt|;
break|break;
case|case
name|bp_catch_throw
case|:
if|if
condition|(
operator|!
name|bs
operator|->
name|stop
operator|||
name|CURRENT_EXCEPTION_KIND
operator|!=
name|EX_EVENT_THROW
condition|)
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
name|bs_class
operator|=
name|bs
operator|->
name|print
condition|?
name|bp_noisy
else|:
name|bp_silent
expr_stmt|;
break|break;
case|case
name|bp_call_dummy
case|:
comment|/* Make sure the action is stop (silent or noisy), so infrun.c 	     pops the dummy frame.  */
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
name|retval
operator|.
name|call_dummy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|current_action
operator|=
name|table
index|[
operator|(
name|int
operator|)
name|bs_class
index|]
index|[
operator|(
name|int
operator|)
name|current_action
index|]
expr_stmt|;
block|}
name|retval
operator|.
name|main_action
operator|=
name|current_action
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we should step constantly (e.g. watchpoints on machines    without hardware support).  This isn't related to a specific bpstat,    just to things like whether watchpoints are set.  */
end_comment

begin_function
name|int
name|bpstat_should_step
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if there are enabled hardware watchpoints. */
end_comment

begin_function
name|int
name|bpstat_have_active_hw_watchpoints
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
operator|(
name|b
operator|->
name|enable
operator|==
name|enabled
operator|)
operator|&&
operator|(
name|b
operator|->
name|inserted
operator|)
operator|&&
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a bpstat that records zero or more triggered eventpoints, this    function returns another bpstat which contains only the catchpoints    on that first list, if any. */
end_comment

begin_function
name|void
name|bpstat_get_triggered_catchpoints
parameter_list|(
name|ep_list
parameter_list|,
name|cp_list
parameter_list|)
name|bpstat
name|ep_list
decl_stmt|;
name|bpstat
modifier|*
name|cp_list
decl_stmt|;
block|{
name|struct
name|bpstats
name|root_bs
index|[
literal|1
index|]
decl_stmt|;
name|bpstat
name|bs
init|=
name|root_bs
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|dll_pathname
decl_stmt|;
name|bpstat_clear
argument_list|(
name|cp_list
argument_list|)
expr_stmt|;
name|root_bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|ep_list
operator|!=
name|NULL
condition|;
name|ep_list
operator|=
name|ep_list
operator|->
name|next
control|)
block|{
comment|/* Is this eventpoint a catchpoint?  If not, ignore it. */
name|ep
operator|=
name|ep_list
operator|->
name|breakpoint_at
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_load
operator|)
operator|&&
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_unload
operator|)
operator|&&
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|)
operator|&&
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_throw
operator|)
condition|)
comment|/* pai: (temp) ADD fork/vfork here!!  */
continue|continue;
comment|/* Yes; add it to the list. */
name|bs
operator|=
name|bpstat_alloc
argument_list|(
name|ep
argument_list|,
name|bs
argument_list|)
expr_stmt|;
operator|*
name|bs
operator|=
operator|*
name|ep_list
expr_stmt|;
name|bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bs
operator|=
name|root_bs
operator|->
name|next
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
comment|/* Also, for each triggered catchpoint, tag it with the name of          the library that caused this trigger.  (We copy the name now,          because it's only guaranteed to be available NOW, when the          catchpoint triggers.  Clients who may wish to know the name          later must get it from the catchpoint itself.) */
if|if
condition|(
name|ep
operator|->
name|triggered_dll_pathname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_load
condition|)
name|dll_pathname
operator|=
name|SOLIB_LOADED_LIBRARY_PATHNAME
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
else|else
name|dll_pathname
operator|=
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
else|#
directive|else
name|dll_pathname
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dll_pathname
condition|)
block|{
name|ep
operator|->
name|triggered_dll_pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dll_pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ep
operator|->
name|triggered_dll_pathname
argument_list|,
name|dll_pathname
argument_list|)
expr_stmt|;
block|}
else|else
name|ep
operator|->
name|triggered_dll_pathname
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|cp_list
operator|=
name|bs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print information on breakpoint number BNUM, or -1 if all.    If WATCHPOINTS is zero, process only breakpoints; if WATCHPOINTS    is nonzero, process only watchpoints.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|enum
name|bptype
name|type
decl_stmt|;
name|char
modifier|*
name|description
decl_stmt|;
block|}
name|ep_type_description_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|breakpoint_1
parameter_list|(
name|bnum
parameter_list|,
name|allflag
parameter_list|)
name|int
name|bnum
decl_stmt|;
name|int
name|allflag
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|found_a_breakpoint
init|=
literal|0
decl_stmt|;
specifier|static
name|ep_type_description_t
name|bptypes
index|[]
init|=
block|{
block|{
name|bp_none
block|,
literal|"?deleted?"
block|}
block|,
block|{
name|bp_breakpoint
block|,
literal|"breakpoint"
block|}
block|,
block|{
name|bp_hardware_breakpoint
block|,
literal|"hw breakpoint"
block|}
block|,
block|{
name|bp_until
block|,
literal|"until"
block|}
block|,
block|{
name|bp_finish
block|,
literal|"finish"
block|}
block|,
block|{
name|bp_watchpoint
block|,
literal|"watchpoint"
block|}
block|,
block|{
name|bp_hardware_watchpoint
block|,
literal|"hw watchpoint"
block|}
block|,
block|{
name|bp_read_watchpoint
block|,
literal|"read watchpoint"
block|}
block|,
block|{
name|bp_access_watchpoint
block|,
literal|"acc watchpoint"
block|}
block|,
block|{
name|bp_longjmp
block|,
literal|"longjmp"
block|}
block|,
block|{
name|bp_longjmp_resume
block|,
literal|"longjmp resume"
block|}
block|,
block|{
name|bp_step_resume
block|,
literal|"step resume"
block|}
block|,
block|{
name|bp_through_sigtramp
block|,
literal|"sigtramp"
block|}
block|,
block|{
name|bp_watchpoint_scope
block|,
literal|"watchpoint scope"
block|}
block|,
block|{
name|bp_call_dummy
block|,
literal|"call dummy"
block|}
block|,
block|{
name|bp_shlib_event
block|,
literal|"shlib events"
block|}
block|,
block|{
name|bp_catch_load
block|,
literal|"catch load"
block|}
block|,
block|{
name|bp_catch_unload
block|,
literal|"catch unload"
block|}
block|,
block|{
name|bp_catch_fork
block|,
literal|"catch fork"
block|}
block|,
block|{
name|bp_catch_vfork
block|,
literal|"catch vfork"
block|}
block|,
block|{
name|bp_catch_exec
block|,
literal|"catch exec"
block|}
block|,
block|{
name|bp_catch_catch
block|,
literal|"catch catch"
block|}
block|,
block|{
name|bp_catch_throw
block|,
literal|"catch throw"
block|}
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bpdisps
index|[]
init|=
block|{
literal|"del"
block|,
literal|"dstp"
block|,
literal|"dis"
block|,
literal|"keep"
block|}
decl_stmt|;
specifier|static
name|char
name|bpenables
index|[]
init|=
literal|"nyn"
decl_stmt|;
name|char
name|wrap_indent
index|[
literal|80
index|]
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
operator|||
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
comment|/*  We only print out user settable breakpoints unless the allflag is set. */
if|if
condition|(
operator|!
name|allflag
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_load
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_unload
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_throw
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
condition|)
continue|continue;
if|if
condition|(
operator|!
name|found_a_breakpoint
operator|++
condition|)
block|{
name|annotate_breakpoints_headers
argument_list|()
expr_stmt|;
name|annotate_field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Num "
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Type           "
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Disp "
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Enb "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Address    "
argument_list|)
expr_stmt|;
block|}
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"What\n"
argument_list|)
expr_stmt|;
name|annotate_breakpoints_table
argument_list|()
expr_stmt|;
block|}
name|annotate_record
argument_list|()
expr_stmt|;
name|annotate_field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|b
operator|->
name|type
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|bptypes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bptypes
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"bptypes table does not describe type #%d."
argument_list|,
operator|(
name|int
operator|)
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|b
operator|->
name|type
operator|!=
name|bptypes
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|type
index|]
operator|.
name|type
condition|)
name|error
argument_list|(
literal|"bptypes table does not describe type #%d?"
argument_list|,
operator|(
name|int
operator|)
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-14s "
argument_list|,
name|bptypes
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|type
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-4s "
argument_list|,
name|bpdisps
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|disposition
index|]
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3c "
argument_list|,
name|bpenables
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|enable
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|wrap_indent
argument_list|,
literal|"                           "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"           "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	       not line up too nicely with the headers, but the effect 	       is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
comment|/* Field 4, the address, is omitted (which makes the columns                not line up too nicely with the headers, but the effect                is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dll_pathname
operator|==
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"<any library> "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"library \"%s\" "
argument_list|,
name|b
operator|->
name|dll_pathname
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	       not line up too nicely with the headers, but the effect 	       is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|forked_inferior_pid
operator|!=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"process %d "
argument_list|,
name|b
operator|->
name|forked_inferior_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	       not line up too nicely with the headers, but the effect 	       is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|exec_pathname
operator|!=
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"program \"%s\" "
argument_list|,
name|b
operator|->
name|exec_pathname
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	       not line up too nicely with the headers, but the effect 	       is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"exception catch "
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_throw
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	       not line up too nicely with the headers, but the effect 	       is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"exception throw "
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_shlib_event
case|:
if|if
condition|(
name|addressprint
condition|)
block|{
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* FIXME-32x64: need a print_address_numeric with                    field width */
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|b
operator|->
name|address
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|last_addr
operator|=
name|b
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|source_file
condition|)
block|{
name|sym
operator|=
name|find_pc_sect_function
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"in "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
name|wrap_indent
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" at "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|b
operator|->
name|source_file
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":%d"
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|print_address_symbolic
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|gdb_stdout
argument_list|,
name|demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|" thread %d"
argument_list|,
name|b
operator|->
name|thread
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|frame
condition|)
block|{
name|annotate_field
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tstop only in stack frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|b
operator|->
name|frame
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|annotate_field
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tstop only if "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|cond
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* FIXME should make an annotation for this */
name|printf_filtered
argument_list|(
literal|"\tstop only in thread %d\n"
argument_list|,
name|b
operator|->
name|thread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_breakpoint_hit_counts
operator|&&
name|b
operator|->
name|hit_count
condition|)
block|{
comment|/* FIXME should make an annotation for this */
if|if
condition|(
name|ep_is_catchpoint
argument_list|(
name|b
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"\tcatchpoint"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"\tbreakpoint"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" already hit %d time%s\n"
argument_list|,
name|b
operator|->
name|hit_count
argument_list|,
operator|(
name|b
operator|->
name|hit_count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|ignore_count
condition|)
block|{
name|annotate_field
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tignore next %d hits\n"
argument_list|,
name|b
operator|->
name|ignore_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l
operator|=
name|b
operator|->
name|commands
operator|)
condition|)
block|{
name|annotate_field
argument_list|(
literal|9
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|print_command_line
argument_list|(
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_a_breakpoint
condition|)
block|{
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"No breakpoints or watchpoints.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"No breakpoint or watchpoint number %d.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Compare against (CORE_ADDR)-1 in case some compiler decides        that a comparison of an unsigned with -1 is always false.  */
if|if
condition|(
name|last_addr
operator|!=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|set_next_address
argument_list|(
name|last_addr
argument_list|)
expr_stmt|;
name|annotate_breakpoints_table_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|breakpoints_info
parameter_list|(
name|bnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|maintenance_info_breakpoints
parameter_list|(
name|bnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print a message describing any breakpoints set at PC.  */
end_comment

begin_function
specifier|static
name|void
name|describe_other_breakpoints
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|register
name|int
name|others
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
if|if
condition|(
name|overlay_debugging
operator|==
literal|0
operator|||
name|b
operator|->
name|section
operator|==
name|section
condition|)
name|others
operator|++
expr_stmt|;
if|if
condition|(
name|others
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Note: breakpoint%s "
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
if|if
condition|(
name|overlay_debugging
operator|==
literal|0
operator|||
name|b
operator|->
name|section
operator|==
name|section
condition|)
block|{
name|others
operator|--
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d%s%s "
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
operator|(
name|b
operator|->
name|enable
operator|==
name|disabled
operator|||
name|b
operator|->
name|enable
operator|==
name|shlib_disabled
operator|||
name|b
operator|->
name|enable
operator|==
name|call_disabled
operator|)
condition|?
literal|" (disabled)"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|","
else|:
operator|(
operator|(
name|others
operator|==
literal|1
operator|)
condition|?
literal|" and"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"also set at pc "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the default place to put a breakpoint    for the `break' command with no arguments.  */
end_comment

begin_function
name|void
name|set_default_breakpoint
parameter_list|(
name|valid
parameter_list|,
name|addr
parameter_list|,
name|symtab
parameter_list|,
name|line
parameter_list|)
name|int
name|valid
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|default_breakpoint_valid
operator|=
name|valid
expr_stmt|;
name|default_breakpoint_address
operator|=
name|addr
expr_stmt|;
name|default_breakpoint_symtab
operator|=
name|symtab
expr_stmt|;
name|default_breakpoint_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rescan breakpoints at address ADDRESS,    marking the first one as "first" and any others as "duplicates".    This is so that the bpt instruction is only inserted once.  */
end_comment

begin_function
specifier|static
name|void
name|check_duplicates
parameter_list|(
name|address
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|address
operator|==
literal|0
condition|)
comment|/* Watchpoints are uninteresting */
return|return;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|call_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|address
operator|&&
operator|(
name|overlay_debugging
operator|==
literal|0
operator|||
name|b
operator|->
name|section
operator|==
name|section
operator|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|b
operator|->
name|duplicate
operator|=
name|count
operator|>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Low level routine to set a breakpoint.    Takes as args the three things that every breakpoint must have.    Returns the breakpoint object so caller can set other things.    Does not set the breakpoint number!    Does not print anything.     ==> This routine should not be called if there is a chance of later    error(); otherwise it leaves a bogus breakpoint on the chain.  Validate    your arguments BEFORE calling this routine!  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|breakpoint
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|b
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|b
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|section
operator|=
name|sal
operator|.
name|section
expr_stmt|;
name|b
operator|->
name|language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|b
operator|->
name|input_radix
operator|=
name|input_radix
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dll_pathname
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|triggered_dll_pathname
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|forked_inferior_pid
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|exec_pathname
operator|=
name|NULL
expr_stmt|;
comment|/* Add this breakpoint to the end of the chain      so that a list of breakpoints will come out in order      of increasing numbers.  */
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
name|breakpoint_chain
operator|=
name|b
expr_stmt|;
else|else
block|{
while|while
condition|(
name|b1
operator|->
name|next
condition|)
name|b1
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|b
expr_stmt|;
block|}
name|check_duplicates
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|section
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_function
specifier|static
name|void
name|create_longjmp_breakpoint
parameter_list|(
name|func_name
parameter_list|)
name|char
modifier|*
name|func_name
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
if|if
condition|(
name|func_name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|func_name
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|sal
operator|.
name|pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
name|sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return;
name|b
operator|->
name|type
operator|=
name|func_name
operator|!=
name|NULL
condition|?
name|bp_longjmp
else|:
name|bp_longjmp_resume
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|func_name
condition|)
name|b
operator|->
name|addr_string
operator|=
name|strsave
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|internal_breakpoint_number
operator|--
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef GET_LONGJMP_TARGET */
end_comment

begin_comment
comment|/* Call this routine when stepping and nexting to enable a breakpoint if we do    a longjmp().  When we hit that breakpoint, call    set_longjmp_resume_breakpoint() to figure out where we are going. */
end_comment

begin_function
name|void
name|enable_longjmp_breakpoint
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|disable_longjmp_breakpoint
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
operator|||
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function
name|void
name|remove_solib_event_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_shlib_event
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_solib_event_breakpoint
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sal
operator|.
name|pc
operator|=
name|address
expr_stmt|;
name|sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|internal_breakpoint_number
operator|--
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_shlib_event
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_breakpoints_in_shlibs
parameter_list|(
name|silent
parameter_list|)
name|int
name|silent
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|disabled_shlib_breaks
init|=
literal|0
decl_stmt|;
comment|/* See also: insert_breakpoints, under DISABLE_UNSETTABLE_BREAK. */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PC_SOLIB
argument_list|)
if|if
condition|(
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_breakpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|)
operator|)
operator|&&
operator|(
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|)
operator|&&
operator|(
name|b
operator|->
name|enable
operator|!=
name|call_disabled
operator|)
operator|&&
operator|!
name|b
operator|->
name|duplicate
operator|&&
name|PC_SOLIB
argument_list|(
name|b
operator|->
name|address
argument_list|)
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|shlib_disabled
expr_stmt|;
if|if
condition|(
operator|!
name|silent
condition|)
block|{
if|if
condition|(
operator|!
name|disabled_shlib_breaks
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Temporarily disabling shared library breakpoints:\n"
argument_list|)
expr_stmt|;
block|}
name|disabled_shlib_breaks
operator|=
literal|1
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|disabled_shlib_breaks
operator|&&
operator|!
name|silent
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to reenable any breakpoints in shared libraries.  */
end_comment

begin_function
name|void
name|re_enable_breakpoints_in_shlibs
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|shlib_disabled
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* Do not reenable the breakpoint if the shared library 	   is still not mapped in.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|create_solib_load_unload_event_breakpoint
parameter_list|(
name|hookname
parameter_list|,
name|tempflag
parameter_list|,
name|dll_pathname
parameter_list|,
name|cond_string
parameter_list|,
name|bp_kind
parameter_list|)
name|char
modifier|*
name|hookname
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|dll_pathname
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
name|enum
name|bptype
name|bp_kind
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|canonical_strings_chain
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|addr_start
init|=
name|hookname
decl_stmt|;
name|char
modifier|*
name|addr_end
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
comment|/* Set a breakpoint on the specified hook. */
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|hookname
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|hookname
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to set a breakpoint on dynamic linker callback."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to set a unique breakpoint on dynamic linker callback."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure that all storage allocated in decode_line_1 gets freed in case      the following errors out.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
name|canonical_strings_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Remove the canonical strings from the cleanup, they are needed below.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|canonical_strings_chain
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|&&
name|canonical
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|b
operator|->
name|addr_string
operator|=
name|canonical
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_start
condition|)
name|b
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
if|if
condition|(
name|dll_pathname
operator|==
name|NULL
condition|)
name|b
operator|->
name|dll_pathname
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|b
operator|->
name|dll_pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dll_pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|b
operator|->
name|dll_pathname
argument_list|,
name|dll_pathname
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|type
operator|=
name|bp_kind
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_solib_load_event_breakpoint
parameter_list|(
name|hookname
parameter_list|,
name|tempflag
parameter_list|,
name|dll_pathname
parameter_list|,
name|cond_string
parameter_list|)
name|char
modifier|*
name|hookname
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|dll_pathname
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|create_solib_load_unload_event_breakpoint
argument_list|(
name|hookname
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_load
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_solib_unload_event_breakpoint
parameter_list|(
name|hookname
parameter_list|,
name|tempflag
parameter_list|,
name|dll_pathname
parameter_list|,
name|cond_string
parameter_list|)
name|char
modifier|*
name|hookname
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|dll_pathname
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|create_solib_load_unload_event_breakpoint
argument_list|(
name|hookname
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_unload
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_fork_vfork_event_catchpoint
parameter_list|(
name|tempflag
parameter_list|,
name|cond_string
parameter_list|,
name|bp_kind
parameter_list|)
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
name|enum
name|bptype
name|bp_kind
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
name|b
operator|->
name|forked_inferior_pid
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_kind
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_fork_event_catchpoint
parameter_list|(
name|tempflag
parameter_list|,
name|cond_string
parameter_list|)
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|create_fork_vfork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_fork
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_vfork_event_catchpoint
parameter_list|(
name|tempflag
parameter_list|,
name|cond_string
parameter_list|)
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|create_fork_vfork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_vfork
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_exec_event_catchpoint
parameter_list|(
name|tempflag
parameter_list|,
name|cond_string
parameter_list|)
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_catch_exec
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hw_breakpoint_used_count
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hw_watchpoint_used_count
parameter_list|(
name|type
parameter_list|,
name|other_type_used
parameter_list|)
name|enum
name|bptype
name|type
decl_stmt|;
name|int
modifier|*
name|other_type_used
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|other_type_used
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|type
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
operator|*
name|other_type_used
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Call this after hitting the longjmp() breakpoint.  Use this to set a new    breakpoint at the target of the jmp_buf.     FIXME - This ought to be done by setting a temporary breakpoint that gets    deleted automatically... */
end_comment

begin_function
name|void
name|set_longjmp_resume_breakpoint
parameter_list|(
name|pc
parameter_list|,
name|frame
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|address
operator|=
name|pc
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
name|frame
operator|!=
name|NULL
condition|)
name|b
operator|->
name|frame
operator|=
name|frame
operator|->
name|frame
expr_stmt|;
else|else
name|b
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|disable_watchpoints_before_interactive_call_start
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|||
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
operator|(
name|b
operator|->
name|enable
operator|==
name|enabled
operator|)
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|call_disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|enable_watchpoints_after_interactive_call_stop
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|||
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
operator|(
name|b
operator|->
name|enable
operator|==
name|call_disabled
operator|)
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set a breakpoint that will evaporate an end of command    at address specified by SAL.    Restrict it to frame FRAME if FRAME is nonzero.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_momentary_breakpoint
parameter_list|(
name|sal
parameter_list|,
name|frame
parameter_list|,
name|type
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|enum
name|bptype
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|frame
operator|=
operator|(
name|frame
condition|?
name|frame
operator|->
name|frame
else|:
literal|0
operator|)
expr_stmt|;
comment|/* If we're debugging a multi-threaded program, then we      want momentary breakpoints to be active in only a       single thread of control.  */
if|if
condition|(
name|in_thread_list
argument_list|(
name|inferior_pid
argument_list|)
condition|)
name|b
operator|->
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the user we have just set a breakpoint B.  */
end_comment

begin_function
specifier|static
name|void
name|mention
parameter_list|(
name|b
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|say_where
init|=
literal|0
decl_stmt|;
comment|/* FIXME: This is misplaced; mention() is called by things (like hitting a      watchpoint) other than breakpoint creation.  It should be possible to      clean this up and at the same time replace the random calls to      breakpoint_changed with this hook, as has already been done for      delete_breakpoint_hook and so on.  */
if|if
condition|(
name|create_breakpoint_hook
condition|)
name|create_breakpoint_hook
argument_list|(
name|b
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|printf_filtered
argument_list|(
literal|"(apparently deleted?) Eventpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_hardware_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_read_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware read watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_access_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware access (read/write) watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
name|printf_filtered
argument_list|(
literal|"Breakpoint %d"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|say_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|bp_hardware_breakpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware assisted breakpoint %d"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|say_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (%s %s)"
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
condition|?
literal|"load"
else|:
literal|"unload"
argument_list|,
operator|(
name|b
operator|->
name|dll_pathname
operator|!=
name|NULL
operator|)
condition|?
name|b
operator|->
name|dll_pathname
else|:
literal|"<any library>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (%s)"
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
condition|?
literal|"fork"
else|:
literal|"vfork"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (exec)"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (%s)"
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
condition|?
literal|"catch"
else|:
literal|"throw"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_shlib_event
case|:
break|break;
block|}
if|if
condition|(
name|say_where
condition|)
block|{
if|if
condition|(
name|addressprint
operator|||
name|b
operator|->
name|source_file
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|b
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|source_file
condition|)
name|printf_filtered
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|source_file
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vAllSetHasBreakAt
operator|,
name|b
operator|,
literal|1
operator|)
argument_list|)
expr_stmt|;
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tuiUpdateAllExecInfos
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set a breakpoint according to ARG (function, linenum or *address)    flag: first bit  : 0 non-temporary, 1 temporary. 	 second bit : 0 normal breakpoint, 1 hardware breakpoint. */
end_comment

begin_function
specifier|static
name|void
name|break_command_1
parameter_list|(
name|arg
parameter_list|,
name|flag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
name|int
name|tempflag
decl_stmt|,
name|hardwareflag
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
comment|/* Pointers in arg to the start, and one past the end, of the condition.  */
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
init|=
name|NULL
decl_stmt|;
comment|/* Pointers in arg to the start, and one past the end,      of the address part.  */
name|char
modifier|*
name|addr_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|addr_end
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|canonical_strings_chain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|hardwareflag
operator|=
name|flag
operator|&
name|BP_HARDWAREFLAG
expr_stmt|;
name|tempflag
operator|=
name|flag
operator|&
name|BP_TEMPFLAG
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* If no arg given, or if first arg is 'if ', use the default breakpoint. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_start
operator|=
name|arg
expr_stmt|;
comment|/* Force almost all breakpoints to be in terms of the 	 current_source_symtab (which is decode_line_1's default).  This 	 should produce the results we want almost all of the time while 	 leaving default_breakpoint_* alone.  */
if|if
condition|(
name|default_breakpoint_valid
operator|&&
operator|(
operator|!
name|current_source_symtab
operator|||
operator|(
name|arg
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|'+'
operator|||
operator|*
name|arg
operator|==
literal|'-'
operator|)
operator|)
operator|)
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/* Make sure that all storage allocated in decode_line_1 gets freed in case      the following `for' loop errors out.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
name|canonical_strings_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|canonical
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No specific thread yet */
comment|/* Resolve all line numbers to PC's, and verify that conditions      can be parsed, before setting any breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|end_tok
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* It's possible for the PC to be nonzero, but still an illegal          value on some targets.           For example, on HP-UX if you start gdb, and before running the          inferior you try to set a breakpoint on a shared library function          "foo" where the inferior doesn't call "foo" directly but does          pass its address to another function call, then we do find a          minimal symbol for the "foo", but it's address is invalid.          (Appears to be an index into a table that the loader sets up          when the inferior is run.)           Give the target a chance to bless sals.sals[i].pc before we          try to make a breakpoint for it. */
if|if
condition|(
name|PC_REQUIRES_RUN_BEFORE_USE
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot break on %s without a running program."
argument_list|,
name|addr_start
argument_list|)
expr_stmt|;
block|}
name|tok
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|tok
operator|&&
operator|*
name|tok
condition|)
block|{
while|while
condition|(
operator|*
name|tok
operator|==
literal|' '
operator|||
operator|*
name|tok
operator|==
literal|'\t'
condition|)
name|tok
operator|++
expr_stmt|;
name|end_tok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|*
name|end_tok
operator|!=
literal|' '
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\t'
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\000'
condition|)
name|end_tok
operator|++
expr_stmt|;
name|toklen
operator|=
name|end_tok
operator|-
name|tok
expr_stmt|;
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"if"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|cond_start
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|tok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"thread"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tmptok
decl_stmt|;
name|tok
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|tmptok
operator|=
name|tok
expr_stmt|;
name|thread
operator|=
name|strtol
argument_list|(
name|tok
argument_list|,
operator|&
name|tok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|tmptok
condition|)
name|error
argument_list|(
literal|"Junk after thread keyword."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_thread_id
argument_list|(
name|thread
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unknown thread %d\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hardwareflag
condition|)
block|{
name|int
name|i
decl_stmt|,
name|target_resources_ok
decl_stmt|;
name|i
operator|=
name|hw_breakpoint_used_count
argument_list|()
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
name|sals
operator|.
name|nelts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the canonical strings from the cleanup, they are needed below.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|canonical_strings_chain
argument_list|)
expr_stmt|;
comment|/* Now set all the breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|section
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|hardwareflag
condition|?
name|bp_hardware_breakpoint
else|:
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
comment|/* If a canonical line spec is needed use that instead of the 	 command string.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|&&
name|canonical
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|b
operator|->
name|addr_string
operator|=
name|canonical
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_start
condition|)
name|b
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_start
condition|)
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_at_finish_at_depth_command_1
parameter_list|(
name|arg
parameter_list|,
name|flag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|,
name|selected_pc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|extra_args
decl_stmt|,
modifier|*
name|level_arg
decl_stmt|,
modifier|*
name|addr_string
decl_stmt|;
name|int
name|extra_args_len
init|=
literal|0
decl_stmt|,
name|if_arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
if|if
condition|(
name|selected_frame
condition|)
block|{
name|selected_pc
operator|=
name|selected_frame
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|if_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extra_args
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_args
condition|)
block|{
name|extra_args
operator|++
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|level_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|extra_args
operator|-
name|arg
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|level_arg
argument_list|,
name|arg
argument_list|,
name|extra_args
operator|-
name|arg
operator|-
literal|1
argument_list|)
expr_stmt|;
name|level_arg
index|[
name|extra_args
operator|-
name|arg
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|level_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|level_arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|level_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
name|selected_pc
operator|=
name|frame
operator|->
name|pc
expr_stmt|;
else|else
name|selected_pc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|if_arg
condition|)
block|{
name|extra_args
operator|=
name|arg
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selected_pc
condition|)
block|{
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|selected_pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
condition|)
block|{
name|addr_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|26
operator|+
name|extra_args_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_args_len
condition|)
name|sprintf
argument_list|(
name|addr_string
argument_list|,
literal|"*0x%x %s"
argument_list|,
name|high
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|addr_string
argument_list|,
literal|"*0x%x"
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|break_command_1
argument_list|(
name|addr_string
argument_list|,
name|flag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|addr_string
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No function contains the specified address"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unable to set breakpoint at procedure exit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_at_finish_command_1
parameter_list|(
name|arg
parameter_list|,
name|flag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|addr_string
decl_stmt|,
modifier|*
name|break_string
decl_stmt|,
modifier|*
name|beg_addr_string
decl_stmt|;
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|extra_args
decl_stmt|;
name|int
name|extra_args_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|if_arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
if|if
condition|(
name|selected_frame
condition|)
block|{
name|addr_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|addr_string
argument_list|,
literal|"*0x%x"
argument_list|,
name|selected_frame
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|if_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|addr_string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_arg
condition|)
block|{
name|extra_args
operator|=
name|arg
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
condition|)
block|{
comment|/* get the stuff after the function name or address */
name|extra_args
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_args
condition|)
block|{
name|extra_args
operator|++
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
block|}
block|}
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|beg_addr_string
operator|=
name|addr_string
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|addr_string
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|beg_addr_string
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|sals
operator|.
name|nelts
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
condition|)
block|{
name|break_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|extra_args_len
operator|+
literal|26
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_args_len
condition|)
name|sprintf
argument_list|(
name|break_string
argument_list|,
literal|"*0x%x %s"
argument_list|,
name|high
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|break_string
argument_list|,
literal|"*0x%x"
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|break_command_1
argument_list|(
name|break_string
argument_list|,
name|flag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|break_string
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No function contains the specified address"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for break_command_1 and disassemble_command.  */
end_comment

begin_function
name|void
name|resolve_sal_pc
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|sal
operator|->
name|pc
operator|==
literal|0
operator|&&
name|sal
operator|->
name|symtab
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|find_line_pc
argument_list|(
name|sal
operator|->
name|symtab
argument_list|,
name|sal
operator|->
name|line
argument_list|,
operator|&
name|pc
argument_list|)
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|->
name|line
argument_list|,
name|sal
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sal
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
if|if
condition|(
name|sal
operator|->
name|section
operator|==
literal|0
operator|&&
name|sal
operator|->
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|index
decl_stmt|;
name|bv
operator|=
name|blockvector_for_pc_sect
argument_list|(
name|sal
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|,
name|sal
operator|->
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|bv
operator|!=
name|NULL
condition|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sym
operator|=
name|block_function
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|sal
operator|->
name|symtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|sal
operator|->
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It really is worthwhile to have the section, so we'll just 		 have to look harder. This case can be executed if we have  		 line numbers but no functions (as can happen in assembly  		 source).  */
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|sal
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
name|sal
operator|->
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|break_at_finish_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_at_finish_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|break_at_finish_at_depth_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_at_finish_at_depth_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
name|BP_TEMPFLAG
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tbreak_at_finish_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_at_finish_command_1
argument_list|(
name|arg
argument_list|,
name|BP_TEMPFLAG
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
name|BP_HARDWAREFLAG
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
operator|(
name|BP_TEMPFLAG
operator||
name|BP_HARDWAREFLAG
operator|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Specify the type of breakpoint to set.\n\ Usage: stop in<function | address>\n\        stop at<line>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stopin_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|badInput
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|badInput
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'*'
condition|)
block|{
name|char
modifier|*
name|argptr
init|=
name|arg
decl_stmt|;
name|int
name|hasColon
init|=
literal|0
decl_stmt|;
comment|/* look for a ':'.  If this is a line number specification, then say 	 it is bad, otherwise, it should be an address or function/method 	 name */
while|while
condition|(
operator|*
name|argptr
operator|&&
operator|!
name|hasColon
condition|)
block|{
name|hasColon
operator|=
operator|(
operator|*
name|argptr
operator|==
literal|':'
operator|)
expr_stmt|;
name|argptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hasColon
condition|)
name|badInput
operator|=
operator|(
operator|*
name|argptr
operator|!=
literal|':'
operator|)
expr_stmt|;
comment|/* Not a class::method */
else|else
name|badInput
operator|=
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
comment|/* a simple line number */
block|}
if|if
condition|(
name|badInput
condition|)
name|printf_filtered
argument_list|(
literal|"Usage: stop in<function | address>\n"
argument_list|)
expr_stmt|;
else|else
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stopat_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|badInput
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
operator|*
name|arg
operator|==
literal|'*'
condition|)
comment|/* no line number */
name|badInput
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|argptr
init|=
name|arg
decl_stmt|;
name|int
name|hasColon
init|=
literal|0
decl_stmt|;
comment|/* look for a ':'.  If there is a '::' then get out, otherwise 	 it is probably a line number. */
while|while
condition|(
operator|*
name|argptr
operator|&&
operator|!
name|hasColon
condition|)
block|{
name|hasColon
operator|=
operator|(
operator|*
name|argptr
operator|==
literal|':'
operator|)
expr_stmt|;
name|argptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hasColon
condition|)
name|badInput
operator|=
operator|(
operator|*
name|argptr
operator|==
literal|':'
operator|)
expr_stmt|;
comment|/* we have class::method */
else|else
name|badInput
operator|=
operator|!
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
comment|/* not a line number */
block|}
if|if
condition|(
name|badInput
condition|)
name|printf_filtered
argument_list|(
literal|"Usage: stop at<line>\n"
argument_list|)
expr_stmt|;
else|else
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_comment
comment|/* accessflag:  0: watch write, 1: watch read, 2: watch access(read or write) */
end_comment

begin_function
specifier|static
name|void
name|watch_command_1
parameter_list|(
name|arg
parameter_list|,
name|accessflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|accessflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|struct
name|block
modifier|*
name|exp_valid_block
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev_frame
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|exp_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|exp_end
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|end_tok
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
init|=
name|NULL
decl_stmt|;
name|struct
name|expression
modifier|*
name|cond
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|other_type_used
decl_stmt|,
name|target_resources_ok
init|=
literal|0
decl_stmt|;
name|enum
name|bptype
name|bp_type
decl_stmt|;
name|int
name|mem_cnt
init|=
literal|0
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* Parse arguments.  */
name|innermost_block
operator|=
name|NULL
expr_stmt|;
name|exp_start
operator|=
name|arg
expr_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp_end
operator|=
name|arg
expr_stmt|;
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|tok
operator|=
name|arg
expr_stmt|;
while|while
condition|(
operator|*
name|tok
operator|==
literal|' '
operator|||
operator|*
name|tok
operator|==
literal|'\t'
condition|)
name|tok
operator|++
expr_stmt|;
name|end_tok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|*
name|end_tok
operator|!=
literal|' '
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\t'
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\000'
condition|)
name|end_tok
operator|++
expr_stmt|;
name|toklen
operator|=
name|end_tok
operator|-
name|tok
expr_stmt|;
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"if"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|cond_start
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|tok
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tok
condition|)
name|error
argument_list|(
literal|"Junk at end of command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|accessflag
operator|==
literal|1
condition|)
name|bp_type
operator|=
name|bp_read_watchpoint
expr_stmt|;
elseif|else
if|if
condition|(
name|accessflag
operator|==
literal|2
condition|)
name|bp_type
operator|=
name|bp_access_watchpoint
expr_stmt|;
else|else
name|bp_type
operator|=
name|bp_hardware_watchpoint
expr_stmt|;
name|mem_cnt
operator|=
name|can_use_hardware_watchpoint
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|==
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Expression cannot be implemented with read/access watchpoint."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|hw_watchpoint_used_count
argument_list|(
name|bp_type
argument_list|,
operator|&
name|other_type_used
argument_list|)
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Target does not have this type of hardware watchpoint support."
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Target resources have been allocated for other types of watchpoints."
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
comment|/*  On HP-UX if you set a h/w      watchpoint before the "run" command, the inferior dies with a e.g.,      SIGILL once you start it.  I initially believed this was due to a      bad interaction between page protection traps and the initial      startup sequence by the dynamic linker.       However, I tried avoiding that by having HP-UX's implementation of      TARGET_CAN_USE_HW_WATCHPOINT return FALSE if there was no inferior_pid      yet, which forced slow watches before a "run" or "attach", and it      still fails somewhere in the startup code.       Until I figure out what's happening, I'm disallowing watches altogether      before the "run" or "attach" command.  We'll tell the user they must      set watches after getting the program started. */
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|warning
argument_list|(
literal|"can't do that without a running program; try \"break main\", \"run\" first"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HPUXHPPA */
comment|/* Now set up the breakpoint.  */
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|exp_valid_block
expr_stmt|;
name|b
operator|->
name|exp_string
operator|=
name|savestring
argument_list|(
name|exp_start
argument_list|,
name|exp_end
operator|-
name|exp_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|cond_start
condition|)
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|cond_string
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
name|block_innermost_frame
argument_list|(
name|exp_valid_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
block|{
name|prev_frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|b
operator|->
name|watchpoint_frame
operator|=
name|frame
operator|->
name|frame
expr_stmt|;
block|}
else|else
name|b
operator|->
name|watchpoint_frame
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|&&
name|target_resources_ok
operator|>
literal|0
condition|)
name|b
operator|->
name|type
operator|=
name|bp_type
expr_stmt|;
else|else
name|b
operator|->
name|type
operator|=
name|bp_watchpoint
expr_stmt|;
comment|/* If the expression is "local", then set up a "watchpoint scope"      breakpoint at the point where we've left the scope of the watchpoint      expression.  */
if|if
condition|(
name|innermost_block
condition|)
block|{
if|if
condition|(
name|prev_frame
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|scope_breakpoint
decl_stmt|;
name|struct
name|symtab_and_line
name|scope_sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|scope_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|scope_sal
operator|.
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
name|scope_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|scope_sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|scope_breakpoint
operator|=
name|set_raw_breakpoint
argument_list|(
name|scope_sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scope_breakpoint
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|scope_breakpoint
operator|->
name|type
operator|=
name|bp_watchpoint_scope
expr_stmt|;
name|scope_breakpoint
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
comment|/* Automatically delete the breakpoint when it hits.  */
name|scope_breakpoint
operator|->
name|disposition
operator|=
name|del
expr_stmt|;
comment|/* Only break in the proper frame (help with recursion).  */
name|scope_breakpoint
operator|->
name|frame
operator|=
name|prev_frame
operator|->
name|frame
expr_stmt|;
comment|/* Set the address at which we will stop.  */
name|scope_breakpoint
operator|->
name|address
operator|=
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
comment|/* The scope breakpoint is related to the watchpoint.  We 	     will need to act on them together.  */
name|b
operator|->
name|related_breakpoint
operator|=
name|scope_breakpoint
expr_stmt|;
block|}
block|}
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return count of locations need to be watched and can be handled    in hardware.  If the watchpoint can not be handled    in hardware return zero.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT
parameter_list|(
name|byte_size
parameter_list|)
define|\
value|((byte_size)<= (REGISTER_SIZE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|can_use_hardware_watchpoint
parameter_list|(
name|v
parameter_list|)
name|struct
name|value
modifier|*
name|v
decl_stmt|;
block|{
name|int
name|found_memory_cnt
init|=
literal|0
decl_stmt|;
comment|/* Did the user specifically forbid us to use hardware watchpoints? */
if|if
condition|(
operator|!
name|can_use_hw_watchpoints
condition|)
return|return
literal|0
return|;
comment|/* Make sure all the intermediate values are in memory.  Also make sure      we found at least one memory expression.  Guards against watch 0x12345,      which is meaningless, but could cause errors if one tries to insert a       hardware watchpoint for the constant expression.  */
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
if|if
condition|(
name|TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
condition|)
name|found_memory_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|lval
operator|!=
name|not_lval
operator|&&
name|v
operator|->
name|modifiable
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* The expression itself looks suitable for using a hardware      watchpoint, but give the target machine a chance to reject it.  */
return|return
name|found_memory_cnt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|watch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rwatch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awatch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routine for the until_command routine in infcmd.c.  Here    because it uses the mechanisms of breakpoints.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|until_break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev_frame
init|=
name|get_prev_frame
argument_list|(
name|selected_frame
argument_list|)
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Set a breakpoint where the user wants it and at return from      this function */
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Couldn't get information on specified line."
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* malloc'd, so freed */
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|selected_frame
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|delete_breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
comment|/* Keep within the current frame */
if|if
condition|(
name|prev_frame
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prev_frame
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|prev_frame
operator|->
name|pc
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|prev_frame
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|delete_breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
block|}
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These aren't used; I don't konw what they were for.  */
end_comment

begin_comment
comment|/* Set a breakpoint at the catch clause for NAME.  */
end_comment

begin_endif
unit|static int catch_breakpoint (name)      char *name; { }  static int disable_catch_breakpoint () { }  static int delete_catch_breakpoint () { }  static int enable_catch_breakpoint () { }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_struct
struct|struct
name|sal_chain
block|{
name|struct
name|sal_chain
modifier|*
name|next
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Not really used -- invocation in handle_gnu_4_16_catch_command    had been commented out in the v.4.16 sources, and stays    disabled there now because "catch NAME" syntax isn't allowed.    pai/1997-07-11 */
end_comment

begin_comment
comment|/* This isn't used; I don't know what it was for.  */
end_comment

begin_comment
comment|/* For each catch clause identified in ARGS, run FUNCTION    with that clause as an argument.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|map_catch_names
argument_list|(
name|args
argument_list|,
name|function
argument_list|)
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|#
directive|if
literal|0
block|struct sal_chain *sal_chain = 0;
endif|#
directive|endif
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more catch names"
argument_list|)
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Don't swallow conditional part.  */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|p1
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|p1
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
break|break;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p1
argument_list|)
condition|)
block|{
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p1
argument_list|)
operator|||
operator|*
name|p1
operator|==
literal|'_'
operator|||
operator|*
name|p1
operator|==
literal|'$'
condition|)
name|p1
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be catch names."
argument_list|)
expr_stmt|;
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (function (p)) 	{ 	  struct sal_chain *next = (struct sal_chain *) 	    alloca (sizeof (struct sal_chain)); 	  next->next = sal_chain; 	  next->sal = get_catch_sal (p); 	  sal_chain = next; 	  goto win; 	}
endif|#
directive|endif
name|printf_unfiltered
argument_list|(
literal|"No catch clause for exception %s.\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|win:
endif|#
directive|endif
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* This shares a lot of code with `print_frame_label_vars' from stack.c.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|get_catch_sals
parameter_list|(
name|this_level_only
parameter_list|)
name|int
name|this_level_only
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|index
decl_stmt|,
name|have_default
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|sal_chain
modifier|*
name|sal_chain
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|blocks_searched
decl_stmt|;
comment|/* Not sure whether an error message is always the correct response,      but it's better than a core dump.  */
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|block
operator|=
name|get_frame_block
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|pc
operator|=
name|selected_frame
operator|->
name|pc
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|blocks_searched
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocks_searched
argument_list|,
literal|0
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
decl_stmt|;
name|int
name|last_index
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
name|blockvector_for_pc
argument_list|(
name|end
argument_list|,
operator|&
name|index
argument_list|)
condition|)
name|error
argument_list|(
literal|"blockvector blotch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
operator|!=
name|block
condition|)
name|error
argument_list|(
literal|"blockvector botch"
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
comment|/* Don't print out blocks that have gone by.  */
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|pc
condition|)
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|blocks_searched
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_default
condition|)
continue|continue;
name|have_default
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
condition|)
block|{
name|struct
name|sal_chain
modifier|*
name|next
init|=
operator|(
expr|struct
name|sal_chain
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sal_chain
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|next
operator|=
name|sal_chain
expr_stmt|;
name|next
operator|->
name|sal
operator|=
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal_chain
operator|=
name|next
expr_stmt|;
block|}
block|}
name|blocks_searched
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_default
condition|)
break|break;
if|if
condition|(
name|sal_chain
operator|&&
name|this_level_only
condition|)
break|break;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sal_chain
condition|)
block|{
name|struct
name|sal_chain
modifier|*
name|tmp_chain
decl_stmt|;
comment|/* Count the number of entries.  */
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|tmp_chain
operator|=
name|sal_chain
init|;
name|tmp_chain
condition|;
name|tmp_chain
operator|=
name|tmp_chain
operator|->
name|next
control|)
name|index
operator|++
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
name|index
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|sal_chain
condition|;
name|sal_chain
operator|=
name|sal_chain
operator|->
name|next
operator|,
name|index
operator|++
control|)
name|sals
operator|.
name|sals
index|[
name|index
index|]
operator|=
name|sal_chain
operator|->
name|sal
expr_stmt|;
block|}
return|return
name|sals
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ep_skip_leading_whitespace
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|s
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
name|NULL
operator|)
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function examines a string, and attempts to find a token    that might be an event name in the leading characters.  If a    possible match is found, a pointer to the last character of    the token is returned.  Else, NULL is returned. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ep_find_event_name_end
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|event_name_end
init|=
name|NULL
decl_stmt|;
comment|/* If we could depend upon the presense of strrpbrk, we'd use that... */
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* We break out of the loop when we find a token delimiter.    Basically, we're looking for alphanumerics and underscores;    anything else delimites the token. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'_'
operator|)
condition|)
break|break;
name|event_name_end
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|event_name_end
return|;
block|}
end_function

begin_comment
comment|/* This function attempts to parse an optional "if<cond>" clause    from the arg string.  If one is not found, it returns NULL.      Else, it returns a pointer to the condition string.  (It does not    attempt to evaluate the string against a particular block.)  And,    it updates arg to point to the first character following the parsed    if clause in the arg string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ep_parse_optional_if_clause
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|cond_string
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|arg
operator|)
index|[
literal|0
index|]
operator|!=
literal|'i'
operator|)
operator|||
operator|(
operator|(
operator|*
name|arg
operator|)
index|[
literal|1
index|]
operator|!=
literal|'f'
operator|)
operator|||
operator|!
name|isspace
argument_list|(
operator|(
operator|*
name|arg
operator|)
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Skip the "if" keyword. */
operator|(
operator|*
name|arg
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* Skip any extra leading whitespace, and record the start of the      condition string. */
name|ep_skip_leading_whitespace
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
operator|*
name|arg
expr_stmt|;
comment|/* Assume that the condition occupies the remainder of the arg string. */
operator|(
operator|*
name|arg
operator|)
operator|+=
name|strlen
argument_list|(
name|cond_string
argument_list|)
expr_stmt|;
return|return
name|cond_string
return|;
block|}
end_function

begin_comment
comment|/* This function attempts to parse an optional filename from the arg    string.  If one is not found, it returns NULL.      Else, it returns a pointer to the parsed filename.  (This function    makes no attempt to verify that a file of that name exists, or is    accessible.)  And, it updates arg to point to the first character    following the parsed filename in the arg string.      Note that clients needing to preserve the returned filename for    future access should copy it to their own buffers. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ep_parse_optional_filename
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|char
name|filename
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|arg_p
init|=
operator|*
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg_p
operator|==
literal|'\0'
operator|)
operator|||
name|isspace
argument_list|(
operator|*
name|arg_p
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|arg_p
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
literal|'\0'
expr_stmt|;
name|filename
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
name|arg_p
operator|++
expr_stmt|;
block|}
operator|*
name|arg
operator|=
name|arg_p
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Commands to deal with catching events, such as signals, exceptions,    process start/exit, etc.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|catch_fork
block|,
name|catch_vfork
block|}
name|catch_fork_kind
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|catch_fork_command_1
parameter_list|(
name|fork_kind
parameter_list|,
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|catch_fork_kind
name|fork_kind
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:         catch [v]fork         catch [v]fork if<cond>        First, check if there's an if clause. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* If this target supports it, create a fork or vfork catchpoint      and enable reporting of such events. */
switch|switch
condition|(
name|fork_kind
condition|)
block|{
case|case
name|catch_fork
case|:
name|create_fork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|catch_vfork
case|:
name|create_vfork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
break|break;
default|default :
name|error
argument_list|(
literal|"unsupported or unknown fork kind; cannot catch it"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|catch_exec_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:         catch exec         catch exec if<cond>       First, check if there's an if clause. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* If this target supports it, create an exec catchpoint      and enable reporting of such events. */
name|create_exec_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
end_if

begin_function
specifier|static
name|void
name|catch_load_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|dll_pathname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:         catch load         catch load if<cond>         catch load<filename>         catch load<filename> if<cond>        The user is not allowed to specify the<filename> after an      if clause.        We'll ignore the pathological case of a file named "if".        First, check if there's an if clause.  If so, then there      cannot be a filename. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If there was an if clause, then there cannot be a filename.      Else, there might be a filename and an if clause. */
if|if
condition|(
name|cond_string
operator|==
name|NULL
condition|)
block|{
name|dll_pathname
operator|=
name|ep_parse_optional_filename
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* Create a load breakpoint that only triggers when a load of      the specified dll (or any dll, if no pathname was specified)      occurs. */
name|SOLIB_CREATE_CATCH_LOAD_HOOK
argument_list|(
name|inferior_pid
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_unload_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|dll_pathname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:         catch unload         catch unload if<cond>         catch unload<filename>         catch unload<filename> if<cond>        The user is not allowed to specify the<filename> after an      if clause.        We'll ignore the pathological case of a file named "if".        First, check if there's an if clause.  If so, then there      cannot be a filename. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If there was an if clause, then there cannot be a filename.      Else, there might be a filename and an if clause. */
if|if
condition|(
name|cond_string
operator|==
name|NULL
condition|)
block|{
name|dll_pathname
operator|=
name|ep_parse_optional_filename
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* Create an unload breakpoint that only triggers when an unload of      the specified dll (or any dll, if no pathname was specified)      occurs. */
name|SOLIB_CREATE_CATCH_UNLOAD_HOOK
argument_list|(
name|inferior_pid
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_ADD */
end_comment

begin_comment
comment|/* Commands to deal with catching exceptions.  */
end_comment

begin_comment
comment|/* Set a breakpoint at the specified callback routine for an    exception event callback */
end_comment

begin_function
specifier|static
name|void
name|create_exception_catchpoint
parameter_list|(
name|tempflag
parameter_list|,
name|cond_string
parameter_list|,
name|ex_event
parameter_list|,
name|sal
parameter_list|)
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
name|enum
name|exception_event_kind
name|ex_event
decl_stmt|;
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
if|if
condition|(
operator|!
name|sal
condition|)
comment|/* no exception support? */
return|return;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
operator|*
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
switch|switch
condition|(
name|ex_event
condition|)
block|{
case|case
name|EX_EVENT_THROW
case|:
name|b
operator|->
name|type
operator|=
name|bp_catch_throw
expr_stmt|;
break|break;
case|case
name|EX_EVENT_CATCH
case|:
name|b
operator|->
name|type
operator|=
name|bp_catch_catch
expr_stmt|;
break|break;
default|default:
comment|/* error condition */
name|b
operator|->
name|type
operator|=
name|bp_none
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|error
argument_list|(
literal|"Internal error -- invalid catchpoint kind"
argument_list|)
expr_stmt|;
block|}
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deal with "catch catch" and "catch throw" commands */
end_comment

begin_function
specifier|static
name|void
name|catch_exception_command_1
parameter_list|(
name|ex_event
parameter_list|,
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|enum
name|exception_event_kind
name|ex_event
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab_and_line
modifier|*
name|sal
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ex_event
operator|!=
name|EX_EVENT_THROW
operator|)
operator|&&
operator|(
name|ex_event
operator|!=
name|EX_EVENT_CATCH
operator|)
condition|)
name|error
argument_list|(
literal|"Unsupported or unknown exception event; cannot catch it"
argument_list|)
expr_stmt|;
comment|/* See if we can find a callback routine */
name|sal
operator|=
name|target_enable_exception_callback
argument_list|(
name|ex_event
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
condition|)
block|{
comment|/* We have callbacks from the runtime system for exceptions.          Set a breakpoint on the sal found, if no errors */
if|if
condition|(
name|sal
operator|!=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
operator|-
literal|1
condition|)
name|create_exception_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|ex_event
argument_list|,
name|sal
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* something went wrong with setting up callbacks */
block|}
else|else
block|{
comment|/* No callbacks from runtime system for exceptions.          Try GNU C++ exception breakpoints using labels in debug info. */
if|if
condition|(
name|ex_event
operator|==
name|EX_EVENT_CATCH
condition|)
block|{
name|handle_gnu_4_16_catch_command
argument_list|(
name|arg
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ex_event
operator|==
name|EX_EVENT_THROW
condition|)
block|{
comment|/* Set a breakpoint on __raise_exception () */
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Unsupported with this platform/compiler combination.\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Perhaps you can achieve the effect you want by setting\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"a breakpoint on __raise_exception().\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Cover routine to allow wrapping target_enable_exception_catchpoints    inside a catch_errors */
end_comment

begin_function
specifier|static
name|int
name|cover_target_enable_exception_callback
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{
name|args_for_catchpoint_enable
modifier|*
name|args
init|=
name|arg
decl_stmt|;
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
name|sal
operator|=
name|target_enable_exception_callback
argument_list|(
name|args
operator|->
name|kind
argument_list|,
name|args
operator|->
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|sal
operator|==
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
comment|/*is valid*/
block|}
end_function

begin_comment
comment|/* This is the original v.4.16 and earlier version of the    catch_command_1() function.  Now that other flavours of "catch"    have been introduced, and since exception handling can be handled    in other ways (through target ops) also, this is used only for the    GNU C++ exception handling system.    Note: Only the "catch" flavour of GDB 4.16 is handled here.  The    "catch NAME" is now no longer allowed in catch_command_1().  Also,    there was no code in GDB 4.16 for "catch throw".        Called from catch_exception_command_1 () */
end_comment

begin_function
specifier|static
name|void
name|handle_gnu_4_16_catch_command
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* First, translate ARG into something we can deal with in terms      of breakpoints.  */
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|save_arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* If no arg given, or if first arg is 'if ', all active catch clauses      are breakpointed. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
comment|/* Grab all active catch clauses.  */
name|sals
operator|=
name|get_catch_sals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Grab selected catch clauses.  */
name|error
argument_list|(
literal|"catch NAME not implemented"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not sure why this code has been disabled. I'm leaving          it disabled.  We can never come here now anyway          since we don't allow the "catch NAME" syntax.          pai/1997-07-11 */
comment|/* This isn't used; I don't know what it was for.  */
block|sals = map_catch_names (arg, catch_breakpoint);
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
name|save_arg
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|(
name|arg
operator|+=
literal|2
operator|,
operator|&
name|arg
operator|)
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|save_arg
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|section
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_breakpoint
expr_stmt|;
comment|/* Important -- this is an ordinary breakpoint.                                   For platforms with callback support for exceptions,                                   create_exception_catchpoint() will create special                                   bp types (bp_catch_catch and bp_catch_throw), and                                   there is code in insert_breakpoints() and elsewhere                                   that depends on that. */
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This creates a temporary internal breakpoint    just to placate infrun */
end_comment

begin_endif
unit|static struct breakpoint * create_temp_exception_breakpoint (pc)   CORE_ADDR pc; {   struct symtab_and_line sal;   struct breakpoint *b;    INIT_SAL(&sal);   sal.pc = pc;   sal.symtab = NULL;   sal.line = 0;    b = set_raw_breakpoint (sal);   if (!b)     error ("Internal error -- couldn't set temp exception breakpoint");    b->type = bp_breakpoint;   b->disposition = del;   b->enable = enabled;   b->silent = 1;   b->number = internal_breakpoint_number--;   return b; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|catch_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* The first argument may be an event name, such as "start" or "load".      If so, then handle it as such.  If it doesn't match an event name,      then attempt to interpret it as an exception name.  (This latter is      the v4.16-and-earlier GDB meaning of the "catch" command.)        First, try to find the bounds of what might be an event name. */
name|char
modifier|*
name|arg1_start
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|arg1_end
decl_stmt|;
name|int
name|arg1_length
decl_stmt|;
if|if
condition|(
name|arg1_start
operator|==
name|NULL
condition|)
block|{
comment|/* Old behaviour was to use pre-v-4.16 syntax */
comment|/* catch_throw_command_1 (arg1_start, tempflag, from_tty); */
comment|/* return; */
comment|/* Now, this is not allowed */
name|error
argument_list|(
literal|"Catch requires an event name."
argument_list|)
expr_stmt|;
block|}
name|arg1_end
operator|=
name|ep_find_event_name_end
argument_list|(
name|arg1_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1_end
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"catch requires an event"
argument_list|)
expr_stmt|;
name|arg1_length
operator|=
name|arg1_end
operator|+
literal|1
operator|-
name|arg1_start
expr_stmt|;
comment|/* Try to match what we found against known event names. */
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"signal"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of signal not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"catch"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_exception_command_1
argument_list|(
name|EX_EVENT_CATCH
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"throw"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_exception_command_1
argument_list|(
name|EX_EVENT_THROW
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"thread_start"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of thread_start not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"thread_exit"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of thread_exit not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"thread_join"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of thread_join not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"start"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of start not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"exit"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of exit not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"fork"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CHILD_INSERT_FORK_CATCHPOINT
argument_list|)
name|catch_fork_command_1
argument_list|(
name|catch_fork
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Catch of fork not yet implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"vfork"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CHILD_INSERT_VFORK_CATCHPOINT
argument_list|)
name|catch_fork_command_1
argument_list|(
name|catch_vfork
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Catch of vfork not yet implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"exec"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CHILD_INSERT_EXEC_CATCHPOINT
argument_list|)
name|catch_exec_command_1
argument_list|(
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Catch of exec not yet implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"load"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
name|catch_load_command_1
argument_list|(
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Catch of load not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"unload"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
name|catch_unload_command_1
argument_list|(
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Catch of load not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"stop"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of stop not yet implemented"
argument_list|)
expr_stmt|;
block|}
comment|/* This doesn't appear to be an event name */
else|else
block|{
comment|/* Pre-v.4.16 behaviour was to treat the argument          as the name of an exception */
comment|/* catch_throw_command_1 (arg1_start, tempflag, from_tty); */
comment|/* Now this is not allowed */
name|error
argument_list|(
literal|"Unknown event kind specified for catch"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used by the gui, could be made a worker for other things. */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_breakpoint_sal
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These aren't used; I don't know what they were for.  */
end_comment

begin_comment
comment|/* Disable breakpoints on all catch clauses described in ARGS.  */
end_comment

begin_comment
unit|static void disable_catch (args)      char *args; {
comment|/* Map the disable command to catch clauses described in ARGS.  */
end_comment

begin_comment
unit|}
comment|/* Enable breakpoints on all catch clauses described in ARGS.  */
end_comment

begin_comment
unit|static void enable_catch (args)      char *args; {
comment|/* Map the disable command to catch clauses described in ARGS.  */
end_comment

begin_comment
unit|}
comment|/* Delete breakpoints on all catch clauses in the active scope.  */
end_comment

begin_comment
unit|static void delete_catch (args)      char *args; {
comment|/* Map the delete command to catch clauses described in ARGS.  */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|catch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|catch_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tcatch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|catch_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|int
name|default_match
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|default_match
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|default_match
operator|=
literal|1
expr_stmt|;
block|}
comment|/* For each line spec given, delete bps which correspond      to it.  We do this in two loops: the first loop looks at      the initial bp(s) in the chain which should be deleted,      the second goes down the rest of the chain looking ahead      one so it can take those bps off the chain without messing      up the chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* If exact pc given, clear bpts at that pc. 	 If line given (pc == 0), clear all bpts on specified line. 	 If defaulting, clear all bpts on default line          or at default pc.         		defaulting    sal.pc != 0    tests to do                         0              1             pc                 1              1             pc _and_ line                 0              0             line                 1              0<can't happen> */
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|breakpoint_chain
comment|/* Why don't we check here that this is not 		a watchpoint, etc., as we do below? 		I can't make it fail, but don't know 		what's stopping the failure: a watchpoint 		of the same address as "sal.pc" should 		wind up being deleted. */
operator|&&
operator|(
operator|(
operator|(
name|sal
operator|.
name|pc
operator|&&
operator|(
name|breakpoint_chain
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
operator|)
operator|)
operator|&&
operator|(
name|overlay_debugging
operator|==
literal|0
operator|||
name|breakpoint_chain
operator|->
name|section
operator|==
name|sal
operator|.
name|section
operator|)
operator|)
operator|||
operator|(
operator|(
name|default_match
operator|||
operator|(
literal|0
operator|==
name|sal
operator|.
name|pc
operator|)
operator|)
operator|&&
name|breakpoint_chain
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|breakpoint_chain
operator|->
name|source_file
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|&&
name|breakpoint_chain
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
name|breakpoint_chain
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
while|while
condition|(
name|b
operator|->
name|next
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_none
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
operator|(
operator|(
operator|(
name|sal
operator|.
name|pc
operator|&&
operator|(
name|b
operator|->
name|next
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
operator|)
operator|)
operator|&&
operator|(
name|overlay_debugging
operator|==
literal|0
operator|||
name|b
operator|->
name|next
operator|->
name|section
operator|==
name|sal
operator|.
name|section
operator|)
operator|)
operator|||
operator|(
operator|(
name|default_match
operator|||
operator|(
literal|0
operator|==
name|sal
operator|.
name|pc
operator|)
operator|)
operator|&&
name|b
operator|->
name|next
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|b
operator|->
name|next
operator|->
name|source_file
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|&&
name|b
operator|->
name|next
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|b
operator|->
name|next
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"No breakpoint at %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No breakpoint at this line."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|->
name|next
condition|)
name|from_tty
operator|=
literal|1
expr_stmt|;
comment|/* Always report if deleted more than one */
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Deleted breakpoint%s "
argument_list|,
name|found
operator|->
name|next
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
while|while
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"%d "
argument_list|,
name|found
operator|->
name|number
argument_list|)
expr_stmt|;
name|b1
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete breakpoint in BS if they are `delete' breakpoints and    all breakpoints that are marked for deletion, whether hit or not.    This is called after any breakpoint is hit, or after errors.  */
end_comment

begin_function
name|void
name|breakpoint_auto_delete
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
for|for
control|(
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|disposition
operator|==
name|del
operator|&&
name|bs
operator|->
name|stop
condition|)
name|delete_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|disposition
operator|==
name|del_at_next_stop
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete a breakpoint and clean up all traces of it in the data structures. */
end_comment

begin_function
name|void
name|delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|bpstat
name|bs
decl_stmt|;
if|if
condition|(
name|bpt
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error (attempted to delete a NULL breakpoint)"
argument_list|)
expr_stmt|;
comment|/* Has this bp already been deleted?  This can happen because multiple      lists can hold pointers to bp's.  bpstat lists are especial culprits.       One example of this happening is a watchpoint's scope bp.  When the      scope bp triggers, we notice that the watchpoint is out of scope, and      delete it.  We also delete its scope bp.  But the scope bp is marked      "auto-deleting", and is already on a bpstat.  That bpstat is then      checked for auto-deleting bp's, which are deleted.       A real solution to this problem might involve reference counts in bp's,      and/or giving them pointers back to their referencing bpstat's, and      teaching delete_breakpoint to only free a bp's storage when no more      references were extent.  A cheaper bandaid was chosen. */
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_none
condition|)
return|return;
if|if
condition|(
name|delete_breakpoint_hook
condition|)
name|delete_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|inserted
condition|)
name|remove_breakpoint
argument_list|(
name|bpt
argument_list|,
name|mark_uninserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_chain
operator|==
name|bpt
condition|)
name|breakpoint_chain
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
comment|/* If we have callback-style exception catchpoints, don't go through      the adjustments to the C++ runtime library etc. if the inferior      isn't actually running.  target_enable_exception_callback for a      null target ops vector gives an undesirable error message, so we      check here and avoid it. Since currently (1997-09-17) only HP-UX aCC's      exceptions are supported in this way, it's OK for now. FIXME */
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|bpt
argument_list|)
operator|&&
name|target_has_execution
condition|)
block|{
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error in deleting catchpoint %d:\n"
decl_stmt|;
specifier|static
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
index|]
decl_stmt|;
name|args_for_catchpoint_enable
name|args
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Format possible error msg */
name|args
operator|.
name|kind
operator|=
name|bpt
operator|->
name|type
operator|==
name|bp_catch_catch
condition|?
name|EX_EVENT_CATCH
else|:
name|EX_EVENT_THROW
expr_stmt|;
name|args
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|catch_errors
argument_list|(
name|cover_target_enable_exception_callback
argument_list|,
operator|&
name|args
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|next
operator|==
name|bpt
condition|)
block|{
name|b
operator|->
name|next
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
break|break;
block|}
comment|/* Before turning off the visuals for the bp, check to see that      there are no other bps at the same address. */
if|if
condition|(
name|tui_version
condition|)
block|{
name|int
name|clearIt
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
name|clearIt
operator|=
operator|(
name|b
operator|->
name|address
operator|!=
name|bpt
operator|->
name|address
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|clearIt
condition|)
break|break;
block|}
if|if
condition|(
name|clearIt
condition|)
block|{
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vAllSetHasBreakAt
operator|,
name|bpt
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tuiUpdateAllExecInfos
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|section
argument_list|)
expr_stmt|;
comment|/* If this breakpoint was inserted, and there is another breakpoint      at the same address, we need to insert the other breakpoint.  */
if|if
condition|(
name|bpt
operator|->
name|inserted
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_catch_exec
condition|)
block|{
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|bpt
operator|->
name|address
operator|&&
name|b
operator|->
name|section
operator|==
name|bpt
operator|->
name|section
operator|&&
operator|!
name|b
operator|->
name|duplicate
operator|&&
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|call_disabled
condition|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|memory_error
argument_list|(
name|val
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* which bombs us out */
block|}
else|else
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
operator|&
name|bpt
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|addr_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exp_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|exp_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|val
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|source_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|dll_pathname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|dll_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|triggered_dll_pathname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exec_pathname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|exec_pathname
argument_list|)
expr_stmt|;
comment|/* Be sure no bpstat's are pointing at it after it's been freed.  */
comment|/* FIXME, how can we find all bpstat's?      We just check stop_bpstat for now.  */
for|for
control|(
name|bs
operator|=
name|stop_bpstat
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|bpt
condition|)
block|{
name|bs
operator|->
name|breakpoint_at
operator|=
name|NULL
expr_stmt|;
comment|/* we'd call bpstat_clear_actions, but that free's stuff and due 	   to the multiple pointers pointing to one item with no 	   reference counts found anywhere through out the bpstat's (how 	   do you spell fragile?), we don't want to free things twice -- 	   better a memory leak than a corrupt malloc pool! */
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* On the chance that someone will soon try again to delete this same      bp, we mark it as deleted before freeing its storage. */
name|bpt
operator|->
name|type
operator|=
name|bp_none
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|int
name|breaks_to_delete
init|=
literal|0
decl_stmt|;
comment|/* Delete all breakpoints if no argument. 	 Do not delete internal or call-dummy breakpoints, these 	 have to be deleted with an explicit breakpoint number argument.  */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_call_dummy
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_shlib_event
operator|&&
name|b
operator|->
name|number
operator|>=
literal|0
condition|)
name|breaks_to_delete
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ask user only if there are some breakpoints to delete.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
operator|(
name|breaks_to_delete
operator|&&
name|query
argument_list|(
literal|"Delete all breakpoints? "
argument_list|)
operator|)
condition|)
block|{
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_call_dummy
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_shlib_event
operator|&&
name|b
operator|->
name|number
operator|>=
literal|0
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|arg
argument_list|,
name|delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset a breakpoint given it's struct breakpoint * BINT.    The value we return ends up being the return value from catch_errors.    Unused in this case.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_re_set_one
parameter_list|(
name|bint
parameter_list|)
name|PTR
name|bint
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|bint
decl_stmt|;
comment|/* get past catch_errs */
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|enable
name|save_enable
decl_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|warning
argument_list|(
literal|"attempted to reset apparently deleted breakpoint #%d?\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
if|if
condition|(
name|b
operator|->
name|addr_string
operator|==
name|NULL
condition|)
block|{
comment|/* Anything without a string can't be re-set. */
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* In case we have a problem, disable this breakpoint.  We'll restore 	 its status if we succeed.  */
name|save_enable
operator|=
name|b
operator|->
name|enable
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|set_language
argument_list|(
name|b
operator|->
name|language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|b
operator|->
name|input_radix
expr_stmt|;
name|s
operator|=
name|b
operator|->
name|addr_string
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Reparse conditions, they might contain references to the 	     old symtab.  */
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We need to re-set the breakpoint if the address changes...*/
if|if
condition|(
name|b
operator|->
name|address
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
comment|/* ...or new and old breakpoints both have source files, and 		 the source file name or the line number changes...  */
operator|||
operator|(
name|b
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|STREQ
argument_list|(
name|b
operator|->
name|source_file
argument_list|,
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|||
name|b
operator|->
name|line_number
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
operator|)
operator|)
comment|/* ...or we switch between having a source file and not having 		 one.  */
operator|||
operator|(
operator|(
name|b
operator|->
name|source_file
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|source_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|b
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|b
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|b
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
comment|/* Used to check for duplicates here, but that can 		cause trouble, as it doesn't check for disable                 breakpoints. */
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Might be better to do this just once per breakpoint_re_set, 		 rather than once for every breakpoint.  */
name|breakpoints_changed
argument_list|()
expr_stmt|;
block|}
name|b
operator|->
name|section
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|section
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|save_enable
expr_stmt|;
comment|/* Restore it, this worked. */
comment|/* Now that this is re-enabled, check_duplicates 	     can be used. */
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|innermost_block
operator|=
name|NULL
expr_stmt|;
comment|/* The issue arises of what context to evaluate this in.  The same 	 one as when it was set, but what does that mean when symbols have 	 been re-read?  We could save the filename and functionname, but 	 if the context is more local than that, the best we could do would 	 be something like how many levels deep and which index at that 	 particular level, but that's going to be less stable than filenames 	 or functionnames.  */
comment|/* So for now, just use a global context.  */
if|if
condition|(
name|b
operator|->
name|exp
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
name|b
operator|->
name|exp
operator|=
name|parse_expression
argument_list|(
name|b
operator|->
name|exp_string
argument_list|)
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|val
condition|)
name|value_free
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|b
operator|->
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
break|break;
comment|/* We needn't really do anything to reset these, since the mask        that requests them is unaffected by e.g., new libraries being        loaded. */
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Deleting unknown breakpoint type %d\n"
argument_list|,
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* fall through */
comment|/* Delete longjmp breakpoints, they will be reset later by        breakpoint_re_set.  */
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
comment|/* This breakpoint is special, it's set up when the inferior        starts and we really don't want to touch it.  */
case|case
name|bp_shlib_event
case|:
comment|/* Keep temporary breakpoints, which can be encountered when we step        over a dlopen call and SOLIB_ADD is resetting the breakpoints.        Otherwise these should have been blown away via the cleanup chain        or by breakpoint_init_inferior when we rerun the executable.  */
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_step_resume
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Re-set all breakpoints after symbols have been re-loaded.  */
end_comment

begin_function
name|void
name|breakpoint_re_set
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|enum
name|language
name|save_language
decl_stmt|;
name|int
name|save_input_radix
decl_stmt|;
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error in re-setting breakpoint %d:\n"
decl_stmt|;
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
comment|/* slop */
index|]
decl_stmt|;
name|save_language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|save_input_radix
operator|=
name|input_radix
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Format possible error msg */
name|catch_errors
argument_list|(
name|breakpoint_re_set_one
argument_list|,
name|b
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
name|set_language
argument_list|(
name|save_language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|save_input_radix
expr_stmt|;
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
name|create_longjmp_breakpoint
argument_list|(
literal|"longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"_longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"siglongjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"_siglongjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Took this out (temporarily at least), since it produces an extra       blank line at startup. This messes up the gdbtests. -PB */
comment|/* Blank line to finish off all those mention() messages we just printed.  */
block|printf_filtered ("\n");
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set ignore-count of breakpoint number BPTNUM to COUNT.    If from_tty is nonzero, it prints a message to that effect,    which ends with a period (no newline).  */
end_comment

begin_comment
comment|/* Reset the thread number of this breakpoint:     - If the breakpoint is for all threads, leave it as-is.    - Else, reset it to the current thread for inferior_pid. */
end_comment

begin_function
name|void
name|breakpoint_re_set_thread
parameter_list|(
name|b
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|in_thread_list
argument_list|(
name|inferior_pid
argument_list|)
condition|)
name|b
operator|->
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_ignore_count
parameter_list|(
name|bptnum
parameter_list|,
name|count
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|bptnum
decl_stmt|,
name|count
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bptnum
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|from_tty
condition|)
return|return;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Will stop next time breakpoint %d is reached."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"Will ignore next crossing of breakpoint %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Will ignore next %d crossings of breakpoint %d."
argument_list|,
name|count
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the ignore counts of all breakpoints.  */
end_comment

begin_function
name|void
name|breakpoint_clear_ignore_counts
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command to set ignore-count of breakpoint N to COUNT.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"a breakpoint number"
argument_list|)
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Second argument (specified ignore-count) is missing."
argument_list|)
expr_stmt|;
name|set_ignore_count
argument_list|(
name|num
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|parse_and_eval
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUNCTION on each of the breakpoints    whose numbers are given in ARGS.  */
end_comment

begin_function_decl
specifier|static
name|void
name|map_breakpoint_numbers
parameter_list|(
name|args
parameter_list|,
name|function
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more breakpoint numbers"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p1
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|related_breakpoint
init|=
name|b
operator|->
name|related_breakpoint
decl_stmt|;
name|function
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|related_breakpoint
condition|)
name|function
argument_list|(
name|related_breakpoint
argument_list|)
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf_unfiltered
argument_list|(
literal|"No breakpoint number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|disable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
comment|/* Never disable a watchpoint scope breakpoint; we want to      hit them when we leave scope so we can delete both the      watchpoint and its scope breakpoint at that time.  */
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint_scope
condition|)
return|return;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|modify_breakpoint_hook
condition|)
name|modify_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|disable_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|warning
argument_list|(
literal|"attempted to disable apparently deleted breakpoint #%d?\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|disable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|disable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_enable_breakpoint
parameter_list|(
name|bpt
parameter_list|,
name|disposition
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
name|enum
name|bpdisp
name|disposition
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|save_selected_frame
init|=
name|NULL
decl_stmt|;
name|int
name|save_selected_frame_level
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|target_resources_ok
decl_stmt|,
name|other_type_used
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|hw_breakpoint_used_count
argument_list|()
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|disposition
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|section
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
if|if
condition|(
name|bpt
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fr
init|=
comment|/* Ensure that we have the current frame.  Else, this              next query may pessimistically be answered as, "No,              not within current scope". */
name|get_current_frame
argument_list|()
decl_stmt|;
name|fr
operator|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|bpt
operator|->
name|watchpoint_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because the block in which its expression\n\ is valid is not currently in scope.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
return|return;
block|}
name|save_selected_frame
operator|=
name|selected_frame
expr_stmt|;
name|save_selected_frame_level
operator|=
name|selected_frame_level
expr_stmt|;
name|select_frame
argument_list|(
name|fr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|bpt
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|int
name|i
init|=
name|hw_watchpoint_used_count
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
operator|&
name|other_type_used
argument_list|)
decl_stmt|;
name|int
name|mem_cnt
init|=
name|can_use_hardware_watchpoint
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
decl_stmt|;
comment|/* Hack around 'unused var' error for some targets here */
operator|(
name|void
operator|)
name|mem_cnt
operator|,
name|i
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
comment|/* we can consider of type is bp_hardware_watchpoint, convert to  	   bp_watchpoint in the following condition */
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because target watch resources\n\ have been allocated for other watchpoints.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|save_selected_frame_level
operator|>=
literal|0
condition|)
name|select_and_print_frame
argument_list|(
name|save_selected_frame
argument_list|,
name|save_selected_frame_level
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modify_breakpoint_hook
condition|)
name|modify_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|do_enable_breakpoint
argument_list|(
name|bpt
argument_list|,
name|bpt
operator|->
name|disposition
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The enable command enables the specified breakpoints (or all defined    breakpoints) so they once again become (or continue to be) effective    in stopping the inferior. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|warning
argument_list|(
literal|"attempted to enable apparently deleted breakpoint #%d?\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|enable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|do_enable_breakpoint
argument_list|(
name|bpt
argument_list|,
name|disable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_once_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_once_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|do_enable_breakpoint
argument_list|(
name|bpt
argument_list|,
name|del
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_delete_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use default_breakpoint_'s, or nothing if they aren't valid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec_1
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_breakpoint
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|breakpoint_chain
operator|=
literal|0
expr_stmt|;
comment|/* Don't bother to call set_breakpoint_count.  $bpnum isn't useful      before a breakpoint is set.  */
name|breakpoint_count
operator|=
literal|0
expr_stmt|;
name|add_com
argument_list|(
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
name|ignore_command
argument_list|,
literal|"Set ignore-count of breakpoint number N to COUNT.\n\ Usage is `ignore N COUNT'."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"bc"
argument_list|,
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"commands"
argument_list|,
name|class_breakpoint
argument_list|,
name|commands_command
argument_list|,
literal|"Set commands to be executed when a breakpoint is hit.\n\ Give breakpoint number as argument after \"commands\".\n\ With no argument, the targeted breakpoint is the last one set.\n\ The commands themselves follow starting on the next line.\n\ Type a line containing \"end\" to indicate the end of them.\n\ Give \"silent\" as the first line to make the breakpoint silent;\n\ then no output is printed when it is hit, except what the commands print."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"condition"
argument_list|,
name|class_breakpoint
argument_list|,
name|condition_command
argument_list|,
literal|"Specify breakpoint number N to break only if COND is true.\n\ Usage is `condition N COND', where N is an integer and COND is an\n\ expression to be evaluated whenever breakpoint N is reached.  "
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|tbreak_command
argument_list|,
literal|"Set a temporary breakpoint.  Args like \"break\" command.\n\ Like \"break\" except the breakpoint is only temporary,\n\ so it will be deleted when hit.  Equivalent to \"break\" followed\n\ by using \"enable delete\" on the breakpoint number."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"txbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|tbreak_at_finish_command
argument_list|,
literal|"Set temporary breakpoint at procedure exit.  Either there should\n\ be no argument or the argument must be a depth.\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"hbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|hbreak_command
argument_list|,
literal|"Set a hardware assisted  breakpoint. Args like \"break\" command.\n\ Like \"break\" except the breakpoint requires hardware support,\n\ some target hardware may not have this support."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"thbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|thbreak_command
argument_list|,
literal|"Set a temporary hardware assisted breakpoint. Args like \"break\" command.\n\ Like \"hbreak\" except the breakpoint is only temporary,\n\ so it will be deleted when hit."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily."
argument_list|,
operator|&
name|enablelist
argument_list|,
literal|"enable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"ab"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"en"
argument_list|,
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_abbrev_prefix_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ This is used to cancel the effect of the \"disable\" command.\n\ May be abbreviated to simply \"enable\".\n"
argument_list|,
operator|&
name|enablebreaklist
argument_list|,
literal|"enable breakpoints "
argument_list|,
literal|1
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled."
argument_list|,
operator|&
name|disablelist
argument_list|,
literal|"disable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dis"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"disa"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"sb"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\ This command may be abbreviated \"disable\"."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ \n\ Also a prefix command for deletion of other GDB objects.\n\ The \"unset\" command is also an alias for \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|,
literal|"delete "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"d"
argument_list|,
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"db"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n"
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ This command may be abbreviated \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"clear"
argument_list|,
name|class_breakpoint
argument_list|,
name|clear_command
argument_list|,
name|concat
argument_list|(
literal|"Clear breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, all breakpoints in that line are cleared.\n\ If function is specified, breakpoints at beginning of function are cleared.\n\ If an address is specified, breakpoints at that address are cleared.\n\n"
argument_list|,
literal|"With no argument, clears all breakpoints in the line that the selected frame\n\ is executing in.\n\ \n\ See also the \"delete\" command which clears breakpoints by number."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_command
argument_list|,
name|concat
argument_list|(
literal|"Set breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, break at start of code for that line.\n\ If function is specified, break at start of code for that function.\n\ If an address is specified, break at that exact address.\n"
argument_list|,
literal|"With no arg, uses current execution address of selected stack frame.\n\ This is useful for breaking on return to a stack frame.\n\ \n\ Multiple breakpoints at one place are permitted, and useful if conditional.\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"b"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"br"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bre"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"brea"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"xbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_at_finish_command
argument_list|,
name|concat
argument_list|(
literal|"Set breakpoint at procedure exit. \n\ Argument may be function name, or \"*\" and an address.\n\ If function is specified, break at end of code for that function.\n\ If an address is specified, break at the end of the function that contains \n\ that exact address.\n"
argument_list|,
literal|"With no arg, uses current execution address of selected stack frame.\n\ This is useful for breaking on return to a stack frame.\n\ \n\ Multiple breakpoints at one place are permitted, and useful if conditional.\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"xb"
argument_list|,
literal|"xbreak"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"xbr"
argument_list|,
literal|"xbreak"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"xbre"
argument_list|,
literal|"xbreak"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"xbrea"
argument_list|,
literal|"xbreak"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"ba"
argument_list|,
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bu"
argument_list|,
literal|"ubreak"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"bx"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_at_finish_at_depth_command
argument_list|,
literal|"Set breakpoint at procedure exit.  Either there should\n\ be no argument or the argument must be a depth.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbx_commands
condition|)
block|{
name|add_abbrev_prefix_cmd
argument_list|(
literal|"stop"
argument_list|,
name|class_breakpoint
argument_list|,
name|stop_command
argument_list|,
literal|"Break in function/address or break at a line in the current file."
argument_list|,
operator|&
name|stoplist
argument_list|,
literal|"stop "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"in"
argument_list|,
name|class_breakpoint
argument_list|,
name|stopin_command
argument_list|,
literal|"Break in function or address.\n"
argument_list|,
operator|&
name|stoplist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"at"
argument_list|,
name|class_breakpoint
argument_list|,
name|stopat_command
argument_list|,
literal|"Break at a line in the current file.\n"
argument_list|,
operator|&
name|stoplist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_info
argument_list|(
literal|"breakpoints"
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"lb"
argument_list|,
name|class_breakpoint
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_breakpoints
argument_list|,
name|concat
argument_list|(
literal|"Status of all breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ \tlongjmp        - internal breakpoint used to step through longjmp()\n\ \tlongjmp resume - internal breakpoint at the target of longjmp()\n\ \tuntil          - internal breakpoint used by the \"until\" command\n\ \tfinish         - internal breakpoint used by the \"finish\" command\n"
argument_list|,
literal|"The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTENANCE_CMDS */
name|add_com
argument_list|(
literal|"catch"
argument_list|,
name|class_breakpoint
argument_list|,
name|catch_command
argument_list|,
literal|"Set catchpoints to catch events.\n\ Raised signals may be caught:\n\ \tcatch signal              - all signals\n\ \tcatch signal<signame>    - a particular signal\n\ Raised exceptions may be caught:\n\ \tcatch throw               - all exceptions, when thrown\n\ \tcatch throw<exceptname>  - a particular exception, when thrown\n\ \tcatch catch               - all exceptions, when caught\n\ \tcatch catch<exceptname>  - a particular exception, when caught\n\ Thread or process events may be caught:\n\ \tcatch thread_start        - any threads, just after creation\n\ \tcatch thread_exit         - any threads, just before expiration\n\ \tcatch thread_join         - any threads, just after joins\n\ Process events may be caught:\n\ \tcatch start               - any processes, just after creation\n\ \tcatch exit                - any processes, just before expiration\n\ \tcatch fork                - calls to fork()\n\ \tcatch vfork               - calls to vfork()\n\ \tcatch exec                - calls to exec()\n\ Dynamically-linked library events may be caught:\n\ \tcatch load                - loads of any library\n\ \tcatch load<libname>      - loads of a particular library\n\ \tcatch unload              - unloads of any library\n\ \tcatch unload<libname>    - unloads of a particular library\n\ The act of your program's execution stopping may also be caught:\n\ \tcatch stop\n\n\ C++ exceptions may be caught:\n\ \tcatch throw               - all exceptions, when thrown\n\ \tcatch catch               - all exceptions, when caught\n\ \n\ Do \"help set follow-fork-mode\" for info on debugging your program\n\ after a fork or vfork is caught.\n\n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tcatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|tcatch_command
argument_list|,
literal|"Set temporary catchpoints to catch events.\n\ Args like \"catch\" command.\n\ Like \"catch\" except the catchpoint is only temporary,\n\ so it will be deleted when hit.  Equivalent to \"catch\" followed\n\ by using \"enable delete\" on the catchpoint number."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"watch"
argument_list|,
name|class_breakpoint
argument_list|,
name|watch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression changes."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rwatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|rwatch_command
argument_list|,
literal|"Set a read watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression is read."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"awatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|awatch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression is either read or written."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"watchpoints"
argument_list|,
name|breakpoints_info
argument_list|,
literal|"Synonym for ``info breakpoints''."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"can-use-hw-watchpoints"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|can_use_hw_watchpoints
argument_list|,
literal|"Set debugger's willingness to use watchpoint hardware.\n\ If zero, gdb will not use hardware for new watchpoints, even if\n\ such is available.  (However, any hardware watchpoints that were\n\ created before setting this to nonzero, will continue to use watchpoint\n\ hardware.)"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|can_use_hw_watchpoints
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

