begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Everything about breakpoints, for GDB.    Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"thread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_comment
comment|/* local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|catch_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_delete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_delete_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_once_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_once_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disable_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_breakpoint_numbers
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|breakpoint
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breakpoint_re_set_one
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|get_catch_sals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|watch_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_use_hardware_watchpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mention
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab_and_line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_duplicates
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|describe_other_breakpoints
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breakpoints_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breakpoint_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bpstat
name|bpstat_alloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|,
name|bpstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breakpoint_cond_eval
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup_executing_breakpoints
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|commands_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|condition_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_breakpoint_count
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remove_breakpoint
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print machine addresses? */
end_comment

begin_comment
comment|/* Are we executing breakpoint commands?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_breakpoint_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Walk the following statement or block through all breakpoints.    ALL_BREAKPOINTS_SAFE does so even if the statment deletes the current    breakpoint.  */
end_comment

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS
parameter_list|(
name|b
parameter_list|)
value|for (b = breakpoint_chain; b; b = b->next)
end_define

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS_SAFE
parameter_list|(
name|b
parameter_list|,
name|tmp
parameter_list|)
define|\
value|for (b = breakpoint_chain;	\ 	     b? (tmp=b->next, 1): 0;	\ 	     b = tmp)
end_define

begin_comment
comment|/* True if breakpoint hit counts should be displayed in breakpoint info.  */
end_comment

begin_decl_stmt
name|int
name|show_breakpoint_hit_counts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all breakpoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last breakpoint made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set breakpoint count to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_breakpoint_count
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|breakpoint_count
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"bpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in run_command to zero the hit count when a new run starts. */
end_comment

begin_function
name|void
name|clear_breakpoint_hit_counts
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|hit_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default address, symtab and line to put a breakpoint at    for "break" command with no arg.    if default_breakpoint_valid is zero, the other three are    not valid, and "break" with no arg is an error.     This set by print_stack_frame, which calls set_default_breakpoint.  */
end_comment

begin_decl_stmt
name|int
name|default_breakpoint_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|default_breakpoint_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|default_breakpoint_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_breakpoint_line
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* *PP is a string denoting a breakpoint.  Get the number of the breakpoint.    Advance *PP after the string and any trailing whitespace.     Currently the string can either be a number or "$" followed by the name    of a convenience variable.  Making it an expression wouldn't work well    for map_breakpoint_numbers (e.g. "4 + 5 + 6").  */
end_comment

begin_function
specifier|static
name|int
name|get_number
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Empty line means refer to the last breakpoint.  */
return|return
name|breakpoint_count
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
comment|/* Make a copy of the name, so we can null-terminate it 	 to pass to lookup_internalvar().  */
name|char
modifier|*
name|varname
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|++
name|p
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
name|p
operator|++
expr_stmt|;
name|varname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|varname
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
name|varname
index|[
name|p
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|varname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variables used to specify breakpoints must have integer values."
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|pp
condition|)
comment|/* There is no number here.  (e.g. "cond a == b").  */
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|atoi
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
name|error
argument_list|(
literal|"breakpoint number expected"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* condition N EXP -- set break condition of breakpoint N to EXP.  */
end_comment

begin_function
specifier|static
name|void
name|condition_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Breakpoint %d now unconditional.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|p
expr_stmt|;
comment|/* I don't know if it matters whether this is the string the user 	       typed in or the decompiled expression.  */
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of expression"
argument_list|)
expr_stmt|;
block|}
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|commands_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
comment|/* If we allowed this, we would have problems with when to      free the storage, if we change the commands currently      being read from.  */
if|if
condition|(
name|executing_breakpoint_commands
condition|)
name|error
argument_list|(
literal|"Can't use the \"commands\" command among a breakpoint's commands."
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"Unexpected extra arguments following breakpoint number."
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|from_tty
operator|&&
name|input_from_terminal_p
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"Type commands for when breakpoint %d is hit, one per line.\n\ End with a line saying just \"end\".\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|l
operator|=
name|read_command_lines
argument_list|()
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|b
operator|->
name|commands
argument_list|)
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|l
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|memory_breakpoint_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from mem-break.c */
end_comment

begin_comment
comment|/* Like target_read_memory() but if breakpoints are inserted, return    the shadow contents instead of the breakpoints themselves.     Read "memory data" from whatever target or inferior we have.     Returns zero if successful, errno value if not.  EIO is used    for address out of bounds.  If breakpoints are inserted, returns    shadow contents, not the breakpoints themselves.  From breakpoint.c.  */
end_comment

begin_function
name|int
name|read_memory_nobpt
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|memory_breakpoint_size
operator|<
literal|0
condition|)
comment|/* No breakpoints on this machine.  FIXME: This should be        dependent on the debugging target.  Probably want        target_insert_breakpoint to return a size, saying how many        bytes of the shadow contents are used, or perhaps have        something like target_xfer_shadow.  */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|||
operator|!
name|b
operator|->
name|inserted
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|b
operator|->
name|address
operator|+
name|memory_breakpoint_size
operator|<=
name|memaddr
condition|)
comment|/* The breakpoint is entirely before the chunk of memory 	   we are reading.  */
continue|continue;
elseif|else
if|if
condition|(
name|b
operator|->
name|address
operator|>=
name|memaddr
operator|+
name|len
condition|)
comment|/* The breakpoint is entirely after the chunk of memory we 	   are reading.  */
continue|continue;
else|else
block|{
comment|/* Copy the breakpoint from the shadow contents, and recurse 	     for the things before and after.  */
comment|/* Addresses and length of the part of the breakpoint that 	     we need to copy.  */
name|CORE_ADDR
name|membpt
init|=
name|b
operator|->
name|address
decl_stmt|;
name|unsigned
name|int
name|bptlen
init|=
name|memory_breakpoint_size
decl_stmt|;
comment|/* Offset within shadow_contents.  */
name|int
name|bptoffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|membpt
operator|<
name|memaddr
condition|)
block|{
comment|/* Only copy the second part of the breakpoint.  */
name|bptlen
operator|-=
name|memaddr
operator|-
name|membpt
expr_stmt|;
name|bptoffset
operator|=
name|memaddr
operator|-
name|membpt
expr_stmt|;
name|membpt
operator|=
name|memaddr
expr_stmt|;
block|}
if|if
condition|(
name|membpt
operator|+
name|bptlen
operator|>
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Only copy the first part of the breakpoint.  */
name|bptlen
operator|-=
operator|(
name|membpt
operator|+
name|bptlen
operator|)
operator|-
operator|(
name|memaddr
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|myaddr
operator|+
name|membpt
operator|-
name|memaddr
argument_list|,
name|b
operator|->
name|shadow_contents
operator|+
name|bptoffset
argument_list|,
name|bptlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|membpt
operator|>
name|memaddr
condition|)
block|{
comment|/* Copy the section of memory before the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|membpt
operator|-
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|membpt
operator|+
name|bptlen
operator|<
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Copy the section of memory after the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|membpt
operator|+
name|bptlen
argument_list|,
name|myaddr
operator|+
name|membpt
operator|+
name|bptlen
operator|-
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
operator|-
operator|(
name|membpt
operator|+
name|bptlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/* Nothing overlaps.  Just call read_memory_noerr.  */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* insert_breakpoints is used when starting or continuing the program.    remove_breakpoints is used when the program stops.    Both return zero if successful,    or an `errno' value if could not write the inferior.  */
end_comment

begin_function
name|int
name|insert_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|disabled_breaks
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
comment|/* Can't set the breakpoint.  */
if|#
directive|if
name|defined
argument_list|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|)
if|if
condition|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|(
name|b
operator|->
name|address
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|shlib_disabled
expr_stmt|;
if|if
condition|(
operator|!
name|disabled_breaks
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Temporarily disabling shared library breakpoints:\n"
argument_list|)
expr_stmt|;
block|}
name|disabled_breaks
operator|=
literal|1
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ONE_PROCESS_WRITETEXT
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memory_error
argument_list|(
name|val
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* which bombs us out */
block|}
block|}
else|else
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|saved_frame
decl_stmt|;
name|int
name|saved_level
decl_stmt|,
name|within_current_scope
decl_stmt|;
name|value_ptr
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
comment|/* Save the current frame and level so we can restore it after 	   evaluating the watchpoint expression on its own frame.  */
name|saved_frame
operator|=
name|selected_frame
expr_stmt|;
name|saved_level
operator|=
name|selected_frame_level
expr_stmt|;
comment|/* Determine if the watchpoint is within scope.  */
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|==
name|NULL
condition|)
name|within_current_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|struct
name|frame_info
modifier|*
name|fi
init|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|b
operator|->
name|watchpoint_frame
argument_list|)
decl_stmt|;
name|within_current_scope
operator|=
operator|(
name|fi
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|within_current_scope
condition|)
name|select_frame
argument_list|(
name|fi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* Evaluate the expression and cut the chain of values 	       produced off from the value chain.  */
name|v
operator|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
name|value_release_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|b
operator|->
name|val_chain
operator|=
name|v
expr_stmt|;
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
comment|/* Look at each value on the value chain.  */
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
comment|/* If it's a memory location, then we must watch it.  */
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|int
name|addr
decl_stmt|,
name|len
decl_stmt|,
name|type
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
name|type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
name|type
operator|=
literal|2
expr_stmt|;
name|val
operator|=
name|target_insert_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Failure to insert a watchpoint on any memory value in the 	       value chain brings us here.  */
if|if
condition|(
operator|!
name|b
operator|->
name|inserted
condition|)
name|warning
argument_list|(
literal|"Hardware watchpoint %d: Could not insert watchpoint\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\ Hardware watchpoint %d deleted because the program has left the block in\n\ which its expression is valid.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|delete_breakpoint
argument_list|(
name|b
operator|->
name|related_breakpoint
argument_list|)
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the frame and level.  */
name|select_frame
argument_list|(
name|saved_frame
argument_list|,
name|saved_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disabled_breaks
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|remove_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|remove_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_breakpoint
parameter_list|(
name|b
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|val
operator|=
name|target_remove_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|value_ptr
name|v
decl_stmt|,
name|n
decl_stmt|;
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
comment|/* Walk down the saved value chain.  */
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
comment|/* For each memory reference remove the watchpoint 	     at that address.  */
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|int
name|addr
decl_stmt|,
name|len
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|target_remove_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Failure to remove any of the hardware watchpoints comes here.  */
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
name|warning
argument_list|(
literal|"Hardware watchpoint %d: Could not remove watchpoint\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Free the saved value chain.  We will construct a new one 	 the next time the watchpoint is inserted.  */
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|n
control|)
block|{
name|n
operator|=
name|v
operator|->
name|next
expr_stmt|;
name|value_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|val_chain
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints.  */
end_comment

begin_function
name|void
name|mark_breakpoints_out
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints and delete any breakpoints    which should go away between runs of the program.  */
end_comment

begin_function
name|void
name|breakpoint_init_inferior
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
comment|/* If the call dummy breakpoint is at the entry point it will 	 cause problems when the inferior is rerun, so we better 	 get rid of it.  */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_call_dummy
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Likewise for scope breakpoints.  */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint_scope
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Likewise for watchpoints on local expressions.  */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* breakpoint_here_p (PC) returns 1 if an enabled breakpoint exists at PC.    When continuing from a location with a breakpoint,    we actually single step once before calling insert_breakpoints.  */
end_comment

begin_function
name|int
name|breakpoint_here_p
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FRAME is a dummy frame.  We can't use PC_IN_CALL_DUMMY    because figuring out the saved SP would take too much time, at least using    get_saved_register on the 68k.  This means that for this function to    work right a port must use the bp_call_dummy breakpoint.  */
end_comment

begin_function
name|int
name|frame_in_dummy
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
ifdef|#
directive|ifdef
name|CALL_DUMMY
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
specifier|static
name|unsigned
name|LONGEST
name|dummy
index|[]
init|=
name|CALL_DUMMY
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_call_dummy
operator|&&
name|b
operator|->
name|frame
operator|==
name|frame
operator|->
name|frame
comment|/* We need to check the PC as well as the frame on the sparc, 	     for signals.exp in the testsuite.  */
operator|&&
operator|(
name|frame
operator|->
name|pc
operator|>=
operator|(
name|b
operator|->
name|address
operator|-
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|REGISTER_SIZE
operator|)
operator|)
operator|&&
name|frame
operator|->
name|pc
operator|<=
name|b
operator|->
name|address
condition|)
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* CALL_DUMMY */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* breakpoint_match_thread (PC, PID) returns true if the breakpoint at PC    is valid for process/thread PID.  */
end_comment

begin_function
name|int
name|breakpoint_thread_match
parameter_list|(
name|pc
parameter_list|,
name|pid
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
operator|&&
operator|(
name|b
operator|->
name|thread
operator|==
operator|-
literal|1
operator|||
name|b
operator|->
name|thread
operator|==
name|thread
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* bpstat stuff.  External routines' interfaces are documented    in breakpoint.h.  */
end_comment

begin_comment
comment|/* Clear a bpstat so that it says we are not at any breakpoint.    Also free any storage that is part of a bpstat.  */
end_comment

begin_function
name|void
name|bpstat_clear
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|bpstat
name|p
decl_stmt|;
name|bpstat
name|q
decl_stmt|;
if|if
condition|(
name|bsp
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|*
name|bsp
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|old_val
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|p
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
operator|*
name|bsp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a copy of a bpstat.  Like "bs1 = bs2" but all storage that    is part of the bpstat is copied as well.  */
end_comment

begin_function
name|bpstat
name|bpstat_copy
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
name|bpstat
name|p
init|=
name|NULL
decl_stmt|;
name|bpstat
name|tmp
decl_stmt|;
name|bpstat
name|retval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
return|return
name|bs
return|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|tmp
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|bs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* This is the first thing in the chain.  */
name|retval
operator|=
name|tmp
expr_stmt|;
else|else
name|p
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Find the bpstat associated with this breakpoint */
end_comment

begin_function
name|bpstat
name|bpstat_find_breakpoint
parameter_list|(
name|bsp
parameter_list|,
name|breakpoint
parameter_list|)
name|bpstat
name|bsp
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
block|{
if|if
condition|(
name|bsp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|bsp
operator|!=
name|NULL
condition|;
name|bsp
operator|=
name|bsp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bsp
operator|->
name|breakpoint_at
operator|==
name|breakpoint
condition|)
return|return
name|bsp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the breakpoint number of the first breakpoint we are stopped    at.  *BSP upon return is a bpstat which points to the remaining    breakpoints stopped at (but which is not guaranteed to be good for    anything but further calls to bpstat_num).    Return 0 if passed a bpstat which does not indicate any breakpoints.  */
end_comment

begin_function
name|int
name|bpstat_num
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|bsp
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* No more breakpoint values */
else|else
block|{
name|b
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|breakpoint_at
expr_stmt|;
operator|*
name|bsp
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* breakpoint that's been deleted since */
else|else
return|return
name|b
operator|->
name|number
return|;
comment|/* We have its number */
block|}
block|}
end_function

begin_comment
comment|/* Modify BS so that the actions will not be performed.  */
end_comment

begin_function
name|void
name|bpstat_clear_actions
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Stub for cleaning up our state if we error-out of a breakpoint command */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|cleanup_executing_breakpoints
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute all the commands associated with all the breakpoints at this    location.  Any of these commands could cause the process to proceed    beyond this point, etc.  We look out for such changes by checking    the global "breakpoint_proceeded" after each command.  */
end_comment

begin_function
name|void
name|bpstat_do_actions
parameter_list|(
name|bsp
parameter_list|)
name|bpstat
modifier|*
name|bsp
decl_stmt|;
block|{
name|bpstat
name|bs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
name|executing_breakpoint_commands
operator|=
literal|1
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|cleanup_executing_breakpoints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top
label|:
name|bs
operator|=
operator|*
name|bsp
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|cmd
operator|=
name|bs
operator|->
name|commands
expr_stmt|;
while|while
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
name|execute_control_command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|breakpoint_proceeded
condition|)
comment|/* The inferior is proceeded by the command; bomb out now. 	   The bpstat chain has been blown away by wait_for_inferior. 	   But since execution has stopped again, there is a new bpstat 	   to look at, so start over.  */
goto|goto
name|top
goto|;
else|else
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
block|}
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the normal print_it function for a bpstat.  In the future,    much of this logic could (should?) be moved to bpstat_stop_status,    by having it set different print_it functions.  */
end_comment

begin_function
specifier|static
name|int
name|print_it_normal
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
comment|/* bs->breakpoint_at can be NULL if it was a momentary breakpoint      which has since been deleted.  */
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
operator|||
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_breakpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_breakpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
comment|/* I think the user probably only wants to see one breakpoint 	 number, not all of them.  */
name|annotate_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nBreakpoint %d, "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
condition|)
block|{
name|annotate_watchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nOld value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|old_val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nNew value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
comment|/* More than one watchpoint may have been triggered.  */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
block|{
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nValue = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* We can't deal with it.  Maybe another member of the bpstat chain can.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a message indicating what happened.  Returns nonzero to    say that only the source line should be printed after this (zero    return means print the frame as well as the source line).  */
end_comment

begin_comment
comment|/* Currently we always return zero.  */
end_comment

begin_function
name|int
name|bpstat_print
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|val
operator|=
call|(
modifier|*
name|bs
operator|->
name|print_it
call|)
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Maybe another breakpoint in the chain caused us to stop.      (Currently all watchpoints go on the bpstat whether hit or      not.  That probably could (should) be changed, provided care is taken      with respect to bpstat_explains_signal).  */
if|if
condition|(
name|bs
operator|->
name|next
condition|)
return|return
name|bpstat_print
argument_list|(
name|bs
operator|->
name|next
argument_list|)
return|;
comment|/* We reached the end of the chain without printing anything.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the expression EXP and return 1 if value is zero.    This is used inside a catch_errors to evaluate the breakpoint condition.     The argument is a "struct expression *" that has been cast to char * to     make it pass through catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_cond_eval
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|value_ptr
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|!
name|value_true
argument_list|(
name|evaluate_expression
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new bpstat and chain it to the current one.  */
end_comment

begin_function
specifier|static
name|bpstat
name|bpstat_alloc
parameter_list|(
name|b
parameter_list|,
name|cbs
parameter_list|)
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|bpstat
name|cbs
decl_stmt|;
comment|/* Current "bs" value */
block|{
name|bpstat
name|bs
decl_stmt|;
name|bs
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|cbs
operator|->
name|next
operator|=
name|bs
expr_stmt|;
name|bs
operator|->
name|breakpoint_at
operator|=
name|b
expr_stmt|;
comment|/* If the condition is false, etc., don't do the commands.  */
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|print_it
operator|=
name|print_it_normal
expr_stmt|;
return|return
name|bs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Possible return values for watchpoint_check (this can't be an enum    because of check_errors).  */
end_comment

begin_comment
comment|/* The watchpoint has been deleted.  */
end_comment

begin_define
define|#
directive|define
name|WP_DELETED
value|1
end_define

begin_comment
comment|/* The value has changed.  */
end_comment

begin_define
define|#
directive|define
name|WP_VALUE_CHANGED
value|2
end_define

begin_comment
comment|/* The value has not changed.  */
end_comment

begin_define
define|#
directive|define
name|WP_VALUE_NOT_CHANGED
value|3
end_define

begin_define
define|#
directive|define
name|BP_TEMPFLAG
value|1
end_define

begin_define
define|#
directive|define
name|BP_HARDWAREFLAG
value|2
end_define

begin_comment
comment|/* Check watchpoint condition.  */
end_comment

begin_function
specifier|static
name|int
name|watchpoint_check
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|bpstat
name|bs
init|=
operator|(
name|bpstat
operator|)
name|p
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fr
decl_stmt|;
name|int
name|within_current_scope
decl_stmt|;
name|b
operator|=
name|bs
operator|->
name|breakpoint_at
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|==
name|NULL
condition|)
name|within_current_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* There is no current frame at this moment.  If we're going to have 	 any chance of handling watchpoints on local variables, we'll need 	 the frame chain (so we can determine if we're in scope).  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|fr
operator|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|b
operator|->
name|watchpoint_frame
argument_list|)
expr_stmt|;
name|within_current_scope
operator|=
operator|(
name|fr
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|within_current_scope
condition|)
comment|/* If we end up stopping, the current frame will get selected 	   in normal_stop.  So this call to select_frame won't affect 	   the user.  */
name|select_frame
argument_list|(
name|fr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* We use value_{,free_to_}mark because it could be a          *long* time before we return to the command level and 	 call free_all_values.  We can't call free_all_values because 	 we might be in the middle of evaluating a function call.  */
name|value_ptr
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|value_ptr
name|new_val
init|=
name|evaluate_expression
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value_equal
argument_list|(
name|b
operator|->
name|val
argument_list|,
name|new_val
argument_list|)
condition|)
block|{
name|release_value
argument_list|(
name|new_val
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|b
operator|->
name|val
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|new_val
expr_stmt|;
comment|/* We will stop here */
return|return
name|WP_VALUE_CHANGED
return|;
block|}
else|else
block|{
comment|/* Nothing changed, don't do anything.  */
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
comment|/* We won't stop here */
return|return
name|WP_VALUE_NOT_CHANGED
return|;
block|}
block|}
else|else
block|{
comment|/* This seems like the only logical thing to do because 	 if we temporarily ignored the watchpoint, then when 	 we reenter the block in which it is valid it contains 	 garbage (in the case of a function, it may have two 	 garbage values, one before and one after the prologue). 	 So we can't even detect the first assignment to it and 	 watch after that (since the garbage may or may not equal 	 the first value assigned).  */
name|printf_filtered
argument_list|(
literal|"\ Watchpoint %d deleted because the program has left the block in\n\ which its expression is valid.\n"
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|delete_breakpoint
argument_list|(
name|b
operator|->
name|related_breakpoint
argument_list|)
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|WP_DELETED
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is used when everything which needs to be printed has    already been printed.  But we still want to print the frame.  */
end_comment

begin_function
specifier|static
name|int
name|print_it_done
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is used when nothing should be printed for this bpstat entry.  */
end_comment

begin_function
specifier|static
name|int
name|print_it_noop
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a bpstat associated with having just stopped at address *PC    and frame address CORE_ADDRESS.  Update *PC to point at the    breakpoint (if we hit a breakpoint).  NOT_A_BREAKPOINT is nonzero    if this is known to not be a real breakpoint (it could still be a    watchpoint, though).  */
end_comment

begin_comment
comment|/* Determine whether we stopped at a breakpoint, etc, or whether we    don't understand this stop.  Result is a chain of bpstat's such that:  	if we don't understand the stop, the result is a null pointer.  	if we understand why we stopped, the result is not null.  	Each element of the chain refers to a particular breakpoint or 	watchpoint at which we have stopped.  (We may have stopped for 	several reasons concurrently.)  	Each element of the chain has valid next, breakpoint_at, 	commands, FIXME??? fields.   */
end_comment

begin_function
name|bpstat
name|bpstat_stop_status
parameter_list|(
name|pc
parameter_list|,
name|not_a_breakpoint
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
name|int
name|not_a_breakpoint
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|CORE_ADDR
name|bp_addr
decl_stmt|;
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
comment|/* True if we've hit a breakpoint (as opposed to a watchpoint).  */
name|int
name|real_breakpoint
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* Root of the chain of bpstat's */
name|struct
name|bpstats
name|root_bs
index|[
literal|1
index|]
decl_stmt|;
comment|/* Pointer to the last thing in the chain currently.  */
name|bpstat
name|bs
init|=
name|root_bs
decl_stmt|;
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error evaluating expression for watchpoint %d\n"
decl_stmt|;
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
comment|/* slop */
index|]
decl_stmt|;
comment|/* Get the address where the breakpoint would have been.  */
name|bp_addr
operator|=
operator|*
name|pc
operator|-
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|disabled
operator|||
name|b
operator|->
name|enable
operator|==
name|shlib_disabled
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|address
operator|!=
name|bp_addr
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|address
operator|!=
operator|(
name|bp_addr
operator|-
name|DECR_PC_AFTER_HW_BREAK
operator|)
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|not_a_breakpoint
condition|)
continue|continue;
comment|/* Come here if it's a watchpoint, or if the break address matches */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
name|bs
operator|=
name|bpstat_alloc
argument_list|(
name|b
argument_list|,
name|bs
argument_list|)
expr_stmt|;
comment|/* Alloc a bpstat to explain stop */
name|bs
operator|->
name|stop
operator|=
literal|1
expr_stmt|;
name|bs
operator|->
name|print
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
condition|)
block|{
switch|switch
condition|(
name|catch_errors
argument_list|(
name|watchpoint_check
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bs
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
case|case
name|WP_DELETED
case|:
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_CHANGED
case|:
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_NOT_CHANGED
case|:
comment|/* Don't stop.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
continue|continue;
default|default:
comment|/* Can't happen.  */
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* Error from catch_errors.  */
name|printf_filtered
argument_list|(
literal|"Watchpoint %d deleted.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|delete_breakpoint
argument_list|(
name|b
operator|->
name|related_breakpoint
argument_list|)
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|target_stopped_data_address
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|CORE_ADDR
name|vaddr
decl_stmt|;
name|vaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|vaddr
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
switch|switch
condition|(
name|catch_errors
argument_list|(
name|watchpoint_check
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bs
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
case|case
name|WP_DELETED
case|:
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_CHANGED
case|:
case|case
name|WP_VALUE_NOT_CHANGED
case|:
comment|/* Stop.  */
break|break;
default|default:
comment|/* Can't happen.  */
case|case
literal|0
case|:
comment|/* Error from catch_errors.  */
name|printf_filtered
argument_list|(
literal|"Watchpoint %d deleted.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|delete_breakpoint
argument_list|(
name|b
operator|->
name|related_breakpoint
argument_list|)
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
else|else
name|real_breakpoint
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|b
operator|->
name|frame
operator|&&
name|b
operator|->
name|frame
operator|!=
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|frame
condition|)
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|value_is_zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
comment|/* Need to select the frame, with all that implies 		 so that the conditions will have the right context.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value_is_zero
operator|=
name|catch_errors
argument_list|(
name|breakpoint_cond_eval
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|b
operator|->
name|cond
operator|)
argument_list|,
literal|"Error in testing breakpoint condition:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* FIXME-someday, should give breakpoint # */
name|free_all_values
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
operator|&&
name|value_is_zero
condition|)
block|{
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|ignore_count
operator|>
literal|0
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|--
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We will stop here */
if|if
condition|(
name|b
operator|->
name|disposition
operator|==
name|disable
condition|)
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|bs
operator|->
name|commands
operator|=
name|b
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|silent
condition|)
name|bs
operator|->
name|print
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|commands
operator|&&
name|STREQ
argument_list|(
literal|"silent"
argument_list|,
name|bs
operator|->
name|commands
operator|->
name|line
argument_list|)
condition|)
block|{
name|bs
operator|->
name|commands
operator|=
name|bs
operator|->
name|commands
operator|->
name|next
expr_stmt|;
name|bs
operator|->
name|print
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Print nothing for this entry if we dont stop or if we dont print.  */
if|if
condition|(
name|bs
operator|->
name|stop
operator|==
literal|0
operator|||
name|bs
operator|->
name|print
operator|==
literal|0
condition|)
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
block|}
name|bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Terminate the chain */
name|bs
operator|=
name|root_bs
operator|->
name|next
expr_stmt|;
comment|/* Re-grab the head of the chain */
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|!=
literal|0
operator|||
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
if|if
condition|(
name|bs
condition|)
block|{
if|if
condition|(
name|real_breakpoint
condition|)
block|{
operator|*
name|pc
operator|=
name|bp_addr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHIFT_INST_REGS
argument_list|)
name|SHIFT_INST_REGS
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* No SHIFT_INST_REGS.  */
name|write_pc
argument_list|(
name|bp_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No SHIFT_INST_REGS.  */
block|}
block|}
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK != 0.  */
comment|/* The value of a hardware watchpoint hasn't changed, but the      intermediate memory locations we are watching may have.  */
if|if
condition|(
name|bs
operator|&&
operator|!
name|bs
operator|->
name|stop
operator|&&
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
condition|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
return|return
name|bs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell what to do about this bpstat.  */
end_comment

begin_function
name|struct
name|bpstat_what
name|bpstat_what
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
comment|/* Classify each bpstat as one of the following.  */
enum|enum
name|class
block|{
comment|/* This bpstat element has no effect on the main_action.  */
name|no_effect
init|=
literal|0
block|,
comment|/* There was a watchpoint, stop but don't print.  */
name|wp_silent
block|,
comment|/* There was a watchpoint, stop and print.  */
name|wp_noisy
block|,
comment|/* There was a breakpoint but we're not stopping.  */
name|bp_nostop
block|,
comment|/* There was a breakpoint, stop but don't print.  */
name|bp_silent
block|,
comment|/* There was a breakpoint, stop and print.  */
name|bp_noisy
block|,
comment|/* We hit the longjmp breakpoint.  */
name|long_jump
block|,
comment|/* We hit the longjmp_resume breakpoint.  */
name|long_resume
block|,
comment|/* We hit the step_resume breakpoint.  */
name|step_resume
block|,
comment|/* We hit the through_sigtramp breakpoint.  */
name|through_sig
block|,
comment|/* We hit the shared library event breakpoint.  */
name|shlib_event
block|,
comment|/* This is just used to count how many enums there are.  */
name|class_last
block|}
enum|;
comment|/* Here is the table which drives this routine.  So that we can      format it pretty, we define some abbreviations for the      enum bpstat_what codes.  */
define|#
directive|define
name|kc
value|BPSTAT_WHAT_KEEP_CHECKING
define|#
directive|define
name|ss
value|BPSTAT_WHAT_STOP_SILENT
define|#
directive|define
name|sn
value|BPSTAT_WHAT_STOP_NOISY
define|#
directive|define
name|sgl
value|BPSTAT_WHAT_SINGLE
define|#
directive|define
name|slr
value|BPSTAT_WHAT_SET_LONGJMP_RESUME
define|#
directive|define
name|clr
value|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
define|#
directive|define
name|clrs
value|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
define|#
directive|define
name|sr
value|BPSTAT_WHAT_STEP_RESUME
define|#
directive|define
name|ts
value|BPSTAT_WHAT_THROUGH_SIGTRAMP
define|#
directive|define
name|shl
value|BPSTAT_WHAT_CHECK_SHLIBS
comment|/* "Can't happen."  Might want to print an error message.    abort() is not out of the question, but chances are GDB is just    a bit confused, not unusable.  */
define|#
directive|define
name|err
value|BPSTAT_WHAT_STOP_NOISY
comment|/* Given an old action and a class, come up with a new action.  */
comment|/* One interesting property of this table is that wp_silent is the same      as bp_silent and wp_noisy is the same as bp_noisy.  That is because      after stopping, the check for whether to step over a breakpoint      (BPSTAT_WHAT_SINGLE type stuff) is handled in proceed() without      reference to how we stopped.  We retain separate wp_silent and bp_silent      codes in case we want to change that someday.  */
comment|/* step_resume entries: a step resume breakpoint overrides another      breakpoint of signal handling (see comment in wait_for_inferior      at first IN_SIGTRAMP where we set the step_resume breakpoint).  */
comment|/* We handle the through_sigtramp_breakpoint the same way; having both      one of those and a step_resume_breakpoint is probably very rare (?).  */
specifier|static
specifier|const
name|enum
name|bpstat_what_main_action
name|table
index|[
operator|(
name|int
operator|)
name|class_last
index|]
index|[
operator|(
name|int
operator|)
name|BPSTAT_WHAT_LAST
index|]
init|=
block|{
comment|/*                              old action */
comment|/*       kc   ss   sn   sgl   slr  clr   clrs  sr   ts  shl 	 */
comment|/*no_effect*/
block|{
name|kc
block|,
name|ss
block|,
name|sn
block|,
name|sgl
block|,
name|slr
block|,
name|clr
block|,
name|clrs
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*wp_silent*/
block|{
name|ss
block|,
name|ss
block|,
name|sn
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*wp_noisy*/
block|{
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*bp_nostop*/
block|{
name|sgl
block|,
name|ss
block|,
name|sn
block|,
name|sgl
block|,
name|slr
block|,
name|clrs
block|,
name|clrs
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*bp_silent*/
block|{
name|ss
block|,
name|ss
block|,
name|sn
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*bp_noisy*/
block|{
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*long_jump*/
block|{
name|slr
block|,
name|ss
block|,
name|sn
block|,
name|slr
block|,
name|err
block|,
name|err
block|,
name|err
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*long_resume*/
block|{
name|clr
block|,
name|ss
block|,
name|sn
block|,
name|clrs
block|,
name|err
block|,
name|err
block|,
name|err
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*step_resume*/
block|{
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*through_sig*/
block|{
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|shl
block|}
block|,
comment|/*shlib*/
block|{
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|ts
block|,
name|shl
block|}
block|}
decl_stmt|;
undef|#
directive|undef
name|kc
undef|#
directive|undef
name|ss
undef|#
directive|undef
name|sn
undef|#
directive|undef
name|sgl
undef|#
directive|undef
name|slr
undef|#
directive|undef
name|clr
undef|#
directive|undef
name|clrs
undef|#
directive|undef
name|err
undef|#
directive|undef
name|sr
undef|#
directive|undef
name|ts
undef|#
directive|undef
name|shl
name|enum
name|bpstat_what_main_action
name|current_action
init|=
name|BPSTAT_WHAT_KEEP_CHECKING
decl_stmt|;
name|struct
name|bpstat_what
name|retval
decl_stmt|;
name|retval
operator|.
name|call_dummy
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|enum
name|class
name|bs_class
init|=
name|no_effect
decl_stmt|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
condition|)
comment|/* I suspect this can happen if it was a momentary breakpoint 	   which has since been deleted.  */
continue|continue;
switch|switch
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|bp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
block|}
else|else
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|wp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|wp_silent
expr_stmt|;
block|}
else|else
comment|/* There was a watchpoint, but we're not stopping.  This requires 	       no further action.  */
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_longjmp
case|:
name|bs_class
operator|=
name|long_jump
expr_stmt|;
break|break;
case|case
name|bp_longjmp_resume
case|:
name|bs_class
operator|=
name|long_resume
expr_stmt|;
break|break;
case|case
name|bp_step_resume
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
name|bs_class
operator|=
name|step_resume
expr_stmt|;
block|}
else|else
comment|/* It is for the wrong frame.  */
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_through_sigtramp
case|:
name|bs_class
operator|=
name|through_sig
expr_stmt|;
break|break;
case|case
name|bp_watchpoint_scope
case|:
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_shlib_event
case|:
name|bs_class
operator|=
name|shlib_event
expr_stmt|;
break|break;
case|case
name|bp_call_dummy
case|:
comment|/* Make sure the action is stop (silent or noisy), so infrun.c 	     pops the dummy frame.  */
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
name|retval
operator|.
name|call_dummy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|current_action
operator|=
name|table
index|[
operator|(
name|int
operator|)
name|bs_class
index|]
index|[
operator|(
name|int
operator|)
name|current_action
index|]
expr_stmt|;
block|}
name|retval
operator|.
name|main_action
operator|=
name|current_action
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we should step constantly (e.g. watchpoints on machines    without hardware support).  This isn't related to a specific bpstat,    just to things like whether watchpoints are set.  */
end_comment

begin_function
name|int
name|bpstat_should_step
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
operator|&&
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print information on breakpoint number BNUM, or -1 if all.    If WATCHPOINTS is zero, process only breakpoints; if WATCHPOINTS    is nonzero, process only watchpoints.  */
end_comment

begin_function
specifier|static
name|void
name|breakpoint_1
parameter_list|(
name|bnum
parameter_list|,
name|allflag
parameter_list|)
name|int
name|bnum
decl_stmt|;
name|int
name|allflag
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|found_a_breakpoint
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|bptypes
index|[]
init|=
block|{
literal|"breakpoint"
block|,
literal|"hw breakpoint"
block|,
literal|"until"
block|,
literal|"finish"
block|,
literal|"watchpoint"
block|,
literal|"hw watchpoint"
block|,
literal|"read watchpoint"
block|,
literal|"acc watchpoint"
block|,
literal|"longjmp"
block|,
literal|"longjmp resume"
block|,
literal|"step resume"
block|,
literal|"sigtramp"
block|,
literal|"watchpoint scope"
block|,
literal|"call dummy"
block|,
literal|"shlib events"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bpdisps
index|[]
init|=
block|{
literal|"del"
block|,
literal|"dis"
block|,
literal|"keep"
block|}
decl_stmt|;
specifier|static
name|char
name|bpenables
index|[]
init|=
literal|"ny"
decl_stmt|;
name|char
name|wrap_indent
index|[
literal|80
index|]
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
operator|||
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
comment|/*  We only print out user settable breakpoints unless the allflag is set. */
if|if
condition|(
operator|!
name|allflag
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
condition|)
continue|continue;
if|if
condition|(
operator|!
name|found_a_breakpoint
operator|++
condition|)
block|{
name|annotate_breakpoints_headers
argument_list|()
expr_stmt|;
name|annotate_field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Num "
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Type           "
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Disp "
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Enb "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Address    "
argument_list|)
expr_stmt|;
block|}
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"What\n"
argument_list|)
expr_stmt|;
name|annotate_breakpoints_table
argument_list|()
expr_stmt|;
block|}
name|annotate_record
argument_list|()
expr_stmt|;
name|annotate_field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-14s "
argument_list|,
name|bptypes
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-4s "
argument_list|,
name|bpdisps
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|disposition
index|]
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3c "
argument_list|,
name|bpenables
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|enable
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|wrap_indent
argument_list|,
literal|"                           "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"           "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	       not line up too nicely with the headers, but the effect 	       is relatively readable).  */
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_shlib_event
case|:
if|if
condition|(
name|addressprint
condition|)
block|{
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* FIXME-32x64: need a print_address_numeric with                    field width */
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|b
operator|->
name|address
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|last_addr
operator|=
name|b
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|source_file
condition|)
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"in "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
name|wrap_indent
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" at "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|b
operator|->
name|source_file
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":%d"
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|print_address_symbolic
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|gdb_stdout
argument_list|,
name|demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|frame
condition|)
block|{
name|annotate_field
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tstop only in stack frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|b
operator|->
name|frame
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|annotate_field
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tstop only if "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|cond
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_breakpoint_hit_counts
operator|&&
name|b
operator|->
name|hit_count
condition|)
block|{
comment|/* FIXME should make an annotation for this */
name|printf_filtered
argument_list|(
literal|"\tbreakpoint already hit %d time%s\n"
argument_list|,
name|b
operator|->
name|hit_count
argument_list|,
operator|(
name|b
operator|->
name|hit_count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|ignore_count
condition|)
block|{
name|annotate_field
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tignore next %d hits\n"
argument_list|,
name|b
operator|->
name|ignore_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l
operator|=
name|b
operator|->
name|commands
operator|)
condition|)
block|{
name|annotate_field
argument_list|(
literal|9
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|print_command_line
argument_list|(
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_a_breakpoint
condition|)
block|{
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"No breakpoints or watchpoints.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"No breakpoint or watchpoint number %d.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Compare against (CORE_ADDR)-1 in case some compiler decides        that a comparison of an unsigned with -1 is always false.  */
if|if
condition|(
name|last_addr
operator|!=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|set_next_address
argument_list|(
name|last_addr
argument_list|)
expr_stmt|;
name|annotate_breakpoints_table_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|breakpoints_info
parameter_list|(
name|bnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|maintenance_info_breakpoints
parameter_list|(
name|bnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print a message describing any breakpoints set at PC.  */
end_comment

begin_function
specifier|static
name|void
name|describe_other_breakpoints
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|int
name|others
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
name|others
operator|++
expr_stmt|;
if|if
condition|(
name|others
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Note: breakpoint%s "
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
block|{
name|others
operator|--
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d%s%s "
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
operator|(
name|b
operator|->
name|enable
operator|==
name|disabled
operator|||
name|b
operator|->
name|enable
operator|==
name|shlib_disabled
operator|)
condition|?
literal|" (disabled)"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|","
else|:
operator|(
operator|(
name|others
operator|==
literal|1
operator|)
condition|?
literal|" and"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"also set at pc "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the default place to put a breakpoint    for the `break' command with no arguments.  */
end_comment

begin_function
name|void
name|set_default_breakpoint
parameter_list|(
name|valid
parameter_list|,
name|addr
parameter_list|,
name|symtab
parameter_list|,
name|line
parameter_list|)
name|int
name|valid
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|default_breakpoint_valid
operator|=
name|valid
expr_stmt|;
name|default_breakpoint_address
operator|=
name|addr
expr_stmt|;
name|default_breakpoint_symtab
operator|=
name|symtab
expr_stmt|;
name|default_breakpoint_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rescan breakpoints at address ADDRESS,    marking the first one as "first" and any others as "duplicates".    This is so that the bpt instruction is only inserted once.  */
end_comment

begin_function
specifier|static
name|void
name|check_duplicates
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|address
operator|==
literal|0
condition|)
comment|/* Watchpoints are uninteresting */
return|return;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|address
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|b
operator|->
name|duplicate
operator|=
name|count
operator|>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Low level routine to set a breakpoint.    Takes as args the three things that every breakpoint must have.    Returns the breakpoint object so caller can set other things.    Does not set the breakpoint number!    Does not print anything.     ==> This routine should not be called if there is a chance of later    error(); otherwise it leaves a bogus breakpoint on the chain.  Validate    your arguments BEFORE calling this routine!  */
end_comment

begin_function
specifier|static
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|breakpoint
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|b
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|b
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|b
operator|->
name|input_radix
operator|=
name|input_radix
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
comment|/* Add this breakpoint to the end of the chain      so that a list of breakpoints will come out in order      of increasing numbers.  */
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
name|breakpoint_chain
operator|=
name|b
expr_stmt|;
else|else
block|{
while|while
condition|(
name|b1
operator|->
name|next
condition|)
name|b1
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|b
expr_stmt|;
block|}
name|check_duplicates
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|internal_breakpoint_number
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_function
specifier|static
name|void
name|create_longjmp_breakpoint
parameter_list|(
name|func_name
parameter_list|)
name|char
modifier|*
name|func_name
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|func_name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|func_name
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|sal
operator|.
name|pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
else|else
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return;
name|b
operator|->
name|type
operator|=
name|func_name
operator|!=
name|NULL
condition|?
name|bp_longjmp
else|:
name|bp_longjmp_resume
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|func_name
condition|)
name|b
operator|->
name|addr_string
operator|=
name|strsave
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|internal_breakpoint_number
operator|--
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef GET_LONGJMP_TARGET */
end_comment

begin_comment
comment|/* Call this routine when stepping and nexting to enable a breakpoint if we do    a longjmp().  When we hit that breakpoint, call    set_longjmp_resume_breakpoint() to figure out where we are going. */
end_comment

begin_function
name|void
name|enable_longjmp_breakpoint
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|disable_longjmp_breakpoint
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
operator|||
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function
name|void
name|remove_solib_event_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_shlib_event
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_solib_event_breakpoint
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|.
name|pc
operator|=
name|address
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|internal_breakpoint_number
operator|--
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_shlib_event
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to reenable any breakpoints in shared libraries.  */
end_comment

begin_function
name|void
name|re_enable_breakpoints_in_shlibs
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|shlib_disabled
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* Do not reenable the breakpoint if the shared library 	   is still not mapped in.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|hw_breakpoint_used_count
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|hw_watchpoint_used_count
parameter_list|(
name|type
parameter_list|,
name|other_type_used
parameter_list|)
name|enum
name|bptype
name|type
decl_stmt|;
name|int
modifier|*
name|other_type_used
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|other_type_used
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|type
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|&&
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
operator|*
name|other_type_used
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Call this after hitting the longjmp() breakpoint.  Use this to set a new    breakpoint at the target of the jmp_buf.     FIXME - This ought to be done by setting a temporary breakpoint that gets    deleted automatically... */
end_comment

begin_function
name|void
name|set_longjmp_resume_breakpoint
parameter_list|(
name|pc
parameter_list|,
name|frame
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|address
operator|=
name|pc
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
name|frame
operator|!=
name|NULL
condition|)
name|b
operator|->
name|frame
operator|=
name|frame
operator|->
name|frame
expr_stmt|;
else|else
name|b
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Set a breakpoint that will evaporate an end of command    at address specified by SAL.    Restrict it to frame FRAME if FRAME is nonzero.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_momentary_breakpoint
parameter_list|(
name|sal
parameter_list|,
name|frame
parameter_list|,
name|type
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|enum
name|bptype
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|frame
operator|=
operator|(
name|frame
condition|?
name|frame
operator|->
name|frame
else|:
literal|0
operator|)
expr_stmt|;
comment|/* If we're debugging a multi-threaded program, then we      want momentary breakpoints to be active in only a       single thread of control.  */
if|if
condition|(
name|in_thread_list
argument_list|(
name|inferior_pid
argument_list|)
condition|)
name|b
operator|->
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void clear_momentary_breakpoints () {   register struct breakpoint *b, *temp;   ALL_BREAKPOINTS_SAFE (b, temp)     if (b->disposition == delete)       { 	delete_breakpoint (b); 	break;       } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Tell the user we have just set a breakpoint B.  */
end_comment

begin_function
specifier|static
name|void
name|mention
parameter_list|(
name|b
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|say_where
init|=
literal|0
decl_stmt|;
comment|/* FIXME: This is misplaced; mention() is called by things (like hitting a      watchpoint) other than breakpoint creation.  It should be possible to      clean this up and at the same time replace the random calls to      breakpoint_changed with this hook, as has already been done for      delete_breakpoint_hook and so on.  */
if|if
condition|(
name|create_breakpoint_hook
condition|)
name|create_breakpoint_hook
argument_list|(
name|b
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_hardware_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_read_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware read watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_access_watchpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware access(read/write) watchpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
name|printf_filtered
argument_list|(
literal|"Breakpoint %d"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|say_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|bp_hardware_breakpoint
case|:
name|printf_filtered
argument_list|(
literal|"Hardware assisted breakpoint %d"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|say_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_shlib_event
case|:
break|break;
block|}
if|if
condition|(
name|say_where
condition|)
block|{
if|if
condition|(
name|addressprint
operator|||
name|b
operator|->
name|source_file
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|b
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|source_file
condition|)
name|printf_filtered
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|source_file
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Nobody calls this currently. */
end_comment

begin_comment
comment|/* Set a breakpoint from a symtab and line.    If TEMPFLAG is nonzero, it is a temporary breakpoint.    ADDR_STRING is a malloc'd string holding the name of where we are    setting the breakpoint.  This is used later to re-set it after the    program is relinked and symbols are reloaded.    Print the same confirmation messages that the breakpoint command prints.  */
end_comment

begin_comment
unit|void set_breakpoint (s, line, tempflag, addr_string)      struct symtab *s;      int line;      int tempflag;      char *addr_string; {   register struct breakpoint *b;   struct symtab_and_line sal;      sal.symtab = s;   sal.line = line;   sal.pc = 0;   resolve_sal_pc (&sal);
comment|/* Might error out */
end_comment

begin_endif
unit|describe_other_breakpoints (sal.pc);    b = set_raw_breakpoint (sal);   set_breakpoint_count (breakpoint_count + 1);   b->number = breakpoint_count;   b->type = bp_breakpoint;   b->cond = 0;   b->addr_string = addr_string;   b->enable = enabled;   b->disposition = tempflag ? delete : donttouch;    mention (b); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set a breakpoint according to ARG (function, linenum or *address)    flag: first bit  : 0 non-temporary, 1 temporary. 	 second bit : 0 normal breakpoint, 1 hardware breakpoint. */
end_comment

begin_function
specifier|static
name|void
name|break_command_1
parameter_list|(
name|arg
parameter_list|,
name|flag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
name|int
name|tempflag
decl_stmt|,
name|hardwareflag
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
comment|/* Pointers in arg to the start, and one past the end, of the condition.  */
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
init|=
name|NULL
decl_stmt|;
comment|/* Pointers in arg to the start, and one past the end,      of the address part.  */
name|char
modifier|*
name|addr_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|addr_end
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|canonical_strings_chain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|hardwareflag
operator|=
name|flag
operator|&
name|BP_HARDWAREFLAG
expr_stmt|;
name|tempflag
operator|=
name|flag
operator|&
name|BP_TEMPFLAG
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|sal
operator|.
name|pc
operator|=
name|sal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* If no arg given, or if first arg is 'if ', use the default breakpoint. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_start
operator|=
name|arg
expr_stmt|;
comment|/* Force almost all breakpoints to be in terms of the 	 current_source_symtab (which is decode_line_1's default).  This 	 should produce the results we want almost all of the time while 	 leaving default_breakpoint_* alone.  */
if|if
condition|(
name|default_breakpoint_valid
operator|&&
operator|(
operator|!
name|current_source_symtab
operator|||
operator|(
name|arg
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|'+'
operator|||
operator|*
name|arg
operator|==
literal|'-'
operator|)
operator|)
operator|)
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/* Make sure that all storage allocated in decode_line_1 gets freed in case      the following `for' loop errors out.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
name|canonical_strings_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|canonical
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No specific thread yet */
comment|/* Resolve all line numbers to PC's, and verify that conditions      can be parsed, before setting any breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|end_tok
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tok
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|tok
operator|&&
operator|*
name|tok
condition|)
block|{
while|while
condition|(
operator|*
name|tok
operator|==
literal|' '
operator|||
operator|*
name|tok
operator|==
literal|'\t'
condition|)
name|tok
operator|++
expr_stmt|;
name|end_tok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|*
name|end_tok
operator|!=
literal|' '
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\t'
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\000'
condition|)
name|end_tok
operator|++
expr_stmt|;
name|toklen
operator|=
name|end_tok
operator|-
name|tok
expr_stmt|;
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"if"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|cond_start
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|tok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"thread"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tmptok
decl_stmt|;
name|tok
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|tmptok
operator|=
name|tok
expr_stmt|;
name|thread
operator|=
name|strtol
argument_list|(
name|tok
argument_list|,
operator|&
name|tok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|tmptok
condition|)
name|error
argument_list|(
literal|"Junk after thread keyword."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_thread_id
argument_list|(
name|thread
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unknown thread %d\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hardwareflag
condition|)
block|{
name|int
name|i
decl_stmt|,
name|target_resources_ok
decl_stmt|;
name|i
operator|=
name|hw_breakpoint_used_count
argument_list|()
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
name|sals
operator|.
name|nelts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the canonical strings from the cleanup, they are needed below.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|canonical_strings_chain
argument_list|)
expr_stmt|;
comment|/* Now set all the breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|hardwareflag
condition|?
name|bp_hardware_breakpoint
else|:
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
comment|/* If a canonical line spec is needed use that instead of the 	 command string.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|&&
name|canonical
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|b
operator|->
name|addr_string
operator|=
name|canonical
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_start
condition|)
name|b
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_start
condition|)
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for break_command_1 and disassemble_command.  */
end_comment

begin_function
name|void
name|resolve_sal_pc
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|sal
operator|->
name|pc
operator|==
literal|0
operator|&&
name|sal
operator|->
name|symtab
operator|!=
literal|0
condition|)
block|{
name|pc
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|->
name|symtab
argument_list|,
name|sal
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|->
name|line
argument_list|,
name|sal
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sal
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
name|BP_TEMPFLAG
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
name|BP_HARDWAREFLAG
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
operator|(
name|BP_TEMPFLAG
operator||
name|BP_HARDWAREFLAG
operator|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_comment
comment|/* accessflag:  0: watch write, 1: watch read, 2: watch access(read or write) */
end_comment

begin_function
specifier|static
name|void
name|watch_command_1
parameter_list|(
name|arg
parameter_list|,
name|accessflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|accessflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|struct
name|block
modifier|*
name|exp_valid_block
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|,
modifier|*
name|prev_frame
decl_stmt|;
name|char
modifier|*
name|exp_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|exp_end
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|end_tok
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
init|=
name|NULL
decl_stmt|;
name|struct
name|expression
modifier|*
name|cond
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|other_type_used
decl_stmt|,
name|target_resources_ok
decl_stmt|;
name|enum
name|bptype
name|bp_type
decl_stmt|;
name|int
name|mem_cnt
init|=
literal|0
decl_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Parse arguments.  */
name|innermost_block
operator|=
name|NULL
expr_stmt|;
name|exp_start
operator|=
name|arg
expr_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp_end
operator|=
name|arg
expr_stmt|;
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|tok
operator|=
name|arg
expr_stmt|;
while|while
condition|(
operator|*
name|tok
operator|==
literal|' '
operator|||
operator|*
name|tok
operator|==
literal|'\t'
condition|)
name|tok
operator|++
expr_stmt|;
name|end_tok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|*
name|end_tok
operator|!=
literal|' '
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\t'
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\000'
condition|)
name|end_tok
operator|++
expr_stmt|;
name|toklen
operator|=
name|end_tok
operator|-
name|tok
expr_stmt|;
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"if"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|cond_start
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|tok
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tok
condition|)
name|error
argument_list|(
literal|"Junk at end of command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|accessflag
operator|==
literal|1
condition|)
name|bp_type
operator|=
name|bp_read_watchpoint
expr_stmt|;
elseif|else
if|if
condition|(
name|accessflag
operator|==
literal|2
condition|)
name|bp_type
operator|=
name|bp_access_watchpoint
expr_stmt|;
else|else
name|bp_type
operator|=
name|bp_hardware_watchpoint
expr_stmt|;
name|mem_cnt
operator|=
name|can_use_hardware_watchpoint
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|==
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Expression cannot be implemented with read/access watchpoint."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|hw_watchpoint_used_count
argument_list|(
name|bp_type
argument_list|,
operator|&
name|other_type_used
argument_list|)
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Target does not have this type of hardware watchpoint support."
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Target resources have been allocated for other types of watchpoints."
argument_list|)
expr_stmt|;
block|}
comment|/* Now set up the breakpoint.  */
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|donttouch
expr_stmt|;
name|b
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|exp_valid_block
expr_stmt|;
name|b
operator|->
name|exp_string
operator|=
name|savestring
argument_list|(
name|exp_start
argument_list|,
name|exp_end
operator|-
name|exp_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|cond_start
condition|)
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|cond_string
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
name|block_innermost_frame
argument_list|(
name|exp_valid_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
block|{
name|prev_frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|b
operator|->
name|watchpoint_frame
operator|=
name|frame
operator|->
name|frame
expr_stmt|;
block|}
else|else
name|b
operator|->
name|watchpoint_frame
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|&&
name|target_resources_ok
operator|>
literal|0
condition|)
name|b
operator|->
name|type
operator|=
name|bp_type
expr_stmt|;
else|else
name|b
operator|->
name|type
operator|=
name|bp_watchpoint
expr_stmt|;
comment|/* If the expression is "local", then set up a "watchpoint scope"      breakpoint at the point where we've left the scope of the watchpoint      expression.  */
if|if
condition|(
name|innermost_block
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|scope_breakpoint
decl_stmt|;
name|struct
name|symtab_and_line
name|scope_sal
decl_stmt|;
if|if
condition|(
name|prev_frame
condition|)
block|{
name|scope_sal
operator|.
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
name|scope_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|scope_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|scope_breakpoint
operator|=
name|set_raw_breakpoint
argument_list|(
name|scope_sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scope_breakpoint
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|scope_breakpoint
operator|->
name|type
operator|=
name|bp_watchpoint_scope
expr_stmt|;
name|scope_breakpoint
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
comment|/* Automatically delete the breakpoint when it hits.  */
name|scope_breakpoint
operator|->
name|disposition
operator|=
name|del
expr_stmt|;
comment|/* Only break in the proper frame (help with recursion).  */
name|scope_breakpoint
operator|->
name|frame
operator|=
name|prev_frame
operator|->
name|frame
expr_stmt|;
comment|/* Set the address at which we will stop.  */
name|scope_breakpoint
operator|->
name|address
operator|=
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
comment|/* The scope breakpoint is related to the watchpoint.  We 	     will need to act on them together.  */
name|b
operator|->
name|related_breakpoint
operator|=
name|scope_breakpoint
expr_stmt|;
block|}
block|}
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return count of locations need to be watched and can be handled    in hardware.  If the watchpoint can not be handled    in hardware return zero.  */
end_comment

begin_function
specifier|static
name|int
name|can_use_hardware_watchpoint
parameter_list|(
name|v
parameter_list|)
name|struct
name|value
modifier|*
name|v
decl_stmt|;
block|{
name|int
name|found_memory_cnt
init|=
literal|0
decl_stmt|;
comment|/* Make sure all the intermediate values are in memory.  Also make sure      we found at least one memory expression.  Guards against watch 0x12345,      which is meaningless, but could cause errors if one tries to insert a       hardware watchpoint for the constant expression.  */
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_memory
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|<=
name|REGISTER_SIZE
condition|)
name|found_memory_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|lval
operator|!=
name|not_lval
operator|&&
name|v
operator|->
name|modifiable
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* The expression itself looks suitable for using a hardware      watchpoint, but give the target machine a chance to reject it.  */
return|return
name|found_memory_cnt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|watch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rwatch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awatch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routine for the until_command routine in infcmd.c.  Here    because it uses the mechanisms of breakpoints.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|until_break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev_frame
init|=
name|get_prev_frame
argument_list|(
name|selected_frame
argument_list|)
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Set a breakpoint where the user wants it and at return from      this function */
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Couldn't get information on specified line."
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* malloc'd, so freed */
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|selected_frame
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|delete_breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
comment|/* Keep within the current frame */
if|if
condition|(
name|prev_frame
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prev_frame
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|prev_frame
operator|->
name|pc
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|prev_frame
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|delete_breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
block|}
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These aren't used; I don't konw what they were for.  */
end_comment

begin_comment
comment|/* Set a breakpoint at the catch clause for NAME.  */
end_comment

begin_endif
unit|static int catch_breakpoint (name)      char *name; { }  static int disable_catch_breakpoint () { }  static int delete_catch_breakpoint () { }  static int enable_catch_breakpoint () { }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_struct
struct|struct
name|sal_chain
block|{
name|struct
name|sal_chain
modifier|*
name|next
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This isn't used; I don't know what it was for.  */
end_comment

begin_comment
comment|/* For each catch clause identified in ARGS, run FUNCTION    with that clause as an argument.  */
end_comment

begin_if
unit|static struct symtabs_and_lines map_catch_names (args, function)      char *args;      int (*function)(); {   register char *p = args;   register char *p1;   struct symtabs_and_lines sals;
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct sal_chain *sal_chain = 0;
endif|#
directive|endif
end_endif

begin_comment
unit|if (p == 0)     error_no_arg ("one or more catch names");    sals.nelts = 0;   sals.sals = NULL;    while (*p)     {       p1 = p;
comment|/* Don't swallow conditional part.  */
end_comment

begin_if
unit|if (p1[0] == 'i'&& p1[1] == 'f'&& (p1[2] == ' ' || p1[2] == '\t')) 	break;        if (isalpha (*p1)) 	{ 	  p1++; 	  while (isalnum (*p1) || *p1 == '_' || *p1 == '$') 	    p1++; 	}        if (*p1&& *p1 != ' '&& *p1 != '\t') 	error ("Arguments must be catch names.");        *p1 = 0;
if|#
directive|if
literal|0
end_if

begin_endif
unit|if (function (p)) 	{ 	  struct sal_chain *next 	    = (struct sal_chain *)alloca (sizeof (struct sal_chain)); 	  next->next = sal_chain; 	  next->sal = get_catch_sal (p); 	  sal_chain = next; 	  goto win; 	}
endif|#
directive|endif
end_endif

begin_if
unit|printf_unfiltered ("No catch clause for exception %s.\n", p);
if|#
directive|if
literal|0
end_if

begin_endif
unit|win:
endif|#
directive|endif
end_endif

begin_endif
unit|p = p1;       while (*p == ' ' || *p == '\t') p++;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* This shares a lot of code with `print_frame_label_vars' from stack.c.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|get_catch_sals
parameter_list|(
name|this_level_only
parameter_list|)
name|int
name|this_level_only
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|index
decl_stmt|,
name|have_default
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|sal_chain
modifier|*
name|sal_chain
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|blocks_searched
decl_stmt|;
comment|/* Not sure whether an error message is always the correct response,      but it's better than a core dump.  */
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|block
operator|=
name|get_frame_block
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|pc
operator|=
name|selected_frame
operator|->
name|pc
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|blocks_searched
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocks_searched
argument_list|,
literal|0
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
decl_stmt|;
name|int
name|last_index
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
name|blockvector_for_pc
argument_list|(
name|end
argument_list|,
operator|&
name|index
argument_list|)
condition|)
name|error
argument_list|(
literal|"blockvector blotch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
operator|!=
name|block
condition|)
name|error
argument_list|(
literal|"blockvector botch"
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
comment|/* Don't print out blocks that have gone by.  */
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|pc
condition|)
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|blocks_searched
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_default
condition|)
continue|continue;
name|have_default
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
condition|)
block|{
name|struct
name|sal_chain
modifier|*
name|next
init|=
operator|(
expr|struct
name|sal_chain
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sal_chain
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|next
operator|=
name|sal_chain
expr_stmt|;
name|next
operator|->
name|sal
operator|=
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal_chain
operator|=
name|next
expr_stmt|;
block|}
block|}
name|blocks_searched
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_default
condition|)
break|break;
if|if
condition|(
name|sal_chain
operator|&&
name|this_level_only
condition|)
break|break;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sal_chain
condition|)
block|{
name|struct
name|sal_chain
modifier|*
name|tmp_chain
decl_stmt|;
comment|/* Count the number of entries.  */
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|tmp_chain
operator|=
name|sal_chain
init|;
name|tmp_chain
condition|;
name|tmp_chain
operator|=
name|tmp_chain
operator|->
name|next
control|)
name|index
operator|++
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
name|index
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|sal_chain
condition|;
name|sal_chain
operator|=
name|sal_chain
operator|->
name|next
operator|,
name|index
operator|++
control|)
name|sals
operator|.
name|sals
index|[
name|index
index|]
operator|=
name|sal_chain
operator|->
name|sal
expr_stmt|;
block|}
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Commands to deal with catching exceptions.  */
end_comment

begin_function
specifier|static
name|void
name|catch_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* First, translate ARG into something we can deal with in terms      of breakpoints.  */
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|save_arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sal
operator|.
name|line
operator|=
name|sal
operator|.
name|pc
operator|=
name|sal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* If no arg given, or if first arg is 'if ', all active catch clauses      are breakpointed. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
comment|/* Grab all active catch clauses.  */
name|sals
operator|=
name|get_catch_sals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Grab selected catch clauses.  */
name|error
argument_list|(
literal|"catch NAME not implemented"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't used; I don't know what it was for.  */
block|sals = map_catch_names (arg, catch_breakpoint);
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
name|save_arg
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|(
name|arg
operator|+=
literal|2
operator|,
operator|&
name|arg
operator|)
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|save_arg
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|del
else|:
name|donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used by the gui, could be made a worker for other things. */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_breakpoint_sal
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bp_breakpoint
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These aren't used; I don't know what they were for.  */
end_comment

begin_comment
comment|/* Disable breakpoints on all catch clauses described in ARGS.  */
end_comment

begin_comment
unit|static void disable_catch (args)      char *args; {
comment|/* Map the disable command to catch clauses described in ARGS.  */
end_comment

begin_comment
unit|}
comment|/* Enable breakpoints on all catch clauses described in ARGS.  */
end_comment

begin_comment
unit|static void enable_catch (args)      char *args; {
comment|/* Map the disable command to catch clauses described in ARGS.  */
end_comment

begin_comment
unit|}
comment|/* Delete breakpoints on all catch clauses in the active scope.  */
end_comment

begin_comment
unit|static void delete_catch (args)      char *args; {
comment|/* Map the delete command to catch clauses described in ARGS.  */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|catch_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|catch_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|clear_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* If exact pc given, clear bpts at that pc. 	 But if sal.pc is zero, clear all bpts on specified line.  */
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|breakpoint_chain
operator|&&
operator|(
name|sal
operator|.
name|pc
condition|?
name|breakpoint_chain
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
else|:
operator|(
name|breakpoint_chain
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|breakpoint_chain
operator|->
name|source_file
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|&&
name|breakpoint_chain
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
name|breakpoint_chain
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
while|while
condition|(
name|b
operator|->
name|next
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|next
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
operator|(
name|sal
operator|.
name|pc
condition|?
name|b
operator|->
name|next
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
else|:
operator|(
name|b
operator|->
name|next
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|b
operator|->
name|next
operator|->
name|source_file
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|&&
name|b
operator|->
name|next
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|b
operator|->
name|next
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"No breakpoint at %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No breakpoint at this line."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|->
name|next
condition|)
name|from_tty
operator|=
literal|1
expr_stmt|;
comment|/* Always report if deleted more than one */
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Deleted breakpoint%s "
argument_list|,
name|found
operator|->
name|next
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
while|while
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"%d "
argument_list|,
name|found
operator|->
name|number
argument_list|)
expr_stmt|;
name|b1
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete breakpoint in BS if they are `delete' breakpoints.    This is called after any breakpoint is hit, or after errors.  */
end_comment

begin_function
name|void
name|breakpoint_auto_delete
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
for|for
control|(
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|disposition
operator|==
name|del
operator|&&
name|bs
operator|->
name|stop
condition|)
name|delete_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a breakpoint and clean up all traces of it in the data structures. */
end_comment

begin_function
name|void
name|delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|bpstat
name|bs
decl_stmt|;
if|if
condition|(
name|delete_breakpoint_hook
condition|)
name|delete_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|inserted
condition|)
name|remove_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_chain
operator|==
name|bpt
condition|)
name|breakpoint_chain
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|next
operator|==
name|bpt
condition|)
block|{
name|b
operator|->
name|next
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* If this breakpoint was inserted, and there is another breakpoint      at the same address, we need to insert the other breakpoint.  */
if|if
condition|(
name|bpt
operator|->
name|inserted
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_access_watchpoint
condition|)
block|{
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|bpt
operator|->
name|address
operator|&&
operator|!
name|b
operator|->
name|duplicate
operator|&&
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|enable
operator|!=
name|shlib_disabled
condition|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot insert breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|memory_error
argument_list|(
name|val
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* which bombs us out */
block|}
else|else
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
operator|&
name|bpt
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|addr_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exp_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|exp_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|source_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|source_file
argument_list|)
expr_stmt|;
comment|/* Be sure no bpstat's are pointing at it after it's been freed.  */
comment|/* FIXME, how can we find all bpstat's?      We just check stop_bpstat for now.  */
for|for
control|(
name|bs
operator|=
name|stop_bpstat
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|bpt
condition|)
name|bs
operator|->
name|breakpoint_at
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
comment|/* Ask user only if there are some breakpoints to delete.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
operator|(
name|breakpoint_chain
operator|&&
name|query
argument_list|(
literal|"Delete all breakpoints? "
argument_list|)
operator|)
condition|)
block|{
comment|/* No arg; clear all breakpoints.  */
while|while
condition|(
name|breakpoint_chain
condition|)
name|delete_breakpoint
argument_list|(
name|breakpoint_chain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|arg
argument_list|,
name|delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset a breakpoint given it's struct breakpoint * BINT.    The value we return ends up being the return value from catch_errors.    Unused in this case.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_re_set_one
parameter_list|(
name|bint
parameter_list|)
name|char
modifier|*
name|bint
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|b
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|bint
decl_stmt|;
comment|/* get past catch_errs */
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|enable
name|save_enable
decl_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
if|if
condition|(
name|b
operator|->
name|addr_string
operator|==
name|NULL
condition|)
block|{
comment|/* Anything without a string can't be re-set. */
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* In case we have a problem, disable this breakpoint.  We'll restore 	 its status if we succeed.  */
name|save_enable
operator|=
name|b
operator|->
name|enable
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|set_language
argument_list|(
name|b
operator|->
name|language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|b
operator|->
name|input_radix
expr_stmt|;
name|s
operator|=
name|b
operator|->
name|addr_string
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Reparse conditions, they might contain references to the 	     old symtab.  */
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We need to re-set the breakpoint if the address changes...*/
if|if
condition|(
name|b
operator|->
name|address
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
comment|/* ...or new and old breakpoints both have source files, and 		 the source file name or the line number changes...  */
operator|||
operator|(
name|b
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|STREQ
argument_list|(
name|b
operator|->
name|source_file
argument_list|,
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|||
name|b
operator|->
name|line_number
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
operator|)
operator|)
comment|/* ...or we switch between having a source file and not having 		 one.  */
operator|||
operator|(
operator|(
name|b
operator|->
name|source_file
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|source_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|b
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|b
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|b
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Might be better to do this just once per breakpoint_re_set, 		 rather than once for every breakpoint.  */
name|breakpoints_changed
argument_list|()
expr_stmt|;
block|}
name|b
operator|->
name|enable
operator|=
name|save_enable
expr_stmt|;
comment|/* Restore it, this worked. */
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|innermost_block
operator|=
name|NULL
expr_stmt|;
comment|/* The issue arises of what context to evaluate this in.  The same 	 one as when it was set, but what does that mean when symbols have 	 been re-read?  We could save the filename and functionname, but 	 if the context is more local than that, the best we could do would 	 be something like how many levels deep and which index at that 	 particular level, but that's going to be less stable than filenames 	 or functionnames.  */
comment|/* So for now, just use a global context.  */
name|b
operator|->
name|exp
operator|=
name|parse_expression
argument_list|(
name|b
operator|->
name|exp_string
argument_list|)
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|b
operator|->
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|enabled
condition|)
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Deleting unknown breakpoint type %d\n"
argument_list|,
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* fall through */
comment|/* Delete longjmp breakpoints, they will be reset later by        breakpoint_re_set.  */
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
comment|/* This breakpoint is special, it's set up when the inferior        starts and we really don't want to touch it.  */
case|case
name|bp_shlib_event
case|:
comment|/* Keep temporary breakpoints, which can be encountered when we step        over a dlopen call and SOLIB_ADD is resetting the breakpoints.        Otherwise these should have been blown away via the cleanup chain        or by breakpoint_init_inferior when we rerun the executable.  */
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_step_resume
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Re-set all breakpoints after symbols have been re-loaded.  */
end_comment

begin_function
name|void
name|breakpoint_re_set
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|enum
name|language
name|save_language
decl_stmt|;
name|int
name|save_input_radix
decl_stmt|;
specifier|static
name|char
name|message1
index|[]
init|=
literal|"Error in re-setting breakpoint %d:\n"
decl_stmt|;
name|char
name|message
index|[
sizeof|sizeof
argument_list|(
name|message1
argument_list|)
operator|+
literal|30
comment|/* slop */
index|]
decl_stmt|;
name|save_language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|save_input_radix
operator|=
name|input_radix
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
name|message1
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Format possible error msg */
name|catch_errors
argument_list|(
name|breakpoint_re_set_one
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
name|set_language
argument_list|(
name|save_language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|save_input_radix
expr_stmt|;
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
name|create_longjmp_breakpoint
argument_list|(
literal|"longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"_longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"siglongjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Took this out (temporarily at least), since it produces an extra       blank line at startup. This messes up the gdbtests. -PB */
comment|/* Blank line to finish off all those mention() messages we just printed.  */
block|printf_filtered ("\n");
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set ignore-count of breakpoint number BPTNUM to COUNT.    If from_tty is nonzero, it prints a message to that effect,    which ends with a period (no newline).  */
end_comment

begin_function
name|void
name|set_ignore_count
parameter_list|(
name|bptnum
parameter_list|,
name|count
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|bptnum
decl_stmt|,
name|count
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bptnum
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|from_tty
condition|)
return|return;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Will stop next time breakpoint %d is reached."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"Will ignore next crossing of breakpoint %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Will ignore next %d crossings of breakpoint %d."
argument_list|,
name|count
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the ignore counts of all breakpoints.  */
end_comment

begin_function
name|void
name|breakpoint_clear_ignore_counts
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command to set ignore-count of breakpoint N to COUNT.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"a breakpoint number"
argument_list|)
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Second argument (specified ignore-count) is missing."
argument_list|)
expr_stmt|;
name|set_ignore_count
argument_list|(
name|num
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|parse_and_eval
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUNCTION on each of the breakpoints    whose numbers are given in ARGS.  */
end_comment

begin_function_decl
specifier|static
name|void
name|map_breakpoint_numbers
parameter_list|(
name|args
parameter_list|,
name|function
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more breakpoint numbers"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p1
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|related_breakpoint
init|=
name|b
operator|->
name|related_breakpoint
decl_stmt|;
name|function
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|related_breakpoint
condition|)
name|function
argument_list|(
name|related_breakpoint
argument_list|)
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf_unfiltered
argument_list|(
literal|"No breakpoint number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|enable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|save_selected_frame
init|=
name|NULL
decl_stmt|;
name|int
name|save_selected_frame_level
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|target_resources_ok
decl_stmt|,
name|other_type_used
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|hw_breakpoint_used_count
argument_list|()
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
if|if
condition|(
name|bpt
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fr
init|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|bpt
operator|->
name|watchpoint_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because the block in which its expression\n\ is valid is not currently in scope.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
return|return;
block|}
name|save_selected_frame
operator|=
name|selected_frame
expr_stmt|;
name|save_selected_frame_level
operator|=
name|selected_frame_level
expr_stmt|;
name|select_frame
argument_list|(
name|fr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|bpt
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|int
name|i
init|=
name|hw_watchpoint_used_count
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
operator|&
name|other_type_used
argument_list|)
decl_stmt|;
name|int
name|mem_cnt
init|=
name|can_use_hardware_watchpoint
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
decl_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
comment|/* we can consider of type is bp_hardware_watchpoint, convert to  	   bp_watchpoint in the following condition */
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because target watch resources\n\ have been allocated for other watchpoints.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|save_selected_frame_level
operator|>=
literal|0
condition|)
name|select_frame
argument_list|(
name|save_selected_frame
argument_list|,
name|save_selected_frame_level
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modify_breakpoint_hook
condition|)
name|modify_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|enable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
comment|/* Never disable a watchpoint scope breakpoint; we want to      hit them when we leave scope so we can delete both the      watchpoint and its scope breakpoint at that time.  */
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint_scope
condition|)
return|return;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|modify_breakpoint_hook
condition|)
name|modify_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|disable_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|disable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|disable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|save_selected_frame
init|=
name|NULL
decl_stmt|;
name|int
name|save_selected_frame_level
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|target_resources_ok
decl_stmt|,
name|other_type_used
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|hw_breakpoint_used_count
argument_list|()
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|disable
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
if|if
condition|(
name|bpt
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fr
init|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|bpt
operator|->
name|watchpoint_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because the block in which its expression\n\ is valid is not currently in scope.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
return|return;
block|}
name|save_selected_frame
operator|=
name|selected_frame
expr_stmt|;
name|save_selected_frame_level
operator|=
name|selected_frame_level
expr_stmt|;
name|select_frame
argument_list|(
name|fr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|bpt
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|int
name|i
init|=
name|hw_watchpoint_used_count
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
operator|&
name|other_type_used
argument_list|)
decl_stmt|;
name|int
name|mem_cnt
init|=
name|can_use_hardware_watchpoint
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
decl_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
comment|/* we can consider of type is bp_hardware_watchpoint, convert to  	   bp_watchpoint in the following condition */
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because target watch resources\n\ have been allocated for other watchpoints.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_selected_frame_level
operator|>=
literal|0
condition|)
name|select_frame
argument_list|(
name|save_selected_frame
argument_list|,
name|save_selected_frame_level
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_once_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_once_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|del
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|enable_delete_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use default_breakpoint_'s, or nothing if they aren't valid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec_1
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_breakpoint
parameter_list|()
block|{
name|breakpoint_chain
operator|=
literal|0
expr_stmt|;
comment|/* Don't bother to call set_breakpoint_count.  $bpnum isn't useful      before a breakpoint is set.  */
name|breakpoint_count
operator|=
literal|0
expr_stmt|;
name|add_com
argument_list|(
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
name|ignore_command
argument_list|,
literal|"Set ignore-count of breakpoint number N to COUNT.\n\ Usage is `ignore N COUNT'."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"commands"
argument_list|,
name|class_breakpoint
argument_list|,
name|commands_command
argument_list|,
literal|"Set commands to be executed when a breakpoint is hit.\n\ Give breakpoint number as argument after \"commands\".\n\ With no argument, the targeted breakpoint is the last one set.\n\ The commands themselves follow starting on the next line.\n\ Type a line containing \"end\" to indicate the end of them.\n\ Give \"silent\" as the first line to make the breakpoint silent;\n\ then no output is printed when it is hit, except what the commands print."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"condition"
argument_list|,
name|class_breakpoint
argument_list|,
name|condition_command
argument_list|,
literal|"Specify breakpoint number N to break only if COND is true.\n\ Usage is `condition N COND', where N is an integer and COND is an\n\ expression to be evaluated whenever breakpoint N is reached.  "
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|tbreak_command
argument_list|,
literal|"Set a temporary breakpoint.  Args like \"break\" command.\n\ Like \"break\" except the breakpoint is only temporary,\n\ so it will be deleted when hit.  Equivalent to \"break\" followed\n\ by using \"enable delete\" on the breakpoint number."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"hbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|hbreak_command
argument_list|,
literal|"Set a hardware assisted  breakpoint. Args like \"break\" command.\n\ Like \"break\" except the breakpoint requires hardware support,\n\ some target hardware may not have this support."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"thbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|thbreak_command
argument_list|,
literal|"Set a temporary hardware assisted breakpoint. Args like \"break\" command.\n\ Like \"hbreak\" except the breakpoint is only temporary,\n\ so it will be deleted when hit."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily."
argument_list|,
operator|&
name|enablelist
argument_list|,
literal|"enable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_abbrev_prefix_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ This is used to cancel the effect of the \"disable\" command.\n\ May be abbreviated to simply \"enable\".\n"
argument_list|,
operator|&
name|enablebreaklist
argument_list|,
literal|"enable breakpoints "
argument_list|,
literal|1
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled."
argument_list|,
operator|&
name|disablelist
argument_list|,
literal|"disable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dis"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"disa"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\ This command may be abbreviated \"disable\"."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ \n\ Also a prefix command for deletion of other GDB objects.\n\ The \"unset\" command is also an alias for \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|,
literal|"delete "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"d"
argument_list|,
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ This command may be abbreviated \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"clear"
argument_list|,
name|class_breakpoint
argument_list|,
name|clear_command
argument_list|,
name|concat
argument_list|(
literal|"Clear breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, all breakpoints in that line are cleared.\n\ If function is specified, breakpoints at beginning of function are cleared.\n\ If an address is specified, breakpoints at that address are cleared.\n\n"
argument_list|,
literal|"With no argument, clears all breakpoints in the line that the selected frame\n\ is executing in.\n\ \n\ See also the \"delete\" command which clears breakpoints by number."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_command
argument_list|,
name|concat
argument_list|(
literal|"Set breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, break at start of code for that line.\n\ If function is specified, break at start of code for that function.\n\ If an address is specified, break at that exact address.\n"
argument_list|,
literal|"With no arg, uses current execution address of selected stack frame.\n\ This is useful for breaking on return to a stack frame.\n\ \n\ Multiple breakpoints at one place are permitted, and useful if conditional.\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"b"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"br"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bre"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"brea"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"breakpoints"
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_breakpoints
argument_list|,
name|concat
argument_list|(
literal|"Status of all breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ \tlongjmp        - internal breakpoint used to step through longjmp()\n\ \tlongjmp resume - internal breakpoint at the target of longjmp()\n\ \tuntil          - internal breakpoint used by the \"until\" command\n\ \tfinish         - internal breakpoint used by the \"finish\" command\n"
argument_list|,
literal|"The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTENANCE_CMDS */
name|add_com
argument_list|(
literal|"catch"
argument_list|,
name|class_breakpoint
argument_list|,
name|catch_command
argument_list|,
literal|"Set breakpoints to catch exceptions that are raised.\n\ Argument may be a single exception to catch, multiple exceptions\n\ to catch, or the default exception \"default\".  If no arguments\n\ are given, breakpoints are set at all exception handlers catch clauses\n\ within the current scope.\n\ \n\ A condition specified for the catch applies to all breakpoints set\n\ with this command\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"watch"
argument_list|,
name|class_breakpoint
argument_list|,
name|watch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression changes."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rwatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|rwatch_command
argument_list|,
literal|"Set a read watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression is read."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"awatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|awatch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression is either read or written."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"watchpoints"
argument_list|,
name|breakpoints_info
argument_list|,
literal|"Synonym for ``info breakpoints''."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

