begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Everything about breakpoints, for GDB.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"gdb.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-script.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"gdb-events.h"
end_include

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|until_break_command_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catch_command_1
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_delete_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_delete_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_once_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_once_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disable_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|map_breakpoint_numbers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignore_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|breakpoint_re_set_one
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catch_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|watch_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_use_hardware_watchpoint
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|break_at_finish_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|break_at_finish_at_depth_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tbreak_at_finish_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|break_command_1
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|breakpoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mention
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
parameter_list|(
name|struct
name|symtab_and_line
parameter_list|,
name|enum
name|bptype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_duplicates
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|breakpoint_adjustment_warning
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|adjust_breakpoint_address
parameter_list|(
name|CORE_ADDR
name|bpaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|describe_other_breakpoints
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|breakpoints_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|breakpoint_1
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bpstat
name|bpstat_alloc
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|,
name|bpstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|breakpoint_cond_eval
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup_executing_breakpoints
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|commands_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|condition_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_number_trailer
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_captured_parse_breakpoint
parameter_list|(
name|struct
name|ui_out
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_breakpoint_count
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
enum|enum
block|{
name|mark_inserted
block|,
name|mark_uninserted
block|}
name|insertion_state_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|remove_breakpoint
parameter_list|(
name|struct
name|bp_location
modifier|*
parameter_list|,
name|insertion_state_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|print_stop_action
name|print_it_typical
parameter_list|(
name|bpstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|print_stop_action
name|print_bp_stop_message
parameter_list|(
name|bpstat
name|bs
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|enum
name|exception_event_kind
name|kind
decl_stmt|;
name|int
name|enable_p
decl_stmt|;
block|}
name|args_for_catchpoint_enable
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|watchpoint_check
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cover_target_enable_exception_callback
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_info_breakpoints
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_longjmp_breakpoint
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_overlay_event_breakpoint
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hw_breakpoint_used_count
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hw_watchpoint_used_count
parameter_list|(
name|enum
name|bptype
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hbreak_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thbreak_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|watch_command_1
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rwatch_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awatch_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_enable_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|,
name|enum
name|bpdisp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|solib_load_unload_1
parameter_list|(
name|char
modifier|*
name|hookname
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|dll_pathname
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|bptype
name|bp_kind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_fork_vfork_event_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|bptype
name|bp_kind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|break_at_finish_at_depth_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|break_at_finish_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stopin_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stopat_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ep_find_event_name_end
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ep_parse_optional_if_clause
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ep_parse_optional_filename
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_exception_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|exception_event_kind
name|ex_event
parameter_list|,
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catch_exception_command_1
parameter_list|(
name|enum
name|exception_event_kind
name|ex_event
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tcatch_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ep_skip_leading_whitespace
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_comment
comment|/* If FALSE, gdb will not use hardware support for watchpoints, even    if such is available. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|can_use_hw_watchpoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If AUTO_BOOLEAN_FALSE, gdb will not attempt to create pending breakpoints.    If AUTO_BOOLEAN_TRUE, gdb will automatically create pending breakpoints    for unrecognized breakpoint locations.      If AUTO_BOOLEAN_AUTO, gdb will query when breakpoints are unrecognized.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|auto_boolean
name|pending_break_support
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|_initialize_breakpoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print machine addresses? */
end_comment

begin_comment
comment|/* Are we executing breakpoint commands?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_breakpoint_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are overlay event breakpoints enabled? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|overlay_events_enabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Walk the following statement or block through all breakpoints.    ALL_BREAKPOINTS_SAFE does so even if the statment deletes the current    breakpoint.  */
end_comment

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS
parameter_list|(
name|B
parameter_list|)
value|for (B = breakpoint_chain; B; B = B->next)
end_define

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS_SAFE
parameter_list|(
name|B
parameter_list|,
name|TMP
parameter_list|)
define|\
value|for (B = breakpoint_chain;	\ 	     B ? (TMP=B->next, 1): 0;	\ 	     B = TMP)
end_define

begin_comment
comment|/* Similar iterators for the low-level breakpoints.  */
end_comment

begin_define
define|#
directive|define
name|ALL_BP_LOCATIONS
parameter_list|(
name|B
parameter_list|)
value|for (B = bp_location_chain; B; B = B->next)
end_define

begin_define
define|#
directive|define
name|ALL_BP_LOCATIONS_SAFE
parameter_list|(
name|B
parameter_list|,
name|TMP
parameter_list|)
define|\
value|for (B = bp_location_chain;	\ 	     B ? (TMP=B->next, 1): 0;	\ 	     B = TMP)
end_define

begin_comment
comment|/* True if breakpoint hit counts should be displayed in breakpoint info.  */
end_comment

begin_decl_stmt
name|int
name|show_breakpoint_hit_counts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chains of all breakpoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bp_location
modifier|*
name|bp_location_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last breakpoint made.  */
end_comment

begin_decl_stmt
name|int
name|breakpoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to current exception event record */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|exception_event_record
modifier|*
name|current_exception_event
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicator of whether exception catchpoints should be nuked    between runs of a program */
end_comment

begin_decl_stmt
name|int
name|exception_catchpoints_are_fragile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicator of when exception catchpoints set-up should be    reinitialized -- e.g. when program is re-run */
end_comment

begin_decl_stmt
name|int
name|exception_support_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function returns a pointer to the string representation of the    pathname of the dynamically-linked library that has just been    loaded.     This function must be used only when SOLIB_HAVE_LOAD_EVENT is TRUE,    or undefined results are guaranteed.     This string's contents are only valid immediately after the    inferior has stopped in the dynamic linker hook, and becomes    invalid as soon as the inferior is continued.  Clients should make    a copy of this string if they wish to continue the inferior and    then access the string.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_LOADED_LIBRARY_PATHNAME
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_LOADED_LIBRARY_PATHNAME
parameter_list|(
name|pid
parameter_list|)
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function returns a pointer to the string representation of the    pathname of the dynamically-linked library that has just been    unloaded.     This function must be used only when SOLIB_HAVE_UNLOAD_EVENT is    TRUE, or undefined results are guaranteed.     This string's contents are only valid immediately after the    inferior has stopped in the dynamic linker hook, and becomes    invalid as soon as the inferior is continued.  Clients should make    a copy of this string if they wish to continue the inferior and    then access the string.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
parameter_list|(
name|pid
parameter_list|)
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called by the "catch load" command.  It allows the    debugger to be notified by the dynamic linker when a specified    library file (or any library file, if filename is NULL) is loaded.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_CREATE_CATCH_LOAD_HOOK
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_CREATE_CATCH_LOAD_HOOK
parameter_list|(
name|pid
parameter_list|,
name|tempflag
parameter_list|,
name|filename
parameter_list|,
name|cond_string
parameter_list|)
define|\
value|error ("catch of library loads not yet implemented on this platform")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called by the "catch unload" command.  It allows    the debugger to be notified by the dynamic linker when a specified    library file (or any library file, if filename is NULL) is    unloaded.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_CREATE_CATCH_UNLOAD_HOOK
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_CREATE_CATCH_UNLOAD_HOOK
parameter_list|(
name|pid
parameter_list|,
name|tempflag
parameter_list|,
name|filename
parameter_list|,
name|cond_string
parameter_list|)
define|\
value|error ("catch of library unloads not yet implemented on this platform")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return whether a breakpoint is an active enabled breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_enabled
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|b
operator|->
name|enable_state
operator|==
name|bp_enabled
operator|&&
operator|!
name|b
operator|->
name|pending
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set breakpoint count to NUM.  */
end_comment

begin_function
name|void
name|set_breakpoint_count
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|breakpoint_count
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"bpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in run_command to zero the hit count when a new run starts. */
end_comment

begin_function
name|void
name|clear_breakpoint_hit_counts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|hit_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default address, symtab and line to put a breakpoint at    for "break" command with no arg.    if default_breakpoint_valid is zero, the other three are    not valid, and "break" with no arg is an error.     This set by print_stack_frame, which calls set_default_breakpoint.  */
end_comment

begin_decl_stmt
name|int
name|default_breakpoint_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|default_breakpoint_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|default_breakpoint_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_breakpoint_line
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* *PP is a string denoting a breakpoint.  Get the number of the breakpoint.    Advance *PP after the string and any trailing whitespace.     Currently the string can either be a number or "$" followed by the name    of a convenience variable.  Making it an expression wouldn't work well    for map_breakpoint_numbers (e.g. "4 + 5 + 6").        TRAILER is a character which can be found after the number; most    commonly this is `-'.  If you don't want a trailer, use \0.  */
end_comment

begin_function
specifier|static
name|int
name|get_number_trailer
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|trailer
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* default */
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Empty line means refer to the last breakpoint.  */
return|return
name|breakpoint_count
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
comment|/* Make a copy of the name, so we can null-terminate it          to pass to lookup_internalvar().  */
name|char
modifier|*
name|varname
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|++
name|p
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
name|p
operator|++
expr_stmt|;
name|varname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|varname
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
name|varname
index|[
name|p
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|varname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
name|retval
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Convenience variable must have integer value.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|pp
condition|)
comment|/* There is no number here.  (e.g. "cond a == b").  */
block|{
comment|/* Skip non-numeric token */
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Return zero, which caller must interpret as error. */
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|atoi
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
name|trailer
operator|)
condition|)
block|{
comment|/* Trailing junk: return 0 and let caller print error msg. */
while|while
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
name|trailer
operator|)
condition|)
operator|++
name|p
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Like get_number_trailer, but don't allow a trailer.  */
end_comment

begin_function
name|int
name|get_number
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
return|return
name|get_number_trailer
argument_list|(
name|pp
argument_list|,
literal|'\0'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a number or a range.  * A number will be of the form handled by get_number.  * A range will be of the form<number1> -<number2>, and   * will represent all the integers between number1 and number2,  * inclusive.  *  * While processing a range, this fuction is called iteratively;  * At each call it will return the next value in the range.  *  * At the beginning of parsing a range, the char pointer PP will  * be advanced past<number1> and left pointing at the '-' token.  * Subsequent calls will not advance the pointer until the range  * is completed.  The call that completes the range will advance  * pointer PP past<number2>.  */
end_comment

begin_function
name|int
name|get_number_or_range
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
specifier|static
name|int
name|last_retval
decl_stmt|,
name|end_value
decl_stmt|;
specifier|static
name|char
modifier|*
name|end_ptr
decl_stmt|;
specifier|static
name|int
name|in_range
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
comment|/* Default case: pp is pointing either to a solo number,  	 or to the first number of a range.  */
name|last_retval
operator|=
name|get_number_trailer
argument_list|(
name|pp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
modifier|*
name|temp
decl_stmt|;
comment|/* This is the start of a range (<number1> -<number2>). 	     Skip the '-', parse and remember the second number, 	     and also remember the end of the final token.  */
name|temp
operator|=
operator|&
name|end_ptr
expr_stmt|;
name|end_ptr
operator|=
operator|*
name|pp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|end_ptr
argument_list|)
condition|)
name|end_ptr
operator|++
expr_stmt|;
comment|/* skip white space */
name|end_value
operator|=
name|get_number
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_value
operator|<
name|last_retval
condition|)
block|{
name|error
argument_list|(
literal|"inverted range"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end_value
operator|==
name|last_retval
condition|)
block|{
comment|/* degenerate range (number1 == number2).  Advance the 		 token pointer so that the range will be treated as a 		 single number.  */
operator|*
name|pp
operator|=
name|end_ptr
expr_stmt|;
block|}
else|else
name|in_range
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|in_range
condition|)
name|error
argument_list|(
literal|"negative value"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pp points to the '-' that betokens a range.  All 	 number-parsing has already been done.  Return the next 	 integer value (one greater than the saved previous value). 	 Do not advance the token pointer 'pp' until the end of range 	 is reached.  */
if|if
condition|(
operator|++
name|last_retval
operator|==
name|end_value
condition|)
block|{
comment|/* End of range reached; advance token pointer.  */
operator|*
name|pp
operator|=
name|end_ptr
expr_stmt|;
name|in_range
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|last_retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* condition N EXP -- set break condition of breakpoint N to EXP.  */
end_comment

begin_function
specifier|static
name|void
name|condition_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|bnum
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bnum
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad breakpoint argument: '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|xfree
argument_list|(
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|b
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Breakpoint %d now unconditional.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|p
expr_stmt|;
comment|/* I don't know if it matters whether this is the string the user 	     typed in or the decompiled expression.  */
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|pending
condition|)
block|{
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of expression"
argument_list|)
expr_stmt|;
block|}
block|}
name|breakpoints_changed
argument_list|()
expr_stmt|;
name|breakpoint_modify_event
argument_list|(
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|commands_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|bnum
decl_stmt|;
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
comment|/* If we allowed this, we would have problems with when to      free the storage, if we change the commands currently      being read from.  */
if|if
condition|(
name|executing_breakpoint_commands
condition|)
name|error
argument_list|(
literal|"Can't use the \"commands\" command among a breakpoint's commands."
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|bnum
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"Unexpected extra arguments following breakpoint number."
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
name|char
modifier|*
name|tmpbuf
init|=
name|xstrprintf
argument_list|(
literal|"Type commands for when breakpoint %d is hit, one per line."
argument_list|,
name|bnum
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|tmpbuf
argument_list|)
decl_stmt|;
name|l
operator|=
name|read_command_lines
argument_list|(
name|tmpbuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|b
operator|->
name|commands
argument_list|)
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|l
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
name|breakpoint_modify_event
argument_list|(
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like target_read_memory() but if breakpoints are inserted, return    the shadow contents instead of the breakpoints themselves.     Read "memory data" from whatever target or inferior we have.     Returns zero if successful, errno value if not.  EIO is used    for address out of bounds.  If breakpoints are inserted, returns    shadow contents, not the breakpoints themselves.  From breakpoint.c.  */
end_comment

begin_function
name|int
name|read_memory_nobpt
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|;
name|CORE_ADDR
name|bp_addr
init|=
literal|0
decl_stmt|;
name|int
name|bp_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|bp_addr
argument_list|,
operator|&
name|bp_size
argument_list|)
operator|==
name|NULL
condition|)
comment|/* No breakpoints on this machine. */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_none
condition|)
name|warning
argument_list|(
literal|"reading through apparently deleted breakpoint #%d?"
argument_list|,
name|b
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|loc_type
operator|!=
name|bp_loc_software_breakpoint
condition|)
continue|continue;
if|if
condition|(
operator|!
name|b
operator|->
name|inserted
condition|)
continue|continue;
comment|/* Addresses and length of the part of the breakpoint that        we need to copy.  */
comment|/* XXXX The m68k, sh and h8300 have different local and remote        breakpoint values.  BREAKPOINT_FROM_PC still manages to        correctly determine the breakpoints memory address and size        for these targets. */
name|bp_addr
operator|=
name|b
operator|->
name|address
expr_stmt|;
name|bp_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|bp_addr
argument_list|,
operator|&
name|bp_size
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|bp_size
operator|==
literal|0
condition|)
comment|/* bp isn't valid */
continue|continue;
if|if
condition|(
name|bp_addr
operator|+
name|bp_size
operator|<=
name|memaddr
condition|)
comment|/* The breakpoint is entirely before the chunk of memory we          are reading.  */
continue|continue;
if|if
condition|(
name|bp_addr
operator|>=
name|memaddr
operator|+
name|len
condition|)
comment|/* The breakpoint is entirely after the chunk of memory we are          reading. */
continue|continue;
comment|/* Copy the breakpoint from the shadow contents, and recurse for        the things before and after.  */
block|{
comment|/* Offset within shadow_contents.  */
name|int
name|bptoffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bp_addr
operator|<
name|memaddr
condition|)
block|{
comment|/* Only copy the second part of the breakpoint.  */
name|bp_size
operator|-=
name|memaddr
operator|-
name|bp_addr
expr_stmt|;
name|bptoffset
operator|=
name|memaddr
operator|-
name|bp_addr
expr_stmt|;
name|bp_addr
operator|=
name|memaddr
expr_stmt|;
block|}
if|if
condition|(
name|bp_addr
operator|+
name|bp_size
operator|>
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Only copy the first part of the breakpoint.  */
name|bp_size
operator|-=
operator|(
name|bp_addr
operator|+
name|bp_size
operator|)
operator|-
operator|(
name|memaddr
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|myaddr
operator|+
name|bp_addr
operator|-
name|memaddr
argument_list|,
name|b
operator|->
name|shadow_contents
operator|+
name|bptoffset
argument_list|,
name|bp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp_addr
operator|>
name|memaddr
condition|)
block|{
comment|/* Copy the section of memory before the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|bp_addr
operator|-
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|bp_addr
operator|+
name|bp_size
operator|<
name|memaddr
operator|+
name|len
condition|)
block|{
comment|/* Copy the section of memory after the breakpoint.  */
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|bp_addr
operator|+
name|bp_size
argument_list|,
name|myaddr
operator|+
name|bp_addr
operator|+
name|bp_size
operator|-
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
operator|-
operator|(
name|bp_addr
operator|+
name|bp_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/* Nothing overlaps.  Just call read_memory_noerr.  */
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A wrapper function for inserting catchpoints.  */
end_comment

begin_function
specifier|static
name|int
name|insert_catchpoint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uo
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|args
decl_stmt|;
name|int
name|val
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_catch_fork
case|:
name|val
operator|=
name|target_insert_fork_catchpoint
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_vfork
case|:
name|val
operator|=
name|target_insert_vfork_catchpoint
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
name|val
operator|=
name|target_insert_exec_catchpoint
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown breakpoint type"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|throw_exception
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert a low-level "breakpoint" of some type.  BPT is the breakpoint.    Any error messages are printed to TMP_ERROR_STREAM; and DISABLED_BREAKS,    PROCESS_WARNING, and HW_BREAKPOINT_ERROR are used to report problems.     NOTE drow/2003-09-09: This routine could be broken down to an object-style    method for each breakpoint or catchpoint type.  */
end_comment

begin_function
specifier|static
name|int
name|insert_bp_location
parameter_list|(
name|struct
name|bp_location
modifier|*
name|bpt
parameter_list|,
name|struct
name|ui_file
modifier|*
name|tmp_error_stream
parameter_list|,
name|int
modifier|*
name|disabled_breaks
parameter_list|,
name|int
modifier|*
name|process_warning
parameter_list|,
name|int
modifier|*
name|hw_breakpoint_error
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
comment|/* Permanent breakpoints cannot be inserted or removed.  Disabled      breakpoints should not be inserted.  */
if|if
condition|(
operator|!
name|breakpoint_enabled
argument_list|(
name|bpt
operator|->
name|owner
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bpt
operator|->
name|inserted
operator|||
name|bpt
operator|->
name|duplicate
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_software_breakpoint
operator|||
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
block|{
comment|/* First check to see if we have to handle an overlay.  */
if|if
condition|(
name|overlay_debugging
operator|==
name|ovly_off
operator|||
name|bpt
operator|->
name|section
operator|==
name|NULL
operator|||
operator|!
operator|(
name|section_is_overlay
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
operator|)
condition|)
block|{
comment|/* No overlay handling: just set the breakpoint.  */
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This breakpoint is in an overlay section.   	     Shall we set a breakpoint at the LMA?  */
if|if
condition|(
operator|!
name|overlay_events_enabled
condition|)
block|{
comment|/* Yes -- overlay event support is not active,  		 so we must try to set a breakpoint at the LMA. 		 This will not work for a hardware breakpoint.  */
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|warning
argument_list|(
literal|"hardware breakpoint %d not supported in overlay!\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
else|else
block|{
name|CORE_ADDR
name|addr
init|=
name|overlay_unmapped_address
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|section
argument_list|)
decl_stmt|;
comment|/* Set a software (trap) breakpoint at the LMA.  */
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Overlay breakpoint %d failed: in ROM?"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Shall we set a breakpoint at the VMA? */
if|if
condition|(
name|section_is_mapped
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* Yes.  This overlay section is mapped into memory.  */
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No.  This breakpoint will not be inserted.   		 No error, but do not mark the bp as 'inserted'.  */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|val
condition|)
block|{
comment|/* Can't set the breakpoint.  */
if|#
directive|if
name|defined
argument_list|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|)
if|if
condition|(
name|DISABLE_UNSETTABLE_BREAK
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* See also: disable_breakpoints_in_shlibs. */
name|val
operator|=
literal|0
expr_stmt|;
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|=
name|bp_shlib_disabled
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|disabled_breaks
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert breakpoint %d.\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Temporarily disabling shared library breakpoints:\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|disabled_breaks
operator|=
literal|1
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"breakpoint #%d\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ONE_PROCESS_WRITETEXT
operator|*
name|process_warning
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
block|{
operator|*
name|hw_breakpoint_error
operator|=
literal|1
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert hardware breakpoint %d.\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert breakpoint %d.\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Error accessing memory address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|tmp_error_stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|": %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|bpt
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_watchpoint
comment|/* NOTE drow/2003-09-08: This state only exists for removing 	      watchpoints.  It's not clear that it's necessary... */
operator|&&
name|bpt
operator|->
name|owner
operator|->
name|disposition
operator|!=
name|disp_del_at_next_stop
condition|)
block|{
comment|/* FIXME drow/2003-09-08: This code sets multiple hardware watchpoints 	 based on the expression.  Ideally this should happen at a higher level, 	 and there should be one bp_location for each computed address we 	 must watch.  As soon as a many-to-one mapping is available I'll 	 convert this.  */
name|struct
name|frame_info
modifier|*
name|saved_frame
decl_stmt|;
name|int
name|saved_level
decl_stmt|,
name|within_current_scope
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
comment|/* Save the current frame and level so we can restore it after 	 evaluating the watchpoint expression on its own frame.  */
comment|/* FIXME drow/2003-09-09: It would be nice if evaluate_expression 	 took a frame parameter, so that we didn't have to change the 	 selected frame.  */
name|saved_frame
operator|=
name|deprecated_selected_frame
expr_stmt|;
name|saved_level
operator|=
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
comment|/* Determine if the watchpoint is within scope.  */
if|if
condition|(
name|bpt
operator|->
name|owner
operator|->
name|exp_valid_block
operator|==
name|NULL
condition|)
name|within_current_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|frame_find_by_id
argument_list|(
name|bpt
operator|->
name|owner
operator|->
name|watchpoint_frame
argument_list|)
expr_stmt|;
name|within_current_scope
operator|=
operator|(
name|fi
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|within_current_scope
condition|)
name|select_frame
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* Evaluate the expression and cut the chain of values 	     produced off from the value chain.  	     Make sure the value returned isn't lazy; we use 	     laziness to determine what memory GDB actually needed 	     in order to compute the value of the expression.  */
name|v
operator|=
name|evaluate_expression
argument_list|(
name|bpt
operator|->
name|owner
operator|->
name|exp
argument_list|)
expr_stmt|;
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|value_release_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|owner
operator|->
name|val_chain
operator|=
name|v
expr_stmt|;
name|bpt
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
comment|/* Look at each value on the value chain.  */
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
comment|/* If it's a memory location, and GDB actually needed 		 its contents to evaluate the expression, then we 		 must watch it.  */
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|==
name|lval_memory
operator|&&
operator|!
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|vtype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We only watch structs and arrays if user asked 		     for it explicitly, never if they just happen to 		     appear in the middle of some value chain.  */
if|if
condition|(
name|v
operator|==
name|bpt
operator|->
name|owner
operator|->
name|val_chain
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|hw_write
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
name|type
operator|=
name|hw_read
expr_stmt|;
elseif|else
if|if
condition|(
name|bpt
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
name|type
operator|=
name|hw_access
expr_stmt|;
name|val
operator|=
name|target_insert_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Don't exit the loop, try to insert 			     every value on the value chain.  That's 			     because we will be removing all the 			     watches below, and removing a 			     watchpoint we didn't insert could have 			     adverse effects.  */
name|bpt
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Failure to insert a watchpoint on any memory value in the 	     value chain brings us here.  */
if|if
condition|(
operator|!
name|bpt
operator|->
name|inserted
condition|)
block|{
name|remove_breakpoint
argument_list|(
name|bpt
argument_list|,
name|mark_uninserted
argument_list|)
expr_stmt|;
operator|*
name|hw_breakpoint_error
operator|=
literal|1
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Could not insert hardware watchpoint %d.\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
name|val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Hardware watchpoint %d deleted "
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"because the program has left the block \n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"in which its expression is valid.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|owner
operator|->
name|related_breakpoint
condition|)
name|bpt
operator|->
name|owner
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
name|bpt
operator|->
name|owner
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
block|}
comment|/* Restore the frame and level.  */
if|if
condition|(
name|saved_frame
operator|!=
name|deprecated_selected_frame
operator|||
name|saved_level
operator|!=
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
condition|)
name|select_frame
argument_list|(
name|saved_frame
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|bpt
operator|->
name|owner
argument_list|)
condition|)
block|{
comment|/* FIXME drow/2003-09-09: This code sets both a catchpoint and a 	 breakpoint.  Once again, it would be better if this was represented 	 as two bp_locations.  */
comment|/* If we get here, we must have a callback mechanism for exception 	 events -- with g++ style embedded label support, we insert 	 ordinary breakpoints and not catchpoints. */
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
comment|/* Couldn't set breakpoint for some reason */
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert catchpoint %d; disabling it.\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Error accessing memory address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|tmp_error_stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|": %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
block|}
else|else
block|{
comment|/* Bp set, now make sure callbacks are enabled */
comment|/* Format possible error msg */
name|char
modifier|*
name|message
init|=
name|xstrprintf
argument_list|(
literal|"Error inserting catchpoint %d:\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|int
name|val
decl_stmt|;
name|args_for_catchpoint_enable
name|args
decl_stmt|;
name|args
operator|.
name|kind
operator|=
name|bpt
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_catch
condition|?
name|EX_EVENT_CATCH
else|:
name|EX_EVENT_THROW
expr_stmt|;
name|args
operator|.
name|enable_p
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|catch_errors
argument_list|(
name|cover_target_enable_exception_callback
argument_list|,
operator|&
name|args
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|val
operator|!=
operator|-
literal|1
condition|)
name|bpt
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
comment|/* Check if something went wrong; val == 0 can be ignored */
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* something went wrong */
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert catchpoint %d; disabling it.\n"
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|bpt
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_fork
operator|||
name|bpt
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|||
name|bpt
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_exec
condition|)
block|{
name|char
modifier|*
name|prefix
init|=
name|xstrprintf
argument_list|(
literal|"warning: inserting catchpoint %d: "
argument_list|,
name|bpt
operator|->
name|owner
operator|->
name|number
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|val
operator|=
name|catch_exceptions
argument_list|(
name|uiout
argument_list|,
name|insert_catchpoint
argument_list|,
name|bpt
operator|->
name|owner
argument_list|,
name|prefix
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
else|else
name|bpt
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
comment|/* We've already printed an error message if there was a problem 	 inserting this catchpoint, and we've disabled the catchpoint, 	 so just return success.  */
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* insert_breakpoints is used when starting or continuing the program.    remove_breakpoints is used when the program stops.    Both return zero if successful,    or an `errno' value if could not write the inferior.  */
end_comment

begin_function
name|int
name|insert_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|return_val
init|=
literal|0
decl_stmt|;
comment|/* return success code. */
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|disabled_breaks
init|=
literal|0
decl_stmt|;
name|int
name|hw_breakpoint_error
init|=
literal|0
decl_stmt|;
name|int
name|process_warning
init|=
literal|0
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|tmp_error_stream
init|=
name|mem_fileopen
argument_list|()
decl_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_error_stream
argument_list|)
expr_stmt|;
comment|/* Explicitly mark the warning -- this will only be printed if      there was an error.  */
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Warning:\n"
argument_list|)
expr_stmt|;
name|ALL_BP_LOCATIONS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
comment|/* Permanent breakpoints cannot be inserted or removed.  Disabled 	 breakpoints should not be inserted.  */
if|if
condition|(
operator|!
name|breakpoint_enabled
argument_list|(
name|b
operator|->
name|owner
argument_list|)
condition|)
continue|continue;
comment|/* FIXME drow/2003-10-07: This code should be pushed elsewhere when 	 hardware watchpoints are split into multiple loc breakpoints.  */
if|if
condition|(
operator|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_watchpoint
operator|||
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_watchpoint
operator|)
operator|&&
operator|!
name|b
operator|->
name|owner
operator|->
name|val
condition|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|owner
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|b
operator|->
name|owner
operator|->
name|val
operator|=
name|val
expr_stmt|;
block|}
name|val
operator|=
name|insert_bp_location
argument_list|(
name|b
argument_list|,
name|tmp_error_stream
argument_list|,
operator|&
name|disabled_breaks
argument_list|,
operator|&
name|process_warning
argument_list|,
operator|&
name|hw_breakpoint_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|return_val
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|return_val
condition|)
block|{
comment|/* If a hardware breakpoint or watchpoint was inserted, add a          message about possibly exhausted resources.  */
if|if
condition|(
name|hw_breakpoint_error
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Could not insert hardware breakpoints:\n\ You may have requested too many hardware breakpoints/watchpoints.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ONE_PROCESS_WRITETEXT
if|if
condition|(
name|process_warning
condition|)
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"The same program may be running in another process."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|error_stream
argument_list|(
name|tmp_error_stream
argument_list|)
expr_stmt|;
block|}
return|return
name|return_val
return|;
block|}
end_function

begin_function
name|int
name|remove_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_uninserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remove_hw_watchpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
operator|&&
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_watchpoint
condition|)
block|{
name|val
operator|=
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_uninserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|reattach_breakpoints
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|save_inferior_ptid
argument_list|()
decl_stmt|;
comment|/* Set inferior_ptid; remove_breakpoint uses this global.  */
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_inserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
comment|/* FIXME drow/2003-10-07: This doesn't handle any other kinds of 	   breakpoints.  It's wrong for watchpoints, for example.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|update_breakpoints_after_exec
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|temp
decl_stmt|;
comment|/* Doing this first prevents the badness of having delete_breakpoint()      write a breakpoint's current "shadow contents" to lift the bp.  That      shadow is NOT valid after an exec()! */
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
comment|/* Solib breakpoints must be explicitly reset after an exec(). */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_shlib_event
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Thread event breakpoints must be set anew after an exec(),        as must overlay event breakpoints.  */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_thread_event
operator|||
name|b
operator|->
name|type
operator|==
name|bp_overlay_event
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Step-resume breakpoints are meaningless after an exec(). */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_step_resume
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ditto the sigtramp handler breakpoints. */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_through_sigtramp
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ditto the exception-handling catchpoints. */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Don't delete an exec catchpoint, because else the inferior        won't stop when it ought!         Similarly, we probably ought to keep vfork catchpoints, 'cause        on this target, we may not be able to stop when the vfork is        seen, but only when the subsequent exec is seen.  (And because        deleting fork catchpoints here but not vfork catchpoints will        seem mysterious to users, keep those too.)         ??rehrauer: Let's hope that merely clearing out this catchpoint's        target address field, if any, is sufficient to have it be reset        automagically.  Certainly on HP-UX that's true.         Jim Blandy<jimb@redhat.com>: Actually, zero is a perfectly        valid code address on some platforms (like the mn10300        simulators).  We shouldn't assign any special interpretation to        a breakpoint with a zero address.  And in fact, GDB doesn't ---        I can't see what that comment above is talking about.  As far        as I can tell, setting the address of a        bp_catch_exec/bp_catch_vfork/bp_catch_fork breakpoint to zero        is meaningless, since those are implemented with HP-UX kernel        hackery, not by storing breakpoint instructions somewhere.  */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
condition|)
block|{
name|b
operator|->
name|loc
operator|->
name|address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* bp_finish is a special case.  The only way we ought to be able        to see one of these when an exec() has happened, is if the user        caught a vfork, and then said "finish".  Ordinarily a finish just        carries them to the call-site of the current callee, by setting        a temporary bp there and resuming.  But in this case, the finish        will carry them entirely through the vfork& exec.         We don't want to allow a bp_finish to remain inserted now.  But        we can't safely delete it, 'cause finish_command has a handle to        the bp on a bpstat, and will later want to delete it.  There's a        chance (and I've seen it happen) that if we delete the bp_finish        here, that its storage will get reused by the time finish_command        gets 'round to deleting the "use to be a bp_finish" breakpoint.        We really must allow finish_command to delete a bp_finish.         In the absense of a general solution for the "how do we know        it's safe to delete something others may have handles to?"        problem, what we'll do here is just uninsert the bp_finish, and        let finish_command delete it.         (We know the bp_finish is "doomed" in the sense that it's        momentary, and will be deleted as soon as finish_command sees        the inferior stopped.  So it doesn't matter that the bp's        address is probably bogus in the new a.out, unlike e.g., the        solib breakpoints.)  */
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_finish
condition|)
block|{
continue|continue;
block|}
comment|/* Without a symbolic address, we have little hope of the        pre-exec() address meaning the same thing in the post-exec()        a.out. */
if|if
condition|(
name|b
operator|->
name|addr_string
operator|==
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this breakpoint has survived the above battery of checks, then        it must have a symbolic address.  Be sure that it gets reevaluated        to a target address, rather than reusing the old evaluation.         Jim Blandy<jimb@redhat.com>: As explained above in the comment        for bp_catch_exec and friends, I'm pretty sure this is entirely        unnecessary.  A call to breakpoint_re_set_one always recomputes        the breakpoint's address from scratch, or deletes it if it can't.        So I think this assignment could be deleted without effect.  */
name|b
operator|->
name|loc
operator|->
name|address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* FIXME what about longjmp breakpoints?  Re-create them here?  */
name|create_overlay_event_breakpoint
argument_list|(
literal|"_ovly_debug_event"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|detach_breakpoints
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|save_inferior_ptid
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
operator|==
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|error
argument_list|(
literal|"Cannot detach breakpoints of inferior_ptid"
argument_list|)
expr_stmt|;
comment|/* Set inferior_ptid; remove_breakpoint uses this global.  */
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|remove_breakpoint
argument_list|(
name|b
argument_list|,
name|mark_inserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_breakpoint
parameter_list|(
name|struct
name|bp_location
modifier|*
name|b
parameter_list|,
name|insertion_state_t
name|is
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|==
name|bp_permanent
condition|)
comment|/* Permanent breakpoints cannot be inserted or removed.  */
return|return
literal|0
return|;
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_none
condition|)
name|warning
argument_list|(
literal|"attempted to remove apparently deleted breakpoint #%d?"
argument_list|,
name|b
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_software_breakpoint
operator|||
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
block|{
comment|/* "Normal" instruction breakpoint: either the standard 	 trap-instruction bp (bp_breakpoint), or a 	 bp_hardware_breakpoint.  */
comment|/* First check to see if we have to handle an overlay.  */
if|if
condition|(
name|overlay_debugging
operator|==
name|ovly_off
operator|||
name|b
operator|->
name|section
operator|==
name|NULL
operator|||
operator|!
operator|(
name|section_is_overlay
argument_list|(
name|b
operator|->
name|section
argument_list|)
operator|)
condition|)
block|{
comment|/* No overlay handling: just remove the breakpoint.  */
if|if
condition|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|val
operator|=
name|target_remove_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This breakpoint is in an overlay section.   	     Did we set a breakpoint at the LMA?  */
if|if
condition|(
operator|!
name|overlay_events_enabled
condition|)
block|{
comment|/* Yes -- overlay event support is not active, so we 		   should have set a breakpoint at the LMA.  Remove it.   		*/
name|CORE_ADDR
name|addr
init|=
name|overlay_unmapped_address
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|section
argument_list|)
decl_stmt|;
comment|/* Ignore any failures: if the LMA is in ROM, we will 		   have already warned when we failed to insert it.  */
if|if
condition|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|target_remove_hw_breakpoint
argument_list|(
name|addr
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|target_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
comment|/* Did we set a breakpoint at the VMA?  	     If so, we will have marked the breakpoint 'inserted'.  */
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
comment|/* Yes -- remove it.  Previously we did not bother to 		 remove the breakpoint if the section had been 		 unmapped, but let's not rely on that being safe.  We 		 don't know what the overlay manager might do.  */
if|if
condition|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_breakpoint
condition|)
name|val
operator|=
name|target_remove_hw_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No -- not inserted, so no need to remove.  No error.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_watchpoint
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|struct
name|value
modifier|*
name|n
decl_stmt|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
comment|/* Walk down the saved value chain.  */
for|for
control|(
name|v
operator|=
name|b
operator|->
name|owner
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
comment|/* For each memory reference remove the watchpoint 	     at that address.  */
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|==
name|lval_memory
operator|&&
operator|!
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|vtype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|b
operator|->
name|owner
operator|->
name|val_chain
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|hw_write
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
name|type
operator|=
name|hw_read
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
name|type
operator|=
name|hw_access
expr_stmt|;
name|val
operator|=
name|target_remove_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Failure to remove any of the hardware watchpoints comes here.  */
if|if
condition|(
operator|(
name|is
operator|==
name|mark_uninserted
operator|)
operator|&&
operator|(
name|b
operator|->
name|inserted
operator|)
condition|)
name|warning
argument_list|(
literal|"Could not remove hardware watchpoint %d."
argument_list|,
name|b
operator|->
name|owner
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* Free the saved value chain.  We will construct a new one          the next time the watchpoint is inserted.  */
for|for
control|(
name|v
operator|=
name|b
operator|->
name|owner
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|n
control|)
block|{
name|n
operator|=
name|v
operator|->
name|next
expr_stmt|;
name|value_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|owner
operator|->
name|val_chain
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_fork
operator|||
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|||
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|owner
operator|->
name|type
condition|)
block|{
case|case
name|bp_catch_fork
case|:
name|val
operator|=
name|target_remove_fork_catchpoint
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_vfork
case|:
name|val
operator|=
name|target_remove_vfork_catchpoint
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
name|val
operator|=
name|target_remove_exec_catchpoint
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Internal error, %s line %d."
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_catch
operator|||
name|b
operator|->
name|owner
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
operator|->
name|owner
argument_list|)
operator|&&
name|b
operator|->
name|inserted
comment|/* sometimes previous insert doesn't happen */
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|val
operator|=
name|target_remove_breakpoint
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
operator|(
name|is
operator|==
name|mark_inserted
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints.  */
end_comment

begin_function
name|void
name|mark_breakpoints_out
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
name|bpt
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints and delete any    breakpoints which should go away between runs of the program.     Plus other such housekeeping that has to be done for breakpoints    between runs.     Note: this function gets called at the end of a run (by    generic_mourn_inferior) and when a run begins (by    init_wait_for_inferior). */
end_comment

begin_function
name|void
name|breakpoint_init_inferior
parameter_list|(
name|enum
name|inf_context
name|context
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
specifier|static
name|int
name|warning_needed
init|=
literal|0
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
name|bpt
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_call_dummy
case|:
case|case
name|bp_watchpoint_scope
case|:
comment|/* If the call dummy breakpoint is at the entry point it will 	   cause problems when the inferior is rerun, so we better 	   get rid of it.   	   Also get rid of scope breakpoints.  */
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
comment|/* Likewise for watchpoints on local expressions.  */
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|inf_starting
condition|)
block|{
comment|/* Reset val field to force reread of starting value 	       in insert_breakpoints.  */
if|if
condition|(
name|b
operator|->
name|val
condition|)
name|value_free
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Likewise for exception catchpoints in dynamic-linked 	   executables where required */
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|&&
name|exception_catchpoints_are_fragile
condition|)
block|{
name|warning_needed
operator|=
literal|1
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|exception_catchpoints_are_fragile
condition|)
name|exception_support_initialized
operator|=
literal|0
expr_stmt|;
comment|/* Don't issue the warning unless it's really needed... */
if|if
condition|(
name|warning_needed
operator|&&
operator|(
name|context
operator|!=
name|inf_exited
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Exception catchpoints from last run were deleted."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"You must reinsert them explicitly."
argument_list|)
expr_stmt|;
name|warning_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* breakpoint_here_p (PC) returns non-zero if an enabled breakpoint    exists at PC.  It returns ordinary_breakpoint_here if it's an    ordinary breakpoint, or permanent_breakpoint_here if it's a    permanent breakpoint.    - When continuing from a location with an ordinary breakpoint, we      actually single step once before calling insert_breakpoints.    - When continuing from a localion with a permanent breakpoint, we      need to use the `SKIP_PERMANENT_BREAKPOINT' macro, provided by      the target, to advance the PC past the breakpoint.  */
end_comment

begin_function
name|enum
name|breakpoint_here
name|breakpoint_here_p
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
name|int
name|any_breakpoint_here
init|=
literal|0
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
block|{
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_software_breakpoint
operator|&&
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_hardware_breakpoint
condition|)
continue|continue;
if|if
condition|(
operator|(
name|breakpoint_enabled
argument_list|(
name|bpt
operator|->
name|owner
argument_list|)
operator|||
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|==
name|bp_permanent
operator|)
operator|&&
name|bpt
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* bp is enabled and matches pc */
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
elseif|else
if|if
condition|(
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|==
name|bp_permanent
condition|)
return|return
name|permanent_breakpoint_here
return|;
else|else
name|any_breakpoint_here
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|any_breakpoint_here
condition|?
name|ordinary_breakpoint_here
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* breakpoint_inserted_here_p (PC) is just like breakpoint_here_p(),    but it only returns true if there is actually a breakpoint inserted    at PC.  */
end_comment

begin_function
name|int
name|breakpoint_inserted_here_p
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
block|{
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_software_breakpoint
operator|&&
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_hardware_breakpoint
condition|)
continue|continue;
if|if
condition|(
name|bpt
operator|->
name|inserted
operator|&&
name|bpt
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* bp is inserted and matches pc */
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function returns non-zero iff there is a software breakpoint    inserted at PC.  */
end_comment

begin_function
name|int
name|software_breakpoint_inserted_here_p
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
name|int
name|any_breakpoint_here
init|=
literal|0
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
block|{
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_software_breakpoint
condition|)
continue|continue;
if|if
condition|(
operator|(
name|breakpoint_enabled
argument_list|(
name|bpt
operator|->
name|owner
argument_list|)
operator|||
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|==
name|bp_permanent
operator|)
operator|&&
name|bpt
operator|->
name|inserted
operator|&&
name|bpt
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* bp is enabled and matches pc */
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FRAME is a dummy frame.  We can't use    DEPRECATED_PC_IN_CALL_DUMMY because figuring out the saved SP would    take too much time, at least using frame_register() on the 68k.    This means that for this function to work right a port must use the    bp_call_dummy breakpoint.  */
end_comment

begin_function
name|int
name|deprecated_frame_in_dummy
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
comment|/* This function is used by two files: get_frame_type(), after first      checking that !DEPRECATED_USE_GENERIC_DUMMY_FRAMES; and      sparc-tdep.c, which doesn't yet use generic dummy frames anyway.  */
name|gdb_assert
argument_list|(
operator|!
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_call_dummy
operator|&&
name|frame_id_eq
argument_list|(
name|b
operator|->
name|frame_id
argument_list|,
name|get_frame_id
argument_list|(
name|frame
argument_list|)
argument_list|)
comment|/* We need to check the PC as well as the frame on the sparc,        for signals.exp in the testsuite.  */
operator|&&
operator|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
operator|>=
operator|(
name|b
operator|->
name|loc
operator|->
name|address
operator|-
name|DEPRECATED_SIZEOF_CALL_DUMMY_WORDS
operator|/
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|DEPRECATED_REGISTER_SIZE
operator|)
operator|)
operator|&&
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
operator|<=
name|b
operator|->
name|loc
operator|->
name|address
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* breakpoint_thread_match (PC, PTID) returns true if the breakpoint at    PC is valid for process/thread PTID.  */
end_comment

begin_function
name|int
name|breakpoint_thread_match
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
block|{
if|if
condition|(
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_software_breakpoint
operator|&&
name|bpt
operator|->
name|loc_type
operator|!=
name|bp_loc_hardware_breakpoint
condition|)
continue|continue;
if|if
condition|(
operator|(
name|breakpoint_enabled
argument_list|(
name|bpt
operator|->
name|owner
argument_list|)
operator|||
name|bpt
operator|->
name|owner
operator|->
name|enable_state
operator|==
name|bp_permanent
operator|)
operator|&&
name|bpt
operator|->
name|address
operator|==
name|pc
operator|&&
operator|(
name|bpt
operator|->
name|owner
operator|->
name|thread
operator|==
operator|-
literal|1
operator|||
name|bpt
operator|->
name|owner
operator|->
name|thread
operator|==
name|thread
operator|)
condition|)
block|{
if|if
condition|(
name|overlay_debugging
operator|&&
name|section_is_overlay
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|bpt
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* unmapped overlay -- can't be a match */
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* bpstat stuff.  External routines' interfaces are documented    in breakpoint.h.  */
end_comment

begin_function
name|int
name|ep_is_catchpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_unload
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
return|;
comment|/* ??rehrauer: Add more kinds here, as are implemented... */
block|}
end_function

begin_function
name|int
name|ep_is_shlib_catchpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_unload
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ep_is_exception_catchpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
operator|||
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_throw
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear a bpstat so that it says we are not at any breakpoint.    Also free any storage that is part of a bpstat.  */
end_comment

begin_function
name|void
name|bpstat_clear
parameter_list|(
name|bpstat
modifier|*
name|bsp
parameter_list|)
block|{
name|bpstat
name|p
decl_stmt|;
name|bpstat
name|q
decl_stmt|;
if|if
condition|(
name|bsp
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|*
name|bsp
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|old_val
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|p
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|p
operator|->
name|commands
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
operator|*
name|bsp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a copy of a bpstat.  Like "bs1 = bs2" but all storage that    is part of the bpstat is copied as well.  */
end_comment

begin_function
name|bpstat
name|bpstat_copy
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
name|bpstat
name|p
init|=
name|NULL
decl_stmt|;
name|bpstat
name|tmp
decl_stmt|;
name|bpstat
name|retval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
return|return
name|bs
return|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|tmp
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|bs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|commands
operator|!=
name|NULL
condition|)
name|tmp
operator|->
name|commands
operator|=
name|copy_command_lines
argument_list|(
name|bs
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
name|tmp
operator|->
name|old_val
operator|=
name|value_copy
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* This is the first thing in the chain.  */
name|retval
operator|=
name|tmp
expr_stmt|;
else|else
name|p
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|p
operator|=
name|tmp
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Find the bpstat associated with this breakpoint */
end_comment

begin_function
name|bpstat
name|bpstat_find_breakpoint
parameter_list|(
name|bpstat
name|bsp
parameter_list|,
name|struct
name|breakpoint
modifier|*
name|breakpoint
parameter_list|)
block|{
if|if
condition|(
name|bsp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|bsp
operator|!=
name|NULL
condition|;
name|bsp
operator|=
name|bsp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bsp
operator|->
name|breakpoint_at
operator|==
name|breakpoint
condition|)
return|return
name|bsp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find a step_resume breakpoint associated with this bpstat.    (If there are multiple step_resume bp's on the list, this function    will arbitrarily pick one.)     It is an error to use this function if BPSTAT doesn't contain a    step_resume breakpoint.     See wait_for_inferior's use of this function.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|bpstat_find_step_resume_breakpoint
parameter_list|(
name|bpstat
name|bsp
parameter_list|)
block|{
name|int
name|current_thread
decl_stmt|;
if|if
condition|(
name|bsp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error (bpstat_find_step_resume_breakpoint)"
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bsp
operator|!=
name|NULL
condition|;
name|bsp
operator|=
name|bsp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bsp
operator|->
name|breakpoint_at
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bsp
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_step_resume
operator|)
operator|&&
operator|(
name|bsp
operator|->
name|breakpoint_at
operator|->
name|thread
operator|==
name|current_thread
operator|||
name|bsp
operator|->
name|breakpoint_at
operator|->
name|thread
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
name|bsp
operator|->
name|breakpoint_at
return|;
block|}
name|error
argument_list|(
literal|"Internal error (no step_resume breakpoint found)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the breakpoint number of the first breakpoint we are stopped    at.  *BSP upon return is a bpstat which points to the remaining    breakpoints stopped at (but which is not guaranteed to be good for    anything but further calls to bpstat_num).    Return 0 if passed a bpstat which does not indicate any breakpoints.  */
end_comment

begin_function
name|int
name|bpstat_num
parameter_list|(
name|bpstat
modifier|*
name|bsp
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|bsp
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* No more breakpoint values */
else|else
block|{
name|b
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|breakpoint_at
expr_stmt|;
operator|*
name|bsp
operator|=
operator|(
operator|*
name|bsp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* breakpoint that's been deleted since */
else|else
return|return
name|b
operator|->
name|number
return|;
comment|/* We have its number */
block|}
block|}
end_function

begin_comment
comment|/* Modify BS so that the actions will not be performed.  */
end_comment

begin_function
name|void
name|bpstat_clear_actions
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|free_command_lines
argument_list|(
operator|&
name|bs
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Stub for cleaning up our state if we error-out of a breakpoint command */
end_comment

begin_function
specifier|static
name|void
name|cleanup_executing_breakpoints
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|executing_breakpoint_commands
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute all the commands associated with all the breakpoints at this    location.  Any of these commands could cause the process to proceed    beyond this point, etc.  We look out for such changes by checking    the global "breakpoint_proceeded" after each command.  */
end_comment

begin_function
name|void
name|bpstat_do_actions
parameter_list|(
name|bpstat
modifier|*
name|bsp
parameter_list|)
block|{
name|bpstat
name|bs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Avoid endless recursion if a `source' command is contained      in bs->commands.  */
if|if
condition|(
name|executing_breakpoint_commands
condition|)
return|return;
name|executing_breakpoint_commands
operator|=
literal|1
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|cleanup_executing_breakpoints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top
label|:
comment|/* Note that (as of this writing), our callers all appear to      be passing us the address of global stop_bpstat.  And, if      our calls to execute_control_command cause the inferior to      proceed, that global (and hence, *bsp) will change.       We must be careful to not touch *bsp unless the inferior      has not proceeded. */
comment|/* This pointer will iterate over the list of bpstat's. */
name|bs
operator|=
operator|*
name|bsp
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|this_cmd_tree_chain
decl_stmt|;
comment|/* Take ownership of the BSP's command tree, if it has one.           The command tree could legitimately contain commands like          'step' and 'next', which call clear_proceed_status, which          frees stop_bpstat's command tree.  To make sure this doesn't          free the tree we're executing out from under us, we need to          take ownership of the tree ourselves.  Since a given bpstat's          commands are only executed once, we don't need to copy it; we          can clear the pointer in the bpstat, and make sure we free          the tree when we're done.  */
name|cmd
operator|=
name|bs
operator|->
name|commands
expr_stmt|;
name|bs
operator|->
name|commands
operator|=
literal|0
expr_stmt|;
name|this_cmd_tree_chain
operator|=
name|make_cleanup_free_command_lines
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
name|execute_control_command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_proceeded
condition|)
break|break;
else|else
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
block|}
comment|/* We can free this command tree now.  */
name|do_cleanups
argument_list|(
name|this_cmd_tree_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_proceeded
condition|)
comment|/* The inferior is proceeded by the command; bomb out now. 	   The bpstat chain has been blown away by wait_for_inferior. 	   But since execution has stopped again, there is a new bpstat 	   to look at, so start over.  */
goto|goto
name|top
goto|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the normal print function for a bpstat.  In the future,    much of this logic could (should?) be moved to bpstat_stop_status,    by having it set different print_it values.     Current scheme: When we stop, bpstat_print() is called.  It loops    through the bpstat list of things causing this stop, calling the    print_bp_stop_message function on each one. The behavior of the    print_bp_stop_message function depends on the print_it field of    bpstat. If such field so indicates, call this function here.     Return values from this routine (ultimately used by bpstat_print()    and normal_stop() to decide what to do):     PRINT_NOTHING: Means we already printed all we needed to print,    don't print anything else.    PRINT_SRC_ONLY: Means we printed something, and we do *not* desire    that something to be followed by a location.    PRINT_SCR_AND_LOC: Means we printed something, and we *do* desire    that something to be followed by a location.    PRINT_UNKNOWN: Means we printed nothing or we need to do some more    analysis.  */
end_comment

begin_function
specifier|static
name|enum
name|print_stop_action
name|print_it_typical
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|,
modifier|*
name|ui_out_chain
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
comment|/* bs->breakpoint_at can be NULL if it was a momentary breakpoint      which has since been deleted.  */
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
condition|)
return|return
name|PRINT_UNKNOWN
return|;
switch|switch
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|loc
operator|->
name|address
operator|!=
name|bs
operator|->
name|breakpoint_at
operator|->
name|loc
operator|->
name|requested_address
condition|)
name|breakpoint_adjustment_warning
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|loc
operator|->
name|requested_address
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|loc
operator|->
name|address
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|annotate_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nBreakpoint "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"breakpoint-hit"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"bkptno"
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|bp_shlib_event
case|:
comment|/* Did we stop because the user set the stop_on_solib_events 	 variable?  (If so, we report this as a generic, "Stopped due 	 to shlib event" message.) */
name|printf_filtered
argument_list|(
literal|"Stopped due to shared library event\n"
argument_list|)
expr_stmt|;
return|return
name|PRINT_NOTHING
return|;
break|break;
case|case
name|bp_thread_event
case|:
comment|/* Not sure how we will get here.  	 GDB should not stop for these breakpoints.  */
name|printf_filtered
argument_list|(
literal|"Thread Event Breakpoint: gdb should not stop!\n"
argument_list|)
expr_stmt|;
return|return
name|PRINT_NOTHING
return|;
break|break;
case|case
name|bp_overlay_event
case|:
comment|/* By analogy with the thread event, GDB should not stop for these. */
name|printf_filtered
argument_list|(
literal|"Overlay Event Breakpoint: gdb should not stop!\n"
argument_list|)
expr_stmt|;
return|return
name|PRINT_NOTHING
return|;
break|break;
case|case
name|bp_catch_load
case|:
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d ("
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"loaded"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|bp_catch_unload
case|:
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d ("
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"unloaded"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|bp_catch_fork
case|:
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d ("
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"forked"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" process %d), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|forked_inferior_pid
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|bp_catch_vfork
case|:
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d ("
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"vforked"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" process %d), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|forked_inferior_pid
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|bp_catch_exec
case|:
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exec'd %s), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|exec_pathname
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|bp_catch_catch
case|:
if|if
condition|(
name|current_exception_event
operator|&&
operator|(
name|CURRENT_EXCEPTION_KIND
operator|==
name|EX_EVENT_CATCH
operator|)
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exception caught), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"throw location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_THROW_PC
operator|&&
name|CURRENT_EXCEPTION_THROW_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_THROW_FILE
argument_list|,
name|CURRENT_EXCEPTION_THROW_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", catch location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_CATCH_PC
operator|&&
name|CURRENT_EXCEPTION_CATCH_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_CATCH_FILE
argument_list|,
name|CURRENT_EXCEPTION_CATCH_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* don't bother to print location frame info */
return|return
name|PRINT_SRC_ONLY
return|;
block|}
else|else
block|{
comment|/* really throw, some other bpstat will handle it */
return|return
name|PRINT_UNKNOWN
return|;
block|}
break|break;
case|case
name|bp_catch_throw
case|:
if|if
condition|(
name|current_exception_event
operator|&&
operator|(
name|CURRENT_EXCEPTION_KIND
operator|==
name|EX_EVENT_THROW
operator|)
condition|)
block|{
name|annotate_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exception thrown), "
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"throw location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_THROW_PC
operator|&&
name|CURRENT_EXCEPTION_THROW_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_THROW_FILE
argument_list|,
name|CURRENT_EXCEPTION_THROW_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", catch location "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_EXCEPTION_CATCH_PC
operator|&&
name|CURRENT_EXCEPTION_CATCH_LINE
condition|)
name|printf_filtered
argument_list|(
literal|"%s:%d"
argument_list|,
name|CURRENT_EXCEPTION_CATCH_FILE
argument_list|,
name|CURRENT_EXCEPTION_CATCH_LINE
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* don't bother to print location frame info */
return|return
name|PRINT_SRC_ONLY
return|;
block|}
else|else
block|{
comment|/* really catch, some other bpstat will handle it */
return|return
name|PRINT_UNKNOWN
return|;
block|}
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|annotate_watchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"watchpoint-trigger"
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nOld value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|old_val
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"old"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nNew value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"new"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* More than one watchpoint may have been triggered.  */
return|return
name|PRINT_UNKNOWN
return|;
break|break;
case|case
name|bp_read_watchpoint
case|:
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"read-watchpoint-trigger"
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nValue = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|PRINT_UNKNOWN
return|;
break|break;
case|case
name|bp_access_watchpoint
case|:
if|if
condition|(
name|bs
operator|->
name|old_val
operator|!=
name|NULL
condition|)
block|{
name|annotate_watchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"access-watchpoint-trigger"
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nOld value = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|bs
operator|->
name|old_val
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"old"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|bs
operator|->
name|old_val
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nNew value = "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mention
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"access-watchpoint-trigger"
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nValue = "
argument_list|)
expr_stmt|;
block|}
name|value_print
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|val
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"new"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|PRINT_UNKNOWN
return|;
break|break;
comment|/* Fall through, we don't deal with these types of breakpoints        here. */
case|case
name|bp_finish
case|:
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"function-finished"
argument_list|)
expr_stmt|;
return|return
name|PRINT_UNKNOWN
return|;
break|break;
case|case
name|bp_until
case|:
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"location-reached"
argument_list|)
expr_stmt|;
return|return
name|PRINT_UNKNOWN
return|;
break|break;
case|case
name|bp_none
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
default|default:
return|return
name|PRINT_UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Generic routine for printing messages indicating why we    stopped. The behavior of this function depends on the value    'print_it' in the bpstat structure.  Under some circumstances we    may decide not to print anything here and delegate the task to    normal_stop(). */
end_comment

begin_function
specifier|static
name|enum
name|print_stop_action
name|print_bp_stop_message
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
switch|switch
condition|(
name|bs
operator|->
name|print_it
condition|)
block|{
case|case
name|print_it_noop
case|:
comment|/* Nothing should be printed for this bpstat entry. */
return|return
name|PRINT_UNKNOWN
return|;
break|break;
case|case
name|print_it_done
case|:
comment|/* We still want to print the frame, but we already printed the          relevant messages. */
return|return
name|PRINT_SRC_AND_LOC
return|;
break|break;
case|case
name|print_it_normal
case|:
comment|/* Normal case.  Call the breakpoint's print_it method, or 	 print_it_typical.  */
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|!=
name|NULL
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|ops
operator|!=
name|NULL
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|ops
operator|->
name|print_it
operator|!=
name|NULL
condition|)
return|return
name|bs
operator|->
name|breakpoint_at
operator|->
name|ops
operator|->
name|print_it
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
return|;
else|else
return|return
name|print_it_typical
argument_list|(
name|bs
argument_list|)
return|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"print_bp_stop_message: unrecognized enum value"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print a message indicating what happened.  This is called from    normal_stop().  The input to this routine is the head of the bpstat    list - a list of the eventpoints that caused this stop.  This    routine calls the generic print routine for printing a message    about reasons for stopping.  This will print (for example) the    "Breakpoint n," part of the output.  The return value of this    routine is one of:     PRINT_UNKNOWN: Means we printed nothing    PRINT_SRC_AND_LOC: Means we printed something, and expect subsequent    code to print the location. An example is     "Breakpoint 1, " which should be followed by    the location.    PRINT_SRC_ONLY: Means we printed something, but there is no need    to also print the location part of the message.    An example is the catch/throw messages, which    don't require a location appended to the end.      PRINT_NOTHING: We have done some printing and we don't need any     further info to be printed.*/
end_comment

begin_function
name|enum
name|print_stop_action
name|bpstat_print
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
comment|/* Maybe another breakpoint in the chain caused us to stop.      (Currently all watchpoints go on the bpstat whether hit or not.      That probably could (should) be changed, provided care is taken      with respect to bpstat_explains_signal).  */
for|for
control|(
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|val
operator|=
name|print_bp_stop_message
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|PRINT_SRC_ONLY
operator|||
name|val
operator|==
name|PRINT_SRC_AND_LOC
operator|||
name|val
operator|==
name|PRINT_NOTHING
condition|)
return|return
name|val
return|;
block|}
comment|/* We reached the end of the chain, or we got a null BS to start      with and nothing was printed. */
return|return
name|PRINT_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the expression EXP and return 1 if value is zero.    This is used inside a catch_errors to evaluate the breakpoint condition.     The argument is a "struct expression *" that has been cast to char * to     make it pass through catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_cond_eval
parameter_list|(
name|void
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|!
name|value_true
argument_list|(
name|evaluate_expression
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new bpstat and chain it to the current one.  */
end_comment

begin_function
specifier|static
name|bpstat
name|bpstat_alloc
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|,
name|bpstat
name|cbs
comment|/* Current "bs" value */
parameter_list|)
block|{
name|bpstat
name|bs
decl_stmt|;
name|bs
operator|=
operator|(
name|bpstat
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|cbs
operator|->
name|next
operator|=
name|bs
expr_stmt|;
name|bs
operator|->
name|breakpoint_at
operator|=
name|b
expr_stmt|;
comment|/* If the condition is false, etc., don't do the commands.  */
name|bs
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|print_it
operator|=
name|print_it_normal
expr_stmt|;
return|return
name|bs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Possible return values for watchpoint_check (this can't be an enum    because of check_errors).  */
end_comment

begin_comment
comment|/* The watchpoint has been deleted.  */
end_comment

begin_define
define|#
directive|define
name|WP_DELETED
value|1
end_define

begin_comment
comment|/* The value has changed.  */
end_comment

begin_define
define|#
directive|define
name|WP_VALUE_CHANGED
value|2
end_define

begin_comment
comment|/* The value has not changed.  */
end_comment

begin_define
define|#
directive|define
name|WP_VALUE_NOT_CHANGED
value|3
end_define

begin_define
define|#
directive|define
name|BP_TEMPFLAG
value|1
end_define

begin_define
define|#
directive|define
name|BP_HARDWAREFLAG
value|2
end_define

begin_comment
comment|/* Check watchpoint condition.  */
end_comment

begin_function
specifier|static
name|int
name|watchpoint_check
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|bpstat
name|bs
init|=
operator|(
name|bpstat
operator|)
name|p
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fr
decl_stmt|;
name|int
name|within_current_scope
decl_stmt|;
name|b
operator|=
name|bs
operator|->
name|breakpoint_at
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|exp_valid_block
operator|==
name|NULL
condition|)
name|within_current_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* There is no current frame at this moment.  If we're going to have          any chance of handling watchpoints on local variables, we'll need          the frame chain (so we can determine if we're in scope).  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|fr
operator|=
name|frame_find_by_id
argument_list|(
name|b
operator|->
name|watchpoint_frame
argument_list|)
expr_stmt|;
name|within_current_scope
operator|=
operator|(
name|fr
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* in_function_epilogue_p() returns a non-zero value if we're still 	 in the function but the stack frame has already been invalidated. 	 Since we can't rely on the values of local variables after the 	 stack has been destroyed, we are treating the watchpoint in that 	 state as `not changed' without further checking. 	  	 vinschen/2003-09-04: The former implementation left out the case 	 that the watchpoint frame couldn't be found by frame_find_by_id() 	 because the current PC is currently in an epilogue.  Calling 	 gdbarch_in_function_epilogue_p() also when fr == NULL fixes that. */
if|if
condition|(
operator|(
operator|!
name|within_current_scope
operator|||
name|fr
operator|==
name|get_current_frame
argument_list|()
operator|)
operator|&&
name|gdbarch_in_function_epilogue_p
argument_list|(
name|current_gdbarch
argument_list|,
name|read_pc
argument_list|()
argument_list|)
condition|)
return|return
name|WP_VALUE_NOT_CHANGED
return|;
if|if
condition|(
name|fr
operator|&&
name|within_current_scope
condition|)
comment|/* If we end up stopping, the current frame will get selected 	   in normal_stop.  So this call to select_frame won't affect 	   the user.  */
name|select_frame
argument_list|(
name|fr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_current_scope
condition|)
block|{
comment|/* We use value_{,free_to_}mark because it could be a          *long* time before we return to the command level and          call free_all_values.  We can't call free_all_values because          we might be in the middle of evaluating a function call.  */
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|struct
name|value
modifier|*
name|new_val
init|=
name|evaluate_expression
argument_list|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value_equal
argument_list|(
name|b
operator|->
name|val
argument_list|,
name|new_val
argument_list|)
condition|)
block|{
name|release_value
argument_list|(
name|new_val
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|b
operator|->
name|val
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|new_val
expr_stmt|;
comment|/* We will stop here */
return|return
name|WP_VALUE_CHANGED
return|;
block|}
else|else
block|{
comment|/* Nothing changed, don't do anything.  */
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
comment|/* We won't stop here */
return|return
name|WP_VALUE_NOT_CHANGED
return|;
block|}
block|}
else|else
block|{
comment|/* This seems like the only logical thing to do because          if we temporarily ignored the watchpoint, then when          we reenter the block in which it is valid it contains          garbage (in the case of a function, it may have two          garbage values, one before and one after the prologue).          So we can't even detect the first assignment to it and          watch after that (since the garbage may or may not equal          the first value assigned).  */
comment|/* We print all the stop information in print_it_typical(), but 	 in this case, by the time we call print_it_typical() this bp 	 will be deleted already. So we have no choice but print the 	 information here. */
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"watchpoint-scope"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nWatchpoint "
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"wpnum"
argument_list|,
name|bs
operator|->
name|breakpoint_at
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" deleted because the program has left the block in\n\ which its expression is valid.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
return|return
name|WP_DELETED
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get a bpstat associated with having just stopped at address    BP_ADDR.  */
end_comment

begin_comment
comment|/* Determine whether we stopped at a breakpoint, etc, or whether we    don't understand this stop.  Result is a chain of bpstat's such that:     if we don't understand the stop, the result is a null pointer.     if we understand why we stopped, the result is not null.     Each element of the chain refers to a particular breakpoint or    watchpoint at which we have stopped.  (We may have stopped for    several reasons concurrently.)     Each element of the chain has valid next, breakpoint_at,    commands, FIXME??? fields.  */
end_comment

begin_function
name|bpstat
name|bpstat_stop_status
parameter_list|(
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* True if we've hit a breakpoint (as opposed to a watchpoint).  */
name|int
name|real_breakpoint
init|=
literal|0
decl_stmt|;
comment|/* Root of the chain of bpstat's */
name|struct
name|bpstats
name|root_bs
index|[
literal|1
index|]
decl_stmt|;
comment|/* Pointer to the last thing in the chain currently.  */
name|bpstat
name|bs
init|=
name|root_bs
decl_stmt|;
name|int
name|thread_id
init|=
name|pid_to_thread_id
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
operator|!
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
operator|&&
name|b
operator|->
name|enable_state
operator|!=
name|bp_permanent
condition|)
continue|continue;
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_catch_throw
condition|)
comment|/* a non-watchpoint bp */
block|{
if|if
condition|(
name|b
operator|->
name|loc
operator|->
name|address
operator|!=
name|bp_addr
condition|)
comment|/* address doesn't match */
continue|continue;
if|if
condition|(
name|overlay_debugging
comment|/* unmapped overlay section */
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|loc
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|b
operator|->
name|loc
operator|->
name|section
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|loc
operator|->
name|address
operator|!=
name|bp_addr
condition|)
continue|continue;
if|if
condition|(
name|overlay_debugging
comment|/* unmapped overlay section */
operator|&&
name|section_is_overlay
argument_list|(
name|b
operator|->
name|loc
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|b
operator|->
name|loc
operator|->
name|section
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Is this a catchpoint of a load or unload?  If so, did we        get a load or unload of the specified library?  If not,        ignore it. */
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_HAVE_LOAD_EVENT
argument_list|)
operator|&&
operator|(
operator|!
name|SOLIB_HAVE_LOAD_EVENT
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|b
operator|->
name|dll_pathname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|dll_pathname
argument_list|,
name|SOLIB_LOADED_LIBRARY_PATHNAME
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_unload
operator|)
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_HAVE_UNLOAD_EVENT
argument_list|)
operator|&&
operator|(
operator|!
name|SOLIB_HAVE_UNLOAD_EVENT
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|b
operator|->
name|dll_pathname
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|dll_pathname
argument_list|,
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
operator|&&
operator|!
name|inferior_has_forked
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|b
operator|->
name|forked_inferior_pid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|)
operator|&&
operator|!
name|inferior_has_vforked
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|b
operator|->
name|forked_inferior_pid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|)
operator|&&
operator|!
name|inferior_has_execd
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|b
operator|->
name|exec_pathname
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|&&
operator|!
operator|(
name|current_exception_event
operator|=
name|target_get_current_exception_event
argument_list|()
operator|)
condition|)
continue|continue;
comment|/* Come here if it's a watchpoint, or if the break address matches */
name|bs
operator|=
name|bpstat_alloc
argument_list|(
name|b
argument_list|,
name|bs
argument_list|)
expr_stmt|;
comment|/* Alloc a bpstat to explain stop */
comment|/* Watchpoints may change this, if not found to have triggered. */
name|bs
operator|->
name|stop
operator|=
literal|1
expr_stmt|;
name|bs
operator|->
name|print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
condition|)
block|{
name|char
modifier|*
name|message
init|=
name|xstrprintf
argument_list|(
literal|"Error evaluating expression for watchpoint %d\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|catch_errors
argument_list|(
name|watchpoint_check
argument_list|,
name|bs
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
decl_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|WP_DELETED
case|:
comment|/* We've already printed what needs to be printed.  */
comment|/* Actually this is superfluous, because by the time we                call print_it_typical() the wp will be already deleted,                and the function will return immediately. */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_CHANGED
case|:
comment|/* Stop.  */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
break|break;
case|case
name|WP_VALUE_NOT_CHANGED
case|:
comment|/* Don't stop.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
continue|continue;
default|default:
comment|/* Can't happen.  */
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* Error from catch_errors.  */
name|printf_filtered
argument_list|(
literal|"Watchpoint %d deleted.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|target_stopped_data_address
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|v
operator|=
name|b
operator|->
name|val_chain
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|==
name|lval_memory
operator|&&
operator|!
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|vtype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|b
operator|->
name|val_chain
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
condition|)
block|{
name|CORE_ADDR
name|vaddr
decl_stmt|;
name|vaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* Exact match not required.  Within range is                        sufficient.  */
if|if
condition|(
name|addr
operator|>=
name|vaddr
operator|&&
name|addr
operator|<
name|vaddr
operator|+
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|char
modifier|*
name|message
init|=
name|xstrprintf
argument_list|(
literal|"Error evaluating expression for watchpoint %d\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|catch_errors
argument_list|(
name|watchpoint_check
argument_list|,
name|bs
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
decl_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|WP_DELETED
case|:
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
comment|/* Stop.  */
break|break;
case|case
name|WP_VALUE_CHANGED
case|:
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
condition|)
block|{
comment|/* Don't stop: read watchpoints shouldn't fire if 		       the value has changed.  This is for targets 		       which cannot set read-only watchpoints.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
break|break;
case|case
name|WP_VALUE_NOT_CHANGED
case|:
comment|/* Stop.  */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Can't happen.  */
case|case
literal|0
case|:
comment|/* Error from catch_errors.  */
name|printf_filtered
argument_list|(
literal|"Watchpoint %d deleted.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|related_breakpoint
condition|)
name|b
operator|->
name|related_breakpoint
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disp_del_at_next_stop
expr_stmt|;
comment|/* We've already printed what needs to be printed.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_done
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* found == 0 */
block|{
comment|/* This is a case where some watchpoint(s) triggered, 	       but not at the address of this watchpoint (FOUND 	       was left zero).  So don't print anything for this 	       watchpoint.  */
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* By definition, an encountered breakpoint is a triggered 	   breakpoint. */
operator|++
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
name|real_breakpoint
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|frame_id_p
argument_list|(
name|b
operator|->
name|frame_id
argument_list|)
operator|&&
operator|!
name|frame_id_eq
argument_list|(
name|b
operator|->
name|frame_id
argument_list|,
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
condition|)
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|value_is_zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
comment|/* Need to select the frame, with all that implies 	       so that the conditions will have the right context.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|value_is_zero
operator|=
name|catch_errors
argument_list|(
name|breakpoint_cond_eval
argument_list|,
operator|(
name|b
operator|->
name|cond
operator|)
argument_list|,
literal|"Error in testing breakpoint condition:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* FIXME-someday, should give breakpoint # */
name|free_all_values
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
operator|&&
name|value_is_zero
condition|)
block|{
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
comment|/* Don't consider this a hit.  */
operator|--
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
operator|&&
name|b
operator|->
name|thread
operator|!=
name|thread_id
condition|)
block|{
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
comment|/* Don't consider this a hit.  */
operator|--
operator|(
name|b
operator|->
name|hit_count
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|ignore_count
operator|>
literal|0
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|--
expr_stmt|;
name|annotate_ignore_count_change
argument_list|()
expr_stmt|;
name|bs
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We will stop here */
if|if
condition|(
name|b
operator|->
name|disposition
operator|==
name|disp_disable
condition|)
name|b
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|silent
condition|)
name|bs
operator|->
name|print
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|commands
operator|=
name|b
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|commands
operator|&&
operator|(
name|strcmp
argument_list|(
literal|"silent"
argument_list|,
name|bs
operator|->
name|commands
operator|->
name|line
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|xdb_commands
operator|&&
name|strcmp
argument_list|(
literal|"Q"
argument_list|,
name|bs
operator|->
name|commands
operator|->
name|line
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|bs
operator|->
name|commands
operator|=
name|bs
operator|->
name|commands
operator|->
name|next
expr_stmt|;
name|bs
operator|->
name|print
operator|=
literal|0
expr_stmt|;
block|}
name|bs
operator|->
name|commands
operator|=
name|copy_command_lines
argument_list|(
name|bs
operator|->
name|commands
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print nothing for this entry if we dont stop or if we dont print.  */
if|if
condition|(
name|bs
operator|->
name|stop
operator|==
literal|0
operator|||
name|bs
operator|->
name|print
operator|==
literal|0
condition|)
name|bs
operator|->
name|print_it
operator|=
name|print_it_noop
expr_stmt|;
block|}
name|bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Terminate the chain */
name|bs
operator|=
name|root_bs
operator|->
name|next
expr_stmt|;
comment|/* Re-grab the head of the chain */
comment|/* The value of a hardware watchpoint hasn't changed, but the      intermediate memory locations we are watching may have.  */
if|if
condition|(
name|bs
operator|&&
operator|!
name|bs
operator|->
name|stop
operator|&&
operator|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
condition|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
return|return
name|bs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell what to do about this bpstat.  */
end_comment

begin_function
name|struct
name|bpstat_what
name|bpstat_what
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
comment|/* Classify each bpstat as one of the following.  */
enum|enum
name|class
block|{
comment|/* This bpstat element has no effect on the main_action.  */
name|no_effect
init|=
literal|0
block|,
comment|/* There was a watchpoint, stop but don't print.  */
name|wp_silent
block|,
comment|/* There was a watchpoint, stop and print.  */
name|wp_noisy
block|,
comment|/* There was a breakpoint but we're not stopping.  */
name|bp_nostop
block|,
comment|/* There was a breakpoint, stop but don't print.  */
name|bp_silent
block|,
comment|/* There was a breakpoint, stop and print.  */
name|bp_noisy
block|,
comment|/* We hit the longjmp breakpoint.  */
name|long_jump
block|,
comment|/* We hit the longjmp_resume breakpoint.  */
name|long_resume
block|,
comment|/* We hit the step_resume breakpoint.  */
name|step_resume
block|,
comment|/* We hit the through_sigtramp breakpoint.  */
name|through_sig
block|,
comment|/* We hit the shared library event breakpoint.  */
name|shlib_event
block|,
comment|/* We caught a shared library event.  */
name|catch_shlib_event
block|,
comment|/* This is just used to count how many enums there are.  */
name|class_last
block|}
enum|;
comment|/* Here is the table which drives this routine.  So that we can      format it pretty, we define some abbreviations for the      enum bpstat_what codes.  */
define|#
directive|define
name|kc
value|BPSTAT_WHAT_KEEP_CHECKING
define|#
directive|define
name|ss
value|BPSTAT_WHAT_STOP_SILENT
define|#
directive|define
name|sn
value|BPSTAT_WHAT_STOP_NOISY
define|#
directive|define
name|sgl
value|BPSTAT_WHAT_SINGLE
define|#
directive|define
name|slr
value|BPSTAT_WHAT_SET_LONGJMP_RESUME
define|#
directive|define
name|clr
value|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
define|#
directive|define
name|clrs
value|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
define|#
directive|define
name|sr
value|BPSTAT_WHAT_STEP_RESUME
define|#
directive|define
name|ts
value|BPSTAT_WHAT_THROUGH_SIGTRAMP
define|#
directive|define
name|shl
value|BPSTAT_WHAT_CHECK_SHLIBS
define|#
directive|define
name|shlr
value|BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
comment|/* "Can't happen."  Might want to print an error message.    abort() is not out of the question, but chances are GDB is just    a bit confused, not unusable.  */
define|#
directive|define
name|err
value|BPSTAT_WHAT_STOP_NOISY
comment|/* Given an old action and a class, come up with a new action.  */
comment|/* One interesting property of this table is that wp_silent is the same      as bp_silent and wp_noisy is the same as bp_noisy.  That is because      after stopping, the check for whether to step over a breakpoint      (BPSTAT_WHAT_SINGLE type stuff) is handled in proceed() without      reference to how we stopped.  We retain separate wp_silent and      bp_silent codes in case we want to change that someday.        Another possibly interesting property of this table is that      there's a partial ordering, priority-like, of the actions.  Once      you've decided that some action is appropriate, you'll never go      back and decide something of a lower priority is better.  The      ordering is:       kc< clr sgl shl shlr slr sn sr ss ts      sgl< clrs shl shlr slr sn sr ss ts      slr< err shl shlr sn sr ss ts      clr< clrs err shl shlr sn sr ss ts      clrs< err shl shlr sn sr ss ts      ss< shl shlr sn sr ts      sn< shl shlr sr ts      sr< shl shlr ts      shl< shlr      ts<       shlr<       What I think this means is that we don't need a damned table      here.  If you just put the rows and columns in the right order,      it'd look awfully regular.  We could simply walk the bpstat list      and choose the highest priority action we find, with a little      logic to handle the 'err' cases, and the CLEAR_LONGJMP_RESUME/      CLEAR_LONGJMP_RESUME_SINGLE distinction (which breakpoint.h says      is messy anyway).  */
comment|/* step_resume entries: a step resume breakpoint overrides another      breakpoint of signal handling (see comment in wait_for_inferior      at first PC_IN_SIGTRAMP where we set the step_resume breakpoint).  */
comment|/* We handle the through_sigtramp_breakpoint the same way; having both      one of those and a step_resume_breakpoint is probably very rare (?).  */
specifier|static
specifier|const
name|enum
name|bpstat_what_main_action
name|table
index|[
operator|(
name|int
operator|)
name|class_last
index|]
index|[
operator|(
name|int
operator|)
name|BPSTAT_WHAT_LAST
index|]
init|=
block|{
comment|/*                              old action */
comment|/*       kc    ss    sn    sgl    slr   clr    clrs   sr    ts   shl   shlr    */
comment|/*no_effect */
block|{
name|kc
block|,
name|ss
block|,
name|sn
block|,
name|sgl
block|,
name|slr
block|,
name|clr
block|,
name|clrs
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*wp_silent */
block|{
name|ss
block|,
name|ss
block|,
name|sn
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*wp_noisy */
block|{
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*bp_nostop */
block|{
name|sgl
block|,
name|ss
block|,
name|sn
block|,
name|sgl
block|,
name|slr
block|,
name|clrs
block|,
name|clrs
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*bp_silent */
block|{
name|ss
block|,
name|ss
block|,
name|sn
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|ss
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*bp_noisy */
block|{
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sn
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*long_jump */
block|{
name|slr
block|,
name|ss
block|,
name|sn
block|,
name|slr
block|,
name|slr
block|,
name|err
block|,
name|err
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*long_resume */
block|{
name|clr
block|,
name|ss
block|,
name|sn
block|,
name|clrs
block|,
name|err
block|,
name|err
block|,
name|err
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*step_resume */
block|{
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|sr
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*through_sig */
block|{
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*shlib */
block|{
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|shl
block|,
name|ts
block|,
name|shl
block|,
name|shlr
block|}
block|,
comment|/*catch_shlib */
block|{
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|shlr
block|,
name|ts
block|,
name|shlr
block|,
name|shlr
block|}
block|}
decl_stmt|;
undef|#
directive|undef
name|kc
undef|#
directive|undef
name|ss
undef|#
directive|undef
name|sn
undef|#
directive|undef
name|sgl
undef|#
directive|undef
name|slr
undef|#
directive|undef
name|clr
undef|#
directive|undef
name|clrs
undef|#
directive|undef
name|err
undef|#
directive|undef
name|sr
undef|#
directive|undef
name|ts
undef|#
directive|undef
name|shl
undef|#
directive|undef
name|shlr
name|enum
name|bpstat_what_main_action
name|current_action
init|=
name|BPSTAT_WHAT_KEEP_CHECKING
decl_stmt|;
name|struct
name|bpstat_what
name|retval
decl_stmt|;
name|retval
operator|.
name|call_dummy
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
name|enum
name|class
name|bs_class
init|=
name|no_effect
decl_stmt|;
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|NULL
condition|)
comment|/* I suspect this can happen if it was a momentary breakpoint 	   which has since been deleted.  */
continue|continue;
switch|switch
condition|(
name|bs
operator|->
name|breakpoint_at
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
continue|continue;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|bp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
block|}
else|else
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|wp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|wp_silent
expr_stmt|;
block|}
else|else
comment|/* There was a watchpoint, but we're not stopping.  	       This requires no further action.  */
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_longjmp
case|:
name|bs_class
operator|=
name|long_jump
expr_stmt|;
break|break;
case|case
name|bp_longjmp_resume
case|:
name|bs_class
operator|=
name|long_resume
expr_stmt|;
break|break;
case|case
name|bp_step_resume
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
name|bs_class
operator|=
name|step_resume
expr_stmt|;
block|}
else|else
comment|/* It is for the wrong frame.  */
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_through_sigtramp
case|:
name|bs_class
operator|=
name|through_sig
expr_stmt|;
break|break;
case|case
name|bp_watchpoint_scope
case|:
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_shlib_event
case|:
name|bs_class
operator|=
name|shlib_event
expr_stmt|;
break|break;
case|case
name|bp_thread_event
case|:
case|case
name|bp_overlay_event
case|:
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
break|break;
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
comment|/* Only if this catchpoint triggered should we cause the 	     step-out-of-dld behaviour.  Otherwise, we ignore this 	     catchpoint.  */
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
name|bs_class
operator|=
name|catch_shlib_event
expr_stmt|;
else|else
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|print
condition|)
name|bs_class
operator|=
name|bp_noisy
expr_stmt|;
else|else
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
block|}
else|else
comment|/* There was a catchpoint, but we're not stopping.   	       This requires no further action.  */
name|bs_class
operator|=
name|no_effect
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
if|if
condition|(
operator|!
name|bs
operator|->
name|stop
operator|||
name|CURRENT_EXCEPTION_KIND
operator|!=
name|EX_EVENT_CATCH
condition|)
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
name|bs_class
operator|=
name|bs
operator|->
name|print
condition|?
name|bp_noisy
else|:
name|bp_silent
expr_stmt|;
break|break;
case|case
name|bp_catch_throw
case|:
if|if
condition|(
operator|!
name|bs
operator|->
name|stop
operator|||
name|CURRENT_EXCEPTION_KIND
operator|!=
name|EX_EVENT_THROW
condition|)
name|bs_class
operator|=
name|bp_nostop
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|->
name|stop
condition|)
name|bs_class
operator|=
name|bs
operator|->
name|print
condition|?
name|bp_noisy
else|:
name|bp_silent
expr_stmt|;
break|break;
case|case
name|bp_call_dummy
case|:
comment|/* Make sure the action is stop (silent or noisy), 	     so infrun.c pops the dummy frame.  */
name|bs_class
operator|=
name|bp_silent
expr_stmt|;
name|retval
operator|.
name|call_dummy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|current_action
operator|=
name|table
index|[
operator|(
name|int
operator|)
name|bs_class
index|]
index|[
operator|(
name|int
operator|)
name|current_action
index|]
expr_stmt|;
block|}
name|retval
operator|.
name|main_action
operator|=
name|current_action
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we should step constantly (e.g. watchpoints on machines    without hardware support).  This isn't related to a specific bpstat,    just to things like whether watchpoints are set.  */
end_comment

begin_function
name|int
name|bpstat_should_step
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
operator|&&
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if there are enabled hardware watchpoints. */
end_comment

begin_function
name|int
name|bpstat_have_active_hw_watchpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|bpt
decl_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|bpt
argument_list|)
if|if
condition|(
name|breakpoint_enabled
argument_list|(
name|bpt
operator|->
name|owner
argument_list|)
operator|&&
name|bpt
operator|->
name|inserted
operator|&&
name|bpt
operator|->
name|loc_type
operator|==
name|bp_loc_hardware_watchpoint
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a bpstat that records zero or more triggered eventpoints, this    function returns another bpstat which contains only the catchpoints    on that first list, if any. */
end_comment

begin_function
name|void
name|bpstat_get_triggered_catchpoints
parameter_list|(
name|bpstat
name|ep_list
parameter_list|,
name|bpstat
modifier|*
name|cp_list
parameter_list|)
block|{
name|struct
name|bpstats
name|root_bs
index|[
literal|1
index|]
decl_stmt|;
name|bpstat
name|bs
init|=
name|root_bs
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|dll_pathname
decl_stmt|;
name|bpstat_clear
argument_list|(
name|cp_list
argument_list|)
expr_stmt|;
name|root_bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|ep_list
operator|!=
name|NULL
condition|;
name|ep_list
operator|=
name|ep_list
operator|->
name|next
control|)
block|{
comment|/* Is this eventpoint a catchpoint?  If not, ignore it. */
name|ep
operator|=
name|ep_list
operator|->
name|breakpoint_at
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_load
operator|)
operator|&&
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_unload
operator|)
operator|&&
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_catch
operator|)
operator|&&
operator|(
name|ep
operator|->
name|type
operator|!=
name|bp_catch_throw
operator|)
condition|)
comment|/* pai: (temp) ADD fork/vfork here!!  */
continue|continue;
comment|/* Yes; add it to the list. */
name|bs
operator|=
name|bpstat_alloc
argument_list|(
name|ep
argument_list|,
name|bs
argument_list|)
expr_stmt|;
operator|*
name|bs
operator|=
operator|*
name|ep_list
expr_stmt|;
name|bs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bs
operator|=
name|root_bs
operator|->
name|next
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
comment|/* Also, for each triggered catchpoint, tag it with the name of          the library that caused this trigger.  (We copy the name now,          because it's only guaranteed to be available NOW, when the          catchpoint triggers.  Clients who may wish to know the name          later must get it from the catchpoint itself.) */
if|if
condition|(
name|ep
operator|->
name|triggered_dll_pathname
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|ep
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|type
operator|==
name|bp_catch_load
condition|)
name|dll_pathname
operator|=
name|SOLIB_LOADED_LIBRARY_PATHNAME
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dll_pathname
operator|=
name|SOLIB_UNLOADED_LIBRARY_PATHNAME
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|dll_pathname
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dll_pathname
condition|)
block|{
name|ep
operator|->
name|triggered_dll_pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dll_pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ep
operator|->
name|triggered_dll_pathname
argument_list|,
name|dll_pathname
argument_list|)
expr_stmt|;
block|}
else|else
name|ep
operator|->
name|triggered_dll_pathname
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|cp_list
operator|=
name|bs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print B to gdb_stdout. */
end_comment

begin_function
specifier|static
name|void
name|print_one_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|,
name|CORE_ADDR
modifier|*
name|last_addr
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
struct|struct
name|ep_type_description
block|{
name|enum
name|bptype
name|type
decl_stmt|;
name|char
modifier|*
name|description
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|ep_type_description
name|bptypes
index|[]
init|=
block|{
block|{
name|bp_none
block|,
literal|"?deleted?"
block|}
block|,
block|{
name|bp_breakpoint
block|,
literal|"breakpoint"
block|}
block|,
block|{
name|bp_hardware_breakpoint
block|,
literal|"hw breakpoint"
block|}
block|,
block|{
name|bp_until
block|,
literal|"until"
block|}
block|,
block|{
name|bp_finish
block|,
literal|"finish"
block|}
block|,
block|{
name|bp_watchpoint
block|,
literal|"watchpoint"
block|}
block|,
block|{
name|bp_hardware_watchpoint
block|,
literal|"hw watchpoint"
block|}
block|,
block|{
name|bp_read_watchpoint
block|,
literal|"read watchpoint"
block|}
block|,
block|{
name|bp_access_watchpoint
block|,
literal|"acc watchpoint"
block|}
block|,
block|{
name|bp_longjmp
block|,
literal|"longjmp"
block|}
block|,
block|{
name|bp_longjmp_resume
block|,
literal|"longjmp resume"
block|}
block|,
block|{
name|bp_step_resume
block|,
literal|"step resume"
block|}
block|,
block|{
name|bp_through_sigtramp
block|,
literal|"sigtramp"
block|}
block|,
block|{
name|bp_watchpoint_scope
block|,
literal|"watchpoint scope"
block|}
block|,
block|{
name|bp_call_dummy
block|,
literal|"call dummy"
block|}
block|,
block|{
name|bp_shlib_event
block|,
literal|"shlib events"
block|}
block|,
block|{
name|bp_thread_event
block|,
literal|"thread events"
block|}
block|,
block|{
name|bp_overlay_event
block|,
literal|"overlay events"
block|}
block|,
block|{
name|bp_catch_load
block|,
literal|"catch load"
block|}
block|,
block|{
name|bp_catch_unload
block|,
literal|"catch unload"
block|}
block|,
block|{
name|bp_catch_fork
block|,
literal|"catch fork"
block|}
block|,
block|{
name|bp_catch_vfork
block|,
literal|"catch vfork"
block|}
block|,
block|{
name|bp_catch_exec
block|,
literal|"catch exec"
block|}
block|,
block|{
name|bp_catch_catch
block|,
literal|"catch catch"
block|}
block|,
block|{
name|bp_catch_throw
block|,
literal|"catch throw"
block|}
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bpdisps
index|[]
init|=
block|{
literal|"del"
block|,
literal|"dstp"
block|,
literal|"dis"
block|,
literal|"keep"
block|}
decl_stmt|;
specifier|static
name|char
name|bpenables
index|[]
init|=
literal|"nynny"
decl_stmt|;
name|char
name|wrap_indent
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|bkpt_chain
decl_stmt|;
name|annotate_record
argument_list|()
expr_stmt|;
name|bkpt_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"bkpt"
argument_list|)
expr_stmt|;
comment|/* 1 */
name|annotate_field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
comment|/* 2 */
name|annotate_field
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|b
operator|->
name|type
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|bptypes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bptypes
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|b
operator|->
name|type
operator|!=
name|bptypes
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|type
index|]
operator|.
name|type
operator|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bptypes table does not describe type #%d."
argument_list|,
operator|(
name|int
operator|)
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"type"
argument_list|,
name|bptypes
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|type
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
comment|/* 3 */
name|annotate_field
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"disp"
argument_list|,
name|bpdisps
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|disposition
index|]
argument_list|)
expr_stmt|;
comment|/* 4 */
name|annotate_field
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"enabled"
argument_list|,
literal|"%c"
argument_list|,
name|bpenables
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|enable_state
index|]
argument_list|)
expr_stmt|;
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 5 and 6 */
name|strcpy
argument_list|(
name|wrap_indent
argument_list|,
literal|"                           "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"           "
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"                   "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|ops
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|ops
operator|->
name|print_one
operator|!=
name|NULL
condition|)
name|b
operator|->
name|ops
operator|->
name|print_one
argument_list|(
name|b
argument_list|,
name|last_addr
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"print_one_breakpoint: bp_none encountered\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	   not line up too nicely with the headers, but the effect 	   is relatively readable).  */
if|if
condition|(
name|addressprint
condition|)
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	   not line up too nicely with the headers, but the effect 	   is relatively readable).  */
if|if
condition|(
name|addressprint
condition|)
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dll_pathname
operator|==
name|NULL
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
literal|"<any library>"
argument_list|)
expr_stmt|;
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"library \""
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
name|b
operator|->
name|dll_pathname
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	   not line up too nicely with the headers, but the effect 	   is relatively readable).  */
if|if
condition|(
name|addressprint
condition|)
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|forked_inferior_pid
operator|!=
literal|0
condition|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"process "
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
name|b
operator|->
name|forked_inferior_pid
argument_list|)
expr_stmt|;
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
name|bp_catch_exec
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	   not line up too nicely with the headers, but the effect 	   is relatively readable).  */
if|if
condition|(
name|addressprint
condition|)
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|exec_pathname
operator|!=
name|NULL
condition|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"program \""
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
name|b
operator|->
name|exec_pathname
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bp_catch_catch
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	   not line up too nicely with the headers, but the effect 	   is relatively readable).  */
if|if
condition|(
name|addressprint
condition|)
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
literal|"exception catch"
argument_list|)
expr_stmt|;
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_throw
case|:
comment|/* Field 4, the address, is omitted (which makes the columns 	   not line up too nicely with the headers, but the effect 	   is relatively readable).  */
if|if
condition|(
name|addressprint
condition|)
name|ui_out_field_skip
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
literal|"exception throw"
argument_list|)
expr_stmt|;
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_shlib_event
case|:
case|case
name|bp_thread_event
case|:
case|case
name|bp_overlay_event
case|:
if|if
condition|(
name|addressprint
condition|)
block|{
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|pending
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
literal|"<PENDING>"
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|last_addr
operator|=
name|b
operator|->
name|loc
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|source_file
condition|)
block|{
name|sym
operator|=
name|find_pc_sect_function
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
name|b
operator|->
name|loc
operator|->
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"in "
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"func"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_wrap_hint
argument_list|(
name|uiout
argument_list|,
name|wrap_indent
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" at "
argument_list|)
expr_stmt|;
block|}
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"file"
argument_list|,
name|b
operator|->
name|source_file
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"line"
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|pending
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"pending"
argument_list|,
name|b
operator|->
name|addr_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_address_symbolic
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
name|demangle
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"at"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* FIXME: This seems to be redundant and lost here; see the 	 "stop only in" line a little further down. */
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" thread "
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"thread"
argument_list|,
name|b
operator|->
name|thread
argument_list|)
expr_stmt|;
block|}
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_id_p
argument_list|(
name|b
operator|->
name|frame_id
argument_list|)
condition|)
block|{
name|annotate_field
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tstop only in stack frame at "
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2002-12-01: Shouldn't be poeking around inside          the frame ID.  */
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"frame"
argument_list|,
name|b
operator|->
name|frame_id
operator|.
name|stack_addr
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|annotate_field
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tstop only if "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|cond
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"cond"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|pending
operator|&&
name|b
operator|->
name|cond_string
condition|)
block|{
name|annotate_field
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tstop only if "
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"cond"
argument_list|,
name|b
operator|->
name|cond_string
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* FIXME should make an annotation for this */
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tstop only in thread "
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"thread"
argument_list|,
name|b
operator|->
name|thread
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_breakpoint_hit_counts
operator|&&
name|b
operator|->
name|hit_count
condition|)
block|{
comment|/* FIXME should make an annotation for this */
if|if
condition|(
name|ep_is_catchpoint
argument_list|(
name|b
argument_list|)
condition|)
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tcatchpoint"
argument_list|)
expr_stmt|;
else|else
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tbreakpoint"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" already hit "
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"times"
argument_list|,
name|b
operator|->
name|hit_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|hit_count
operator|==
literal|1
condition|)
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" time\n"
argument_list|)
expr_stmt|;
else|else
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" times\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output the count also if it is zero, but only if this is      mi. FIXME: Should have a better test for this. */
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
if|if
condition|(
name|show_breakpoint_hit_counts
operator|&&
name|b
operator|->
name|hit_count
operator|==
literal|0
condition|)
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"times"
argument_list|,
name|b
operator|->
name|hit_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ignore_count
condition|)
block|{
name|annotate_field
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tignore next "
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"ignore"
argument_list|,
name|b
operator|->
name|ignore_count
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" hits\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l
operator|=
name|b
operator|->
name|commands
operator|)
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|script_chain
decl_stmt|;
name|annotate_field
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|script_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"script"
argument_list|)
expr_stmt|;
name|print_command_lines
argument_list|(
name|uiout
argument_list|,
name|l
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|script_chain
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|bkpt_chain
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|captured_breakpoint_query_args
block|{
name|int
name|bnum
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|do_captured_breakpoint_query
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_breakpoint_query_args
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|CORE_ADDR
name|dummy_addr
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|args
operator|->
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
name|print_one_breakpoint
argument_list|(
name|b
argument_list|,
operator|&
name|dummy_addr
argument_list|)
expr_stmt|;
return|return
name|GDB_RC_OK
return|;
block|}
block|}
return|return
name|GDB_RC_NONE
return|;
block|}
end_function

begin_function
name|enum
name|gdb_rc
name|gdb_breakpoint_query
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|int
name|bnum
parameter_list|)
block|{
name|struct
name|captured_breakpoint_query_args
name|args
decl_stmt|;
name|args
operator|.
name|bnum
operator|=
name|bnum
expr_stmt|;
comment|/* For the moment we don't trust print_one_breakpoint() to not throw      an error. */
return|return
name|catch_exceptions
argument_list|(
name|uiout
argument_list|,
name|do_captured_breakpoint_query
argument_list|,
operator|&
name|args
argument_list|,
name|NULL
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if B is user settable (breakpoints, watchpoints,    catchpoints, et.al.). */
end_comment

begin_function
specifier|static
name|int
name|user_settable_breakpoint
parameter_list|(
specifier|const
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|b
operator|->
name|type
operator|==
name|bp_breakpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_load
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_unload
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_vfork
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_exec
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
operator|||
name|b
operator|->
name|type
operator|==
name|bp_catch_throw
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print information on user settable breakpoint (watchpoint, etc)    number BNUM.  If BNUM is -1 print all user settable breakpoints.    If ALLFLAG is non-zero, include non- user settable breakpoints. */
end_comment

begin_function
specifier|static
name|void
name|breakpoint_1
parameter_list|(
name|int
name|bnum
parameter_list|,
name|int
name|allflag
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|nr_printable_breakpoints
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|bkpttbl_chain
decl_stmt|;
comment|/* Compute the number of rows in the table. */
name|nr_printable_breakpoints
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
operator|||
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
if|if
condition|(
name|allflag
operator|||
name|user_settable_breakpoint
argument_list|(
name|b
argument_list|)
condition|)
name|nr_printable_breakpoints
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|addressprint
condition|)
name|bkpttbl_chain
operator|=
name|make_cleanup_ui_out_table_begin_end
argument_list|(
name|uiout
argument_list|,
literal|6
argument_list|,
name|nr_printable_breakpoints
argument_list|,
literal|"BreakpointTable"
argument_list|)
expr_stmt|;
else|else
name|bkpttbl_chain
operator|=
name|make_cleanup_ui_out_table_begin_end
argument_list|(
name|uiout
argument_list|,
literal|5
argument_list|,
name|nr_printable_breakpoints
argument_list|,
literal|"BreakpointTable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_breakpoints_headers
argument_list|()
expr_stmt|;
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|3
argument_list|,
name|ui_left
argument_list|,
literal|"number"
argument_list|,
literal|"Num"
argument_list|)
expr_stmt|;
comment|/* 1 */
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_field
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|14
argument_list|,
name|ui_left
argument_list|,
literal|"type"
argument_list|,
literal|"Type"
argument_list|)
expr_stmt|;
comment|/* 2 */
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_field
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|4
argument_list|,
name|ui_left
argument_list|,
literal|"disp"
argument_list|,
literal|"Disp"
argument_list|)
expr_stmt|;
comment|/* 3 */
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_field
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|3
argument_list|,
name|ui_left
argument_list|,
literal|"enabled"
argument_list|,
literal|"Enb"
argument_list|)
expr_stmt|;
comment|/* 4 */
if|if
condition|(
name|addressprint
condition|)
block|{
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|10
argument_list|,
name|ui_left
argument_list|,
literal|"addr"
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
comment|/* 5 */
else|else
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|18
argument_list|,
name|ui_left
argument_list|,
literal|"addr"
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
comment|/* 5 */
block|}
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ui_out_table_header
argument_list|(
name|uiout
argument_list|,
literal|40
argument_list|,
name|ui_noalign
argument_list|,
literal|"what"
argument_list|,
literal|"What"
argument_list|)
expr_stmt|;
comment|/* 6 */
name|ui_out_table_body
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_printable_breakpoints
operator|>
literal|0
condition|)
name|annotate_breakpoints_table
argument_list|()
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
operator|||
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
comment|/* We only print out user settable breakpoints unless the 	   allflag is set. */
if|if
condition|(
name|allflag
operator|||
name|user_settable_breakpoint
argument_list|(
name|b
argument_list|)
condition|)
name|print_one_breakpoint
argument_list|(
name|b
argument_list|,
operator|&
name|last_addr
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|bkpttbl_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_printable_breakpoints
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
condition|)
name|ui_out_message
argument_list|(
name|uiout
argument_list|,
literal|0
argument_list|,
literal|"No breakpoints or watchpoints.\n"
argument_list|)
expr_stmt|;
else|else
name|ui_out_message
argument_list|(
name|uiout
argument_list|,
literal|0
argument_list|,
literal|"No breakpoint or watchpoint number %d.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compare against (CORE_ADDR)-1 in case some compiler decides 	 that a comparison of an unsigned with -1 is always false.  */
if|if
condition|(
name|last_addr
operator|!=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|set_next_address
argument_list|(
name|last_addr
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME? Should this be moved up so that it is only called when      there have been breakpoints? */
name|annotate_breakpoints_table_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|breakpoints_info
parameter_list|(
name|char
modifier|*
name|bnum_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_long
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_info_breakpoints
parameter_list|(
name|char
modifier|*
name|bnum_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_long
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message describing any breakpoints set at PC.  */
end_comment

begin_function
specifier|static
name|void
name|describe_other_breakpoints
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|int
name|others
init|=
literal|0
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|loc
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* address match / overlay match */
if|if
condition|(
operator|!
name|b
operator|->
name|pending
operator|&&
operator|(
operator|!
name|overlay_debugging
operator|||
name|b
operator|->
name|loc
operator|->
name|section
operator|==
name|section
operator|)
condition|)
name|others
operator|++
expr_stmt|;
if|if
condition|(
name|others
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Note: breakpoint%s "
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|loc
operator|->
name|address
operator|==
name|pc
condition|)
comment|/* address match / overlay match */
if|if
condition|(
operator|!
name|b
operator|->
name|pending
operator|&&
operator|(
operator|!
name|overlay_debugging
operator|||
name|b
operator|->
name|loc
operator|->
name|section
operator|==
name|section
operator|)
condition|)
block|{
name|others
operator|--
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d%s%s "
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
operator|(
name|b
operator|->
name|enable_state
operator|==
name|bp_disabled
operator|||
name|b
operator|->
name|enable_state
operator|==
name|bp_shlib_disabled
operator|||
name|b
operator|->
name|enable_state
operator|==
name|bp_call_disabled
operator|)
condition|?
literal|" (disabled)"
else|:
name|b
operator|->
name|enable_state
operator|==
name|bp_permanent
condition|?
literal|" (permanent)"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|","
else|:
operator|(
operator|(
name|others
operator|==
literal|1
operator|)
condition|?
literal|" and"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"also set at pc "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the default place to put a breakpoint    for the `break' command with no arguments.  */
end_comment

begin_function
name|void
name|set_default_breakpoint
parameter_list|(
name|int
name|valid
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|default_breakpoint_valid
operator|=
name|valid
expr_stmt|;
name|default_breakpoint_address
operator|=
name|addr
expr_stmt|;
name|default_breakpoint_symtab
operator|=
name|symtab
expr_stmt|;
name|default_breakpoint_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true iff it is meaningful to use the address member of    BPT.  For some breakpoint types, the address member is irrelevant    and it makes no sense to attempt to compare it to other addresses    (or use it for any other purpose either).     More specifically, each of the following breakpoint types will always    have a zero valued address and we don't want check_duplicates() to mark    breakpoints of any of these types to be a duplicate of an actual    breakpoint at address zero:        bp_watchpoint       bp_hardware_watchpoint       bp_read_watchpoint       bp_access_watchpoint       bp_catch_exec       bp_longjmp_resume       bp_catch_fork       bp_catch_vork */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_address_is_meaningful
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
name|enum
name|bptype
name|type
init|=
name|bpt
operator|->
name|type
decl_stmt|;
return|return
operator|(
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|type
operator|!=
name|bp_catch_exec
operator|&&
name|type
operator|!=
name|bp_longjmp_resume
operator|&&
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|type
operator|!=
name|bp_catch_vfork
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Rescan breakpoints at the same address and section as BPT,    marking the first one as "first" and any others as "duplicates".    This is so that the bpt instruction is only inserted once.    If we have a permanent breakpoint at the same place as BPT, make    that one the official one, and the rest as duplicates.  */
end_comment

begin_function
specifier|static
name|void
name|check_duplicates
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|b
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|bp_location
modifier|*
name|perm_bp
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|address
init|=
name|bpt
operator|->
name|loc
operator|->
name|address
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|bpt
operator|->
name|loc
operator|->
name|section
decl_stmt|;
if|if
condition|(
operator|!
name|breakpoint_address_is_meaningful
argument_list|(
name|bpt
argument_list|)
condition|)
return|return;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|!=
name|bp_disabled
operator|&&
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|!=
name|bp_shlib_disabled
operator|&&
operator|!
name|b
operator|->
name|owner
operator|->
name|pending
operator|&&
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|!=
name|bp_call_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|address
comment|/* address / overlay match */
operator|&&
operator|(
operator|!
name|overlay_debugging
operator|||
name|b
operator|->
name|section
operator|==
name|section
operator|)
operator|&&
name|breakpoint_address_is_meaningful
argument_list|(
name|b
operator|->
name|owner
argument_list|)
condition|)
block|{
comment|/* Have we found a permanent breakpoint?  */
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|==
name|bp_permanent
condition|)
block|{
name|perm_bp
operator|=
name|b
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
name|b
operator|->
name|duplicate
operator|=
name|count
operator|>
literal|1
expr_stmt|;
block|}
comment|/* If we found a permanent breakpoint at this address, go over the      list again and declare all the other breakpoints there to be the      duplicates.  */
if|if
condition|(
name|perm_bp
condition|)
block|{
name|perm_bp
operator|->
name|duplicate
operator|=
literal|0
expr_stmt|;
comment|/* Permanent breakpoint should always be inserted.  */
if|if
condition|(
operator|!
name|perm_bp
operator|->
name|inserted
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"allegedly permanent breakpoint is not "
literal|"actually inserted"
argument_list|)
expr_stmt|;
name|ALL_BP_LOCATIONS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|!=
name|perm_bp
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|!=
name|bp_disabled
operator|&&
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|!=
name|bp_shlib_disabled
operator|&&
operator|!
name|b
operator|->
name|owner
operator|->
name|pending
operator|&&
name|b
operator|->
name|owner
operator|->
name|enable_state
operator|!=
name|bp_call_disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|address
comment|/* address / overlay match */
operator|&&
operator|(
operator|!
name|overlay_debugging
operator|||
name|b
operator|->
name|section
operator|==
name|section
operator|)
operator|&&
name|breakpoint_address_is_meaningful
argument_list|(
name|b
operator|->
name|owner
argument_list|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"another breakpoint was inserted on top of "
literal|"a permanent breakpoint"
argument_list|)
expr_stmt|;
name|b
operator|->
name|duplicate
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|breakpoint_adjustment_warning
parameter_list|(
name|CORE_ADDR
name|from_addr
parameter_list|,
name|CORE_ADDR
name|to_addr
parameter_list|,
name|int
name|bnum
parameter_list|,
name|int
name|have_bnum
parameter_list|)
block|{
name|char
name|astr1
index|[
literal|40
index|]
decl_stmt|;
name|char
name|astr2
index|[
literal|40
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|astr1
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|from_addr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|astr2
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|to_addr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_bnum
condition|)
name|warning
argument_list|(
literal|"Breakpoint %d address previously adjusted from %s to %s."
argument_list|,
name|bnum
argument_list|,
name|astr1
argument_list|,
name|astr2
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Breakpoint address adjusted from %s to %s."
argument_list|,
name|astr1
argument_list|,
name|astr2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust a breakpoint's address to account for architectural constraints    on breakpoint placement.  Return the adjusted address.  Note: Very    few targets require this kind of adjustment.  For most targets,    this function is simply the identity function.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|adjust_breakpoint_address
parameter_list|(
name|CORE_ADDR
name|bpaddr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gdbarch_adjust_breakpoint_address_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
comment|/* Very few targets need any kind of breakpoint adjustment.  */
return|return
name|bpaddr
return|;
block|}
else|else
block|{
name|CORE_ADDR
name|adjusted_bpaddr
decl_stmt|;
comment|/* Some targets have architectural constraints on the placement          of breakpoint instructions.  Obtain the adjusted address.  */
name|adjusted_bpaddr
operator|=
name|gdbarch_adjust_breakpoint_address
argument_list|(
name|current_gdbarch
argument_list|,
name|bpaddr
argument_list|)
expr_stmt|;
comment|/* An adjusted breakpoint address can significantly alter          a user's expectations.  Print a warning if an adjustment 	 is required.  */
if|if
condition|(
name|adjusted_bpaddr
operator|!=
name|bpaddr
condition|)
name|breakpoint_adjustment_warning
argument_list|(
name|bpaddr
argument_list|,
name|adjusted_bpaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|adjusted_bpaddr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a struct bp_location.  */
end_comment

begin_function
specifier|static
name|struct
name|bp_location
modifier|*
name|allocate_bp_location
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|,
name|enum
name|bptype
name|bp_type
parameter_list|)
block|{
name|struct
name|bp_location
modifier|*
name|loc
decl_stmt|,
modifier|*
name|loc_p
decl_stmt|;
name|loc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bp_location
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|->
name|owner
operator|=
name|bpt
expr_stmt|;
switch|switch
condition|(
name|bp_type
condition|)
block|{
case|case
name|bp_breakpoint
case|:
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_shlib_event
case|:
case|case
name|bp_thread_event
case|:
case|case
name|bp_overlay_event
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
name|loc
operator|->
name|loc_type
operator|=
name|bp_loc_software_breakpoint
expr_stmt|;
break|break;
case|case
name|bp_hardware_breakpoint
case|:
name|loc
operator|->
name|loc_type
operator|=
name|bp_loc_hardware_breakpoint
expr_stmt|;
break|break;
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|loc
operator|->
name|loc_type
operator|=
name|bp_loc_hardware_watchpoint
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
name|loc
operator|->
name|loc_type
operator|=
name|bp_loc_other
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown breakpoint type"
argument_list|)
expr_stmt|;
block|}
comment|/* Add this breakpoint to the end of the chain.  */
name|loc_p
operator|=
name|bp_location_chain
expr_stmt|;
if|if
condition|(
name|loc_p
operator|==
literal|0
condition|)
name|bp_location_chain
operator|=
name|loc
expr_stmt|;
else|else
block|{
while|while
condition|(
name|loc_p
operator|->
name|next
condition|)
name|loc_p
operator|=
name|loc_p
operator|->
name|next
expr_stmt|;
name|loc_p
operator|->
name|next
operator|=
name|loc
expr_stmt|;
block|}
return|return
name|loc
return|;
block|}
end_function

begin_comment
comment|/* set_raw_breakpoint() is a low level routine for allocating and    partially initializing a breakpoint of type BPTYPE.  The newly    created breakpoint's address, section, source file name, and line    number are provided by SAL.  The newly created and partially    initialized breakpoint is added to the breakpoint chain and    is also returned as the value of this function.     It is expected that the caller will complete the initialization of    the newly created breakpoint struct as well as output any status    information regarding the creation of a new breakpoint.  In    particular, set_raw_breakpoint() does NOT set the breakpoint    number!  Care should be taken to not allow an error() to occur    prior to completing the initialization of the breakpoint.  If this    should happen, a bogus breakpoint will be left on the chain.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|,
name|enum
name|bptype
name|bptype
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|breakpoint
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|loc
operator|=
name|allocate_bp_location
argument_list|(
name|b
argument_list|,
name|bptype
argument_list|)
expr_stmt|;
name|b
operator|->
name|loc
operator|->
name|requested_address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|b
operator|->
name|loc
operator|->
name|address
operator|=
name|adjust_breakpoint_address
argument_list|(
name|b
operator|->
name|loc
operator|->
name|requested_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|b
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|b
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|loc
operator|->
name|section
operator|=
name|sal
operator|.
name|section
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|bptype
expr_stmt|;
name|b
operator|->
name|language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|b
operator|->
name|input_radix
operator|=
name|input_radix
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|frame_id
operator|=
name|null_frame_id
expr_stmt|;
name|b
operator|->
name|dll_pathname
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|triggered_dll_pathname
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|forked_inferior_pid
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|exec_pathname
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|ops
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
comment|/* Add this breakpoint to the end of the chain      so that a list of breakpoints will come out in order      of increasing numbers.  */
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
name|breakpoint_chain
operator|=
name|b
expr_stmt|;
else|else
block|{
while|while
condition|(
name|b1
operator|->
name|next
condition|)
name|b1
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|b
expr_stmt|;
block|}
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Note that the breakpoint object B describes a permanent breakpoint    instruction, hard-wired into the inferior's code.  */
end_comment

begin_function
name|void
name|make_breakpoint_permanent
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_permanent
expr_stmt|;
comment|/* By definition, permanent breakpoints are already present in the code.  */
name|b
operator|->
name|loc
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|breakpoint
modifier|*
name|create_internal_breakpoint
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|,
name|enum
name|bptype
name|type
parameter_list|)
block|{
specifier|static
name|int
name|internal_breakpoint_number
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sal
operator|.
name|pc
operator|=
name|address
expr_stmt|;
name|sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|internal_breakpoint_number
operator|--
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disp_donttouch
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_longjmp_breakpoint
parameter_list|(
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|func_name
operator|==
name|NULL
condition|)
name|b
operator|=
name|create_internal_breakpoint
argument_list|(
literal|0
argument_list|,
name|bp_longjmp_resume
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|func_name
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|b
operator|=
name|create_internal_breakpoint
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|m
argument_list|)
argument_list|,
name|bp_longjmp
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|func_name
condition|)
name|b
operator|->
name|addr_string
operator|=
name|xstrdup
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this routine when stepping and nexting to enable a breakpoint    if we do a longjmp().  When we hit that breakpoint, call    set_longjmp_resume_breakpoint() to figure out where we are going. */
end_comment

begin_function
name|void
name|enable_longjmp_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|disable_longjmp_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp
operator|||
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|create_overlay_event_breakpoint
parameter_list|(
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|func_name
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|b
operator|=
name|create_internal_breakpoint
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|m
argument_list|)
argument_list|,
name|bp_overlay_event
argument_list|)
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|xstrdup
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay_debugging
operator|==
name|ovly_auto
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|overlay_events_enabled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|overlay_events_enabled
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|enable_overlay_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_overlay_event
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|overlay_events_enabled
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|disable_overlay_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_overlay_event
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|overlay_events_enabled
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|breakpoint
modifier|*
name|create_thread_event_breakpoint
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|create_internal_breakpoint
argument_list|(
name|address
argument_list|,
name|bp_thread_event
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
comment|/* addr_string has to be used or breakpoint_re_set will delete me.  */
name|xasprintf
argument_list|(
operator|&
name|b
operator|->
name|addr_string
argument_list|,
literal|"*0x%s"
argument_list|,
name|paddr
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|void
name|remove_thread_event_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_thread_event
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|captured_parse_breakpoint_args
block|{
name|char
modifier|*
modifier|*
name|arg_p
decl_stmt|;
name|struct
name|symtabs_and_lines
modifier|*
name|sals_p
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|addr_string_p
decl_stmt|;
name|int
modifier|*
name|not_found_ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lang_and_radix
block|{
name|enum
name|language
name|lang
decl_stmt|;
name|int
name|radix
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Cleanup helper routine to restore the current language and    input radix.  */
end_comment

begin_function
specifier|static
name|void
name|do_restore_lang_radix_cleanup
parameter_list|(
name|void
modifier|*
name|old
parameter_list|)
block|{
name|struct
name|lang_and_radix
modifier|*
name|p
init|=
name|old
decl_stmt|;
name|set_language
argument_list|(
name|p
operator|->
name|lang
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|p
operator|->
name|radix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try and resolve a pending breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|resolve_pending_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
comment|/* Try and reparse the breakpoint in case the shared library      is now loaded.  */
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|pending_sal
decl_stmt|;
name|char
modifier|*
modifier|*
name|cond_string
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|copy_arg
init|=
name|b
operator|->
name|addr_string
decl_stmt|;
name|char
modifier|*
modifier|*
name|addr_string
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|not_found
init|=
literal|0
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|old_gdb_stderr
decl_stmt|;
name|struct
name|lang_and_radix
name|old_lr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Set language, input-radix, then reissue breakpoint command.       Ensure the language and input-radix are restored afterwards.  */
name|old_lr
operator|.
name|lang
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|old_lr
operator|.
name|radix
operator|=
name|input_radix
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|do_restore_lang_radix_cleanup
argument_list|,
operator|&
name|old_lr
argument_list|)
expr_stmt|;
name|set_language
argument_list|(
name|b
operator|->
name|language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|b
operator|->
name|input_radix
expr_stmt|;
name|rc
operator|=
name|break_command_1
argument_list|(
name|b
operator|->
name|addr_string
argument_list|,
name|b
operator|->
name|flag
argument_list|,
name|b
operator|->
name|from_tty
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|GDB_RC_OK
condition|)
comment|/* Pending breakpoint has been resolved.  */
name|printf_filtered
argument_list|(
literal|"Pending breakpoint \"%s\" resolved\n"
argument_list|,
name|b
operator|->
name|addr_string
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function
name|void
name|remove_solib_event_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_shlib_event
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|breakpoint
modifier|*
name|create_solib_event_breakpoint
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|create_internal_breakpoint
argument_list|(
name|address
argument_list|,
name|bp_shlib_event
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Disable any breakpoints that are on code in shared libraries.  Only    apply to enabled breakpoints, disabled ones can just stay disabled.  */
end_comment

begin_function
name|void
name|disable_breakpoints_in_shlibs
parameter_list|(
name|int
name|silent
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|disabled_shlib_breaks
init|=
literal|0
decl_stmt|;
comment|/* See also: insert_breakpoints, under DISABLE_UNSETTABLE_BREAK. */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PC_SOLIB
argument_list|)
if|if
condition|(
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_breakpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|)
operator|)
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
operator|&&
operator|!
name|b
operator|->
name|loc
operator|->
name|duplicate
operator|&&
name|PC_SOLIB
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_shlib_disabled
expr_stmt|;
if|if
condition|(
operator|!
name|silent
condition|)
block|{
if|if
condition|(
operator|!
name|disabled_shlib_breaks
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|warning
argument_list|(
literal|"Temporarily disabling shared library breakpoints:"
argument_list|)
expr_stmt|;
block|}
name|disabled_shlib_breaks
operator|=
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|"breakpoint #%d "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Try to reenable any breakpoints in shared libraries.  */
end_comment

begin_function
name|void
name|re_enable_breakpoints_in_shlibs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|enable_state
operator|==
name|bp_shlib_disabled
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|,
modifier|*
name|lib
decl_stmt|;
comment|/* Do not reenable the breakpoint if the shared library 	   is still not mapped in.  */
name|lib
operator|=
name|PC_SOLIB
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|lib
operator|!=
name|NULL
operator|&&
name|target_read_memory
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|pending
operator|&&
operator|(
name|b
operator|->
name|enable_state
operator|==
name|bp_enabled
operator|)
condition|)
block|{
if|if
condition|(
name|resolve_pending_breakpoint
argument_list|(
name|b
argument_list|)
operator|==
name|GDB_RC_OK
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|solib_load_unload_1
parameter_list|(
name|char
modifier|*
name|hookname
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|dll_pathname
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|bptype
name|bp_kind
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|canonical_strings_chain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|addr_start
init|=
name|hookname
decl_stmt|;
name|char
modifier|*
name|addr_end
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
comment|/* Set a breakpoint on the specified hook. */
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|hookname
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|hookname
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to set a breakpoint on dynamic linker callback."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to set unique breakpoint on dynamic linker callback."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure that all storage allocated in decode_line_1 gets freed      in case the following errors out.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
name|canonical_strings_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|canonical
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Remove the canonical strings from the cleanup, they are needed below.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|canonical_strings_chain
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
name|bp_kind
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|&&
name|canonical
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|b
operator|->
name|addr_string
operator|=
name|canonical
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_start
condition|)
name|b
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
expr_stmt|;
if|if
condition|(
name|dll_pathname
operator|==
name|NULL
condition|)
name|b
operator|->
name|dll_pathname
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|b
operator|->
name|dll_pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dll_pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|b
operator|->
name|dll_pathname
argument_list|,
name|dll_pathname
argument_list|)
expr_stmt|;
block|}
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_solib_load_event_breakpoint
parameter_list|(
name|char
modifier|*
name|hookname
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|dll_pathname
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|solib_load_unload_1
argument_list|(
name|hookname
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_load
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_solib_unload_event_breakpoint
parameter_list|(
name|char
modifier|*
name|hookname
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|dll_pathname
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|solib_load_unload_1
argument_list|(
name|hookname
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_unload
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_fork_vfork_event_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|bptype
name|bp_kind
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|bp_kind
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
expr_stmt|;
name|b
operator|->
name|forked_inferior_pid
operator|=
literal|0
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_fork_event_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|create_fork_vfork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_fork
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_vfork_event_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|create_fork_vfork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|bp_catch_vfork
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_exec_event_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|bp_catch_exec
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hw_breakpoint_used_count
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
operator|&&
name|b
operator|->
name|enable_state
operator|==
name|bp_enabled
condition|)
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hw_watchpoint_used_count
parameter_list|(
name|enum
name|bptype
name|type
parameter_list|,
name|int
modifier|*
name|other_type_used
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|other_type_used
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|type
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
condition|)
operator|*
name|other_type_used
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Call this after hitting the longjmp() breakpoint.  Use this to set    a new breakpoint at the target of the jmp_buf.     FIXME - This ought to be done by setting a temporary breakpoint    that gets deleted automatically... */
end_comment

begin_function
name|void
name|set_longjmp_resume_breakpoint
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|frame_id
name|frame_id
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_longjmp_resume
condition|)
block|{
name|b
operator|->
name|loc
operator|->
name|requested_address
operator|=
name|pc
expr_stmt|;
name|b
operator|->
name|loc
operator|->
name|address
operator|=
name|adjust_breakpoint_address
argument_list|(
name|b
operator|->
name|loc
operator|->
name|requested_address
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|frame_id
operator|=
name|frame_id
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|disable_watchpoints_before_interactive_call_start
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|||
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_call_disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|enable_watchpoints_after_interactive_call_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|b
operator|->
name|type
operator|==
name|bp_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|)
operator|||
operator|(
name|b
operator|->
name|type
operator|==
name|bp_access_watchpoint
operator|)
operator|||
name|ep_is_exception_catchpoint
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
operator|(
name|b
operator|->
name|enable_state
operator|==
name|bp_call_disabled
operator|)
condition|)
block|{
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set a breakpoint that will evaporate an end of command    at address specified by SAL.    Restrict it to frame FRAME if FRAME is nonzero.  */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_momentary_breakpoint
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|,
name|struct
name|frame_id
name|frame_id
parameter_list|,
name|enum
name|bptype
name|type
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disp_donttouch
expr_stmt|;
name|b
operator|->
name|frame_id
operator|=
name|frame_id
expr_stmt|;
comment|/* If we're debugging a multi-threaded program, then we      want momentary breakpoints to be active in only a       single thread of control.  */
if|if
condition|(
name|in_thread_list
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|b
operator|->
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the user we have just set a breakpoint B.  */
end_comment

begin_function
specifier|static
name|void
name|mention
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
name|int
name|say_where
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|,
modifier|*
name|ui_out_chain
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
comment|/* FIXME: This is misplaced; mention() is called by things (like hitting a      watchpoint) other than breakpoint creation.  It should be possible to      clean this up and at the same time replace the random calls to      breakpoint_changed with this hook, as has already been done for      delete_breakpoint_hook and so on.  */
if|if
condition|(
name|create_breakpoint_hook
condition|)
name|create_breakpoint_hook
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|breakpoint_create_event
argument_list|(
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ops
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|ops
operator|->
name|print_mention
operator|!=
name|NULL
condition|)
name|b
operator|->
name|ops
operator|->
name|print_mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|printf_filtered
argument_list|(
literal|"(apparently deleted?) Eventpoint %d: "
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Watchpoint "
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"wpt"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"exp"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_hardware_watchpoint
case|:
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Hardware watchpoint "
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"wpt"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"exp"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_read_watchpoint
case|:
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Hardware read watchpoint "
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"hw-rwpt"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"exp"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_access_watchpoint
case|:
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Hardware access (read/write) watchpoint "
argument_list|)
expr_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"hw-awpt"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"exp"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_breakpoint
case|:
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
block|{
name|say_where
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"Breakpoint %d"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|say_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|bp_hardware_breakpoint
case|:
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
block|{
name|say_where
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"Hardware assisted breakpoint %d"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|say_where
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (%s %s)"
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_load
operator|)
condition|?
literal|"load"
else|:
literal|"unload"
argument_list|,
operator|(
name|b
operator|->
name|dll_pathname
operator|!=
name|NULL
operator|)
condition|?
name|b
operator|->
name|dll_pathname
else|:
literal|"<any library>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (%s)"
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_fork
operator|)
condition|?
literal|"fork"
else|:
literal|"vfork"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_exec
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (exec)"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (%s)"
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|type
operator|==
name|bp_catch_catch
operator|)
condition|?
literal|"catch"
else|:
literal|"throw"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_step_resume
case|:
case|case
name|bp_through_sigtramp
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_shlib_event
case|:
case|case
name|bp_thread_event
case|:
case|case
name|bp_overlay_event
case|:
break|break;
block|}
if|if
condition|(
name|say_where
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|pending
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" (%s) pending."
argument_list|,
name|b
operator|->
name|addr_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addressprint
operator|||
name|b
operator|->
name|source_file
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|source_file
condition|)
name|printf_filtered
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|source_file
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
return|return;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add SALS.nelts breakpoints to the breakpoint table.  For each    SALS.sal[i] breakpoint, include the corresponding ADDR_STRING[i],    COND[i] and COND_STRING[i] values.     The parameter PENDING_BP points to a pending breakpoint that is    the basis of the breakpoints currently being created.  The pending    breakpoint may contain a separate condition string or commands    that were added after the initial pending breakpoint was created.     NOTE: If the function succeeds, the caller is expected to cleanup    the arrays ADDR_STRING, COND_STRING, COND and SALS (but not the    array contents).  If the function fails (error() is called), the    caller is expected to cleanups both the ADDR_STRING, COND_STRING,    COND and SALS arrays and each of those arrays contents. */
end_comment

begin_function
specifier|static
name|void
name|create_breakpoints
parameter_list|(
name|struct
name|symtabs_and_lines
name|sals
parameter_list|,
name|char
modifier|*
modifier|*
name|addr_string
parameter_list|,
name|struct
name|expression
modifier|*
modifier|*
name|cond
parameter_list|,
name|char
modifier|*
modifier|*
name|cond_string
parameter_list|,
name|enum
name|bptype
name|type
parameter_list|,
name|enum
name|bpdisp
name|disposition
parameter_list|,
name|int
name|thread
parameter_list|,
name|int
name|ignore_count
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|breakpoint
modifier|*
name|pending_bp
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
name|int
name|i
init|=
name|hw_breakpoint_used_count
argument_list|()
decl_stmt|;
name|int
name|target_resources_ok
init|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
name|sals
operator|.
name|nelts
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
comment|/* Now set all the breakpoints.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
init|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|section
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
index|[
name|i
index|]
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|addr_string
index|[
name|i
index|]
condition|)
name|b
operator|->
name|addr_string
operator|=
name|addr_string
index|[
name|i
index|]
expr_stmt|;
else|else
comment|/* addr_string has to be used or breakpoint_re_set will delete 	     me.  */
name|xasprintf
argument_list|(
operator|&
name|b
operator|->
name|addr_string
argument_list|,
literal|"*0x%s"
argument_list|,
name|paddr
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|cond_string
index|[
name|i
index|]
expr_stmt|;
name|b
operator|->
name|ignore_count
operator|=
name|ignore_count
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disposition
expr_stmt|;
comment|/* If resolving a pending breakpoint, a check must be made to see if 	   the user has specified a new condition or commands for the  	   breakpoint.  A new condition will override any condition that was  	   initially specified with the initial breakpoint command.  */
if|if
condition|(
name|pending_bp
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|pending_bp
operator|->
name|cond_string
condition|)
block|{
name|arg
operator|=
name|pending_bp
operator|->
name|cond_string
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of pending breakpoint condition expression"
argument_list|)
expr_stmt|;
block|}
comment|/* If there are commands associated with the breakpoint, they should  	       be copied too.  */
if|if
condition|(
name|pending_bp
operator|->
name|commands
condition|)
name|b
operator|->
name|commands
operator|=
name|copy_command_lines
argument_list|(
name|pending_bp
operator|->
name|commands
argument_list|)
expr_stmt|;
comment|/* We have to copy over the ignore_count and thread as well.  */
name|b
operator|->
name|ignore_count
operator|=
name|pending_bp
operator|->
name|ignore_count
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|pending_bp
operator|->
name|thread
expr_stmt|;
block|}
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse ARG which is assumed to be a SAL specification possibly    followed by conditionals.  On return, SALS contains an array of SAL    addresses found. ADDR_STRING contains a vector of (canonical)    address strings. ARG points to the end of the SAL. */
end_comment

begin_function
specifier|static
name|void
name|parse_breakpoint_sals
parameter_list|(
name|char
modifier|*
modifier|*
name|address
parameter_list|,
name|struct
name|symtabs_and_lines
modifier|*
name|sals
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|addr_string
parameter_list|,
name|int
modifier|*
name|not_found_ptr
parameter_list|)
block|{
name|char
modifier|*
name|addr_start
init|=
operator|*
name|address
decl_stmt|;
operator|*
name|addr_string
operator|=
name|NULL
expr_stmt|;
comment|/* If no arg given, or if first arg is 'if ', use the default      breakpoint. */
if|if
condition|(
operator|(
operator|*
name|address
operator|)
operator|==
name|NULL
operator|||
operator|(
name|strncmp
argument_list|(
operator|(
operator|*
name|address
operator|)
argument_list|,
literal|"if"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
operator|*
name|address
operator|)
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sals
operator|->
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|sals
operator|->
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|->
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Force almost all breakpoints to be in terms of the          current_source_symtab (which is decode_line_1's default).  This          should produce the results we want almost all of the time while          leaving default_breakpoint_* alone.            ObjC: However, don't match an Objective-C method name which          may have a '+' or '-' succeeded by a '[' */
name|struct
name|symtab_and_line
name|cursal
init|=
name|get_current_source_symtab_and_line
argument_list|()
decl_stmt|;
if|if
condition|(
name|default_breakpoint_valid
operator|&&
operator|(
operator|!
name|cursal
operator|.
name|symtab
operator|||
operator|(
operator|(
name|strchr
argument_list|(
literal|"+-"
argument_list|,
operator|(
operator|*
name|address
operator|)
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|*
name|address
operator|)
index|[
literal|1
index|]
operator|!=
literal|'['
operator|)
operator|)
operator|)
condition|)
operator|*
name|sals
operator|=
name|decode_line_1
argument_list|(
name|address
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
name|addr_string
argument_list|,
name|not_found_ptr
argument_list|)
expr_stmt|;
else|else
operator|*
name|sals
operator|=
name|decode_line_1
argument_list|(
name|address
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|addr_string
argument_list|,
name|not_found_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* For any SAL that didn't have a canonical string, fill one in. */
if|if
condition|(
name|sals
operator|->
name|nelts
operator|>
literal|0
operator|&&
operator|*
name|addr_string
operator|==
name|NULL
condition|)
operator|*
name|addr_string
operator|=
name|xcalloc
argument_list|(
name|sals
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_start
operator|!=
operator|(
operator|*
name|address
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* Add the string if not present. */
if|if
condition|(
operator|(
operator|*
name|addr_string
operator|)
index|[
name|i
index|]
operator|==
name|NULL
condition|)
operator|(
operator|*
name|addr_string
operator|)
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
operator|(
operator|*
name|address
operator|)
operator|-
name|addr_start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Convert each SAL into a real PC.  Verify that the PC can be    inserted as a breakpoint.  If it can't throw an error. */
end_comment

begin_function
specifier|static
name|void
name|breakpoint_sals_to_pc
parameter_list|(
name|struct
name|symtabs_and_lines
modifier|*
name|sals
parameter_list|,
name|char
modifier|*
name|address
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|->
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* It's possible for the PC to be nonzero, but still an illegal          value on some targets.           For example, on HP-UX if you start gdb, and before running the          inferior you try to set a breakpoint on a shared library function          "foo" where the inferior doesn't call "foo" directly but does          pass its address to another function call, then we do find a          minimal symbol for the "foo", but it's address is invalid.          (Appears to be an index into a table that the loader sets up          when the inferior is run.)           Give the target a chance to bless sals.sals[i].pc before we          try to make a breakpoint for it. */
if|if
condition|(
name|PC_REQUIRES_RUN_BEFORE_USE
argument_list|(
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|address
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot break without a running program."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot break on %s without a running program."
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_captured_parse_breakpoint
parameter_list|(
name|struct
name|ui_out
modifier|*
name|ui
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_parse_breakpoint_args
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|parse_breakpoint_sals
argument_list|(
name|args
operator|->
name|arg_p
argument_list|,
name|args
operator|->
name|sals_p
argument_list|,
name|args
operator|->
name|addr_string_p
argument_list|,
name|args
operator|->
name|not_found_ptr
argument_list|)
expr_stmt|;
return|return
name|GDB_RC_OK
return|;
block|}
end_function

begin_comment
comment|/* Set a breakpoint according to ARG (function, linenum or *address)    flag: first bit  : 0 non-temporary, 1 temporary.    second bit : 0 normal breakpoint, 1 hardware breakpoint.      PENDING_BP is non-NULL when this function is being called to resolve    a pending breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|break_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|breakpoint
modifier|*
name|pending_bp
parameter_list|)
block|{
name|int
name|tempflag
decl_stmt|,
name|hardwareflag
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|expression
modifier|*
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
name|struct
name|symtab_and_line
name|pending_sal
decl_stmt|;
name|char
modifier|*
modifier|*
name|cond_string
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|copy_arg
decl_stmt|;
name|char
modifier|*
name|err_msg
decl_stmt|;
name|char
modifier|*
name|addr_start
init|=
name|arg
decl_stmt|;
name|char
modifier|*
modifier|*
name|addr_string
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|breakpoint_chain
init|=
name|NULL
decl_stmt|;
name|struct
name|captured_parse_breakpoint_args
name|parse_args
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|int
name|pending
init|=
literal|0
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ignore_count
init|=
literal|0
decl_stmt|;
name|int
name|not_found
init|=
literal|0
decl_stmt|;
name|hardwareflag
operator|=
name|flag
operator|&
name|BP_HARDWAREFLAG
expr_stmt|;
name|tempflag
operator|=
name|flag
operator|&
name|BP_TEMPFLAG
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|parse_args
operator|.
name|arg_p
operator|=
operator|&
name|arg
expr_stmt|;
name|parse_args
operator|.
name|sals_p
operator|=
operator|&
name|sals
expr_stmt|;
name|parse_args
operator|.
name|addr_string_p
operator|=
operator|&
name|addr_string
expr_stmt|;
name|parse_args
operator|.
name|not_found_ptr
operator|=
operator|&
name|not_found
expr_stmt|;
name|rc
operator|=
name|catch_exceptions_with_msg
argument_list|(
name|uiout
argument_list|,
name|do_captured_parse_breakpoint
argument_list|,
operator|&
name|parse_args
argument_list|,
name|NULL
argument_list|,
operator|&
name|err_msg
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* If caller is interested in rc value from parse, set value.  */
if|if
condition|(
name|rc
operator|!=
name|GDB_RC_OK
condition|)
block|{
comment|/* Check for file or function not found.  */
if|if
condition|(
name|not_found
condition|)
block|{
comment|/* If called to resolve pending breakpoint, just return error code.  */
if|if
condition|(
name|pending_bp
condition|)
return|return
name|rc
return|;
name|error_output_message
argument_list|(
name|NULL
argument_list|,
name|err_msg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|err_msg
argument_list|)
expr_stmt|;
comment|/* If pending breakpoint support is turned off, throw error.  */
if|if
condition|(
name|pending_break_support
operator|==
name|AUTO_BOOLEAN_FALSE
condition|)
name|throw_exception
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
comment|/* If pending breakpoint support is auto query and the user selects  	     no, then simply return the error code.  */
if|if
condition|(
name|pending_break_support
operator|==
name|AUTO_BOOLEAN_AUTO
operator|&&
operator|!
name|nquery
argument_list|(
literal|"Make breakpoint pending on future shared library load? "
argument_list|)
condition|)
return|return
name|rc
return|;
comment|/* At this point, either the user was queried about setting a  	     pending breakpoint and selected yes, or pending breakpoint  	     behavior is on and thus a pending breakpoint is defaulted  	     on behalf of the user.  */
name|copy_arg
operator|=
name|xstrdup
argument_list|(
name|addr_start
argument_list|)
expr_stmt|;
name|addr_string
operator|=
operator|&
name|copy_arg
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|&
name|pending_sal
expr_stmt|;
name|pending_sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
name|rc
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return
name|GDB_RC_FAIL
return|;
comment|/* Create a chain of things that always need to be cleaned up. */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pending
condition|)
block|{
comment|/* Make sure that all storage allocated to SALS gets freed.  */
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* Cleanup the addr_string array but not its contents. */
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|addr_string
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate space for all the cond expressions. */
name|cond
operator|=
name|xcalloc
argument_list|(
name|sals
operator|.
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond
argument_list|)
expr_stmt|;
comment|/* Allocate space for all the cond strings. */
name|cond_string
operator|=
name|xcalloc
argument_list|(
name|sals
operator|.
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
comment|/* ----------------------------- SNIP -----------------------------      Anything added to the cleanup chain beyond this point is assumed      to be part of a breakpoint.  If the breakpoint create succeeds      then the memory is not reclaimed. */
name|breakpoint_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark the contents of the addr_string for cleanup.  These go on      the breakpoint_chain and only occure if the breakpoint create      fails. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_string
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|addr_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve all line numbers to PC's and verify that the addresses      are ok for the target.  */
if|if
condition|(
operator|!
name|pending
condition|)
name|breakpoint_sals_to_pc
argument_list|(
operator|&
name|sals
argument_list|,
name|addr_start
argument_list|)
expr_stmt|;
comment|/* Verify that condition can be parsed, before setting any      breakpoints.  Allocate a separate condition expression for each      breakpoint. */
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No specific thread yet */
if|if
condition|(
operator|!
name|pending
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|tok
init|=
name|arg
decl_stmt|;
while|while
condition|(
name|tok
operator|&&
operator|*
name|tok
condition|)
block|{
name|char
modifier|*
name|end_tok
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|tok
operator|==
literal|' '
operator|||
operator|*
name|tok
operator|==
literal|'\t'
condition|)
name|tok
operator|++
expr_stmt|;
name|end_tok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|*
name|end_tok
operator|!=
literal|' '
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\t'
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\000'
condition|)
name|end_tok
operator|++
expr_stmt|;
name|toklen
operator|=
name|end_tok
operator|-
name|tok
expr_stmt|;
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"if"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|cond_start
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|cond
index|[
name|i
index|]
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|tok
expr_stmt|;
name|cond_string
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"thread"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tmptok
decl_stmt|;
name|tok
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|tmptok
operator|=
name|tok
expr_stmt|;
name|thread
operator|=
name|strtol
argument_list|(
name|tok
argument_list|,
operator|&
name|tok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|tmptok
condition|)
name|error
argument_list|(
literal|"Junk after thread keyword."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_thread_id
argument_list|(
name|thread
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unknown thread %d\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
block|}
name|create_breakpoints
argument_list|(
name|sals
argument_list|,
name|addr_string
argument_list|,
name|cond
argument_list|,
name|cond_string
argument_list|,
name|hardwareflag
condition|?
name|bp_hardware_breakpoint
else|:
name|bp_breakpoint
argument_list|,
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
argument_list|,
name|thread
argument_list|,
name|ignore_count
argument_list|,
name|from_tty
argument_list|,
name|pending_bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|copy_arg
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|hardwareflag
condition|?
name|bp_hardware_breakpoint
else|:
name|bp_breakpoint
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
operator|*
name|cond
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
operator|*
name|addr_string
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|*
name|cond_string
expr_stmt|;
name|b
operator|->
name|ignore_count
operator|=
name|ignore_count
expr_stmt|;
name|b
operator|->
name|pending
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
expr_stmt|;
name|b
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
name|b
operator|->
name|flag
operator|=
name|flag
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Multiple breakpoints were set."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints."
argument_list|)
expr_stmt|;
block|}
comment|/* That's it. Discard the cleanups for data inserted into the      breakpoint. */
name|discard_cleanups
argument_list|(
name|breakpoint_chain
argument_list|)
expr_stmt|;
comment|/* But cleanup everything else. */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|GDB_RC_OK
return|;
block|}
end_function

begin_comment
comment|/* Set a breakpoint of TYPE/DISPOSITION according to ARG (function,    linenum or *address) with COND and IGNORE_COUNT. */
end_comment

begin_struct
struct|struct
name|captured_breakpoint_args
block|{
name|char
modifier|*
name|address
decl_stmt|;
name|char
modifier|*
name|condition
decl_stmt|;
name|int
name|hardwareflag
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|int
name|ignore_count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|do_captured_breakpoint
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_breakpoint_args
modifier|*
name|args
init|=
name|data
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|expression
modifier|*
modifier|*
name|cond
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|breakpoint_chain
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|addr_string
decl_stmt|;
name|char
modifier|*
modifier|*
name|cond_string
decl_stmt|;
name|char
modifier|*
name|address_end
decl_stmt|;
comment|/* Parse the source and lines spec.  Delay check that the expression      didn't contain trailing garbage until after cleanups are in      place. */
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|address_end
operator|=
name|args
operator|->
name|address
expr_stmt|;
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|parse_breakpoint_sals
argument_list|(
operator|&
name|address_end
argument_list|,
operator|&
name|sals
argument_list|,
operator|&
name|addr_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return
name|GDB_RC_NONE
return|;
comment|/* Create a chain of things at always need to be cleaned up. */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Always have a addr_string array, even if it is empty. */
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|addr_string
argument_list|)
expr_stmt|;
comment|/* Make sure that all storage allocated to SALS gets freed.  */
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* Allocate space for all the cond expressions. */
name|cond
operator|=
name|xcalloc
argument_list|(
name|sals
operator|.
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond
argument_list|)
expr_stmt|;
comment|/* Allocate space for all the cond strings. */
name|cond_string
operator|=
name|xcalloc
argument_list|(
name|sals
operator|.
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
comment|/* ----------------------------- SNIP -----------------------------      Anything added to the cleanup chain beyond this point is assumed      to be part of a breakpoint.  If the breakpoint create goes      through then that memory is not cleaned up. */
name|breakpoint_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark the contents of the addr_string for cleanup.  These go on      the breakpoint_chain and only occure if the breakpoint create      fails. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_string
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|addr_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Wait until now before checking for garbage at the end of the      address. That way cleanups can take care of freeing any      memory. */
if|if
condition|(
operator|*
name|address_end
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Garbage %s following breakpoint address"
argument_list|,
name|address_end
argument_list|)
expr_stmt|;
comment|/* Resolve all line numbers to PC's.  */
name|breakpoint_sals_to_pc
argument_list|(
operator|&
name|sals
argument_list|,
name|args
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Verify that conditions can be parsed, before setting any      breakpoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
operator|->
name|condition
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tok
init|=
name|args
operator|->
name|condition
decl_stmt|;
name|cond
index|[
name|i
index|]
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tok
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Garbage %s follows condition"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|cond
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cond_string
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|args
operator|->
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
name|create_breakpoints
argument_list|(
name|sals
argument_list|,
name|addr_string
argument_list|,
name|cond
argument_list|,
name|cond_string
argument_list|,
name|args
operator|->
name|hardwareflag
condition|?
name|bp_hardware_breakpoint
else|:
name|bp_breakpoint
argument_list|,
name|args
operator|->
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
argument_list|,
name|args
operator|->
name|thread
argument_list|,
name|args
operator|->
name|ignore_count
argument_list|,
literal|0
comment|/*from-tty*/
argument_list|,
name|NULL
comment|/*pending_bp*/
argument_list|)
expr_stmt|;
comment|/* That's it. Discard the cleanups for data inserted into the      breakpoint. */
name|discard_cleanups
argument_list|(
name|breakpoint_chain
argument_list|)
expr_stmt|;
comment|/* But cleanup everything else. */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|GDB_RC_OK
return|;
block|}
end_function

begin_function
name|enum
name|gdb_rc
name|gdb_breakpoint
parameter_list|(
name|char
modifier|*
name|address
parameter_list|,
name|char
modifier|*
name|condition
parameter_list|,
name|int
name|hardwareflag
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|thread
parameter_list|,
name|int
name|ignore_count
parameter_list|)
block|{
name|struct
name|captured_breakpoint_args
name|args
decl_stmt|;
name|args
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|args
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
name|args
operator|.
name|hardwareflag
operator|=
name|hardwareflag
expr_stmt|;
name|args
operator|.
name|tempflag
operator|=
name|tempflag
expr_stmt|;
name|args
operator|.
name|thread
operator|=
name|thread
expr_stmt|;
name|args
operator|.
name|ignore_count
operator|=
name|ignore_count
expr_stmt|;
return|return
name|catch_errors
argument_list|(
name|do_captured_breakpoint
argument_list|,
operator|&
name|args
argument_list|,
name|NULL
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_at_finish_at_depth_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|,
name|selected_pc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|extra_args
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|level_arg
decl_stmt|;
name|int
name|extra_args_len
init|=
literal|0
decl_stmt|,
name|if_arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
if|if
condition|(
name|deprecated_selected_frame
condition|)
block|{
name|selected_pc
operator|=
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|if_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extra_args
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_args
condition|)
block|{
name|extra_args
operator|++
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|level_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|extra_args
operator|-
name|arg
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|level_arg
argument_list|,
name|arg
argument_list|,
name|extra_args
operator|-
name|arg
operator|-
literal|1
argument_list|)
expr_stmt|;
name|level_arg
index|[
name|extra_args
operator|-
name|arg
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|level_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|level_arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|level_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
name|selected_pc
operator|=
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
else|else
name|selected_pc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|if_arg
condition|)
block|{
name|extra_args
operator|=
name|arg
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selected_pc
condition|)
block|{
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|selected_pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
condition|)
block|{
name|char
modifier|*
name|addr_string
decl_stmt|;
if|if
condition|(
name|extra_args_len
condition|)
name|addr_string
operator|=
name|xstrprintf
argument_list|(
literal|"*0x%s %s"
argument_list|,
name|paddr_nz
argument_list|(
name|high
argument_list|)
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
else|else
name|addr_string
operator|=
name|xstrprintf
argument_list|(
literal|"*0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|break_command_1
argument_list|(
name|addr_string
argument_list|,
name|flag
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|addr_string
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No function contains the specified address"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unable to set breakpoint at procedure exit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_at_finish_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|addr_string
decl_stmt|,
modifier|*
name|break_string
decl_stmt|,
modifier|*
name|beg_addr_string
decl_stmt|;
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|extra_args
init|=
name|NULL
decl_stmt|;
name|int
name|extra_args_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|if_arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
if|if
condition|(
name|deprecated_selected_frame
condition|)
block|{
name|addr_string
operator|=
name|xstrprintf
argument_list|(
literal|"*0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|if_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|addr_string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_arg
condition|)
block|{
name|extra_args
operator|=
name|arg
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
condition|)
block|{
comment|/* get the stuff after the function name or address */
name|extra_args
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_args
condition|)
block|{
name|extra_args
operator|++
expr_stmt|;
name|extra_args_len
operator|=
name|strlen
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
block|}
block|}
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|beg_addr_string
operator|=
name|addr_string
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|addr_string
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|beg_addr_string
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|sals
operator|.
name|nelts
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
condition|)
block|{
name|break_string
expr_stmt|;
if|if
condition|(
name|extra_args_len
condition|)
name|break_string
operator|=
name|xstrprintf
argument_list|(
literal|"*0x%s %s"
argument_list|,
name|paddr_nz
argument_list|(
name|high
argument_list|)
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
else|else
name|break_string
operator|=
name|xstrprintf
argument_list|(
literal|"*0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|break_command_1
argument_list|(
name|break_string
argument_list|,
name|flag
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|break_string
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No function contains the specified address"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints."
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for break_command_1 and disassemble_command.  */
end_comment

begin_function
name|void
name|resolve_sal_pc
parameter_list|(
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|sal
operator|->
name|pc
operator|==
literal|0
operator|&&
name|sal
operator|->
name|symtab
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|find_line_pc
argument_list|(
name|sal
operator|->
name|symtab
argument_list|,
name|sal
operator|->
name|line
argument_list|,
operator|&
name|pc
argument_list|)
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|->
name|line
argument_list|,
name|sal
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sal
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
if|if
condition|(
name|sal
operator|->
name|section
operator|==
literal|0
operator|&&
name|sal
operator|->
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|index
decl_stmt|;
name|bv
operator|=
name|blockvector_for_pc_sect
argument_list|(
name|sal
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|,
name|sal
operator|->
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|bv
operator|!=
name|NULL
condition|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sym
operator|=
name|block_function
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|sal
operator|->
name|symtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|sal
operator|->
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It really is worthwhile to have the section, so we'll just 	         have to look harder. This case can be executed if we have  	         line numbers but no functions (as can happen in assembly  	         source).  */
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|sal
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
name|sal
operator|->
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|break_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|break_at_finish_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_at_finish_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|break_at_finish_at_depth_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_at_finish_at_depth_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tbreak_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
name|BP_TEMPFLAG
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tbreak_at_finish_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_at_finish_command_1
argument_list|(
name|arg
argument_list|,
name|BP_TEMPFLAG
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hbreak_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
name|BP_HARDWAREFLAG
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thbreak_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
operator|(
name|BP_TEMPFLAG
operator||
name|BP_HARDWAREFLAG
operator|)
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"Specify the type of breakpoint to set.\n\ Usage: stop in<function | address>\n\        stop at<line>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stopin_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|badInput
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|badInput
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'*'
condition|)
block|{
name|char
modifier|*
name|argptr
init|=
name|arg
decl_stmt|;
name|int
name|hasColon
init|=
literal|0
decl_stmt|;
comment|/* look for a ':'.  If this is a line number specification, then          say it is bad, otherwise, it should be an address or          function/method name */
while|while
condition|(
operator|*
name|argptr
operator|&&
operator|!
name|hasColon
condition|)
block|{
name|hasColon
operator|=
operator|(
operator|*
name|argptr
operator|==
literal|':'
operator|)
expr_stmt|;
name|argptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hasColon
condition|)
name|badInput
operator|=
operator|(
operator|*
name|argptr
operator|!=
literal|':'
operator|)
expr_stmt|;
comment|/* Not a class::method */
else|else
name|badInput
operator|=
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
comment|/* a simple line number */
block|}
if|if
condition|(
name|badInput
condition|)
name|printf_filtered
argument_list|(
literal|"Usage: stop in<function | address>\n"
argument_list|)
expr_stmt|;
else|else
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stopat_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|badInput
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
operator|*
name|arg
operator|==
literal|'*'
condition|)
comment|/* no line number */
name|badInput
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|argptr
init|=
name|arg
decl_stmt|;
name|int
name|hasColon
init|=
literal|0
decl_stmt|;
comment|/* look for a ':'.  If there is a '::' then get out, otherwise          it is probably a line number. */
while|while
condition|(
operator|*
name|argptr
operator|&&
operator|!
name|hasColon
condition|)
block|{
name|hasColon
operator|=
operator|(
operator|*
name|argptr
operator|==
literal|':'
operator|)
expr_stmt|;
name|argptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hasColon
condition|)
name|badInput
operator|=
operator|(
operator|*
name|argptr
operator|==
literal|':'
operator|)
expr_stmt|;
comment|/* we have class::method */
else|else
name|badInput
operator|=
operator|!
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
comment|/* not a line number */
block|}
if|if
condition|(
name|badInput
condition|)
name|printf_filtered
argument_list|(
literal|"Usage: stop at<line>\n"
argument_list|)
expr_stmt|;
else|else
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* accessflag:  hw_write:  watch write,                  hw_read:   watch read,  		hw_access: watch access (read or write) */
end_comment

begin_function
specifier|static
name|void
name|watch_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|accessflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|struct
name|block
modifier|*
name|exp_valid_block
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev_frame
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|exp_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|exp_end
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|end_tok
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|char
modifier|*
name|cond_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_end
init|=
name|NULL
decl_stmt|;
name|struct
name|expression
modifier|*
name|cond
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|other_type_used
decl_stmt|,
name|target_resources_ok
init|=
literal|0
decl_stmt|;
name|enum
name|bptype
name|bp_type
decl_stmt|;
name|int
name|mem_cnt
init|=
literal|0
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* Parse arguments.  */
name|innermost_block
operator|=
name|NULL
expr_stmt|;
name|exp_start
operator|=
name|arg
expr_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp_end
operator|=
name|arg
expr_stmt|;
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|tok
operator|=
name|arg
expr_stmt|;
while|while
condition|(
operator|*
name|tok
operator|==
literal|' '
operator|||
operator|*
name|tok
operator|==
literal|'\t'
condition|)
name|tok
operator|++
expr_stmt|;
name|end_tok
operator|=
name|tok
expr_stmt|;
while|while
condition|(
operator|*
name|end_tok
operator|!=
literal|' '
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\t'
operator|&&
operator|*
name|end_tok
operator|!=
literal|'\000'
condition|)
name|end_tok
operator|++
expr_stmt|;
name|toklen
operator|=
name|end_tok
operator|-
name|tok
expr_stmt|;
if|if
condition|(
name|toklen
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
name|tok
argument_list|,
literal|"if"
argument_list|,
name|toklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|cond_start
operator|=
name|end_tok
operator|+
literal|1
expr_stmt|;
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|tok
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_end
operator|=
name|tok
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tok
condition|)
name|error
argument_list|(
literal|"Junk at end of command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|accessflag
operator|==
name|hw_read
condition|)
name|bp_type
operator|=
name|bp_read_watchpoint
expr_stmt|;
elseif|else
if|if
condition|(
name|accessflag
operator|==
name|hw_access
condition|)
name|bp_type
operator|=
name|bp_access_watchpoint
expr_stmt|;
else|else
name|bp_type
operator|=
name|bp_hardware_watchpoint
expr_stmt|;
name|mem_cnt
operator|=
name|can_use_hardware_watchpoint
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|==
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Expression cannot be implemented with read/access watchpoint."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cnt
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|hw_watchpoint_used_count
argument_list|(
name|bp_type
argument_list|,
operator|&
name|other_type_used
argument_list|)
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Target does not support this type of hardware watchpoint."
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
operator|&&
name|bp_type
operator|!=
name|bp_hardware_watchpoint
condition|)
name|error
argument_list|(
literal|"Target can only support one kind of HW watchpoint at a time."
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
comment|/*  On HP-UX if you set a h/w      watchpoint before the "run" command, the inferior dies with a e.g.,      SIGILL once you start it.  I initially believed this was due to a      bad interaction between page protection traps and the initial      startup sequence by the dynamic linker.       However, I tried avoiding that by having HP-UX's implementation of      TARGET_CAN_USE_HW_WATCHPOINT return FALSE if there was no inferior_ptid      yet, which forced slow watches before a "run" or "attach", and it      still fails somewhere in the startup code.       Until I figure out what's happening, I'm disallowing watches altogether      before the "run" or "attach" command.  We'll tell the user they must      set watches after getting the program started. */
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|warning
argument_list|(
literal|"can't do that without a running program; try \"break main\", \"run\" first"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HPUXHPPA */
comment|/* Change the type of breakpoint to an ordinary watchpoint if a hardware      watchpoint could not be set.  */
if|if
condition|(
operator|!
name|mem_cnt
operator|||
name|target_resources_ok
operator|<=
literal|0
condition|)
name|bp_type
operator|=
name|bp_watchpoint
expr_stmt|;
comment|/* Now set up the breakpoint.  */
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|bp_type
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|disp_donttouch
expr_stmt|;
name|b
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|exp_valid_block
expr_stmt|;
name|b
operator|->
name|exp_string
operator|=
name|savestring
argument_list|(
name|exp_start
argument_list|,
name|exp_end
operator|-
name|exp_start
argument_list|)
expr_stmt|;
name|b
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|cond_start
condition|)
name|b
operator|->
name|cond_string
operator|=
name|savestring
argument_list|(
name|cond_start
argument_list|,
name|cond_end
operator|-
name|cond_start
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|cond_string
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
name|block_innermost_frame
argument_list|(
name|exp_valid_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
block|{
name|prev_frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|b
operator|->
name|watchpoint_frame
operator|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|b
operator|->
name|watchpoint_frame
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|watchpoint_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the expression is "local", then set up a "watchpoint scope"      breakpoint at the point where we've left the scope of the watchpoint      expression.  */
if|if
condition|(
name|innermost_block
condition|)
block|{
if|if
condition|(
name|prev_frame
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|scope_breakpoint
decl_stmt|;
name|scope_breakpoint
operator|=
name|create_internal_breakpoint
argument_list|(
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
argument_list|,
name|bp_watchpoint_scope
argument_list|)
expr_stmt|;
name|scope_breakpoint
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
comment|/* Automatically delete the breakpoint when it hits.  */
name|scope_breakpoint
operator|->
name|disposition
operator|=
name|disp_del
expr_stmt|;
comment|/* Only break in the proper frame (help with recursion).  */
name|scope_breakpoint
operator|->
name|frame_id
operator|=
name|get_frame_id
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
comment|/* Set the address at which we will stop.  */
name|scope_breakpoint
operator|->
name|loc
operator|->
name|requested_address
operator|=
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
name|scope_breakpoint
operator|->
name|loc
operator|->
name|address
operator|=
name|adjust_breakpoint_address
argument_list|(
name|scope_breakpoint
operator|->
name|loc
operator|->
name|requested_address
argument_list|)
expr_stmt|;
comment|/* The scope breakpoint is related to the watchpoint.  We 	     will need to act on them together.  */
name|b
operator|->
name|related_breakpoint
operator|=
name|scope_breakpoint
expr_stmt|;
block|}
block|}
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return count of locations need to be watched and can be handled    in hardware.  If the watchpoint can not be handled    in hardware return zero.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT
parameter_list|(
name|BYTE_SIZE
parameter_list|)
define|\
value|((BYTE_SIZE)<= (DEPRECATED_REGISTER_SIZE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_REGION_OK_FOR_HW_WATCHPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_REGION_OK_FOR_HW_WATCHPOINT
parameter_list|(
name|ADDR
parameter_list|,
name|LEN
parameter_list|)
define|\
value|(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(LEN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|can_use_hardware_watchpoint
parameter_list|(
name|struct
name|value
modifier|*
name|v
parameter_list|)
block|{
name|int
name|found_memory_cnt
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|head
init|=
name|v
decl_stmt|;
comment|/* Did the user specifically forbid us to use hardware watchpoints? */
if|if
condition|(
operator|!
name|can_use_hw_watchpoints
condition|)
return|return
literal|0
return|;
comment|/* Make sure that the value of the expression depends only upon      memory contents, and values computed from them within GDB.  If we      find any register references or function calls, we can't use a      hardware watchpoint.       The idea here is that evaluating an expression generates a series      of values, one holding the value of every subexpression.  (The      expression a*b+c has five subexpressions: a, b, a*b, c, and      a*b+c.)  GDB's values hold almost enough information to establish      the criteria given above --- they identify memory lvalues,      register lvalues, computed values, etcetera.  So we can evaluate      the expression, and then scan the chain of values that leaves      behind to decide whether we can detect any possible change to the      expression's final value using only hardware watchpoints.       However, I don't think that the values returned by inferior      function calls are special in any way.  So this function may not      notice that an expression involving an inferior function call      can't be watched with hardware watchpoints.  FIXME.  */
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|==
name|lval_memory
condition|)
block|{
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
condition|)
comment|/* A lazy memory lvalue is one that GDB never needed to fetch; 	       we either just used its address (e.g., `a' in `a.b') or 	       we never needed it at all (e.g., `a' in `a,b').  */
empty_stmt|;
else|else
block|{
comment|/* Ahh, memory we actually used!  Check if we can cover                  it with hardware watchpoints.  */
name|struct
name|type
modifier|*
name|vtype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We only watch structs and arrays if user asked for it 		 explicitly, never if they just happen to appear in a 		 middle of some value chain.  */
if|if
condition|(
name|v
operator|==
name|head
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|vtype
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
condition|)
block|{
name|CORE_ADDR
name|vaddr
init|=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_REGION_OK_FOR_HW_WATCHPOINT
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|found_memory_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|lval
operator|!=
name|not_lval
operator|&&
name|v
operator|->
name|modifiable
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* ??? What does this represent? */
elseif|else
if|if
condition|(
name|v
operator|->
name|lval
operator|==
name|lval_register
condition|)
return|return
literal|0
return|;
comment|/* cannot watch a register with a HW watchpoint */
block|}
comment|/* The expression itself looks suitable for using a hardware      watchpoint, but give the target machine a chance to reject it.  */
return|return
name|found_memory_cnt
return|;
block|}
end_function

begin_function
name|void
name|watch_command_wrapper
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|watch_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|watch_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
name|hw_write
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rwatch_command_wrapper
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|rwatch_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rwatch_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
name|hw_read
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|awatch_command_wrapper
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|awatch_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awatch_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|watch_command_1
argument_list|(
name|arg
argument_list|,
name|hw_access
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routines for the until_command routine in infcmd.c.  Here    because it uses the mechanisms of breakpoints.  */
end_comment

begin_comment
comment|/* This function is called by fetch_inferior_event via the    cmd_continuation pointer, to complete the until command. It takes    care of cleaning up the temporary breakpoints set up by the until    command. */
end_comment

begin_function
specifier|static
name|void
name|until_break_command_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|cleanups
operator|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|arg
operator|->
name|data
operator|.
name|pointer
expr_stmt|;
name|do_exec_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|until_break_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|int
name|anywhere
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev_frame
init|=
name|get_prev_frame
argument_list|(
name|deprecated_selected_frame
argument_list|)
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|continuation_arg
modifier|*
name|arg1
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Set a breakpoint where the user wants it and at return from      this function */
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Couldn't get information on specified line."
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* malloc'd, so freed */
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
if|if
condition|(
name|anywhere
condition|)
comment|/* If the user told us to continue until a specified location,        we don't specify a frame at which we need to stop.  */
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|null_frame_id
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, specify the current frame, because we want to stop only        at the very same frame.  */
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|get_frame_id
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|old_chain
operator|=
name|make_cleanup_delete_breakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
else|else
name|old_chain
operator|=
name|make_exec_cleanup_delete_breakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
comment|/* If we are running asynchronously, and the target supports async      execution, we are not waiting for the target to stop, in the call      tp proceed, below. This means that we cannot delete the      brekpoints until the target has actually stopped. The only place      where we get a chance to do that is in fetch_inferior_event, so      we must set things up for that. */
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* In this case the arg for the continuation is just the point          in the exec_cleanups chain from where to start doing          cleanups, because all the continuation does is the cleanups in          the exec_cleanup_chain. */
name|arg1
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|arg1
operator|->
name|data
operator|.
name|pointer
operator|=
name|old_chain
expr_stmt|;
name|add_continuation
argument_list|(
name|until_break_command_continuation
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* Keep within the current frame, or in frames called by the current      one.  */
if|if
condition|(
name|prev_frame
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|get_frame_id
argument_list|(
name|prev_frame
argument_list|)
argument_list|,
name|bp_until
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|make_cleanup_delete_breakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
else|else
name|make_exec_cleanup_delete_breakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
block|}
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do the cleanups now, anly if we are not running asynchronously,      of if we are, but the target is still synchronous. */
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ep_skip_leading_whitespace
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|s
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
name|NULL
operator|)
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function examines a string, and attempts to find a token    that might be an event name in the leading characters.  If a    possible match is found, a pointer to the last character of    the token is returned.  Else, NULL is returned. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ep_find_event_name_end
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|event_name_end
init|=
name|NULL
decl_stmt|;
comment|/* If we could depend upon the presense of strrpbrk, we'd use that... */
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* We break out of the loop when we find a token delimiter.      Basically, we're looking for alphanumerics and underscores;      anything else delimites the token. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'_'
operator|)
condition|)
break|break;
name|event_name_end
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|event_name_end
return|;
block|}
end_function

begin_comment
comment|/* This function attempts to parse an optional "if<cond>" clause    from the arg string.  If one is not found, it returns NULL.     Else, it returns a pointer to the condition string.  (It does not    attempt to evaluate the string against a particular block.)  And,    it updates arg to point to the first character following the parsed    if clause in the arg string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ep_parse_optional_if_clause
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|cond_string
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|arg
operator|)
index|[
literal|0
index|]
operator|!=
literal|'i'
operator|)
operator|||
operator|(
operator|(
operator|*
name|arg
operator|)
index|[
literal|1
index|]
operator|!=
literal|'f'
operator|)
operator|||
operator|!
name|isspace
argument_list|(
operator|(
operator|*
name|arg
operator|)
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Skip the "if" keyword. */
operator|(
operator|*
name|arg
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* Skip any extra leading whitespace, and record the start of the      condition string. */
name|ep_skip_leading_whitespace
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
operator|*
name|arg
expr_stmt|;
comment|/* Assume that the condition occupies the remainder of the arg string. */
operator|(
operator|*
name|arg
operator|)
operator|+=
name|strlen
argument_list|(
name|cond_string
argument_list|)
expr_stmt|;
return|return
name|cond_string
return|;
block|}
end_function

begin_comment
comment|/* This function attempts to parse an optional filename from the arg    string.  If one is not found, it returns NULL.     Else, it returns a pointer to the parsed filename.  (This function    makes no attempt to verify that a file of that name exists, or is    accessible.)  And, it updates arg to point to the first character    following the parsed filename in the arg string.     Note that clients needing to preserve the returned filename for    future access should copy it to their own buffers. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ep_parse_optional_filename
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|char
name|filename
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|arg_p
init|=
operator|*
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg_p
operator|==
literal|'\0'
operator|)
operator|||
name|isspace
argument_list|(
operator|*
name|arg_p
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|arg_p
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
literal|'\0'
expr_stmt|;
name|filename
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
name|arg_p
operator|++
expr_stmt|;
block|}
operator|*
name|arg
operator|=
name|arg_p
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Commands to deal with catching events, such as signals, exceptions,    process start/exit, etc.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|catch_fork
block|,
name|catch_vfork
block|}
name|catch_fork_kind
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|catch_fork_command_1
parameter_list|(
name|catch_fork_kind
name|fork_kind
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:      catch [v]fork      catch [v]fork if<cond>       First, check if there's an if clause. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* If this target supports it, create a fork or vfork catchpoint      and enable reporting of such events. */
switch|switch
condition|(
name|fork_kind
condition|)
block|{
case|case
name|catch_fork
case|:
name|create_fork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|catch_vfork
case|:
name|create_vfork_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unsupported or unknown fork kind; cannot catch it"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|catch_exec_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:      catch exec      catch exec if<cond>       First, check if there's an if clause. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* If this target supports it, create an exec catchpoint      and enable reporting of such events. */
name|create_exec_event_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_load_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|dll_pathname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:      catch load      catch load if<cond>      catch load<filename>      catch load<filename> if<cond>       The user is not allowed to specify the<filename> after an      if clause.       We'll ignore the pathological case of a file named "if".       First, check if there's an if clause.  If so, then there      cannot be a filename. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If there was an if clause, then there cannot be a filename.      Else, there might be a filename and an if clause. */
if|if
condition|(
name|cond_string
operator|==
name|NULL
condition|)
block|{
name|dll_pathname
operator|=
name|ep_parse_optional_filename
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* Create a load breakpoint that only triggers when a load of      the specified dll (or any dll, if no pathname was specified)      occurs. */
name|SOLIB_CREATE_CATCH_LOAD_HOOK
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_unload_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|dll_pathname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* The allowed syntax is:      catch unload      catch unload if<cond>      catch unload<filename>      catch unload<filename> if<cond>       The user is not allowed to specify the<filename> after an      if clause.       We'll ignore the pathological case of a file named "if".       First, check if there's an if clause.  If so, then there      cannot be a filename. */
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If there was an if clause, then there cannot be a filename.      Else, there might be a filename and an if clause. */
if|if
condition|(
name|cond_string
operator|==
name|NULL
condition|)
block|{
name|dll_pathname
operator|=
name|ep_parse_optional_filename
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
comment|/* Create an unload breakpoint that only triggers when an unload of      the specified dll (or any dll, if no pathname was specified)      occurs. */
name|SOLIB_CREATE_CATCH_UNLOAD_HOOK
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|tempflag
argument_list|,
name|dll_pathname
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commands to deal with catching exceptions.  */
end_comment

begin_comment
comment|/* Set a breakpoint at the specified callback routine for an    exception event callback */
end_comment

begin_function
specifier|static
name|void
name|create_exception_catchpoint
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|exception_event_kind
name|ex_event
parameter_list|,
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All threads. */
name|enum
name|bptype
name|bptype
decl_stmt|;
if|if
condition|(
operator|!
name|sal
condition|)
comment|/* no exception support? */
return|return;
switch|switch
condition|(
name|ex_event
condition|)
block|{
case|case
name|EX_EVENT_THROW
case|:
name|bptype
operator|=
name|bp_catch_throw
expr_stmt|;
break|break;
case|case
name|EX_EVENT_CATCH
case|:
name|bptype
operator|=
name|bp_catch_catch
expr_stmt|;
break|break;
default|default:
comment|/* error condition */
name|error
argument_list|(
literal|"Internal error -- invalid catchpoint kind"
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
operator|*
name|sal
argument_list|,
name|bptype
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|print_stop_action
name|print_exception_catchpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
name|annotate_catchpoint
argument_list|(
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|b
operator|->
name|addr_string
argument_list|,
literal|"throw"
argument_list|)
operator|!=
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exception thrown)\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"\nCatchpoint %d (exception caught)\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
return|return
name|PRINT_SRC_AND_LOC
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_one_exception_catchpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|,
name|CORE_ADDR
modifier|*
name|last_addr
parameter_list|)
block|{
if|if
condition|(
name|addressprint
condition|)
block|{
name|annotate_field
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|b
operator|->
name|loc
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|annotate_field
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|last_addr
operator|=
name|b
operator|->
name|loc
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|b
operator|->
name|addr_string
argument_list|,
literal|"throw"
argument_list|)
operator|!=
name|NULL
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
literal|"exception throw"
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"what"
argument_list|,
literal|"exception catch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_mention_exception_catchpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|b
operator|->
name|addr_string
argument_list|,
literal|"throw"
argument_list|)
operator|!=
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (throw)"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Catchpoint %d (catch)"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|breakpoint_ops
name|gnu_v3_exception_catchpoint_ops
init|=
block|{
name|print_exception_catchpoint
block|,
name|print_one_exception_catchpoint
block|,
name|print_mention_exception_catchpoint
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|handle_gnu_v3_exceptions
parameter_list|(
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|,
name|enum
name|exception_event_kind
name|ex_event
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|trigger_func_name
decl_stmt|,
modifier|*
name|nameptr
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|ex_event
operator|==
name|EX_EVENT_CATCH
condition|)
name|trigger_func_name
operator|=
name|xstrdup
argument_list|(
literal|"__cxa_begin_catch"
argument_list|)
expr_stmt|;
else|else
name|trigger_func_name
operator|=
name|xstrdup
argument_list|(
literal|"__cxa_throw"
argument_list|)
expr_stmt|;
name|nameptr
operator|=
name|trigger_func_name
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|nameptr
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|trigger_func_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
name|bp_breakpoint
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|cond_string
operator|=
operator|(
name|cond_string
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|cond_string
argument_list|,
name|strlen
argument_list|(
name|cond_string
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|addr_string
operator|=
name|trigger_func_name
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|b
operator|->
name|disposition
operator|=
name|tempflag
condition|?
name|disp_del
else|:
name|disp_donttouch
expr_stmt|;
name|b
operator|->
name|ops
operator|=
operator|&
name|gnu_v3_exception_catchpoint_ops
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Deal with "catch catch" and "catch throw" commands */
end_comment

begin_function
specifier|static
name|void
name|catch_exception_command_1
parameter_list|(
name|enum
name|exception_event_kind
name|ex_event
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|cond_string
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab_and_line
modifier|*
name|sal
init|=
name|NULL
decl_stmt|;
name|ep_skip_leading_whitespace
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|cond_string
operator|=
name|ep_parse_optional_if_clause
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ex_event
operator|!=
name|EX_EVENT_THROW
operator|)
operator|&&
operator|(
name|ex_event
operator|!=
name|EX_EVENT_CATCH
operator|)
condition|)
name|error
argument_list|(
literal|"Unsupported or unknown exception event; cannot catch it"
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle_gnu_v3_exceptions
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|ex_event
argument_list|,
name|from_tty
argument_list|)
condition|)
return|return;
comment|/* See if we can find a callback routine */
name|sal
operator|=
name|target_enable_exception_callback
argument_list|(
name|ex_event
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
condition|)
block|{
comment|/* We have callbacks from the runtime system for exceptions.          Set a breakpoint on the sal found, if no errors */
if|if
condition|(
name|sal
operator|!=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
operator|-
literal|1
condition|)
name|create_exception_catchpoint
argument_list|(
name|tempflag
argument_list|,
name|cond_string
argument_list|,
name|ex_event
argument_list|,
name|sal
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* something went wrong with setting up callbacks */
block|}
name|warning
argument_list|(
literal|"Unsupported with this platform/compiler combination."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cover routine to allow wrapping target_enable_exception_catchpoints    inside a catch_errors */
end_comment

begin_function
specifier|static
name|int
name|cover_target_enable_exception_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|args_for_catchpoint_enable
modifier|*
name|args
init|=
name|arg
decl_stmt|;
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
name|sal
operator|=
name|target_enable_exception_callback
argument_list|(
name|args
operator|->
name|kind
argument_list|,
name|args
operator|->
name|enable_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|sal
operator|==
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
comment|/*is valid */
block|}
end_function

begin_function
specifier|static
name|void
name|catch_command_1
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* The first argument may be an event name, such as "start" or "load".      If so, then handle it as such.  If it doesn't match an event name,      then attempt to interpret it as an exception name.  (This latter is      the v4.16-and-earlier GDB meaning of the "catch" command.)       First, try to find the bounds of what might be an event name. */
name|char
modifier|*
name|arg1_start
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|arg1_end
decl_stmt|;
name|int
name|arg1_length
decl_stmt|;
if|if
condition|(
name|arg1_start
operator|==
name|NULL
condition|)
block|{
comment|/* Old behaviour was to use pre-v-4.16 syntax */
comment|/* catch_throw_command_1 (arg1_start, tempflag, from_tty); */
comment|/* return; */
comment|/* Now, this is not allowed */
name|error
argument_list|(
literal|"Catch requires an event name."
argument_list|)
expr_stmt|;
block|}
name|arg1_end
operator|=
name|ep_find_event_name_end
argument_list|(
name|arg1_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1_end
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"catch requires an event"
argument_list|)
expr_stmt|;
name|arg1_length
operator|=
name|arg1_end
operator|+
literal|1
operator|-
name|arg1_start
expr_stmt|;
comment|/* Try to match what we found against known event names. */
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"signal"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of signal not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"catch"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_exception_command_1
argument_list|(
name|EX_EVENT_CATCH
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"throw"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_exception_command_1
argument_list|(
name|EX_EVENT_THROW
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"thread_start"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of thread_start not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"thread_exit"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of thread_exit not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"thread_join"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of thread_join not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"start"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of start not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"exit"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of exit not yet implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"fork"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_fork_command_1
argument_list|(
name|catch_fork
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"vfork"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_fork_command_1
argument_list|(
name|catch_vfork
argument_list|,
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"exec"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_exec_command_1
argument_list|(
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"load"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_load_command_1
argument_list|(
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"unload"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catch_unload_command_1
argument_list|(
name|arg1_end
operator|+
literal|1
argument_list|,
name|tempflag
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg1_start
argument_list|,
literal|"stop"
argument_list|,
name|arg1_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Catch of stop not yet implemented"
argument_list|)
expr_stmt|;
block|}
comment|/* This doesn't appear to be an event name */
else|else
block|{
comment|/* Pre-v.4.16 behaviour was to treat the argument          as the name of an exception */
comment|/* catch_throw_command_1 (arg1_start, tempflag, from_tty); */
comment|/* Now this is not allowed */
name|error
argument_list|(
literal|"Unknown event kind specified for catch"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used by the gui, could be made a worker for other things. */
end_comment

begin_function
name|struct
name|breakpoint
modifier|*
name|set_breakpoint_sal
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|,
name|bp_breakpoint
argument_list|)
expr_stmt|;
name|set_breakpoint_count
argument_list|(
name|breakpoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|catch_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tcatch_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|catch_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete breakpoints by address or line.  */
end_comment

begin_function
specifier|static
name|void
name|clear_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|int
name|default_match
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|default_match
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|default_match
operator|=
literal|1
expr_stmt|;
block|}
comment|/* For each line spec given, delete bps which correspond      to it.  Do it in two passes, solely to preserve the current      behavior that from_tty is forced true if we delete more than      one breakpoint.  */
name|found
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* If exact pc given, clear bpts at that pc.          If line given (pc == 0), clear all bpts on specified line.          If defaulting, clear all bpts on default line          or at default pc.           defaulting    sal.pc != 0    tests to do           0              1             pc          1              1             pc _and_ line          0              0             line          1              0<can't happen> */
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* Find all matching breakpoints, remove them from the 	 breakpoint chain, and add them to the 'found' chain.  */
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|tmp
argument_list|)
block|{
comment|/* Are we going to delete b? */
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_none
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_access_watchpoint
comment|/* Not if b is a watchpoint of any sort... */
operator|&&
operator|(
operator|(
operator|(
name|sal
operator|.
name|pc
operator|&&
operator|(
name|b
operator|->
name|loc
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
operator|)
operator|)
operator|&&
operator|(
operator|!
name|section_is_overlay
argument_list|(
name|b
operator|->
name|loc
operator|->
name|section
argument_list|)
operator|||
name|b
operator|->
name|loc
operator|->
name|section
operator|==
name|sal
operator|.
name|section
operator|)
operator|)
comment|/* Yes, if sal.pc matches b (modulo overlays).  */
operator|||
operator|(
operator|(
name|default_match
operator|||
operator|(
literal|0
operator|==
name|sal
operator|.
name|pc
operator|)
operator|)
operator|&&
name|b
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|b
operator|->
name|source_file
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|&&
name|b
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
comment|/* Yes, if sal source file and line matches b.  */
block|{
comment|/* Remove it from breakpoint_chain...  */
if|if
condition|(
name|b
operator|==
name|breakpoint_chain
condition|)
block|{
comment|/* b is at the head of the list */
name|breakpoint_chain
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|next
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
comment|/* And add it to 'found' chain.  */
name|b
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep b, and keep a pointer to it.  */
name|prev
operator|=
name|b
expr_stmt|;
block|}
block|}
block|}
comment|/* Now go thru the 'found' chain and delete them.  */
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"No breakpoint at %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No breakpoint at this line."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|->
name|next
condition|)
name|from_tty
operator|=
literal|1
expr_stmt|;
comment|/* Always report if deleted more than one */
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Deleted breakpoint%s "
argument_list|,
name|found
operator|->
name|next
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
while|while
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"%d "
argument_list|,
name|found
operator|->
name|number
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|found
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete breakpoint in BS if they are `delete' breakpoints and    all breakpoints that are marked for deletion, whether hit or not.    This is called after any breakpoint is hit, or after errors.  */
end_comment

begin_function
name|void
name|breakpoint_auto_delete
parameter_list|(
name|bpstat
name|bs
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
for|for
control|(
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|&&
name|bs
operator|->
name|breakpoint_at
operator|->
name|disposition
operator|==
name|disp_del
operator|&&
name|bs
operator|->
name|stop
condition|)
name|delete_breakpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|disposition
operator|==
name|disp_del_at_next_stop
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete a breakpoint and clean up all traces of it in the data    structures. */
end_comment

begin_function
name|void
name|delete_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|bpstat
name|bs
decl_stmt|;
name|struct
name|bp_location
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|bpt
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error (attempted to delete a NULL breakpoint)"
argument_list|)
expr_stmt|;
comment|/* Has this bp already been deleted?  This can happen because multiple      lists can hold pointers to bp's.  bpstat lists are especial culprits.       One example of this happening is a watchpoint's scope bp.  When the      scope bp triggers, we notice that the watchpoint is out of scope, and      delete it.  We also delete its scope bp.  But the scope bp is marked      "auto-deleting", and is already on a bpstat.  That bpstat is then      checked for auto-deleting bp's, which are deleted.       A real solution to this problem might involve reference counts in bp's,      and/or giving them pointers back to their referencing bpstat's, and      teaching delete_breakpoint to only free a bp's storage when no more      references were extent.  A cheaper bandaid was chosen. */
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_none
condition|)
return|return;
if|if
condition|(
name|delete_breakpoint_hook
condition|)
name|delete_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
name|breakpoint_delete_event
argument_list|(
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|loc
operator|->
name|inserted
condition|)
name|remove_breakpoint
argument_list|(
name|bpt
operator|->
name|loc
argument_list|,
name|mark_inserted
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_chain
operator|==
name|bpt
condition|)
name|breakpoint_chain
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bp_location_chain
operator|==
name|bpt
operator|->
name|loc
condition|)
name|bp_location_chain
operator|=
name|bpt
operator|->
name|loc
operator|->
name|next
expr_stmt|;
comment|/* If we have callback-style exception catchpoints, don't go through      the adjustments to the C++ runtime library etc. if the inferior      isn't actually running.  target_enable_exception_callback for a      null target ops vector gives an undesirable error message, so we      check here and avoid it. Since currently (1997-09-17) only HP-UX aCC's      exceptions are supported in this way, it's OK for now. FIXME */
if|if
condition|(
name|ep_is_exception_catchpoint
argument_list|(
name|bpt
argument_list|)
operator|&&
name|target_has_execution
condition|)
block|{
comment|/* Format possible error msg */
name|char
modifier|*
name|message
init|=
name|xstrprintf
argument_list|(
literal|"Error in deleting catchpoint %d:\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|args_for_catchpoint_enable
name|args
decl_stmt|;
name|args
operator|.
name|kind
operator|=
name|bpt
operator|->
name|type
operator|==
name|bp_catch_catch
condition|?
name|EX_EVENT_CATCH
else|:
name|EX_EVENT_THROW
expr_stmt|;
name|args
operator|.
name|enable_p
operator|=
literal|0
expr_stmt|;
name|catch_errors
argument_list|(
name|cover_target_enable_exception_callback
argument_list|,
operator|&
name|args
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|next
operator|==
name|bpt
condition|)
block|{
name|b
operator|->
name|next
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|ALL_BP_LOCATIONS
argument_list|(
argument|loc
argument_list|)
if|if
condition|(
name|loc
operator|->
name|next
operator|==
name|bpt
operator|->
name|loc
condition|)
block|{
name|loc
operator|->
name|next
operator|=
name|bpt
operator|->
name|loc
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|check_duplicates
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
comment|/* If this breakpoint was inserted, and there is another breakpoint      at the same address, we need to insert the other breakpoint.  */
if|if
condition|(
name|bpt
operator|->
name|loc
operator|->
name|inserted
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_hardware_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_read_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_access_watchpoint
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_catch_fork
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_catch_vfork
operator|&&
name|bpt
operator|->
name|type
operator|!=
name|bp_catch_exec
condition|)
block|{
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|loc
operator|->
name|address
operator|==
name|bpt
operator|->
name|loc
operator|->
name|address
operator|&&
name|b
operator|->
name|loc
operator|->
name|section
operator|==
name|bpt
operator|->
name|loc
operator|->
name|section
operator|&&
operator|!
name|b
operator|->
name|loc
operator|->
name|duplicate
operator|&&
name|b
operator|->
name|enable_state
operator|!=
name|bp_disabled
operator|&&
name|b
operator|->
name|enable_state
operator|!=
name|bp_shlib_disabled
operator|&&
operator|!
name|b
operator|->
name|pending
operator|&&
name|b
operator|->
name|enable_state
operator|!=
name|bp_call_disabled
condition|)
block|{
name|int
name|val
decl_stmt|;
comment|/* We should never reach this point if there is a permanent 	     breakpoint at the same address as the one being deleted. 	     If there is a permanent breakpoint somewhere, it should 	     always be the only one inserted.  */
if|if
condition|(
name|b
operator|->
name|enable_state
operator|==
name|bp_permanent
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"another breakpoint was inserted on top of "
literal|"a permanent breakpoint"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|val
operator|=
name|target_insert_hw_breakpoint
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
name|b
operator|->
name|loc
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_insert_breakpoint
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
name|b
operator|->
name|loc
operator|->
name|shadow_contents
argument_list|)
expr_stmt|;
comment|/* If there was an error in the insert, print a message, then stop execution.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|struct
name|ui_file
modifier|*
name|tmp_error_stream
init|=
name|mem_fileopen
argument_list|()
decl_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_error_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert hardware breakpoint %d.\n"
literal|"You may have requested too many hardware breakpoints.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Cannot insert breakpoint %d.\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"Error accessing memory address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|b
operator|->
name|loc
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|tmp_error_stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|": %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|tmp_error_stream
argument_list|,
literal|"The same program may be running in another process."
argument_list|)
expr_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|error_stream
argument_list|(
name|tmp_error_stream
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|->
name|loc
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
operator|&
name|bpt
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|cond_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|addr_string
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exp
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exp_string
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|exp_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|val
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|source_file
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|dll_pathname
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|dll_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|triggered_dll_pathname
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|triggered_dll_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|exec_pathname
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|bpt
operator|->
name|exec_pathname
argument_list|)
expr_stmt|;
comment|/* Be sure no bpstat's are pointing at it after it's been freed.  */
comment|/* FIXME, how can we find all bpstat's?      We just check stop_bpstat for now.  */
for|for
control|(
name|bs
operator|=
name|stop_bpstat
init|;
name|bs
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
if|if
condition|(
name|bs
operator|->
name|breakpoint_at
operator|==
name|bpt
condition|)
block|{
name|bs
operator|->
name|breakpoint_at
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|old_val
operator|=
name|NULL
expr_stmt|;
comment|/* bs->commands will be freed later.  */
block|}
comment|/* On the chance that someone will soon try again to delete this same      bp, we mark it as deleted before freeing its storage. */
name|bpt
operator|->
name|type
operator|=
name|bp_none
expr_stmt|;
name|xfree
argument_list|(
name|bpt
operator|->
name|loc
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_delete_breakpoint_cleanup
parameter_list|(
name|void
modifier|*
name|b
parameter_list|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_delete_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_delete_breakpoint_cleanup
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_exec_cleanup_delete_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
return|return
name|make_exec_cleanup
argument_list|(
name|do_delete_breakpoint_cleanup
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|delete_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|int
name|breaks_to_delete
init|=
literal|0
decl_stmt|;
comment|/* Delete all breakpoints if no argument.          Do not delete internal or call-dummy breakpoints, these          have to be deleted with an explicit breakpoint number argument.  */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_call_dummy
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_shlib_event
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_thread_event
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_overlay_event
operator|&&
name|b
operator|->
name|number
operator|>=
literal|0
condition|)
name|breaks_to_delete
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ask user only if there are some breakpoints to delete.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
operator|(
name|breaks_to_delete
operator|&&
name|query
argument_list|(
literal|"Delete all breakpoints? "
argument_list|)
operator|)
condition|)
block|{
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
if|if
condition|(
name|b
operator|->
name|type
operator|!=
name|bp_call_dummy
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_shlib_event
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_thread_event
operator|&&
name|b
operator|->
name|type
operator|!=
name|bp_overlay_event
operator|&&
name|b
operator|->
name|number
operator|>=
literal|0
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|arg
argument_list|,
name|delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset a breakpoint given it's struct breakpoint * BINT.    The value we return ends up being the return value from catch_errors.    Unused in this case.  */
end_comment

begin_function
specifier|static
name|int
name|breakpoint_re_set_one
parameter_list|(
name|void
modifier|*
name|bint
parameter_list|)
block|{
comment|/* get past catch_errs */
name|struct
name|breakpoint
modifier|*
name|b
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|bint
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|enable_state
name|save_enable
decl_stmt|;
switch|switch
condition|(
name|b
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|warning
argument_list|(
literal|"attempted to reset apparently deleted breakpoint #%d?"
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
if|if
condition|(
name|b
operator|->
name|addr_string
operator|==
name|NULL
condition|)
block|{
comment|/* Anything without a string can't be re-set. */
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* HACK: cagney/2001-11-11: kettenis/2001-11-11: MarkK wrote:  	 ``And a hack it is, although Apple's Darwin version of GDB 	 contains an almost identical hack to implement a "future 	 break" command.  It seems to work in many real world cases, 	 but it is easy to come up with a test case where the patch 	 doesn't help at all.''  	 ``It seems that the way GDB implements breakpoints - in - 	 shared - libraries was designed for a.out shared library 	 systems (SunOS 4) where shared libraries were loaded at a 	 fixed address in memory.  Since ELF shared libraries can (and 	 will) be loaded at any address in memory, things break. 	 Fixing this is not trivial.  Therefore, I'm not sure whether 	 we should add this hack to the branch only.  I cannot 	 guarantee that things will be fixed on the trunk in the near 	 future.''           In case we have a problem, disable this breakpoint.  We'll          restore its status if we succeed.  Don't disable a          shlib_disabled breakpoint though.  There's a fair chance we          can't re-set it if the shared library it's in hasn't been          loaded yet.  */
if|if
condition|(
name|b
operator|->
name|pending
condition|)
break|break;
name|save_enable
operator|=
name|b
operator|->
name|enable_state
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|enable_state
operator|!=
name|bp_shlib_disabled
condition|)
name|b
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|set_language
argument_list|(
name|b
operator|->
name|language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|b
operator|->
name|input_radix
expr_stmt|;
name|s
operator|=
name|b
operator|->
name|addr_string
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Reparse conditions, they might contain references to the 	     old symtab.  */
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|xfree
argument_list|(
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
comment|/* Avoid re-freeing b->exp if an error during the call 		     to parse_exp_1.  */
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We need to re-set the breakpoint if the address changes... */
if|if
condition|(
name|b
operator|->
name|loc
operator|->
name|address
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
comment|/* ...or new and old breakpoints both have source files, and 	     the source file name or the line number changes...  */
operator|||
operator|(
name|b
operator|->
name|source_file
operator|!=
name|NULL
operator|&&
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|source_file
argument_list|,
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|)
operator|!=
literal|0
operator|||
name|b
operator|->
name|line_number
operator|!=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
operator|)
operator|)
comment|/* ...or we switch between having a source file and not having 	     one.  */
operator|||
operator|(
operator|(
name|b
operator|->
name|source_file
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|source_file
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|b
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|b
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|b
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|loc
operator|->
name|requested_address
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|b
operator|->
name|loc
operator|->
name|address
operator|=
name|adjust_breakpoint_address
argument_list|(
name|b
operator|->
name|loc
operator|->
name|requested_address
argument_list|)
expr_stmt|;
comment|/* Used to check for duplicates here, but that can 	         cause trouble, as it doesn't check for disabled 	         breakpoints. */
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Might be better to do this just once per breakpoint_re_set, 	         rather than once for every breakpoint.  */
name|breakpoints_changed
argument_list|()
expr_stmt|;
block|}
name|b
operator|->
name|loc
operator|->
name|section
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|section
expr_stmt|;
name|b
operator|->
name|enable_state
operator|=
name|save_enable
expr_stmt|;
comment|/* Restore it, this worked. */
comment|/* Now that this is re-enabled, check_duplicates 	     can be used. */
name|check_duplicates
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|innermost_block
operator|=
name|NULL
expr_stmt|;
comment|/* The issue arises of what context to evaluate this in.  The          same one as when it was set, but what does that mean when          symbols have been re-read?  We could save the filename and          functionname, but if the context is more local than that, the          best we could do would be something like how many levels deep          and which index at that particular level, but that's going to          be less stable than filenames or function names.  */
comment|/* So for now, just use a global context.  */
if|if
condition|(
name|b
operator|->
name|exp
condition|)
block|{
name|xfree
argument_list|(
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
comment|/* Avoid re-freeing b->exp if an error during the call to              parse_expression.  */
name|b
operator|->
name|exp
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|->
name|exp
operator|=
name|parse_expression
argument_list|(
name|b
operator|->
name|exp_string
argument_list|)
expr_stmt|;
name|b
operator|->
name|exp_valid_block
operator|=
name|innermost_block
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|val
condition|)
block|{
name|value_free
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* Avoid re-freeing b->val if an error during the call to              evaluate_expression.  */
name|b
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|b
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|b
operator|->
name|val
argument_list|)
operator|&&
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|b
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond_string
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|b
operator|->
name|cond_string
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|xfree
argument_list|(
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
comment|/* Avoid re-freeing b->exp if an error during the call 		 to parse_exp_1.  */
name|b
operator|->
name|cond
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|->
name|cond
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|breakpoint_enabled
argument_list|(
name|b
argument_list|)
condition|)
name|mention
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
break|break;
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
break|break;
comment|/* We needn't really do anything to reset these, since the mask          that requests them is unaffected by e.g., new libraries being          loaded. */
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Deleting unknown breakpoint type %d\n"
argument_list|,
name|b
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* fall through */
comment|/* Delete longjmp and overlay event breakpoints; they will be          reset later by breakpoint_re_set.  */
case|case
name|bp_longjmp
case|:
case|case
name|bp_longjmp_resume
case|:
case|case
name|bp_overlay_event
case|:
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
comment|/* This breakpoint is special, it's set up when the inferior          starts and we really don't want to touch it.  */
case|case
name|bp_shlib_event
case|:
comment|/* Like bp_shlib_event, this breakpoint type is special. 	 Once it is set up, we do not want to touch it.  */
case|case
name|bp_thread_event
case|:
comment|/* Keep temporary breakpoints, which can be encountered when we step          over a dlopen call and SOLIB_ADD is resetting the breakpoints.          Otherwise these should have been blown away via the cleanup chain          or by breakpoint_init_inferior when we rerun the executable.  */
case|case
name|bp_until
case|:
case|case
name|bp_finish
case|:
case|case
name|bp_watchpoint_scope
case|:
case|case
name|bp_call_dummy
case|:
case|case
name|bp_step_resume
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Re-set all breakpoints after symbols have been re-loaded.  */
end_comment

begin_function
name|void
name|breakpoint_re_set
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|enum
name|language
name|save_language
decl_stmt|;
name|int
name|save_input_radix
decl_stmt|;
name|save_language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|save_input_radix
operator|=
name|input_radix
expr_stmt|;
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|temp
argument_list|)
block|{
comment|/* Format possible error msg */
name|char
modifier|*
name|message
init|=
name|xstrprintf
argument_list|(
literal|"Error in re-setting breakpoint %d:\n"
argument_list|,
name|b
operator|->
name|number
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|catch_errors
argument_list|(
name|breakpoint_re_set_one
argument_list|,
name|b
argument_list|,
name|message
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
name|set_language
argument_list|(
name|save_language
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|save_input_radix
expr_stmt|;
if|if
condition|(
name|GET_LONGJMP_TARGET_P
argument_list|()
condition|)
block|{
name|create_longjmp_breakpoint
argument_list|(
literal|"longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"_longjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"siglongjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
literal|"_siglongjmp"
argument_list|)
expr_stmt|;
name|create_longjmp_breakpoint
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|create_overlay_event_breakpoint
argument_list|(
literal|"_ovly_debug_event"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reset the thread number of this breakpoint:     - If the breakpoint is for all threads, leave it as-is.    - Else, reset it to the current thread for inferior_ptid. */
end_comment

begin_function
name|void
name|breakpoint_re_set_thread
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|thread
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|in_thread_list
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|b
operator|->
name|thread
operator|=
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set ignore-count of breakpoint number BPTNUM to COUNT.    If from_tty is nonzero, it prints a message to that effect,    which ends with a period (no newline).  */
end_comment

begin_function
name|void
name|set_ignore_count
parameter_list|(
name|int
name|bptnum
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bptnum
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Will stop next time breakpoint %d is reached."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"Will ignore next crossing of breakpoint %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Will ignore next %d crossings of breakpoint %d."
argument_list|,
name|count
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
block|}
name|breakpoints_changed
argument_list|()
expr_stmt|;
name|breakpoint_modify_event
argument_list|(
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the ignore counts of all breakpoints.  */
end_comment

begin_function
name|void
name|breakpoint_clear_ignore_counts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command to set ignore-count of breakpoint N to COUNT.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"a breakpoint number"
argument_list|)
expr_stmt|;
name|num
operator|=
name|get_number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"bad breakpoint number: '%s'"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Second argument (specified ignore-count) is missing."
argument_list|)
expr_stmt|;
name|set_ignore_count
argument_list|(
name|num
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|parse_and_eval
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUNCTION on each of the breakpoints    whose numbers are given in ARGS.  */
end_comment

begin_function
specifier|static
name|void
name|map_breakpoint_numbers
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|num
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|match
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more breakpoint numbers"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|num
operator|=
name|get_number_or_range
argument_list|(
operator|&
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"bad breakpoint number at or near '%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ALL_BREAKPOINTS_SAFE
argument_list|(
argument|b
argument_list|,
argument|tmp
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|related_breakpoint
init|=
name|b
operator|->
name|related_breakpoint
decl_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
name|function
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|related_breakpoint
condition|)
name|function
argument_list|(
name|related_breakpoint
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"No breakpoint number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set ignore-count of breakpoint number BPTNUM to COUNT.    If from_tty is nonzero, it prints a message to that effect,    which ends with a period (no newline).  */
end_comment

begin_function
name|void
name|disable_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
comment|/* Never disable a watchpoint scope breakpoint; we want to      hit them when we leave scope so we can delete both the      watchpoint and its scope breakpoint at that time.  */
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint_scope
condition|)
return|return;
comment|/* You can't disable permanent breakpoints.  */
if|if
condition|(
name|bpt
operator|->
name|enable_state
operator|==
name|bp_permanent
condition|)
return|return;
name|bpt
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|modify_breakpoint_hook
condition|)
name|modify_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
name|breakpoint_modify_event
argument_list|(
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|warning
argument_list|(
literal|"attempted to disable apparently deleted breakpoint #%d?"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|disable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|disable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_enable_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|,
name|enum
name|bpdisp
name|disposition
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|save_selected_frame
init|=
name|NULL
decl_stmt|;
name|int
name|save_selected_frame_level
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|target_resources_ok
decl_stmt|,
name|other_type_used
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|hw_breakpoint_used_count
argument_list|()
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bp_hardware_breakpoint
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_resources_ok
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No hardware breakpoint support in the target."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Hardware breakpoints used exceeds limit."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bpt
operator|->
name|pending
condition|)
block|{
if|if
condition|(
name|bpt
operator|->
name|enable_state
operator|!=
name|bp_enabled
condition|)
block|{
comment|/* When enabling a pending breakpoint, we need to check if the breakpoint 	     is resolvable since shared libraries could have been loaded 	     after the breakpoint was disabled.  */
name|breakpoints_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|resolve_pending_breakpoint
argument_list|(
name|bpt
argument_list|)
operator|==
name|GDB_RC_OK
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
return|return;
block|}
name|bpt
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|disposition
expr_stmt|;
block|}
block|}
else|else
comment|/* Not a pending breakpoint.  */
block|{
if|if
condition|(
name|bpt
operator|->
name|enable_state
operator|!=
name|bp_permanent
condition|)
name|bpt
operator|->
name|enable_state
operator|=
name|bp_enabled
expr_stmt|;
name|bpt
operator|->
name|disposition
operator|=
name|disposition
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
name|breakpoints_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
if|if
condition|(
name|bpt
operator|->
name|exp_valid_block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fr
init|=
name|fr
operator|=
name|frame_find_by_id
argument_list|(
name|bpt
operator|->
name|watchpoint_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because the block in which its expression\n\ is valid is not currently in scope.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
return|return;
block|}
name|save_selected_frame
operator|=
name|deprecated_selected_frame
expr_stmt|;
name|save_selected_frame_level
operator|=
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|fr
argument_list|)
expr_stmt|;
block|}
name|value_free
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
name|mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|bpt
operator|->
name|val
operator|=
name|evaluate_expression
argument_list|(
name|bpt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|type
operator|==
name|bp_hardware_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_read_watchpoint
operator|||
name|bpt
operator|->
name|type
operator|==
name|bp_access_watchpoint
condition|)
block|{
name|int
name|i
init|=
name|hw_watchpoint_used_count
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
operator|&
name|other_type_used
argument_list|)
decl_stmt|;
name|int
name|mem_cnt
init|=
name|can_use_hardware_watchpoint
argument_list|(
name|bpt
operator|->
name|val
argument_list|)
decl_stmt|;
comment|/* Hack around 'unused var' error for some targets here */
operator|(
name|void
operator|)
name|mem_cnt
operator|,
name|i
expr_stmt|;
name|target_resources_ok
operator|=
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|bpt
operator|->
name|type
argument_list|,
name|i
operator|+
name|mem_cnt
argument_list|,
name|other_type_used
argument_list|)
expr_stmt|;
comment|/* we can consider of type is bp_hardware_watchpoint, convert to  		 bp_watchpoint in the following condition */
if|if
condition|(
name|target_resources_ok
operator|<
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Cannot enable watchpoint %d because target watch resources\n\ have been allocated for other watchpoints.\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|bpt
operator|->
name|enable_state
operator|=
name|bp_disabled
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|save_selected_frame_level
operator|>=
literal|0
condition|)
name|select_frame
argument_list|(
name|save_selected_frame
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|modify_breakpoint_hook
condition|)
name|modify_breakpoint_hook
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
name|breakpoint_modify_event
argument_list|(
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enable_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
name|do_enable_breakpoint
argument_list|(
name|bpt
argument_list|,
name|bpt
operator|->
name|disposition
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The enable command enables the specified breakpoints (or all defined    breakpoints) so they once again become (or continue to be) effective    in stopping the inferior. */
end_comment

begin_function
specifier|static
name|void
name|enable_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
switch|switch
condition|(
name|bpt
operator|->
name|type
condition|)
block|{
case|case
name|bp_none
case|:
name|warning
argument_list|(
literal|"attempted to enable apparently deleted breakpoint #%d?"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|bp_breakpoint
case|:
case|case
name|bp_catch_load
case|:
case|case
name|bp_catch_unload
case|:
case|case
name|bp_catch_fork
case|:
case|case
name|bp_catch_vfork
case|:
case|case
name|bp_catch_exec
case|:
case|case
name|bp_catch_catch
case|:
case|case
name|bp_catch_throw
case|:
case|case
name|bp_hardware_breakpoint
case|:
case|case
name|bp_watchpoint
case|:
case|case
name|bp_hardware_watchpoint
case|:
case|case
name|bp_read_watchpoint
case|:
case|case
name|bp_access_watchpoint
case|:
name|enable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
name|do_enable_breakpoint
argument_list|(
name|bpt
argument_list|,
name|disp_disable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_once_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_breakpoint
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
block|{
name|do_enable_breakpoint
argument_list|(
name|bpt
argument_list|,
name|disp_del
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_breakpoint_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|show_breakpoint_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Use default_breakpoint_'s, or nothing if they aren't valid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec_1
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|funfirstline
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|breakpoint_set_cmdlist
decl_stmt|;
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|breakpoint_show_cmdlist
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|breakpoint_chain
operator|=
literal|0
expr_stmt|;
comment|/* Don't bother to call set_breakpoint_count.  $bpnum isn't useful      before a breakpoint is set.  */
name|breakpoint_count
operator|=
literal|0
expr_stmt|;
name|add_com
argument_list|(
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
name|ignore_command
argument_list|,
literal|"Set ignore-count of breakpoint number N to COUNT.\n\ Usage is `ignore N COUNT'."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"bc"
argument_list|,
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"commands"
argument_list|,
name|class_breakpoint
argument_list|,
name|commands_command
argument_list|,
literal|"Set commands to be executed when a breakpoint is hit.\n\ Give breakpoint number as argument after \"commands\".\n\ With no argument, the targeted breakpoint is the last one set.\n\ The commands themselves follow starting on the next line.\n\ Type a line containing \"end\" to indicate the end of them.\n\ Give \"silent\" as the first line to make the breakpoint silent;\n\ then no output is printed when it is hit, except what the commands print."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"condition"
argument_list|,
name|class_breakpoint
argument_list|,
name|condition_command
argument_list|,
literal|"Specify breakpoint number N to break only if COND is true.\n\ Usage is `condition N COND', where N is an integer and COND is an\n\ expression to be evaluated whenever breakpoint N is reached."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"tbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|tbreak_command
argument_list|,
literal|"Set a temporary breakpoint.  Args like \"break\" command.\n\ Like \"break\" except the breakpoint is only temporary,\n\ so it will be deleted when hit.  Equivalent to \"break\" followed\n\ by using \"enable delete\" on the breakpoint number."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"hbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|hbreak_command
argument_list|,
literal|"Set a hardware assisted  breakpoint. Args like \"break\" command.\n\ Like \"break\" except the breakpoint requires hardware support,\n\ some target hardware may not have this support."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"thbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|thbreak_command
argument_list|,
literal|"Set a temporary hardware assisted breakpoint. Args like \"break\" command.\n\ Like \"hbreak\" except the breakpoint is only temporary,\n\ so it will be deleted when hit."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily."
argument_list|,
operator|&
name|enablelist
argument_list|,
literal|"enable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"ab"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"en"
argument_list|,
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_abbrev_prefix_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ This is used to cancel the effect of the \"disable\" command.\n\ May be abbreviated to simply \"enable\".\n"
argument_list|,
operator|&
name|enablebreaklist
argument_list|,
literal|"enable breakpoints "
argument_list|,
literal|1
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled."
argument_list|,
operator|&
name|disablelist
argument_list|,
literal|"disable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dis"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"disa"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"sb"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\ This command may be abbreviated \"disable\"."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ \n\ Also a prefix command for deletion of other GDB objects.\n\ The \"unset\" command is also an alias for \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|,
literal|"delete "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"d"
argument_list|,
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"db"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n"
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ This command may be abbreviated \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"clear"
argument_list|,
name|class_breakpoint
argument_list|,
name|clear_command
argument_list|,
name|concat
argument_list|(
literal|"Clear breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, all breakpoints in that line are cleared.\n\ If function is specified, breakpoints at beginning of function are cleared.\n\ If an address is specified, breakpoints at that address are cleared.\n\n"
argument_list|,
literal|"With no argument, clears all breakpoints in the line that the selected frame\n\ is executing in.\n\ \n\ See also the \"delete\" command which clears breakpoints by number."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_command
argument_list|,
name|concat
argument_list|(
literal|"Set breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, break at start of code for that line.\n\ If function is specified, break at start of code for that function.\n\ If an address is specified, break at that exact address.\n"
argument_list|,
literal|"With no arg, uses current execution address of selected stack frame.\n\ This is useful for breaking on return to a stack frame.\n\ \n\ Multiple breakpoints at one place are permitted, and useful if conditional.\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"b"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"br"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bre"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"brea"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"ba"
argument_list|,
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bu"
argument_list|,
literal|"ubreak"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbx_commands
condition|)
block|{
name|add_abbrev_prefix_cmd
argument_list|(
literal|"stop"
argument_list|,
name|class_breakpoint
argument_list|,
name|stop_command
argument_list|,
literal|"Break in function/address or break at a line in the current file."
argument_list|,
operator|&
name|stoplist
argument_list|,
literal|"stop "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"in"
argument_list|,
name|class_breakpoint
argument_list|,
name|stopin_command
argument_list|,
literal|"Break in function or address.\n"
argument_list|,
operator|&
name|stoplist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"at"
argument_list|,
name|class_breakpoint
argument_list|,
name|stopat_command
argument_list|,
literal|"Break at a line in the current file.\n"
argument_list|,
operator|&
name|stoplist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_info
argument_list|(
literal|"breakpoints"
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"lb"
argument_list|,
name|class_breakpoint
argument_list|,
name|breakpoints_info
argument_list|,
name|concat
argument_list|(
literal|"Status of user-settable breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_breakpoints
argument_list|,
name|concat
argument_list|(
literal|"Status of all breakpoints, or breakpoint number NUMBER.\n\ The \"Type\" column indicates one of:\n\ \tbreakpoint     - normal breakpoint\n\ \twatchpoint     - watchpoint\n\ \tlongjmp        - internal breakpoint used to step through longjmp()\n\ \tlongjmp resume - internal breakpoint at the target of longjmp()\n\ \tuntil          - internal breakpoint used by the \"until\" command\n\ \tfinish         - internal breakpoint used by the \"finish\" command\n"
argument_list|,
literal|"The \"Disp\" column contains one of \"keep\", \"del\", or \"dis\" to indicate\n\ the disposition of the breakpoint after it gets hit.  \"dis\" means that the\n\ breakpoint will be disabled.  The \"Address\" and \"What\" columns indicate the\n\ address and file/line number respectively.\n\n"
argument_list|,
literal|"Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed.\n\n\ Convenience variable \"$bpnum\" contains the number of the last\n\ breakpoint set."
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"catch"
argument_list|,
name|class_breakpoint
argument_list|,
name|catch_command
argument_list|,
literal|"Set catchpoints to catch events.\n\ Raised signals may be caught:\n\ \tcatch signal              - all signals\n\ \tcatch signal<signame>    - a particular signal\n\ Raised exceptions may be caught:\n\ \tcatch throw               - all exceptions, when thrown\n\ \tcatch throw<exceptname>  - a particular exception, when thrown\n\ \tcatch catch               - all exceptions, when caught\n\ \tcatch catch<exceptname>  - a particular exception, when caught\n\ Thread or process events may be caught:\n\ \tcatch thread_start        - any threads, just after creation\n\ \tcatch thread_exit         - any threads, just before expiration\n\ \tcatch thread_join         - any threads, just after joins\n\ Process events may be caught:\n\ \tcatch start               - any processes, just after creation\n\ \tcatch exit                - any processes, just before expiration\n\ \tcatch fork                - calls to fork()\n\ \tcatch vfork               - calls to vfork()\n\ \tcatch exec                - calls to exec()\n\ Dynamically-linked library events may be caught:\n\ \tcatch load                - loads of any library\n\ \tcatch load<libname>      - loads of a particular library\n\ \tcatch unload              - unloads of any library\n\ \tcatch unload<libname>    - unloads of a particular library\n\ The act of your program's execution stopping may also be caught:\n\ \tcatch stop\n\n\ C++ exceptions may be caught:\n\ \tcatch throw               - all exceptions, when thrown\n\ \tcatch catch               - all exceptions, when caught\n\ \n\ Do \"help set follow-fork-mode\" for info on debugging your program\n\ after a fork or vfork is caught.\n\n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tcatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|tcatch_command
argument_list|,
literal|"Set temporary catchpoints to catch events.\n\ Args like \"catch\" command.\n\ Like \"catch\" except the catchpoint is only temporary,\n\ so it will be deleted when hit.  Equivalent to \"catch\" followed\n\ by using \"enable delete\" on the catchpoint number."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"watch"
argument_list|,
name|class_breakpoint
argument_list|,
name|watch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression changes."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"rwatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|rwatch_command
argument_list|,
literal|"Set a read watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression is read."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"awatch"
argument_list|,
name|class_breakpoint
argument_list|,
name|awatch_command
argument_list|,
literal|"Set a watchpoint for an expression.\n\ A watchpoint stops execution of your program whenever the value of\n\ an expression is either read or written."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"watchpoints"
argument_list|,
name|breakpoints_info
argument_list|,
literal|"Synonym for ``info breakpoints''."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"can-use-hw-watchpoints"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|can_use_hw_watchpoints
argument_list|,
literal|"Set debugger's willingness to use watchpoint hardware.\n\ If zero, gdb will not use hardware for new watchpoints, even if\n\ such is available.  (However, any hardware watchpoints that were\n\ created before setting this to nonzero, will continue to use watchpoint\n\ hardware.)"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|can_use_hw_watchpoints
operator|=
literal|1
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"breakpoint"
argument_list|,
name|class_maintenance
argument_list|,
name|set_breakpoint_cmd
argument_list|,
literal|"\ Breakpoint specific settings\n\ Configure various breakpoint-specific variables such as\n\ pending breakpoint behavior"
argument_list|,
operator|&
name|breakpoint_set_cmdlist
argument_list|,
literal|"set breakpoint "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"breakpoint"
argument_list|,
name|class_maintenance
argument_list|,
name|show_breakpoint_cmd
argument_list|,
literal|"\ Breakpoint specific settings\n\ Configure various breakpoint-specific variables such as\n\ pending breakpoint behavior"
argument_list|,
operator|&
name|breakpoint_show_cmdlist
argument_list|,
literal|"show breakpoint "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_setshow_auto_boolean_cmd
argument_list|(
literal|"pending"
argument_list|,
name|no_class
argument_list|,
operator|&
name|pending_break_support
argument_list|,
literal|"\ Set debugger's behavior regarding pending breakpoints.\n\ If on, an unrecognized breakpoint location will cause gdb to create a\n\ pending breakpoint.  If off, an unrecognized breakpoint location results in\n\ an error.  If auto, an unrecognized breakpoint location results in a\n\ user-query to see if a pending breakpoint should be created."
argument_list|,
literal|"\ Show debugger's behavior regarding pending breakpoints.\n\ If on, an unrecognized breakpoint location will cause gdb to create a\n\ pending breakpoint.  If off, an unrecognized breakpoint location results in\n\ an error.  If auto, an unrecognized breakpoint location results in a\n\ user-query to see if a pending breakpoint should be created."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|breakpoint_set_cmdlist
argument_list|,
operator|&
name|breakpoint_show_cmdlist
argument_list|)
expr_stmt|;
name|pending_break_support
operator|=
name|AUTO_BOOLEAN_AUTO
expr_stmt|;
block|}
end_function

end_unit

