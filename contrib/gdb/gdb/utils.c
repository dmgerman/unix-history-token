begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* General utility routines for GDB, the GNU debugger.    Copyright 1986, 89, 90, 91, 92, 95, 96, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CURSES_H
end_ifdef

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERM_H
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SunOS's curses.h has a '#define reg register' in it.  Thank you Sun. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|reg
end_ifdef

begin_undef
undef|#
directive|undef
name|reg
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_macro
name|void
argument_list|(
argument|*error_begin_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|vfprintf_maybe_filtered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fputs_maybe_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_MMALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_MMCHECK
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|malloc_botch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|fatal_dump_core
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prompt_for_continue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_width_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_width
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GDB_FILE_ISATTY
end_ifndef

begin_define
define|#
directive|define
name|GDB_FILE_ISATTY
parameter_list|(
name|GDB_FILE_PTR
parameter_list|)
value|(gdb_file_isatty(GDB_FILE_PTR))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain of cleanup actions established with make_cleanup,    to be executed if an error happens.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up after a failed command */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|final_cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up when gdb exits */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|run_cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cleaned up on each 'run' */
end_comment

begin_comment
comment|/* Nonzero if we have job control. */
end_comment

begin_decl_stmt
name|int
name|job_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a quit has been requested.  */
end_comment

begin_decl_stmt
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means quit immediately if Control-C is typed now, rather    than waiting until QUIT is executed.  Be careful in setting this;    code which executes with immediate_quit set has to be very careful    about being able to deal with being interrupted at any time.  It is    almost always better to use QUIT; the only exception I can think of    is being able to quit out of a system call (using EINTR loses if    the SIGINT happens between the previous QUIT and the system call).    To immediately quit in the case in which a SIGINT happens between    the previous QUIT and setting immediate_quit (desirable anytime we    expect to block), call QUIT after setting immediate_quit.  */
end_comment

begin_decl_stmt
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++ names should be printed out in their    C++ form rather than raw.  */
end_comment

begin_decl_stmt
name|int
name|demangle
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++ names should be printed out in their    C++ form even in assembler language displays.  If this is set, but    DEMANGLE is zero, names are printed raw, i.e. DEMANGLE controls.  */
end_comment

begin_decl_stmt
name|int
name|asm_demangle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that strings with character values>0x7F should be printed    as octal escapes.  Zero means just print the value (e.g. it's an    international character, and the terminal or window can cope.)  */
end_comment

begin_decl_stmt
name|int
name|sevenbit_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before error messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before quit messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|quit_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before warning messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|warning_pre_print
init|=
literal|"\nwarning: "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pagination_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add a new cleanup to the cleanup_chain,    and return the previous chain pointer    to be passed later to do_cleanups or discard_cleanups.    Args are FUNCTION to clean up with, and ARG to pass to it.  */
end_comment

begin_function_decl
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|(
name|function
parameter_list|,
name|arg
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_block

begin_function_decl
name|struct
name|cleanup
modifier|*
name|make_final_cleanup
parameter_list|(
name|function
parameter_list|,
name|arg
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_block

begin_function_decl
name|struct
name|cleanup
modifier|*
name|make_run_cleanup
parameter_list|(
name|function
parameter_list|,
name|arg
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|make_my_cleanup
argument_list|(
operator|&
name|run_cleanup_chain
argument_list|,
name|function
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_block

begin_function_decl
name|struct
name|cleanup
modifier|*
name|make_my_cleanup
parameter_list|(
name|pmy_chain
parameter_list|,
name|function
parameter_list|,
name|arg
parameter_list|)
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|new
init|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cleanup
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
operator|*
name|pmy_chain
decl_stmt|;
name|new
operator|->
name|next
operator|=
operator|*
name|pmy_chain
expr_stmt|;
name|new
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|new
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
operator|*
name|pmy_chain
operator|=
name|new
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_block

begin_comment
comment|/* Discard cleanups and do the actions they describe    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|do_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_final_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_run_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
name|do_my_cleanups
argument_list|(
operator|&
name|run_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_my_cleanups
parameter_list|(
name|pmy_chain
parameter_list|,
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
operator|*
name|pmy_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
operator|*
name|pmy_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Do this first incase recursion */
call|(
modifier|*
name|ptr
operator|->
name|function
call|)
argument_list|(
name|ptr
operator|->
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Discard cleanups, not doing the actions they describe,    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|discard_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
name|discard_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|discard_final_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
name|discard_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|discard_my_cleanups
parameter_list|(
name|pmy_chain
parameter_list|,
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
operator|*
name|pmy_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
operator|*
name|pmy_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the cleanup_chain to 0, and return the old cleanup chain.  */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|save_cleanups
parameter_list|()
block|{
return|return
name|save_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|save_final_cleanups
parameter_list|()
block|{
return|return
name|save_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|save_my_cleanups
parameter_list|(
name|pmy_chain
parameter_list|)
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
operator|*
name|pmy_chain
decl_stmt|;
operator|*
name|pmy_chain
operator|=
literal|0
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Restore the cleanup chain from a previously saved chain.  */
end_comment

begin_function
name|void
name|restore_cleanups
parameter_list|(
name|chain
parameter_list|)
name|struct
name|cleanup
modifier|*
name|chain
decl_stmt|;
block|{
name|restore_my_cleanups
argument_list|(
operator|&
name|cleanup_chain
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_final_cleanups
parameter_list|(
name|chain
parameter_list|)
name|struct
name|cleanup
modifier|*
name|chain
decl_stmt|;
block|{
name|restore_my_cleanups
argument_list|(
operator|&
name|final_cleanup_chain
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_my_cleanups
parameter_list|(
name|pmy_chain
parameter_list|,
name|chain
parameter_list|)
name|struct
name|cleanup
modifier|*
modifier|*
name|pmy_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|chain
decl_stmt|;
block|{
operator|*
name|pmy_chain
operator|=
name|chain
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is useful for cleanups.    Do       foo = xmalloc (...);      old_chain = make_cleanup (free_current_contents,&foo);     to arrange to free the object thus allocated.  */
end_comment

begin_function
name|void
name|free_current_contents
parameter_list|(
name|location
parameter_list|)
name|char
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|free
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Provide a known function that does nothing, to use as a base for    for a possibly long chain of cleanups.  This is useful where we    use the cleanup chain for handling normal cleanups as well as dealing    with cleanups that need to be done as a result of a call to error().    In such cases, we may not be certain where the first cleanup is, unless    we have a do-nothing one to always use as the base. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|null_cleanup
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a warning message.  Way to use this is to call warning_begin,    output the warning message (use unfiltered output to gdb_stderr),    ending in a newline.  There is not currently a warning_end that you    call afterwards, but such a thing might be added if it is useful    for a GUI to separate warning messages from other output.     FIXME: Why do warnings use unfiltered output and errors filtered?    Is this anything other than a historical accident?  */
end_comment

begin_function
name|void
name|warning_begin
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_pre_print
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|warning_pre_print
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning message.    The first argument STRING is the warning message, used as a fprintf string,    and the remaining args are passed as arguments to it.    The primary difference between warnings and errors is that a warning    does not force the return to command level.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_decl_stmt
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|warning
argument_list|(
specifier|const
name|char
operator|*
name|string
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|warning
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|warning_hook
condition|)
call|(
modifier|*
name|warning_hook
call|)
argument_list|(
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
name|warning_begin
argument_list|()
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Start the printing of an error message.  Way to use this is to call    this, output the error message (use filtered output to gdb_stderr    (FIXME: Some callers, like memory_error, use gdb_stdout)), ending    in a newline, and then call return_to_top_level (RETURN_ERROR).    error() provides a convenient way to do this for the special case    that the error message can be formatted with a single printf call,    but this is more general.  */
end_comment

begin_function
name|void
name|error_begin
parameter_list|()
block|{
if|if
condition|(
name|error_begin_hook
condition|)
name|error_begin_hook
argument_list|()
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_pre_print
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|error_pre_print
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and return to command level.    The first argument STRING is the error message, used as a fprintf string,    and the remaining args are passed as arguments to it.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_decl_stmt
name|NORETURN
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|error
argument_list|(
specifier|const
name|char
operator|*
name|string
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|error
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error_hook
condition|)
call|(
modifier|*
name|error_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|error_begin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|char
modifier|*
name|string1
decl_stmt|;
name|string1
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string1
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Print an error message and exit reporting failure.    This is for a error that we cannot continue from.    The arguments are printed a la printf.     This function cannot be declared volatile (NORETURN) in an    ANSI environment because exit() is not declared volatile. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|NORETURN
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|fatal
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fatal
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\ngdb: "
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and exit, dumping core.    The arguments are printed a la printf ().  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|fatal_dump_core
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fatal_dump_core
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* "internal error" is always correct, since GDB should never dump      core, no matter what the input.  */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\ngdb internal error: "
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
comment|/* We should never get here, but just in case...  */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The strerror() function can return NULL for errno values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented errno %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The strsignal() function can return NULL for signal values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strsignal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|strsignal
argument_list|(
name|signo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented signal %d)"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the system error message for errno, and also mention STRING    as the file name for which the error was encountered.    Then return to command level.  */
end_comment

begin_function
name|NORETURN
name|void
name|perror_with_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* I understand setting these is a matter of taste.  Still, some people      may clear errno but not know about bfd_error.  Doing this here is not      unreasonable. */
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s."
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the system error message for ERRCODE, and also mention STRING    as the file name for which the error was encountered.  */
end_comment

begin_function
name|void
name|print_sys_errmsg
parameter_list|(
name|string
parameter_list|,
name|errcode
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|errcode
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* We want anything which was printed on stdout to come out first, before      this message.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s.\n"
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Control C eventually causes this to be called, at a convenient time.  */
end_comment

begin_function
name|void
name|quit
parameter_list|()
block|{
name|serial_t
name|gdb_stdout_serial
init|=
name|serial_fdopen
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* We want all output to appear now, before we print "Quit".  We      have 3 levels of buffering we have to flush (it's possible that      some of these should be changed to flush the lower-level ones      too):  */
comment|/* 1.  The _filtered buffer.  */
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 2.  The stdio buffer.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* 3.  The system-level buffer.  */
name|SERIAL_DRAIN_OUTPUT
argument_list|(
name|gdb_stdout_serial
argument_list|)
expr_stmt|;
name|SERIAL_UN_FDOPEN
argument_list|(
name|gdb_stdout_serial
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
comment|/* Don't use *_filtered; we don't want to prompt the user to continue.  */
if|if
condition|(
name|quit_pre_print
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|quit_pre_print
argument_list|)
expr_stmt|;
if|if
condition|(
name|job_control
comment|/* If there is no terminal switching for this target, then we can't 	 possibly get screwed by the lack of job control.  */
operator|||
name|current_target
operator|.
name|to_terminal_ours
operator|==
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit (expect signal SIGINT when the program is resumed)\n"
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_comment
comment|/* In the absence of signals, poll keyboard for a quit.    Called from #define QUIT pollquit() in xm-go32.h. */
end_comment

begin_function
name|void
name|notice_quit
parameter_list|()
block|{
if|if
condition|(
name|kbhit
argument_list|()
condition|)
switch|switch
condition|(
name|getkey
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|quit_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|immediate_quit
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* We just ignore it */
comment|/* FIXME!! Don't think this actually works! */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"CTRL-A to quit, CTRL-B to quit harder\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_comment
comment|/* should test for wingdb instead? */
end_comment

begin_comment
comment|/*  * Windows translates all keyboard and mouse events   * into a message which is appended to the message   * queue for the process.  */
end_comment

begin_function
name|void
name|notice_quit
parameter_list|()
block|{
name|int
name|k
init|=
name|win32pollquit
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
name|quit_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
literal|2
condition|)
name|immediate_quit
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined(__GO32__)&& !defined(_MSC_VER) */
end_comment

begin_function
name|void
name|notice_quit
parameter_list|()
block|{
comment|/* Done by signals */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(__GO32__)&& !defined(_MSC_VER) */
end_comment

begin_function
name|void
name|pollquit
parameter_list|()
block|{
name|notice_quit
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_flag
operator|||
name|immediate_quit
condition|)
name|quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Control C comes here */
end_comment

begin_function
name|void
name|request_quit
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
comment|/* Restore the signal handler.  Harmless with BSD-style signals, needed      for System V-style signals.  So just always do it, rather than worrying      about USG defines and stuff like that.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REQUEST_QUIT
name|REQUEST_QUIT
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|immediate_quit
condition|)
name|quit
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memory management stuff (malloc friends).  */
end_comment

begin_comment
comment|/* Make a substitute size_t for non-ANSI compilers. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDDEF_H
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|size_t
end_ifndef

begin_define
define|#
directive|define
name|size_t
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_MMALLOC
argument_list|)
end_if

begin_function
name|PTR
name|mmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|PTR
name|mrealloc
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
comment|/* Guard against old realloc's */
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
else|else
return|return
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mfree
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MMALLOC */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_MMALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_MMCHECK
argument_list|)
end_if

begin_function
name|void
name|init_malloc
parameter_list|(
name|md
parameter_list|)
name|PTR
name|md
decl_stmt|;
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Have mmalloc and want corruption checking */
end_comment

begin_function
specifier|static
name|void
name|malloc_botch
parameter_list|()
block|{
name|fatal_dump_core
argument_list|(
literal|"Memory corruption"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to install hooks in mmalloc/mrealloc/mfree for the heap specified    by MD, to detect memory corruption.  Note that MD may be NULL to specify    the default heap that grows via sbrk.     Note that for freshly created regions, we must call mmcheckf prior to any    mallocs in the region.  Otherwise, any region which was allocated prior to    installing the checking hooks, which is later reallocated or freed, will    fail the checks!  The mmcheck function only allows initial hooks to be    installed before the first mmalloc.  However, anytime after we have called    mmcheck the first time to install the checking hooks, we can call it again    to update the function pointer to the memory corruption handler.     Returns zero on failure, non-zero on success. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MMCHECK_FORCE
end_ifndef

begin_define
define|#
directive|define
name|MMCHECK_FORCE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_malloc
parameter_list|(
name|md
parameter_list|)
name|PTR
name|md
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mmcheckf
argument_list|(
name|md
argument_list|,
name|malloc_botch
argument_list|,
name|MMCHECK_FORCE
argument_list|)
condition|)
block|{
comment|/* Don't use warning(), which relies on current_target being set 	 to something other than dummy_target, until after 	 initialize_all_files(). */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"warning: failed to install memory consistency checks; "
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"configuration should define NO_MMCHECK or MMCHECK_FORCE\n"
argument_list|)
expr_stmt|;
block|}
name|mmtrace
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Have mmalloc and want corruption checking  */
end_comment

begin_comment
comment|/* Called when a memory allocation fails, with the number of bytes of    memory requested in SIZE. */
end_comment

begin_function
name|NORETURN
name|void
name|nomem
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"virtual memory exhausted: can't allocate %ld bytes."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"virtual memory exhausted."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like mmalloc but get error if no storage available, and protect against    the caller wanting to allocate zero bytes.  Whether to return NULL for    a zero byte request, or translate the request into a request for one    byte of zero'd storage, is a religious issue. */
end_comment

begin_function
name|PTR
name|xmmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like mrealloc but get error if no storage available.  */
end_comment

begin_function
name|PTR
name|xmrealloc
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|mrealloc
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like malloc but get error if no storage available, and protect against    the caller wanting to allocate zero bytes.  */
end_comment

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|xmmalloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like mrealloc but get error if no storage available.  */
end_comment

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|xmrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* My replacement for the read system call.    Used like `read' but keeps going if `read' returns too soon.  */
end_comment

begin_function
name|int
name|myread
parameter_list|(
name|desc
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|orglen
init|=
name|len
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
name|orglen
operator|-
name|len
return|;
name|len
operator|-=
name|val
expr_stmt|;
name|addr
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|orglen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters    (and add a null character at the end in the copy).    Uses malloc to get the space.  Returns the address of the copy.  */
end_comment

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|msavestring
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmmalloc
argument_list|(
name|md
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The "const" is so it compiles under DGUX (which prototypes strsave    in<string.h>.  FIXME: This should be named "xstrsave", shouldn't it?    Doesn't real strsave return NULL if out of memory?  */
end_comment

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|ptr
parameter_list|)
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
name|savestring
argument_list|(
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mstrsave
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|PTR
name|md
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
operator|(
name|msavestring
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_spaces
parameter_list|(
name|n
parameter_list|,
name|file
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|GDB_FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|file
operator|->
name|ts_streamtype
operator|==
name|astring
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|gdb_file_adjust_strbuf
argument_list|(
name|n
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|p
operator|=
name|file
operator|->
name|ts_strbuf
operator|+
name|strlen
argument_list|(
name|file
operator|->
name|ts_strbuf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a host address.  */
end_comment

begin_function
name|void
name|gdb_print_address
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* We could use the %p conversion specifier to fprintf if we had any      way of knowing whether this host supports it.  But the following      should work on the Alpha and on 32 bit machines.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask user a y-or-n question and return 1 iff answer is yes.    Takes three args which are given to printf to print the question.    The first, a control string, should end in "? ".    It should not say how to answer, because we do that.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|query
parameter_list|(
name|char
modifier|*
name|ctlstr
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|query
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
specifier|register
name|int
name|answer
decl_stmt|;
specifier|register
name|int
name|ans2
decl_stmt|;
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|ctlstr
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|ctlstr
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|ctlstr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|query_hook
condition|)
block|{
return|return
name|query_hook
argument_list|(
name|ctlstr
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* Automatically answer "yes" if input is not from a terminal.  */
if|if
condition|(
operator|!
name|input_from_terminal_p
argument_list|()
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|MPW
comment|/* FIXME Automatically answer "yes" if called from MacGDB.  */
if|if
condition|(
name|mac_app
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* MPW */
while|while
condition|(
literal|1
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032pre-query\n"
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|ctlstr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(y or n) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032query\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MPW
comment|/* If not in MacGDB, move to a new line so the entered line doesn't 	 have a prompt on the front of it. */
if|if
condition|(
operator|!
name|mac_app
condition|)
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MPW */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
operator|!
name|tui_version
operator|||
name|cmdWin
operator|==
name|tuiWinWithFocus
argument_list|()
condition|)
endif|#
directive|endif
name|answer
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
else|else
name|answer
operator|=
operator|(
name|unsigned
name|char
operator|)
name|tuiBufferGetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* in case of C-d */
if|if
condition|(
name|answer
operator|==
name|EOF
condition|)
comment|/* C-d */
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Eat rest of input line, to EOF or newline */
if|if
condition|(
operator|(
name|answer
operator|!=
literal|'\n'
operator|)
operator|||
operator|(
name|tui_version
operator|&&
name|answer
operator|!=
literal|'\r'
operator|)
condition|)
do|do
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
operator|!
name|tui_version
operator|||
name|cmdWin
operator|==
name|tuiWinWithFocus
argument_list|()
condition|)
endif|#
directive|endif
name|ans2
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
else|else
name|ans2
operator|=
operator|(
name|unsigned
name|char
operator|)
name|tuiBufferGetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ans2
operator|!=
name|EOF
operator|&&
name|ans2
operator|!=
literal|'\n'
operator|&&
name|ans2
operator|!=
literal|'\r'
condition|)
do|;
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vStartNewLines
operator|,
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|>=
literal|'a'
condition|)
name|answer
operator|-=
literal|040
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|'Y'
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|answer
operator|==
literal|'N'
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"Please answer y or n.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032post-query\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    should point to the character after the \.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|int
name|parse_escape
parameter_list|(
name|string_ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
literal|007
return|;
comment|/* Bell (alert) char */
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'e'
case|:
comment|/* Escape character */
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'v'
case|:
return|return
literal|'\v'
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'^'
case|:
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|parse_escape
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
return|return
literal|0177
return|;
return|return
operator|(
name|c
operator|&
literal|0200
operator|)
operator||
operator|(
name|c
operator|&
literal|037
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|*=
literal|8
expr_stmt|;
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that this routine should only    be call for printing things which are independent of the language    of the program being debugged. */
end_comment

begin_function
name|void
name|gdb_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|c
operator|<
literal|0x20
operator|||
comment|/* Low control chars */
operator|(
name|c
operator|>=
literal|0x7F
operator|&&
name|c
operator|<
literal|0xA0
operator|)
operator|||
comment|/* DEL, High controls */
operator|(
name|sevenbit_strings
operator|&&
name|c
operator|>=
literal|0x80
operator|)
condition|)
block|{
comment|/* high order bit set */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hexlate
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|fmthex
parameter_list|(
name|inbuf
parameter_list|,
name|outbuff
parameter_list|,
name|length
parameter_list|,
name|linelength
parameter_list|)
name|unsigned
name|char
modifier|*
name|inbuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|outbuff
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|linelength
decl_stmt|;
block|{
name|unsigned
name|char
name|byte
decl_stmt|,
name|nib
decl_stmt|;
name|int
name|outlength
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
condition|)
block|{
if|if
condition|(
name|outlength
operator|>=
name|linelength
condition|)
break|break ;
name|byte
operator|=
operator|*
name|inbuf
expr_stmt|;
name|inbuf
operator|++
expr_stmt|;
name|nib
operator|=
name|byte
operator|>>
literal|4
expr_stmt|;
operator|*
name|outbuff
operator|++
operator|=
name|hexlate
index|[
name|nib
index|]
expr_stmt|;
name|nib
operator|=
name|byte
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|outbuff
operator|++
operator|=
name|hexlate
index|[
name|nib
index|]
expr_stmt|;
operator|*
name|outbuff
operator|++
operator|=
literal|' '
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|outlength
operator|+=
literal|3
expr_stmt|;
block|}
operator|*
name|outbuff
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate our output line */
return|return
name|outlength
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Number of lines per page or UINT_MAX if paging is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_per_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars per line or UNIT_MAX is line folding is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|chars_per_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current count of lines printed on this page, chars on this line.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_printed
decl_stmt|,
name|chars_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer and start column of buffered text, for doing smarter word-    wrapping.  When someone calls wrap_here(), we start buffering output    that comes through fputs_filtered().  If we see a newline, we just    spit it out and forget about the wrap_here().  If we see another    wrap_here(), we spit it out and remember the newer one.  If we see    the end of the line, we spit out a newline, the indent, and then    the buffered output.  */
end_comment

begin_comment
comment|/* Malloc'd buffer with chars_per_line+2 bytes.  Contains characters which    are waiting to be output (they have already been counted in chars_printed).    When wrap_buffer[0] is null, the buffer is empty.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer in wrap_buffer to the next character to fill.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to indent by if the wrap occurs.  Must not be NULL if wrap_column    is non-zero.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column number on the screen where wrap_buffer begins, or 0 if wrapping    is not in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrap_column
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Inialize the lines and chars per page */
end_comment

begin_function
name|void
name|init_page_info
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
name|tui_version
operator|&&
name|m_winPtrNotNull
argument_list|(
name|cmdWin
argument_list|)
condition|)
block|{
name|lines_per_page
operator|=
name|cmdWin
operator|->
name|generic
operator|.
name|height
expr_stmt|;
name|chars_per_line
operator|=
name|cmdWin
operator|->
name|generic
operator|.
name|width
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* These defaults will be used if we are unable to get the correct          values from termcap.  */
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|lines_per_page
operator|=
name|ScreenRows
argument_list|()
expr_stmt|;
name|chars_per_line
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
else|#
directive|else
name|lines_per_page
operator|=
literal|24
expr_stmt|;
name|chars_per_line
operator|=
literal|80
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MPW
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* No termcap under MPW, although might be cool to do something          by looking at worksheet or console window sizes. */
comment|/* Initialize the screen height and width from termcap.  */
block|{
name|char
modifier|*
name|termtype
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
comment|/* Positive means success, nonpositive means failure.  */
name|int
name|status
decl_stmt|;
comment|/* 2048 is large enough for all known terminals, according to the            GNU termcap manual.  */
name|char
name|term_buffer
index|[
literal|2048
index|]
decl_stmt|;
if|if
condition|(
name|termtype
condition|)
block|{
name|status
operator|=
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|termtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|running_in_emacs
init|=
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|val
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
operator|&&
operator|!
name|running_in_emacs
condition|)
name|lines_per_page
operator|=
name|val
expr_stmt|;
else|else
comment|/* The number of lines per page is not mentioned 		     in the terminal description.  This probably means 		     that paging is not useful (e.g. emacs shell window), 		     so disable paging.  */
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
name|val
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
name|chars_per_line
operator|=
name|val
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* MPW */
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
comment|/* If there is a better way to determine the window size, use it. */
name|SIGWINCH_HANDLER
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* If the output is not a terminal, don't paginate it.  */
if|if
condition|(
operator|!
name|GDB_FILE_ISATTY
argument_list|(
name|gdb_stdout
argument_list|)
condition|)
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
block|}
comment|/* the command_line_version */
name|set_width
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_width
parameter_list|()
block|{
if|if
condition|(
name|chars_per_line
operator|==
literal|0
condition|)
name|init_page_info
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
block|{
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|wrap_buffer
argument_list|,
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Start it at the beginning */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_width_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|set_width
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait, so the user can read what's on the screen.  Prompt the user    to continue by pressing RETURN.  */
end_comment

begin_function
specifier|static
name|void
name|prompt_for_continue
parameter_list|()
block|{
name|char
modifier|*
name|ignore
decl_stmt|;
name|char
name|cont_prompt
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n\032\032pre-prompt-for-continue\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cont_prompt
argument_list|,
literal|"---Type<return> to continue, or q<return> to quit---"
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|strcat
argument_list|(
name|cont_prompt
argument_list|,
literal|"\n\032\032prompt-for-continue\n"
argument_list|)
expr_stmt|;
comment|/* We must do this *before* we call gdb_readline, else it will eventually      call us -- thinking that we're trying to print beyond the end of the       screen.  */
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
comment|/* On a real operating system, the user can quit with SIGINT.      But not on GO32.       'q' is provided on all systems so users don't have to change habits      from system to system, and because telling them what to do in      the prompt is more user-friendly than expecting them to think of      SIGINT.  */
comment|/* Call readline, not gdb_readline, because GO32 readline handles control-C      whereas control-C to gdb_readline will cause the user to get dumped      out to DOS.  */
name|ignore
operator|=
name|readline
argument_list|(
name|cont_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n\032\032post-prompt-for-continue\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|ignore
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'q'
condition|)
name|request_quit
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|--
expr_stmt|;
comment|/* Now we have to do this again, so that GDB will know that it doesn't      need to save the ---Type<return>--- line at the top of the screen.  */
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Forget prev cmd -- CR won't repeat it. */
block|}
end_function

begin_comment
comment|/* Reinitialize filter; ie. tell it to reset to original values.  */
end_comment

begin_function
name|void
name|reinitialize_more_filter
parameter_list|()
block|{
name|lines_printed
operator|=
literal|0
expr_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that if the next sequence of characters overflows the line,    a newline should be inserted here rather than when it hits the end.     If INDENT is non-null, it is a string to be printed to indent the    wrapped part on the next line.  INDENT must remain accessible until    the next call to wrap_here() or until a newline is printed through    fputs_filtered().     If the line is already overfull, we immediately print a newline and    the indentation, and disable further wrapping.     If we don't know the width of lines, but we know the page height,    we must not wrap words, but should still keep track of newlines    that were explicitly printed.     INDENT should not contain tabs, as that will mess up the char count    on the next line.  FIXME.     This routine is guaranteed to force out any output which has been    squirreled away in the wrap_buffer, so wrap_here ((char *)0) can be    used to force out output from the wrap_buffer.  */
end_comment

begin_function
name|void
name|wrap_here
parameter_list|(
name|indent
parameter_list|)
name|char
modifier|*
name|indent
decl_stmt|;
block|{
comment|/* This should have been allocated, but be paranoid anyway. */
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|wrap_buffer
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|wrap_buffer
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chars_per_line
operator|==
name|UINT_MAX
condition|)
comment|/* No line overflow checking */
block|{
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|!=
name|NULL
condition|)
name|puts_filtered
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wrap_column
operator|=
name|chars_printed
expr_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
name|wrap_indent
operator|=
literal|""
expr_stmt|;
else|else
name|wrap_indent
operator|=
name|indent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure that whatever gets printed next, using the filtered output    commands, starts at the beginning of the line.  I.E. if there is    any pending output for the current line, flush it and start a new    line.  Otherwise do nothing. */
end_comment

begin_function
name|void
name|begin_line
parameter_list|()
block|{
if|if
condition|(
name|chars_printed
operator|>
literal|0
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|gdb_file_isatty
parameter_list|(
name|stream
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|afile
condition|)
return|return
operator|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stream
operator|->
name|ts_filestream
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|GDB_FILE
modifier|*
name|gdb_file_init_astring
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|GDB_FILE
modifier|*
name|tmpstream
decl_stmt|;
name|tmpstream
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GDB_FILE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpstream
operator|->
name|ts_streamtype
operator|=
name|astring
expr_stmt|;
name|tmpstream
operator|->
name|ts_filestream
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|tmpstream
operator|->
name|ts_strbuf
operator|=
name|xmalloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|tmpstream
operator|->
name|ts_strbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|tmpstream
operator|->
name|ts_strbuf
operator|=
name|NULL
expr_stmt|;
name|tmpstream
operator|->
name|ts_buflen
operator|=
name|n
expr_stmt|;
return|return
name|tmpstream
return|;
block|}
end_function

begin_function
name|void
name|gdb_file_deallocate
parameter_list|(
name|streamptr
parameter_list|)
name|GDB_FILE
modifier|*
modifier|*
name|streamptr
decl_stmt|;
block|{
name|GDB_FILE
modifier|*
name|tmpstream
decl_stmt|;
name|tmpstream
operator|=
operator|*
name|streamptr
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstream
operator|->
name|ts_streamtype
operator|==
name|astring
operator|)
operator|&&
operator|(
name|tmpstream
operator|->
name|ts_strbuf
operator|!=
name|NULL
operator|)
condition|)
block|{
name|free
argument_list|(
name|tmpstream
operator|->
name|ts_strbuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmpstream
argument_list|)
expr_stmt|;
operator|*
name|streamptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|gdb_file_get_strbuf
parameter_list|(
name|stream
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
return|return
operator|(
name|stream
operator|->
name|ts_strbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* adjust the length of the buffer by the amount necessary    to accomodate appending a string of length N to the buffer contents */
end_comment

begin_function
name|void
name|gdb_file_adjust_strbuf
parameter_list|(
name|n
parameter_list|,
name|stream
parameter_list|)
name|int
name|n
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|non_null_chars
decl_stmt|;
name|non_null_chars
operator|=
name|strlen
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
name|stream
operator|->
name|ts_buflen
operator|-
name|non_null_chars
operator|-
literal|1
operator|)
condition|)
block|{
name|stream
operator|->
name|ts_buflen
operator|=
name|n
operator|+
name|non_null_chars
operator|+
literal|1
expr_stmt|;
name|stream
operator|->
name|ts_strbuf
operator|=
name|xrealloc
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|stream
operator|->
name|ts_buflen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GDB_FILE
modifier|*
name|gdb_fopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|gdb_file_size
decl_stmt|;
name|GDB_FILE
modifier|*
name|tmp
decl_stmt|;
name|gdb_file_size
operator|=
sizeof|sizeof
argument_list|(
name|GDB_FILE
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|GDB_FILE
operator|*
operator|)
name|xmalloc
argument_list|(
name|gdb_file_size
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|ts_streamtype
operator|=
name|afile
expr_stmt|;
name|tmp
operator|->
name|ts_filestream
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|ts_strbuf
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|ts_buflen
operator|=
literal|0
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|void
name|gdb_flush
parameter_list|(
name|stream
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|flush_hook
operator|&&
operator|(
name|stream
operator|==
name|gdb_stdout
operator|||
name|stream
operator|==
name|gdb_stderr
operator|)
condition|)
block|{
name|flush_hook
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|fflush
argument_list|(
name|stream
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gdb_fclose
parameter_list|(
name|streamptr
parameter_list|)
name|GDB_FILE
modifier|*
modifier|*
name|streamptr
decl_stmt|;
block|{
name|GDB_FILE
modifier|*
name|tmpstream
decl_stmt|;
name|tmpstream
operator|=
operator|*
name|streamptr
expr_stmt|;
name|fclose
argument_list|(
name|tmpstream
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
name|gdb_file_deallocate
argument_list|(
name|streamptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like fputs but if FILTER is true, pause after every screenful.     Regardless of FILTER can wrap at points other than the final    character of a line.     Unlike fputs, fputs_maybe_filtered does not return a value.    It is OK for LINEBUFFER to be NULL, in which case just don't print    anything.     Note that a longjmp to top level may occur in this routine (only if    FILTER is true) (since prompt_for_continue may do so) so this    routine should not be called when cleanups are not in place.  */
end_comment

begin_function
specifier|static
name|void
name|fputs_maybe_filtered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|,
name|filter
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|lineptr
decl_stmt|;
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
return|return;
comment|/* Don't do any filtering if it is disabled.  */
if|if
condition|(
name|stream
operator|!=
name|gdb_stdout
operator|||
operator|(
name|lines_per_page
operator|==
name|UINT_MAX
operator|&&
name|chars_per_line
operator|==
name|UINT_MAX
operator|)
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go through and output each character.  Show line extension      when this is necessary; prompt user for new page when this is      necessary.  */
name|lineptr
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
condition|)
block|{
comment|/* Possible new page.  */
if|if
condition|(
name|filter
operator|&&
operator|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
operator|)
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
operator|&&
operator|*
name|lineptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Print a single line.  */
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
literal|'\t'
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Shifting right by 3 produces the number of tab stops 	         we have already passed, and then adding one and 		 shifting left 3 advances to the next tab stop.  */
name|chars_printed
operator|=
operator|(
operator|(
name|chars_printed
operator|>>
literal|3
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
operator|*
name|lineptr
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
operator|*
name|lineptr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chars_printed
operator|++
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|unsigned
name|int
name|save_chars
init|=
name|chars_printed
decl_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|lines_printed
operator|++
expr_stmt|;
comment|/* If we aren't actually wrapping, don't output newline -- 		 if chars_per_line is right, we probably just overflowed 		 anyway; if it's wrong, let us keep going.  */
if|if
condition|(
name|wrap_column
condition|)
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Possible new page.  */
if|if
condition|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
comment|/* Now output indentation and wrapped string */
if|if
condition|(
name|wrap_column
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|wrap_indent
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate saved stuff */
name|fputs_unfiltered
argument_list|(
name|wrap_buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* and eject it */
comment|/* FIXME, this strlen is what prevents wrap_indent from 		     containing tabs.  However, if we recurse to print it 		     and count its chars, we risk trouble if wrap_indent is 		     longer than (the user settable) chars_per_line.  		     Note also that this can set chars_printed> chars_per_line 		     if we are printing a long string.  */
name|chars_printed
operator|=
name|strlen
argument_list|(
name|wrap_indent
argument_list|)
operator|+
operator|(
name|save_chars
operator|-
name|wrap_column
operator|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Reset buffer */
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
comment|/* And disable fancy wrap */
block|}
block|}
block|}
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\n'
condition|)
block|{
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Spit out chars, cancel further wraps */
name|lines_printed
operator|++
expr_stmt|;
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|fputs_filtered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_maybe_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|putchar_unfiltered
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|buf
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|fputc_unfiltered
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|fputc_filtered
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* puts_debug is like fputs_unfiltered, except it prints special    characters in printable fashion.  */
end_comment

begin_function
name|void
name|puts_debug
parameter_list|(
name|prefix
parameter_list|,
name|string
parameter_list|,
name|suffix
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
comment|/* Print prefix and suffix after each line.  */
specifier|static
name|int
name|new_line
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|return_p
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|prev_prefix
init|=
literal|""
decl_stmt|;
specifier|static
name|char
modifier|*
name|prev_suffix
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\n'
condition|)
name|return_p
operator|=
literal|0
expr_stmt|;
comment|/* If the prefix is changing, print the previous suffix, a new line,      and the new prefix.  */
if|if
condition|(
operator|(
name|return_p
operator|||
operator|(
name|strcmp
argument_list|(
name|prev_prefix
argument_list|,
name|prefix
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|!
name|new_line
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|prev_suffix
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|prefix
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Print prefix if we printed a newline during the previous call.  */
if|if
condition|(
name|new_line
condition|)
block|{
name|new_line
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|prefix
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
name|prev_prefix
operator|=
name|prefix
expr_stmt|;
name|prev_suffix
operator|=
name|suffix
expr_stmt|;
comment|/* Output characters in a printable format.  */
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc_unfiltered
argument_list|(
name|ch
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\\x%02x"
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\\\"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\b"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\f"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|new_line
operator|=
literal|1
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\r"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\t"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\v"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
block|}
name|return_p
operator|=
name|ch
operator|==
literal|'\r'
expr_stmt|;
block|}
comment|/* Print suffix if we printed a newline.  */
if|if
condition|(
name|new_line
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|suffix
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a variable number of ARGS using format FORMAT.  If this    information is going to put the amount written (since the last call    to REINITIALIZE_MORE_FILTER or the last page break) over the page size,    call prompt_for_continue to get the users permision to continue.     Unlike fprintf, this function does not return a value.     We implement three variants, vfprintf (takes a vararg list and stream),    fprintf (takes a stream to write on), and printf (the usual).     Note also that a longjmp to top level may occur in this routine    (since prompt_for_continue may do so) so this routine should not be    called when cleanups are not in place.  */
end_comment

begin_function
specifier|static
name|void
name|vfprintf_maybe_filtered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|,
name|filter
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuffer
operator|==
name|NULL
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"\ngdb: virtual memory exhausted.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|fputs_maybe_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfprintf_filtered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf_maybe_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfprintf_unfiltered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuffer
operator|==
name|NULL
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"\ngdb: virtual memory exhausted.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vprintf_filtered
parameter_list|(
name|format
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf_maybe_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vprintf_unfiltered
parameter_list|(
name|format
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|fprintf_filtered
parameter_list|(
name|GDB_FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fprintf_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GDB_FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|fprintf_unfiltered
parameter_list|(
name|GDB_FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fprintf_unfiltered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GDB_FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf_unfiltered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like fprintf_filtered, but prints its result indented.    Called as fprintfi_filtered (spaces, stream, format, ...);  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|fprintfi_filtered
parameter_list|(
name|int
name|spaces
parameter_list|,
name|GDB_FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fprintfi_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|spaces
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GDB_FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|printf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|printf_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|printf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|printf_unfiltered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like printf_filtered, but prints it's result indented.    Called as printfi_filtered (spaces, format, ...);  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|printfi_filtered
parameter_list|(
name|int
name|spaces
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|printfi_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|spaces
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Easy -- but watch out!     This routine is *not* a replacement for puts()!  puts() appends a newline.    This one doesn't, and had better not!  */
end_comment

begin_function
name|void
name|puts_filtered
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|puts_unfiltered
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fputs_unfiltered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to N spaces and a null.  The pointer is good    until the next call to here.  */
end_comment

begin_function
name|char
modifier|*
name|n_spaces
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
modifier|*
name|spaces
decl_stmt|;
specifier|static
name|int
name|max_spaces
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|max_spaces
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|free
argument_list|(
name|spaces
argument_list|)
expr_stmt|;
name|spaces
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|spaces
operator|+
name|n
init|;
name|t
operator|!=
name|spaces
condition|;
control|)
operator|*
operator|--
name|t
operator|=
literal|' '
expr_stmt|;
name|spaces
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|max_spaces
operator|=
name|n
expr_stmt|;
block|}
return|return
name|spaces
operator|+
name|max_spaces
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/* Print N spaces.  */
end_comment

begin_function
name|void
name|print_spaces_filtered
parameter_list|(
name|n
parameter_list|,
name|stream
parameter_list|)
name|int
name|n
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
name|n_spaces
argument_list|(
name|n
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* C++ demangler stuff.  */
end_comment

begin_comment
comment|/* fprintf_symbol_filtered attempts to demangle NAME, a symbol in language    LANG, using demangling args ARG_MODE, and print it filtered to STREAM.    If the name is not mangled, or the language for the name is unknown, or    demangling is off, the name is printed in its "raw" form. */
end_comment

begin_function
name|void
name|fprintf_symbol_filtered
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|,
name|lang
parameter_list|,
name|arg_mode
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
name|int
name|arg_mode
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* If user wants to see raw output, no problem.  */
if|if
condition|(
operator|!
name|demangle
condition|)
block|{
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
name|language_cplus
case|:
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|arg_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|language_java
case|:
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|arg_mode
operator||
name|DMGL_JAVA
argument_list|)
expr_stmt|;
break|break;
case|case
name|language_chill
case|:
name|demangled
operator|=
name|chill_demangle
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|demangled
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|fputs_filtered
argument_list|(
name|demangled
condition|?
name|demangled
else|:
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do a strcmp() type operation on STRING1 and STRING2, ignoring any    differences in whitespace.  Returns 0 if they match, non-zero if they    don't (slightly different than strcmp()'s range of return values).        As an extra hack, string1=="FOO(ARGS)" matches string2=="FOO".    This "feature" is useful when searching for matching C++ function names    (such as if the user types 'break FOO', where FOO is a mangled C++    function). */
end_comment

begin_function
name|int
name|strcmp_iw
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
specifier|const
name|char
modifier|*
name|string1
decl_stmt|;
specifier|const
name|char
modifier|*
name|string2
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string1
argument_list|)
condition|)
block|{
name|string1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string2
argument_list|)
condition|)
block|{
name|string2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
operator|*
name|string2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
block|{
name|string1
operator|++
expr_stmt|;
name|string2
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|&&
operator|*
name|string1
operator|!=
literal|'('
operator|)
operator|||
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** subsetCompare() **    Answer whether stringToCompare is a full or partial match to **    templateString.  The partial match must be in sequence starting **    at index 0. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|_STDC__
name|subsetCompare
parameter_list|(
name|char
modifier|*
name|stringToCompare
parameter_list|,
name|char
modifier|*
name|templateString
parameter_list|)
else|#
directive|else
function|subsetCompare
parameter_list|(
name|stringToCompare
parameter_list|,
name|templateString
parameter_list|)
name|char
modifier|*
name|stringToCompare
decl_stmt|;
name|char
modifier|*
name|templateString
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|match
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|templateString
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|stringToCompare
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strlen
argument_list|(
name|stringToCompare
argument_list|)
operator|<=
name|strlen
argument_list|(
name|templateString
argument_list|)
condition|)
name|match
operator|=
operator|(
name|strncmp
argument_list|(
name|templateString
argument_list|,
name|stringToCompare
argument_list|,
name|strlen
argument_list|(
name|stringToCompare
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/* subsetCompare */
end_comment

begin_function
name|void
name|pagination_on_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|pagination_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pagination_off_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|pagination_enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize_utils
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"width"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chars_per_line
argument_list|,
literal|"Set number of characters gdb thinks are in a line."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_width_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"height"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lines_per_page
argument_list|,
literal|"Set number of lines gdb thinks are in a page."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|init_page_info
argument_list|()
expr_stmt|;
comment|/* If the output is not a terminal, don't paginate it.  */
if|if
condition|(
operator|!
name|GDB_FILE_ISATTY
argument_list|(
name|gdb_stdout
argument_list|)
condition|)
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
name|set_width_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|demangle
argument_list|,
literal|"Set demangling of encoded C++ names when displaying symbols."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pagination"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pagination_enabled
argument_list|,
literal|"Set state of pagination."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"am"
argument_list|,
name|class_support
argument_list|,
name|pagination_on_command
argument_list|,
literal|"Enable pagination"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sm"
argument_list|,
name|class_support
argument_list|,
name|pagination_off_command
argument_list|,
literal|"Disable pagination"
argument_list|)
expr_stmt|;
block|}
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"sevenbit-strings"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sevenbit_strings
argument_list|,
literal|"Set printing of 8-bit characters in strings as \\nnn."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"asm-demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|asm_demangle
argument_list|,
literal|"Set demangling of C++ names in disassembly listings."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Machine specific function to handle SIGWINCH signal. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH_HANDLER_BODY
end_ifdef

begin_decl_stmt
name|SIGWINCH_HANDLER_BODY
endif|#
directive|endif
comment|/* Support for converting target fp numbers into host DOUBLEST format.  */
comment|/* XXX - This code should really be in libiberty/floatformat.c, however    configuration issues with libiberty made this very difficult to do in the    available time.  */
include|#
directive|include
file|"floatformat.h"
include|#
directive|include
file|<math.h>
comment|/* ldexp */
comment|/* The odds that CHAR_BIT will be anything but 8 are low enough that I'm not    going to bother with trying to muck around with whether it is defined in    a system header, what we do if not, etc.  */
define|#
directive|define
name|FLOATFORMAT_CHAR_BIT
value|8
specifier|static
name|unsigned
name|long
name|get_field
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
expr|enum
name|floatformat_byteorders
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extract a field which starts at START and is LEN bytes long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_field
parameter_list|(
name|data
parameter_list|,
name|order
parameter_list|,
name|total_len
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|enum
name|floatformat_byteorders
name|order
decl_stmt|;
name|unsigned
name|int
name|total_len
decl_stmt|;
name|unsigned
name|int
name|start
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|long
name|result
decl_stmt|;
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|cur_bitshift
decl_stmt|;
comment|/* Start at the least significant part of the field.  */
name|cur_byte
operator|=
operator|(
name|start
operator|+
name|len
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
name|cur_byte
operator|=
operator|(
name|total_len
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|cur_byte
operator|-
literal|1
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|result
operator|=
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|>>
operator|(
operator|-
name|cur_bitshift
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
comment|/* Move towards the most significant part of the field.  */
while|while
condition|(
name|cur_bitshift
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|-
name|cur_bitshift
operator|<
name|FLOATFORMAT_CHAR_BIT
condition|)
comment|/* This is the last byte; zero out the bits which are not part of 	   this field.  */
name|result
operator||=
operator|(
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
name|cur_bitshift
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|cur_bitshift
expr_stmt|;
else|else
name|result
operator||=
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|<<
name|cur_bitshift
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert from FMT to a DOUBLEST.    FROM is the address of the extended float.    Store the DOUBLEST in *TO.  */
end_comment

begin_function
name|void
name|floatformat_to_doublest
parameter_list|(
name|fmt
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|DOUBLEST
modifier|*
name|to
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|ufrom
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|DOUBLEST
name|dto
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|unsigned
name|long
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|int
name|special_exponent
decl_stmt|;
comment|/* It's a NaN, denorm or zero */
comment|/* If the mantissa bits are not contiguous from one end of the      mantissa to the other, we need to make a private copy of the      source bytes that is in the right order since the unpacking      algorithm assumes that the bits are contiguous.       Swap the bytes individually rather than accessing them through      "long *" since we have no guarantee that they start on a long      alignment, and also sizeof(long) for the host could be different      than sizeof(long) for the target.  FIXME: Assumes sizeof(long)      for the target is 4. */
if|if
condition|(
name|fmt
operator|->
name|byteorder
operator|==
name|floatformat_littlebyte_bigword
condition|)
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|newfrom
decl_stmt|;
name|unsigned
name|char
modifier|*
name|swapin
decl_stmt|,
modifier|*
name|swapout
decl_stmt|;
name|int
name|longswaps
decl_stmt|;
name|longswaps
operator|=
name|fmt
operator|->
name|totalsize
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|longswaps
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|newfrom
operator|==
name|NULL
condition|)
block|{
name|newfrom
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|fmt
operator|->
name|totalsize
argument_list|)
expr_stmt|;
block|}
name|swapout
operator|=
name|newfrom
expr_stmt|;
name|swapin
operator|=
name|ufrom
expr_stmt|;
name|ufrom
operator|=
name|newfrom
expr_stmt|;
while|while
condition|(
name|longswaps
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* This is ugly, but efficient */
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|5
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|6
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|7
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|3
index|]
expr_stmt|;
name|swapin
operator|+=
literal|8
expr_stmt|;
block|}
block|}
name|exponent
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|)
expr_stmt|;
comment|/* Note that if exponent indicates a NaN, we can't really do anything useful      (not knowing if the host has NaN's, or how to build one).  So it will      end up as an infinity or something close; that is OK.  */
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
name|dto
operator|=
literal|0.0
expr_stmt|;
name|special_exponent
operator|=
name|exponent
operator|==
literal|0
operator|||
name|exponent
operator|==
name|fmt
operator|->
name|exp_nan
expr_stmt|;
comment|/* Don't bias zero's, denorms or NaNs.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
name|exponent
operator|-=
name|fmt
operator|->
name|exp_bias
expr_stmt|;
comment|/* Build the result algebraically.  Might go infinite, underflow, etc;      who cares. */
comment|/* If this format uses a hidden bit, explicitly add it in now.  Otherwise,    increment the exponent by one to account for the integer bit.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
if|if
condition|(
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
name|dto
operator|=
name|ldexp
argument_list|(
literal|1.0
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
else|else
name|exponent
operator|++
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant_bits
operator|=
name|min
argument_list|(
name|mant_bits_left
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|mant
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
expr_stmt|;
name|dto
operator|+=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant
argument_list|,
name|exponent
operator|-
name|mant_bits
argument_list|)
expr_stmt|;
name|exponent
operator|-=
name|mant_bits
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
comment|/* Negate it if negative.  */
if|if
condition|(
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|)
condition|)
name|dto
operator|=
operator|-
name|dto
expr_stmt|;
operator|*
name|to
operator|=
name|dto
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|put_field
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
expr|enum
name|floatformat_byteorders
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set a field which starts at START and is LEN bytes long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|void
name|put_field
parameter_list|(
name|data
parameter_list|,
name|order
parameter_list|,
name|total_len
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|,
name|stuff_to_put
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|enum
name|floatformat_byteorders
name|order
decl_stmt|;
name|unsigned
name|int
name|total_len
decl_stmt|;
name|unsigned
name|int
name|start
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|long
name|stuff_to_put
decl_stmt|;
block|{
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|cur_bitshift
decl_stmt|;
comment|/* Start at the least significant part of the field.  */
name|cur_byte
operator|=
operator|(
name|start
operator|+
name|len
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
name|cur_byte
operator|=
operator|(
name|total_len
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|cur_byte
operator|-
literal|1
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&=
operator|~
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
operator|-
name|cur_bitshift
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator||=
operator|(
name|stuff_to_put
operator|&
operator|(
operator|(
literal|1
operator|<<
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
operator|-
name|cur_bitshift
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
comment|/* Move towards the most significant part of the field.  */
while|while
condition|(
name|cur_bitshift
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|-
name|cur_bitshift
operator|<
name|FLOATFORMAT_CHAR_BIT
condition|)
block|{
comment|/* This is the last byte.  */
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
name|cur_bitshift
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator||=
operator|(
name|stuff_to_put
operator|>>
name|cur_bitshift
operator|)
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|=
operator|(
operator|(
name|stuff_to_put
operator|>>
name|cur_bitshift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
end_ifdef

begin_comment
comment|/* Return the fractional part of VALUE, and put the exponent of VALUE in *EPTR.    The range of the returned value is>= 0.5 and< 1.0.  This is equivalent to    frexp, but operates on the long double data type.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|double
name|ldfrexp
name|PARAMS
argument_list|(
operator|(
name|long
name|double
name|value
operator|,
name|int
operator|*
name|eptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|double
name|ldfrexp
parameter_list|(
name|value
parameter_list|,
name|eptr
parameter_list|)
name|long
name|double
name|value
decl_stmt|;
name|int
modifier|*
name|eptr
decl_stmt|;
block|{
name|long
name|double
name|tmp
decl_stmt|;
name|int
name|exp
decl_stmt|;
comment|/* Unfortunately, there are no portable functions for extracting the exponent      of a long double, so we have to do it iteratively by multiplying or dividing      by two until the fraction is between 0.5 and 1.0.  */
if|if
condition|(
name|value
operator|<
literal|0.0l
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|tmp
operator|=
literal|1.0l
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|tmp
condition|)
comment|/* Value>= 1.0 */
while|while
condition|(
name|value
operator|>=
name|tmp
condition|)
block|{
name|tmp
operator|*=
literal|2.0l
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0.0l
condition|)
comment|/* Value< 1.0  and> 0.0 */
block|{
while|while
condition|(
name|value
operator|<
name|tmp
condition|)
block|{
name|tmp
operator|/=
literal|2.0l
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
name|tmp
operator|*=
literal|2.0l
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
operator|*
name|eptr
operator|=
name|exp
expr_stmt|;
return|return
name|value
operator|/
name|tmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LONG_DOUBLE */
end_comment

begin_comment
comment|/* The converse: convert the DOUBLEST *FROM to an extended float    and store where TO points.  Neither FROM nor TO have any alignment    restrictions.  */
end_comment

begin_function
name|void
name|floatformat_from_doublest
parameter_list|(
name|fmt
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|CONST
name|struct
name|floatformat
modifier|*
name|fmt
decl_stmt|;
name|DOUBLEST
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|DOUBLEST
name|dfrom
decl_stmt|;
name|int
name|exponent
decl_stmt|;
name|DOUBLEST
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uto
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|to
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dfrom
argument_list|,
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|dfrom
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|uto
argument_list|,
literal|0
argument_list|,
name|fmt
operator|->
name|totalsize
operator|/
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfrom
operator|==
literal|0
condition|)
return|return;
comment|/* Result is zero */
if|if
condition|(
name|dfrom
operator|!=
name|dfrom
condition|)
comment|/* Result is NaN */
block|{
comment|/* From is NaN */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
comment|/* Be sure it's not infinity, but NaN value is irrel */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If negative, set the sign bit.  */
if|if
condition|(
name|dfrom
operator|<
literal|0
condition|)
block|{
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dfrom
operator|=
operator|-
name|dfrom
expr_stmt|;
block|}
if|if
condition|(
name|dfrom
operator|+
name|dfrom
operator|==
name|dfrom
operator|&&
name|dfrom
operator|!=
literal|0.0
condition|)
comment|/* Result is Infinity */
block|{
comment|/* Infinity exponent is same as NaN's.  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
comment|/* Infinity mantissa is all zeroes.  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
name|fmt
operator|->
name|man_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|mant
operator|=
name|ldfrexp
argument_list|(
name|dfrom
argument_list|,
operator|&
name|exponent
argument_list|)
expr_stmt|;
else|#
directive|else
name|mant
operator|=
name|frexp
argument_list|(
name|dfrom
argument_list|,
operator|&
name|exponent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|mant_long
decl_stmt|;
name|mant_bits
operator|=
name|mant_bits_left
operator|<
literal|32
condition|?
name|mant_bits_left
else|:
literal|32
expr_stmt|;
name|mant
operator|*=
literal|4294967296.0
expr_stmt|;
name|mant_long
operator|=
operator|(
name|unsigned
name|long
operator|)
name|mant
expr_stmt|;
name|mant
operator|-=
name|mant_long
expr_stmt|;
comment|/* If the integer bit is implicit, then we need to discard it. 	 If we are discarding a zero, we should be (but are not) creating 	 a denormalized	number which means adjusting the exponent 	 (I think).  */
if|if
condition|(
name|mant_bits_left
operator|==
name|fmt
operator|->
name|man_len
operator|&&
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
block|{
name|mant_long
operator|<<=
literal|1
expr_stmt|;
name|mant_bits
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mant_bits
operator|<
literal|32
condition|)
block|{
comment|/* The bits we want are in the most significant MANT_BITS bits of 	     mant_long.  Move them to the least significant.  */
name|mant_long
operator|>>=
literal|32
operator|-
name|mant_bits
expr_stmt|;
block|}
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|,
name|mant_long
argument_list|)
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
if|if
condition|(
name|fmt
operator|->
name|byteorder
operator|==
name|floatformat_littlebyte_bigword
condition|)
block|{
name|int
name|count
decl_stmt|;
name|unsigned
name|char
modifier|*
name|swaplow
init|=
name|uto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|swaphigh
init|=
name|uto
operator|+
literal|4
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|4
condition|;
name|count
operator|++
control|)
block|{
name|tmp
operator|=
operator|*
name|swaplow
expr_stmt|;
operator|*
name|swaplow
operator|++
operator|=
operator|*
name|swaphigh
expr_stmt|;
operator|*
name|swaphigh
operator|++
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* temporary storage using circular buffer */
end_comment

begin_define
define|#
directive|define
name|NUMCELLS
value|16
end_define

begin_define
define|#
directive|define
name|CELLSIZE
value|32
end_define

begin_function
specifier|static
name|char
modifier|*
name|get_cell
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
name|NUMCELLS
index|]
index|[
name|CELLSIZE
index|]
decl_stmt|;
specifier|static
name|int
name|cell
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|++
name|cell
operator|>=
name|NUMCELLS
condition|)
name|cell
operator|=
literal|0
expr_stmt|;
return|return
name|buf
index|[
name|cell
index|]
return|;
block|}
end_function

begin_comment
comment|/* print routines to handle variable size regs, etc.     FIXME: Note that t_addr is a bfd_vma, which is currently either an    unsigned long or unsigned long long, determined at configure time.    If t_addr is an unsigned long long and sizeof (unsigned long long)    is greater than sizeof (unsigned long), then I believe this code will    probably lose, at least for little endian machines.  I believe that    it would also be better to eliminate the switch on the absolute size    of t_addr and replace it with a sequence of if statements that compare    sizeof t_addr with sizeof the various types and do the right thing,    which includes knowing whether or not the host supports long long.    -fnf   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thirty_two
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* eliminate warning from compiler on 32-bit systems */
end_comment

begin_function
name|char
modifier|*
name|paddr
parameter_list|(
name|addr
parameter_list|)
name|t_addr
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|paddr_str
init|=
name|get_cell
argument_list|()
decl_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|t_addr
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%08lx%08lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr
operator|>>
name|thirty_two
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%04x"
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|addr
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|paddr_str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|preg
parameter_list|(
name|reg
parameter_list|)
name|t_reg
name|reg
decl_stmt|;
block|{
name|char
modifier|*
name|preg_str
init|=
name|get_cell
argument_list|()
decl_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|t_reg
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%08lx%08lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|reg
operator|>>
name|thirty_two
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|reg
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%04x"
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|reg
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|preg_str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|paddr_nz
parameter_list|(
name|addr
parameter_list|)
name|t_addr
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|paddr_str
init|=
name|get_cell
argument_list|()
decl_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|t_addr
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
block|{
name|unsigned
name|long
name|high
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr
operator|>>
name|thirty_two
argument_list|)
decl_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%lx%08lx"
argument_list|,
name|high
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%x"
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|addr
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|paddr_str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|paddr_str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|preg_nz
parameter_list|(
name|reg
parameter_list|)
name|t_reg
name|reg
decl_stmt|;
block|{
name|char
modifier|*
name|preg_str
init|=
name|get_cell
argument_list|()
decl_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|t_reg
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
block|{
name|unsigned
name|long
name|high
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|reg
operator|>>
name|thirty_two
argument_list|)
decl_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|reg
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%lx%08lx"
argument_list|,
name|high
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|reg
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%x"
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|reg
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|preg_str
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|preg_str
return|;
block|}
end_function

end_unit

