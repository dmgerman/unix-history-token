begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for GDB when running under Unix.    Copyright 1986-87, 1989, 1991-92, 1995, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
end_ifdef

begin_define
define|#
directive|define
name|PROCESS_GROUP_TYPE
value|pid_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_define
define|#
directive|define
name|PROCESS_GROUP_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SGTTY
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_PGRP
end_ifdef

begin_comment
comment|/* This is only used for the ultra.  Does it have pid_t?  */
end_comment

begin_define
define|#
directive|define
name|PROCESS_GROUP_TYPE
value|short
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROCESS_GROUP_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgtty */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|FASYNC
argument_list|)
operator|&&
name|defined
argument_list|(
name|FD_SET
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETOWN
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|handle_sigio
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|pass_signal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kill_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|terminal_ours_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Record terminal status separately for debugger and inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|stdin_serial
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TTY state for the inferior.  We save it whenever the inferior stops, and    restore it when it resumes.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_ttystate
name|inferior_ttystate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our own tty state, which we restore every time we need to deal with the    terminal.  We only set it once, when GDB first starts.  The settings of    flags which readline saves and restores and unimportant.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_ttystate
name|our_ttystate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fcntl flags for us and the inferior.  Saved and restored just like    {our,inferior}_ttystate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tflags_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tflags_ours
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PROCESS_GROUP_TYPE
end_ifdef

begin_comment
comment|/* Process group for us and the inferior.  Saved and restored just like    {our,inferior}_ttystate.  */
end_comment

begin_decl_stmt
name|PROCESS_GROUP_TYPE
name|our_process_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PROCESS_GROUP_TYPE
name|inferior_process_group
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* While the inferior is running, we want SIGINT and SIGQUIT to go to the    inferior only.  If we have job control, that takes care of it.  If not,    we save our handlers in these two variables and set SIGINT and SIGQUIT    to SIG_IGN.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|sigint_ours
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|sigquit_ours
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name of the tty (from the `tty' command) that we gave to the inferior    when it was last started.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inferior_thisrun_terminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if our terminal settings are in effect.  Zero if the    inferior's settings are in effect.  Ignored if !gdb_has_a_terminal    ().  */
end_comment

begin_decl_stmt
name|int
name|terminal_is_ours
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|yes
block|,
name|no
block|,
name|have_not_checked
block|}
name|gdb_has_a_terminal_flag
init|=
name|have_not_checked
enum|;
end_enum

begin_comment
comment|/* Does GDB have a terminal (on stdin)?  */
end_comment

begin_function
name|int
name|gdb_has_a_terminal
parameter_list|()
block|{
switch|switch
condition|(
name|gdb_has_a_terminal_flag
condition|)
block|{
case|case
name|yes
case|:
return|return
literal|1
return|;
case|case
name|no
case|:
return|return
literal|0
return|;
case|case
name|have_not_checked
case|:
comment|/* Get all the current tty settings (including whether we have a tty at 	 all!).  Can't do this in _initialize_inflow because SERIAL_FDOPEN 	 won't work until the serial_ops_list is initialized.  */
ifdef|#
directive|ifdef
name|F_GETFL
name|tflags_ours
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gdb_has_a_terminal_flag
operator|=
name|no
expr_stmt|;
name|stdin_serial
operator|=
name|SERIAL_FDOPEN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdin_serial
operator|!=
name|NULL
condition|)
block|{
name|our_ttystate
operator|=
name|SERIAL_GET_TTY_STATE
argument_list|(
name|stdin_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|our_ttystate
operator|!=
name|NULL
condition|)
block|{
name|gdb_has_a_terminal_flag
operator|=
name|yes
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|our_process_group
operator|=
name|tcgetpgrp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|our_process_group
operator|=
name|getpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|our_process_group
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|gdb_has_a_terminal_flag
operator|==
name|yes
return|;
default|default:
comment|/* "Can't happen".  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Macro for printing errors from ioctl operations */
end_comment

begin_define
define|#
directive|define
name|OOPSY
parameter_list|(
name|what
parameter_list|)
define|\
value|if (result == -1)	\     fprintf_unfiltered(gdb_stderr, "[%s failed in terminal_inferior: %s]\n", \ 	    what, strerror (errno))
end_define

begin_decl_stmt
specifier|static
name|void
name|terminal_ours_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the terminal settings we record for the inferior,    before we actually run the inferior.  */
end_comment

begin_function
name|void
name|terminal_init_inferior_with_pgrp
parameter_list|(
name|pgrp
parameter_list|)
name|int
name|pgrp
decl_stmt|;
block|{
if|if
condition|(
name|gdb_has_a_terminal
argument_list|()
condition|)
block|{
comment|/* We could just as well copy our_ttystate (if we felt like adding 	 a new function SERIAL_COPY_TTY_STATE).  */
if|if
condition|(
name|inferior_ttystate
condition|)
name|free
argument_list|(
name|inferior_ttystate
argument_list|)
expr_stmt|;
name|inferior_ttystate
operator|=
name|SERIAL_GET_TTY_STATE
argument_list|(
name|stdin_serial
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCESS_GROUP_TYPE
name|inferior_process_group
operator|=
name|pgrp
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure that next time we call terminal_inferior (which will be 	 before the program runs, as it needs to be), we install the new 	 process group.  */
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|terminal_init_inferior
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PROCESS_GROUP_TYPE
comment|/* This is for Lynx, and should be cleaned up by having Lynx be a separate      debugging target with a version of target_terminal_init_inferior which      passes in the process group to a generic routine which does all the work      (and the non-threaded child_terminal_init_inferior can just pass in      inferior_pid to the same routine).  */
comment|/* We assume INFERIOR_PID is also the child's process group.  */
name|terminal_init_inferior_with_pgrp
argument_list|(
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROCESS_GROUP_TYPE */
block|}
end_function

begin_comment
comment|/* Put the inferior's terminal settings into effect.    This is preparation for starting or resuming the inferior.  */
end_comment

begin_function
name|void
name|terminal_inferior
parameter_list|()
block|{
if|if
condition|(
name|gdb_has_a_terminal
argument_list|()
operator|&&
name|terminal_is_ours
operator|&&
name|inferior_thisrun_terminal
operator|==
literal|0
condition|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|F_GETFL
comment|/* Is there a reason this is being done twice?  It happens both 	 places we use F_SETFL, so I'm inclined to think perhaps there 	 is some reason, however perverse.  Perhaps not though...  */
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"fcntl F_SETFL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Because we were careful to not change in or out of raw mode in 	 terminal_ours, we will not change in our out of raw mode with 	 this call, so we don't flush any input.  */
name|result
operator|=
name|SERIAL_SET_TTY_STATE
argument_list|(
name|stdin_serial
argument_list|,
name|inferior_ttystate
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"setting tty state"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|job_control
condition|)
block|{
name|sigint_ours
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|sigquit_ours
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If attach_flag is set, we don't know whether we are sharing a 	 terminal with the inferior or not.  (attaching a process 	 without a terminal is one case where we do not; attaching a 	 process which we ran from the same shell as GDB via `&' is 	 one case where we do, I think (but perhaps this is not 	 `sharing' in the sense that we need to save and restore tty 	 state)).  I don't know if there is any way to tell whether we 	 are sharing a terminal.  So what we do is to go through all 	 the saving and restoring of the tty state, but ignore errors 	 setting the process group, which will happen if we are not 	 sharing a terminal).  */
if|if
condition|(
name|job_control
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|result
operator|=
name|tcsetpgrp
argument_list|(
literal|0
argument_list|,
name|inferior_process_group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attach_flag
condition|)
name|OOPSY
argument_list|(
literal|"tcsetpgrp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|inferior_process_group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attach_flag
condition|)
name|OOPSY
argument_list|(
literal|"TIOCSPGRP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|terminal_is_ours
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put some of our terminal settings into effect,    enough to get proper results from our output,    but do not change into or out of RAW mode    so that no input is discarded.     After doing this, either terminal_ours or terminal_inferior    should be called to get back to a normal state of affairs.  */
end_comment

begin_function
name|void
name|terminal_ours_for_output
parameter_list|()
block|{
name|terminal_ours_1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put our terminal settings into effect.    First record the inferior's terminal settings    so they can be restored properly later.  */
end_comment

begin_function
name|void
name|terminal_ours
parameter_list|()
block|{
name|terminal_ours_1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_only is not used, and should not be used unless we introduce    separate terminal_is_ours and terminal_is_ours_for_output    flags.  */
end_comment

begin_function
specifier|static
name|void
name|terminal_ours_1
parameter_list|(
name|output_only
parameter_list|)
name|int
name|output_only
decl_stmt|;
block|{
comment|/* Checking inferior_thisrun_terminal is necessary so that      if GDB is running in the background, it won't block trying      to do the ioctl()'s below.  Checking gdb_has_a_terminal      avoids attempting all the ioctl's when running in batch.  */
if|if
condition|(
name|inferior_thisrun_terminal
operator|!=
literal|0
operator|||
name|gdb_has_a_terminal
argument_list|()
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
block|{
comment|/* Ignore this signal since it will happen when we try to set the 	 pgrp.  */
name|void
function_decl|(
modifier|*
name|osigttou
function_decl|)
parameter_list|()
function_decl|;
name|int
name|result
decl_stmt|;
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTTOU
if|if
condition|(
name|job_control
condition|)
name|osigttou
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|inferior_ttystate
condition|)
name|free
argument_list|(
name|inferior_ttystate
argument_list|)
expr_stmt|;
name|inferior_ttystate
operator|=
name|SERIAL_GET_TTY_STATE
argument_list|(
name|stdin_serial
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|inferior_process_group
operator|=
name|tcgetpgrp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|inferior_process_group
operator|=
name|getpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|inferior_process_group
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Here we used to set ICANON in our ttystate, but I believe this 	 was an artifact from before when we used readline.  Readline sets 	 the tty state when it needs to. 	 FIXME-maybe: However, query() expects non-raw mode and doesn't 	 use readline.  Maybe query should use readline (on the other hand, 	 this only matters for HAVE_SGTTY, not termio or termios, I think).  */
comment|/* Set tty state to our_ttystate.  We don't change in our out of raw 	 mode, to avoid flushing input.  We need to do the same thing 	 regardless of output_only, because we don't have separate 	 terminal_is_ours and terminal_is_ours_for_output flags.  It's OK, 	 though, since readline will deal with raw mode when/if it needs to. 	 */
name|SERIAL_NOFLUSH_SET_TTY_STATE
argument_list|(
name|stdin_serial
argument_list|,
name|our_ttystate
argument_list|,
name|inferior_ttystate
argument_list|)
expr_stmt|;
if|if
condition|(
name|job_control
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|result
operator|=
name|tcsetpgrp
argument_list|(
literal|0
argument_list|,
name|our_process_group
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This fails on Ultrix with EINVAL if you run the testsuite 	     in the background with nohup, and then log out.  GDB never 	     used to check for an error here, so perhaps there are other 	     such situations as well.  */
block|if (result == -1) 	    fprintf_unfiltered (gdb_stderr, "[tcsetpgrp failed in terminal_ours: %s]\n", 		     strerror (errno));
endif|#
directive|endif
endif|#
directive|endif
comment|/* termios */
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|our_process_group
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SIGTTOU
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|osigttou
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|job_control
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_ours
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigquit_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|F_GETFL
name|tflags_inferior
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Is there a reason this is being done twice?  It happens both 	 places we use F_SETFL, so I'm inclined to think perhaps there 	 is some reason, however perverse.  Perhaps not though...  */
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_ours
argument_list|)
expr_stmt|;
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|result
expr_stmt|;
comment|/* lint */
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|term_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|target_terminal_info
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|child_terminal_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|gdb_has_a_terminal
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"This GDB does not control a terminal.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Inferior's terminal status (currently saved by GDB):\n"
argument_list|)
expr_stmt|;
comment|/* First the fcntl flags.  */
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|tflags_inferior
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"File descriptor flags = "
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|O_ACCMODE
define|#
directive|define
name|O_ACCMODE
value|(O_RDONLY | O_WRONLY | O_RDWR)
endif|#
directive|endif
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug */
switch|switch
condition|(
name|flags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|printf_filtered
argument_list|(
literal|"O_RDONLY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|printf_filtered
argument_list|(
literal|"O_WRONLY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|printf_filtered
argument_list|(
literal|"O_RDWR"
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|&=
operator|~
operator|(
name|O_ACCMODE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|printf_filtered
argument_list|(
literal|" | O_NONBLOCK"
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
comment|/* If O_NDELAY and O_NONBLOCK are defined to the same thing, we will        print it as O_NONBLOCK, which is good cause that is what POSIX        has, and the flag will already be cleared by the time we get here.  */
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
name|printf_filtered
argument_list|(
literal|" | O_NDELAY"
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|O_NDELAY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|O_APPEND
condition|)
name|printf_filtered
argument_list|(
literal|" | O_APPEND"
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|O_APPEND
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|O_BINARY
argument_list|)
if|if
condition|(
name|flags
operator|&
name|O_BINARY
condition|)
name|printf_filtered
argument_list|(
literal|" | O_BINARY"
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
condition|)
name|printf_filtered
argument_list|(
literal|" | 0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCESS_GROUP_TYPE
name|printf_filtered
argument_list|(
literal|"Process group = %d\n"
argument_list|,
name|inferior_process_group
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SERIAL_PRINT_TTY_STATE
argument_list|(
name|stdin_serial
argument_list|,
name|inferior_ttystate
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* NEW_TTY_PREFORK is called before forking a new child process,    so we can record the state of ttys in the child to be formed.    TTYNAME is null if we are to share the terminal with gdb;    or points to a string containing the name of the desired tty.     NEW_TTY is called in new child processes under Unix, which will    become debugger target processes.  This actually switches to    the terminal specified in the NEW_TTY_PREFORK call.  */
end_comment

begin_function
name|void
name|new_tty_prefork
parameter_list|(
name|ttyname
parameter_list|)
name|char
modifier|*
name|ttyname
decl_stmt|;
block|{
comment|/* Save the name for later, for determining whether we and the child      are sharing a tty.  */
name|inferior_thisrun_terminal
operator|=
name|ttyname
expr_stmt|;
block|}
end_function

begin_function
name|void
name|new_tty
parameter_list|()
block|{
specifier|register
name|int
name|tty
decl_stmt|;
if|if
condition|(
name|inferior_thisrun_terminal
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* Disconnect the child process from our controlling terminal.  On some      systems (SVR4 for example), this may cause a SIGTTOU, so temporarily      ignore SIGTTOU. */
name|tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|>
literal|0
condition|)
block|{
name|void
function_decl|(
modifier|*
name|osigttou
function_decl|)
parameter_list|()
function_decl|;
name|osigttou
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|osigttou
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now open the specified new terminal.  */
ifdef|#
directive|ifdef
name|USE_O_NOCTTY
name|tty
operator|=
name|open
argument_list|(
name|inferior_thisrun_terminal
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
else|#
directive|else
name|tty
operator|=
name|open
argument_list|(
name|inferior_thisrun_terminal
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tty
operator|==
operator|-
literal|1
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|inferior_thisrun_terminal
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid use of dup2; doesn't exist on all systems.  */
if|if
condition|(
name|tty
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|!=
literal|2
condition|)
block|{
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|>
literal|2
condition|)
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !go32&& !win32*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kill_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* FIXME:  This should not really be inferior_pid (or target_has_execution).      It should be a distinct flag that indicates that a target is active, cuz      some targets don't have processes! */
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Kill the program being debugged? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|target_kill
argument_list|()
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
comment|/* Destroy thread info */
comment|/* Killing off the inferior can leave us with a core file.  If so,      print the state we are left in.  */
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"In %s,\n"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|fputs_filtered
argument_list|(
literal|"No selected stack frame.\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
else|else
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call set_sigint_trap when you need to pass a signal on to an attached    process when handling SIGINT */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|pass_signal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|_WIN32
name|kill
argument_list|(
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|osig
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|set_sigint_trap
parameter_list|()
block|{
if|if
condition|(
name|attach_flag
operator|||
name|inferior_thisrun_terminal
condition|)
block|{
name|osig
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|pass_signal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|clear_sigint_trap
parameter_list|()
block|{
if|if
condition|(
name|attach_flag
operator|||
name|inferior_thisrun_terminal
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|FASYNC
argument_list|)
operator|&&
name|defined
argument_list|(
name|FD_SET
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETOWN
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_sigio
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|handle_sigio
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|numfds
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|handle_sigio
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|target_activity_fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|numfds
operator|=
name|select
argument_list|(
name|target_activity_fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|target_activity_fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|_WIN32
if|if
condition|(
call|(
modifier|*
name|target_activity_function
call|)
argument_list|()
condition|)
name|kill
argument_list|(
name|inferior_pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|old_fcntl_flags
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_sigio_trap
parameter_list|()
block|{
if|if
condition|(
name|target_activity_function
condition|)
block|{
name|old_sigio
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|handle_sigio
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|target_activity_fd
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|old_fcntl_flags
operator|=
name|fcntl
argument_list|(
name|target_activity_fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|target_activity_fd
argument_list|,
name|F_SETFL
argument_list|,
name|old_fcntl_flags
operator||
name|FASYNC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|clear_sigio_trap
parameter_list|()
block|{
if|if
condition|(
name|target_activity_function
condition|)
block|{
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|old_sigio
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|target_activity_fd
argument_list|,
name|F_SETFL
argument_list|,
name|old_fcntl_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No SIGIO.  */
end_comment

begin_function
name|void
name|set_sigio_trap
parameter_list|()
block|{
if|if
condition|(
name|target_activity_function
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_sigio_trap
parameter_list|()
block|{
if|if
condition|(
name|target_activity_function
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No SIGIO.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This is here because this is where we figure out whether we (probably)    have job control.  Just using job_control only does part of it because    setpgid or setpgrp might not exist on a system without job control.    It might be considered misplaced (on the other hand, process groups and    job control are closely related to ttys).     For a more clean implementation, in libiberty, put a setpgid which merely    calls setpgrp and a setpgrp which does nothing (any system with job control    will have one or the other).  */
end_comment

begin_function
name|int
name|gdb_setpgid
parameter_list|()
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|job_control
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEED_POSIX_SETPGID
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETPGID
argument_list|)
operator|)
comment|/* setpgid (0, 0) is supposed to work and mean the same thing as 	 this, but on Ultrix 4.2A it fails with EPERM (and 	 setpgid (getpid (), getpid ()) succeeds).  */
name|retval
operator|=
name|setpgid
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TIOCGPGRP
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SETPGRP_ARGS
argument_list|)
name|retval
operator|=
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|setpgrp
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* TIOCGPGRP.  */
endif|#
directive|endif
comment|/* NEED_POSIX_SETPGID */
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|_initialize_inflow
parameter_list|()
block|{
name|add_info
argument_list|(
literal|"terminal"
argument_list|,
name|term_info
argument_list|,
literal|"Print inferior's saved terminal status."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"kill"
argument_list|,
name|class_run
argument_list|,
name|kill_command
argument_list|,
literal|"Kill execution of program being debugged."
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
comment|/* OK, figure out whether we have job control.  If neither termios nor      sgtty (i.e. termio or go32), leave job_control 0.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* Do all systems with termios have the POSIX way of identifying job      control?  I hope so.  */
ifdef|#
directive|ifdef
name|_POSIX_JOB_CONTROL
name|job_control
operator|=
literal|1
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_SC_JOB_CONTROL
name|job_control
operator|=
name|sysconf
argument_list|(
name|_SC_JOB_CONTROL
argument_list|)
expr_stmt|;
else|#
directive|else
name|job_control
operator|=
literal|0
expr_stmt|;
comment|/* have to assume the worst */
endif|#
directive|endif
comment|/* _SC_JOB_CONTROL */
endif|#
directive|endif
comment|/* _POSIX_JOB_CONTROL */
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SGTTY
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|job_control
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|job_control
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
endif|#
directive|endif
comment|/* sgtty */
block|}
end_function

end_unit

