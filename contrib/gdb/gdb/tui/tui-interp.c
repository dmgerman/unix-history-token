begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* TUI Interpreter definitions for GDB, the GNU debugger.     Copyright 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"interps.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"cli-out.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-io.h"
end_include

begin_comment
comment|/* Set to 1 when the TUI mode must be activated when we first start gdb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tui_start_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleanup the tui before exiting.  */
end_comment

begin_function
specifier|static
name|void
name|tui_exit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Disable the tui.  Curses mode is left leaving the screen      in a clean state (see endwin()).  */
name|tui_disable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These implement the TUI interpreter.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|tui_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Install exit handler to leave the screen in a good shape.  */
name|atexit
argument_list|(
name|tui_exit
argument_list|)
expr_stmt|;
name|tui_initialize_static_data
argument_list|()
expr_stmt|;
name|tui_initialize_io
argument_list|()
expr_stmt|;
name|tui_initialize_readline
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tui_resume
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|stream
decl_stmt|;
comment|/* gdb_setup_readline will change gdb_stdout.  If the TUI was previously      writing to gdb_stdout, then set it to the new gdb_stdout afterwards.  */
name|stream
operator|=
name|cli_out_set_stream
argument_list|(
name|tui_old_uiout
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|gdb_stdout
condition|)
block|{
name|cli_out_set_stream
argument_list|(
name|tui_old_uiout
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
name|gdb_setup_readline
argument_list|()
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|NULL
condition|)
name|cli_out_set_stream
argument_list|(
name|tui_old_uiout
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_start_enabled
condition|)
name|tui_enable
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tui_suspend
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tui_start_enabled
operator|=
name|tui_active
expr_stmt|;
name|tui_disable
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Display the prompt if we are silent.  */
end_comment

begin_function
specifier|static
name|int
name|tui_display_prompt_p
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|interp_quiet_p
argument_list|(
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tui_exec
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|command_str
parameter_list|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_exec called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize all the necessary variables, start the event loop,    register readline, and stdin, start the loop.  */
end_comment

begin_function
specifier|static
name|void
name|tui_command_loop
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|a_prompt
decl_stmt|;
name|char
modifier|*
name|gdb_prompt
init|=
name|get_prompt
argument_list|()
decl_stmt|;
comment|/* If we are using readline, set things up and display the first      prompt, otherwise just print the prompt.  */
if|if
condition|(
name|async_command_editing_p
condition|)
block|{
comment|/* Tell readline what the prompt to display is and what function          it will need to call after a whole line is read. This also          displays the first prompt.  */
name|length
operator|=
name|strlen
argument_list|(
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdb_prompt
argument_list|)
operator|+
name|strlen
argument_list|(
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|a_prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|a_prompt
argument_list|,
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|a_prompt
argument_list|,
name|gdb_prompt
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|a_prompt
argument_list|,
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rl_callback_handler_install
argument_list|(
name|a_prompt
argument_list|,
name|input_handler
argument_list|)
expr_stmt|;
block|}
else|else
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Loop until there is nothing to do. This is the entry point to the      event loop engine. gdb_do_one_event, called via catch_errors()      will process one event for each invocation.  It blocks waits for      an event and then processes it.>0 when an event is processed, 0      when catch_errors() caught an error and<0 when there are no      longer any event sources registered.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|result
init|=
name|catch_errors
argument_list|(
name|gdb_do_one_event
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
break|break;
comment|/* Update gdb output according to TUI mode.  Since catch_errors          preserves the uiout from changing, this must be done at top          level of event loop.  */
if|if
condition|(
name|tui_active
condition|)
name|uiout
operator|=
name|tui_out
expr_stmt|;
else|else
name|uiout
operator|=
name|tui_old_uiout
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: this should really be a call to a hook that is 	     interface specific, because interfaces can display the 	     prompt in their own way.  */
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This call looks bizarre, but it is required.  If the user 	     entered a command that caused an error, 	     after_char_processing_hook won't be called from 	     rl_callback_read_char_wrapper.  Using a cleanup there 	     won't work, since we want this function to be called 	     after a new prompt is printed.  */
if|if
condition|(
name|after_char_processing_hook
condition|)
call|(
modifier|*
name|after_char_processing_hook
call|)
argument_list|()
expr_stmt|;
comment|/* Maybe better to set a flag to be checked somewhere as to 	     whether display the prompt or not.  */
block|}
block|}
comment|/* We are done with the event loop. There are no more event sources      to listen to.  So we exit GDB.  */
return|return;
block|}
end_function

begin_function
name|void
name|_initialize_tui_interp
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|interp_procs
name|procs
init|=
block|{
name|tui_init
block|,
name|tui_resume
block|,
name|tui_suspend
block|,
name|tui_exec
block|,
name|tui_display_prompt_p
block|,
name|tui_command_loop
block|,   }
decl_stmt|;
name|struct
name|interp
modifier|*
name|tui_interp
decl_stmt|;
comment|/* Create a default uiout builder for the TUI. */
name|tui_out
operator|=
name|tui_out_new
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|interp_add
argument_list|(
name|interp_new
argument_list|(
literal|"tui"
argument_list|,
name|NULL
argument_list|,
name|tui_out
argument_list|,
operator|&
name|procs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interpreter_p
operator|&&
name|strcmp
argument_list|(
name|interpreter_p
argument_list|,
literal|"tui"
argument_list|)
operator|==
literal|0
condition|)
name|tui_start_enabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|interpreter_p
operator|&&
name|strcmp
argument_list|(
name|interpreter_p
argument_list|,
name|INTERP_CONSOLE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|interpreter_p
argument_list|)
expr_stmt|;
name|interpreter_p
operator|=
name|xstrdup
argument_list|(
literal|"tui"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

