begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembly display.     Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Hewlett-Packard Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"disasm.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-layout.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-winsource.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-stack.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-file.h"
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_struct
struct|struct
name|tui_asm_line
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|addr_string
decl_stmt|;
name|char
modifier|*
name|insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Function to set the disassembly window's content.    Disassemble count lines starting at pc.    Return address of the count'th instruction after pc.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|tui_disassemble
parameter_list|(
name|struct
name|tui_asm_line
modifier|*
name|asm_lines
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|gdb_dis_out
decl_stmt|;
comment|/* now init the ui_file structure */
name|gdb_dis_out
operator|=
name|tui_sfileopen
argument_list|(
literal|256
argument_list|)
expr_stmt|;
comment|/* Now construct each line */
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|asm_lines
operator|++
control|)
block|{
if|if
condition|(
name|asm_lines
operator|->
name|addr_string
condition|)
name|xfree
argument_list|(
name|asm_lines
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_lines
operator|->
name|insn
condition|)
name|xfree
argument_list|(
name|asm_lines
operator|->
name|insn
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|pc
argument_list|,
name|gdb_dis_out
argument_list|)
expr_stmt|;
name|asm_lines
operator|->
name|addr
operator|=
name|pc
expr_stmt|;
name|asm_lines
operator|->
name|addr_string
operator|=
name|xstrdup
argument_list|(
name|tui_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|gdb_dis_out
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pc
operator|+
name|gdb_print_insn
argument_list|(
name|pc
argument_list|,
name|gdb_dis_out
argument_list|)
expr_stmt|;
name|asm_lines
operator|->
name|insn
operator|=
name|xstrdup
argument_list|(
name|tui_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset the buffer to empty */
name|ui_file_rewind
argument_list|(
name|gdb_dis_out
argument_list|)
expr_stmt|;
block|}
name|ui_file_delete
argument_list|(
name|gdb_dis_out
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Find the disassembly address that corresponds to FROM lines    above or below the PC.  Variable sized instructions are taken    into account by the algorithm.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|tui_find_disassembly_address
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|CORE_ADDR
name|new_low
decl_stmt|;
name|int
name|max_lines
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tui_asm_line
modifier|*
name|asm_lines
decl_stmt|;
name|max_lines
operator|=
operator|(
name|from
operator|>
literal|0
operator|)
condition|?
name|from
else|:
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|max_lines
operator|<=
literal|1
condition|)
return|return
name|pc
return|;
name|asm_lines
operator|=
operator|(
expr|struct
name|tui_asm_line
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tui_asm_line
argument_list|)
operator|*
name|max_lines
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|asm_lines
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tui_asm_line
argument_list|)
operator|*
name|max_lines
argument_list|)
expr_stmt|;
name|new_low
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|from
operator|>
literal|0
condition|)
block|{
name|tui_disassemble
argument_list|(
name|asm_lines
argument_list|,
name|pc
argument_list|,
name|max_lines
argument_list|)
expr_stmt|;
name|new_low
operator|=
name|asm_lines
index|[
name|max_lines
operator|-
literal|1
index|]
operator|.
name|addr
expr_stmt|;
block|}
else|else
block|{
name|CORE_ADDR
name|last_addr
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Find backward an address which is a symbol          and for which disassembling from that address will fill          completely the window.  */
name|pos
operator|=
name|max_lines
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|new_low
operator|-=
literal|1
operator|*
name|max_lines
expr_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|new_low
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
condition|)
name|new_low
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
else|else
name|new_low
operator|+=
literal|1
operator|*
name|max_lines
expr_stmt|;
name|tui_disassemble
argument_list|(
name|asm_lines
argument_list|,
name|new_low
argument_list|,
name|max_lines
argument_list|)
expr_stmt|;
name|last_addr
operator|=
name|asm_lines
index|[
name|pos
index|]
operator|.
name|addr
expr_stmt|;
block|}
do|while
condition|(
name|last_addr
operator|>
name|pc
operator|&&
name|msymbol
condition|)
do|;
comment|/* Scan forward disassembling one instruction at a time          until the last visible instruction of the window          matches the pc.  We keep the disassembled instructions          in the 'lines' window and shift it downward (increasing          its addresses).  */
if|if
condition|(
name|last_addr
operator|<
name|pc
condition|)
do|do
block|{
name|CORE_ADDR
name|next_addr
decl_stmt|;
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|max_lines
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|next_addr
operator|=
name|tui_disassemble
argument_list|(
operator|&
name|asm_lines
index|[
name|pos
index|]
argument_list|,
name|last_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If there are some problems while disassembling exit.  */
if|if
condition|(
name|next_addr
operator|<=
name|last_addr
condition|)
break|break;
name|last_addr
operator|=
name|next_addr
expr_stmt|;
block|}
do|while
condition|(
name|last_addr
operator|<=
name|pc
condition|)
do|;
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|max_lines
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|new_low
operator|=
name|asm_lines
index|[
name|pos
index|]
operator|.
name|addr
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_lines
condition|;
name|i
operator|++
control|)
block|{
name|xfree
argument_list|(
name|asm_lines
index|[
name|i
index|]
operator|.
name|addr_string
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|asm_lines
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|new_low
return|;
block|}
end_function

begin_comment
comment|/* Function to set the disassembly window's content.  */
end_comment

begin_function
name|enum
name|tui_status
name|tui_set_disassem_content
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|enum
name|tui_status
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
init|=
name|TUI_DISASM_WIN
operator|->
name|detail
operator|.
name|source_info
operator|.
name|horizontal_offset
decl_stmt|;
name|int
name|line_width
decl_stmt|,
name|max_lines
decl_stmt|;
name|CORE_ADDR
name|cur_pc
decl_stmt|;
name|struct
name|tui_gen_win_info
modifier|*
name|locator
init|=
name|tui_locator_win_info_ptr
argument_list|()
decl_stmt|;
name|int
name|tab_len
init|=
name|tui_default_tab_len
argument_list|()
decl_stmt|;
name|struct
name|tui_asm_line
modifier|*
name|asm_lines
decl_stmt|;
name|int
name|insn_pos
decl_stmt|;
name|int
name|addr_size
decl_stmt|,
name|max_size
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
name|TUI_FAILURE
return|;
name|ret
operator|=
name|tui_alloc_source_buffer
argument_list|(
name|TUI_DISASM_WIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TUI_SUCCESS
condition|)
return|return
name|ret
return|;
name|TUI_DISASM_WIN
operator|->
name|detail
operator|.
name|source_info
operator|.
name|start_line_or_addr
operator|.
name|addr
operator|=
name|pc
expr_stmt|;
name|cur_pc
operator|=
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|locator
operator|.
name|addr
argument_list|)
expr_stmt|;
name|max_lines
operator|=
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|height
operator|-
literal|2
expr_stmt|;
comment|/* account for hilite */
comment|/* Get temporary table that will hold all strings (addr& insn).  */
name|asm_lines
operator|=
operator|(
expr|struct
name|tui_asm_line
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tui_asm_line
argument_list|)
operator|*
name|max_lines
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|asm_lines
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tui_asm_line
argument_list|)
operator|*
name|max_lines
argument_list|)
expr_stmt|;
name|line_width
operator|=
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|width
operator|-
literal|1
expr_stmt|;
name|tui_disassemble
argument_list|(
name|asm_lines
argument_list|,
name|pc
argument_list|,
name|max_lines
argument_list|)
expr_stmt|;
comment|/* See what is the maximum length of an address and of a line.  */
name|addr_size
operator|=
literal|0
expr_stmt|;
name|max_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_lines
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|asm_lines
index|[
name|i
index|]
operator|.
name|addr_string
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|addr_size
condition|)
name|addr_size
operator|=
name|len
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|asm_lines
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
operator|+
name|tab_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|len
expr_stmt|;
block|}
name|max_size
operator|+=
name|addr_size
operator|+
name|tab_len
expr_stmt|;
comment|/* Allocate memory to create each line.  */
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
name|insn_pos
operator|=
operator|(
literal|1
operator|+
operator|(
name|addr_size
operator|/
name|tab_len
operator|)
operator|)
operator|*
name|tab_len
expr_stmt|;
comment|/* Now construct each line */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_lines
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_win_element
modifier|*
name|element
decl_stmt|;
name|struct
name|tui_source_element
modifier|*
name|src
decl_stmt|;
name|int
name|cur_len
decl_stmt|;
name|element
operator|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
expr_stmt|;
name|src
operator|=
operator|&
name|element
operator|->
name|which_element
operator|.
name|source
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|asm_lines
index|[
name|i
index|]
operator|.
name|addr_string
argument_list|)
expr_stmt|;
name|cur_len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Add spaces to make the instructions start on the same column */
while|while
condition|(
name|cur_len
operator|<
name|insn_pos
condition|)
block|{
name|strcat
argument_list|(
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|cur_len
operator|++
expr_stmt|;
block|}
name|strcat
argument_list|(
name|line
argument_list|,
name|asm_lines
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
comment|/* Now copy the line taking the offset into account */
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|>
name|offset
condition|)
name|strcpy
argument_list|(
name|src
operator|->
name|line
argument_list|,
operator|&
name|line
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
else|else
name|src
operator|->
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|src
operator|->
name|line_or_addr
operator|.
name|addr
operator|=
name|asm_lines
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|src
operator|->
name|is_exec_point
operator|=
name|asm_lines
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|cur_pc
expr_stmt|;
comment|/* See whether there is a breakpoint installed.  */
name|src
operator|->
name|has_break
operator|=
operator|(
operator|!
name|src
operator|->
name|is_exec_point
operator|&&
name|breakpoint_here_p
argument_list|(
name|pc
argument_list|)
operator|!=
name|no_breakpoint_here
operator|)
expr_stmt|;
name|xfree
argument_list|(
name|asm_lines
index|[
name|i
index|]
operator|.
name|addr_string
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|asm_lines
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
block|}
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|content_size
operator|=
name|i
expr_stmt|;
return|return
name|TUI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Function to display the disassembly window with disassembled code.   */
end_comment

begin_function
name|void
name|tui_show_disassem
parameter_list|(
name|CORE_ADDR
name|start_addr
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|find_pc_symtab
argument_list|(
name|start_addr
argument_list|)
decl_stmt|;
name|struct
name|tui_win_info
modifier|*
name|win_with_focus
init|=
name|tui_win_with_focus
argument_list|()
decl_stmt|;
name|union
name|tui_line_or_address
name|val
decl_stmt|;
name|val
operator|.
name|addr
operator|=
name|start_addr
expr_stmt|;
name|tui_add_win_to_layout
argument_list|(
name|DISASSEM_WIN
argument_list|)
expr_stmt|;
name|tui_update_source_window
argument_list|(
name|TUI_DISASM_WIN
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      ** if the focus was in the src win, put it in the asm win, if the      ** source view isn't split    */
if|if
condition|(
name|tui_current_layout
argument_list|()
operator|!=
name|SRC_DISASSEM_COMMAND
operator|&&
name|win_with_focus
operator|==
name|TUI_SRC_WIN
condition|)
name|tui_set_win_focus_to
argument_list|(
name|TUI_DISASM_WIN
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Function to display the disassembly window.   */
end_comment

begin_function
name|void
name|tui_show_disassem_and_update_source
parameter_list|(
name|CORE_ADDR
name|start_addr
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|tui_show_disassem
argument_list|(
name|start_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_current_layout
argument_list|()
operator|==
name|SRC_DISASSEM_COMMAND
condition|)
block|{
name|union
name|tui_line_or_address
name|val
decl_stmt|;
comment|/*          ** Update what is in the source window if it is displayed too,          ** note that it follows what is in the disassembly window and visa-versa        */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|start_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|.
name|line_no
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|tui_update_source_window
argument_list|(
name|TUI_SRC_WIN
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
block|{
name|set_current_source_symtab_and_line
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
name|tui_update_locator_filename
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|tui_update_locator_filename
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|CORE_ADDR
name|tui_get_begin_asm_address
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|locator
decl_stmt|;
name|struct
name|tui_locator_element
modifier|*
name|element
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|locator
operator|=
name|tui_locator_win_info_ptr
argument_list|()
expr_stmt|;
name|element
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|locator
expr_stmt|;
if|if
condition|(
name|element
operator|->
name|addr
operator|==
literal|0
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|main_symbol
decl_stmt|;
comment|/* Find address of the start of program.          Note: this should be language specific.  */
name|main_symbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"main"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_symbol
operator|==
literal|0
condition|)
name|main_symbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"MAIN"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_symbol
operator|==
literal|0
condition|)
name|main_symbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_start"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_symbol
condition|)
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|main_symbol
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* the target is executing */
name|addr
operator|=
name|element
operator|->
name|addr
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Determine what the low address will be to display in the TUI's    disassembly window.  This may or may not be the same as the    low address input.  */
end_comment

begin_function
name|CORE_ADDR
name|tui_get_low_disassembly_address
parameter_list|(
name|CORE_ADDR
name|low
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
comment|/* Determine where to start the disassembly so that the pc is about in the      middle of the viewport.  */
name|pos
operator|=
name|tui_default_win_viewport_height
argument_list|(
name|DISASSEM_WIN
argument_list|,
name|DISASSEM_COMMAND
argument_list|)
operator|/
literal|2
expr_stmt|;
name|pc
operator|=
name|tui_find_disassembly_address
argument_list|(
name|pc
argument_list|,
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|low
condition|)
name|pc
operator|=
name|low
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Scroll the disassembly forward or backward vertically.  */
end_comment

begin_function
name|void
name|tui_vertical_disassem_scroll
parameter_list|(
name|enum
name|tui_scroll_direction
name|scroll_direction
parameter_list|,
name|int
name|num_to_scroll
parameter_list|)
block|{
if|if
condition|(
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|content
operator|!=
name|NULL
condition|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|tui_win_content
name|content
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|union
name|tui_line_or_address
name|val
decl_stmt|;
name|int
name|max_lines
decl_stmt|,
name|dir
decl_stmt|;
name|struct
name|symtab_and_line
name|cursal
init|=
name|get_current_source_symtab_and_line
argument_list|()
decl_stmt|;
name|content
operator|=
operator|(
name|tui_win_content
operator|)
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|content
expr_stmt|;
if|if
condition|(
name|cursal
operator|.
name|symtab
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
condition|)
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|cursal
operator|.
name|symtab
expr_stmt|;
comment|/* account for hilite */
name|max_lines
operator|=
name|TUI_DISASM_WIN
operator|->
name|generic
operator|.
name|height
operator|-
literal|2
expr_stmt|;
name|pc
operator|=
name|content
index|[
literal|0
index|]
operator|->
name|which_element
operator|.
name|source
operator|.
name|line_or_addr
operator|.
name|addr
expr_stmt|;
name|dir
operator|=
operator|(
name|scroll_direction
operator|==
name|FORWARD_SCROLL
operator|)
condition|?
name|max_lines
else|:
operator|-
name|max_lines
expr_stmt|;
name|val
operator|.
name|addr
operator|=
name|tui_find_disassembly_address
argument_list|(
name|pc
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|tui_update_source_window_as_is
argument_list|(
name|TUI_DISASM_WIN
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

