begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** tuiRegs.c **         This module contains functions to support display of registers **         in the data window. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tuiLayout.h"
end_include

begin_include
include|#
directive|include
file|"tuiWin.h"
end_include

begin_comment
comment|/***************************************** ** LOCAL DEFINITIONS                    ** ******************************************/
end_comment

begin_define
define|#
directive|define
name|DOUBLE_FLOAT_LABEL_WIDTH
value|6
end_define

begin_define
define|#
directive|define
name|DOUBLE_FLOAT_LABEL_FMT
value|"%6.6s: "
end_define

begin_define
define|#
directive|define
name|DOUBLE_FLOAT_VALUE_WIDTH
value|30
end_define

begin_comment
comment|/*min of 16 but may be in sci notation */
end_comment

begin_define
define|#
directive|define
name|SINGLE_FLOAT_LABEL_WIDTH
value|6
end_define

begin_define
define|#
directive|define
name|SINGLE_FLOAT_LABEL_FMT
value|"%6.6s: "
end_define

begin_define
define|#
directive|define
name|SINGLE_FLOAT_VALUE_WIDTH
value|25
end_define

begin_comment
comment|/* min of 8 but may be in sci notation */
end_comment

begin_define
define|#
directive|define
name|SINGLE_LABEL_WIDTH
value|10
end_define

begin_define
define|#
directive|define
name|SINGLE_LABEL_FMT
value|"%10.10s: "
end_define

begin_define
define|#
directive|define
name|SINGLE_VALUE_WIDTH
value|14
end_define

begin_comment
comment|/* minimum of 8 but may be in sci notation */
end_comment

begin_comment
comment|/* In the code HP gave Cygnus, this was actually a function call to a    PA-specific function, which was supposed to determine whether the    target was a 64-bit or 32-bit processor.  However, the 64-bit    support wasn't complete, so we didn't merge that in, so we leave    this here as a stub.  */
end_comment

begin_define
define|#
directive|define
name|IS_64BIT
value|0
end_define

begin_comment
comment|/***************************************** ** STATIC DATA                          ** ******************************************/
end_comment

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS FORWARD DECLS    ** ******************************************/
end_comment

begin_decl_stmt
specifier|static
name|TuiStatus
name|_tuiSetRegsContent
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|frame_info
operator|*
operator|,
name|TuiRegisterDisplayType
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_tuiRegisterName
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiStatus
name|_tuiGetRegisterRawValue
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
expr|struct
name|frame_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiSetRegisterElement
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|frame_info
operator|*
operator|,
name|TuiDataElementPtr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiDisplayRegister
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|TuiGenWinInfoPtr
operator|,
expr|enum
name|precision_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiRegisterFormat
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|TuiDataElementPtr
operator|,
expr|enum
name|precision_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiStatus
name|_tuiSetGeneralRegsContent
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiStatus
name|_tuiSetSpecialRegsContent
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiStatus
name|_tuiSetGeneralAndSpecialRegsContent
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiStatus
name|_tuiSetFloatRegsContent
name|PARAMS
argument_list|(
operator|(
name|TuiRegisterDisplayType
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_tuiRegValueHasChanged
name|PARAMS
argument_list|(
operator|(
name|TuiDataElementPtr
operator|,
expr|struct
name|frame_info
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiShowFloat_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiShowGeneral_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiShowSpecial_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tui_vShowRegisters_commandSupport
name|PARAMS
argument_list|(
operator|(
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiToggleFloatRegs_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiScrollRegsForward_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tuiScrollRegsBackward_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tui_vShowRegisters_commandSupport
name|PARAMS
argument_list|(
operator|(
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************************** ** PUBLIC FUNCTIONS                     ** ******************************************/
end_comment

begin_comment
comment|/* ** tuiLastRegsLineNo() **        Answer the number of the last line in the regs display. **        If there are no registers (-1) is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiLastRegsLineNo
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiLastRegsLineNo
parameter_list|()
endif|#
directive|endif
block|{
specifier|register
name|int
name|numLines
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|>
literal|0
condition|)
block|{
name|numLines
operator|=
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|/
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|)
expr_stmt|;
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|%
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
condition|)
name|numLines
operator|++
expr_stmt|;
block|}
return|return
name|numLines
return|;
block|}
end_function

begin_comment
comment|/* tuiLastRegsLineNo */
end_comment

begin_comment
comment|/* ** tuiLineFromRegElementNo() **        Answer the line number that the register element at elementNo is **        on.  If elementNo is greater than the number of register elements **        there are, -1 is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiLineFromRegElementNo
parameter_list|(
name|int
name|elementNo
parameter_list|)
else|#
directive|else
function|tuiLineFromRegElementNo
parameter_list|(
name|elementNo
parameter_list|)
name|int
name|elementNo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|elementNo
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
condition|)
block|{
name|int
name|i
decl_stmt|,
name|line
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|line
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|elementNo
operator|<
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|*
name|i
operator|)
condition|)
name|line
operator|=
name|i
operator|-
literal|1
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiLineFromRegElementNo */
end_comment

begin_comment
comment|/* ** tuiFirstRegElementNoInLine() **        Answer the index of the first element in lineNo.  If lineNo is **        past the register area (-1) is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiFirstRegElementNoInLine
parameter_list|(
name|int
name|lineNo
parameter_list|)
else|#
directive|else
function|tuiFirstRegElementNoInLine
parameter_list|(
name|lineNo
parameter_list|)
name|int
name|lineNo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|lineNo
operator|*
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|)
operator|<=
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
condition|)
return|return
operator|(
operator|(
name|lineNo
operator|+
literal|1
operator|)
operator|*
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|)
operator|-
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiFirstRegElementNoInLine */
end_comment

begin_comment
comment|/* ** tuiLastRegElementNoInLine() **        Answer the index of the last element in lineNo.  If lineNo is past **        the register area (-1) is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiLastRegElementNoInLine
parameter_list|(
name|int
name|lineNo
parameter_list|)
else|#
directive|else
function|tuiLastRegElementNoInLine
parameter_list|(
name|lineNo
parameter_list|)
name|int
name|lineNo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|lineNo
operator|*
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|)
operator|<=
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
condition|)
return|return
operator|(
operator|(
name|lineNo
operator|+
literal|1
operator|)
operator|*
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|)
operator|-
literal|1
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiLastRegElementNoInLine */
end_comment

begin_comment
comment|/* ** tuiCalculateRegsColumnCount **        Calculate the number of columns that should be used to display **        the registers. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiCalculateRegsColumnCount
parameter_list|(
name|TuiRegisterDisplayType
name|dpyType
parameter_list|)
else|#
directive|else
function|tuiCalculateRegsColumnCount
parameter_list|(
name|dpyType
parameter_list|)
name|TuiRegisterDisplayType
name|dpyType
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|colCount
decl_stmt|,
name|colWidth
decl_stmt|;
if|if
condition|(
name|IS_64BIT
operator|||
name|dpyType
operator|==
name|TUI_DFLOAT_REGS
condition|)
name|colWidth
operator|=
name|DOUBLE_FLOAT_VALUE_WIDTH
operator|+
name|DOUBLE_FLOAT_LABEL_WIDTH
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dpyType
operator|==
name|TUI_SFLOAT_REGS
condition|)
name|colWidth
operator|=
name|SINGLE_FLOAT_VALUE_WIDTH
operator|+
name|SINGLE_FLOAT_LABEL_WIDTH
expr_stmt|;
else|else
name|colWidth
operator|=
name|SINGLE_VALUE_WIDTH
operator|+
name|SINGLE_LABEL_WIDTH
expr_stmt|;
block|}
name|colCount
operator|=
operator|(
name|dataWin
operator|->
name|generic
operator|.
name|width
operator|-
literal|2
operator|)
operator|/
name|colWidth
expr_stmt|;
return|return
name|colCount
return|;
block|}
end_function

begin_comment
comment|/* tuiCalulateRegsColumnCount */
end_comment

begin_comment
comment|/* ** tuiShowRegisters(). **        Show the registers int the data window as indicated by dpyType. **        If there is any other registers being displayed, then they are **        cleared.  What registers are displayed is dependent upon dpyType. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowRegisters
parameter_list|(
name|TuiRegisterDisplayType
name|dpyType
parameter_list|)
else|#
directive|else
function|tuiShowRegisters
parameter_list|(
name|dpyType
parameter_list|)
name|TuiRegisterDisplayType
name|dpyType
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|refreshValuesOnly
init|=
name|FALSE
decl_stmt|;
comment|/* Say that registers should be displayed, even if there is a problem */
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|displayRegs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|target_has_registers
condition|)
block|{
name|refreshValuesOnly
operator|=
operator|(
name|dpyType
operator|==
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|)
expr_stmt|;
switch|switch
condition|(
name|dpyType
condition|)
block|{
case|case
name|TUI_GENERAL_REGS
case|:
name|ret
operator|=
name|_tuiSetGeneralRegsContent
argument_list|(
name|refreshValuesOnly
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUI_SFLOAT_REGS
case|:
case|case
name|TUI_DFLOAT_REGS
case|:
name|ret
operator|=
name|_tuiSetFloatRegsContent
argument_list|(
name|dpyType
argument_list|,
name|refreshValuesOnly
argument_list|)
expr_stmt|;
break|break;
comment|/* could ifdef out */
case|case
name|TUI_SPECIAL_REGS
case|:
name|ret
operator|=
name|_tuiSetSpecialRegsContent
argument_list|(
name|refreshValuesOnly
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUI_GENERAL_AND_SPECIAL_REGS
case|:
name|ret
operator|=
name|_tuiSetGeneralAndSpecialRegsContent
argument_list|(
name|refreshValuesOnly
argument_list|)
expr_stmt|;
break|break;
comment|/* end of potential if def */
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|TUI_FAILURE
condition|)
block|{
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|=
name|TUI_UNDEFINED_REGS
expr_stmt|;
name|tuiEraseDataContent
argument_list|(
name|NO_REGS_STRING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Clear all notation of changed values */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|TuiGenWinInfoPtr
name|dataItemWin
decl_stmt|;
name|dataItemWin
operator|=
operator|&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
operator|(
operator|&
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|dataItemWin
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|data
operator|)
operator|->
name|highlight
operator|=
name|FALSE
expr_stmt|;
block|}
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|=
name|dpyType
expr_stmt|;
name|tuiDisplayAllData
argument_list|()
expr_stmt|;
block|}
operator|(
name|tuiLayoutDef
argument_list|()
operator|)
operator|->
name|regsDisplayType
operator|=
name|dpyType
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowRegisters */
end_comment

begin_comment
comment|/* ** tuiDisplayRegistersFrom(). **        Function to display the registers in the content from **        'startElementNo' until the end of the register content or the **        end of the display height.  No checking for displaying past **        the end of the registers is done here. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayRegistersFrom
parameter_list|(
name|int
name|startElementNo
parameter_list|)
else|#
directive|else
function|tuiDisplayRegistersFrom
parameter_list|(
name|startElementNo
parameter_list|)
name|int
name|startElementNo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
operator|&&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|startElementNo
decl_stmt|;
name|int
name|j
decl_stmt|,
name|valueCharsWide
decl_stmt|,
name|charsWide
decl_stmt|,
name|itemWinWidth
decl_stmt|,
name|curY
decl_stmt|,
name|labelWidth
decl_stmt|;
name|enum
name|precision_type
name|precision
decl_stmt|;
name|precision
operator|=
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_DFLOAT_REGS
operator|)
condition|?
name|double_precision
else|:
name|unspecified_precision
expr_stmt|;
if|if
condition|(
name|IS_64BIT
operator|||
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_DFLOAT_REGS
condition|)
block|{
name|valueCharsWide
operator|=
name|DOUBLE_FLOAT_VALUE_WIDTH
expr_stmt|;
name|labelWidth
operator|=
name|DOUBLE_FLOAT_LABEL_WIDTH
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_SFLOAT_REGS
condition|)
block|{
name|valueCharsWide
operator|=
name|SINGLE_FLOAT_VALUE_WIDTH
expr_stmt|;
name|labelWidth
operator|=
name|SINGLE_FLOAT_LABEL_WIDTH
expr_stmt|;
block|}
else|else
block|{
name|valueCharsWide
operator|=
name|SINGLE_VALUE_WIDTH
expr_stmt|;
name|labelWidth
operator|=
name|SINGLE_LABEL_WIDTH
expr_stmt|;
block|}
block|}
name|itemWinWidth
operator|=
name|valueCharsWide
operator|+
name|labelWidth
expr_stmt|;
comment|/*         ** Now create each data "sub" window, and write the display into it.         */
name|curY
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|&&
name|curY
operator|<=
name|dataWin
operator|->
name|generic
operator|.
name|viewportHeight
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|&&
name|i
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|TuiGenWinInfoPtr
name|dataItemWin
decl_stmt|;
name|TuiDataElementPtr
name|dataElementPtr
decl_stmt|;
comment|/* create the window if necessary*/
name|dataItemWin
operator|=
operator|&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
name|dataElementPtr
operator|=
operator|&
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|dataItemWin
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|dataItemWin
operator|->
name|handle
operator|==
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|dataItemWin
operator|->
name|height
operator|=
literal|1
expr_stmt|;
name|dataItemWin
operator|->
name|width
operator|=
operator|(
name|precision
operator|==
name|double_precision
operator|)
condition|?
name|itemWinWidth
operator|+
literal|2
else|:
name|itemWinWidth
operator|+
literal|1
expr_stmt|;
name|dataItemWin
operator|->
name|origin
operator|.
name|x
operator|=
operator|(
name|itemWinWidth
operator|*
name|j
operator|)
operator|+
literal|1
expr_stmt|;
name|dataItemWin
operator|->
name|origin
operator|.
name|y
operator|=
name|curY
expr_stmt|;
name|makeWindow
argument_list|(
name|dataItemWin
argument_list|,
name|DONT_BOX_WINDOW
argument_list|)
expr_stmt|;
block|}
comment|/*                 ** Get the printable representation of the register                 ** and display it                 */
name|_tuiDisplayRegister
argument_list|(
name|dataElementPtr
operator|->
name|itemNo
argument_list|,
name|dataItemWin
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* next register */
block|}
name|curY
operator|++
expr_stmt|;
comment|/* next row; */
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDisplayRegistersFrom */
end_comment

begin_comment
comment|/* ** tuiDisplayRegElementAtLine(). **        Function to display the registers in the content from **        'startElementNo' on 'startLineNo' until the end of the **        register content or the end of the display height. **        This function checks that we won't display off the end **        of the register display. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayRegElementAtLine
parameter_list|(
name|int
name|startElementNo
parameter_list|,
name|int
name|startLineNo
parameter_list|)
else|#
directive|else
function|tuiDisplayRegElementAtLine
parameter_list|(
name|startElementNo
parameter_list|,
name|startLineNo
parameter_list|)
name|int
name|startElementNo
decl_stmt|;
name|int
name|startLineNo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
operator|&&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|elementNo
init|=
name|startElementNo
decl_stmt|;
if|if
condition|(
name|startElementNo
operator|!=
literal|0
operator|&&
name|startLineNo
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|lastLineNo
decl_stmt|,
name|firstLineOnLastPage
decl_stmt|;
name|lastLineNo
operator|=
name|tuiLastRegsLineNo
argument_list|()
expr_stmt|;
name|firstLineOnLastPage
operator|=
name|lastLineNo
operator|-
operator|(
name|dataWin
operator|->
name|generic
operator|.
name|height
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|firstLineOnLastPage
operator|<
literal|0
condition|)
name|firstLineOnLastPage
operator|=
literal|0
expr_stmt|;
comment|/*             ** If there is no other data displayed except registers,             ** and the elementNo causes us to scroll past the end of the             ** registers, adjust what element to really start the display at.             */
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|<=
literal|0
operator|&&
name|startLineNo
operator|>
name|firstLineOnLastPage
condition|)
name|elementNo
operator|=
name|tuiFirstRegElementNoInLine
argument_list|(
name|firstLineOnLastPage
argument_list|)
expr_stmt|;
block|}
name|tuiDisplayRegistersFrom
argument_list|(
name|elementNo
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDisplayRegElementAtLine */
end_comment

begin_comment
comment|/* ** tuiDisplayRegistersFromLine(). **        Function to display the registers starting at line lineNo in **        the data window.  Answers the line number that the display **        actually started from.  If nothing is displayed (-1) is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayRegistersFromLine
parameter_list|(
name|int
name|lineNo
parameter_list|,
name|int
name|forceDisplay
parameter_list|)
else|#
directive|else
function|tuiDisplayRegistersFromLine
parameter_list|(
name|lineNo
parameter_list|,
name|forceDisplay
parameter_list|)
name|int
name|lineNo
decl_stmt|;
name|int
name|forceDisplay
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|elementNo
decl_stmt|;
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|>
literal|0
condition|)
block|{
name|int
name|line
decl_stmt|,
name|elementNo
decl_stmt|;
if|if
condition|(
name|lineNo
operator|<
literal|0
condition|)
name|line
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|forceDisplay
condition|)
block|{
comment|/*             ** If we must display regs (forceDisplay is true), then make             ** sure that we don't display off the end of the registers.             */
if|if
condition|(
name|lineNo
operator|>=
name|tuiLastRegsLineNo
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|tuiLineFromRegElementNo
argument_list|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|-
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|line
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|line
operator|=
name|lineNo
expr_stmt|;
block|}
else|else
name|line
operator|=
name|lineNo
expr_stmt|;
name|elementNo
operator|=
name|tuiFirstRegElementNoInLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|elementNo
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
condition|)
name|tuiDisplayRegElementAtLine
argument_list|(
name|elementNo
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|line
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|line
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* nothing was displayed */
block|}
end_function

begin_comment
comment|/* tuiDisplayRegistersFromLine */
end_comment

begin_comment
comment|/* ** tuiCheckRegisterValues() **        This function check all displayed registers for changes in **        values, given a particular frame.  If the values have changed, **        they are updated with the new value and highlighted. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiCheckRegisterValues
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
else|#
directive|else
function|tuiCheckRegisterValues
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|dataWin
argument_list|)
operator|&&
name|dataWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
block|{
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|<=
literal|0
operator|&&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|displayRegs
condition|)
name|tuiShowRegisters
argument_list|(
operator|(
name|tuiLayoutDef
argument_list|()
operator|)
operator|->
name|regsDisplayType
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|rawBuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|TuiDataElementPtr
name|dataElementPtr
decl_stmt|;
name|TuiGenWinInfoPtr
name|dataItemWinPtr
decl_stmt|;
name|int
name|wasHilighted
decl_stmt|;
name|dataItemWinPtr
operator|=
operator|&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
name|dataElementPtr
operator|=
operator|&
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|dataItemWinPtr
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|data
expr_stmt|;
name|wasHilighted
operator|=
name|dataElementPtr
operator|->
name|highlight
expr_stmt|;
name|dataElementPtr
operator|->
name|highlight
operator|=
name|_tuiRegValueHasChanged
argument_list|(
name|dataElementPtr
argument_list|,
name|frame
argument_list|,
operator|&
name|rawBuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataElementPtr
operator|->
name|highlight
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_REGISTER_RAW_SIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dataElementPtr
operator|->
name|value
operator|)
index|[
name|j
index|]
operator|=
name|rawBuf
index|[
name|j
index|]
expr_stmt|;
name|_tuiDisplayRegister
argument_list|(
name|dataElementPtr
operator|->
name|itemNo
argument_list|,
name|dataItemWinPtr
argument_list|,
operator|(
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_DFLOAT_REGS
operator|)
condition|?
name|double_precision
else|:
name|unspecified_precision
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasHilighted
condition|)
block|{
name|dataElementPtr
operator|->
name|highlight
operator|=
name|FALSE
expr_stmt|;
name|_tuiDisplayRegister
argument_list|(
name|dataElementPtr
operator|->
name|itemNo
argument_list|,
name|dataItemWinPtr
argument_list|,
operator|(
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_DFLOAT_REGS
operator|)
condition|?
name|double_precision
else|:
name|unspecified_precision
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiCheckRegisterValues */
end_comment

begin_comment
comment|/* ** tuiToggleFloatRegs(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiToggleFloatRegs
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiToggleFloatRegs
parameter_list|()
endif|#
directive|endif
block|{
name|TuiLayoutDefPtr
name|layoutDef
init|=
name|tuiLayoutDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutDef
operator|->
name|floatRegsDisplayType
operator|==
name|TUI_SFLOAT_REGS
condition|)
name|layoutDef
operator|->
name|floatRegsDisplayType
operator|=
name|TUI_DFLOAT_REGS
expr_stmt|;
else|else
name|layoutDef
operator|->
name|floatRegsDisplayType
operator|=
name|TUI_SFLOAT_REGS
expr_stmt|;
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|dataWin
argument_list|)
operator|&&
name|dataWin
operator|->
name|generic
operator|.
name|isVisible
operator|&&
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_SFLOAT_REGS
operator|||
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_DFLOAT_REGS
operator|)
condition|)
name|tuiShowRegisters
argument_list|(
name|layoutDef
operator|->
name|floatRegsDisplayType
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiToggleFloatRegs */
end_comment

begin_function
name|void
name|_initialize_tuiRegs
parameter_list|()
block|{
if|if
condition|(
name|tui_version
operator|&&
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"fr"
argument_list|,
name|class_tui
argument_list|,
name|_tuiShowFloat_command
argument_list|,
literal|"Display only floating point registers\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"gr"
argument_list|,
name|class_tui
argument_list|,
name|_tuiShowGeneral_command
argument_list|,
literal|"Display only general registers\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sr"
argument_list|,
name|class_tui
argument_list|,
name|_tuiShowSpecial_command
argument_list|,
literal|"Display only special registers\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"+r"
argument_list|,
name|class_tui
argument_list|,
name|_tuiScrollRegsForward_command
argument_list|,
literal|"Scroll the registers window forward\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"-r"
argument_list|,
name|class_tui
argument_list|,
name|_tuiScrollRegsBackward_command
argument_list|,
literal|"Scroll the register window backward\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tf"
argument_list|,
name|class_tui
argument_list|,
name|_tuiToggleFloatRegs_command
argument_list|,
literal|"Toggle between single and double precision floating point registers.\n"
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
name|TUI_FLOAT_REGS_NAME_LOWER
argument_list|,
name|class_tui
argument_list|,
name|_tuiToggleFloatRegs_command
argument_list|,
literal|"Toggle between single and double precision floating point \ registers.\n"
argument_list|,
operator|&
name|togglelist
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* _initialize_tuiRegs */
end_comment

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS                 ** ******************************************/
end_comment

begin_comment
comment|/* ** _tuiRegisterName(). **        Return the register name. */
end_comment

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiRegisterName
parameter_list|(
name|int
name|regNum
parameter_list|)
else|#
directive|else
function|_tuiRegisterName
parameter_list|(
name|regNum
parameter_list|)
name|int
name|regNum
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|reg_names
index|[
name|regNum
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|*
operator|(
name|reg_names
index|[
name|regNum
index|]
operator|)
operator|!=
operator|(
name|char
operator|)
literal|0
condition|)
return|return
name|reg_names
index|[
name|regNum
index|]
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiGetRegisterName */
end_comment

begin_comment
comment|/* ** _tuiRegisterFormat **        Function to format the register name and value into a buffer, **        suitable for printing or display */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiRegisterFormat
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufLen
parameter_list|,
name|int
name|regNum
parameter_list|,
name|TuiDataElementPtr
name|dataElement
parameter_list|,
name|enum
name|precision_type
name|precision
parameter_list|)
else|#
directive|else
function|_tuiRegisterFormat
parameter_list|(
name|buf
parameter_list|,
name|bufLen
parameter_list|,
name|regNum
parameter_list|,
name|dataElement
parameter_list|,
name|precision
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufLen
decl_stmt|;
name|int
name|regNum
decl_stmt|;
name|TuiDataElementPtr
name|dataElement
decl_stmt|;
name|enum
name|precision_type
name|precision
decl_stmt|;
endif|#
directive|endif
block|{
name|char
name|tmpBuf
index|[
literal|15
index|]
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|gdb_file_init_astring
argument_list|(
name|bufLen
argument_list|)
expr_stmt|;
name|pa_do_strcat_registers_info
argument_list|(
name|regNum
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|gdb_file_get_strbuf
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_file_deallocate
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tuiRegisterFormat */
end_comment

begin_define
define|#
directive|define
name|NUM_GENERAL_REGS
value|32
end_define

begin_comment
comment|/* ** _tuiSetGeneralRegsContent(). **      Set the content of the data window to consist of the general registers. */
end_comment

begin_function
specifier|static
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiSetGeneralRegsContent
parameter_list|(
name|int
name|refreshValuesOnly
parameter_list|)
else|#
directive|else
function|_tuiSetGeneralRegsContent
parameter_list|(
name|refreshValuesOnly
parameter_list|)
name|int
name|refreshValuesOnly
decl_stmt|;
endif|#
directive|endif
block|{
return|return
operator|(
name|_tuiSetRegsContent
argument_list|(
literal|0
argument_list|,
name|NUM_GENERAL_REGS
operator|-
literal|1
argument_list|,
name|selected_frame
argument_list|,
name|TUI_GENERAL_REGS
argument_list|,
name|refreshValuesOnly
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* _tuiSetGeneralRegsContent */
end_comment

begin_define
define|#
directive|define
name|START_SPECIAL_REGS
value|PCOQ_HEAD_REGNUM
end_define

begin_comment
comment|/* ** _tuiSetSpecialRegsContent(). **      Set the content of the data window to consist of the special registers. */
end_comment

begin_function
specifier|static
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiSetSpecialRegsContent
parameter_list|(
name|int
name|refreshValuesOnly
parameter_list|)
else|#
directive|else
function|_tuiSetSpecialRegsContent
parameter_list|(
name|refreshValuesOnly
parameter_list|)
name|int
name|refreshValuesOnly
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|endRegNum
decl_stmt|;
name|endRegNum
operator|=
name|FP0_REGNUM
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|endRegNum = (-1);   for (i = START_SPECIAL_REGS; (i< ARCH_NUM_REGS&& endRegNum< 0); i++)     if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)       endRegNum = i - 1;
endif|#
directive|endif
name|ret
operator|=
name|_tuiSetRegsContent
argument_list|(
name|START_SPECIAL_REGS
argument_list|,
name|endRegNum
argument_list|,
name|selected_frame
argument_list|,
name|TUI_SPECIAL_REGS
argument_list|,
name|refreshValuesOnly
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* _tuiSetSpecialRegsContent */
end_comment

begin_comment
comment|/* ** _tuiSetGeneralAndSpecialRegsContent(). **      Set the content of the data window to consist of the special registers. */
end_comment

begin_function
specifier|static
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiSetGeneralAndSpecialRegsContent
parameter_list|(
name|int
name|refreshValuesOnly
parameter_list|)
else|#
directive|else
function|_tuiSetGeneralAndSpecialRegsContent
parameter_list|(
name|refreshValuesOnly
parameter_list|)
name|int
name|refreshValuesOnly
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|endRegNum
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|endRegNum
operator|=
name|FP0_REGNUM
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|endRegNum = (-1);   for (i = 0; (i< ARCH_NUM_REGS&& endRegNum< 0); i++)     if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)       endRegNum = i - 1;
endif|#
directive|endif
name|ret
operator|=
name|_tuiSetRegsContent
argument_list|(
literal|0
argument_list|,
name|endRegNum
argument_list|,
name|selected_frame
argument_list|,
name|TUI_SPECIAL_REGS
argument_list|,
name|refreshValuesOnly
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* _tuiSetGeneralAndSpecialRegsContent */
end_comment

begin_comment
comment|/* ** _tuiSetFloatRegsContent(). **        Set the content of the data window to consist of the float registers. */
end_comment

begin_function
specifier|static
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiSetFloatRegsContent
parameter_list|(
name|TuiRegisterDisplayType
name|dpyType
parameter_list|,
name|int
name|refreshValuesOnly
parameter_list|)
else|#
directive|else
function|_tuiSetFloatRegsContent
parameter_list|(
name|dpyType
parameter_list|,
name|refreshValuesOnly
parameter_list|)
name|TuiRegisterDisplayType
name|dpyType
decl_stmt|;
name|int
name|refreshValuesOnly
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|startRegNum
decl_stmt|;
name|startRegNum
operator|=
name|FP0_REGNUM
expr_stmt|;
if|#
directive|if
literal|0
block|startRegNum = (-1);   for (i = ARCH_NUM_REGS - 1; (i>= 0&& startRegNum< 0); i--)     if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) != TYPE_CODE_FLT)       startRegNum = i + 1;
endif|#
directive|endif
name|ret
operator|=
name|_tuiSetRegsContent
argument_list|(
name|startRegNum
argument_list|,
name|ARCH_NUM_REGS
operator|-
literal|1
argument_list|,
name|selected_frame
argument_list|,
name|dpyType
argument_list|,
name|refreshValuesOnly
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* _tuiSetFloatRegsContent */
end_comment

begin_comment
comment|/* ** _tuiRegValueHasChanged(). **        Answer TRUE if the register's value has changed, FALSE otherwise. **        If TRUE, newValue is filled in with the new value. */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiRegValueHasChanged
parameter_list|(
name|TuiDataElementPtr
name|dataElement
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|char
modifier|*
name|newValue
parameter_list|)
else|#
directive|else
function|_tuiRegValueHasChanged
parameter_list|(
name|dataElement
parameter_list|,
name|frame
parameter_list|,
name|newValue
parameter_list|)
name|TuiDataElementPtr
name|dataElement
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|char
modifier|*
name|newValue
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|hasChanged
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|dataElement
operator|->
name|itemNo
operator|!=
name|UNDEFINED_ITEM
operator|&&
name|_tuiRegisterName
argument_list|(
name|dataElement
operator|->
name|itemNo
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
name|rawBuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|_tuiGetRegisterRawValue
argument_list|(
name|dataElement
operator|->
name|itemNo
argument_list|,
name|rawBuf
argument_list|,
name|frame
argument_list|)
operator|==
name|TUI_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MAX_REGISTER_RAW_SIZE
operator|&&
operator|!
name|hasChanged
operator|)
condition|;
name|i
operator|++
control|)
name|hasChanged
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|dataElement
operator|->
name|value
operator|)
index|[
name|i
index|]
operator|!=
name|rawBuf
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hasChanged
operator|&&
name|newValue
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MAX_REGISTER_RAW_SIZE
operator|)
condition|;
name|i
operator|++
control|)
name|newValue
index|[
name|i
index|]
operator|=
name|rawBuf
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
name|hasChanged
return|;
block|}
end_function

begin_comment
comment|/* _tuiRegValueHasChanged */
end_comment

begin_comment
comment|/* ** _tuiGetRegisterRawValue(). **        Get the register raw value.  The raw value is returned in regValue. */
end_comment

begin_function
specifier|static
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiGetRegisterRawValue
parameter_list|(
name|int
name|regNum
parameter_list|,
name|char
modifier|*
name|regValue
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
else|#
directive|else
function|_tuiGetRegisterRawValue
parameter_list|(
name|regNum
parameter_list|,
name|regValue
parameter_list|,
name|frame
parameter_list|)
name|int
name|regNum
decl_stmt|;
name|char
modifier|*
name|regValue
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
if|if
condition|(
name|target_has_registers
condition|)
block|{
name|read_relative_register_raw_bytes_for_frame
argument_list|(
name|regNum
argument_list|,
name|regValue
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* _tuiGetRegisterRawValue */
end_comment

begin_comment
comment|/* ** _tuiSetRegisterElement(). **       Function to initialize a data element with the input and **       the register value. */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiSetRegisterElement
parameter_list|(
name|int
name|regNum
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|TuiDataElementPtr
name|dataElement
parameter_list|,
name|int
name|refreshValueOnly
parameter_list|)
else|#
directive|else
function|_tuiSetRegisterElement
parameter_list|(
name|regNum
parameter_list|,
name|frame
parameter_list|,
name|dataElement
parameter_list|,
name|refreshValueOnly
parameter_list|)
name|int
name|regNum
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|TuiDataElementPtr
name|dataElement
decl_stmt|;
name|int
name|refreshValueOnly
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|dataElement
operator|!=
operator|(
name|TuiDataElementPtr
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|refreshValueOnly
condition|)
block|{
name|dataElement
operator|->
name|itemNo
operator|=
name|regNum
expr_stmt|;
name|dataElement
operator|->
name|name
operator|=
name|_tuiRegisterName
argument_list|(
name|regNum
argument_list|)
expr_stmt|;
name|dataElement
operator|->
name|highlight
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|dataElement
operator|->
name|value
operator|==
operator|(
name|Opaque
operator|)
name|NULL
condition|)
name|dataElement
operator|->
name|value
operator|=
operator|(
name|Opaque
operator|)
name|xmalloc
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataElement
operator|->
name|value
operator|!=
operator|(
name|Opaque
operator|)
name|NULL
condition|)
name|_tuiGetRegisterRawValue
argument_list|(
name|regNum
argument_list|,
name|dataElement
operator|->
name|value
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* _tuiSetRegisterElement */
end_comment

begin_comment
comment|/* ** _tuiSetRegsContent(). **        Set the content of the data window to consist of the registers **        numbered from startRegNum to endRegNum.  Note that if **        refreshValuesOnly is TRUE, startRegNum and endRegNum are ignored. */
end_comment

begin_function
specifier|static
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiSetRegsContent
parameter_list|(
name|int
name|startRegNum
parameter_list|,
name|int
name|endRegNum
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|TuiRegisterDisplayType
name|dpyType
parameter_list|,
name|int
name|refreshValuesOnly
parameter_list|)
else|#
directive|else
function|_tuiSetRegsContent
parameter_list|(
name|startRegNum
parameter_list|,
name|endRegNum
parameter_list|,
name|frame
parameter_list|,
name|dpyType
parameter_list|,
name|refreshValuesOnly
parameter_list|)
name|int
name|startRegNum
decl_stmt|;
name|int
name|endRegNum
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|TuiRegisterDisplayType
name|dpyType
decl_stmt|;
name|int
name|refreshValuesOnly
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|numRegs
init|=
name|endRegNum
operator|-
name|startRegNum
operator|+
literal|1
decl_stmt|;
name|int
name|allocatedHere
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|>
literal|0
operator|&&
operator|!
name|refreshValuesOnly
condition|)
block|{
name|freeDataContent
argument_list|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
argument_list|,
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
argument_list|)
expr_stmt|;
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|<=
literal|0
condition|)
block|{
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|=
name|allocContent
argument_list|(
name|numRegs
argument_list|,
name|DATA_WIN
argument_list|)
expr_stmt|;
name|allocatedHere
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|refreshValuesOnly
operator|||
name|allocatedHere
condition|)
block|{
name|dataWin
operator|->
name|generic
operator|.
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|NULL
expr_stmt|;
name|dataWin
operator|->
name|generic
operator|.
name|contentSize
operator|=
literal|0
expr_stmt|;
name|addContentElements
argument_list|(
operator|&
name|dataWin
operator|->
name|generic
argument_list|,
name|numRegs
argument_list|)
expr_stmt|;
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|dataWin
operator|->
name|generic
operator|.
name|content
expr_stmt|;
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|=
name|numRegs
expr_stmt|;
block|}
comment|/*         ** Now set the register names and values         */
for|for
control|(
name|i
operator|=
name|startRegNum
init|;
operator|(
name|i
operator|<=
name|endRegNum
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|TuiGenWinInfoPtr
name|dataItemWin
decl_stmt|;
name|dataItemWin
operator|=
operator|&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
index|[
name|i
operator|-
name|startRegNum
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
name|_tuiSetRegisterElement
argument_list|(
name|i
argument_list|,
name|frame
argument_list|,
operator|&
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|dataItemWin
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|data
argument_list|,
operator|!
name|allocatedHere
operator|&&
name|refreshValuesOnly
argument_list|)
expr_stmt|;
block|}
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|=
name|tuiCalculateRegsColumnCount
argument_list|(
name|dpyType
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LATER
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|>
literal|0
condition|)
block|{
comment|/* delete all the windows? */
comment|/* realloc content equal to dataContentCount + regsContentCount */
comment|/* append dataWin->detail.dataDisplayInfo.dataContent to content */
block|}
endif|#
directive|endif
name|dataWin
operator|->
name|generic
operator|.
name|contentSize
operator|=
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|+
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* _tuiSetRegsContent */
end_comment

begin_comment
comment|/* ** _tuiDisplayRegister(). **        Function to display a register in a window.  If hilite is TRUE, **        than the value will be displayed in reverse video */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiDisplayRegister
parameter_list|(
name|int
name|regNum
parameter_list|,
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|,
comment|/* the data item window */
name|enum
name|precision_type
name|precision
parameter_list|)
else|#
directive|else
function|_tuiDisplayRegister
parameter_list|(
name|regNum
parameter_list|,
name|winInfo
parameter_list|,
name|precision
parameter_list|)
name|int
name|regNum
decl_stmt|;
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
comment|/* the data item window */
name|enum
name|precision_type
name|precision
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|winInfo
operator|->
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|valueCharsWide
decl_stmt|,
name|labelWidth
decl_stmt|;
name|TuiDataElementPtr
name|dataElementPtr
init|=
operator|&
operator|(
operator|(
name|TuiWinContent
operator|)
name|winInfo
operator|->
name|content
operator|)
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|IS_64BIT
operator|||
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_DFLOAT_REGS
condition|)
block|{
name|valueCharsWide
operator|=
name|DOUBLE_FLOAT_VALUE_WIDTH
expr_stmt|;
name|labelWidth
operator|=
name|DOUBLE_FLOAT_LABEL_WIDTH
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|==
name|TUI_SFLOAT_REGS
condition|)
block|{
name|valueCharsWide
operator|=
name|SINGLE_FLOAT_VALUE_WIDTH
expr_stmt|;
name|labelWidth
operator|=
name|SINGLE_FLOAT_LABEL_WIDTH
expr_stmt|;
block|}
else|else
block|{
name|valueCharsWide
operator|=
name|SINGLE_VALUE_WIDTH
expr_stmt|;
name|labelWidth
operator|=
name|SINGLE_LABEL_WIDTH
expr_stmt|;
block|}
block|}
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|_tuiRegisterFormat
argument_list|(
name|buf
argument_list|,
name|valueCharsWide
operator|+
name|labelWidth
argument_list|,
name|regNum
argument_list|,
name|dataElementPtr
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataElementPtr
operator|->
name|highlight
condition|)
name|wstandout
argument_list|(
name|winInfo
operator|->
name|handle
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|winInfo
operator|->
name|handle
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|winInfo
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|winInfo
operator|->
name|handle
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataElementPtr
operator|->
name|highlight
condition|)
name|wstandend
argument_list|(
name|winInfo
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tuiRefreshWin
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* _tuiDisplayRegister */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tui_vShowRegisters_commandSupport
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|_tui_vShowRegisters_commandSupport
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiRegisterDisplayType
name|dpyType
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|TuiRegisterDisplayType
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|dataWin
argument_list|)
operator|&&
name|dataWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
block|{
comment|/* Data window already displayed, show the registers */
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|!=
name|dpyType
condition|)
name|tuiShowRegisters
argument_list|(
name|dpyType
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|tuiLayoutDef
argument_list|()
operator|)
operator|->
name|regsDisplayType
operator|=
name|dpyType
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tui_vShowRegisters_commandSupport */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiShowFloat_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_tuiShowFloat_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|m_winPtrIsNull
argument_list|(
name|dataWin
argument_list|)
operator|||
operator|!
name|dataWin
operator|->
name|generic
operator|.
name|isVisible
operator|||
operator|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|!=
name|TUI_SFLOAT_REGS
operator|&&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|!=
name|TUI_DFLOAT_REGS
operator|)
condition|)
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|_tui_vShowRegisters_commandSupport
argument_list|,
operator|(
name|tuiLayoutDef
argument_list|()
operator|)
operator|->
name|floatRegsDisplayType
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tuiShowFloat_command */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiShowGeneral_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_tuiShowGeneral_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|_tui_vShowRegisters_commandSupport
argument_list|,
name|TUI_GENERAL_REGS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tuiShowGeneral_command */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiShowSpecial_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_tuiShowSpecial_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|_tui_vShowRegisters_commandSupport
argument_list|,
name|TUI_SPECIAL_REGS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tuiShowSpecial_command */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiToggleFloatRegs_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_tuiToggleFloatRegs_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|dataWin
argument_list|)
operator|&&
name|dataWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tuiToggleFloatRegs
argument_list|)
expr_stmt|;
else|else
block|{
name|TuiLayoutDefPtr
name|layoutDef
init|=
name|tuiLayoutDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutDef
operator|->
name|floatRegsDisplayType
operator|==
name|TUI_SFLOAT_REGS
condition|)
name|layoutDef
operator|->
name|floatRegsDisplayType
operator|=
name|TUI_DFLOAT_REGS
expr_stmt|;
else|else
name|layoutDef
operator|->
name|floatRegsDisplayType
operator|=
name|TUI_SFLOAT_REGS
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* _tuiToggleFloatRegs_command */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiScrollRegsForward_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_tuiScrollRegsForward_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vScroll
argument_list|,
name|FORWARD_SCROLL
argument_list|,
name|dataWin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tuiScrollRegsForward_command */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiScrollRegsBackward_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_tuiScrollRegsBackward_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vScroll
argument_list|,
name|BACKWARD_SCROLL
argument_list|,
name|dataWin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _tuiScrollRegsBackward_command */
end_comment

end_unit

