begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* TUI display registers in window.     Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Hewlett-Packard Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-layout.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-windata.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-wingeneral.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-file.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS FORWARD DECLS    ** ******************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|tui_display_register
parameter_list|(
name|struct
name|tui_data_element
modifier|*
name|data
parameter_list|,
name|struct
name|tui_gen_win_info
modifier|*
name|win_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tui_status
name|tui_show_register_group
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|reggroup
modifier|*
name|group
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|refresh_values_only
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tui_status
name|tui_get_register
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|struct
name|tui_data_element
modifier|*
name|data
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|changedp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tui_register_format
parameter_list|(
name|struct
name|gdbarch
modifier|*
parameter_list|,
name|struct
name|frame_info
modifier|*
parameter_list|,
name|struct
name|tui_data_element
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tui_scroll_regs_forward_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tui_scroll_regs_backward_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/***************************************** ** PUBLIC FUNCTIONS                     ** ******************************************/
end_comment

begin_comment
comment|/* Answer the number of the last line in the regs display.  If there    are no registers (-1) is returned.  */
end_comment

begin_function
name|int
name|tui_last_regs_line_no
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|num_lines
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
operator|>
literal|0
condition|)
block|{
name|num_lines
operator|=
operator|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
operator|/
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
operator|)
expr_stmt|;
if|if
condition|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
operator|%
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
condition|)
name|num_lines
operator|++
expr_stmt|;
block|}
return|return
name|num_lines
return|;
block|}
end_function

begin_comment
comment|/* Answer the line number that the register element at element_no is    on.  If element_no is greater than the number of register elements    there are, -1 is returned.  */
end_comment

begin_function
name|int
name|tui_line_from_reg_element_no
parameter_list|(
name|int
name|element_no
parameter_list|)
block|{
if|if
condition|(
name|element_no
operator|<
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
condition|)
block|{
name|int
name|i
decl_stmt|,
name|line
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|line
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|element_no
operator|<
operator|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
operator|*
name|i
operator|)
condition|)
name|line
operator|=
name|i
operator|-
literal|1
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Answer the index of the first element in line_no.  If line_no is past    the register area (-1) is returned.  */
end_comment

begin_function
name|int
name|tui_first_reg_element_no_inline
parameter_list|(
name|int
name|line_no
parameter_list|)
block|{
if|if
condition|(
operator|(
name|line_no
operator|*
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
operator|)
operator|<=
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
condition|)
return|return
operator|(
operator|(
name|line_no
operator|+
literal|1
operator|)
operator|*
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
operator|)
operator|-
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Answer the index of the last element in line_no.  If line_no is    past the register area (-1) is returned.  */
end_comment

begin_function
name|int
name|tui_last_reg_element_no_in_line
parameter_list|(
name|int
name|line_no
parameter_list|)
block|{
if|if
condition|(
operator|(
name|line_no
operator|*
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
operator|)
operator|<=
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
condition|)
return|return
operator|(
operator|(
name|line_no
operator|+
literal|1
operator|)
operator|*
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_column_count
operator|)
operator|-
literal|1
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Show the registers of the given group in the data window    and refresh the window.  */
end_comment

begin_function
name|void
name|tui_show_registers
parameter_list|(
name|struct
name|reggroup
modifier|*
name|group
parameter_list|)
block|{
name|enum
name|tui_status
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|struct
name|tui_data_info
modifier|*
name|display_info
decl_stmt|;
comment|/* Make sure the curses mode is enabled.  */
name|tui_enable
argument_list|()
expr_stmt|;
comment|/* Make sure the register window is visible.  If not, select an      appropriate layout.  */
if|if
condition|(
name|TUI_DATA_WIN
operator|==
name|NULL
operator|||
operator|!
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|is_visible
condition|)
name|tui_set_layout_for_display_command
argument_list|(
name|DATA_NAME
argument_list|)
expr_stmt|;
name|display_info
operator|=
operator|&
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
expr_stmt|;
if|if
condition|(
name|group
operator|==
literal|0
condition|)
name|group
operator|=
name|general_reggroup
expr_stmt|;
comment|/* Say that registers should be displayed, even if there is a problem.  */
name|display_info
operator|->
name|display_regs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|target_has_registers
operator|&&
name|target_has_stack
operator|&&
name|target_has_memory
condition|)
block|{
name|ret
operator|=
name|tui_show_register_group
argument_list|(
name|current_gdbarch
argument_list|,
name|group
argument_list|,
name|get_current_frame
argument_list|()
argument_list|,
name|group
operator|==
name|display_info
operator|->
name|current_group
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|TUI_FAILURE
condition|)
block|{
name|display_info
operator|->
name|current_group
operator|=
literal|0
expr_stmt|;
name|tui_erase_data_content
argument_list|(
name|NO_REGS_STRING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Clear all notation of changed values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|display_info
operator|->
name|regs_content_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|data_item_win
decl_stmt|;
name|struct
name|tui_win_element
modifier|*
name|win
decl_stmt|;
name|data_item_win
operator|=
operator|&
name|display_info
operator|->
name|regs_content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|data_window
expr_stmt|;
name|win
operator|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|data_item_win
operator|->
name|content
index|[
literal|0
index|]
expr_stmt|;
name|win
operator|->
name|which_element
operator|.
name|data
operator|.
name|highlight
operator|=
name|FALSE
expr_stmt|;
block|}
name|display_info
operator|->
name|current_group
operator|=
name|group
expr_stmt|;
name|tui_display_all_data
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the data window to display the registers of the register group    using the given frame.  Values are refreshed only when refresh_values_only    is TRUE.  */
end_comment

begin_function
specifier|static
name|enum
name|tui_status
name|tui_show_register_group
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|reggroup
modifier|*
name|group
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|refresh_values_only
parameter_list|)
block|{
name|enum
name|tui_status
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|int
name|nr_regs
decl_stmt|;
name|int
name|allocated_here
init|=
name|FALSE
decl_stmt|;
name|int
name|regnum
decl_stmt|,
name|pos
decl_stmt|;
name|char
name|title
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|tui_data_info
modifier|*
name|display_info
init|=
operator|&
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
decl_stmt|;
comment|/* Make a new title showing which group we display.  */
name|snprintf
argument_list|(
name|title
argument_list|,
sizeof|sizeof
argument_list|(
name|title
argument_list|)
operator|-
literal|1
argument_list|,
literal|"Register group: %s"
argument_list|,
name|reggroup_name
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|title
argument_list|)
expr_stmt|;
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|title
operator|=
name|xstrdup
argument_list|(
name|title
argument_list|)
expr_stmt|;
comment|/* See how many registers must be displayed.  */
name|nr_regs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
comment|/* Must be in the group and have a name.  */
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|group
argument_list|)
operator|&&
name|gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
operator|!=
literal|0
condition|)
name|nr_regs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|display_info
operator|->
name|regs_content_count
operator|>
literal|0
operator|&&
operator|!
name|refresh_values_only
condition|)
block|{
name|tui_free_data_content
argument_list|(
name|display_info
operator|->
name|regs_content
argument_list|,
name|display_info
operator|->
name|regs_content_count
argument_list|)
expr_stmt|;
name|display_info
operator|->
name|regs_content_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|display_info
operator|->
name|regs_content_count
operator|<=
literal|0
condition|)
block|{
name|display_info
operator|->
name|regs_content
operator|=
name|tui_alloc_content
argument_list|(
name|nr_regs
argument_list|,
name|DATA_WIN
argument_list|)
expr_stmt|;
name|allocated_here
operator|=
name|TRUE
expr_stmt|;
name|refresh_values_only
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|display_info
operator|->
name|regs_content
operator|!=
operator|(
name|tui_win_content
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|refresh_values_only
operator|||
name|allocated_here
condition|)
block|{
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|content
operator|=
operator|(
name|void
operator|*
operator|)
name|NULL
expr_stmt|;
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|content_size
operator|=
literal|0
expr_stmt|;
name|tui_add_content_elements
argument_list|(
operator|&
name|TUI_DATA_WIN
operator|->
name|generic
argument_list|,
name|nr_regs
argument_list|)
expr_stmt|;
name|display_info
operator|->
name|regs_content
operator|=
operator|(
name|tui_win_content
operator|)
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|content
expr_stmt|;
name|display_info
operator|->
name|regs_content_count
operator|=
name|nr_regs
expr_stmt|;
block|}
comment|/* Now set the register names and values */
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|data_item_win
decl_stmt|;
name|struct
name|tui_data_element
modifier|*
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|group
argument_list|)
condition|)
continue|continue;
name|name
operator|=
name|gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
continue|continue;
name|data_item_win
operator|=
operator|&
name|display_info
operator|->
name|regs_content
index|[
name|pos
index|]
operator|->
name|which_element
operator|.
name|data_window
expr_stmt|;
name|data
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|data_item_win
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
if|if
condition|(
operator|!
name|refresh_values_only
condition|)
block|{
name|data
operator|->
name|item_no
operator|=
name|regnum
expr_stmt|;
name|data
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|data
operator|->
name|highlight
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|value
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
name|data
operator|->
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|MAX_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|tui_get_register
argument_list|(
name|gdbarch
argument_list|,
name|frame
argument_list|,
name|data
argument_list|,
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|content_size
operator|=
name|display_info
operator|->
name|regs_content_count
operator|+
name|display_info
operator|->
name|data_content_count
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Function to display the registers in the content from    'start_element_no' until the end of the register content or the end    of the display height.  No checking for displaying past the end of    the registers is done here.  */
end_comment

begin_function
name|void
name|tui_display_registers_from
parameter_list|(
name|int
name|start_element_no
parameter_list|)
block|{
name|struct
name|tui_data_info
modifier|*
name|display_info
init|=
operator|&
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
decl_stmt|;
if|if
condition|(
name|display_info
operator|->
name|regs_content
operator|!=
operator|(
name|tui_win_content
operator|)
name|NULL
operator|&&
name|display_info
operator|->
name|regs_content_count
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
name|start_element_no
decl_stmt|;
name|int
name|j
decl_stmt|,
name|value_chars_wide
decl_stmt|,
name|item_win_width
decl_stmt|,
name|cur_y
decl_stmt|;
name|int
name|max_len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|display_info
operator|->
name|regs_content_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_data_element
modifier|*
name|data
decl_stmt|;
name|struct
name|tui_gen_win_info
modifier|*
name|data_item_win
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|data_item_win
operator|=
operator|&
name|display_info
operator|->
name|regs_content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|data_window
expr_stmt|;
name|data
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|data_item_win
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|data
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|data
operator|->
name|content
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\t'
condition|)
name|len
operator|=
literal|8
operator|*
operator|(
operator|(
name|len
operator|/
literal|8
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|len
expr_stmt|;
block|}
name|item_win_width
operator|=
name|max_len
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|start_element_no
expr_stmt|;
name|display_info
operator|->
name|regs_column_count
operator|=
operator|(
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|width
operator|-
literal|2
operator|)
operator|/
name|item_win_width
expr_stmt|;
if|if
condition|(
name|display_info
operator|->
name|regs_column_count
operator|==
literal|0
condition|)
name|display_info
operator|->
name|regs_column_count
operator|=
literal|1
expr_stmt|;
name|item_win_width
operator|=
operator|(
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|width
operator|-
literal|2
operator|)
operator|/
name|display_info
operator|->
name|regs_column_count
expr_stmt|;
comment|/*          ** Now create each data "sub" window, and write the display into it.        */
name|cur_y
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|display_info
operator|->
name|regs_content_count
operator|&&
name|cur_y
operator|<=
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|viewport_height
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|display_info
operator|->
name|regs_column_count
operator|&&
name|i
operator|<
name|display_info
operator|->
name|regs_content_count
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|data_item_win
decl_stmt|;
name|struct
name|tui_data_element
modifier|*
name|data_element_ptr
decl_stmt|;
comment|/* create the window if necessary */
name|data_item_win
operator|=
operator|&
name|display_info
operator|->
name|regs_content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|data_window
expr_stmt|;
name|data_element_ptr
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|data_item_win
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|data_item_win
operator|->
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|data_item_win
operator|->
name|height
operator|!=
literal|1
operator|||
name|data_item_win
operator|->
name|width
operator|!=
name|item_win_width
operator|||
name|data_item_win
operator|->
name|origin
operator|.
name|x
operator|!=
operator|(
name|item_win_width
operator|*
name|j
operator|)
operator|+
literal|1
operator|||
name|data_item_win
operator|->
name|origin
operator|.
name|y
operator|!=
name|cur_y
operator|)
condition|)
block|{
name|tui_delete_win
argument_list|(
name|data_item_win
operator|->
name|handle
argument_list|)
expr_stmt|;
name|data_item_win
operator|->
name|handle
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_item_win
operator|->
name|handle
operator|==
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|data_item_win
operator|->
name|height
operator|=
literal|1
expr_stmt|;
name|data_item_win
operator|->
name|width
operator|=
name|item_win_width
expr_stmt|;
name|data_item_win
operator|->
name|origin
operator|.
name|x
operator|=
operator|(
name|item_win_width
operator|*
name|j
operator|)
operator|+
literal|1
expr_stmt|;
name|data_item_win
operator|->
name|origin
operator|.
name|y
operator|=
name|cur_y
expr_stmt|;
name|tui_make_window
argument_list|(
name|data_item_win
argument_list|,
name|DONT_BOX_WINDOW
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|data_item_win
operator|->
name|handle
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|touchwin
argument_list|(
name|data_item_win
operator|->
name|handle
argument_list|)
expr_stmt|;
comment|/* Get the printable representation of the register                  and display it.  */
name|tui_display_register
argument_list|(
name|data_element_ptr
argument_list|,
name|data_item_win
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* next register */
block|}
name|cur_y
operator|++
expr_stmt|;
comment|/* next row; */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Function to display the registers in the content from    'start_element_no' on 'start_line_no' until the end of the register    content or the end of the display height.  This function checks    that we won't display off the end of the register display.  */
end_comment

begin_function
name|void
name|tui_display_reg_element_at_line
parameter_list|(
name|int
name|start_element_no
parameter_list|,
name|int
name|start_line_no
parameter_list|)
block|{
if|if
condition|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content
operator|!=
operator|(
name|tui_win_content
operator|)
name|NULL
operator|&&
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
operator|>
literal|0
condition|)
block|{
name|int
name|element_no
init|=
name|start_element_no
decl_stmt|;
if|if
condition|(
name|start_element_no
operator|!=
literal|0
operator|&&
name|start_line_no
operator|!=
literal|0
condition|)
block|{
name|int
name|last_line_no
decl_stmt|,
name|first_line_on_last_page
decl_stmt|;
name|last_line_no
operator|=
name|tui_last_regs_line_no
argument_list|()
expr_stmt|;
name|first_line_on_last_page
operator|=
name|last_line_no
operator|-
operator|(
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|height
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|first_line_on_last_page
operator|<
literal|0
condition|)
name|first_line_on_last_page
operator|=
literal|0
expr_stmt|;
comment|/* 	     ** If there is no other data displayed except registers, 	     ** and the element_no causes us to scroll past the end of the 	     ** registers, adjust what element to really start the display at. 	   */
if|if
condition|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|data_content_count
operator|<=
literal|0
operator|&&
name|start_line_no
operator|>
name|first_line_on_last_page
condition|)
name|element_no
operator|=
name|tui_first_reg_element_no_inline
argument_list|(
name|first_line_on_last_page
argument_list|)
expr_stmt|;
block|}
name|tui_display_registers_from
argument_list|(
name|element_no
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function to display the registers starting at line line_no in the    data window.  Answers the line number that the display actually    started from.  If nothing is displayed (-1) is returned.  */
end_comment

begin_function
name|int
name|tui_display_registers_from_line
parameter_list|(
name|int
name|line_no
parameter_list|,
name|int
name|force_display
parameter_list|)
block|{
if|if
condition|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
operator|>
literal|0
condition|)
block|{
name|int
name|line
decl_stmt|,
name|element_no
decl_stmt|;
if|if
condition|(
name|line_no
operator|<
literal|0
condition|)
name|line
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|force_display
condition|)
block|{
comment|/* 				   ** If we must display regs (force_display is true), then make 				   ** sure that we don't display off the end of the registers. 				 */
if|if
condition|(
name|line_no
operator|>=
name|tui_last_regs_line_no
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|tui_line_from_reg_element_no
argument_list|(
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
operator|-
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|line
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|line
operator|=
name|line_no
expr_stmt|;
block|}
else|else
name|line
operator|=
name|line_no
expr_stmt|;
name|element_no
operator|=
name|tui_first_reg_element_no_inline
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|element_no
operator|<
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|regs_content_count
condition|)
name|tui_display_reg_element_at_line
argument_list|(
name|element_no
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|line
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|line
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* nothing was displayed */
block|}
end_function

begin_comment
comment|/* This function check all displayed registers for changes in values,    given a particular frame.  If the values have changed, they are    updated with the new value and highlighted.  */
end_comment

begin_function
name|void
name|tui_check_register_values
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|TUI_DATA_WIN
operator|!=
name|NULL
operator|&&
name|TUI_DATA_WIN
operator|->
name|generic
operator|.
name|is_visible
condition|)
block|{
name|struct
name|tui_data_info
modifier|*
name|display_info
init|=
operator|&
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
decl_stmt|;
if|if
condition|(
name|display_info
operator|->
name|regs_content_count
operator|<=
literal|0
operator|&&
name|display_info
operator|->
name|display_regs
condition|)
name|tui_show_registers
argument_list|(
name|display_info
operator|->
name|current_group
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|display_info
operator|->
name|regs_content_count
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_data_element
modifier|*
name|data
decl_stmt|;
name|struct
name|tui_gen_win_info
modifier|*
name|data_item_win_ptr
decl_stmt|;
name|int
name|was_hilighted
decl_stmt|;
name|data_item_win_ptr
operator|=
operator|&
name|display_info
operator|->
name|regs_content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|data_window
expr_stmt|;
name|data
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|data_item_win_ptr
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|data
expr_stmt|;
name|was_hilighted
operator|=
name|data
operator|->
name|highlight
expr_stmt|;
name|tui_get_register
argument_list|(
name|current_gdbarch
argument_list|,
name|frame
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|item_no
argument_list|,
operator|&
name|data
operator|->
name|highlight
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|highlight
operator|||
name|was_hilighted
condition|)
block|{
name|tui_display_register
argument_list|(
name|data
argument_list|,
name|data_item_win_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Display a register in a window.  If hilite is TRUE,    then the value will be displayed in reverse video  */
end_comment

begin_function
specifier|static
name|void
name|tui_display_register
parameter_list|(
name|struct
name|tui_data_element
modifier|*
name|data
parameter_list|,
name|struct
name|tui_gen_win_info
modifier|*
name|win_info
parameter_list|)
block|{
if|if
condition|(
name|win_info
operator|->
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|highlight
condition|)
name|wstandout
argument_list|(
name|win_info
operator|->
name|handle
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win_info
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|win_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|win_info
operator|->
name|handle
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win_info
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|content
condition|)
name|waddstr
argument_list|(
name|win_info
operator|->
name|handle
argument_list|,
name|data
operator|->
name|content
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|highlight
condition|)
name|wstandend
argument_list|(
name|win_info
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tui_refresh_win
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tui_reg_next_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|TUI_DATA_WIN
operator|!=
literal|0
condition|)
block|{
name|struct
name|reggroup
modifier|*
name|group
init|=
name|TUI_DATA_WIN
operator|->
name|detail
operator|.
name|data_display_info
operator|.
name|current_group
decl_stmt|;
name|group
operator|=
name|reggroup_next
argument_list|(
name|current_gdbarch
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
literal|0
condition|)
name|group
operator|=
name|reggroup_next
argument_list|(
name|current_gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
condition|)
name|tui_show_registers
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tui_reg_float_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|tui_show_registers
argument_list|(
name|float_reggroup
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_reg_general_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|tui_show_registers
argument_list|(
name|general_reggroup
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_reg_system_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|tui_show_registers
argument_list|(
name|system_reggroup
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|tuireglist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tui_reg_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"tui reg\" must be followed by the name of a "
literal|"tui reg command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|tuireglist
argument_list|,
literal|"tui reg "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_tui_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|tuicmd
decl_stmt|;
name|tuicmd
operator|=
name|tui_get_cmd_list
argument_list|()
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"reg"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_command
argument_list|,
literal|"TUI commands to control the register window."
argument_list|,
operator|&
name|tuireglist
argument_list|,
literal|"tui reg "
argument_list|,
literal|0
argument_list|,
name|tuicmd
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"float"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_float_command
argument_list|,
literal|"Display only floating point registers\n"
argument_list|,
operator|&
name|tuireglist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"general"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_general_command
argument_list|,
literal|"Display only general registers\n"
argument_list|,
operator|&
name|tuireglist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"system"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_system_command
argument_list|,
literal|"Display only system registers\n"
argument_list|,
operator|&
name|tuireglist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"next"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_next_command
argument_list|,
literal|"Display next register group\n"
argument_list|,
operator|&
name|tuireglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"fr"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_float_command
argument_list|,
literal|"Display only floating point registers\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"gr"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_general_command
argument_list|,
literal|"Display only general registers\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sr"
argument_list|,
name|class_tui
argument_list|,
name|tui_reg_system_command
argument_list|,
literal|"Display only special registers\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"+r"
argument_list|,
name|class_tui
argument_list|,
name|tui_scroll_regs_forward_command
argument_list|,
literal|"Scroll the registers window forward\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"-r"
argument_list|,
name|class_tui
argument_list|,
name|tui_scroll_regs_backward_command
argument_list|,
literal|"Scroll the register window backward\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS                 ** ******************************************/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|pagination_enabled
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tui_restore_gdbout
parameter_list|(
name|void
modifier|*
name|ui
parameter_list|)
block|{
name|ui_file_delete
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_stdout
operator|=
operator|(
expr|struct
name|ui_file
operator|*
operator|)
name|ui
expr_stmt|;
name|pagination_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the register from the frame and make a printable representation    of it in the data element.  */
end_comment

begin_function
specifier|static
name|void
name|tui_register_format
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|struct
name|tui_data_element
modifier|*
name|data_element
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|stream
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|old_stdout
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
name|name
operator|=
name|gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|pagination_enabled
operator|=
literal|0
expr_stmt|;
name|old_stdout
operator|=
name|gdb_stdout
expr_stmt|;
name|stream
operator|=
name|tui_sfileopen
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|gdb_stdout
operator|=
name|stream
expr_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|tui_restore_gdbout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|old_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%-14s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|print_scalar_formatted
argument_list|(
name|buf
argument_list|,
name|type
argument_list|,
literal|'f'
argument_list|,
name|len
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdbarch_print_registers_info
argument_list|(
name|current_gdbarch
argument_list|,
name|stream
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Save formatted output in the buffer.  */
name|p
operator|=
name|tui_file_get_strbuf
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* Remove the possible \n.  */
name|s
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|0
condition|)
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
name|data_element
operator|->
name|content
argument_list|)
expr_stmt|;
name|data_element
operator|->
name|content
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the register value from the given frame and format it for    the display.  When changep is set, check if the new register value    has changed with respect to the previous call.  */
end_comment

begin_function
specifier|static
name|enum
name|tui_status
name|tui_get_register
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|struct
name|tui_data_element
modifier|*
name|data
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|changedp
parameter_list|)
block|{
name|enum
name|tui_status
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
if|if
condition|(
name|changedp
condition|)
operator|*
name|changedp
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|target_has_registers
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-03-13: This is bogus.  It is refering to          the register cache and not the frame which could have pulled          the register value off the stack.  */
if|if
condition|(
name|register_cached
argument_list|(
name|regnum
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|changedp
condition|)
block|{
name|int
name|size
init|=
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
name|char
modifier|*
name|old
init|=
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
name|old
index|[
name|i
index|]
condition|)
block|{
operator|*
name|changedp
operator|=
name|TRUE
expr_stmt|;
name|old
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Reformat the data content if the value changed.  */
if|if
condition|(
name|changedp
operator|==
literal|0
operator|||
operator|*
name|changedp
operator|==
name|TRUE
condition|)
name|tui_register_format
argument_list|(
name|gdbarch
argument_list|,
name|frame
argument_list|,
name|data
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_scroll_regs_forward_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|tui_scroll
argument_list|(
name|FORWARD_SCROLL
argument_list|,
name|TUI_DATA_WIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_scroll_regs_backward_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|tui_scroll
argument_list|(
name|BACKWARD_SCROLL
argument_list|,
name|TUI_DATA_WIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

