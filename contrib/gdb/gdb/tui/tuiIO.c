begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** This module contains functions to support i/o in the TUI */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"tuiIO.h"
end_include

begin_include
include|#
directive|include
file|"tuiCommand.h"
end_include

begin_include
include|#
directive|include
file|"tuiWin.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The Solaris header files seem to provide no declaration for this at    all when __STDC__ is defined.  This shouldn't conflict with    anything.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|insert_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************** **       LOCAL STATIC FORWARD DECLS        ** ********************************************/
end_comment

begin_decl_stmt
specifier|static
name|void
name|_updateCommandInfo
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|_tuiHandleResizeDuringIO
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************************************************************* **                              PUBLIC FUNCTIONS                                ** *********************************************************************************/
end_comment

begin_comment
comment|/* ** tuiPuts_unfiltered(). **        Function to put a string to the command window **              When running in TUI mode, this is the "hook" **              for fputs_unfiltered(). That is, all debugger **              output eventually makes it's way to the bottom-level **              routine fputs_unfiltered (main.c), which (in TUI **              mode), calls tuiPuts_unfiltered(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiPuts_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|GDB_FILE
modifier|*
name|stream
parameter_list|)
else|#
directive|else
function|tuiPuts_unfiltered
parameter_list|(
name|string
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|linech
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
name|m_tuiStartNewLine
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|+
literal|1
operator|)
operator|>
name|cmdWin
operator|->
name|generic
operator|.
name|width
condition|)
name|m_tuiStartNewLine
expr_stmt|;
if|if
condition|(
name|insert_mode
condition|)
block|{
name|mvwinsch
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|++
argument_list|,
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
block|}
else|else
name|mvwaddch
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|++
argument_list|,
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|tuiRefreshWin
argument_list|(
operator|&
name|cmdWin
operator|->
name|generic
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiPuts_unfiltered */
end_comment

begin_comment
comment|/* A cover routine for tputs().  * tputs() is called from the readline package to put  * out strings representing cursor positioning.  * In TUI mode (non-XDB-style), tui_tputs() is called instead.  *  * The reason we need to hook tputs() is:  * Since the output is going to curses and not to  * a raw terminal, we need to intercept these special  * sequences, and handle them them here.  *  * This function seems to be correctly handling all sequences  * aimed at hpterm's, but there is additional work to do  * for xterm's and dtterm's. I abandoned further work on this  * in favor of "XDB style". In "XDB style", the command region  * looks like terminal, not a curses window, and this routine  * is not called. - RT  */
end_comment

begin_function_decl
name|void
name|tui_tputs
parameter_list|(
name|str
parameter_list|,
name|affcnt
parameter_list|,
name|putfunc
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|affcnt
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*putfunc
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
comment|/* the prompt string */
comment|/* This set of globals are defined and initialized    * by the readline package.    *    * Note we're assuming tui_tputs() is being called    * by the readline package. That's because we're recognizing    * that a given string is being passed by    * matching the string address against readline's    * term_<whatever> global. To make this more general,    * we'd have to actually recognize the termcap sequence    * inside the string (more work than I want to do). - RT    *    * We don't see or need to handle every one of these here;    * this is just the full list defined in readline/readline.c    */
specifier|extern
name|char
modifier|*
name|term_backspace
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_clreol
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_clrpag
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_cr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_dc
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_ei
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_goto
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_ic
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_im
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_mm
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_mo
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_up
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_scroll_region
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_memory_lock
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_memory_unlock
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_cursor_move
decl_stmt|;
specifier|extern
name|char
modifier|*
name|visible_bell
decl_stmt|;
comment|/* Sanity check - if not TUI, just call tputs() */
if|if
condition|(
operator|!
name|tui_version
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
name|affcnt
argument_list|,
name|putfunc
argument_list|)
expr_stmt|;
comment|/* The strings we special-case are handled first */
if|if
condition|(
name|str
operator|==
name|term_backspace
condition|)
block|{
comment|/* Backspace. */
comment|/* We see this on an emacs control-B.      * I.e., it's like the left-arrow key (not like the backspace key).      * The effect that readline wants when it transmits this      * character to us is simply to back up one character      * (but not to write a space over the old character).      */
name|_updateCommandInfo
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_clreol
condition|)
block|{
comment|/* Clear to end of line. */
name|wclrtoeol
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_cr
condition|)
block|{
comment|/* Carriage return */
name|_updateCommandInfo
argument_list|(
operator|-
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
argument_list|,
literal|0
comment|/* readline will rewrite the prompt from 0 */
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_goto
condition|)
block|{
comment|/* This is actually a tgoto() specifying a character position,      * followed by either a term_IC/term_DC which [I think] means      * insert/delete one character at that position.      * There are complications with this one - need to either      * extract the position from the string, or have a backdoor      * means of communicating it from ../readline/display.c.      * So this one is not yet implemented.      * Not doing it seems to have no ill effects on command-line-editing      * that I've noticed so far. - RT      */
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_dc
condition|)
block|{
comment|/* Delete character at current cursor position */
name|wdelch
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_im
condition|)
block|{
comment|/* Turn on insert mode. */
name|insert_mode
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_ei
condition|)
block|{
comment|/* Turn off insert mode. */
name|insert_mode
operator|=
literal|0
expr_stmt|;
comment|/* Strings we know about but don't handle    * specially here are just passed along to tputs().    *    * These are not handled because (as far as I can tell)    * they are not actually emitted by the readline package    * in the course of doing command-line editing. Some of them    * theoretically could be used in the future, in which case we'd    * need to handle them.    */
block|}
elseif|else
if|if
condition|(
name|str
operator|==
name|term_ic
operator|||
comment|/* insert character */
name|str
operator|==
name|term_cursor_move
operator|||
comment|/* cursor move */
name|str
operator|==
name|term_clrpag
operator|||
comment|/* clear page */
name|str
operator|==
name|term_mm
operator|||
comment|/* turn on meta key */
name|str
operator|==
name|term_mo
operator|||
comment|/* turn off meta key */
name|str
operator|==
name|term_up
operator|||
comment|/* up one line (not expected) */
name|str
operator|==
name|term_scroll_region
operator|||
comment|/* set scroll region */
name|str
operator|==
name|term_memory_lock
operator|||
comment|/* lock screen above cursor */
name|str
operator|==
name|term_memory_unlock
operator|||
comment|/* unlock screen above cursor */
name|str
operator|==
name|visible_bell
condition|)
block|{
comment|/* flash screen */
name|tputs
argument_list|(
name|str
argument_list|,
name|affcnt
argument_list|,
name|putfunc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* something else */
name|tputs
argument_list|(
name|str
argument_list|,
name|affcnt
argument_list|,
name|putfunc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* tui_tputs */
end_comment

begin_comment
comment|/* ** tui_vwgetch() **        Wrapper around wgetch with the window in a va_list */
end_comment

begin_function
name|unsigned
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vwgetch
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vwgetch
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|unsigned
name|int
name|ch
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|window
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|WINDOW
operator|*
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|int
operator|)
name|wgetch
argument_list|(
name|window
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tui_vwgetch */
end_comment

begin_comment
comment|/* ** tui_vread() **   Wrapper around read() with paramets in a va_list */
end_comment

begin_function
name|unsigned
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vread
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vread
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|filedes
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|int
name|nbytes
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|result
operator|=
name|read
argument_list|(
name|filedes
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* tui_vread() */
end_comment

begin_comment
comment|/* ** tuiRead() **    Function to perform a read() catching resize events */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiRead
parameter_list|(
name|int
name|filedes
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
else|#
directive|else
function|tuiRead
parameter_list|(
name|filedes
parameter_list|,
name|buf
parameter_list|,
name|nbytes
parameter_list|)
name|int
name|filedes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|result
operator|=
operator|(
name|int
operator|)
name|vcatch_errors
argument_list|(
operator|(
name|OpaqueFuncPtr
operator|)
name|tui_vread
argument_list|,
name|filedes
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|_tuiHandleResizeDuringIO
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* tuiRead */
end_comment

begin_comment
comment|/* ** tuiGetc(). **        Get a character from the command window. **		This is called from the readline package, **              that is, we have: **                tuiGetc() [here], called from **                readline code [in ../readline/], called from **                command_line_input() in top.c */
end_comment

begin_function
name|unsigned
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiGetc
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiGetc
parameter_list|()
endif|#
directive|endif
block|{
name|unsigned
name|int
name|ch
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
specifier|extern
name|int
name|rl_point
decl_stmt|;
comment|/* Call the curses routine that reads one character */
ifndef|#
directive|ifndef
name|COMMENT
name|ch
operator|=
operator|(
name|unsigned
name|int
operator|)
name|vcatch_errors
argument_list|(
operator|(
name|OpaqueFuncPtr
operator|)
name|tui_vwgetch
argument_list|,
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
else|#
directive|else
name|ch
operator|=
name|wgetch
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ch
operator|=
name|_tuiHandleResizeDuringIO
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_isCommandChar
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* Handle prev/next/up/down here */
name|tuiTermSetup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|=
name|tuiDispatchCtrlChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|=
name|strlen
argument_list|(
name|rl_prompt
argument_list|)
operator|+
name|rl_point
expr_stmt|;
name|tuiTermUnsetup
argument_list|(
literal|0
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\f'
condition|)
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|=
literal|0
expr_stmt|;
else|else
name|tuiIncrCommandCharCountBy
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* tuiGetc */
end_comment

begin_comment
comment|/* ** tuiBufferGetc(). */
end_comment

begin_comment
comment|/*elz: this function reads a line of input from the user and puts it in a static buffer. Subsequent calls to this same function obtain one char at the time, providing the caller with a behavior similar to fgetc. When the input is buffered, the backspaces have the needed effect, i.e. ignore the last char active in the buffer*/
end_comment

begin_comment
comment|/* so far this function is called only from the query function in utils.c*/
end_comment

begin_function
name|unsigned
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiBufferGetc
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiBufferGetc
parameter_list|()
endif|#
directive|endif
block|{
name|unsigned
name|int
name|ch
decl_stmt|;
specifier|static
name|unsigned
name|char
name|_ibuffer
index|[
literal|512
index|]
decl_stmt|;
specifier|static
name|int
name|index_read
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|length_of_answer
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length_of_answer
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* this is the first time through, need to read the answer*/
do|do
block|{
comment|/* Call the curses routine that reads one character */
name|ch
operator|=
operator|(
name|unsigned
name|int
operator|)
name|wgetch
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\b'
condition|)
block|{
name|_ibuffer
index|[
name|pos
index|]
operator|=
name|ch
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
name|pos
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
do|;
name|length_of_answer
operator|=
name|pos
expr_stmt|;
name|index_read
operator|=
literal|0
expr_stmt|;
block|}
name|ch
operator|=
name|_ibuffer
index|[
name|index_read
index|]
expr_stmt|;
name|index_read
operator|++
expr_stmt|;
if|if
condition|(
name|index_read
operator|==
name|length_of_answer
condition|)
block|{
comment|/*this is the last time through, reset for next query*/
name|index_read
operator|=
operator|-
literal|1
expr_stmt|;
name|length_of_answer
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|wrefresh
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiBufferGetc */
end_comment

begin_comment
comment|/* ** tuiStartNewLines(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiStartNewLines
parameter_list|(
name|int
name|numLines
parameter_list|)
else|#
directive|else
function|tuiStartNewLines
parameter_list|(
name|numLines
parameter_list|)
name|int
name|numLines
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|numLines
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cmdWin
operator|->
name|generic
operator|.
name|viewportHeight
operator|>
literal|1
operator|&&
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
operator|<
name|cmdWin
operator|->
name|generic
operator|.
name|viewportHeight
condition|)
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
operator|+=
name|numLines
expr_stmt|;
else|else
name|scroll
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|=
literal|0
expr_stmt|;
name|wmove
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
name|tuiRefreshWin
argument_list|(
operator|&
name|cmdWin
operator|->
name|generic
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiStartNewLines */
end_comment

begin_comment
comment|/* ** tui_vStartNewLines(). **        With numLines in a va_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vStartNewLines
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vStartNewLines
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|numLines
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|tuiStartNewLines
argument_list|(
name|numLines
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tui_vStartNewLines */
end_comment

begin_comment
comment|/**************************************************************************** **                   LOCAL STATIC FUNCTIONS                                ** *****************************************************************************/
end_comment

begin_comment
comment|/* ** _tuiHandleResizeDuringIO **    This function manages the cleanup when a resize has occured **    From within a call to getch() or read.  Returns the character **    to return from getc or read. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiHandleResizeDuringIO
parameter_list|(
name|unsigned
name|int
name|originalCh
parameter_list|)
comment|/* the char just read */
else|#
directive|else
function|_tuiHandleResizeDuringIO
parameter_list|(
name|originalCh
parameter_list|)
name|unsigned
name|int
name|originalCh
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|tuiWinResized
argument_list|()
condition|)
block|{
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tuiRefreshAll
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|tuiSetWinResizedTo
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|rl_reset
argument_list|()
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
else|else
return|return
name|originalCh
return|;
block|}
end_function

begin_comment
comment|/* _tuiHandleResizeDuringIO */
end_comment

begin_comment
comment|/* ** _updateCommandInfo(). **        Function to update the command window information. */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_updateCommandInfo
parameter_list|(
name|int
name|sizeOfString
parameter_list|)
else|#
directive|else
function|_updateCommandInfo
parameter_list|(
name|sizeOfString
parameter_list|)
name|int
name|sizeOfString
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|sizeOfString
operator|+
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|)
operator|>
name|cmdWin
operator|->
name|generic
operator|.
name|width
condition|)
block|{
name|int
name|newCurch
init|=
name|sizeOfString
operator|+
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
decl_stmt|;
name|tuiStartNewLines
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|=
name|newCurch
operator|-
name|cmdWin
operator|->
name|generic
operator|.
name|width
expr_stmt|;
block|}
else|else
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|+=
name|sizeOfString
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* _updateCommandInfo */
end_comment

begin_comment
comment|/* Looked at in main.c, fputs_unfiltered(), to decide  * if it's safe to do standard output to the command window.  */
end_comment

begin_decl_stmt
name|int
name|tui_owns_terminal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called to set up the terminal for TUI (curses) I/O.  * We do this either on our way "in" to GDB after target  * program execution, or else within tuiDo just before  * going off to TUI routines.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiTermSetup
parameter_list|(
name|int
name|turn_off_echo
parameter_list|)
else|#
directive|else
function|tuiTermSetup
parameter_list|(
name|turn_off_echo
parameter_list|)
name|int
name|turn_off_echo
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|endcol
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_scroll_region
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_cursor_move
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_memory_lock
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_memory_unlock
decl_stmt|;
comment|/* Turn off echoing, since the TUI does not      * expect echoing. Below I only put in the TERMIOS      * case, since that is what applies on HP-UX. turn_off_echo      * is 1 except for the case where we're being called      * on a "quit", in which case we want to leave echo on.      */
if|if
condition|(
name|turn_off_echo
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tio
decl_stmt|;
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|tio
argument_list|)
expr_stmt|;
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator|)
expr_stmt|;
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|tio
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Compute the start and end lines of the command      * region. (Actually we only use end here)      */
name|start
operator|=
name|winList
index|[
name|CMD_WIN
index|]
operator|->
name|generic
operator|.
name|origin
operator|.
name|y
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|winList
index|[
name|CMD_WIN
index|]
operator|->
name|generic
operator|.
name|height
operator|-
literal|1
expr_stmt|;
name|endcol
operator|=
name|winList
index|[
name|CMD_WIN
index|]
operator|->
name|generic
operator|.
name|width
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|term_memory_unlock
condition|)
block|{
comment|/* Un-do the effect of the memory lock in terminal_inferior() */
name|tputs
argument_list|(
name|term_memory_unlock
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|term_scroll_region
condition|)
block|{
comment|/* Un-do the effect of setting scroll region in terminal_inferior() */
comment|/* I'm actually not sure how to do this (we don't know for        * sure what the scroll region was *before* we changed it),        * but I'll guess that setting it to the whole screen is        * the right thing. So, ...        */
comment|/* Set scroll region to be 0..end */
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|tgoto
argument_list|(
name|term_scroll_region
argument_list|,
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
block|}
comment|/* else we're out of luck */
comment|/* This is an attempt to keep the logical& physical        * cursor in synch, going into curses. Without this,        * curses seems to be confused by the fact that        * GDB has physically moved the curser on it. One        * visible effect of removing this code is that the        * locator window fails to get updated and the line        * of text that *should* go into the locator window        * often goes to the wrong place.        */
comment|/* What's done here is to  tell curses to write a ' '        * at the bottom right corner of the screen.        * The idea is to wind up with the cursor in a known        * place.        * Note I'm relying on refresh()        * only writing what changed (the space),        * not the whole screen.        */
name|standend
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|end
argument_list|,
name|endcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|tui_owns_terminal
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tuiTermSetup */
end_comment

begin_comment
comment|/* Called to set up the terminal for target program I/O, meaning I/O  * is confined to the command-window area.  We also call this on our  * way out of tuiDo, thus setting up the terminal this way for  * debugger command I/O.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiTermUnsetup
parameter_list|(
name|int
name|turn_on_echo
parameter_list|,
name|int
name|to_column
parameter_list|)
else|#
directive|else
function|tuiTermUnsetup
parameter_list|(
name|turn_on_echo
parameter_list|,
name|to_column
parameter_list|)
name|int
name|turn_on_echo
decl_stmt|;
name|int
name|to_column
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|curline
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* The next bunch of things are from readline */
specifier|extern
name|char
modifier|*
name|term_scroll_region
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_cursor_move
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_memory_lock
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_memory_unlock
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_se
decl_stmt|;
comment|/* We need to turn on echoing, since the TUI turns it off */
comment|/* Below I only put in the TERMIOS case, since that      * is what applies on HP-UX.      */
if|if
condition|(
name|turn_on_echo
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tio
decl_stmt|;
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|tio
argument_list|)
expr_stmt|;
name|tio
operator|.
name|c_lflag
operator||=
operator|(
name|ECHO
operator|)
expr_stmt|;
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|tio
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Compute the start and end lines of the command      * region, as well as the last "real" line of      * the region (normally same as end, except when      * we're first populating the region)      */
name|start
operator|=
name|winList
index|[
name|CMD_WIN
index|]
operator|->
name|generic
operator|.
name|origin
operator|.
name|y
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|winList
index|[
name|CMD_WIN
index|]
operator|->
name|generic
operator|.
name|height
operator|-
literal|1
expr_stmt|;
name|curline
operator|=
name|start
operator|+
name|winList
index|[
name|CMD_WIN
index|]
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
expr_stmt|;
comment|/* We want to confine target I/O to the command region.      * In order to do so, we must either have "memory lock"      * (hpterm's) or "scroll regions" (xterm's).      */
if|if
condition|(
name|term_cursor_move
operator|&&
name|term_memory_lock
condition|)
block|{
comment|/* Memory lock means lock region above cursor.        * So first position the cursor, then call memory lock.        */
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_cursor_move
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|term_memory_lock
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|term_scroll_region
condition|)
block|{
comment|/* Set the scroll region to the command window */
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_scroll_region
argument_list|,
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
block|}
comment|/* else we can't do anything about target I/O */
comment|/* Also turn off standout mode, in case it is on */
if|if
condition|(
name|term_se
operator|!=
name|NULL
condition|)
name|tputs
argument_list|(
name|term_se
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
comment|/* Now go to the appropriate spot on the end line */
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_cursor_move
argument_list|,
name|to_column
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|putchar
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|tui_owns_terminal
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tuiTermUnsetup */
end_comment

end_unit

