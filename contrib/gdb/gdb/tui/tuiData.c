begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** tuiData.c **    This module contains functions for manipulating the data **    structures used by the TUI */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_comment
comment|/**************************** ** GLOBAL DECLARATIONS ****************************/
end_comment

begin_decl_stmt
name|TuiWinInfoPtr
name|winList
index|[
name|MAX_MAJOR_WINDOWS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************** ** Private Definitions ****************************/
end_comment

begin_define
define|#
directive|define
name|FILE_WIDTH
value|30
end_define

begin_define
define|#
directive|define
name|PROC_WIDTH
value|40
end_define

begin_define
define|#
directive|define
name|LINE_WIDTH
value|4
end_define

begin_define
define|#
directive|define
name|PC_WIDTH
value|8
end_define

begin_comment
comment|/*************************** ** Private data ****************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_tuiNullStr
init|=
name|TUI_NULL_STR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_tuiBlankStr
init|=
literal|"   "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_tuiLocationStr
init|=
literal|">"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_tuiBreakStr
init|=
literal|" * "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_tuiBreakLocationStr
init|=
literal|" *>"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiLayoutType
name|_currentLayout
init|=
name|UNDEFINED_LAYOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_termHeight
decl_stmt|,
name|_termWidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_historyLimit
init|=
name|DEFAULT_HISTORY_COUNT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiGenWinInfo
name|_locator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiGenWinInfo
name|_execInfo
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiWinInfoPtr
name|_srcWinList
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiList
name|_sourceWindows
init|=
block|{
operator|(
name|OpaqueList
operator|)
name|_srcWinList
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_defaultTabLen
init|=
name|DEFAULT_TAB_LEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiWinInfoPtr
name|_winWithFocus
init|=
operator|(
name|TuiWinInfoPtr
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TuiLayoutDef
name|_layoutDef
init|=
block|{
name|SRC_WIN
block|,
comment|/* displayMode */
name|FALSE
block|,
comment|/* split */
name|TUI_UNDEFINED_REGS
block|,
comment|/* regsDisplayType */
name|TUI_SFLOAT_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* floatRegsDisplayType */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_winResized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************* ** Static function forward decls **********************************/
end_comment

begin_decl_stmt
specifier|static
name|void
name|freeContent
name|PARAMS
argument_list|(
operator|(
name|TuiWinContent
operator|,
name|int
operator|,
name|TuiWinType
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freeContentElements
name|PARAMS
argument_list|(
operator|(
name|TuiWinContent
operator|,
name|int
operator|,
name|TuiWinType
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************* ** PUBLIC FUNCTIONS **********************************/
end_comment

begin_comment
comment|/****************************************** ** ACCESSORS& MUTATORS FOR PRIVATE DATA ******************************************/
end_comment

begin_comment
comment|/* ** tuiWinResized(). **        Answer a whether the terminal window has been resized or not */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiWinResized
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiWinResized
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_winResized
return|;
block|}
end_function

begin_comment
comment|/* tuiWinResized */
end_comment

begin_comment
comment|/* ** tuiSetWinResized(). **        Set a whether the terminal window has been resized or not */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetWinResizedTo
parameter_list|(
name|int
name|resized
parameter_list|)
else|#
directive|else
function|tuiSetWinResizedTo
parameter_list|(
name|resized
parameter_list|)
name|int
name|resized
decl_stmt|;
endif|#
directive|endif
block|{
name|_winResized
operator|=
name|resized
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiSetWinResizedTo */
end_comment

begin_comment
comment|/* ** tuiLayoutDef(). **        Answer a pointer to the current layout definition */
end_comment

begin_function
name|TuiLayoutDefPtr
ifdef|#
directive|ifdef
name|__STDC__
name|tuiLayoutDef
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiLayoutDef
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|&
name|_layoutDef
return|;
block|}
end_function

begin_comment
comment|/* tuiLayoutDef */
end_comment

begin_comment
comment|/* ** tuiWinWithFocus(). **        Answer the window with the logical focus */
end_comment

begin_function
name|TuiWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|tuiWinWithFocus
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiWinWithFocus
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_winWithFocus
return|;
block|}
end_function

begin_comment
comment|/* tuiWinWithFocus */
end_comment

begin_comment
comment|/* ** tuiSetWinWithFocus(). **        Set the window that has the logical focus */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetWinWithFocus
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiSetWinWithFocus
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|_winWithFocus
operator|=
name|winInfo
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiSetWinWithFocus */
end_comment

begin_comment
comment|/* ** tuiDefaultTabLen(). **        Answer the length in chars, of tabs */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDefaultTabLen
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiDefaultTabLen
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_defaultTabLen
return|;
block|}
end_function

begin_comment
comment|/* tuiDefaultTabLen */
end_comment

begin_comment
comment|/* ** tuiSetDefaultTabLen(). **        Set the length in chars, of tabs */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetDefaultTabLen
parameter_list|(
name|int
name|len
parameter_list|)
else|#
directive|else
function|tuiSetDefaultTabLen
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
endif|#
directive|endif
block|{
name|_defaultTabLen
operator|=
name|len
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiSetDefaultTabLen */
end_comment

begin_comment
comment|/* ** currentSourceWin() **        Accessor for the current source window.  Usually there is only **        one source window (either source or disassembly), but both can **        be displayed at the same time. */
end_comment

begin_function
name|TuiListPtr
ifdef|#
directive|ifdef
name|__STDC__
name|sourceWindows
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|sourceWindows
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|&
name|_sourceWindows
return|;
block|}
end_function

begin_comment
comment|/* currentSourceWindows */
end_comment

begin_comment
comment|/* ** clearSourceWindows() **        Clear the list of source windows.  Usually there is only one **        source window (either source or disassembly), but both can be **        displayed at the same time. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|clearSourceWindows
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|clearSourceWindows
parameter_list|()
endif|#
directive|endif
block|{
name|_sourceWindows
operator|.
name|list
index|[
literal|0
index|]
operator|=
operator|(
name|Opaque
operator|)
name|NULL
expr_stmt|;
name|_sourceWindows
operator|.
name|list
index|[
literal|1
index|]
operator|=
operator|(
name|Opaque
operator|)
name|NULL
expr_stmt|;
name|_sourceWindows
operator|.
name|count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* currentSourceWindows */
end_comment

begin_comment
comment|/* ** clearSourceWindowsDetail() **        Clear the pertinant detail in the source windows. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|clearSourceWindowsDetail
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|clearSourceWindowsDetail
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|clearWinDetail
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* currentSourceWindows */
end_comment

begin_comment
comment|/* ** addSourceWindowToList(). **       Add a window to the list of source windows.  Usually there is **       only one source window (either source or disassembly), but **       both can be displayed at the same time. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|addToSourceWindows
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|addToSourceWindows
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|_sourceWindows
operator|.
name|count
operator|<
literal|2
condition|)
name|_sourceWindows
operator|.
name|list
index|[
name|_sourceWindows
operator|.
name|count
operator|++
index|]
operator|=
operator|(
name|Opaque
operator|)
name|winInfo
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* addToSourceWindows */
end_comment

begin_comment
comment|/* ** clearWinDetail() **        Clear the pertinant detail in the windows. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|clearWinDetail
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|clearWinDetail
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|winInfo
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
case|case
name|DISASSEM_WIN
case|:
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|startLineOrAddr
operator|.
name|addr
operator|=
operator|(
name|Opaque
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CMD_WIN
case|:
name|winInfo
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
operator|=
name|winInfo
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DATA_WIN
case|:
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|=
name|TUI_UNDEFINED_REGS
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|=
literal|1
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|displayRegs
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* clearWinDetail */
end_comment

begin_comment
comment|/* ** blankStr() **        Accessor for the blank string. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|blankStr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|blankStr
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_tuiBlankStr
return|;
block|}
end_function

begin_comment
comment|/* blankStr */
end_comment

begin_comment
comment|/* ** locationStr() **        Accessor for the location string. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|locationStr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|locationStr
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_tuiLocationStr
return|;
block|}
end_function

begin_comment
comment|/* locationStr */
end_comment

begin_comment
comment|/* ** breakStr() **        Accessor for the break string. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|breakStr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|breakStr
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_tuiBreakStr
return|;
block|}
end_function

begin_comment
comment|/* breakStr */
end_comment

begin_comment
comment|/* ** breakLocationStr() **        Accessor for the breakLocation string. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|breakLocationStr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|breakLocationStr
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_tuiBreakLocationStr
return|;
block|}
end_function

begin_comment
comment|/* breakLocationStr */
end_comment

begin_comment
comment|/* ** nullStr() **        Accessor for the null string. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|nullStr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|nullStr
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_tuiNullStr
return|;
block|}
end_function

begin_comment
comment|/* nullStr */
end_comment

begin_comment
comment|/* ** sourceExecInfoPtr(). **        Accessor for the source execution info ptr. */
end_comment

begin_function
name|TuiGenWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|sourceExecInfoWinPtr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|sourceExecInfoWinPtr
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|&
name|_execInfo
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* sourceExecInfoWinPtr */
end_comment

begin_comment
comment|/* ** disassemExecInfoPtr(). **        Accessor for the disassem execution info ptr. */
end_comment

begin_function
name|TuiGenWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|disassemExecInfoWinPtr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|disassemExecInfoWinPtr
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|&
name|_execInfo
index|[
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* disassemExecInfoWinPtr */
end_comment

begin_comment
comment|/* ** locatorWinInfoPtr(). **        Accessor for the locator win info.  Answers a pointer to the **        static locator win info struct. */
end_comment

begin_function
name|TuiGenWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|locatorWinInfoPtr
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|locatorWinInfoPtr
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|&
name|_locator
return|;
block|}
end_function

begin_comment
comment|/* locatorWinInfoPtr */
end_comment

begin_comment
comment|/* ** historyLimit(). **        Accessor for the history limit */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|historyLimit
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|historyLimit
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_historyLimit
return|;
block|}
end_function

begin_comment
comment|/* historyLimit */
end_comment

begin_comment
comment|/* ** setHistoryLimitTo(). **        Mutator for the history limit */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|setHistoryLimitTo
parameter_list|(
name|int
name|h
parameter_list|)
else|#
directive|else
function|setHistoryLimitTo
parameter_list|(
name|h
parameter_list|)
name|int
name|h
decl_stmt|;
endif|#
directive|endif
block|{
name|_historyLimit
operator|=
name|h
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* setHistoryLimitTo */
end_comment

begin_comment
comment|/* ** termHeight(). **        Accessor for the termHeight */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|termHeight
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|termHeight
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_termHeight
return|;
block|}
end_function

begin_comment
comment|/* termHeight */
end_comment

begin_comment
comment|/* ** setTermHeightTo(). **        Mutator for the term height */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|setTermHeightTo
parameter_list|(
name|int
name|h
parameter_list|)
else|#
directive|else
function|setTermHeightTo
parameter_list|(
name|h
parameter_list|)
name|int
name|h
decl_stmt|;
endif|#
directive|endif
block|{
name|_termHeight
operator|=
name|h
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* setTermHeightTo */
end_comment

begin_comment
comment|/* ** termWidth(). **        Accessor for the termWidth */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|termWidth
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|termWidth
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_termWidth
return|;
block|}
end_function

begin_comment
comment|/* termWidth */
end_comment

begin_comment
comment|/* ** setTermWidth(). **        Mutator for the termWidth */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|setTermWidthTo
parameter_list|(
name|int
name|w
parameter_list|)
else|#
directive|else
function|setTermWidthTo
parameter_list|(
name|w
parameter_list|)
name|int
name|w
decl_stmt|;
endif|#
directive|endif
block|{
name|_termWidth
operator|=
name|w
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* setTermWidthTo */
end_comment

begin_comment
comment|/* ** currentLayout(). **        Accessor for the current layout */
end_comment

begin_function
name|TuiLayoutType
ifdef|#
directive|ifdef
name|__STDC__
name|currentLayout
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|currentLayout
parameter_list|()
endif|#
directive|endif
block|{
return|return
name|_currentLayout
return|;
block|}
end_function

begin_comment
comment|/* currentLayout */
end_comment

begin_comment
comment|/* ** setCurrentLayoutTo(). **        Mutator for the current layout */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|setCurrentLayoutTo
parameter_list|(
name|TuiLayoutType
name|newLayout
parameter_list|)
else|#
directive|else
function|setCurrentLayoutTo
parameter_list|(
name|newLayout
parameter_list|)
name|TuiLayoutType
name|newLayout
decl_stmt|;
endif|#
directive|endif
block|{
name|_currentLayout
operator|=
name|newLayout
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* setCurrentLayoutTo */
end_comment

begin_comment
comment|/* ** setGenWinOrigin(). **        Set the origin of the window */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|setGenWinOrigin
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
else|#
directive|else
function|setGenWinOrigin
parameter_list|(
name|winInfo
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
endif|#
directive|endif
block|{
name|winInfo
operator|->
name|origin
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|winInfo
operator|->
name|origin
operator|.
name|y
operator|=
name|y
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* setGenWinOrigin */
end_comment

begin_comment
comment|/***************************** ** OTHER PUBLIC FUNCTIONS *****************************/
end_comment

begin_comment
comment|/* ** tuiNextWin(). **        Answer the next window in the list, cycling back to the top **        if necessary */
end_comment

begin_function
name|TuiWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|tuiNextWin
parameter_list|(
name|TuiWinInfoPtr
name|curWin
parameter_list|)
else|#
directive|else
function|tuiNextWin
parameter_list|(
name|curWin
parameter_list|)
name|TuiWinInfoPtr
name|curWin
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinType
name|type
init|=
name|curWin
operator|->
name|generic
operator|.
name|type
decl_stmt|;
name|TuiWinInfoPtr
name|nextWin
init|=
operator|(
name|TuiWinInfoPtr
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|curWin
operator|->
name|generic
operator|.
name|type
operator|==
name|CMD_WIN
condition|)
name|type
operator|=
name|SRC_WIN
expr_stmt|;
else|else
name|type
operator|=
name|curWin
operator|->
name|generic
operator|.
name|type
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|type
operator|!=
name|curWin
operator|->
name|generic
operator|.
name|type
operator|&&
name|m_winPtrIsNull
argument_list|(
name|nextWin
argument_list|)
condition|)
block|{
if|if
condition|(
name|winList
index|[
name|type
index|]
operator|->
name|generic
operator|.
name|isVisible
condition|)
name|nextWin
operator|=
name|winList
index|[
name|type
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|type
operator|==
name|CMD_WIN
condition|)
name|type
operator|=
name|SRC_WIN
expr_stmt|;
else|else
name|type
operator|++
expr_stmt|;
block|}
block|}
return|return
name|nextWin
return|;
block|}
end_function

begin_comment
comment|/* tuiNextWin */
end_comment

begin_comment
comment|/* ** tuiPrevWin(). **        Answer the prev window in the list, cycling back to the bottom **        if necessary */
end_comment

begin_function
name|TuiWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|tuiPrevWin
parameter_list|(
name|TuiWinInfoPtr
name|curWin
parameter_list|)
else|#
directive|else
function|tuiPrevWin
parameter_list|(
name|curWin
parameter_list|)
name|TuiWinInfoPtr
name|curWin
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinType
name|type
init|=
name|curWin
operator|->
name|generic
operator|.
name|type
decl_stmt|;
name|TuiWinInfoPtr
name|prev
init|=
operator|(
name|TuiWinInfoPtr
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|curWin
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
name|type
operator|=
name|CMD_WIN
expr_stmt|;
else|else
name|type
operator|=
name|curWin
operator|->
name|generic
operator|.
name|type
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|type
operator|!=
name|curWin
operator|->
name|generic
operator|.
name|type
operator|&&
name|m_winPtrIsNull
argument_list|(
name|prev
argument_list|)
condition|)
block|{
if|if
condition|(
name|winList
index|[
name|type
index|]
operator|->
name|generic
operator|.
name|isVisible
condition|)
name|prev
operator|=
name|winList
index|[
name|type
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|type
operator|==
name|SRC_WIN
condition|)
name|type
operator|=
name|CMD_WIN
expr_stmt|;
else|else
name|type
operator|--
expr_stmt|;
block|}
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* tuiPrevWin */
end_comment

begin_comment
comment|/* ** displayableWinContentOf(). **        Answer a the content at the location indicated by index.  Note **        that if this is a locator window, the string returned should be **        freed after use. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|displayableWinContentOf
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|,
name|TuiWinElementPtr
name|elementPtr
parameter_list|)
else|#
directive|else
function|displayableWinContentOf
parameter_list|(
name|winInfo
parameter_list|,
name|elementPtr
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
name|TuiWinElementPtr
name|elementPtr
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|string
init|=
name|nullStr
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementPtr
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
operator|||
name|winInfo
operator|->
name|type
operator|==
name|LOCATOR_WIN
condition|)
block|{
comment|/*         ** Now convert the line to a displayable string         */
switch|switch
condition|(
name|winInfo
operator|->
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
case|case
name|DISASSEM_WIN
case|:
name|string
operator|=
name|elementPtr
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|CMD_WIN
case|:
name|string
operator|=
name|elementPtr
operator|->
name|whichElement
operator|.
name|command
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|LOCATOR_WIN
case|:
if|if
condition|(
operator|(
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|termWidth
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|string
operator|=
name|nullStr
argument_list|()
expr_stmt|;
else|else
block|{
name|char
name|lineNo
index|[
literal|50
index|]
decl_stmt|,
name|pc
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|fname
decl_stmt|,
modifier|*
name|pname
decl_stmt|;
specifier|register
name|int
name|strSize
init|=
name|termWidth
argument_list|()
decl_stmt|,
name|i
decl_stmt|,
name|procWidth
decl_stmt|,
name|fileWidth
decl_stmt|;
comment|/*                     ** First determine the amount of file/proc name width                     ** we have available                     */
name|i
operator|=
name|strSize
operator|-
operator|(
name|PC_WIDTH
operator|+
name|LINE_WIDTH
operator|+
literal|25
comment|/* pc and line labels */
operator|+
name|strlen
argument_list|(
name|FILE_PREFIX
argument_list|)
operator|+
literal|1
comment|/* file label */
operator|+
literal|15
comment|/* procedure label */
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|FILE_WIDTH
operator|+
name|PROC_WIDTH
condition|)
block|{
name|fileWidth
operator|=
name|FILE_WIDTH
expr_stmt|;
name|procWidth
operator|=
name|PROC_WIDTH
expr_stmt|;
block|}
else|else
block|{
name|fileWidth
operator|=
name|i
operator|/
literal|2
expr_stmt|;
name|procWidth
operator|=
name|i
operator|-
name|fileWidth
expr_stmt|;
block|}
comment|/* Now convert elements to string form */
if|if
condition|(
name|elementPtr
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
operator|&&
operator|*
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|fileName
operator|!=
operator|(
name|char
operator|)
literal|0
operator|&&
name|srcWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
name|fname
operator|=
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|fileName
expr_stmt|;
else|else
name|fname
operator|=
literal|"??"
expr_stmt|;
if|if
condition|(
name|elementPtr
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
operator|&&
operator|*
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|procName
operator|!=
operator|(
name|char
operator|)
literal|0
condition|)
name|pname
operator|=
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|procName
expr_stmt|;
else|else
name|pname
operator|=
literal|"??"
expr_stmt|;
if|if
condition|(
name|elementPtr
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
operator|&&
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|lineNo
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|lineNo
argument_list|,
literal|"%d"
argument_list|,
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|lineNo
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|lineNo
argument_list|,
literal|"??"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elementPtr
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
operator|&&
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|addr
operator|>
operator|(
name|Opaque
operator|)
literal|0
condition|)
name|sprintf
argument_list|(
name|pc
argument_list|,
literal|"0x%x"
argument_list|,
name|elementPtr
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|addr
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|pc
argument_list|,
literal|"??"
argument_list|)
expr_stmt|;
comment|/*                     ** Now create the locator line from the string version                     ** of the elements.  We could use sprintf() here but                     ** that wouldn't ensure that we don't overrun the size                     ** of the allocated buffer.  strcat_to_buf() will.                     */
operator|*
name|string
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
comment|/* Filename */
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|FILE_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|>
name|fileWidth
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|fname
argument_list|,
name|fileWidth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|fileWidth
operator|-
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|buf
index|[
name|fileWidth
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* procedure/class name */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%15s"
argument_list|,
name|PROC_PREFIX
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|pname
argument_list|)
operator|>
name|procWidth
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|pname
argument_list|,
name|procWidth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|procWidth
operator|-
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|buf
index|[
name|procWidth
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%10s"
argument_list|,
name|LINE_PREFIX
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|lineNo
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%10s"
argument_list|,
name|PC_PREFIX
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|string
argument_list|,
name|strSize
argument_list|,
name|pc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
init|;
name|i
operator|<
name|strSize
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|string
index|[
name|strSize
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|EXEC_INFO_WIN
case|:
name|string
operator|=
name|elementPtr
operator|->
name|whichElement
operator|.
name|simpleString
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* displayableWinContentOf */
end_comment

begin_comment
comment|/* **    winContentAt(). **        Answer a the content at the location indicated by index */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|displayableWinContentAt
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|index
parameter_list|)
else|#
directive|else
function|displayableWinContentAt
parameter_list|(
name|winInfo
parameter_list|,
name|index
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|index
decl_stmt|;
endif|#
directive|endif
block|{
return|return
operator|(
name|displayableWinContentOf
argument_list|(
name|winInfo
argument_list|,
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|content
index|[
name|index
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* winContentAt */
end_comment

begin_comment
comment|/* ** winElementHeight(). **        Answer the height of the element in lines */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|winElementHeight
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|,
name|TuiWinElementPtr
name|element
parameter_list|)
else|#
directive|else
function|winElementHeight
parameter_list|(
name|winInfo
parameter_list|,
name|element
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
name|TuiWinElementPtr
name|element
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|h
decl_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|type
operator|==
name|DATA_WIN
condition|)
comment|/* FOR NOW SAY IT IS ONLY ONE LINE HIGH */
name|h
operator|=
literal|1
expr_stmt|;
else|else
name|h
operator|=
literal|1
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* winElementHeight */
end_comment

begin_comment
comment|/* **  winByName(). **      Answer the window represented by name */
end_comment

begin_function
name|TuiWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|winByName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
else|#
directive|else
function|winByName
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinInfoPtr
name|winInfo
init|=
operator|(
name|TuiWinInfoPtr
operator|)
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|MAX_MAJOR_WINDOWS
operator|&&
name|m_winPtrIsNull
argument_list|(
name|winInfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|winName
argument_list|(
operator|&
operator|(
name|winList
index|[
name|i
index|]
operator|->
name|generic
operator|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|winInfo
operator|=
name|winList
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|winInfo
return|;
block|}
end_function

begin_comment
comment|/* winByName */
end_comment

begin_comment
comment|/* **  partialWinByName(). **      Answer the window represented by name */
end_comment

begin_function
name|TuiWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|partialWinByName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
else|#
directive|else
function|partialWinByName
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinInfoPtr
name|winInfo
init|=
operator|(
name|TuiWinInfoPtr
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|MAX_MAJOR_WINDOWS
operator|&&
name|m_winPtrIsNull
argument_list|(
name|winInfo
argument_list|)
condition|)
block|{
name|char
modifier|*
name|curName
init|=
name|winName
argument_list|(
operator|&
name|winList
index|[
name|i
index|]
operator|->
name|generic
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<=
name|strlen
argument_list|(
name|curName
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|curName
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|winInfo
operator|=
name|winList
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
name|winInfo
return|;
block|}
end_function

begin_comment
comment|/* partialWinByName */
end_comment

begin_comment
comment|/* ** winName(). **      Answer the name of the window */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|winName
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|winName
parameter_list|(
name|winInfo
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|winInfo
operator|->
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
name|name
operator|=
name|SRC_NAME
expr_stmt|;
break|break;
case|case
name|CMD_WIN
case|:
name|name
operator|=
name|CMD_NAME
expr_stmt|;
break|break;
case|case
name|DISASSEM_WIN
case|:
name|name
operator|=
name|DISASSEM_NAME
expr_stmt|;
break|break;
case|case
name|DATA_WIN
case|:
name|name
operator|=
name|DATA_NAME
expr_stmt|;
break|break;
default|default:
name|name
operator|=
literal|""
expr_stmt|;
break|break;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* winName */
end_comment

begin_comment
comment|/* ** initializeStaticData */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|initializeStaticData
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|initializeStaticData
parameter_list|()
endif|#
directive|endif
block|{
name|initGenericPart
argument_list|(
name|sourceExecInfoWinPtr
argument_list|()
argument_list|)
expr_stmt|;
name|initGenericPart
argument_list|(
name|disassemExecInfoWinPtr
argument_list|()
argument_list|)
expr_stmt|;
name|initGenericPart
argument_list|(
name|locatorWinInfoPtr
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* initializeStaticData */
end_comment

begin_comment
comment|/* ** allocGenericWinInfo(). */
end_comment

begin_function
name|TuiGenWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|allocGenericWinInfo
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|allocGenericWinInfo
parameter_list|()
endif|#
directive|endif
block|{
name|TuiGenWinInfoPtr
name|win
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TuiGenWinInfoPtr
argument_list|)
argument_list|)
operator|)
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
name|initGenericPart
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* allocGenericWinInfo */
end_comment

begin_comment
comment|/* ** initGenericPart(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|initGenericPart
parameter_list|(
name|TuiGenWinInfoPtr
name|win
parameter_list|)
else|#
directive|else
function|initGenericPart
parameter_list|(
name|win
parameter_list|)
name|TuiGenWinInfoPtr
name|win
decl_stmt|;
endif|#
directive|endif
block|{
name|win
operator|->
name|width
operator|=
name|win
operator|->
name|height
operator|=
name|win
operator|->
name|origin
operator|.
name|x
operator|=
name|win
operator|->
name|origin
operator|.
name|y
operator|=
name|win
operator|->
name|viewportHeight
operator|=
name|win
operator|->
name|contentSize
operator|=
name|win
operator|->
name|lastVisibleLine
operator|=
literal|0
expr_stmt|;
name|win
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|win
operator|->
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|NULL
expr_stmt|;
name|win
operator|->
name|contentInUse
operator|=
name|win
operator|->
name|isVisible
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* initGenericPart */
end_comment

begin_comment
comment|/* ** initContentElement(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|initContentElement
parameter_list|(
name|TuiWinElementPtr
name|element
parameter_list|,
name|TuiWinType
name|type
parameter_list|)
else|#
directive|else
function|initContentElement
parameter_list|(
name|element
parameter_list|,
name|type
parameter_list|)
name|TuiWinElementPtr
name|element
decl_stmt|;
name|TuiWinType
name|type
decl_stmt|;
endif|#
directive|endif
block|{
name|element
operator|->
name|highlight
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
case|case
name|DISASSEM_WIN
case|:
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
operator|=
literal|0
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
operator|=
name|FALSE
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DATA_WIN
case|:
name|initGenericPart
argument_list|(
operator|&
name|element
operator|->
name|whichElement
operator|.
name|dataWindow
argument_list|)
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|dataWindow
operator|.
name|type
operator|=
name|DATA_ITEM_WIN
expr_stmt|;
operator|(
operator|(
name|TuiGenWinInfoPtr
operator|)
operator|&
name|element
operator|->
name|whichElement
operator|.
name|dataWindow
operator|)
operator|->
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|allocContent
argument_list|(
literal|1
argument_list|,
name|DATA_ITEM_WIN
argument_list|)
expr_stmt|;
operator|(
operator|(
name|TuiGenWinInfoPtr
operator|)
operator|&
name|element
operator|->
name|whichElement
operator|.
name|dataWindow
operator|)
operator|->
name|contentSize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CMD_WIN
case|:
name|element
operator|->
name|whichElement
operator|.
name|command
operator|.
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
case|case
name|DATA_ITEM_WIN
case|:
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|type
operator|=
name|TUI_REGISTER
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|itemNo
operator|=
name|UNDEFINED_ITEM
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|value
operator|=
operator|(
name|Opaque
operator|)
name|NULL
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|highlight
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOCATOR_WIN
case|:
name|element
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|fileName
index|[
literal|0
index|]
operator|=
name|element
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|procName
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|lineNo
operator|=
literal|0
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EXEC_INFO_WIN
case|:
name|element
operator|->
name|whichElement
operator|.
name|simpleString
operator|=
name|blankStr
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* initContentElement */
end_comment

begin_comment
comment|/* ** initWinInfo(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|initWinInfo
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|initWinInfo
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|initGenericPart
argument_list|(
operator|&
name|winInfo
operator|->
name|generic
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|canHighlight
operator|=
name|winInfo
operator|->
name|isHighlighted
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
case|case
name|DISASSEM_WIN
case|:
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
operator|=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|hasLocator
operator|=
name|FALSE
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|startLineOrAddr
operator|.
name|addr
operator|=
operator|(
name|Opaque
operator|)
name|NULL
expr_stmt|;
break|break;
case|case
name|DATA_WIN
case|:
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|=
name|TUI_UNDEFINED_REGS
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|=
literal|1
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|displayRegs
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|CMD_WIN
case|:
name|winInfo
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curLine
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|winInfo
operator|->
name|detail
operator|.
name|opaque
operator|=
operator|(
name|Opaque
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* initWinInfo */
end_comment

begin_comment
comment|/* ** allocWinInfo(). */
end_comment

begin_function
name|TuiWinInfoPtr
ifdef|#
directive|ifdef
name|__STDC__
name|allocWinInfo
parameter_list|(
name|TuiWinType
name|type
parameter_list|)
else|#
directive|else
function|allocWinInfo
parameter_list|(
name|type
parameter_list|)
name|TuiWinType
name|type
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinInfoPtr
name|winInfo
init|=
operator|(
name|TuiWinInfoPtr
operator|)
name|NULL
decl_stmt|;
name|winInfo
operator|=
operator|(
name|TuiWinInfoPtr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TuiWinInfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|winInfo
argument_list|)
condition|)
block|{
name|winInfo
operator|->
name|generic
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|initWinInfo
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|winInfo
return|;
block|}
end_function

begin_comment
comment|/* allocWinInfo */
end_comment

begin_comment
comment|/* ** allocContent(). **        Allocates the content and elements in a block. */
end_comment

begin_function
name|TuiWinContent
ifdef|#
directive|ifdef
name|__STDC__
name|allocContent
parameter_list|(
name|int
name|numElements
parameter_list|,
name|TuiWinType
name|type
parameter_list|)
else|#
directive|else
function|allocContent
parameter_list|(
name|numElements
parameter_list|,
name|type
parameter_list|)
name|int
name|numElements
decl_stmt|;
name|TuiWinType
name|type
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinContent
name|content
init|=
operator|(
name|TuiWinContent
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|elementBlockPtr
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|content
operator|=
operator|(
name|TuiWinContent
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TuiWinElementPtr
argument_list|)
operator|*
name|numElements
argument_list|)
operator|)
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
condition|)
block|{
comment|/*         ** All windows, except the data window, can allocate the elements         ** in a chunk.  The data window cannot because items can be         ** added/removed from the data display by the user at any time.         */
if|if
condition|(
name|type
operator|!=
name|DATA_WIN
condition|)
block|{
if|if
condition|(
operator|(
name|elementBlockPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TuiWinElement
argument_list|)
operator|*
name|numElements
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numElements
condition|;
name|i
operator|++
control|)
block|{
name|content
index|[
name|i
index|]
operator|=
operator|(
name|TuiWinElementPtr
operator|)
name|elementBlockPtr
expr_stmt|;
name|initContentElement
argument_list|(
name|content
index|[
name|i
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|elementBlockPtr
operator|+=
sizeof|sizeof
argument_list|(
name|TuiWinElement
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|content
argument_list|)
expr_stmt|;
name|content
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
name|content
return|;
block|}
end_function

begin_comment
comment|/* allocContent */
end_comment

begin_comment
comment|/* ** addContentElements(). **        Adds the input number of elements to the windows's content.  If **        no content has been allocated yet, allocContent() is called to **        do this.  The index of the first element added is returned, **        unless there is a memory allocation error, in which case, (-1) **        is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|addContentElements
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|numElements
parameter_list|)
else|#
directive|else
function|addContentElements
parameter_list|(
name|winInfo
parameter_list|,
name|numElements
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|numElements
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiWinElementPtr
name|elementPtr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|indexStart
decl_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|content
operator|==
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|winInfo
operator|->
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|allocContent
argument_list|(
name|numElements
argument_list|,
name|winInfo
operator|->
name|type
argument_list|)
expr_stmt|;
name|indexStart
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|indexStart
operator|=
name|winInfo
operator|->
name|contentSize
expr_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|indexStart
init|;
operator|(
name|i
operator|<
name|numElements
operator|+
name|indexStart
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|elementPtr
operator|=
operator|(
name|TuiWinElementPtr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TuiWinElement
argument_list|)
argument_list|)
operator|)
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
condition|)
block|{
name|winInfo
operator|->
name|content
index|[
name|i
index|]
operator|=
operator|(
name|Opaque
operator|)
name|elementPtr
expr_stmt|;
name|initContentElement
argument_list|(
name|elementPtr
argument_list|,
name|winInfo
operator|->
name|type
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|contentSize
operator|++
expr_stmt|;
block|}
else|else
comment|/* things must be really hosed now! We ran out of memory!?*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
name|indexStart
return|;
block|}
end_function

begin_comment
comment|/* addContentElements */
end_comment

begin_comment
comment|/* **  tuiDelWindow(). **     Delete all curses windows associated with winInfo, leaving everything **     else in tact. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDelWindow
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiDelWindow
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|Opaque
name|detail
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TuiGenWinInfoPtr
name|genericWin
decl_stmt|;
switch|switch
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
case|case
name|DISASSEM_WIN
case|:
name|genericWin
operator|=
name|locatorWinInfoPtr
argument_list|()
expr_stmt|;
if|if
condition|(
name|genericWin
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|genericWin
operator|->
name|handle
argument_list|)
expr_stmt|;
name|genericWin
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|genericWin
operator|->
name|isVisible
operator|=
name|FALSE
expr_stmt|;
block|}
name|genericWin
operator|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
expr_stmt|;
if|if
condition|(
name|genericWin
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|genericWin
operator|->
name|handle
argument_list|)
expr_stmt|;
name|genericWin
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|genericWin
operator|->
name|isVisible
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|DATA_WIN
case|:
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tuiDelDataWindows
argument_list|(
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
argument_list|,
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
argument_list|)
expr_stmt|;
name|tuiDelDataWindows
argument_list|(
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
argument_list|,
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|isVisible
operator|=
name|FALSE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDelWindow */
end_comment

begin_comment
comment|/* **  freeWindow(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeWindow
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|freeWindow
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|Opaque
name|detail
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TuiGenWinInfoPtr
name|genericWin
decl_stmt|;
switch|switch
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
condition|)
block|{
case|case
name|SRC_WIN
case|:
case|case
name|DISASSEM_WIN
case|:
name|genericWin
operator|=
name|locatorWinInfoPtr
argument_list|()
expr_stmt|;
if|if
condition|(
name|genericWin
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|genericWin
operator|->
name|handle
argument_list|)
expr_stmt|;
name|genericWin
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|freeWinContent
argument_list|(
name|genericWin
argument_list|)
expr_stmt|;
name|genericWin
operator|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
expr_stmt|;
if|if
condition|(
name|genericWin
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|genericWin
operator|->
name|handle
argument_list|)
expr_stmt|;
name|genericWin
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|freeWinContent
argument_list|(
name|genericWin
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DATA_WIN
case|:
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|freeDataContent
argument_list|(
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
argument_list|,
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
operator|=
literal|0
expr_stmt|;
name|freeDataContent
argument_list|(
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
argument_list|,
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
operator|=
operator|(
name|TuiWinContent
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|=
literal|0
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsDisplayType
operator|=
name|TUI_UNDEFINED_REGS
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsColumnCount
operator|=
literal|1
expr_stmt|;
name|winInfo
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|displayRegs
operator|=
name|FALSE
expr_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|NULL
expr_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|freeWinContent
argument_list|(
operator|&
name|winInfo
operator|->
name|generic
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* freeWindow */
end_comment

begin_comment
comment|/* ** freeAllSourceWinsContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeAllSourceWinsContent
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|freeAllSourceWinsContent
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|TuiWinInfoPtr
name|winInfo
init|=
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|winInfo
argument_list|)
condition|)
block|{
name|freeWinContent
argument_list|(
operator|&
operator|(
name|winInfo
operator|->
name|generic
operator|)
argument_list|)
expr_stmt|;
name|freeWinContent
argument_list|(
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* freeAllSourceWinsContent */
end_comment

begin_comment
comment|/* ** freeWinContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeWinContent
parameter_list|(
name|TuiGenWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|freeWinContent
parameter_list|(
name|winInfo
parameter_list|)
name|TuiGenWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|winInfo
operator|->
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|freeContent
argument_list|(
operator|(
name|TuiWinContent
operator|)
name|winInfo
operator|->
name|content
argument_list|,
name|winInfo
operator|->
name|contentSize
argument_list|,
name|winInfo
operator|->
name|type
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|NULL
expr_stmt|;
block|}
name|winInfo
operator|->
name|contentSize
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* freeWinContent */
end_comment

begin_comment
comment|/* ** freeAllWindows(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeAllWindows
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|freeAllWindows
parameter_list|()
endif|#
directive|endif
block|{
name|TuiWinType
name|type
init|=
name|SRC_WIN
decl_stmt|;
for|for
control|(
init|;
name|type
operator|<
name|MAX_MAJOR_WINDOWS
condition|;
name|type
operator|++
control|)
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|winList
index|[
name|type
index|]
argument_list|)
operator|&&
name|winList
index|[
name|type
index|]
operator|->
name|generic
operator|.
name|type
operator|!=
name|UNDEFINED_WIN
condition|)
name|freeWindow
argument_list|(
name|winList
index|[
name|type
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* freeAllWindows */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDelDataWindows
parameter_list|(
name|TuiWinContent
name|content
parameter_list|,
name|int
name|contentSize
parameter_list|)
else|#
directive|else
function|tuiDelDataWindows
parameter_list|(
name|content
parameter_list|,
name|contentSize
parameter_list|)
name|TuiWinContent
name|content
decl_stmt|;
name|int
name|contentSize
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
comment|/*     ** Remember that data window content elements are of type TuiGenWinInfoPtr,     ** each of which whose single element is a data element.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|contentSize
condition|;
name|i
operator|++
control|)
block|{
name|TuiGenWinInfoPtr
name|genericWin
init|=
operator|&
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
decl_stmt|;
if|if
condition|(
name|genericWin
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|genericWin
operator|->
name|handle
argument_list|)
expr_stmt|;
name|genericWin
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|genericWin
operator|->
name|isVisible
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDelDataWindows */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeDataContent
parameter_list|(
name|TuiWinContent
name|content
parameter_list|,
name|int
name|contentSize
parameter_list|)
else|#
directive|else
function|freeDataContent
parameter_list|(
name|content
parameter_list|,
name|contentSize
parameter_list|)
name|TuiWinContent
name|content
decl_stmt|;
name|int
name|contentSize
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
comment|/*     ** Remember that data window content elements are of type TuiGenWinInfoPtr,     ** each of which whose single element is a data element.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|contentSize
condition|;
name|i
operator|++
control|)
block|{
name|TuiGenWinInfoPtr
name|genericWin
init|=
operator|&
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
decl_stmt|;
if|if
condition|(
name|genericWin
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|tuiDelwin
argument_list|(
name|genericWin
operator|->
name|handle
argument_list|)
expr_stmt|;
name|genericWin
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|freeWinContent
argument_list|(
name|genericWin
argument_list|)
expr_stmt|;
block|}
block|}
name|freeContent
argument_list|(
name|content
argument_list|,
name|contentSize
argument_list|,
name|DATA_WIN
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* freeDataContent */
end_comment

begin_comment
comment|/********************************** ** LOCAL STATIC FUNCTIONS        ** **********************************/
end_comment

begin_comment
comment|/* ** freeContent(). */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeContent
parameter_list|(
name|TuiWinContent
name|content
parameter_list|,
name|int
name|contentSize
parameter_list|,
name|TuiWinType
name|winType
parameter_list|)
else|#
directive|else
function|freeContent
parameter_list|(
name|content
parameter_list|,
name|contentSize
parameter_list|,
name|winType
parameter_list|)
name|TuiWinContent
name|content
decl_stmt|;
name|int
name|contentSize
decl_stmt|;
name|TuiWinType
name|winType
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|content
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
condition|)
block|{
name|freeContentElements
argument_list|(
name|content
argument_list|,
name|contentSize
argument_list|,
name|winType
argument_list|)
expr_stmt|;
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|content
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* freeContent */
end_comment

begin_comment
comment|/* ** freeContentElements(). */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|freeContentElements
parameter_list|(
name|TuiWinContent
name|content
parameter_list|,
name|int
name|contentSize
parameter_list|,
name|TuiWinType
name|type
parameter_list|)
else|#
directive|else
function|freeContentElements
parameter_list|(
name|content
parameter_list|,
name|contentSize
parameter_list|,
name|type
parameter_list|)
name|TuiWinContent
name|content
decl_stmt|;
name|int
name|contentSize
decl_stmt|;
name|TuiWinType
name|type
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|content
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SRC_WIN
operator|||
name|type
operator|==
name|DISASSEM_WIN
condition|)
block|{
comment|/* free whole source block */
if|if
condition|(
name|content
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|tuiFree
argument_list|(
name|content
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|contentSize
condition|;
name|i
operator|++
control|)
block|{
name|TuiWinElementPtr
name|element
decl_stmt|;
name|element
operator|=
name|content
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|element
operator|!=
operator|(
name|TuiWinElementPtr
operator|)
name|NULL
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_WIN
case|:
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|element
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_ITEM_WIN
case|:
comment|/*                             ** Note that data elements are not allocated                             ** in a single block, but individually, as needed.                             */
if|if
condition|(
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|type
operator|!=
name|TUI_REGISTER
condition|)
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|name
argument_list|)
expr_stmt|;
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|element
operator|->
name|whichElement
operator|.
name|data
operator|.
name|value
argument_list|)
expr_stmt|;
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|element
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_WIN
case|:
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|element
operator|->
name|whichElement
operator|.
name|command
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|type
operator|!=
name|DATA_WIN
operator|&&
name|type
operator|!=
name|DATA_ITEM_WIN
condition|)
name|tuiFree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|content
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* free the element block */
block|}
return|return;
block|}
end_function

begin_comment
comment|/* freeContentElements */
end_comment

end_unit

