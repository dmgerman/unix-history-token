begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* UI_FILE - a generic STDIO like output stream.    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"ui-file.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-file.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-io.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* A ``struct ui_file'' that is compatible with all the legacy    code. */
end_comment

begin_comment
comment|/* new */
end_comment

begin_enum
enum|enum
name|streamtype
block|{
name|afile
block|,
name|astring
block|}
enum|;
end_enum

begin_comment
comment|/* new */
end_comment

begin_struct
struct|struct
name|tui_stream
block|{
name|int
modifier|*
name|ts_magic
decl_stmt|;
name|enum
name|streamtype
name|ts_streamtype
decl_stmt|;
name|FILE
modifier|*
name|ts_filestream
decl_stmt|;
name|char
modifier|*
name|ts_strbuf
decl_stmt|;
name|int
name|ts_buflen
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|ui_file_flush_ftype
name|tui_file_flush
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ui_file_fputs_ftype
name|tui_file_fputs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ui_file_isatty_ftype
name|tui_file_isatty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ui_file_rewind_ftype
name|tui_file_rewind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ui_file_put_ftype
name|tui_file_put
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ui_file_delete_ftype
name|tui_file_delete
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|ui_file
modifier|*
name|tui_file_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|tui_file_magic
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|ui_file
modifier|*
name|tui_file_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|tui
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tui_stream
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|file
init|=
name|ui_file_new
argument_list|()
decl_stmt|;
name|set_ui_file_data
argument_list|(
name|file
argument_list|,
name|tui
argument_list|,
name|tui_file_delete
argument_list|)
expr_stmt|;
name|set_ui_file_flush
argument_list|(
name|file
argument_list|,
name|tui_file_flush
argument_list|)
expr_stmt|;
name|set_ui_file_fputs
argument_list|(
name|file
argument_list|,
name|tui_file_fputs
argument_list|)
expr_stmt|;
name|set_ui_file_isatty
argument_list|(
name|file
argument_list|,
name|tui_file_isatty
argument_list|)
expr_stmt|;
name|set_ui_file_rewind
argument_list|(
name|file
argument_list|,
name|tui_file_rewind
argument_list|)
expr_stmt|;
name|set_ui_file_put
argument_list|(
name|file
argument_list|,
name|tui_file_put
argument_list|)
expr_stmt|;
name|tui
operator|->
name|ts_magic
operator|=
operator|&
name|tui_file_magic
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_file_delete
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|tmpstream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpstream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_delete: bad magic number"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstream
operator|->
name|ts_streamtype
operator|==
name|astring
operator|)
operator|&&
operator|(
name|tmpstream
operator|->
name|ts_strbuf
operator|!=
name|NULL
operator|)
condition|)
block|{
name|xfree
argument_list|(
name|tmpstream
operator|->
name|ts_strbuf
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|tmpstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ui_file
modifier|*
name|tui_fileopen
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|file
init|=
name|tui_file_new
argument_list|()
decl_stmt|;
name|struct
name|tui_stream
modifier|*
name|tmpstream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|tmpstream
operator|->
name|ts_streamtype
operator|=
name|afile
expr_stmt|;
name|tmpstream
operator|->
name|ts_filestream
operator|=
name|stream
expr_stmt|;
name|tmpstream
operator|->
name|ts_strbuf
operator|=
name|NULL
expr_stmt|;
name|tmpstream
operator|->
name|ts_buflen
operator|=
literal|0
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
name|struct
name|ui_file
modifier|*
name|tui_sfileopen
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|file
init|=
name|tui_file_new
argument_list|()
decl_stmt|;
name|struct
name|tui_stream
modifier|*
name|tmpstream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|tmpstream
operator|->
name|ts_streamtype
operator|=
name|astring
expr_stmt|;
name|tmpstream
operator|->
name|ts_filestream
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|tmpstream
operator|->
name|ts_strbuf
operator|=
name|xmalloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|tmpstream
operator|->
name|ts_strbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* Do not allocate the buffer now.  The first time something is printed        one will be allocated by tui_file_adjust_strbuf()  */
name|tmpstream
operator|->
name|ts_strbuf
operator|=
name|NULL
expr_stmt|;
name|tmpstream
operator|->
name|ts_buflen
operator|=
name|n
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tui_file_isatty
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_isatty: bad magic number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|afile
condition|)
return|return
operator|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stream
operator|->
name|ts_filestream
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_file_rewind
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_rewind: bad magic number"
argument_list|)
expr_stmt|;
name|stream
operator|->
name|ts_strbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_file_put
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|ui_file_put_method_ftype
modifier|*
name|write
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_put: bad magic number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|astring
condition|)
name|write
argument_list|(
name|dest
argument_list|,
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|strlen
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All TUI I/O sent to the *_filtered and *_unfiltered functions    eventually ends up here.  The fputs_unfiltered_hook is primarily    used by GUIs to collect all output and send it to the GUI, instead    of the controlling terminal.  Only output to gdb_stdout and    gdb_stderr are sent to the hook.  Everything else is sent on to    fputs to allow file I/O to be handled appropriately.  */
end_comment

begin_comment
comment|/* FIXME: Should be broken up and moved to a TUI specific file. */
end_comment

begin_function
name|void
name|tui_file_fputs
parameter_list|(
specifier|const
name|char
modifier|*
name|linebuffer
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|astring
condition|)
block|{
name|tui_file_adjust_strbuf
argument_list|(
name|strlen
argument_list|(
name|linebuffer
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tui_puts
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|tui_file_get_strbuf
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_get_strbuf: bad magic number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|stream
operator|->
name|ts_strbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* adjust the length of the buffer by the amount necessary    to accomodate appending a string of length N to the buffer contents */
end_comment

begin_function
name|void
name|tui_file_adjust_strbuf
parameter_list|(
name|int
name|n
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|int
name|non_null_chars
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_adjust_strbuf: bad magic number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|!=
name|astring
condition|)
return|return;
if|if
condition|(
name|stream
operator|->
name|ts_strbuf
condition|)
block|{
comment|/* There is already a buffer allocated */
name|non_null_chars
operator|=
name|strlen
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
name|stream
operator|->
name|ts_buflen
operator|-
name|non_null_chars
operator|-
literal|1
operator|)
condition|)
block|{
name|stream
operator|->
name|ts_buflen
operator|=
name|n
operator|+
name|non_null_chars
operator|+
literal|1
expr_stmt|;
name|stream
operator|->
name|ts_strbuf
operator|=
name|xrealloc
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|stream
operator|->
name|ts_buflen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* No buffer yet, so allocate one of the desired size */
name|stream
operator|->
name|ts_strbuf
operator|=
name|xmalloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_file_flush
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|tui_stream
modifier|*
name|stream
init|=
name|ui_file_data
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|ts_magic
operator|!=
operator|&
name|tui_file_magic
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"tui_file_flush: bad magic number"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stream
operator|->
name|ts_streamtype
condition|)
block|{
case|case
name|astring
case|:
break|break;
case|case
name|afile
case|:
name|fflush
argument_list|(
name|stream
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

