begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** tuiSourceWin.c **         This module contains functions for displaying source or assembly in the "source" window. *        The "source" window may be the assembly or the source windows. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"tuiStack.h"
end_include

begin_include
include|#
directive|include
file|"tuiSourceWin.h"
end_include

begin_include
include|#
directive|include
file|"tuiSource.h"
end_include

begin_include
include|#
directive|include
file|"tuiDisassem.h"
end_include

begin_comment
comment|/***************************************** ** EXTERNAL FUNCTION DECLS                ** ******************************************/
end_comment

begin_comment
comment|/***************************************** ** EXTERNAL DATA DECLS                    ** ******************************************/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|current_source_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|symtab
modifier|*
name|current_source_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS FORWARD DECLS    ** ******************************************/
end_comment

begin_comment
comment|/***************************************** ** STATIC LOCAL DATA                    ** ******************************************/
end_comment

begin_comment
comment|/***************************************** ** PUBLIC FUNCTIONS                        ** ******************************************/
end_comment

begin_comment
comment|/********************************* ** SOURCE/DISASSEM  FUNCTIONS    ** *********************************/
end_comment

begin_comment
comment|/* ** tuiSrcWinIsDisplayed(). */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSrcWinIsDisplayed
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiSrcWinIsDisplayed
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|(
name|m_winPtrNotNull
argument_list|(
name|srcWin
argument_list|)
operator|&&
name|srcWin
operator|->
name|generic
operator|.
name|isVisible
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiSrcWinIsDisplayed */
end_comment

begin_comment
comment|/* ** tuiAsmWinIsDisplayed(). */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiAsmWinIsDisplayed
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiAsmWinIsDisplayed
parameter_list|()
endif|#
directive|endif
block|{
return|return
operator|(
name|m_winPtrNotNull
argument_list|(
name|disassemWin
argument_list|)
operator|&&
name|disassemWin
operator|->
name|generic
operator|.
name|isVisible
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tuiAsmWinIsDisplayed */
end_comment

begin_comment
comment|/* ** tuiDisplayMainFunction(). **        Function to display the "main" routine" */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayMainFunction
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiDisplayMainFunction
parameter_list|()
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<=
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
literal|"MAIN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|tuiUpdateSourceWindowsWithAddr
argument_list|(
operator|(
name|Opaque
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tuiSwitchFilename
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDisplayMainFunction */
end_comment

begin_comment
comment|/* ** tuiUpdateSourceWindow(). **    Function to display source in the source window.  This function **    initializes the horizontal scroll to 0. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateSourceWindow
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|Opaque
name|lineOrAddr
parameter_list|,
name|int
name|noerror
parameter_list|)
else|#
directive|else
function|tuiUpdateSourceWindow
parameter_list|(
name|winInfo
parameter_list|,
name|s
parameter_list|,
name|lineOrAddr
parameter_list|,
name|noerror
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|Opaque
name|lineOrAddr
decl_stmt|;
name|int
name|noerror
decl_stmt|;
endif|#
directive|endif
block|{
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
operator|=
literal|0
expr_stmt|;
name|tuiUpdateSourceWindowAsIs
argument_list|(
name|winInfo
argument_list|,
name|s
argument_list|,
name|lineOrAddr
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiUpdateSourceWindow */
end_comment

begin_comment
comment|/* ** tuiUpdateSourceWindowAsIs(). **        Function to display source in the source/asm window.  This **        function shows the source as specified by the horizontal offset. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateSourceWindowAsIs
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|Opaque
name|lineOrAddr
parameter_list|,
name|int
name|noerror
parameter_list|)
else|#
directive|else
function|tuiUpdateSourceWindowAsIs
parameter_list|(
name|winInfo
parameter_list|,
name|s
parameter_list|,
name|lineOrAddr
parameter_list|,
name|noerror
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|Opaque
name|lineOrAddr
decl_stmt|;
name|int
name|noerror
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
decl_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
name|ret
operator|=
name|tuiSetSourceContent
argument_list|(
name|s
argument_list|,
operator|(
name|int
operator|)
name|lineOrAddr
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|tuiSetDisassemContent
argument_list|(
name|s
argument_list|,
operator|(
name|Opaque
operator|)
name|lineOrAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|TUI_FAILURE
condition|)
block|{
name|tuiClearSourceContent
argument_list|(
name|winInfo
argument_list|,
name|EMPTY_SOURCE_PROMPT
argument_list|)
expr_stmt|;
name|tuiClearExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tuiEraseSourceContent
argument_list|(
name|winInfo
argument_list|,
name|NO_EMPTY_SOURCE_PROMPT
argument_list|)
expr_stmt|;
name|tuiShowSourceContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
name|tuiUpdateExecInfo
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
block|{
name|current_source_line
operator|=
operator|(
name|int
operator|)
name|lineOrAddr
operator|+
operator|(
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
operator|-
literal|2
operator|)
expr_stmt|;
name|current_source_symtab
operator|=
name|s
expr_stmt|;
comment|/*             ** If the focus was in the asm win, put it in the src             ** win if we don't have a split layout             */
if|if
condition|(
name|tuiWinWithFocus
argument_list|()
operator|==
name|disassemWin
operator|&&
name|currentLayout
argument_list|()
operator|!=
name|SRC_DISASSEM_COMMAND
condition|)
name|tuiSetWinFocusTo
argument_list|(
name|srcWin
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiUpdateSourceWindowAsIs */
end_comment

begin_comment
comment|/* ** tuiUpdateSourceWindowsWithAddr(). **        Function to ensure that the source and/or disassemly windows **        reflect the input address. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateSourceWindowsWithAddr
parameter_list|(
name|Opaque
name|addr
parameter_list|)
else|#
directive|else
function|tuiUpdateSourceWindowsWithAddr
parameter_list|(
name|addr
parameter_list|)
name|Opaque
name|addr
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|addr
operator|>
operator|(
name|Opaque
operator|)
name|NULL
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
switch|switch
condition|(
name|currentLayout
argument_list|()
condition|)
block|{
case|case
name|DISASSEM_COMMAND
case|:
case|case
name|DISASSEM_DATA_COMMAND
case|:
name|tuiShowDisassem
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRC_DISASSEM_COMMAND
case|:
name|tuiShowDisassemAndUpdateSource
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sal
operator|=
name|find_pc_line
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tuiShowSource
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
operator|(
name|Opaque
operator|)
name|sal
operator|.
name|line
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|TuiWinInfoPtr
name|winInfo
init|=
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
name|tuiClearSourceContent
argument_list|(
name|winInfo
argument_list|,
name|EMPTY_SOURCE_PROMPT
argument_list|)
expr_stmt|;
name|tuiClearExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiUpdateSourceWindowsWithAddr */
end_comment

begin_comment
comment|/* ** tui_vUpdateSourceWindowsWithAddr() **        Update the source window with the address in a va_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vUpdateSourceWindowsWithAddr
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vUpdateSourceWindowsWithAddr
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|Opaque
name|addr
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|Opaque
argument_list|)
decl_stmt|;
name|tuiUpdateSourceWindowsWithAddr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tui_vUpdateSourceWindowsWithAddr */
end_comment

begin_comment
comment|/* ** tuiUpdateSourceWindowsWithLine(). **        Function to ensure that the source and/or disassemly windows **        reflect the input address. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateSourceWindowsWithLine
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|tuiUpdateSourceWindowsWithLine
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
endif|#
directive|endif
block|{
switch|switch
condition|(
name|currentLayout
argument_list|()
condition|)
block|{
case|case
name|DISASSEM_COMMAND
case|:
case|case
name|DISASSEM_DATA_COMMAND
case|:
name|tuiUpdateSourceWindowsWithAddr
argument_list|(
operator|(
name|Opaque
operator|)
name|find_line_pc
argument_list|(
name|s
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tuiShowSource
argument_list|(
name|s
argument_list|,
operator|(
name|Opaque
operator|)
name|line
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentLayout
argument_list|()
operator|==
name|SRC_DISASSEM_COMMAND
condition|)
name|tuiShowDisassem
argument_list|(
operator|(
name|Opaque
operator|)
name|find_line_pc
argument_list|(
name|s
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiUpdateSourceWindowsWithLine */
end_comment

begin_comment
comment|/* ** tui_vUpdateSourceWindowsWithLine() **        Update the source window with the line number in a va_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vUpdateSourceWindowsWithLine
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vUpdateSourceWindowsWithLine
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
expr|struct
name|symtab
operator|*
argument_list|)
decl_stmt|;
name|int
name|line
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|tuiUpdateSourceWindowsWithLine
argument_list|(
name|s
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tui_vUpdateSourceWindowsWithLine */
end_comment

begin_comment
comment|/* ** tuiClearSourceContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiClearSourceContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|displayPrompt
parameter_list|)
else|#
directive|else
function|tuiClearSourceContent
parameter_list|(
name|winInfo
parameter_list|,
name|displayPrompt
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|displayPrompt
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|winInfo
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|contentInUse
operator|=
name|FALSE
expr_stmt|;
name|tuiEraseSourceContent
argument_list|(
name|winInfo
argument_list|,
name|displayPrompt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
condition|;
name|i
operator|++
control|)
block|{
name|TuiWinElementPtr
name|element
init|=
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
decl_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|=
name|FALSE
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiClearSourceContent */
end_comment

begin_comment
comment|/* ** tuiClearAllSourceWinsContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiClearAllSourceWinsContent
parameter_list|(
name|int
name|displayPrompt
parameter_list|)
else|#
directive|else
function|tuiClearAllSourceWinsContent
parameter_list|(
name|displayPrompt
parameter_list|)
name|int
name|displayPrompt
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiClearSourceContent
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|,
name|displayPrompt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiClearAllSourceWinsContent */
end_comment

begin_comment
comment|/* ** tuiEraseSourceContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiEraseSourceContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|displayPrompt
parameter_list|)
else|#
directive|else
function|tuiEraseSourceContent
parameter_list|(
name|winInfo
parameter_list|,
name|displayPrompt
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|displayPrompt
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|xPos
decl_stmt|;
name|int
name|halfWidth
init|=
operator|(
name|winInfo
operator|->
name|generic
operator|.
name|width
operator|-
literal|2
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|werase
argument_list|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|checkAndDisplayHighlightIfNeeded
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|displayPrompt
operator|==
name|EMPTY_SOURCE_PROMPT
condition|)
block|{
name|char
modifier|*
name|noSrcStr
decl_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
name|noSrcStr
operator|=
name|NO_SRC_STRING
expr_stmt|;
else|else
name|noSrcStr
operator|=
name|NO_DISASSEM_STRING
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|noSrcStr
argument_list|)
operator|>=
name|halfWidth
condition|)
name|xPos
operator|=
literal|1
expr_stmt|;
else|else
name|xPos
operator|=
name|halfWidth
operator|-
name|strlen
argument_list|(
name|noSrcStr
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
argument_list|,
operator|(
name|winInfo
operator|->
name|generic
operator|.
name|height
operator|/
literal|2
operator|)
argument_list|,
name|xPos
argument_list|,
name|noSrcStr
argument_list|)
expr_stmt|;
comment|/* elz: added this function call to set the real contents of                    the window to what is on the  screen, so that later calls                    to refresh, do display                    the correct stuff, and not the old image */
name|tuiSetSourceContentNil
argument_list|(
name|winInfo
argument_list|,
name|noSrcStr
argument_list|)
expr_stmt|;
block|}
name|tuiRefreshWin
argument_list|(
operator|&
name|winInfo
operator|->
name|generic
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiEraseSourceContent */
end_comment

begin_comment
comment|/* ** tuiEraseAllSourceContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiEraseAllSourceWinsContent
parameter_list|(
name|int
name|displayPrompt
parameter_list|)
else|#
directive|else
function|tuiEraseAllSourceWinsContent
parameter_list|(
name|displayPrompt
parameter_list|)
name|int
name|displayPrompt
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiEraseSourceContent
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|,
name|displayPrompt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiEraseAllSourceWinsContent */
end_comment

begin_comment
comment|/* ** tuiShowSourceContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowSourceContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiShowSourceContent
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|curLine
decl_stmt|,
name|i
decl_stmt|,
name|curX
decl_stmt|;
name|tuiEraseSourceContent
argument_list|(
name|winInfo
argument_list|,
operator|(
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
operator|<=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
for|for
control|(
name|curLine
operator|=
literal|1
init|;
operator|(
name|curLine
operator|<=
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
operator|)
condition|;
name|curLine
operator|++
control|)
name|mvwaddstr
argument_list|(
name|winInfo
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|curLine
argument_list|,
literal|1
argument_list|,
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
name|curLine
operator|-
literal|1
index|]
operator|)
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
name|checkAndDisplayHighlightIfNeeded
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
name|tuiRefreshWin
argument_list|(
operator|&
name|winInfo
operator|->
name|generic
argument_list|)
expr_stmt|;
name|winInfo
operator|->
name|generic
operator|.
name|contentInUse
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowSourceContent */
end_comment

begin_comment
comment|/* ** tuiShowAllSourceWinsContent() */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowAllSourceWinsContent
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiShowAllSourceWinsContent
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiShowSourceContent
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowAllSourceWinsContent */
end_comment

begin_comment
comment|/* ** tuiHorizontalSourceScroll(). **      Scroll the source forward or backward horizontally */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiHorizontalSourceScroll
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|TuiScrollDirection
name|direction
parameter_list|,
name|int
name|numToScroll
parameter_list|)
else|#
directive|else
function|tuiHorizontalSourceScroll
parameter_list|(
name|winInfo
parameter_list|,
name|direction
parameter_list|,
name|numToScroll
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|TuiScrollDirection
name|direction
decl_stmt|;
name|int
name|numToScroll
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
condition|)
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|selected_frame
operator|->
name|pc
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|current_source_symtab
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|LEFT_SCROLL
condition|)
name|offset
operator|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
operator|+
name|numToScroll
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|offset
operator|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
operator|-
name|numToScroll
operator|)
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
operator|=
name|offset
expr_stmt|;
name|tuiUpdateSourceWindowAsIs
argument_list|(
name|winInfo
argument_list|,
name|s
argument_list|,
operator|(
operator|(
name|winInfo
operator|==
name|srcWin
operator|)
condition|?
call|(
name|Opaque
call|)
argument_list|(
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
literal|0
index|]
argument_list|)
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
else|:
call|(
name|Opaque
call|)
argument_list|(
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
literal|0
index|]
argument_list|)
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
operator|)
argument_list|,
operator|(
name|int
operator|)
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiHorizontalSourceScroll */
end_comment

begin_comment
comment|/* ** tuiSetHasExecPointAt(). **        Set or clear the hasBreak flag in the line whose line is lineNo. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetIsExecPointAt
parameter_list|(
name|Opaque
name|lineOrAddr
parameter_list|,
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiSetIsExecPointAt
parameter_list|(
name|lineOrAddr
parameter_list|,
name|winInfo
parameter_list|)
name|Opaque
name|lineOrAddr
decl_stmt|;
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|TuiWinContent
name|content
init|=
operator|(
name|TuiWinContent
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
condition|)
block|{
if|if
condition|(
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
operator|==
name|lineOrAddr
condition|)
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
operator|=
name|TRUE
expr_stmt|;
else|else
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
operator|=
name|FALSE
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiSetIsExecPointAt */
end_comment

begin_comment
comment|/* ** tuiSetHasBreakAt(). **        Set or clear the hasBreak flag in the line whose line is lineNo. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetHasBreakAt
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bp
parameter_list|,
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|hasBreak
parameter_list|)
else|#
directive|else
function|tuiSetHasBreakAt
parameter_list|(
name|bp
parameter_list|,
name|winInfo
parameter_list|,
name|hasBreak
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bp
decl_stmt|;
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|hasBreak
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|TuiWinContent
name|content
init|=
operator|(
name|TuiWinContent
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
condition|)
block|{
name|int
name|gotIt
decl_stmt|;
name|TuiGenWinInfoPtr
name|locator
init|=
name|locatorWinInfoPtr
argument_list|()
decl_stmt|;
if|if
condition|(
name|winInfo
operator|==
name|srcWin
condition|)
block|{
name|char
modifier|*
name|fileNameDisplayed
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|fileName
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|fileNameDisplayed
operator|=
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|fileName
expr_stmt|;
elseif|else
if|if
condition|(
name|current_source_symtab
operator|!=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
condition|)
name|fileNameDisplayed
operator|=
name|current_source_symtab
operator|->
name|filename
expr_stmt|;
name|gotIt
operator|=
operator|(
name|fileNameDisplayed
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|bp
operator|->
name|source_file
argument_list|,
name|fileNameDisplayed
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
operator|==
name|bp
operator|->
name|line_number
operator|)
expr_stmt|;
block|}
else|else
name|gotIt
operator|=
operator|(
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
operator|==
operator|(
name|Opaque
operator|)
name|bp
operator|->
name|address
operator|)
expr_stmt|;
if|if
condition|(
name|gotIt
condition|)
block|{
name|content
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|=
name|hasBreak
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiSetHasBreakAt */
end_comment

begin_comment
comment|/* ** tuiAllSetHasBreakAt(). **        Set or clear the hasBreak flag in all displayed source windows. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiAllSetHasBreakAt
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bp
parameter_list|,
name|int
name|hasBreak
parameter_list|)
else|#
directive|else
function|tuiAllSetHasBreakAt
parameter_list|(
name|bp
parameter_list|,
name|hasBreak
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bp
decl_stmt|;
name|int
name|hasBreak
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiSetHasBreakAt
argument_list|(
name|bp
argument_list|,
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|,
name|hasBreak
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiAllSetHasBreakAt */
end_comment

begin_comment
comment|/* ** tui_vAllSetHasBreakAt() **        Set or clear the hasBreak flag in all displayed source windows, **        with params in a va_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vAllSetHasBreakAt
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vAllSetHasBreakAt
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|breakpoint
modifier|*
name|bp
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
expr|struct
name|breakpoint
operator|*
argument_list|)
decl_stmt|;
name|int
name|hasBreak
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|tuiAllSetHasBreakAt
argument_list|(
name|bp
argument_list|,
name|hasBreak
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tui_vAllSetHasBreakAt */
end_comment

begin_comment
comment|/********************************* ** EXECUTION INFO FUNCTIONS        ** *********************************/
end_comment

begin_comment
comment|/* ** tuiSetExecInfoContent(). **      Function to initialize the content of the execution info window, **      based upon the input window which is either the source or **      disassembly window. */
end_comment

begin_function
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetExecInfoContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiSetExecInfoContent
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_SUCCESS
decl_stmt|;
if|if
condition|(
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
operator|!=
operator|(
name|TuiGenWinInfoPtr
operator|)
name|NULL
condition|)
block|{
name|TuiGenWinInfoPtr
name|execInfoPtr
init|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
decl_stmt|;
if|if
condition|(
name|execInfoPtr
operator|->
name|content
operator|==
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
name|execInfoPtr
operator|->
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|allocContent
argument_list|(
name|winInfo
operator|->
name|generic
operator|.
name|height
argument_list|,
name|execInfoPtr
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|execInfoPtr
operator|->
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
condition|;
name|i
operator|++
control|)
block|{
name|TuiWinElementPtr
name|element
decl_stmt|;
name|TuiWinElementPtr
name|srcElement
decl_stmt|;
name|element
operator|=
operator|(
name|TuiWinElementPtr
operator|)
name|execInfoPtr
operator|->
name|content
index|[
name|i
index|]
expr_stmt|;
name|srcElement
operator|=
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
expr_stmt|;
comment|/*                 ** First check to see if we have a breakpoint that is                 ** temporary.  If so, and this is our current execution point,                 ** then clear the break indicator.                 */
if|if
condition|(
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|&&
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
condition|)
block|{
name|struct
name|breakpoint
modifier|*
name|bp
decl_stmt|;
name|int
name|found
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|breakpoint_chain
init|;
operator|(
name|bp
operator|!=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|found
operator|)
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
name|found
operator|=
operator|(
name|winInfo
operator|==
name|srcWin
operator|&&
name|bp
operator|->
name|line_number
operator|==
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
operator|)
operator|||
operator|(
name|winInfo
operator|==
name|disassemWin
operator|&&
name|bp
operator|->
name|address
operator|==
operator|(
name|CORE_ADDR
operator|)
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
operator|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|=
operator|(
name|bp
operator|->
name|disposition
operator|!=
name|del
operator|||
name|bp
operator|->
name|hit_count
operator|<=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*                 ** Now update the exec info content based upon the state                 ** of each line as indicated by the source content.                 */
if|if
condition|(
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|&&
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
condition|)
name|element
operator|->
name|whichElement
operator|.
name|simpleString
operator|=
name|breakLocationStr
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
condition|)
name|element
operator|->
name|whichElement
operator|.
name|simpleString
operator|=
name|breakStr
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|srcElement
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
condition|)
name|element
operator|->
name|whichElement
operator|.
name|simpleString
operator|=
name|locationStr
argument_list|()
expr_stmt|;
else|else
name|element
operator|->
name|whichElement
operator|.
name|simpleString
operator|=
name|blankStr
argument_list|()
expr_stmt|;
block|}
name|execInfoPtr
operator|->
name|contentSize
operator|=
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|TUI_FAILURE
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* tuiSetExecInfoContent */
end_comment

begin_comment
comment|/* ** tuiShowExecInfoContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowExecInfoContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiShowExecInfoContent
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiGenWinInfoPtr
name|execInfo
init|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
decl_stmt|;
name|int
name|curLine
decl_stmt|;
name|werase
argument_list|(
name|execInfo
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tuiRefreshWin
argument_list|(
name|execInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|curLine
operator|=
literal|1
init|;
operator|(
name|curLine
operator|<=
name|execInfo
operator|->
name|contentSize
operator|)
condition|;
name|curLine
operator|++
control|)
name|mvwaddstr
argument_list|(
name|execInfo
operator|->
name|handle
argument_list|,
name|curLine
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|execInfo
operator|->
name|content
index|[
name|curLine
operator|-
literal|1
index|]
operator|)
operator|->
name|whichElement
operator|.
name|simpleString
argument_list|)
expr_stmt|;
name|tuiRefreshWin
argument_list|(
name|execInfo
argument_list|)
expr_stmt|;
name|execInfo
operator|->
name|contentInUse
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowExecInfoContent */
end_comment

begin_comment
comment|/* ** tuiShowAllExecInfosContent() */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowAllExecInfosContent
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiShowAllExecInfosContent
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiShowExecInfoContent
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowAllExecInfosContent */
end_comment

begin_comment
comment|/* ** tuiEraseExecInfoContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiEraseExecInfoContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiEraseExecInfoContent
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiGenWinInfoPtr
name|execInfo
init|=
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
decl_stmt|;
name|werase
argument_list|(
name|execInfo
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tuiRefreshWin
argument_list|(
name|execInfo
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiEraseExecInfoContent */
end_comment

begin_comment
comment|/* ** tuiEraseAllExecInfosContent() */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiEraseAllExecInfosContent
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiEraseAllExecInfosContent
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiEraseExecInfoContent
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiEraseAllExecInfosContent */
end_comment

begin_comment
comment|/* ** tuiClearExecInfoContent(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiClearExecInfoContent
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiClearExecInfoContent
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|winInfo
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|executionInfo
operator|->
name|contentInUse
operator|=
name|FALSE
expr_stmt|;
name|tuiEraseExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiClearExecInfoContent */
end_comment

begin_comment
comment|/* ** tuiClearAllExecInfosContent() */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiClearAllExecInfosContent
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiClearAllExecInfosContent
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiClearExecInfoContent
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiClearAllExecInfosContent */
end_comment

begin_comment
comment|/* ** tuiUpdateExecInfo(). **        Function to update the execution info window */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateExecInfo
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiUpdateExecInfo
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiSetExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
name|tuiShowExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tuiUpdateExecInfo   /* ** tuiUpdateAllExecInfos() */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateAllExecInfos
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiUpdateAllExecInfos
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|tuiUpdateExecInfo
argument_list|(
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiUpdateAllExecInfos*/
end_comment

begin_comment
comment|/* tuiUpdateOnEnd() **       elz: This function clears the execution info from the source windows **       and resets the locator to display no line info, procedure info, pc **       info.  It is called by stack_publish_stopped_with_no_frame, which **       is called then the target terminates execution */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiUpdateOnEnd
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiUpdateOnEnd
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|TuiGenWinInfoPtr
name|locator
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|locator
operator|=
name|locatorWinInfoPtr
argument_list|()
expr_stmt|;
comment|/* for all the windows (src, asm) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sourceWindows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|winInfo
operator|=
call|(
name|TuiWinInfoPtr
call|)
argument_list|(
name|sourceWindows
argument_list|()
argument_list|)
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
name|tuiSetIsExecPointAt
argument_list|(
operator|(
name|Opaque
operator|)
operator|-
literal|1
argument_list|,
name|winInfo
argument_list|)
expr_stmt|;
comment|/* the target is'n running */
comment|/* -1 should not match any line number or pc */
name|tuiSetExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
comment|/*set winInfo so that> is'n displayed*/
name|tuiShowExecInfoContent
argument_list|(
name|winInfo
argument_list|)
expr_stmt|;
comment|/* display the new contents */
block|}
comment|/*now update the locator*/
name|tuiClearLocatorDisplay
argument_list|()
expr_stmt|;
name|tuiGetLocatorFilename
argument_list|(
name|locator
argument_list|,
operator|&
name|filename
argument_list|)
expr_stmt|;
name|tuiSetLocatorInfo
argument_list|(
name|filename
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|Opaque
operator|)
name|NULL
argument_list|,
operator|&
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|locator
argument_list|)
expr_stmt|;
name|tuiShowLocatorContent
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiUpdateOnEnd */
end_comment

begin_function
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|tuiAllocSourceBuffer
parameter_list|(
name|TuiWinInfoPtr
name|winInfo
parameter_list|)
else|#
directive|else
function|tuiAllocSourceBuffer
parameter_list|(
name|winInfo
parameter_list|)
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|srcLine
decl_stmt|,
modifier|*
name|srcLineBuf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|lineWidth
decl_stmt|,
name|c
decl_stmt|,
name|maxLines
decl_stmt|;
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|maxLines
operator|=
name|winInfo
operator|->
name|generic
operator|.
name|height
expr_stmt|;
comment|/* less the highlight box */
name|lineWidth
operator|=
name|winInfo
operator|->
name|generic
operator|.
name|width
operator|-
literal|1
expr_stmt|;
comment|/*     ** Allocate the buffer for the source lines.  Do this only once since they     ** will be re-used for all source displays.  The only other time this will     ** be done is when a window's size changes.     */
if|if
condition|(
name|winInfo
operator|->
name|generic
operator|.
name|content
operator|==
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|srcLineBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|maxLines
operator|*
name|lineWidth
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcLineBuf
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|fputs_unfiltered
argument_list|(
literal|"Unable to Allocate Memory for Source or Disassembly Display.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* allocate the content list */
if|if
condition|(
operator|(
name|winInfo
operator|->
name|generic
operator|.
name|content
operator|=
operator|(
name|OpaquePtr
operator|)
name|allocContent
argument_list|(
name|maxLines
argument_list|,
name|SRC_WIN
argument_list|)
operator|)
operator|==
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|tuiFree
argument_list|(
name|srcLineBuf
argument_list|)
expr_stmt|;
name|srcLineBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"Unable to Allocate Memory for Source or Disassembly Display.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxLines
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
operator|=
name|srcLineBuf
operator|+
operator|(
name|lineWidth
operator|*
name|i
operator|)
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* tuiAllocSourceBuffer */
end_comment

begin_comment
comment|/* ** tuiLineIsDisplayed(). **      Answer whether the a particular line number or address is displayed **      in the current source window. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiLineIsDisplayed
parameter_list|(
name|Opaque
name|lineNoOrAddr
parameter_list|,
name|TuiWinInfoPtr
name|winInfo
parameter_list|,
name|int
name|checkThreshold
parameter_list|)
else|#
directive|else
function|tuiLineIsDisplayed
parameter_list|(
name|lineNoOrAddr
parameter_list|,
name|winInfo
parameter_list|,
name|checkThreshold
parameter_list|)
name|Opaque
name|lineNoOrAddr
decl_stmt|;
name|TuiWinInfoPtr
name|winInfo
decl_stmt|;
name|int
name|checkThreshold
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|isDisplayed
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|threshold
decl_stmt|;
if|if
condition|(
name|checkThreshold
condition|)
name|threshold
operator|=
name|SCROLL_THRESHOLD
expr_stmt|;
else|else
name|threshold
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|winInfo
operator|->
name|generic
operator|.
name|contentSize
operator|-
name|threshold
operator|&&
operator|!
name|isDisplayed
condition|)
block|{
if|if
condition|(
name|winInfo
operator|==
name|srcWin
condition|)
name|isDisplayed
operator|=
operator|(
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
operator|==
operator|(
name|int
operator|)
name|lineNoOrAddr
operator|)
expr_stmt|;
else|else
name|isDisplayed
operator|=
operator|(
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|winInfo
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
operator|==
name|lineNoOrAddr
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|isDisplayed
return|;
block|}
end_function

begin_comment
comment|/* tuiLineIsDisplayed */
end_comment

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS               ** ******************************************/
end_comment

end_unit

