begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* TUI support I/O functions.     Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Hewlett-Packard Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-io.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-command.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-wingeneral.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-file.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"cli-out.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_function
name|int
name|key_is_start_sequence
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|==
literal|27
operator|)
return|;
block|}
end_function

begin_function
name|int
name|key_is_end_sequence
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|==
literal|126
operator|)
return|;
block|}
end_function

begin_function
name|int
name|key_is_backspace
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|==
literal|8
operator|)
return|;
block|}
end_function

begin_function
name|int
name|key_is_command_char
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ch
operator|==
name|KEY_NPAGE
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_PPAGE
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_LEFT
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_RIGHT
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_UP
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_DOWN
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_SF
operator|)
operator|||
operator|(
name|ch
operator|==
name|KEY_SR
operator|)
operator|||
operator|(
name|ch
operator|==
operator|(
name|int
operator|)
literal|'\f'
operator|)
operator|||
name|key_is_start_sequence
argument_list|(
name|ch
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Use definition from readline 4.3.  */
end_comment

begin_undef
undef|#
directive|undef
name|CTRL_CHAR
end_undef

begin_define
define|#
directive|define
name|CTRL_CHAR
parameter_list|(
name|c
parameter_list|)
value|((c)< control_character_threshold&& (((c)& 0x80) == 0))
end_define

begin_comment
comment|/* This file controls the IO interactions between gdb and curses.    When the TUI is enabled, gdb has two modes a curses and a standard    mode.     In curses mode, the gdb outputs are made in a curses command window.    For this, the gdb_stdout and gdb_stderr are redirected to the specific    ui_file implemented by TUI.  The output is handled by tui_puts().    The input is also controlled by curses with tui_getc().  The readline    library uses this function to get its input.  Several readline hooks    are installed to redirect readline output to the TUI (see also the    note below).     In normal mode, the gdb outputs are restored to their origin, that    is as if TUI is not used.  Readline also uses its original getc()    function with stdin.     Note SCz/2001-07-21: the current readline is not clean in its management of    the output.  Even if we install a redisplay handler, it sometimes writes on    a stdout file.  It is important to redirect every output produced by    readline, otherwise the curses window will be garbled.  This is implemented    with a pipe that TUI reads and readline writes to.  A gdb input handler    is created so that reading the pipe is handled automatically.    This will probably not work on non-Unix platforms.  The best fix is    to make readline clean enougth so that is never write on stdout.     Note SCz/2002-09-01: we now use more readline hooks and it seems that    with them we don't need the pipe anymore (verified by creating the pipe    and closing its end so that write causes a SIGPIPE).  The old pipe code    is still there and can be conditionally removed by    #undef TUI_USE_PIPE_FOR_READLINE.  */
end_comment

begin_comment
comment|/* For gdb 5.3, prefer to continue the pipe hack as a backup wheel.  */
end_comment

begin_define
define|#
directive|define
name|TUI_USE_PIPE_FOR_READLINE
end_define

begin_comment
comment|/*#undef TUI_USE_PIPE_FOR_READLINE*/
end_comment

begin_comment
comment|/* TUI output files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ui_file
modifier|*
name|tui_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ui_file
modifier|*
name|tui_stderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_out
modifier|*
name|tui_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GDB output files in non-curses mode.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ui_file
modifier|*
name|tui_old_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ui_file
modifier|*
name|tui_old_stderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_out
modifier|*
name|tui_old_uiout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Readline previous hooks.  */
end_comment

begin_decl_stmt
specifier|static
name|Function
modifier|*
name|tui_old_rl_getc_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VFunction
modifier|*
name|tui_old_rl_redisplay_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VFunction
modifier|*
name|tui_old_rl_prep_terminal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VFunction
modifier|*
name|tui_old_rl_deprep_terminal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tui_old_readline_echoing_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Readline output stream.    Should be removed when readline is clean.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tui_rl_outstream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tui_old_rl_outstream
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TUI_USE_PIPE_FOR_READLINE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|tui_readline_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The last gdb prompt that was registered in readline.    This may be the main gdb prompt or a secondary prompt.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tui_rl_saved_prompt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|tui_handle_resize_during_io
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|tui_putc
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tui_puts
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the string in the curses command window.  */
end_comment

begin_function
name|void
name|tui_puts
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|static
name|int
name|tui_skip_line
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|;
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Catch annotation and discard them.  We need two \032 and          discard until a \n is seen.  */
if|if
condition|(
name|c
operator|==
literal|'\032'
condition|)
block|{
name|tui_skip_line
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tui_skip_line
operator|!=
literal|1
condition|)
block|{
name|tui_skip_line
operator|=
operator|-
literal|1
expr_stmt|;
name|waddch
argument_list|(
name|w
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|tui_skip_line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|getyx
argument_list|(
name|w
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|cur_line
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
argument_list|)
expr_stmt|;
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|start_line
operator|=
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|cur_line
expr_stmt|;
comment|/* We could defer the following.  */
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Readline callback.    Redisplay the command line with its prompt after readline has    changed the edited text.  */
end_comment

begin_function
name|void
name|tui_redisplay_readline
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|prev_col
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|col
decl_stmt|,
name|line
decl_stmt|;
name|int
name|c_pos
decl_stmt|;
name|int
name|c_line
decl_stmt|;
name|int
name|in
decl_stmt|;
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|start_line
decl_stmt|;
comment|/* Detect when we temporarily left SingleKey and now the readline      edit buffer is empty, automatically restore the SingleKey mode.  */
if|if
condition|(
name|tui_current_key_mode
operator|==
name|TUI_ONE_COMMAND_MODE
operator|&&
name|rl_end
operator|==
literal|0
condition|)
name|tui_set_key_mode
argument_list|(
name|TUI_SINGLE_KEY_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_current_key_mode
operator|==
name|TUI_SINGLE_KEY_MODE
condition|)
name|prompt
operator|=
literal|""
expr_stmt|;
else|else
name|prompt
operator|=
name|tui_rl_saved_prompt
expr_stmt|;
name|c_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|c_line
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|=
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
expr_stmt|;
name|start_line
operator|=
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|start_line
expr_stmt|;
name|wmove
argument_list|(
name|w
argument_list|,
name|start_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev_col
operator|=
literal|0
expr_stmt|;
name|height
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|prompt
operator|&&
name|prompt
index|[
name|in
index|]
condition|;
name|in
operator|++
control|)
block|{
name|waddch
argument_list|(
name|w
argument_list|,
name|prompt
index|[
name|in
index|]
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|w
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|<
name|prev_col
condition|)
name|height
operator|++
expr_stmt|;
name|prev_col
operator|=
name|col
expr_stmt|;
block|}
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|rl_end
condition|;
name|in
operator|++
control|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|rl_line_buffer
index|[
name|in
index|]
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
block|{
name|getyx
argument_list|(
name|w
argument_list|,
name|c_line
argument_list|,
name|c_pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
block|{
name|waddch
argument_list|(
name|w
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|w
argument_list|,
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|?
name|UNCTRL
argument_list|(
name|c
argument_list|)
else|:
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waddch
argument_list|(
name|w
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|getyx
argument_list|(
name|w
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|start_line
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
argument_list|)
expr_stmt|;
block|}
name|getyx
argument_list|(
name|w
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|<
name|prev_col
condition|)
name|height
operator|++
expr_stmt|;
name|prev_col
operator|=
name|col
expr_stmt|;
block|}
name|wclrtobot
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|w
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|start_line
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_line
operator|>=
literal|0
condition|)
block|{
name|wmove
argument_list|(
name|w
argument_list|,
name|c_line
argument_list|,
name|c_pos
argument_list|)
expr_stmt|;
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|cur_line
operator|=
name|c_line
expr_stmt|;
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
operator|=
name|c_pos
expr_stmt|;
block|}
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|start_line
operator|-=
name|height
operator|-
literal|1
expr_stmt|;
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Readline callback to prepare the terminal.  It is called once    each time we enter readline.  Terminal is already setup in curses mode.  */
end_comment

begin_function
specifier|static
name|void
name|tui_prep_terminal
parameter_list|(
name|int
name|notused1
parameter_list|)
block|{
comment|/* Save the prompt registered in readline to correctly display it.      (we can't use gdb_prompt() due to secondary prompts and can't use      rl_prompt because it points to an alloca buffer).  */
name|xfree
argument_list|(
name|tui_rl_saved_prompt
argument_list|)
expr_stmt|;
name|tui_rl_saved_prompt
operator|=
name|xstrdup
argument_list|(
name|rl_prompt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Readline callback to restore the terminal.  It is called once    each time we leave readline.  There is nothing to do in curses mode.  */
end_comment

begin_function
specifier|static
name|void
name|tui_deprep_terminal
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TUI_USE_PIPE_FOR_READLINE
end_ifdef

begin_comment
comment|/* Read readline output pipe and feed the command window with it.    Should be removed when readline is clean.  */
end_comment

begin_function
specifier|static
name|void
name|tui_readline_output
parameter_list|(
name|int
name|code
parameter_list|,
name|gdb_client_data
name|data
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|size
operator|=
name|read
argument_list|(
name|tui_readline_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|tui_active
condition|)
block|{
name|buf
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|tui_puts
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the portion of PATHNAME that should be output when listing    possible completions.  If we are hacking filename completion, we    are only interested in the basename, the portion following the    final slash.  Otherwise, we return what we were passed.     Comes from readline/complete.c  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable_part
parameter_list|(
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|rl_filename_completion_desired
condition|?
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
name|temp
operator|==
literal|0
operator|&&
name|isalpha
argument_list|(
name|pathname
index|[
literal|0
index|]
argument_list|)
operator|&&
name|pathname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|temp
operator|=
name|pathname
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|temp
condition|?
operator|++
name|temp
else|:
name|pathname
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we    are using it, check for and output a single character for `special'    filenames.  Return the number of characters we output. */
end_comment

begin_define
define|#
directive|define
name|PUTX
parameter_list|(
name|c
parameter_list|)
define|\
value|do { \       if (CTRL_CHAR (c)) \         { \           tui_puts ("^"); \           tui_putc (UNCTRL (c)); \           printed_len += 2; \         } \       else if (c == RUBOUT) \ 	{ \ 	  tui_puts ("^?"); \ 	  printed_len += 2; \ 	} \       else \ 	{ \ 	  tui_putc (c); \ 	  printed_len++; \ 	} \     } while (0)
end_define

begin_function
specifier|static
name|int
name|print_filename
parameter_list|(
name|char
modifier|*
name|to_print
parameter_list|,
name|char
modifier|*
name|full_pathname
parameter_list|)
block|{
name|int
name|printed_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|to_print
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|PUTX
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|printed_len
return|;
block|}
end_function

begin_comment
comment|/* The user must press "y" or "n".  Non-zero return means "y" pressed.    Comes from readline/complete.c  */
end_comment

begin_function
specifier|static
name|int
name|get_y_or_n
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
name|_rl_abort_internal
parameter_list|()
function_decl|;
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|' '
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
literal|'N'
operator|||
name|c
operator|==
name|RUBOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|ABORT_CHAR
condition|)
name|_rl_abort_internal
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A convenience function for displaying a list of strings in    columnar format on readline's output stream.  MATCHES is the list    of strings, in argv format, LEN is the number of strings in MATCHES,    and MAX is the length of the longest string in MATCHES.     Comes from readline/complete.c and modified to write in    the TUI command window using tui_putc/tui_puts.  */
end_comment

begin_function
specifier|static
name|void
name|tui_rl_display_match_list
parameter_list|(
name|char
modifier|*
modifier|*
name|matches
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|max
parameter_list|)
block|{
typedef|typedef
name|int
name|QSFUNC
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
typedef|;
specifier|extern
name|int
name|_rl_qsort_string_compare
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_rl_print_completions_horizontally
decl_stmt|;
name|int
name|count
decl_stmt|,
name|limit
decl_stmt|,
name|printed_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Screen dimension correspond to the TUI command window.  */
name|int
name|screenwidth
init|=
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|width
decl_stmt|;
comment|/* If there are many items, then ask the user if she really wants to      see them all. */
if|if
condition|(
name|len
operator|>=
name|rl_completion_query_items
condition|)
block|{
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\nDisplay all %d possibilities? (y or n)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tui_puts
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_y_or_n
argument_list|()
operator|==
literal|0
condition|)
block|{
name|tui_puts
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* How many items of MAX length can we fit in the screen window? */
name|max
operator|+=
literal|2
expr_stmt|;
name|limit
operator|=
name|screenwidth
operator|/
name|max
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|1
operator|&&
operator|(
name|limit
operator|*
name|max
operator|==
name|screenwidth
operator|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Avoid a possible floating exception.  If max> screenwidth,      limit will be 0 and a divide-by-zero fault will result. */
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
literal|1
expr_stmt|;
comment|/* How many iterations of the printing loop? */
name|count
operator|=
operator|(
name|len
operator|+
operator|(
name|limit
operator|-
literal|1
operator|)
operator|)
operator|/
name|limit
expr_stmt|;
comment|/* Watch out for special case.  If LEN is less than LIMIT, then      just do the inner printing loop. 	   0< len<= limit  implies  count = 1. */
comment|/* Sort the items if they are not already sorted. */
if|if
condition|(
name|rl_ignore_completion_duplicates
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|QSFUNC
operator|*
operator|)
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
name|tui_putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_print_completions_horizontally
operator|==
literal|0
condition|)
block|{
comment|/* Print the sorted items, up-and-down alphabetically, like ls. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|i
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|>
name|len
operator|||
name|matches
index|[
name|l
index|]
operator|==
literal|0
condition|)
break|break;
else|else
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
name|printed_len
operator|=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|limit
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_len
condition|;
name|k
operator|++
control|)
name|tui_putc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|l
operator|+=
name|count
expr_stmt|;
block|}
name|tui_putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Print the sorted items, across alphabetically, like ls -x. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printed_len
operator|=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Have we reached the end of this line? */
if|if
condition|(
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
name|limit
operator|>
literal|1
operator|)
operator|&&
operator|(
name|i
operator|%
name|limit
operator|)
operator|==
literal|0
condition|)
name|tui_putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_len
condition|;
name|k
operator|++
control|)
name|tui_putc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|tui_putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Setup the IO for curses or non-curses mode.    - In non-curses mode, readline and gdb use the standard input and    standard output/error directly.    - In curses mode, the standard output/error is controlled by TUI    with the tui_stdout and tui_stderr.  The output is redirected in    the curses command window.  Several readline callbacks are installed    so that readline asks for its input to the curses command window    with wgetch().  */
end_comment

begin_function
name|void
name|tui_setup_io
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
specifier|extern
name|int
name|readline_echoing_p
decl_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
comment|/* Redirect readline to TUI.  */
name|tui_old_rl_redisplay_function
operator|=
name|rl_redisplay_function
expr_stmt|;
name|tui_old_rl_deprep_terminal
operator|=
name|rl_deprep_term_function
expr_stmt|;
name|tui_old_rl_prep_terminal
operator|=
name|rl_prep_term_function
expr_stmt|;
name|tui_old_rl_getc_function
operator|=
name|rl_getc_function
expr_stmt|;
name|tui_old_rl_outstream
operator|=
name|rl_outstream
expr_stmt|;
name|tui_old_readline_echoing_p
operator|=
name|readline_echoing_p
expr_stmt|;
name|rl_redisplay_function
operator|=
name|tui_redisplay_readline
expr_stmt|;
name|rl_deprep_term_function
operator|=
name|tui_deprep_terminal
expr_stmt|;
name|rl_prep_term_function
operator|=
name|tui_prep_terminal
expr_stmt|;
name|rl_getc_function
operator|=
name|tui_getc
expr_stmt|;
name|readline_echoing_p
operator|=
literal|0
expr_stmt|;
name|rl_outstream
operator|=
name|tui_rl_outstream
expr_stmt|;
name|rl_prompt
operator|=
literal|0
expr_stmt|;
name|rl_completion_display_matches_hook
operator|=
name|tui_rl_display_match_list
expr_stmt|;
name|rl_already_prompted
operator|=
literal|0
expr_stmt|;
comment|/* Keep track of previous gdb output.  */
name|tui_old_stdout
operator|=
name|gdb_stdout
expr_stmt|;
name|tui_old_stderr
operator|=
name|gdb_stderr
expr_stmt|;
name|tui_old_uiout
operator|=
name|uiout
expr_stmt|;
comment|/* Reconfigure gdb output.  */
name|gdb_stdout
operator|=
name|tui_stdout
expr_stmt|;
name|gdb_stderr
operator|=
name|tui_stderr
expr_stmt|;
name|gdb_stdlog
operator|=
name|gdb_stdout
expr_stmt|;
comment|/* for moment */
name|gdb_stdtarg
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
name|uiout
operator|=
name|tui_out
expr_stmt|;
comment|/* Save tty for SIGCONT.  */
name|savetty
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore gdb output.  */
name|gdb_stdout
operator|=
name|tui_old_stdout
expr_stmt|;
name|gdb_stderr
operator|=
name|tui_old_stderr
expr_stmt|;
name|gdb_stdlog
operator|=
name|gdb_stdout
expr_stmt|;
comment|/* for moment */
name|gdb_stdtarg
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
name|uiout
operator|=
name|tui_old_uiout
expr_stmt|;
comment|/* Restore readline.  */
name|rl_redisplay_function
operator|=
name|tui_old_rl_redisplay_function
expr_stmt|;
name|rl_deprep_term_function
operator|=
name|tui_old_rl_deprep_terminal
expr_stmt|;
name|rl_prep_term_function
operator|=
name|tui_old_rl_prep_terminal
expr_stmt|;
name|rl_getc_function
operator|=
name|tui_old_rl_getc_function
expr_stmt|;
name|rl_outstream
operator|=
name|tui_old_rl_outstream
expr_stmt|;
name|rl_completion_display_matches_hook
operator|=
literal|0
expr_stmt|;
name|readline_echoing_p
operator|=
name|tui_old_readline_echoing_p
expr_stmt|;
name|rl_already_prompted
operator|=
literal|0
expr_stmt|;
comment|/* Save tty for SIGCONT.  */
name|savetty
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCONT
end_ifdef

begin_comment
comment|/* Catch SIGCONT to restore the terminal and refresh the screen.  */
end_comment

begin_function
specifier|static
name|void
name|tui_cont_sig
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|tui_active
condition|)
block|{
comment|/* Restore the terminal setting because another process (shell)          might have changed it.  */
name|resetty
argument_list|()
expr_stmt|;
comment|/* Force a refresh of the screen.  */
name|tui_refresh_all_win
argument_list|()
expr_stmt|;
comment|/* Update cursor position on the screen.  */
name|wmove
argument_list|(
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|start_line
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|sig
argument_list|,
name|tui_cont_sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize the IO for gdb in curses mode.  */
end_comment

begin_function
name|void
name|tui_initialize_io
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIGCONT
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|tui_cont_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create tui output streams.  */
name|tui_stdout
operator|=
name|tui_fileopen
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|tui_stderr
operator|=
name|tui_fileopen
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|tui_out
operator|=
name|tui_out_new
argument_list|(
name|tui_stdout
argument_list|)
expr_stmt|;
comment|/* Create the default UI.  It is not created because we installed      a init_ui_hook.  */
name|tui_old_uiout
operator|=
name|uiout
operator|=
name|cli_out_new
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TUI_USE_PIPE_FOR_READLINE
comment|/* Temporary solution for readline writing to stdout:      redirect readline output in a pipe, read that pipe and      output the content in the curses command window.  */
if|if
condition|(
name|pipe
argument_list|(
name|tui_readline_pipe
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot create pipe for readline"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tui_rl_outstream
operator|=
name|fdopen
argument_list|(
name|tui_readline_pipe
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_rl_outstream
operator|==
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot redirect readline output"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setvbuf
argument_list|(
name|tui_rl_outstream
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|tui_readline_pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|O_NDELAY
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|tui_readline_pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|add_file_handler
argument_list|(
name|tui_readline_pipe
index|[
literal|0
index|]
argument_list|,
name|tui_readline_output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|tui_rl_outstream
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get a character from the command window.  This is called from the readline    package.  */
end_comment

begin_function
name|int
name|tui_getc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|TUI_CMD_WIN
operator|->
name|generic
operator|.
name|handle
expr_stmt|;
ifdef|#
directive|ifdef
name|TUI_USE_PIPE_FOR_READLINE
comment|/* Flush readline output.  */
name|tui_readline_output
argument_list|(
name|GDB_READABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ch
operator|=
name|wgetch
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|ch
operator|=
name|tui_handle_resize_during_io
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* The \n must be echoed because it will not be printed by readline.  */
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|/* When hitting return with an empty input, gdb executes the last          command.  If we emit a newline, this fills up the command window          with empty lines with gdb prompt at beginning.  Instead of that,          stay on the same line but provide a visual effect to show the          user we recognized the command.  */
if|if
condition|(
name|rl_end
operator|==
literal|0
condition|)
block|{
name|wmove
argument_list|(
name|w
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|cur_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the line.  This will blink the gdb prompt since              it will be redrawn at the same line.  */
name|wclrtoeol
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wmove
argument_list|(
name|w
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|cur_line
argument_list|,
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|w
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|key_is_command_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* Handle prev/next/up/down here */
name|ch
operator|=
name|tui_dispatch_ctrl_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\f'
condition|)
name|TUI_CMD_WIN
operator|->
name|detail
operator|.
name|command_info
operator|.
name|curch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|KEY_BACKSPACE
condition|)
return|return
literal|'\b'
return|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Cleanup when a resize has occured.    Returns the character that must be processed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tui_handle_resize_during_io
parameter_list|(
name|unsigned
name|int
name|original_ch
parameter_list|)
block|{
if|if
condition|(
name|tui_win_resized
argument_list|()
condition|)
block|{
name|tui_refresh_all_win
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|tui_set_win_resized_to
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
else|else
return|return
name|original_ch
return|;
block|}
end_function

end_unit

