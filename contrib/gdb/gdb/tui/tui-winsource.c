begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* TUI display source/assembly window.     Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Hewlett-Packard Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-stack.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-wingeneral.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-winsource.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-source.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-disasm.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_comment
comment|/* Function to display the "main" routine.  */
end_comment

begin_function
name|void
name|tui_display_main
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|tui_get_begin_asm_address
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|tui_update_source_windows_with_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|tui_update_locator_filename
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|tui_update_locator_filename
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Function to display source in the source window.  This function    initializes the horizontal scroll to 0.  */
end_comment

begin_function
name|void
name|tui_update_source_window
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|union
name|tui_line_or_address
name|line_or_addr
parameter_list|,
name|int
name|noerror
parameter_list|)
block|{
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|horizontal_offset
operator|=
literal|0
expr_stmt|;
name|tui_update_source_window_as_is
argument_list|(
name|win_info
argument_list|,
name|s
argument_list|,
name|line_or_addr
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Function to display source in the source/asm window.  This function    shows the source as specified by the horizontal offset.  */
end_comment

begin_function
name|void
name|tui_update_source_window_as_is
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|union
name|tui_line_or_address
name|line_or_addr
parameter_list|,
name|int
name|noerror
parameter_list|)
block|{
name|enum
name|tui_status
name|ret
decl_stmt|;
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
name|ret
operator|=
name|tui_set_source_content
argument_list|(
name|s
argument_list|,
name|line_or_addr
operator|.
name|line_no
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|tui_set_disassem_content
argument_list|(
name|line_or_addr
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|TUI_FAILURE
condition|)
block|{
name|tui_clear_source_content
argument_list|(
name|win_info
argument_list|,
name|EMPTY_SOURCE_PROMPT
argument_list|)
expr_stmt|;
name|tui_clear_exec_info_content
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tui_update_breakpoint_info
argument_list|(
name|win_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tui_show_source_content
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
name|tui_update_exec_info
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|.
name|line
operator|=
name|line_or_addr
operator|.
name|line_no
operator|+
operator|(
name|win_info
operator|->
name|generic
operator|.
name|content_size
operator|-
literal|2
operator|)
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|set_current_source_symtab_and_line
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* 	     ** If the focus was in the asm win, put it in the src 	     ** win if we don't have a split layout 	   */
if|if
condition|(
name|tui_win_with_focus
argument_list|()
operator|==
name|TUI_DISASM_WIN
operator|&&
name|tui_current_layout
argument_list|()
operator|!=
name|SRC_DISASSEM_COMMAND
condition|)
name|tui_set_win_focus_to
argument_list|(
name|TUI_SRC_WIN
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Function to ensure that the source and/or disassemly windows    reflect the input address.  */
end_comment

begin_function
name|void
name|tui_update_source_windows_with_addr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|union
name|tui_line_or_address
name|l
decl_stmt|;
switch|switch
condition|(
name|tui_current_layout
argument_list|()
condition|)
block|{
case|case
name|DISASSEM_COMMAND
case|:
case|case
name|DISASSEM_DATA_COMMAND
case|:
name|tui_show_disassem
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRC_DISASSEM_COMMAND
case|:
name|tui_show_disassem_and_update_source
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sal
operator|=
name|find_pc_line
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|l
operator|.
name|line_no
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|tui_show_symtab_source
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|l
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_win_info
modifier|*
name|win_info
init|=
operator|(
expr|struct
name|tui_win_info
operator|*
operator|)
operator|(
name|tui_source_windows
argument_list|()
operator|)
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
name|tui_clear_source_content
argument_list|(
name|win_info
argument_list|,
name|EMPTY_SOURCE_PROMPT
argument_list|)
expr_stmt|;
name|tui_clear_exec_info_content
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Function to ensure that the source and/or disassemly windows    reflect the input address.  */
end_comment

begin_function
name|void
name|tui_update_source_windows_with_line
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|union
name|tui_line_or_address
name|l
decl_stmt|;
switch|switch
condition|(
name|tui_current_layout
argument_list|()
condition|)
block|{
case|case
name|DISASSEM_COMMAND
case|:
case|case
name|DISASSEM_DATA_COMMAND
case|:
name|find_line_pc
argument_list|(
name|s
argument_list|,
name|line
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|tui_update_source_windows_with_addr
argument_list|(
name|pc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|l
operator|.
name|line_no
operator|=
name|line
expr_stmt|;
name|tui_show_symtab_source
argument_list|(
name|s
argument_list|,
name|l
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_current_layout
argument_list|()
operator|==
name|SRC_DISASSEM_COMMAND
condition|)
block|{
name|find_line_pc
argument_list|(
name|s
argument_list|,
name|line
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|tui_show_disassem
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|tui_clear_source_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|int
name|display_prompt
parameter_list|)
block|{
if|if
condition|(
name|win_info
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|win_info
operator|->
name|generic
operator|.
name|content_in_use
operator|=
name|FALSE
expr_stmt|;
name|tui_erase_source_content
argument_list|(
name|win_info
argument_list|,
name|display_prompt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|win_info
operator|->
name|generic
operator|.
name|content_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_win_element
modifier|*
name|element
init|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
decl_stmt|;
name|element
operator|->
name|which_element
operator|.
name|source
operator|.
name|has_break
operator|=
name|FALSE
expr_stmt|;
name|element
operator|->
name|which_element
operator|.
name|source
operator|.
name|is_exec_point
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|tui_erase_source_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|int
name|display_prompt
parameter_list|)
block|{
name|int
name|x_pos
decl_stmt|;
name|int
name|half_width
init|=
operator|(
name|win_info
operator|->
name|generic
operator|.
name|width
operator|-
literal|2
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
block|{
name|werase
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|tui_check_and_display_highlight_if_needed
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_prompt
operator|==
name|EMPTY_SOURCE_PROMPT
condition|)
block|{
name|char
modifier|*
name|no_src_str
decl_stmt|;
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|type
operator|==
name|SRC_WIN
condition|)
name|no_src_str
operator|=
name|NO_SRC_STRING
expr_stmt|;
else|else
name|no_src_str
operator|=
name|NO_DISASSEM_STRING
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|no_src_str
argument_list|)
operator|>=
name|half_width
condition|)
name|x_pos
operator|=
literal|1
expr_stmt|;
else|else
name|x_pos
operator|=
name|half_width
operator|-
name|strlen
argument_list|(
name|no_src_str
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
operator|(
name|win_info
operator|->
name|generic
operator|.
name|height
operator|/
literal|2
operator|)
argument_list|,
name|x_pos
argument_list|,
name|no_src_str
argument_list|)
expr_stmt|;
comment|/* elz: added this function call to set the real contents of 	     the window to what is on the  screen, so that later calls 	     to refresh, do display 	     the correct stuff, and not the old image */
name|tui_set_source_content_nil
argument_list|(
name|win_info
argument_list|,
name|no_src_str
argument_list|)
expr_stmt|;
block|}
name|tui_refresh_win
argument_list|(
operator|&
name|win_info
operator|->
name|generic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Redraw the complete line of a source or disassembly window.  */
end_comment

begin_function
specifier|static
name|void
name|tui_show_source_line
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|tui_win_element
modifier|*
name|line
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|line
operator|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
name|lineno
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|which_element
operator|.
name|source
operator|.
name|is_exec_point
condition|)
name|wattron
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|lineno
argument_list|,
literal|1
argument_list|,
name|line
operator|->
name|which_element
operator|.
name|source
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|which_element
operator|.
name|source
operator|.
name|is_exec_point
condition|)
name|wattroff
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|A_STANDOUT
argument_list|)
expr_stmt|;
comment|/* Clear to end of line but stop before the border.  */
name|getyx
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|+
literal|1
operator|<
name|win_info
operator|->
name|generic
operator|.
name|width
condition|)
block|{
name|waddch
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tui_show_source_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|content_size
operator|>
literal|0
condition|)
block|{
name|int
name|lineno
decl_stmt|;
for|for
control|(
name|lineno
operator|=
literal|1
init|;
name|lineno
operator|<=
name|win_info
operator|->
name|generic
operator|.
name|content_size
condition|;
name|lineno
operator|++
control|)
name|tui_show_source_line
argument_list|(
name|win_info
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
else|else
name|tui_erase_source_content
argument_list|(
name|win_info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tui_check_and_display_highlight_if_needed
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
name|tui_refresh_win
argument_list|(
operator|&
name|win_info
operator|->
name|generic
argument_list|)
expr_stmt|;
name|win_info
operator|->
name|generic
operator|.
name|content_in_use
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scroll the source forward or backward horizontally.  */
end_comment

begin_function
name|void
name|tui_horizontal_source_scroll
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|enum
name|tui_scroll_direction
name|direction
parameter_list|,
name|int
name|num_to_scroll
parameter_list|)
block|{
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|content
operator|!=
name|NULL
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|symtab_and_line
name|cursal
init|=
name|get_current_source_symtab_and_line
argument_list|()
decl_stmt|;
if|if
condition|(
name|cursal
operator|.
name|symtab
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
condition|)
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|cursal
operator|.
name|symtab
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|LEFT_SCROLL
condition|)
name|offset
operator|=
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|horizontal_offset
operator|+
name|num_to_scroll
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|offset
operator|=
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|horizontal_offset
operator|-
name|num_to_scroll
operator|)
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|horizontal_offset
operator|=
name|offset
expr_stmt|;
name|tui_update_source_window_as_is
argument_list|(
name|win_info
argument_list|,
name|s
argument_list|,
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|which_element
operator|.
name|source
operator|.
name|line_or_addr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Set or clear the has_break flag in the line whose line is line_no.  */
end_comment

begin_function
name|void
name|tui_set_is_exec_point_at
parameter_list|(
name|union
name|tui_line_or_address
name|l
parameter_list|,
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tui_win_content
name|content
init|=
operator|(
name|tui_win_content
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|win_info
operator|->
name|generic
operator|.
name|content_size
condition|)
block|{
name|int
name|new_state
decl_stmt|;
if|if
condition|(
name|content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|source
operator|.
name|line_or_addr
operator|.
name|addr
operator|==
name|l
operator|.
name|addr
condition|)
name|new_state
operator|=
name|TRUE
expr_stmt|;
else|else
name|new_state
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|new_state
operator|!=
name|content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|source
operator|.
name|is_exec_point
condition|)
block|{
name|changed
operator|++
expr_stmt|;
name|content
index|[
name|i
index|]
operator|->
name|which_element
operator|.
name|source
operator|.
name|is_exec_point
operator|=
name|new_state
expr_stmt|;
name|tui_show_source_line
argument_list|(
name|win_info
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
name|tui_refresh_win
argument_list|(
operator|&
name|win_info
operator|->
name|generic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the execution windows to show the active breakpoints.    This is called whenever a breakpoint is inserted, removed or    has its state changed.  */
end_comment

begin_function
name|void
name|tui_update_all_breakpoint_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tui_list
modifier|*
name|list
init|=
name|tui_source_windows
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_win_info
modifier|*
name|win
init|=
operator|(
expr|struct
name|tui_win_info
operator|*
operator|)
name|list
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tui_update_breakpoint_info
argument_list|(
name|win
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|tui_update_exec_info
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the source window and the breakpoints to update the    has_break information for each line.    Returns 1 if something changed and the execution window    must be refreshed.  */
end_comment

begin_function
name|int
name|tui_update_breakpoint_info
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win
parameter_list|,
name|int
name|current_only
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|need_refresh
init|=
literal|0
decl_stmt|;
name|struct
name|tui_source_info
modifier|*
name|src
init|=
operator|&
name|win
operator|->
name|detail
operator|.
name|source_info
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|win
operator|->
name|generic
operator|.
name|content_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|breakpoint
modifier|*
name|bp
decl_stmt|;
specifier|extern
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|tui_source_element
modifier|*
name|line
decl_stmt|;
name|line
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|which_element
operator|.
name|source
expr_stmt|;
if|if
condition|(
name|current_only
operator|&&
operator|!
name|line
operator|->
name|is_exec_point
condition|)
continue|continue;
comment|/* Scan each breakpoint to see if the current line has something to          do with it.  Identify enable/disabled breakpoints as well as          those that we already hit.  */
name|mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|breakpoint_chain
init|;
name|bp
operator|!=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|win
operator|==
name|TUI_SRC_WIN
operator|&&
name|bp
operator|->
name|source_file
operator|&&
operator|(
name|strcmp
argument_list|(
name|src
operator|->
name|filename
argument_list|,
name|bp
operator|->
name|source_file
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|bp
operator|->
name|line_number
operator|==
name|line
operator|->
name|line_or_addr
operator|.
name|line_no
operator|)
operator|||
operator|(
name|win
operator|==
name|TUI_DISASM_WIN
operator|&&
name|bp
operator|->
name|loc
operator|->
name|address
operator|==
name|line
operator|->
name|line_or_addr
operator|.
name|addr
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|enable_state
operator|==
name|bp_disabled
condition|)
name|mode
operator||=
name|TUI_BP_DISABLED
expr_stmt|;
else|else
name|mode
operator||=
name|TUI_BP_ENABLED
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|hit_count
condition|)
name|mode
operator||=
name|TUI_BP_HIT
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|cond
condition|)
name|mode
operator||=
name|TUI_BP_CONDITIONAL
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
name|mode
operator||=
name|TUI_BP_HARDWARE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line
operator|->
name|has_break
operator|!=
name|mode
condition|)
block|{
name|line
operator|->
name|has_break
operator|=
name|mode
expr_stmt|;
name|need_refresh
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|need_refresh
return|;
block|}
end_function

begin_comment
comment|/* Function to initialize the content of the execution info window,    based upon the input window which is either the source or    disassembly window.  */
end_comment

begin_function
name|enum
name|tui_status
name|tui_set_exec_info_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|enum
name|tui_status
name|ret
init|=
name|TUI_SUCCESS
decl_stmt|;
if|if
condition|(
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|execution_info
operator|!=
operator|(
expr|struct
name|tui_gen_win_info
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|exec_info_ptr
init|=
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|execution_info
decl_stmt|;
if|if
condition|(
name|exec_info_ptr
operator|->
name|content
operator|==
name|NULL
condition|)
name|exec_info_ptr
operator|->
name|content
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|tui_alloc_content
argument_list|(
name|win_info
operator|->
name|generic
operator|.
name|height
argument_list|,
name|exec_info_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_info_ptr
operator|->
name|content
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tui_update_breakpoint_info
argument_list|(
name|win_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|win_info
operator|->
name|generic
operator|.
name|content_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tui_win_element
modifier|*
name|element
decl_stmt|;
name|struct
name|tui_win_element
modifier|*
name|src_element
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|element
operator|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|exec_info_ptr
operator|->
name|content
index|[
name|i
index|]
expr_stmt|;
name|src_element
operator|=
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
expr_stmt|;
name|memset
argument_list|(
name|element
operator|->
name|which_element
operator|.
name|simple_string
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|element
operator|->
name|which_element
operator|.
name|simple_string
argument_list|)
argument_list|)
expr_stmt|;
name|element
operator|->
name|which_element
operator|.
name|simple_string
index|[
name|TUI_EXECINFO_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Now update the exec info content based upon the state                  of each line as indicated by the source content.  */
name|mode
operator|=
name|src_element
operator|->
name|which_element
operator|.
name|source
operator|.
name|has_break
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|TUI_BP_HIT
condition|)
name|element
operator|->
name|which_element
operator|.
name|simple_string
index|[
name|TUI_BP_HIT_POS
index|]
operator|=
operator|(
name|mode
operator|&
name|TUI_BP_HARDWARE
operator|)
condition|?
literal|'H'
else|:
literal|'B'
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
operator|(
name|TUI_BP_ENABLED
operator||
name|TUI_BP_DISABLED
operator|)
condition|)
name|element
operator|->
name|which_element
operator|.
name|simple_string
index|[
name|TUI_BP_HIT_POS
index|]
operator|=
operator|(
name|mode
operator|&
name|TUI_BP_HARDWARE
operator|)
condition|?
literal|'h'
else|:
literal|'b'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|TUI_BP_ENABLED
condition|)
name|element
operator|->
name|which_element
operator|.
name|simple_string
index|[
name|TUI_BP_BREAK_POS
index|]
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|TUI_BP_DISABLED
condition|)
name|element
operator|->
name|which_element
operator|.
name|simple_string
index|[
name|TUI_BP_BREAK_POS
index|]
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|src_element
operator|->
name|which_element
operator|.
name|source
operator|.
name|is_exec_point
condition|)
name|element
operator|->
name|which_element
operator|.
name|simple_string
index|[
name|TUI_EXEC_POS
index|]
operator|=
literal|'>'
expr_stmt|;
block|}
name|exec_info_ptr
operator|->
name|content_size
operator|=
name|win_info
operator|->
name|generic
operator|.
name|content_size
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|TUI_FAILURE
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|tui_show_exec_info_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|exec_info
init|=
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|execution_info
decl_stmt|;
name|int
name|cur_line
decl_stmt|;
name|werase
argument_list|(
name|exec_info
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tui_refresh_win
argument_list|(
name|exec_info
argument_list|)
expr_stmt|;
for|for
control|(
name|cur_line
operator|=
literal|1
init|;
operator|(
name|cur_line
operator|<=
name|exec_info
operator|->
name|content_size
operator|)
condition|;
name|cur_line
operator|++
control|)
name|mvwaddstr
argument_list|(
name|exec_info
operator|->
name|handle
argument_list|,
name|cur_line
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|exec_info
operator|->
name|content
index|[
name|cur_line
operator|-
literal|1
index|]
operator|)
operator|->
name|which_element
operator|.
name|simple_string
argument_list|)
expr_stmt|;
name|tui_refresh_win
argument_list|(
name|exec_info
argument_list|)
expr_stmt|;
name|exec_info
operator|->
name|content_in_use
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tui_erase_exec_info_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|struct
name|tui_gen_win_info
modifier|*
name|exec_info
init|=
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|execution_info
decl_stmt|;
name|werase
argument_list|(
name|exec_info
operator|->
name|handle
argument_list|)
expr_stmt|;
name|tui_refresh_win
argument_list|(
name|exec_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tui_clear_exec_info_content
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|win_info
operator|->
name|detail
operator|.
name|source_info
operator|.
name|execution_info
operator|->
name|content_in_use
operator|=
name|FALSE
expr_stmt|;
name|tui_erase_exec_info_content
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Function to update the execution info window.  */
end_comment

begin_function
name|void
name|tui_update_exec_info
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|tui_set_exec_info_content
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
name|tui_show_exec_info_content
argument_list|(
name|win_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|tui_status
name|tui_alloc_source_buffer
parameter_list|(
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|)
block|{
name|char
modifier|*
name|src_line_buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|line_width
decl_stmt|,
name|max_lines
decl_stmt|;
name|enum
name|tui_status
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|max_lines
operator|=
name|win_info
operator|->
name|generic
operator|.
name|height
expr_stmt|;
comment|/* less the highlight box */
name|line_width
operator|=
name|win_info
operator|->
name|generic
operator|.
name|width
operator|-
literal|1
expr_stmt|;
comment|/*      ** Allocate the buffer for the source lines.  Do this only once since they      ** will be re-used for all source displays.  The only other time this will      ** be done is when a window's size changes.    */
if|if
condition|(
name|win_info
operator|->
name|generic
operator|.
name|content
operator|==
name|NULL
condition|)
block|{
name|src_line_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_lines
operator|*
name|line_width
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_line_buf
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|fputs_unfiltered
argument_list|(
literal|"Unable to Allocate Memory for Source or Disassembly Display.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* allocate the content list */
if|if
condition|(
operator|(
name|win_info
operator|->
name|generic
operator|.
name|content
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|tui_alloc_content
argument_list|(
name|max_lines
argument_list|,
name|SRC_WIN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|src_line_buf
argument_list|)
expr_stmt|;
name|src_line_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"Unable to Allocate Memory for Source or Disassembly Display.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_lines
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|which_element
operator|.
name|source
operator|.
name|line
operator|=
name|src_line_buf
operator|+
operator|(
name|line_width
operator|*
name|i
operator|)
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Answer whether the a particular line number or address is displayed    in the current source window.  */
end_comment

begin_function
name|int
name|tui_line_is_displayed
parameter_list|(
name|int
name|line
parameter_list|,
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|int
name|check_threshold
parameter_list|)
block|{
name|int
name|is_displayed
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|threshold
decl_stmt|;
if|if
condition|(
name|check_threshold
condition|)
name|threshold
operator|=
name|SCROLL_THRESHOLD
expr_stmt|;
else|else
name|threshold
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|win_info
operator|->
name|generic
operator|.
name|content_size
operator|-
name|threshold
operator|&&
operator|!
name|is_displayed
condition|)
block|{
name|is_displayed
operator|=
operator|(
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|which_element
operator|.
name|source
operator|.
name|line_or_addr
operator|.
name|line_no
operator|==
operator|(
name|int
operator|)
name|line
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|is_displayed
return|;
block|}
end_function

begin_comment
comment|/* Answer whether the a particular line number or address is displayed    in the current source window.  */
end_comment

begin_function
name|int
name|tui_addr_is_displayed
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|tui_win_info
modifier|*
name|win_info
parameter_list|,
name|int
name|check_threshold
parameter_list|)
block|{
name|int
name|is_displayed
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|threshold
decl_stmt|;
if|if
condition|(
name|check_threshold
condition|)
name|threshold
operator|=
name|SCROLL_THRESHOLD
expr_stmt|;
else|else
name|threshold
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|win_info
operator|->
name|generic
operator|.
name|content_size
operator|-
name|threshold
operator|&&
operator|!
name|is_displayed
condition|)
block|{
name|is_displayed
operator|=
operator|(
operator|(
operator|(
expr|struct
name|tui_win_element
operator|*
operator|)
name|win_info
operator|->
name|generic
operator|.
name|content
index|[
name|i
index|]
operator|)
operator|->
name|which_element
operator|.
name|source
operator|.
name|line_or_addr
operator|.
name|addr
operator|==
name|addr
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|is_displayed
return|;
block|}
end_function

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS               ** ******************************************/
end_comment

end_unit

