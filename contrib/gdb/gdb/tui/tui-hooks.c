begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB hooks for TUI.     Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdb-events.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-hooks.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-data.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-layout.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-io.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-regs.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-win.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-stack.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-windata.h"
end_include

begin_include
include|#
directive|include
file|"tui/tui-winsource.h"
end_include

begin_include
include|#
directive|include
file|"gdb_curses.h"
end_include

begin_decl_stmt
name|int
name|tui_target_has_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|tui_target_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|tui_new_objfile_hook
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|tui_active
condition|)
name|tui_display_main
argument_list|()
expr_stmt|;
if|if
condition|(
name|tui_target_new_objfile_chain
condition|)
name|tui_target_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tui_query_hook
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
name|argp
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|int
name|ans2
decl_stmt|;
name|int
name|answer
decl_stmt|;
comment|/* Automatically answer "yes" if input is not from a terminal.  */
if|if
condition|(
operator|!
name|input_from_terminal_p
argument_list|()
condition|)
return|return
literal|1
return|;
name|echo
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|msg
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(y or n) "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|answer
operator|=
name|tui_getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* in case of C-d */
if|if
condition|(
name|answer
operator|==
name|EOF
condition|)
comment|/* C-d */
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Eat rest of input line, to EOF or newline */
if|if
condition|(
name|answer
operator|!=
literal|'\n'
condition|)
do|do
block|{
name|ans2
operator|=
name|tui_getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ans2
operator|!=
name|EOF
operator|&&
name|ans2
operator|!=
literal|'\n'
operator|&&
name|ans2
operator|!=
literal|'\r'
condition|)
do|;
if|if
condition|(
name|answer
operator|>=
literal|'a'
condition|)
name|answer
operator|-=
literal|040
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|'Y'
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|answer
operator|==
literal|'N'
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"Please answer y or n.\n"
argument_list|)
expr_stmt|;
block|}
name|noecho
argument_list|()
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Prevent recursion of registers_changed_hook().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tui_refreshing_registers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tui_registers_changed_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|deprecated_selected_frame
expr_stmt|;
if|if
condition|(
name|fi
operator|&&
name|tui_refreshing_registers
operator|==
literal|0
condition|)
block|{
name|tui_refreshing_registers
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|tui_check_data_values (fi);
endif|#
directive|endif
name|tui_refreshing_registers
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tui_register_changed_hook
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|deprecated_selected_frame
expr_stmt|;
if|if
condition|(
name|fi
operator|&&
name|tui_refreshing_registers
operator|==
literal|0
condition|)
block|{
name|tui_refreshing_registers
operator|=
literal|1
expr_stmt|;
name|tui_check_data_values
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|tui_refreshing_registers
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Breakpoint creation hook.    Update the screen to show the new breakpoint.  */
end_comment

begin_function
specifier|static
name|void
name|tui_event_create_breakpoint
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|tui_update_all_breakpoint_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Breakpoint deletion hook.    Refresh the screen to update the breakpoint marks.  */
end_comment

begin_function
specifier|static
name|void
name|tui_event_delete_breakpoint
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|tui_update_all_breakpoint_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_event_modify_breakpoint
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|tui_update_all_breakpoint_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tui_event_default
parameter_list|(
name|int
name|number
parameter_list|)
block|{
empty_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|gdb_events
modifier|*
name|tui_old_event_hooks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gdb_events
name|tui_event_hooks
init|=
block|{
name|tui_event_create_breakpoint
block|,
name|tui_event_delete_breakpoint
block|,
name|tui_event_modify_breakpoint
block|,
name|tui_event_default
block|,
name|tui_event_default
block|,
name|tui_event_default
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called when going to wait for the target.    Leave curses mode and setup program mode.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|tui_target_wait_hook
parameter_list|(
name|ptid_t
name|pid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|ptid_t
name|res
decl_stmt|;
comment|/* Leave tui mode (optional).  */
if|#
directive|if
literal|0
block|if (tui_active)     {       target_terminal_ours ();       endwin ();       target_terminal_inferior ();     }
endif|#
directive|endif
name|tui_target_has_run
operator|=
literal|1
expr_stmt|;
name|res
operator|=
name|target_wait
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_active
condition|)
block|{
comment|/* TODO: need to refresh (optional).  */
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* The selected frame has changed.  This is happens after a target    stop or when the user explicitly changes the frame (up/down/thread/...).  */
end_comment

begin_function
specifier|static
name|void
name|tui_selected_frame_level_changed_hook
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|deprecated_selected_frame
expr_stmt|;
comment|/* Ensure that symbols for this frame are read in.  Also, determine the      source language of this frame, and switch to it if desired.  */
if|if
condition|(
name|fi
condition|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* elz: this if here fixes the problem with the pc not being displayed          in the tui asm layout, with no debug symbols. The value of s           would be 0 here, and select_source_symtab would abort the          command by calling the 'error' function */
if|if
condition|(
name|s
condition|)
name|select_source_symtab
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Display the frame position (even if there is no symbols).  */
name|tui_show_frame_info
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* Refresh the register window if it's visible.  */
if|if
condition|(
name|tui_is_window_visible
argument_list|(
name|DATA_WIN
argument_list|)
condition|)
block|{
name|tui_refreshing_registers
operator|=
literal|1
expr_stmt|;
name|tui_check_data_values
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|tui_refreshing_registers
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called from print_frame_info to list the line we stopped in.  */
end_comment

begin_function
specifier|static
name|void
name|tui_print_frame_info_listing_hook
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
block|{
name|select_source_symtab
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tui_show_frame_info
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when the target process died or is detached.    Update the status line.  */
end_comment

begin_function
specifier|static
name|void
name|tui_detach_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|tui_show_frame_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tui_display_main
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install the TUI specific hooks.  */
end_comment

begin_function
name|void
name|tui_install_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|target_wait_hook
operator|=
name|tui_target_wait_hook
expr_stmt|;
name|selected_frame_level_changed_hook
operator|=
name|tui_selected_frame_level_changed_hook
expr_stmt|;
name|print_frame_info_listing_hook
operator|=
name|tui_print_frame_info_listing_hook
expr_stmt|;
name|query_hook
operator|=
name|tui_query_hook
expr_stmt|;
comment|/* Install the event hooks.  */
name|tui_old_event_hooks
operator|=
name|set_gdb_event_hooks
argument_list|(
operator|&
name|tui_event_hooks
argument_list|)
expr_stmt|;
name|registers_changed_hook
operator|=
name|tui_registers_changed_hook
expr_stmt|;
name|register_changed_hook
operator|=
name|tui_register_changed_hook
expr_stmt|;
name|detach_hook
operator|=
name|tui_detach_hook
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the TUI specific hooks.  */
end_comment

begin_function
name|void
name|tui_remove_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|target_wait_hook
operator|=
literal|0
expr_stmt|;
name|selected_frame_level_changed_hook
operator|=
literal|0
expr_stmt|;
name|print_frame_info_listing_hook
operator|=
literal|0
expr_stmt|;
name|query_hook
operator|=
literal|0
expr_stmt|;
name|registers_changed_hook
operator|=
literal|0
expr_stmt|;
name|register_changed_hook
operator|=
literal|0
expr_stmt|;
name|detach_hook
operator|=
literal|0
expr_stmt|;
comment|/* Restore the previous event hooks.  */
name|set_gdb_event_hooks
argument_list|(
name|tui_old_event_hooks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|_initialize_tui_hooks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_tui_hooks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Install the permanent hooks.  */
name|tui_target_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|tui_new_objfile_hook
expr_stmt|;
block|}
end_function

end_unit

