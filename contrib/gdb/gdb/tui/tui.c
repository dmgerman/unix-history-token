begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** tui.c **         General functions for the WDB TUI */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERM_H
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"tuiLayout.h"
end_include

begin_include
include|#
directive|include
file|"tuiIO.h"
end_include

begin_include
include|#
directive|include
file|"tuiRegs.h"
end_include

begin_include
include|#
directive|include
file|"tuiWin.h"
end_include

begin_comment
comment|/* The Solaris header files seem to provide no declaration for this at    all when __STDC__ is defined.  This shouldn't conflict with    anything.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*********************** ** Local Definitions ************************/
end_comment

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_comment
comment|/* Solaris<sys/termios.h> defines CTRL. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTRL
end_ifndef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|(x& ~0140)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHK
parameter_list|(
name|val
parameter_list|,
name|dft
parameter_list|)
value|(val<=0 ? dft : val)
end_define

begin_define
define|#
directive|define
name|TOGGLE_USAGE
value|"Usage:toggle breakpoints"
end_define

begin_define
define|#
directive|define
name|TUI_TOGGLE_USAGE
value|"Usage:\ttoggle $fregs\n\ttoggle breakpoints"
end_define

begin_comment
comment|/***************************** ** Local static forward decls ******************************/
end_comment

begin_decl_stmt
specifier|static
name|void
name|_tuiReset
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_toggle_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_tui_vToggle_command
name|PARAMS
argument_list|(
operator|(
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Opaque
name|_tui_vDo
name|PARAMS
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************** ** Public Functions ************************/
end_comment

begin_comment
comment|/* ** tuiInit(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiInit
parameter_list|(
name|char
modifier|*
name|argv0
parameter_list|)
else|#
directive|else
function|tuiInit
parameter_list|(
name|argv0
parameter_list|)
name|char
modifier|*
name|argv0
decl_stmt|;
endif|#
directive|endif
block|{
specifier|extern
name|void
name|init_page_info
parameter_list|()
function_decl|;
specifier|extern
name|void
name|initialize_tui_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
name|initialize_tui_files
argument_list|()
expr_stmt|;
name|initializeStaticData
argument_list|()
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|setTermHeightTo
argument_list|(
name|LINES
argument_list|)
expr_stmt|;
name|setTermWidthTo
argument_list|(
name|COLS
argument_list|)
expr_stmt|;
name|tuiInitWindows
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|init_page_info
argument_list|()
expr_stmt|;
comment|/* Don't hook debugger output if doing command-window      * the XDB way. However, one thing we do want to do in      * XDB style is set up the scrolling region to be      * the bottom of the screen (tuiTermUnsetup()).      */
name|fputs_unfiltered_hook
operator|=
name|NULL
expr_stmt|;
name|flush_hook
operator|=
name|NULL
expr_stmt|;
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* need readline initialization to 		      * create termcap sequences 		      */
name|tuiTermUnsetup
argument_list|(
literal|1
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiInit */
end_comment

begin_comment
comment|/* ** tuiInitWindows(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiInitWindows
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiInitWindows
parameter_list|()
endif|#
directive|endif
block|{
name|TuiWinType
name|type
decl_stmt|;
name|tuiSetLocatorContent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|showLayout
argument_list|(
name|SRC_COMMAND
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|tuiSetWinFocusTo
argument_list|(
name|srcWin
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiInitWindows */
end_comment

begin_comment
comment|/* ** tuiCleanUp(). **        Kill signal handler and cleanup termination method */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiResetScreen
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiResetScreen
parameter_list|()
endif|#
directive|endif
block|{
name|TuiWinType
name|type
init|=
name|SRC_WIN
decl_stmt|;
name|keypad
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|type
operator|<
name|MAX_MAJOR_WINDOWS
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|winList
index|[
name|type
index|]
argument_list|)
operator|&&
name|winList
index|[
name|type
index|]
operator|->
name|generic
operator|.
name|type
operator|!=
name|UNDEFINED_WIN
operator|&&
operator|!
name|winList
index|[
name|type
index|]
operator|->
name|generic
operator|.
name|isVisible
condition|)
name|tuiDelWindow
argument_list|(
name|winList
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
name|endwin
argument_list|()
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiResetScreen */
end_comment

begin_comment
comment|/* ** tuiCleanUp(). **        Kill signal handler and cleanup termination method */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiCleanUp
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiCleanUp
parameter_list|()
endif|#
directive|endif
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|extern
name|char
modifier|*
name|term_cursor_move
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tuiTermSetup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore scrolling region to whole screen */
name|keypad
argument_list|(
name|cmdWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|freeAllWindows
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_cursor_move
argument_list|,
literal|0
argument_list|,
name|termHeight
argument_list|()
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
name|_tuiReset
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiCleanUp */
end_comment

begin_comment
comment|/* ** tuiError(). */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiError
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|exitGdb
parameter_list|)
else|#
directive|else
function|tuiError
parameter_list|(
name|string
parameter_list|,
name|exitGdb
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|exitGdb
decl_stmt|;
endif|#
directive|endif
block|{
name|puts_unfiltered
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitGdb
condition|)
block|{
name|tuiCleanUp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiError */
end_comment

begin_comment
comment|/* ** tui_vError() **        tuiError with args in a va_list. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vError
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vError
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|exitGdb
decl_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|exitGdb
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|tuiError
argument_list|(
name|string
argument_list|,
name|exitGdb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tui_vError */
end_comment

begin_comment
comment|/* ** tuiFree() **    Wrapper on top of free() to ensure that input address is greater than 0x0 */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiFree
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
else|#
directive|else
function|tuiFree
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|ptr
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiFree */
end_comment

begin_comment
comment|/* tuiGetLowDisassemblyAddress(). **        Determine what the low address will be to display in the TUI's **        disassembly window.  This may or may not be the same as the **        low address input. */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|tuiGetLowDisassemblyAddress
parameter_list|(
name|Opaque
name|low
parameter_list|,
name|Opaque
name|pc
parameter_list|)
else|#
directive|else
function|tuiGetLowDisassemblyAddress
parameter_list|(
name|low
parameter_list|,
name|pc
parameter_list|)
name|Opaque
name|low
decl_stmt|;
name|Opaque
name|pc
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|line
decl_stmt|;
name|Opaque
name|newLow
decl_stmt|;
comment|/*     ** Determine where to start the disassembly so that the pc is about in the     ** middle of the viewport.     */
for|for
control|(
name|line
operator|=
literal|0
operator|,
name|newLow
operator|=
name|pc
init|;
operator|(
name|newLow
operator|>
name|low
operator|&&
name|line
operator|<
operator|(
name|tuiDefaultWinViewportHeight
argument_list|(
name|DISASSEM_WIN
argument_list|,
name|DISASSEM_COMMAND
argument_list|)
operator|/
literal|2
operator|)
operator|)
condition|;
control|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|newLow
operator|-=
sizeof|sizeof
argument_list|(
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
return|return
name|newLow
return|;
block|}
end_function

begin_comment
comment|/* tuiGetLowDisassemblyAddress */
end_comment

begin_comment
comment|/* tui_vGetLowDisassemblyAddress(). **        Determine what the low address will be to display in the TUI's **        disassembly window with args in a va_list. */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vGetLowDisassemblyAddress
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vGetLowDisassemblyAddress
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|line
decl_stmt|;
name|Opaque
name|newLow
decl_stmt|;
name|Opaque
name|low
decl_stmt|;
name|Opaque
name|pc
decl_stmt|;
name|low
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|Opaque
argument_list|)
expr_stmt|;
name|pc
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|Opaque
argument_list|)
expr_stmt|;
return|return
operator|(
name|tuiGetLowDisassemblyAddress
argument_list|(
name|low
argument_list|,
name|pc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tui_vGetLowDisassemblyAddress */
end_comment

begin_comment
comment|/* ** tuiDo(). **        General purpose function to execute a tui function.  Transitions **        between curses and the are handled here.  This function is called **        by non-tui gdb functions. ** **        Errors are caught here. **        If there is no error, the value returned by 'func' is returned. **        If there is an error, then zero is returned. ** **       Must not be called with immediate_quit in effect (bad things might **       happen, say we got a signal in the middle of a memcpy to quit_return). **       This is an OK restriction; with very few exceptions immediate_quit can **       be replaced by judicious use of QUIT. */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDo
parameter_list|(
name|TuiOpaqueFuncPtr
name|func
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|tuiDo
parameter_list|(
name|func
parameter_list|,
name|va_alist
parameter_list|)
name|TuiOpaqueFuncPtr
name|func
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
specifier|extern
name|int
name|terminal_is_ours
decl_stmt|;
name|Opaque
name|ret
init|=
operator|(
name|Opaque
operator|)
name|NULL
decl_stmt|;
comment|/* It is an error to be tuiDo'ing if we      * don't own the terminal.      */
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|tui_version
condition|)
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|args
argument_list|,
name|func
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|_tui_vDo
argument_list|(
name|func
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* tuiDo */
end_comment

begin_comment
comment|/* ** tuiDoAndReturnToTop(). **        General purpose function to execute a tui function.  Transitions **        between curses and the are handled here.  This function is called **        by non-tui gdb functions who wish to reset gdb to the top level. **        After the tuiDo is performed, a return to the top level occurs. ** **        Errors are caught here. **        If there is no error, the value returned by 'func' is returned. **        If there is an error, then zero is returned. ** **       Must not be called with immediate_quit in effect (bad things might **       happen, say we got a signal in the middle of a memcpy to quit_return). **       This is an OK restriction; with very few exceptions immediate_quit can **       be replaced by judicious use of QUIT. ** */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDoAndReturnToTop
parameter_list|(
name|TuiOpaqueFuncPtr
name|func
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|tuiDoAndReturnToTop
parameter_list|(
name|func
parameter_list|,
name|va_alist
parameter_list|)
name|TuiOpaqueFuncPtr
name|func
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
specifier|extern
name|int
name|terminal_is_ours
decl_stmt|;
name|Opaque
name|ret
init|=
operator|(
name|Opaque
operator|)
name|NULL
decl_stmt|;
comment|/* It is an error to be tuiDo'ing if we      * don't own the terminal.      */
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|tui_version
condition|)
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|args
argument_list|,
name|func
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|_tui_vDo
argument_list|(
name|func
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* force a return to the top level */
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* tuiDoAndReturnToTop */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vSelectSourceSymtab
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vSelectSourceSymtab
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
expr|struct
name|symtab
operator|*
argument_list|)
decl_stmt|;
name|select_source_symtab
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tui_vSelectSourceSymtab */
end_comment

begin_comment
comment|/* ** _initialize_tui(). **      Function to initialize gdb commands, for tui window manipulation. */
end_comment

begin_function
name|void
name|_initialize_tui
parameter_list|()
block|{
if|#
directive|if
literal|0
block|if (tui_version)     {       add_com ("toggle", class_tui, _toggle_command, 	       "Toggle Terminal UI Features\n\ Usage: Toggle $fregs\n\ \tToggles between single and double precision floating point registers.\n");     }
endif|#
directive|endif
name|char
modifier|*
name|helpStr
decl_stmt|;
if|if
condition|(
name|tui_version
condition|)
name|helpStr
operator|=
literal|"Toggle Specified Features\n\ Usage:\ttoggle $fregs\n\ttoggle breakpoints"
expr_stmt|;
else|else
name|helpStr
operator|=
literal|"Toggle Specified Features\nUsage:toggle breakpoints"
expr_stmt|;
name|add_abbrev_prefix_cmd
argument_list|(
literal|"toggle"
argument_list|,
name|class_tui
argument_list|,
name|_toggle_command
argument_list|,
name|helpStr
argument_list|,
operator|&
name|togglelist
argument_list|,
literal|"toggle "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* _initialize_tui*/
end_comment

begin_comment
comment|/* ** va_catch_errors(). **       General purpose function to execute a function, catching errors. **       If there is no error, the value returned by 'func' is returned. **       If there is error, then zero is returned. **       Note that 'func' must take a variable argument list as well. ** **       Must not be called with immediate_quit in effect (bad things might **       happen, say we got a signal in the middle of a memcpy to quit_return). **       This is an OK restriction; with very few exceptions immediate_quit can **       be replaced by judicious use of QUIT. */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|va_catch_errors
parameter_list|(
name|TuiOpaqueFuncPtr
name|func
parameter_list|,
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|va_catch_errors
parameter_list|(
name|func
parameter_list|,
name|args
parameter_list|)
name|TuiOpaqueFuncPtr
name|func
decl_stmt|;
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|Opaque
name|ret
init|=
operator|(
name|Opaque
operator|)
name|NULL
decl_stmt|;
comment|/*   ** We could have used catch_errors(), but it doesn't handle variable args.   ** Also, for the tui, we always want to catch all errors, so we don't   ** need to pass a mask, or an error string.   */
name|jmp_buf
name|saved_error
decl_stmt|;
name|jmp_buf
name|saved_quit
decl_stmt|;
name|jmp_buf
name|tmp_jmp
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|saved_cleanup_chain
decl_stmt|;
name|char
modifier|*
name|saved_error_pre_print
decl_stmt|;
name|char
modifier|*
name|saved_quit_pre_print
decl_stmt|;
specifier|extern
name|jmp_buf
name|error_return
decl_stmt|;
specifier|extern
name|jmp_buf
name|quit_return
decl_stmt|;
name|saved_cleanup_chain
operator|=
name|save_cleanups
argument_list|()
expr_stmt|;
name|saved_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|saved_quit_pre_print
operator|=
name|quit_pre_print
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|saved_error
argument_list|,
operator|(
name|char
operator|*
operator|)
name|error_return
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
literal|""
expr_stmt|;
name|memcpy
argument_list|(
name|saved_quit
argument_list|,
name|quit_return
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pre_print
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|tmp_jmp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_list
name|argList
init|=
name|args
decl_stmt|;
name|memcpy
argument_list|(
name|error_return
argument_list|,
name|tmp_jmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|quit_return
argument_list|,
name|tmp_jmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|func
argument_list|(
name|argList
argument_list|)
expr_stmt|;
block|}
name|restore_cleanups
argument_list|(
name|saved_cleanup_chain
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|error_return
argument_list|,
name|saved_error
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|saved_error_pre_print
expr_stmt|;
name|memcpy
argument_list|(
name|quit_return
argument_list|,
name|saved_quit
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pre_print
operator|=
name|saved_quit_pre_print
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ** vcatch_errors(). **        Catch errors occurring in tui or non tui function, handling **        variable param lists. Note that 'func' must take a variable **        argument list as well. */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|vcatch_errors
parameter_list|(
name|OpaqueFuncPtr
name|func
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|vcatch_errors
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
comment|/* vcatch_errors(func, va_alist)     OpaqueFuncPtr    func;     va_dcl */
endif|#
directive|endif
block|{
name|Opaque
name|ret
init|=
operator|(
name|Opaque
operator|)
name|NULL
decl_stmt|;
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|args
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/*     va_arg(args, OpaqueFuncPtr); */
else|#
directive|else
name|OpaqueFuncPtr
name|func
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|func
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|OpaqueFuncPtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|va_catch_errors
argument_list|(
name|func
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|strcat_to_buf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|char
modifier|*
name|itemToAdd
parameter_list|)
else|#
directive|else
function|strcat_to_buf
parameter_list|(
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|itemToAdd
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|char
modifier|*
name|itemToAdd
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|itemToAdd
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|buf
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|itemToAdd
argument_list|)
operator|)
operator|<=
name|buflen
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|itemToAdd
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|buf
argument_list|,
name|itemToAdd
argument_list|,
operator|(
name|buflen
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* strcat_to_buf */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|strcat_to_buf_with_fmt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufLen
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|strcat_to_buf_with_fmt
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufLen
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|buf
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|bufLen
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|strcat_to_buf
argument_list|(
name|buf
argument_list|,
name|bufLen
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************** ** Static Functions ************************/
end_comment

begin_comment
comment|/* ** _tui_vDo(). **        General purpose function to execute a tui function.  Transitions **        between curses and the are handled here.  This function is called **        by non-tui gdb functions. ** **        Errors are caught here. **        If there is no error, the value returned by 'func' is returned. **        If there is an error, then zero is returned. ** **       Must not be called with immediate_quit in effect (bad things might **       happen, say we got a signal in the middle of a memcpy to quit_return). **       This is an OK restriction; with very few exceptions immediate_quit can **       be replaced by judicious use of QUIT. */
end_comment

begin_function
specifier|static
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|_tui_vDo
parameter_list|(
name|TuiOpaqueFuncPtr
name|func
parameter_list|,
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|_tui_vDo
parameter_list|(
name|func
parameter_list|,
name|args
parameter_list|)
name|TuiOpaqueFuncPtr
name|func
decl_stmt|;
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
specifier|extern
name|int
name|terminal_is_ours
decl_stmt|;
name|Opaque
name|ret
init|=
operator|(
name|Opaque
operator|)
name|NULL
decl_stmt|;
comment|/* It is an error to be tuiDo'ing if we      * don't own the terminal.      */
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|tui_version
condition|)
block|{
comment|/* If doing command window the "XDB way" (command window          * is unmanaged by curses...          */
comment|/* Set up terminal for TUI */
name|tuiTermSetup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|va_catch_errors
argument_list|(
name|func
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Set up terminal for command window */
name|tuiTermUnsetup
argument_list|(
literal|1
argument_list|,
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* _tui_vDo */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_toggle_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|fromTTY
parameter_list|)
else|#
directive|else
function|_toggle_command
parameter_list|(
name|arg
parameter_list|,
name|fromTTY
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
endif|#
directive|endif
block|{
name|printf_filtered
argument_list|(
literal|"Specify feature to toggle.\n%s\n"
argument_list|,
operator|(
name|tui_version
operator|)
condition|?
name|TUI_TOGGLE_USAGE
else|:
name|TOGGLE_USAGE
argument_list|)
expr_stmt|;
comment|/*   tuiDo((TuiOpaqueFuncPtr)_Toggle_command, arg, fromTTY); */
block|}
end_function

begin_comment
comment|/* ** _tui_vToggle_command(). */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tui_vToggle_command
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|_tui_vToggle_command
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|fromTTY
decl_stmt|;
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|printf_filtered
argument_list|(
name|TOGGLE_USAGE
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|tuiStrDup
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ptr
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsetCompare
argument_list|(
name|ptr
argument_list|,
name|TUI_FLOAT_REGS_NAME
argument_list|)
condition|)
name|tuiToggleFloatRegs
argument_list|()
expr_stmt|;
comment|/*        else if (subsetCompare(ptr, "ANOTHER TOGGLE OPTION"))             ... */
else|else
name|printf_filtered
argument_list|(
name|TOGGLE_USAGE
argument_list|)
expr_stmt|;
name|tuiFree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* _tuiToggle_command */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|_tuiReset
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|_tuiReset
parameter_list|()
endif|#
directive|endif
block|{
name|struct
name|termio
name|mode
decl_stmt|;
comment|/*     ** reset the teletype mode bits to a sensible state.     ** Copied tset.c     */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
name|struct
name|tchars
name|tbuf
decl_stmt|;
endif|#
directive|endif
comment|/* !USG&& TIOCGETC */
ifdef|#
directive|ifdef
name|UCB_NTTY
name|struct
name|ltchars
name|ltc
decl_stmt|;
if|if
condition|(
name|ldisc
operator|==
name|NTTYDISC
condition|)
block|{
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_suspc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_suspc
argument_list|,
name|CTRL
argument_list|(
literal|'Z'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_dsuspc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_dsuspc
argument_list|,
name|CTRL
argument_list|(
literal|'Y'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_rprntc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_rprntc
argument_list|,
name|CTRL
argument_list|(
literal|'R'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_flushc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_flushc
argument_list|,
name|CTRL
argument_list|(
literal|'O'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_werasc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_werasc
argument_list|,
name|CTRL
argument_list|(
literal|'W'
argument_list|)
argument_list|)
expr_stmt|;
name|ltc
operator|.
name|t_lnextc
operator|=
name|CHK
argument_list|(
name|ltc
operator|.
name|t_lnextc
argument_list|,
name|CTRL
argument_list|(
literal|'V'
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UCB_NTTY */
ifndef|#
directive|ifndef
name|USG
ifdef|#
directive|ifdef
name|TIOCGETC
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_intrc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_intrc
argument_list|,
name|CTRL
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_quitc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_quitc
argument_list|,
name|CTRL
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_startc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_startc
argument_list|,
name|CTRL
argument_list|(
literal|'Q'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_stopc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_stopc
argument_list|,
name|CTRL
argument_list|(
literal|'S'
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_eofc
operator|=
name|CHK
argument_list|(
name|tbuf
operator|.
name|t_eofc
argument_list|,
name|CTRL
argument_list|(
literal|'D'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* brkc is left alone */
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGETC */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|RAW
ifdef|#
directive|ifdef
name|CBREAK
operator||
name|CBREAK
endif|#
directive|endif
comment|/* CBREAK */
operator||
name|VTDELAY
operator||
name|ALLDELAY
operator|)
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator||=
name|XTABS
operator||
name|ECHO
operator||
name|CRMOD
operator||
name|ANYP
expr_stmt|;
else|#
directive|else
comment|/*USG*/
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VINTR
index|]
argument_list|,
name|CTRL
argument_list|(
literal|'?'
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VQUIT
index|]
argument_list|,
name|CTRL
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|CHK
argument_list|(
name|mode
operator|.
name|c_cc
index|[
name|VEOF
index|]
argument_list|,
name|CTRL
argument_list|(
literal|'D'
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNBRK
operator||
name|PARMRK
operator||
name|INPCK
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|IUCLC
operator||
name|IXOFF
operator|)
expr_stmt|;
name|mode
operator|.
name|c_iflag
operator||=
operator|(
name|BRKINT
operator||
name|ISTRIP
operator||
name|ICRNL
operator||
name|IXON
operator|)
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OLCUC
operator||
name|OCRNL
operator||
name|ONOCR
operator||
name|ONLRET
operator||
name|OFILL
operator||
name|OFDEL
operator||
name|NLDLY
operator||
name|CRDLY
operator||
name|TABDLY
operator||
name|BSDLY
operator||
name|VTDLY
operator||
name|FFDLY
operator|)
expr_stmt|;
name|mode
operator|.
name|c_oflag
operator||=
operator|(
name|OPOST
operator||
name|ONLCR
operator|)
expr_stmt|;
name|mode
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARODD
operator||
name|CLOCAL
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|hp9000s800
name|mode
operator|.
name|c_cflag
operator||=
operator|(
name|CS8
operator||
name|CREAD
operator|)
expr_stmt|;
else|#
directive|else
comment|/*hp9000s800*/
name|mode
operator|.
name|c_cflag
operator||=
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* hp9000s800 */
name|mode
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|XCASE
operator||
name|ECHONL
operator||
name|NOFLSH
operator|)
expr_stmt|;
name|mode
operator|.
name|c_lflag
operator||=
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOK
operator|)
expr_stmt|;
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
return|return;
block|}
end_function

begin_comment
comment|/* _tuiReset */
end_comment

end_unit

