begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** tuiDisassem.c **         This module contains functions for handling disassembly display. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"tuiLayout.h"
end_include

begin_include
include|#
directive|include
file|"tuiSourceWin.h"
end_include

begin_include
include|#
directive|include
file|"tuiStack.h"
end_include

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS FORWARD DECLS    ** ******************************************/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|_hasBreak
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************************** ** PUBLIC FUNCTIONS                        ** ******************************************/
end_comment

begin_comment
comment|/* ** tuiSetDisassemContent(). **        Function to set the disassembly window's content. */
end_comment

begin_function
name|TuiStatus
ifdef|#
directive|ifdef
name|__STDC__
name|tuiSetDisassemContent
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|Opaque
name|startAddr
parameter_list|)
else|#
directive|else
function|tuiSetDisassemContent
parameter_list|(
name|s
parameter_list|,
name|startAddr
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|Opaque
name|startAddr
decl_stmt|;
endif|#
directive|endif
block|{
name|TuiStatus
name|ret
init|=
name|TUI_FAILURE
decl_stmt|;
name|GDB_FILE
modifier|*
name|gdb_dis_out
decl_stmt|;
if|if
condition|(
name|startAddr
operator|!=
operator|(
name|Opaque
operator|)
name|NULL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|tuiAllocSourceBuffer
argument_list|(
name|disassemWin
argument_list|)
operator|)
operator|==
name|TUI_SUCCESS
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|disassemWin
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|horizontalOffset
decl_stmt|;
specifier|register
name|int
name|threshold
decl_stmt|,
name|curLine
init|=
literal|0
decl_stmt|,
name|lineWidth
decl_stmt|,
name|maxLines
decl_stmt|;
name|CORE_ADDR
name|newpc
decl_stmt|,
name|pc
decl_stmt|;
name|disassemble_info
name|asmInfo
decl_stmt|;
name|TuiGenWinInfoPtr
name|locator
init|=
name|locatorWinInfoPtr
argument_list|()
decl_stmt|;
specifier|extern
name|void
name|strcat_address
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|strcat_address_numeric
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
name|int
name|curLen
init|=
literal|0
decl_stmt|;
name|int
name|tab_len
init|=
name|tuiDefaultTabLen
argument_list|()
decl_stmt|;
name|maxLines
operator|=
name|disassemWin
operator|->
name|generic
operator|.
name|height
operator|-
literal|2
expr_stmt|;
comment|/* account for hilite */
name|lineWidth
operator|=
name|disassemWin
operator|->
name|generic
operator|.
name|width
operator|-
literal|1
expr_stmt|;
name|threshold
operator|=
operator|(
name|lineWidth
operator|-
literal|1
operator|)
operator|+
name|offset
expr_stmt|;
comment|/* now init the gdb_file structure */
name|gdb_dis_out
operator|=
name|gdb_file_init_astring
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|INIT_DISASSEMBLE_INFO_NO_ARCH
argument_list|(
name|asmInfo
argument_list|,
name|gdb_dis_out
argument_list|,
operator|(
name|fprintf_ftype
operator|)
name|fprintf_filtered
argument_list|)
expr_stmt|;
name|asmInfo
operator|.
name|read_memory_func
operator|=
name|dis_asm_read_memory
expr_stmt|;
name|asmInfo
operator|.
name|memory_error_func
operator|=
name|dis_asm_memory_error
expr_stmt|;
name|disassemWin
operator|->
name|detail
operator|.
name|sourceInfo
operator|.
name|startLineOrAddr
operator|.
name|addr
operator|=
name|startAddr
expr_stmt|;
comment|/* Now construct each line */
for|for
control|(
name|curLine
operator|=
literal|0
operator|,
name|pc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|startAddr
init|;
operator|(
name|curLine
operator|<
name|maxLines
operator|)
condition|;
control|)
block|{
name|TuiWinElementPtr
name|element
init|=
operator|(
name|TuiWinElementPtr
operator|)
name|disassemWin
operator|->
name|generic
operator|.
name|content
index|[
name|curLine
index|]
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|bp
decl_stmt|;
name|print_address
argument_list|(
name|pc
argument_list|,
name|gdb_dis_out
argument_list|)
expr_stmt|;
name|curLen
operator|=
name|strlen
argument_list|(
name|gdb_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|curLen
operator|-
operator|(
operator|(
name|curLen
operator|/
name|tab_len
operator|)
operator|*
name|tab_len
operator|)
expr_stmt|;
comment|/* adjust buffer length if necessary */
name|gdb_file_adjust_strbuf
argument_list|(
operator|(
name|tab_len
operator|-
name|i
operator|>
literal|0
operator|)
condition|?
operator|(
name|tab_len
operator|-
name|i
operator|)
else|:
literal|0
argument_list|,
name|gdb_dis_out
argument_list|)
expr_stmt|;
comment|/* Add spaces to make the instructions start onthe same column */
while|while
condition|(
name|i
operator|<
name|tab_len
condition|)
block|{
name|gdb_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
index|[
name|curLen
index|]
operator|=
literal|' '
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|curLen
operator|++
expr_stmt|;
block|}
name|gdb_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
index|[
name|curLen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|newpc
operator|=
name|pc
operator|+
operator|(
call|(
modifier|*
name|tm_print_insn
call|)
argument_list|(
name|pc
argument_list|,
operator|&
name|asmInfo
argument_list|)
operator|)
expr_stmt|;
comment|/* Now copy the line taking the offset into account */
if|if
condition|(
name|strlen
argument_list|(
name|gdb_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
argument_list|)
operator|>
name|offset
condition|)
name|strcpy
argument_list|(
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
argument_list|,
operator|&
operator|(
name|gdb_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
index|[
name|offset
index|]
operator|)
argument_list|)
expr_stmt|;
else|else
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
operator|=
operator|(
name|Opaque
operator|)
name|pc
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
operator|=
operator|(
name|pc
operator|==
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
name|TuiWinElementPtr
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
argument_list|)
operator|->
name|whichElement
operator|.
name|locator
operator|.
name|addr
operator|)
expr_stmt|;
name|bp
operator|=
name|_hasBreak
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|hasBreak
operator|=
operator|(
name|bp
operator|!=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|!
name|element
operator|->
name|whichElement
operator|.
name|source
operator|.
name|isExecPoint
operator|||
operator|(
name|bp
operator|->
name|disposition
operator|!=
name|del
operator|||
name|bp
operator|->
name|hit_count
operator|<=
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|curLine
operator|++
expr_stmt|;
name|pc
operator|=
name|newpc
expr_stmt|;
comment|/* reset the buffer to empty */
name|gdb_file_get_strbuf
argument_list|(
name|gdb_dis_out
argument_list|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|gdb_file_deallocate
argument_list|(
operator|&
name|gdb_dis_out
argument_list|)
expr_stmt|;
name|disassemWin
operator|->
name|generic
operator|.
name|contentSize
operator|=
name|curLine
expr_stmt|;
name|ret
operator|=
name|TUI_SUCCESS
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* tuiSetDisassemContent */
end_comment

begin_comment
comment|/* ** tuiShowDisassem(). **        Function to display the disassembly window with disassembled code. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowDisassem
parameter_list|(
name|Opaque
name|startAddr
parameter_list|)
else|#
directive|else
function|tuiShowDisassem
parameter_list|(
name|startAddr
parameter_list|)
name|Opaque
name|startAddr
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|find_pc_symtab
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|startAddr
argument_list|)
decl_stmt|;
name|TuiWinInfoPtr
name|winWithFocus
init|=
name|tuiWinWithFocus
argument_list|()
decl_stmt|;
name|tuiAddWinToLayout
argument_list|(
name|DISASSEM_WIN
argument_list|)
expr_stmt|;
name|tuiUpdateSourceWindow
argument_list|(
name|disassemWin
argument_list|,
name|s
argument_list|,
name|startAddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*     ** if the focus was in the src win, put it in the asm win, if the     ** source view isn't split     */
if|if
condition|(
name|currentLayout
argument_list|()
operator|!=
name|SRC_DISASSEM_COMMAND
operator|&&
name|winWithFocus
operator|==
name|srcWin
condition|)
name|tuiSetWinFocusTo
argument_list|(
name|disassemWin
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowDisassem */
end_comment

begin_comment
comment|/* ** tuiShowDisassemAndUpdateSource(). **        Function to display the disassembly window. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowDisassemAndUpdateSource
parameter_list|(
name|Opaque
name|startAddr
parameter_list|)
else|#
directive|else
function|tuiShowDisassemAndUpdateSource
parameter_list|(
name|startAddr
parameter_list|)
name|Opaque
name|startAddr
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|tuiShowDisassem
argument_list|(
name|startAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentLayout
argument_list|()
operator|==
name|SRC_DISASSEM_COMMAND
condition|)
block|{
name|TuiGenWinInfoPtr
name|locator
init|=
name|locatorWinInfoPtr
argument_list|()
decl_stmt|;
comment|/*         ** Update what is in the source window if it is displayed too,         ** note that it follows what is in the disassembly window and visa-versa         */
name|sal
operator|=
name|find_pc_line
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|startAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|tuiUpdateSourceWindow
argument_list|(
name|srcWin
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
operator|(
name|Opaque
operator|)
name|sal
operator|.
name|line
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tuiUpdateLocatorFilename
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowDisassemAndUpdateSource */
end_comment

begin_comment
comment|/* ** tuiShowDisassemAsIs(). **        Function to display the disassembly window.  This function shows **        the disassembly as specified by the horizontal offset. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiShowDisassemAsIs
parameter_list|(
name|Opaque
name|addr
parameter_list|)
else|#
directive|else
function|tuiShowDisassemAsIs
parameter_list|(
name|addr
parameter_list|)
name|Opaque
name|addr
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiAddWinToLayout
argument_list|(
name|DISASSEM_WIN
argument_list|)
expr_stmt|;
name|tuiUpdateSourceWindowAsIs
argument_list|(
name|disassemWin
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
name|addr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*     ** Update what is in the source window if it is displayed too, not that it     ** follows what is in the disassembly window and visa-versa     */
if|if
condition|(
name|currentLayout
argument_list|()
operator|==
name|SRC_DISASSEM_COMMAND
condition|)
name|tuiShowSourceContent
argument_list|(
name|srcWin
argument_list|)
expr_stmt|;
comment|/*????  Need to do more? */
return|return;
block|}
end_function

begin_comment
comment|/* tuiShowDisassem */
end_comment

begin_comment
comment|/* ** tuiGetBeginAsmAddress(). */
end_comment

begin_function
name|Opaque
ifdef|#
directive|ifdef
name|__STDC__
name|tuiGetBeginAsmAddress
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiGetBeginAsmAddress
parameter_list|()
endif|#
directive|endif
block|{
name|TuiGenWinInfoPtr
name|locator
decl_stmt|;
name|TuiLocatorElementPtr
name|element
decl_stmt|;
name|Opaque
name|addr
decl_stmt|;
name|locator
operator|=
name|locatorWinInfoPtr
argument_list|()
expr_stmt|;
name|element
operator|=
operator|&
operator|(
operator|(
name|TuiWinElementPtr
operator|)
name|locator
operator|->
name|content
index|[
literal|0
index|]
operator|)
operator|->
name|whichElement
operator|.
name|locator
expr_stmt|;
if|if
condition|(
name|element
operator|->
name|addr
operator|==
operator|(
name|Opaque
operator|)
literal|0
condition|)
block|{
comment|/*the target is not executing, because the pc is 0*/
name|addr
operator|=
operator|(
name|Opaque
operator|)
name|parse_and_eval_address
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|Opaque
operator|)
literal|0
condition|)
name|addr
operator|=
operator|(
name|Opaque
operator|)
name|parse_and_eval_address
argument_list|(
literal|"MAIN"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* the target is executing */
name|addr
operator|=
name|element
operator|->
name|addr
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* tuiGetBeginAsmAddress */
end_comment

begin_comment
comment|/* ** tuiVerticalDisassemScroll(). **      Scroll the disassembly forward or backward vertically */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiVerticalDisassemScroll
parameter_list|(
name|TuiScrollDirection
name|scrollDirection
parameter_list|,
name|int
name|numToScroll
parameter_list|)
else|#
directive|else
function|tuiVerticalDisassemScroll
parameter_list|(
name|scrollDirection
parameter_list|,
name|numToScroll
parameter_list|)
name|TuiScrollDirection
name|scrollDirection
decl_stmt|;
name|int
name|numToScroll
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|disassemWin
operator|->
name|generic
operator|.
name|content
operator|!=
operator|(
name|OpaquePtr
operator|)
name|NULL
condition|)
block|{
name|Opaque
name|pc
decl_stmt|,
name|lowAddr
decl_stmt|;
name|TuiWinContent
name|content
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|content
operator|=
operator|(
name|TuiWinContent
operator|)
name|disassemWin
operator|->
name|generic
operator|.
name|content
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
condition|)
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|selected_frame
operator|->
name|pc
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|current_source_symtab
expr_stmt|;
name|pc
operator|=
name|content
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|&
name|lowAddr
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No function contains prgram counter for selected frame.\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|line
init|=
literal|0
decl_stmt|;
specifier|register
name|Opaque
name|newLow
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|newLow
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|scrollDirection
operator|==
name|FORWARD_SCROLL
condition|)
block|{
for|for
control|(
init|;
name|line
operator|<
name|numToScroll
condition|;
name|line
operator|++
control|)
name|newLow
operator|+=
sizeof|sizeof
argument_list|(
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|newLow
operator|>=
operator|(
name|Opaque
operator|)
literal|0
operator|&&
name|line
operator|<
name|numToScroll
condition|;
name|line
operator|++
control|)
name|newLow
operator|-=
sizeof|sizeof
argument_list|(
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tuiUpdateSourceWindowAsIs
argument_list|(
name|disassemWin
argument_list|,
name|s
argument_list|,
name|newLow
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiVerticalDisassemScroll */
end_comment

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS                 ** ******************************************/
end_comment

begin_comment
comment|/* ** _hasBreak(). **      Answer whether there is a break point at the input line in the **      source file indicated */
end_comment

begin_function
specifier|static
name|struct
name|breakpoint
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|_hasBreak
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
else|#
directive|else
function|_hasBreak
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|breakpoint
modifier|*
name|bpWithBreak
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|bp
decl_stmt|;
specifier|extern
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|breakpoint_chain
init|;
operator|(
name|bp
operator|!=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|NULL
operator|&&
name|bpWithBreak
operator|==
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|NULL
operator|)
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|addr
operator|==
name|bp
operator|->
name|address
condition|)
name|bpWithBreak
operator|=
name|bp
expr_stmt|;
return|return
name|bpWithBreak
return|;
block|}
end_function

begin_comment
comment|/* _hasBreak */
end_comment

end_unit

