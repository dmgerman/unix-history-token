begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** tuiDataWin.c **   This module contains functions to support the data/register window display. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"tuiRegs.h"
end_include

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS FORWARD DECLS    ** ******************************************/
end_comment

begin_comment
comment|/***************************************** ** PUBLIC FUNCTIONS                        ** ******************************************/
end_comment

begin_comment
comment|/* ** tuiFirstDataItemDisplayed() **    Answer the index first element displayed. **    If none are displayed, then return (-1). */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiFirstDataItemDisplayed
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiFirstDataItemDisplayed
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|elementNo
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|dataWin
operator|->
name|generic
operator|.
name|contentSize
operator|&&
name|elementNo
operator|<
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|TuiGenWinInfoPtr
name|dataItemWin
decl_stmt|;
name|dataItemWin
operator|=
operator|&
operator|(
operator|(
name|TuiWinContent
operator|)
name|dataWin
operator|->
name|generic
operator|.
name|content
operator|)
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
if|if
condition|(
name|dataItemWin
operator|->
name|handle
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|&&
name|dataItemWin
operator|->
name|isVisible
condition|)
name|elementNo
operator|=
name|i
expr_stmt|;
block|}
return|return
name|elementNo
return|;
block|}
end_function

begin_comment
comment|/* tuiFirstDataItemDisplayed */
end_comment

begin_comment
comment|/* ** tuiFirstDataElementNoInLine() **        Answer the index of the first element in lineNo.  If lineNo is **        past the data area (-1) is returned. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|tuiFirstDataElementNoInLine
parameter_list|(
name|int
name|lineNo
parameter_list|)
else|#
directive|else
function|tuiFirstDataElementNoInLine
parameter_list|(
name|lineNo
parameter_list|)
name|int
name|lineNo
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|firstElementNo
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
comment|/*     ** First see if there is a register on lineNo, and if so, set the     ** first element number     */
if|if
condition|(
operator|(
name|firstElementNo
operator|=
name|tuiFirstRegElementNoInLine
argument_list|(
name|lineNo
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*       ** Looking at the general data, the 1st element on lineNo       */
block|}
return|return
name|firstElementNo
return|;
block|}
end_function

begin_comment
comment|/* tuiFirstDataElementNoInLine */
end_comment

begin_comment
comment|/* ** tuiDeleteDataContentWindows() **        Function to delete all the item windows in the data window. **        This is usually done when the data window is scrolled. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDeleteDataContentWindows
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiDeleteDataContentWindows
parameter_list|()
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|TuiGenWinInfoPtr
name|dataItemWinPtr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|dataWin
operator|->
name|generic
operator|.
name|contentSize
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dataItemWinPtr
operator|=
operator|&
operator|(
operator|(
name|TuiWinContent
operator|)
name|dataWin
operator|->
name|generic
operator|.
name|content
operator|)
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
name|tuiDelwin
argument_list|(
name|dataItemWinPtr
operator|->
name|handle
argument_list|)
expr_stmt|;
name|dataItemWinPtr
operator|->
name|handle
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|dataItemWinPtr
operator|->
name|isVisible
operator|=
name|FALSE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDeleteDataContentWindows */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiEraseDataContent
parameter_list|(
name|char
modifier|*
name|prompt
parameter_list|)
else|#
directive|else
function|tuiEraseDataContent
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
endif|#
directive|endif
block|{
name|werase
argument_list|(
name|dataWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
name|checkAndDisplayHighlightIfNeeded
argument_list|(
name|dataWin
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|halfWidth
init|=
operator|(
name|dataWin
operator|->
name|generic
operator|.
name|width
operator|-
literal|2
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|xPos
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|prompt
argument_list|)
operator|>=
name|halfWidth
condition|)
name|xPos
operator|=
literal|1
expr_stmt|;
else|else
name|xPos
operator|=
name|halfWidth
operator|-
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|dataWin
operator|->
name|generic
operator|.
name|handle
argument_list|,
operator|(
name|dataWin
operator|->
name|generic
operator|.
name|height
operator|/
literal|2
operator|)
argument_list|,
name|xPos
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
block|}
name|wrefresh
argument_list|(
name|dataWin
operator|->
name|generic
operator|.
name|handle
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tuiEraseDataContent */
end_comment

begin_comment
comment|/* ** tuiDisplayAllData(). **        This function displays the data that is in the data window's **        content.  It does not set the content. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayAllData
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiDisplayAllData
parameter_list|()
endif|#
directive|endif
block|{
if|if
condition|(
name|dataWin
operator|->
name|generic
operator|.
name|contentSize
operator|<=
literal|0
condition|)
name|tuiEraseDataContent
argument_list|(
name|NO_DATA_STRING
argument_list|)
expr_stmt|;
else|else
block|{
name|tuiEraseDataContent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tuiDeleteDataContentWindows
argument_list|()
expr_stmt|;
name|checkAndDisplayHighlightIfNeeded
argument_list|(
name|dataWin
argument_list|)
expr_stmt|;
name|tuiDisplayRegistersFrom
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*         ** Then display the other data         */
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
operator|!=
operator|(
name|TuiWinContent
operator|)
name|NULL
operator|&&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|>
literal|0
condition|)
block|{ 	}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDisplayAllData */
end_comment

begin_comment
comment|/* ** tuiDisplayDataFromLine() **        Function to display the data starting at line, lineNo, in the **        data window. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayDataFromLine
parameter_list|(
name|int
name|lineNo
parameter_list|)
else|#
directive|else
function|tuiDisplayDataFromLine
parameter_list|(
name|lineNo
parameter_list|)
name|int
name|lineNo
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|_lineNo
init|=
name|lineNo
decl_stmt|;
if|if
condition|(
name|lineNo
operator|<
literal|0
condition|)
name|_lineNo
operator|=
literal|0
expr_stmt|;
name|checkAndDisplayHighlightIfNeeded
argument_list|(
name|dataWin
argument_list|)
expr_stmt|;
comment|/* there is no general data, force regs to display (if there are any) */
if|if
condition|(
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
operator|<=
literal|0
condition|)
name|tuiDisplayRegistersFromLine
argument_list|(
name|_lineNo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|elementNo
decl_stmt|,
name|startLineNo
decl_stmt|;
name|int
name|regsLastLine
init|=
name|tuiLastRegsLineNo
argument_list|()
decl_stmt|;
comment|/* display regs if we can */
if|if
condition|(
name|tuiDisplayRegistersFromLine
argument_list|(
name|_lineNo
argument_list|,
name|FALSE
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/*             ** _lineNo is past the regs display, so calc where the             ** start data element is             */
if|if
condition|(
name|regsLastLine
operator|<
name|_lineNo
condition|)
block|{
comment|/* figure out how many lines each element is to obtain                     the start elementNo */
block|}
block|}
else|else
block|{
comment|/*            ** calculate the starting element of the data display, given            ** regsLastLine and how many lines each element is, up to            ** _lineNo            */
block|}
comment|/* Now display the data , starting at elementNo */
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDisplayDataFromLine */
end_comment

begin_comment
comment|/* ** tuiDisplayDataFrom() **        Display data starting at element elementNo */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiDisplayDataFrom
parameter_list|(
name|int
name|elementNo
parameter_list|,
name|int
name|reuseWindows
parameter_list|)
else|#
directive|else
function|tuiDisplayDataFrom
parameter_list|(
name|elementNo
parameter_list|,
name|reuseWindows
parameter_list|)
name|int
name|elementNo
decl_stmt|;
name|int
name|reuseWindows
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|firstLine
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|elementNo
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
condition|)
name|firstLine
operator|=
name|tuiLineFromRegElementNo
argument_list|(
name|elementNo
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* calculate the firstLine from the element number */
block|}
if|if
condition|(
name|firstLine
operator|>=
literal|0
condition|)
block|{
name|tuiEraseDataContent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reuseWindows
condition|)
name|tuiDeleteDataContentWindows
argument_list|()
expr_stmt|;
name|tuiDisplayDataFromLine
argument_list|(
name|firstLine
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiDisplayDataFrom */
end_comment

begin_comment
comment|/* ** tuiRefreshDataWin() **        Function to redisplay the contents of the data window. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiRefreshDataWin
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|tuiRefreshDataWin
parameter_list|()
endif|#
directive|endif
block|{
name|tuiEraseDataContent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataWin
operator|->
name|generic
operator|.
name|contentSize
operator|>
literal|0
condition|)
block|{
name|int
name|firstElement
init|=
name|tuiFirstDataItemDisplayed
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstElement
operator|>=
literal|0
condition|)
comment|/* re-use existing windows */
name|tuiDisplayDataFrom
argument_list|(
name|firstElement
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiRefreshDataWin */
end_comment

begin_comment
comment|/* ** tuiCheckDataValues(). **        Function to check the data values and hilite any that have changed */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiCheckDataValues
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
else|#
directive|else
function|tuiCheckDataValues
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
endif|#
directive|endif
block|{
name|tuiCheckRegisterValues
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* Now check any other data values that there are */
if|if
condition|(
name|m_winPtrNotNull
argument_list|(
name|dataWin
argument_list|)
operator|&&
name|dataWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContentCount
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|LATER
name|TuiDataElementPtr
name|dataElementPtr
decl_stmt|;
name|TuiGenWinInfoPtr
name|dataItemWinPtr
decl_stmt|;
name|Opaque
name|newValue
decl_stmt|;
name|dataItemPtr
operator|=
operator|&
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|dataContent
index|[
name|i
index|]
operator|->
name|whichElement
operator|.
name|dataWindow
expr_stmt|;
name|dataElementPtr
operator|=
operator|&
operator|(
operator|(
name|TuiWinContent
operator|)
name|dataItemWinPtr
operator|->
name|content
operator|)
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|data
expr_stmt|;
if|if value 	    has changed
condition|(
name|dataElementPtr
operator|,
name|frame
operator|,
operator|&
name|newValue
condition|)
block|{
name|dataElementPtr
operator|->
name|value
operator|=
name|newValue
expr_stmt|;
name|update
name|the
name|display
name|with
name|the
name|new
name|value
decl_stmt|,
name|hiliting
name|it
operator|.
decl|}
endif|#
directive|endif
block|}
block|}
block|}
comment|/* tuiCheckDataValues */
comment|/* ** tui_vCheckDataValues(). **        Function to check the data values and hilite any that have **        changed with args in a va_list */
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tui_vCheckDataValues
parameter_list|(
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|tui_vCheckDataValues
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
expr|struct
name|frame_info
operator|*
argument_list|)
decl_stmt|;
name|tuiCheckDataValues
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* tui_vCheckDataValues */
comment|/* ** tuiVerticalDataScroll() **        Scroll the data window vertically forward or backward. */
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tuiVerticalDataScroll
parameter_list|(
name|TuiScrollDirection
name|scrollDirection
parameter_list|,
name|int
name|numToScroll
parameter_list|)
else|#
directive|else
function|tuiVerticalDataScroll
parameter_list|(
name|scrollDirection
parameter_list|,
name|numToScroll
parameter_list|)
name|TuiScrollDirection
name|scrollDirection
decl_stmt|;
name|int
name|numToScroll
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|firstElementNo
decl_stmt|;
name|int
name|firstLine
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|firstElementNo
operator|=
name|tuiFirstDataItemDisplayed
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstElementNo
operator|<
name|dataWin
operator|->
name|detail
operator|.
name|dataDisplayInfo
operator|.
name|regsContentCount
condition|)
name|firstLine
operator|=
name|tuiLineFromRegElementNo
argument_list|(
name|firstElementNo
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* calculate the first line from the element number which is in         ** the general data content         */
block|}
if|if
condition|(
name|firstLine
operator|>=
literal|0
condition|)
block|{
name|int
name|lastElementNo
decl_stmt|,
name|lastLine
decl_stmt|;
if|if
condition|(
name|scrollDirection
operator|==
name|FORWARD_SCROLL
condition|)
name|firstLine
operator|+=
name|numToScroll
expr_stmt|;
else|else
name|firstLine
operator|-=
name|numToScroll
expr_stmt|;
name|tuiEraseDataContent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tuiDeleteDataContentWindows
argument_list|()
expr_stmt|;
name|tuiDisplayDataFromLine
argument_list|(
name|firstLine
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* tuiVerticalDataScroll */
end_comment

begin_comment
comment|/***************************************** ** STATIC LOCAL FUNCTIONS               ** ******************************************/
end_comment

end_unit

