begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Serial interface for local (hardwired) serial ports on Un*x like systems    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"ser-unix.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
end_ifdef

begin_struct
struct|struct
name|hardwire_ttystate
block|{
name|struct
name|termios
name|termios
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* termios */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_comment
comment|/* It is believed that all systems which have added job control to SVR3    (e.g. sco) have also added termios.  Even if not, trying to figure out    all the variations (TIOCGPGRP vs. TCGETPGRP, etc.) would be pretty    bewildering.  So we don't attempt it.  */
end_comment

begin_struct
struct|struct
name|hardwire_ttystate
block|{
name|struct
name|termio
name|termio
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* termio */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SGTTY
end_ifdef

begin_struct
struct|struct
name|hardwire_ttystate
block|{
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
name|struct
name|tchars
name|tc
decl_stmt|;
name|struct
name|ltchars
name|ltc
decl_stmt|;
comment|/* Line discipline flags.  */
name|int
name|lmode
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgtty */
end_comment

begin_function_decl
specifier|static
name|int
name|hardwire_open
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hardwire_raw
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_for
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_hardwire_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|generic_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
function_decl|(
modifier|*
name|do_readchar
function_decl|)
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rate_to_code
parameter_list|(
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_setbaudrate
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hardwire_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|struct
name|hardwire_ttystate
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|struct
name|hardwire_ttystate
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|serial_ttystate
name|hardwire_get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_noflush_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|,
name|serial_ttystate
parameter_list|,
name|serial_ttystate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hardwire_print_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|,
name|serial_ttystate
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_drain_output
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_flush_output
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_flush_input
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_send_break
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hardwire_setstopbits
parameter_list|(
name|struct
name|serial
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_unix_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timer_handler_func
name|push_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|handler_func
name|fd_event
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|reschedule
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_ser_hardwire
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ui_loop_hook
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Open up a real live device for serial I/O */
end_comment

begin_function
specifier|static
name|int
name|hardwire_open
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|scb
operator|->
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|struct
name|hardwire_ttystate
modifier|*
name|state
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
if|if
condition|(
name|tcgetattr
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
operator|&
name|state
operator|->
name|termios
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|state
operator|->
name|termio
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|state
operator|->
name|sgttyb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|state
operator|->
name|tc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|state
operator|->
name|ltc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|state
operator|->
name|lmode
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|struct
name|hardwire_ttystate
modifier|*
name|state
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
if|if
condition|(
name|tcsetattr
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|state
operator|->
name|termios
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|state
operator|->
name|termio
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|state
operator|->
name|sgttyb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|state
operator|->
name|tc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|state
operator|->
name|ltc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|state
operator|->
name|lmode
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|serial_ttystate
name|hardwire_get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|hardwire_ttystate
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_tty_state
argument_list|(
name|scb
argument_list|,
name|state
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|serial_ttystate
operator|)
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|hardwire_ttystate
operator|*
operator|)
name|ttystate
expr_stmt|;
return|return
name|set_tty_state
argument_list|(
name|scb
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_noflush_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|new_ttystate
parameter_list|,
name|serial_ttystate
name|old_ttystate
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
name|new_state
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|struct
name|hardwire_ttystate
modifier|*
name|state
init|=
operator|(
expr|struct
name|hardwire_ttystate
operator|*
operator|)
name|old_ttystate
decl_stmt|;
endif|#
directive|endif
name|new_state
operator|=
operator|*
operator|(
expr|struct
name|hardwire_ttystate
operator|*
operator|)
name|new_ttystate
expr_stmt|;
comment|/* Don't change in or out of raw mode; we don't want to flush input.      termio and termios have no such restriction; for them flushing input      is separate from setting the attributes.  */
ifdef|#
directive|ifdef
name|HAVE_SGTTY
if|if
condition|(
name|state
operator|->
name|sgttyb
operator|.
name|sg_flags
operator|&
name|RAW
condition|)
name|new_state
operator|.
name|sgttyb
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
else|else
name|new_state
operator|.
name|sgttyb
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
expr_stmt|;
comment|/* I'm not sure whether this is necessary; the manpage just mentions      RAW not CBREAK.  */
if|if
condition|(
name|state
operator|->
name|sgttyb
operator|.
name|sg_flags
operator|&
name|CBREAK
condition|)
name|new_state
operator|.
name|sgttyb
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
else|else
name|new_state
operator|.
name|sgttyb
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
endif|#
directive|endif
return|return
name|set_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|new_state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hardwire_print_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
modifier|*
name|state
init|=
operator|(
expr|struct
name|hardwire_ttystate
operator|*
operator|)
name|ttystate
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"c_iflag = 0x%x, c_oflag = 0x%x,\n"
argument_list|,
operator|(
name|int
operator|)
name|state
operator|->
name|termios
operator|.
name|c_iflag
argument_list|,
operator|(
name|int
operator|)
name|state
operator|->
name|termios
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"c_cflag = 0x%x, c_lflag = 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|state
operator|->
name|termios
operator|.
name|c_cflag
argument_list|,
operator|(
name|int
operator|)
name|state
operator|->
name|termios
operator|.
name|c_lflag
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This not in POSIX, and is not really documented by those systems      which have it (at least not Sun).  */
block|fprintf_filtered (stream, "c_line = 0x%x.\n", state->termios.c_line);
endif|#
directive|endif
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"c_cc: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCS
condition|;
name|i
operator|+=
literal|1
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x "
argument_list|,
name|state
operator|->
name|termios
operator|.
name|c_cc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"c_iflag = 0x%x, c_oflag = 0x%x,\n"
argument_list|,
name|state
operator|->
name|termio
operator|.
name|c_iflag
argument_list|,
name|state
operator|->
name|termio
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"c_cflag = 0x%x, c_lflag = 0x%x, c_line = 0x%x.\n"
argument_list|,
name|state
operator|->
name|termio
operator|.
name|c_cflag
argument_list|,
name|state
operator|->
name|termio
operator|.
name|c_lflag
argument_list|,
name|state
operator|->
name|termio
operator|.
name|c_line
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"c_cc: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCC
condition|;
name|i
operator|+=
literal|1
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x "
argument_list|,
name|state
operator|->
name|termio
operator|.
name|c_cc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"sgttyb.sg_flags = 0x%x.\n"
argument_list|,
name|state
operator|->
name|sgttyb
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"tchars: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|tchars
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x "
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|state
operator|->
name|tc
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"ltchars: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ltchars
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x "
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|state
operator|->
name|ltc
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"lmode:  0x%x\n"
argument_list|,
name|state
operator|->
name|lmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Wait for the output to drain away, as opposed to flushing (discarding) it */
end_comment

begin_function
specifier|static
name|int
name|hardwire_drain_output
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
return|return
name|tcdrain
argument_list|(
name|scb
operator|->
name|fd
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
return|return
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCSBRK
argument_list|,
literal|1
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
comment|/* Get the current state and then restore it using TIOCSETP,      which should cause the output to drain and pending input      to be discarded. */
block|{
name|struct
name|hardwire_ttystate
name|state
decl_stmt|;
if|if
condition|(
name|get_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|state
operator|.
name|sgttyb
argument_list|)
operator|)
return|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_flush_output
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
return|return
name|tcflush
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCOFLUSH
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
return|return
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCFLSH
argument_list|,
literal|1
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
comment|/* This flushes both input and output, but we can't do better.  */
return|return
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCFLUSH
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_flush_input
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|ser_unix_flush_input
argument_list|(
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
return|return
name|tcflush
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCIFLUSH
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
return|return
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCFLSH
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
comment|/* This flushes both input and output, but we can't do better.  */
return|return
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCFLUSH
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_send_break
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
return|return
name|tcsendbreak
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
return|return
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TCSBRK
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
block|{
name|int
name|status
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|status
operator|=
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCSBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Can't use usleep; it doesn't exist in BSD 4.2.  */
comment|/* Note that if this select() is interrupted by a signal it will not wait        the full length of time.  I think that is OK.  */
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|250000
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|status
operator|=
name|ioctl
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|TIOCCBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|hardwire_raw
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
name|state
decl_stmt|;
if|if
condition|(
name|get_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"get_tty_state failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|state
operator|.
name|termios
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cflag
operator||=
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|state
operator|.
name|termio
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cflag
operator||=
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|state
operator|.
name|sgttyb
operator|.
name|sg_flags
operator||=
name|RAW
operator||
name|ANYP
expr_stmt|;
name|state
operator|.
name|sgttyb
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|CBREAK
operator||
name|ECHO
operator|)
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|current_timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"set_tty_state failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for input on scb, with timeout seconds.  Returns 0 on success,    otherwise SERIAL_TIMEOUT or SERIAL_ERROR.     For termio{s}, we actually just setup VTIME if necessary, and let the    timeout occur in the read() in hardwire_read().  */
end_comment

begin_comment
comment|/* FIXME: cagney/1999-09-16: Don't replace this with the equivalent    ser_unix*() until the old TERMIOS/SGTTY/... timer code has been    flushed. . */
end_comment

begin_comment
comment|/* NOTE: cagney/1999-09-30: Much of the code below is dead.  The only    possible values of the TIMEOUT parameter are ONE and ZERO.    Consequently all the code that tries to handle the possability of    an overflowed timer is unnecessary. */
end_comment

begin_function
specifier|static
name|int
name|wait_for
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SGTTY
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|int
name|numfds
decl_stmt|;
comment|/* NOTE: Some OS's can scramble the READFDS when the select()          call fails (ex the kernel with Red Hat 5.2).  Initialize all          arguments before each call. */
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>=
literal|0
condition|)
name|numfds
operator|=
name|select
argument_list|(
name|scb
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
else|else
name|numfds
operator|=
name|select
argument_list|(
name|scb
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<=
literal|0
condition|)
if|if
condition|(
name|numfds
operator|==
literal|0
condition|)
return|return
name|SERIAL_TIMEOUT
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
else|else
return|return
name|SERIAL_ERROR
return|;
comment|/* Got an error from select or poll */
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SGTTY */
if|#
directive|if
name|defined
name|HAVE_TERMIO
operator|||
name|defined
name|HAVE_TERMIOS
if|if
condition|(
name|timeout
operator|==
name|scb
operator|->
name|current_timeout
condition|)
return|return
literal|0
return|;
name|scb
operator|->
name|current_timeout
operator|=
name|timeout
expr_stmt|;
block|{
name|struct
name|hardwire_ttystate
name|state
decl_stmt|;
if|if
condition|(
name|get_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"get_tty_state failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
comment|/* No timeout.  */
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
name|timeout
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|!=
name|timeout
operator|*
literal|10
condition|)
block|{
comment|/* If c_cc is an 8-bit signed character, we can't go  	       bigger than this.  If it is always unsigned, we could use 	       25.  */
name|scb
operator|->
name|current_timeout
operator|=
literal|12
expr_stmt|;
name|state
operator|.
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
name|scb
operator|->
name|current_timeout
operator|*
literal|10
expr_stmt|;
name|scb
operator|->
name|timeout_remaining
operator|=
name|timeout
operator|-
name|scb
operator|->
name|current_timeout
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
comment|/* No timeout.  */
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
name|timeout
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|!=
name|timeout
operator|*
literal|10
condition|)
block|{
comment|/* If c_cc is an 8-bit signed character, we can't go  	       bigger than this.  If it is always unsigned, we could use 	       25.  */
name|scb
operator|->
name|current_timeout
operator|=
literal|12
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
name|scb
operator|->
name|current_timeout
operator|*
literal|10
expr_stmt|;
name|scb
operator|->
name|timeout_remaining
operator|=
name|timeout
operator|-
name|scb
operator|->
name|current_timeout
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|set_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"set_tty_state failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIO || HAVE_TERMIOS */
block|}
end_function

begin_comment
comment|/* Read a character with user-specified timeout.  TIMEOUT is number of seconds    to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns    char if successful.  Returns SERIAL_TIMEOUT if timeout expired, EOF if line    dropped dead, or SERIAL_ERROR for any other error (see errno in that case).  */
end_comment

begin_comment
comment|/* FIXME: cagney/1999-09-16: Don't replace this with the equivalent    ser_unix*() until the old TERMIOS/SGTTY/... timer code has been    flushed. */
end_comment

begin_comment
comment|/* NOTE: cagney/1999-09-16: This function is not identical to    ser_unix_readchar() as part of replacing it with ser_unix*()    merging will be required - this code handles the case where read()    times out due to no data while ser_unix_readchar() doesn't expect    that. */
end_comment

begin_function
specifier|static
name|int
name|do_hardwire_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|detach
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|timeout
operator|++
expr_stmt|;
comment|/* We have to be able to keep the GUI alive here, so we break the original      timeout into steps of 1 second, running the "keep the GUI alive" hook       each time through the loop.      Also, timeout = 0 means to poll, so we just set the delta to 0, so we      will only go through the loop once. */
name|delta
operator|=
operator|(
name|timeout
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* N.B. The UI may destroy our world (for instance by calling          remote_stop,) in which case we want to get out of here as          quickly as possible.  It is not safe to touch scb, since          someone else might have freed it.  The ui_loop_hook signals that           we should exit by returning 1. */
if|if
condition|(
name|ui_loop_hook
condition|)
name|detach
operator|=
name|ui_loop_hook
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|detach
condition|)
return|return
name|SERIAL_TIMEOUT
return|;
name|scb
operator|->
name|timeout_remaining
operator|=
operator|(
name|timeout
operator|<
literal|0
condition|?
name|timeout
else|:
name|timeout
operator|-
name|delta
operator|)
expr_stmt|;
name|status
operator|=
name|wait_for
argument_list|(
name|scb
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|status
operator|=
name|read
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|scb
operator|->
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* Zero characters means timeout (it could also be EOF, but 	         we don't (yet at least) distinguish).  */
if|if
condition|(
name|scb
operator|->
name|timeout_remaining
operator|>
literal|0
condition|)
block|{
name|timeout
operator|=
name|scb
operator|->
name|timeout_remaining
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|timeout_remaining
operator|<
literal|0
condition|)
continue|continue;
else|else
return|return
name|SERIAL_TIMEOUT
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
else|else
return|return
name|SERIAL_ERROR
return|;
comment|/* Got an error from read */
block|}
name|scb
operator|->
name|bufcnt
operator|=
name|status
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|--
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
return|return
operator|*
name|scb
operator|->
name|bufp
operator|++
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
name|generic_readchar
argument_list|(
name|scb
argument_list|,
name|timeout
argument_list|,
name|do_hardwire_readchar
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|B19200
end_ifndef

begin_define
define|#
directive|define
name|B19200
value|EXTA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|B38400
end_ifndef

begin_define
define|#
directive|define
name|B38400
value|EXTB
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate baud rates from integers to damn B_codes.  Unix should    have outgrown this crap years ago, but even POSIX wouldn't buck it.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|rate
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|baudtab
index|[]
init|=
block|{
block|{
literal|50
block|,
name|B50
block|}
block|,
block|{
literal|75
block|,
name|B75
block|}
block|,
block|{
literal|110
block|,
name|B110
block|}
block|,
block|{
literal|134
block|,
name|B134
block|}
block|,
block|{
literal|150
block|,
name|B150
block|}
block|,
block|{
literal|200
block|,
name|B200
block|}
block|,
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|600
block|,
name|B600
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|1800
block|,
name|B1800
block|}
block|,
block|{
literal|2400
block|,
name|B2400
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
block|{
literal|9600
block|,
name|B9600
block|}
block|,
block|{
literal|19200
block|,
name|B19200
block|}
block|,
block|{
literal|38400
block|,
name|B38400
block|}
block|,
ifdef|#
directive|ifdef
name|B57600
block|{
literal|57600
block|,
name|B57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
literal|115200
block|,
name|B115200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B230400
block|{
literal|230400
block|,
name|B230400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B460800
block|{
literal|460800
block|,
name|B460800
block|}
block|,
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|rate_to_code
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|baudtab
index|[
name|i
index|]
operator|.
name|rate
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* test for perfect macth. */
if|if
condition|(
name|rate
operator|==
name|baudtab
index|[
name|i
index|]
operator|.
name|rate
condition|)
return|return
name|baudtab
index|[
name|i
index|]
operator|.
name|code
return|;
else|else
block|{
comment|/* check if it is in between valid values. */
if|if
condition|(
name|rate
operator|<
name|baudtab
index|[
name|i
index|]
operator|.
name|rate
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|warning
argument_list|(
literal|"Invalid baud rate %d.  Closest values are %d and %d."
argument_list|,
name|rate
argument_list|,
name|baudtab
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rate
argument_list|,
name|baudtab
index|[
name|i
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Invalid baud rate %d.  Minimum value is %d."
argument_list|,
name|rate
argument_list|,
name|baudtab
index|[
literal|0
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|/* The requested speed was too large. */
name|warning
argument_list|(
literal|"Invalid baud rate %d.  Maximum value is %d."
argument_list|,
name|rate
argument_list|,
name|baudtab
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_setbaudrate
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
name|state
decl_stmt|;
name|int
name|baud_code
init|=
name|rate_to_code
argument_list|(
name|rate
argument_list|)
decl_stmt|;
if|if
condition|(
name|baud_code
operator|<
literal|0
condition|)
block|{
comment|/* The baud rate was not valid.          A warning has already been issued. */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|get_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|cfsetospeed
argument_list|(
operator|&
name|state
operator|.
name|termios
argument_list|,
name|baud_code
argument_list|)
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|state
operator|.
name|termios
argument_list|,
name|baud_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
ifndef|#
directive|ifndef
name|CIBAUD
define|#
directive|define
name|CIBAUD
value|CBAUD
endif|#
directive|endif
name|state
operator|.
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CBAUD
operator||
name|CIBAUD
operator|)
expr_stmt|;
name|state
operator|.
name|termio
operator|.
name|c_cflag
operator||=
name|baud_code
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
name|state
operator|.
name|sgttyb
operator|.
name|sg_ispeed
operator|=
name|baud_code
expr_stmt|;
name|state
operator|.
name|sgttyb
operator|.
name|sg_ospeed
operator|=
name|baud_code
expr_stmt|;
endif|#
directive|endif
return|return
name|set_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hardwire_setstopbits
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|hardwire_ttystate
name|state
decl_stmt|;
name|int
name|newbit
decl_stmt|;
if|if
condition|(
name|get_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
name|SERIAL_1_STOPBITS
case|:
name|newbit
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SERIAL_1_AND_A_HALF_STOPBITS
case|:
case|case
name|SERIAL_2_STOPBITS
case|:
name|newbit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
if|if
condition|(
operator|!
name|newbit
condition|)
name|state
operator|.
name|termios
operator|.
name|c_cflag
operator|&=
operator|~
name|CSTOPB
expr_stmt|;
else|else
name|state
operator|.
name|termios
operator|.
name|c_cflag
operator||=
name|CSTOPB
expr_stmt|;
comment|/* two bits */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
if|if
condition|(
operator|!
name|newbit
condition|)
name|state
operator|.
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
name|CSTOPB
expr_stmt|;
else|else
name|state
operator|.
name|termio
operator|.
name|c_cflag
operator||=
name|CSTOPB
expr_stmt|;
comment|/* two bits */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SGTTY
return|return
literal|0
return|;
comment|/* sgtty doesn't support this */
endif|#
directive|endif
return|return
name|set_tty_state
argument_list|(
name|scb
argument_list|,
operator|&
name|state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hardwire_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|fd
operator|<
literal|0
condition|)
return|return;
name|close
argument_list|(
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic operations used by all UNIX/FD based serial interfaces. */
end_comment

begin_function
name|serial_ttystate
name|ser_unix_nop_get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
comment|/* allocate a dummy */
return|return
operator|(
name|serial_ttystate
operator|)
name|XMALLOC
argument_list|(
name|int
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_nop_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ser_unix_nop_raw
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return;
comment|/* Always in raw mode */
block|}
end_function

begin_comment
comment|/* Wait for input on scb, with timeout seconds.  Returns 0 on success,    otherwise SERIAL_TIMEOUT or SERIAL_ERROR. */
end_comment

begin_function
name|int
name|ser_unix_wait_for
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|numfds
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|,
name|exceptfds
decl_stmt|;
comment|/* NOTE: Some OS's can scramble the READFDS when the select()          call fails (ex the kernel with Red Hat 5.2).  Initialize all          arguments before each call. */
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>=
literal|0
condition|)
name|numfds
operator|=
name|select
argument_list|(
name|scb
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
else|else
name|numfds
operator|=
name|select
argument_list|(
name|scb
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
operator|&
name|exceptfds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|numfds
operator|==
literal|0
condition|)
return|return
name|SERIAL_TIMEOUT
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
else|else
return|return
name|SERIAL_ERROR
return|;
comment|/* Got an error from select or poll */
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read a character with user-specified timeout.  TIMEOUT is number of seconds    to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns    char if successful.  Returns -2 if timeout expired, EOF if line dropped    dead, or -3 for any other error (see errno in that case). */
end_comment

begin_function
specifier|static
name|int
name|do_unix_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|delta
decl_stmt|;
comment|/* We have to be able to keep the GUI alive here, so we break the original      timeout into steps of 1 second, running the "keep the GUI alive" hook       each time through the loop.       Also, timeout = 0 means to poll, so we just set the delta to 0, so we      will only go through the loop once. */
name|delta
operator|=
operator|(
name|timeout
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* N.B. The UI may destroy our world (for instance by calling          remote_stop,) in which case we want to get out of here as          quickly as possible.  It is not safe to touch scb, since          someone else might have freed it.  The ui_loop_hook signals that           we should exit by returning 1. */
if|if
condition|(
name|ui_loop_hook
condition|)
block|{
if|if
condition|(
name|ui_loop_hook
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|SERIAL_TIMEOUT
return|;
block|}
name|status
operator|=
name|ser_unix_wait_for
argument_list|(
name|scb
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|timeout
operator|-=
name|delta
expr_stmt|;
comment|/* If we got a character or an error back from wait_for, then we can           break from the loop before the timeout is completed. */
if|if
condition|(
name|status
operator|!=
name|SERIAL_TIMEOUT
condition|)
block|{
break|break;
block|}
comment|/* If we have exhausted the original timeout, then generate          a SERIAL_TIMEOUT, and pass it out of the loop. */
elseif|else
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|SERIAL_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|read
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|scb
operator|->
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINTR
condition|)
break|break;
block|}
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|SERIAL_TIMEOUT
return|;
comment|/* 0 chars means timeout [may need to 				   distinguish between EOF& timeouts 				   someday] */
else|else
return|return
name|SERIAL_ERROR
return|;
comment|/* Got an error from read */
block|}
name|scb
operator|->
name|bufcnt
operator|=
name|status
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|--
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
return|return
operator|*
name|scb
operator|->
name|bufp
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Perform operations common to both old and new readchar. */
end_comment

begin_comment
comment|/* Return the next character from the input FIFO.  If the FIFO is    empty, call the SERIAL specific routine to try and read in more    characters.     Initially data from the input FIFO is returned (fd_event()    pre-reads the input into that FIFO.  Once that has been emptied,    further data is obtained by polling the input FD using the device    specific readchar() function.  Note: reschedule() is called after    every read.  This is because there is no guarentee that the lower    level fd_event() poll_event() code (which also calls reschedule())    will be called. */
end_comment

begin_function
specifier|static
name|int
name|generic_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
function_decl|(
name|do_readchar
function_decl|)
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|scb
operator|->
name|bufp
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|--
expr_stmt|;
name|scb
operator|->
name|bufp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|<
literal|0
condition|)
block|{
comment|/* Some errors/eof are are sticky. */
name|ch
operator|=
name|scb
operator|->
name|bufcnt
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|do_readchar
argument_list|(
name|scb
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
expr|enum
name|serial_rc
operator|)
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
case|case
name|SERIAL_ERROR
case|:
comment|/* Make the error/eof stick. */
name|scb
operator|->
name|bufcnt
operator|=
name|ch
expr_stmt|;
break|break;
case|case
name|SERIAL_TIMEOUT
case|:
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|reschedule
argument_list|(
name|scb
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
name|generic_readchar
argument_list|(
name|scb
argument_list|,
name|timeout
argument_list|,
name|do_unix_readchar
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_nop_noflush_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|new_ttystate
parameter_list|,
name|serial_ttystate
name|old_ttystate
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ser_unix_nop_print_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* Nothing to print.  */
return|return;
block|}
end_function

begin_function
name|int
name|ser_unix_nop_setbaudrate
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
return|return
literal|0
return|;
comment|/* Never fails! */
block|}
end_function

begin_function
name|int
name|ser_unix_nop_setstopbits
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|num
parameter_list|)
block|{
return|return
literal|0
return|;
comment|/* Never fails! */
block|}
end_function

begin_function
name|int
name|ser_unix_write
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cc
operator|=
name|write
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|len
operator|-=
name|cc
expr_stmt|;
name|str
operator|+=
name|cc
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_nop_flush_output
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_flush_input
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|>=
literal|0
condition|)
block|{
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|SERIAL_ERROR
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_nop_send_break
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ser_unix_nop_drain_output
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Event handling for ASYNC serial code.     At any time the SERIAL device either: has an empty FIFO and is    waiting on a FD event; or has a non-empty FIFO/error condition and    is constantly scheduling timer events.     ASYNC only stops pestering its client when it is de-async'ed or it    is told to go away. */
end_comment

begin_comment
comment|/* Value of scb->async_state: */
end_comment

begin_enum
enum|enum
block|{
comment|/*>= 0 (TIMER_SCHEDULED) */
comment|/* The ID of the currently scheduled timer event. This state is      rarely encountered.  Timer events are one-off so as soon as the      event is delivered the state is shanged to NOTHING_SCHEDULED. */
name|FD_SCHEDULED
init|=
operator|-
literal|1
block|,
comment|/* The fd_event() handler is scheduled.  It is called when ever the      file descriptor becomes ready. */
name|NOTHING_SCHEDULED
init|=
operator|-
literal|2
comment|/* Either no task is scheduled (just going into ASYNC mode) or a      timer event has just gone off and the current state has been      forced into nothing scheduled. */
block|}
enum|;
end_enum

begin_comment
comment|/* Identify and schedule the next ASYNC task based on scb->async_state    and scb->buf* (the input FIFO).  A state machine is used to avoid    the need to make redundant calls into the event-loop - the next    scheduled task is only changed when needed. */
end_comment

begin_function
specifier|static
name|void
name|reschedule
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|serial_is_async_p
argument_list|(
name|scb
argument_list|)
condition|)
block|{
name|int
name|next_state
decl_stmt|;
switch|switch
condition|(
name|scb
operator|->
name|async_state
condition|)
block|{
case|case
name|FD_SCHEDULED
case|:
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|==
literal|0
condition|)
name|next_state
operator|=
name|FD_SCHEDULED
expr_stmt|;
else|else
block|{
name|delete_file_handler
argument_list|(
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
name|next_state
operator|=
name|create_timer
argument_list|(
literal|0
argument_list|,
name|push_event
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOTHING_SCHEDULED
case|:
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|==
literal|0
condition|)
block|{
name|add_file_handler
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|fd_event
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|next_state
operator|=
name|FD_SCHEDULED
expr_stmt|;
block|}
else|else
block|{
name|next_state
operator|=
name|create_timer
argument_list|(
literal|0
argument_list|,
name|push_event
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* TIMER SCHEDULED */
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|==
literal|0
condition|)
block|{
name|delete_timer
argument_list|(
name|scb
operator|->
name|async_state
argument_list|)
expr_stmt|;
name|add_file_handler
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|fd_event
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|next_state
operator|=
name|FD_SCHEDULED
expr_stmt|;
block|}
else|else
name|next_state
operator|=
name|scb
operator|->
name|async_state
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|serial_debug_p
argument_list|(
name|scb
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|next_state
condition|)
block|{
case|case
name|FD_SCHEDULED
case|:
if|if
condition|(
name|scb
operator|->
name|async_state
operator|!=
name|FD_SCHEDULED
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"[fd%d->fd-scheduled]\n"
argument_list|,
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* TIMER SCHEDULED */
if|if
condition|(
name|scb
operator|->
name|async_state
operator|==
name|FD_SCHEDULED
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"[fd%d->timer-scheduled]\n"
argument_list|,
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|scb
operator|->
name|async_state
operator|=
name|next_state
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FD_EVENT: This is scheduled when the input FIFO is empty (and there    is no pending error).  As soon as data arrives, it is read into the    input FIFO and the client notified.  The client should then drain    the FIFO using readchar().  If the FIFO isn't immediatly emptied,    push_event() is used to nag the client until it is. */
end_comment

begin_function
specifier|static
name|void
name|fd_event
parameter_list|(
name|int
name|error
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|serial
modifier|*
name|scb
init|=
name|context
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|scb
operator|->
name|bufcnt
operator|=
name|SERIAL_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|bufcnt
operator|==
literal|0
condition|)
block|{
comment|/* Prime the input FIFO.  The readchar() function is used to          pull characters out of the buffer.  See also          generic_readchar(). */
name|int
name|nr
decl_stmt|;
do|do
block|{
name|nr
operator|=
name|read
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|scb
operator|->
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nr
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|bufcnt
operator|=
name|SERIAL_EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nr
operator|>
literal|0
condition|)
block|{
name|scb
operator|->
name|bufcnt
operator|=
name|nr
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|bufcnt
operator|=
name|SERIAL_ERROR
expr_stmt|;
block|}
block|}
name|scb
operator|->
name|async_handler
argument_list|(
name|scb
argument_list|,
name|scb
operator|->
name|async_context
argument_list|)
expr_stmt|;
name|reschedule
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PUSH_EVENT: The input FIFO is non-empty (or there is a pending    error).  Nag the client until all the data has been read.  In the    case of errors, the client will need to close or de-async the    device before naging stops. */
end_comment

begin_function
specifier|static
name|void
name|push_event
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|serial
modifier|*
name|scb
init|=
name|context
decl_stmt|;
name|scb
operator|->
name|async_state
operator|=
name|NOTHING_SCHEDULED
expr_stmt|;
comment|/* Timers are one-off */
name|scb
operator|->
name|async_handler
argument_list|(
name|scb
argument_list|,
name|scb
operator|->
name|async_context
argument_list|)
expr_stmt|;
comment|/* re-schedule */
name|reschedule
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the SERIAL device into/out-of ASYNC mode.  */
end_comment

begin_function
name|void
name|ser_unix_async
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|async_p
parameter_list|)
block|{
if|if
condition|(
name|async_p
condition|)
block|{
comment|/* Force a re-schedule. */
name|scb
operator|->
name|async_state
operator|=
name|NOTHING_SCHEDULED
expr_stmt|;
if|if
condition|(
name|serial_debug_p
argument_list|(
name|scb
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"[fd%d->asynchronous]\n"
argument_list|,
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
name|reschedule
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|serial_debug_p
argument_list|(
name|scb
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"[fd%d->synchronous]\n"
argument_list|,
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* De-schedule whatever tasks are currently scheduled. */
switch|switch
condition|(
name|scb
operator|->
name|async_state
condition|)
block|{
case|case
name|FD_SCHEDULED
case|:
name|delete_file_handler
argument_list|(
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
name|NOTHING_SCHEDULED
label|:
break|break;
default|default:
comment|/* TIMER SCHEDULED */
name|delete_timer
argument_list|(
name|scb
operator|->
name|async_state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_initialize_ser_hardwire
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|serial_ops
modifier|*
name|ops
init|=
name|XMALLOC
argument_list|(
expr|struct
name|serial_ops
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|serial_ops
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
operator|->
name|name
operator|=
literal|"hardwire"
expr_stmt|;
name|ops
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ops
operator|->
name|open
operator|=
name|hardwire_open
expr_stmt|;
name|ops
operator|->
name|close
operator|=
name|hardwire_close
expr_stmt|;
comment|/* FIXME: Don't replace this with the equivalent ser_unix*() until      the old TERMIOS/SGTTY/... timer code has been flushed. cagney      1999-09-16. */
name|ops
operator|->
name|readchar
operator|=
name|hardwire_readchar
expr_stmt|;
name|ops
operator|->
name|write
operator|=
name|ser_unix_write
expr_stmt|;
name|ops
operator|->
name|flush_output
operator|=
name|hardwire_flush_output
expr_stmt|;
name|ops
operator|->
name|flush_input
operator|=
name|hardwire_flush_input
expr_stmt|;
name|ops
operator|->
name|send_break
operator|=
name|hardwire_send_break
expr_stmt|;
name|ops
operator|->
name|go_raw
operator|=
name|hardwire_raw
expr_stmt|;
name|ops
operator|->
name|get_tty_state
operator|=
name|hardwire_get_tty_state
expr_stmt|;
name|ops
operator|->
name|set_tty_state
operator|=
name|hardwire_set_tty_state
expr_stmt|;
name|ops
operator|->
name|print_tty_state
operator|=
name|hardwire_print_tty_state
expr_stmt|;
name|ops
operator|->
name|noflush_set_tty_state
operator|=
name|hardwire_noflush_set_tty_state
expr_stmt|;
name|ops
operator|->
name|setbaudrate
operator|=
name|hardwire_setbaudrate
expr_stmt|;
name|ops
operator|->
name|setstopbits
operator|=
name|hardwire_setstopbits
expr_stmt|;
name|ops
operator|->
name|drain_output
operator|=
name|hardwire_drain_output
expr_stmt|;
name|ops
operator|->
name|async
operator|=
name|ser_unix_async
expr_stmt|;
name|serial_add_interface
argument_list|(
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

