begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Cache and manage the values of registers for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/*  * DATA STRUCTURE  *  * Here is the actual register cache.  */
end_comment

begin_comment
comment|/* NOTE: this is a write-through cache.  There is no "dirty" bit for    recording if the register values have been changed (eg. by the    user).  Therefore all registers must be written back to the    target when appropriate.  */
end_comment

begin_comment
comment|/* REGISTERS contains the cached register values (in target byte order). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|registers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* REGISTER_VALID is 0 if the register needs to be fetched,                      1 if it has been fetched, and 		    -1 if the register value was not available.      "Not available" means don't try to fetch it again.  */
end_comment

begin_decl_stmt
name|signed
name|char
modifier|*
name|register_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The thread/process associated with the current set of registers. */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|registers_ptid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTIONS:  */
end_comment

begin_comment
comment|/* REGISTER_CACHED()     Returns 0 if the value is not in the cache (needs fetch).>0 if the value is in the cache.<0 if the value is permanently unavailable (don't ask again).  */
end_comment

begin_function
name|int
name|register_cached
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|register_valid
index|[
name|regnum
index|]
return|;
block|}
end_function

begin_comment
comment|/* Record that REGNUM's value is cached if STATE is>0, uncached but    fetchable if STATE is 0, and uncached and unfetchable if STATE is<0.  */
end_comment

begin_function
name|void
name|set_register_cached
parameter_list|(
name|int
name|regnum
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|register_valid
index|[
name|regnum
index|]
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REGISTER_CHANGED     invalidate a single register REGNUM in the cache */
end_comment

begin_function
name|void
name|register_changed
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|set_register_cached
argument_list|(
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If REGNUM>= 0, return a pointer to register REGNUM's cache buffer area,    else return a pointer to the start of the cache buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|register_buffer
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return whether register REGNUM is a real register.  */
end_comment

begin_function
specifier|static
name|int
name|real_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|NUM_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return whether register REGNUM is a pseudo register.  */
end_comment

begin_function
specifier|static
name|int
name|pseudo_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|regnum
operator|>=
name|NUM_REGS
operator|&&
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNUM into the cache.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* NOTE: cagney/2001-12-04: Legacy targets were using fetch/store      pseudo-register as a way of handling registers that needed to be      constructed from one or more raw registers.  New targets instead      use gdbarch register read/write.  */
if|if
condition|(
name|FETCH_PSEUDO_REGISTER_P
argument_list|()
operator|&&
name|pseudo_register
argument_list|(
name|regnum
argument_list|)
condition|)
name|FETCH_PSEUDO_REGISTER
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
else|else
name|target_fetch_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write register REGNUM cached value to the target.  */
end_comment

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* NOTE: cagney/2001-12-04: Legacy targets were using fetch/store      pseudo-register as a way of handling registers that needed to be      constructed from one or more raw registers.  New targets instead      use gdbarch register read/write.  */
if|if
condition|(
name|STORE_PSEUDO_REGISTER_P
argument_list|()
operator|&&
name|pseudo_register
argument_list|(
name|regnum
argument_list|)
condition|)
name|STORE_PSEUDO_REGISTER
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
else|else
name|target_store_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Low level examining and depositing of registers.     The caller is responsible for making sure that the inferior is    stopped before calling the fetching routines, or it will get    garbage.  (a change from GDB version 3, in which the caller got the    value from the last stop).  */
end_comment

begin_comment
comment|/* REGISTERS_CHANGED ()     Indicate that registers may have changed, so invalidate the cache.  */
end_comment

begin_function
name|void
name|registers_changed
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|registers_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Force cleanup of any alloca areas if using C alloca instead of      a builtin alloca.  This particular call is used to clean up      areas allocated by low level target code which may build up      during lengthy interactions between gdb and the target before      gdb gives control to the user (ie watchpoints).  */
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
name|set_register_cached
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|registers_changed_hook
condition|)
name|registers_changed_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REGISTERS_FETCHED ()     Indicate that all registers have been fetched, so mark them all valid.  */
end_comment

begin_comment
comment|/* NOTE: cagney/2001-12-04: This function does not set valid on the    pseudo-register range since pseudo registers are always supplied    using supply_register().  */
end_comment

begin_comment
comment|/* FIXME: cagney/2001-12-04: This function is DEPRECATED.  The target    code was blatting the registers[] array and then calling this.    Since targets should only be using supply_register() the need for    this function/hack is eliminated.  */
end_comment

begin_function
name|void
name|registers_fetched
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|set_register_cached
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Do not assume that the pseudo-regs have also been fetched.      Fetching all real regs NEVER accounts for pseudo-regs.  */
block|}
end_function

begin_comment
comment|/* read_register_bytes and write_register_bytes are generally a *BAD*    idea.  They are inefficient because they need to check for partial    updates, which can only be done by scanning through all of the    registers and seeing if the bytes that are being read/written fall    inside of an invalid register.  [The main reason this is necessary    is that register sizes can vary, so a simple index won't suffice.]    It is far better to call read_register_gen and write_register_gen    if you want to get at the raw register contents, as it only takes a    regnum as an argument, and therefore can't do a partial register    update.     Prior to the recent fixes to check for partial updates, both read    and write_register_bytes always checked to see if any registers    were stale, and then called target_fetch_registers (-1) to update    the whole set.  This caused really slowed things down for remote    targets.  */
end_comment

begin_comment
comment|/* Copy INLEN bytes of consecutive data from registers    starting with the INREGBYTE'th byte of register data    into memory at MYADDR.  */
end_comment

begin_function
name|void
name|read_register_bytes
parameter_list|(
name|int
name|in_start
parameter_list|,
name|char
modifier|*
name|in_buf
parameter_list|,
name|int
name|in_len
parameter_list|)
block|{
name|int
name|in_end
init|=
name|in_start
operator|+
name|in_len
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
modifier|*
name|reg_buf
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
comment|/* See if we are trying to read bytes from out-of-date registers.  If so,      update just those registers.  */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|int
name|reg_start
decl_stmt|;
name|int
name|reg_end
decl_stmt|;
name|int
name|reg_len
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|byte
decl_stmt|;
name|reg_start
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|reg_len
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|reg_end
operator|=
name|reg_start
operator|+
name|reg_len
expr_stmt|;
if|if
condition|(
name|reg_end
operator|<=
name|in_start
operator|||
name|in_end
operator|<=
name|reg_start
condition|)
comment|/* The range the user wants to read doesn't overlap with regnum.  */
continue|continue;
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\0'
condition|)
comment|/* Force the cache to fetch the entire register.  */
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|reg_buf
argument_list|)
expr_stmt|;
else|else
comment|/* Legacy note: even though this register is ``invalid'' we            still need to return something.  It would appear that some            code relies on apparent gaps in the register array also            being returned.  */
comment|/* FIXME: cagney/2001-08-18: This is just silly.  It defeats            the entire register read/write flow of control.  Must            resist temptation to return 0xdeadbeef.  */
name|memcpy
argument_list|(
name|reg_buf
argument_list|,
name|registers
operator|+
name|reg_start
argument_list|,
name|reg_len
argument_list|)
expr_stmt|;
comment|/* Legacy note: This function, for some reason, allows a NULL          input buffer.  If the buffer is NULL, the registers are still          fetched, just the final transfer is skipped. */
if|if
condition|(
name|in_buf
operator|==
name|NULL
condition|)
continue|continue;
comment|/* start = max (reg_start, in_start) */
if|if
condition|(
name|reg_start
operator|>
name|in_start
condition|)
name|start
operator|=
name|reg_start
expr_stmt|;
else|else
name|start
operator|=
name|in_start
expr_stmt|;
comment|/* end = min (reg_end, in_end) */
if|if
condition|(
name|reg_end
operator|<
name|in_end
condition|)
name|end
operator|=
name|reg_end
expr_stmt|;
else|else
name|end
operator|=
name|in_end
expr_stmt|;
comment|/* Transfer just the bytes common to both IN_BUF and REG_BUF */
for|for
control|(
name|byte
operator|=
name|start
init|;
name|byte
operator|<
name|end
condition|;
name|byte
operator|++
control|)
block|{
name|in_buf
index|[
name|byte
operator|-
name|in_start
index|]
operator|=
name|reg_buf
index|[
name|byte
operator|-
name|reg_start
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read register REGNUM into memory at MYADDR, which must be large    enough for REGISTER_RAW_BYTES (REGNUM).  Target byte-order.  If the    register is known to be the size of a CORE_ADDR or smaller,    read_register can be used instead.  */
end_comment

begin_function
specifier|static
name|void
name|legacy_read_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_cached
argument_list|(
name|regnum
argument_list|)
condition|)
name|fetch_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_read
parameter_list|(
name|int
name|rawnum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|rawnum
operator|>=
literal|0
operator|&&
name|rawnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
comment|/* For moment, just use underlying legacy code. Ulgh!!! */
name|legacy_read_register_gen
argument_list|(
name|rawnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gdbarch_register_read_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
name|legacy_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdbarch_register_read
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write register REGNUM at MYADDR to the target.  MYADDR points at    REGISTER_RAW_BYTES(REGNUM), which must be in target byte-order.  */
end_comment

begin_function
specifier|static
name|void
name|legacy_write_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
comment|/* On the sparc, writing %g0 is a no-op, so we don't even want to      change the registers array if something writes to this register.  */
if|if
condition|(
name|CANNOT_STORE_REGISTER
argument_list|(
name|regnum
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
name|size
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_register
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* If we have a valid copy of the register, and new value == old 	 value, then don't bother doing the actual store. */
if|if
condition|(
name|register_cached
argument_list|(
name|regnum
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|myaddr
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return;
else|else
name|target_prepare_to_store
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|myaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|set_register_cached
argument_list|(
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_write
parameter_list|(
name|int
name|rawnum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|rawnum
operator|>=
literal|0
operator|&&
name|rawnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
comment|/* For moment, just use underlying legacy code. Ulgh!!! */
name|legacy_write_register_gen
argument_list|(
name|rawnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gdbarch_register_write_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
name|legacy_write_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdbarch_register_write
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy INLEN bytes of consecutive data from memory at MYADDR    into registers starting with the MYREGSTART'th byte of register data.  */
end_comment

begin_function
name|void
name|write_register_bytes
parameter_list|(
name|int
name|myregstart
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|int
name|myregend
init|=
name|myregstart
operator|+
name|inlen
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|target_prepare_to_store
argument_list|()
expr_stmt|;
comment|/* Scan through the registers updating any that are covered by the      range myregstart<=>myregend using write_register_gen, which does      nice things like handling threads, and avoiding updates when the      new and old contents are the same.  */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|int
name|regstart
decl_stmt|,
name|regend
decl_stmt|;
name|regstart
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|regend
operator|=
name|regstart
operator|+
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
comment|/* Is this register completely outside the range the user is writing?  */
if|if
condition|(
name|myregend
operator|<=
name|regstart
operator|||
name|regend
operator|<=
name|myregstart
condition|)
comment|/* do nothing */
empty_stmt|;
comment|/* Is this register completely within the range the user is writing?  */
elseif|else
if|if
condition|(
name|myregstart
operator|<=
name|regstart
operator|&&
name|regend
operator|<=
name|myregend
condition|)
name|write_register_gen
argument_list|(
name|regnum
argument_list|,
name|myaddr
operator|+
operator|(
name|regstart
operator|-
name|myregstart
operator|)
argument_list|)
expr_stmt|;
comment|/* The register partially overlaps the range being written.  */
else|else
block|{
name|char
modifier|*
name|regbuf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
comment|/* What's the overlap between this register's bytes and              those the caller wants to write?  */
name|int
name|overlapstart
init|=
name|max
argument_list|(
name|regstart
argument_list|,
name|myregstart
argument_list|)
decl_stmt|;
name|int
name|overlapend
init|=
name|min
argument_list|(
name|regend
argument_list|,
name|myregend
argument_list|)
decl_stmt|;
comment|/* We may be doing a partial update of an invalid register. 	     Update it from the target before scribbling on it.  */
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|registers
operator|+
name|overlapstart
argument_list|,
name|myaddr
operator|+
operator|(
name|overlapstart
operator|-
name|myregstart
operator|)
argument_list|,
name|overlapend
operator|-
name|overlapstart
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the contents of register REGNUM as an unsigned integer.  */
end_comment

begin_function
name|ULONGEST
name|read_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
decl_stmt|;
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|read_register_pid
parameter_list|(
name|int
name|regnum
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|save_ptid
decl_stmt|;
name|int
name|save_pid
decl_stmt|;
name|CORE_ADDR
name|retval
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|retval
operator|=
name|read_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|save_ptid
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return the contents of register REGNUM as a signed integer.  */
end_comment

begin_function
name|LONGEST
name|read_signed_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
decl_stmt|;
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LONGEST
name|read_signed_register_pid
parameter_list|(
name|int
name|regnum
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|save_ptid
decl_stmt|;
name|LONGEST
name|retval
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
return|return
name|read_signed_register
argument_list|(
name|regnum
argument_list|)
return|;
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|retval
operator|=
name|read_signed_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|save_ptid
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Store VALUE into the raw contents of register number REGNUM.  */
end_comment

begin_function
name|void
name|write_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|LONGEST
name|val
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|(
name|LONGEST
operator|)
name|val
argument_list|)
expr_stmt|;
name|write_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_register_pid
parameter_list|(
name|int
name|regnum
parameter_list|,
name|CORE_ADDR
name|val
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|save_ptid
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|write_register
argument_list|(
name|regnum
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|save_ptid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SUPPLY_REGISTER()     Record that register REGNUM contains VAL.  This is used when the    value is obtained from the inferior or core dump, so there is no    need to store the value there.     If VAL is a NULL pointer, then it's probably an unsupported register.    We just set its value to all zeros.  We might want to record this    fact, and report it to the users of read_register and friends.  */
end_comment

begin_function
name|void
name|supply_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
endif|#
directive|endif
name|set_register_cached
argument_list|(
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|memcpy
argument_list|(
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|val
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|,
literal|'\000'
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On some architectures, e.g. HPPA, there are a few stray bits in      some registers, that the rest of the code would like to ignore.  */
comment|/* NOTE: cagney/2001-03-16: The macro CLEAN_UP_REGISTER_VALUE is      going to be deprecated.  Instead architectures will leave the raw      register value as is and instead clean things up as they pass      through the method gdbarch_register_read() clean up the      values. */
ifdef|#
directive|ifdef
name|DEPRECATED_CLEAN_UP_REGISTER_VALUE
name|DEPRECATED_CLEAN_UP_REGISTER_VALUE
argument_list|(
name|regnum
argument_list|,
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|regcache_collect
parameter_list|(
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|register_buffer
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read_pc, write_pc, read_sp, write_sp, read_fp, write_fp, etc.    Special handling for registers PC, SP, and FP.  */
end_comment

begin_comment
comment|/* NOTE: cagney/2001-02-18: The functions generic_target_read_pc(),    read_pc_pid(), read_pc(), generic_target_write_pc(),    write_pc_pid(), write_pc(), generic_target_read_sp(), read_sp(),    generic_target_write_sp(), write_sp(), generic_target_read_fp(),    read_fp(), generic_target_write_fp(), write_fp will eventually be    moved out of the reg-cache into either frame.[hc] or to the    multi-arch framework.  The are not part of the raw register cache.  */
end_comment

begin_comment
comment|/* This routine is getting awfully cluttered with #if's.  It's probably    time to turn this into READ_PC and define it in the tm.h file.    Ditto for write_pc.     1999-06-08: The following were re-written so that it assumes the    existence of a TARGET_READ_PC et.al. macro.  A default generic    version of that macro is made available where needed.     Since the ``TARGET_READ_PC'' et.al. macro is going to be controlled    by the multi-arch framework, it will eventually be possible to    eliminate the intermediate read_pc_pid().  The client would call    TARGET_READ_PC directly. (cagney). */
end_comment

begin_function
name|CORE_ADDR
name|generic_target_read_pc
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
if|if
condition|(
name|PC_REGNUM
operator|>=
literal|0
condition|)
block|{
name|CORE_ADDR
name|pc_val
init|=
name|ADDR_BITS_REMOVE
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|read_register_pid
argument_list|(
name|PC_REGNUM
argument_list|,
name|ptid
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|pc_val
return|;
block|}
endif|#
directive|endif
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_read_pc"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|read_pc_pid
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|saved_inferior_ptid
decl_stmt|;
name|CORE_ADDR
name|pc_val
decl_stmt|;
comment|/* In case ptid != inferior_ptid. */
name|saved_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|pc_val
operator|=
name|TARGET_READ_PC
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|saved_inferior_ptid
expr_stmt|;
return|return
name|pc_val
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|read_pc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|read_pc_pid
argument_list|(
name|inferior_ptid
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|generic_target_write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
if|if
condition|(
name|PC_REGNUM
operator|>=
literal|0
condition|)
name|write_register_pid
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NPC_REGNUM
operator|>=
literal|0
condition|)
name|write_register_pid
argument_list|(
name|NPC_REGNUM
argument_list|,
name|pc
operator|+
literal|4
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NNPC_REGNUM
operator|>=
literal|0
condition|)
name|write_register_pid
argument_list|(
name|NNPC_REGNUM
argument_list|,
name|pc
operator|+
literal|8
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_write_pc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|write_pc_pid
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|saved_inferior_ptid
decl_stmt|;
comment|/* In case ptid != inferior_ptid. */
name|saved_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|TARGET_WRITE_PC
argument_list|(
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|saved_inferior_ptid
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|write_pc_pid
argument_list|(
name|pc
argument_list|,
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cope with strage ways of getting to the stack and frame pointers */
end_comment

begin_function
name|CORE_ADDR
name|generic_target_read_sp
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SP_REGNUM
if|if
condition|(
name|SP_REGNUM
operator|>=
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
return|;
endif|#
directive|endif
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_read_sp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CORE_ADDR
name|read_sp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_READ_SP
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|generic_target_write_sp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SP_REGNUM
if|if
condition|(
name|SP_REGNUM
operator|>=
literal|0
condition|)
block|{
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_write_sp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_sp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
name|TARGET_WRITE_SP
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CORE_ADDR
name|generic_target_read_fp
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FP_REGNUM
if|if
condition|(
name|FP_REGNUM
operator|>=
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
return|;
endif|#
directive|endif
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_read_fp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CORE_ADDR
name|read_fp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_READ_FP
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|generic_target_write_fp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FP_REGNUM
if|if
condition|(
name|FP_REGNUM
operator|>=
literal|0
condition|)
block|{
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_write_fp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_fp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
name|TARGET_WRITE_FP
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|reg_flush_command
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Force-flush the register cache.  */
name|registers_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Register cache flushed.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_regcache
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|sizeof_register_valid
decl_stmt|;
comment|/* Come up with the real size of the registers buffer.  */
name|int
name|sizeof_registers
init|=
name|REGISTER_BYTES
decl_stmt|;
comment|/* OK use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
block|{
name|long
name|regend
decl_stmt|;
comment|/* Keep extending the buffer so that there is always enough          space for all registers.  The comparison is necessary since          legacy code is free to put registers in random places in the          buffer separated by holes.  Once REGISTER_BYTE() is killed          this can be greatly simplified.  */
comment|/* FIXME: cagney/2001-12-04: This code shouldn't need to use          REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the          buffer out so that certain registers just happen to overlap.          Ulgh!  New targets use gdbarch's register read/write and          entirely avoid this uglyness.  */
name|regend
operator|=
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
operator|+
name|REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeof_registers
operator|<
name|regend
condition|)
name|sizeof_registers
operator|=
name|regend
expr_stmt|;
block|}
name|registers
operator|=
name|xmalloc
argument_list|(
name|sizeof_registers
argument_list|)
expr_stmt|;
name|sizeof_register_valid
operator|=
operator|(
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|register_valid
argument_list|)
operator|)
expr_stmt|;
name|register_valid
operator|=
name|xmalloc
argument_list|(
name|sizeof_register_valid
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|register_valid
argument_list|,
literal|0
argument_list|,
name|sizeof_register_valid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_regcache
parameter_list|(
name|void
parameter_list|)
block|{
name|build_regcache
argument_list|()
expr_stmt|;
name|register_gdbarch_swap
argument_list|(
operator|&
name|registers
argument_list|,
sizeof|sizeof
argument_list|(
name|registers
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|register_gdbarch_swap
argument_list|(
operator|&
name|register_valid
argument_list|,
sizeof|sizeof
argument_list|(
name|register_valid
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_regcache
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"flushregs"
argument_list|,
name|class_maintenance
argument_list|,
name|reg_flush_command
argument_list|,
literal|"Force gdb to flush its register cache (maintainer command)"
argument_list|)
expr_stmt|;
comment|/* Initialize the thread/process associated with the current set of       registers.  For now, -1 is special, and means `no current process'.  */
name|registers_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

