begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Cache and manage the values of registers for GDB, the GNU debugger.     Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,    2001, 2002, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* For maintenanceprintlist.  */
end_comment

begin_comment
comment|/*  * DATA STRUCTURE  *  * Here is the actual register cache.  */
end_comment

begin_comment
comment|/* Per-architecture object describing the layout of a register cache.    Computed once when the architecture is created */
end_comment

begin_decl_stmt
name|struct
name|gdbarch_data
modifier|*
name|regcache_descr_handle
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|regcache_descr
block|{
comment|/* The architecture this descriptor belongs to.  */
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
comment|/* Is this a ``legacy'' register cache?  Such caches reserve space      for raw and pseudo registers and allow access to both.  */
name|int
name|legacy_p
decl_stmt|;
comment|/* The raw register cache.  Each raw (or hard) register is supplied      by the target interface.  The raw cache should not contain      redundant information - if the PC is constructed from two      registers then those regigisters and not the PC lives in the raw      cache.  */
name|int
name|nr_raw_registers
decl_stmt|;
name|long
name|sizeof_raw_registers
decl_stmt|;
name|long
name|sizeof_raw_register_valid_p
decl_stmt|;
comment|/* The cooked register space.  Each cooked register in the range      [0..NR_RAW_REGISTERS) is direct-mapped onto the corresponding raw      register.  The remaining [NR_RAW_REGISTERS      .. NR_COOKED_REGISTERS) (a.k.a. pseudo regiters) are mapped onto      both raw registers and memory by the architecture methods      gdbarch_register_read and gdbarch_register_write.  */
name|int
name|nr_cooked_registers
decl_stmt|;
name|long
name|sizeof_cooked_registers
decl_stmt|;
name|long
name|sizeof_cooked_register_valid_p
decl_stmt|;
comment|/* Offset and size (in 8 bit bytes), of reach register in the      register cache.  All registers (including those in the range      [NR_RAW_REGISTERS .. NR_COOKED_REGISTERS) are given an offset.      Assigning all registers an offset makes it possible to keep      legacy code, such as that found in read_register_bytes() and      write_register_bytes() working.  */
name|long
modifier|*
name|register_offset
decl_stmt|;
name|long
modifier|*
name|sizeof_register
decl_stmt|;
comment|/* Cached table containing the type of each register.  */
name|struct
name|type
modifier|*
modifier|*
name|register_type
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|init_legacy_regcache_descr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache_descr
modifier|*
name|descr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* FIXME: cagney/2002-05-11: gdbarch_data() should take that      ``gdbarch'' as a parameter.  */
name|gdb_assert
argument_list|(
name|gdbarch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Compute the offset of each register.  Legacy architectures define      DEPRECATED_REGISTER_BYTE() so use that.  */
comment|/* FIXME: cagney/2002-11-07: Instead of using      DEPRECATED_REGISTER_BYTE() this code should, as is done in      init_regcache_descr(), compute the offets at runtime.  This      currently isn't possible as some ISAs define overlapping register      regions - see the mess in read_register_bytes() and      write_register_bytes() registers.  */
name|descr
operator|->
name|sizeof_register
operator|=
name|GDBARCH_OBSTACK_CALLOC
argument_list|(
name|gdbarch
argument_list|,
name|descr
operator|->
name|nr_cooked_registers
argument_list|,
name|long
argument_list|)
expr_stmt|;
name|descr
operator|->
name|register_offset
operator|=
name|GDBARCH_OBSTACK_CALLOC
argument_list|(
name|gdbarch
argument_list|,
name|descr
operator|->
name|nr_cooked_registers
argument_list|,
name|long
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|i
operator|++
control|)
block|{
comment|/* FIXME: cagney/2001-12-04: This code shouldn't need to use          DEPRECATED_REGISTER_BYTE().  Unfortunately, legacy code likes          to lay the buffer out so that certain registers just happen          to overlap.  Ulgh!  New targets use gdbarch's register          read/write and entirely avoid this uglyness.  */
name|descr
operator|->
name|register_offset
index|[
name|i
index|]
operator|=
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|descr
operator|->
name|sizeof_register
index|[
name|i
index|]
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|MAX_REGISTER_SIZE
operator|>=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|MAX_REGISTER_SIZE
operator|>=
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the real size of the register buffer.  Start out by      trusting DEPRECATED_REGISTER_BYTES, but then adjust it upwards      should that be found to not be sufficient.  */
comment|/* FIXME: cagney/2002-11-05: Instead of using the macro      DEPRECATED_REGISTER_BYTES, this code should, as is done in      init_regcache_descr(), compute the total number of register bytes      using the accumulated offsets.  */
name|descr
operator|->
name|sizeof_cooked_registers
operator|=
name|DEPRECATED_REGISTER_BYTES
expr_stmt|;
comment|/* OK */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|i
operator|++
control|)
block|{
name|long
name|regend
decl_stmt|;
comment|/* Keep extending the buffer so that there is always enough          space for all registers.  The comparison is necessary since          legacy code is free to put registers in random places in the          buffer separated by holes.  Once DEPRECATED_REGISTER_BYTE()          is killed this can be greatly simplified.  */
name|regend
operator|=
name|descr
operator|->
name|register_offset
index|[
name|i
index|]
operator|+
name|descr
operator|->
name|sizeof_register
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|descr
operator|->
name|sizeof_cooked_registers
operator|<
name|regend
condition|)
name|descr
operator|->
name|sizeof_cooked_registers
operator|=
name|regend
expr_stmt|;
block|}
comment|/* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers      in the register cache.  Unfortunately some architectures still      rely on this and the pseudo_register_write() method.  */
name|descr
operator|->
name|sizeof_raw_registers
operator|=
name|descr
operator|->
name|sizeof_cooked_registers
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|init_regcache_descr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|regcache_descr
modifier|*
name|descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|gdbarch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create an initial, zero filled, table.  */
name|descr
operator|=
name|GDBARCH_OBSTACK_ZALLOC
argument_list|(
name|gdbarch
argument_list|,
expr|struct
name|regcache_descr
argument_list|)
expr_stmt|;
name|descr
operator|->
name|gdbarch
operator|=
name|gdbarch
expr_stmt|;
comment|/* Total size of the register space.  The raw registers are mapped      directly onto the raw register cache while the pseudo's are      either mapped onto raw-registers or memory.  */
name|descr
operator|->
name|nr_cooked_registers
operator|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
expr_stmt|;
name|descr
operator|->
name|sizeof_cooked_register_valid_p
operator|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
expr_stmt|;
comment|/* Fill in a table of register types.  */
name|descr
operator|->
name|register_type
operator|=
name|GDBARCH_OBSTACK_CALLOC
argument_list|(
name|gdbarch
argument_list|,
name|descr
operator|->
name|nr_cooked_registers
argument_list|,
expr|struct
name|type
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gdbarch_register_type_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
block|{
name|gdb_assert
argument_list|(
operator|!
name|DEPRECATED_REGISTER_VIRTUAL_TYPE_P
argument_list|()
argument_list|)
expr_stmt|;
comment|/* OK */
name|descr
operator|->
name|register_type
index|[
name|i
index|]
operator|=
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|descr
operator|->
name|register_type
index|[
name|i
index|]
operator|=
name|DEPRECATED_REGISTER_VIRTUAL_TYPE
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* OK */
block|}
comment|/* Construct a strictly RAW register cache.  Don't allow pseudo's      into the register cache.  */
name|descr
operator|->
name|nr_raw_registers
operator|=
name|NUM_REGS
expr_stmt|;
comment|/* FIXME: cagney/2002-08-13: Overallocate the register_valid_p      array.  This pretects GDB from erant code that accesses elements      of the global register_valid_p[] array in the range [NUM_REGS      .. NUM_REGS + NUM_PSEUDO_REGS).  */
name|descr
operator|->
name|sizeof_raw_register_valid_p
operator|=
name|descr
operator|->
name|sizeof_cooked_register_valid_p
expr_stmt|;
comment|/* If an old style architecture, fill in the remainder of the      register cache descriptor using the register macros.  */
comment|/* NOTE: cagney/2003-06-29: If either of DEPRECATED_REGISTER_BYTE or      DEPRECATED_REGISTER_RAW_SIZE are still present, things are most likely      totally screwed.  Ex: an architecture with raw register sizes      smaller than what DEPRECATED_REGISTER_BYTE indicates; non      monotonic DEPRECATED_REGISTER_BYTE values.  For GDB 6 check for      these nasty methods and fall back to legacy code when present.      Sigh!  */
if|if
condition|(
operator|(
operator|!
name|gdbarch_pseudo_register_read_p
argument_list|(
name|gdbarch
argument_list|)
operator|&&
operator|!
name|gdbarch_pseudo_register_write_p
argument_list|(
name|gdbarch
argument_list|)
operator|&&
operator|!
name|gdbarch_register_type_p
argument_list|(
name|gdbarch
argument_list|)
operator|)
operator|||
name|DEPRECATED_REGISTER_BYTE_P
argument_list|()
operator|||
name|DEPRECATED_REGISTER_RAW_SIZE_P
argument_list|()
condition|)
block|{
name|descr
operator|->
name|legacy_p
operator|=
literal|1
expr_stmt|;
name|init_legacy_regcache_descr
argument_list|(
name|gdbarch
argument_list|,
name|descr
argument_list|)
expr_stmt|;
return|return
name|descr
return|;
block|}
comment|/* Lay out the register cache.       NOTE: cagney/2002-05-22: Only register_type() is used when      constructing the register cache.  It is assumed that the      register's raw size, virtual size and type length are all the      same.  */
block|{
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|descr
operator|->
name|sizeof_register
operator|=
name|GDBARCH_OBSTACK_CALLOC
argument_list|(
name|gdbarch
argument_list|,
name|descr
operator|->
name|nr_cooked_registers
argument_list|,
name|long
argument_list|)
expr_stmt|;
name|descr
operator|->
name|register_offset
operator|=
name|GDBARCH_OBSTACK_CALLOC
argument_list|(
name|gdbarch
argument_list|,
name|descr
operator|->
name|nr_cooked_registers
argument_list|,
name|long
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|i
operator|++
control|)
block|{
name|descr
operator|->
name|sizeof_register
index|[
name|i
index|]
operator|=
name|TYPE_LENGTH
argument_list|(
name|descr
operator|->
name|register_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|descr
operator|->
name|register_offset
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|descr
operator|->
name|sizeof_register
index|[
name|i
index|]
expr_stmt|;
name|gdb_assert
argument_list|(
name|MAX_REGISTER_SIZE
operator|>=
name|descr
operator|->
name|sizeof_register
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Set the real size of the register cache buffer.  */
name|descr
operator|->
name|sizeof_cooked_registers
operator|=
name|offset
expr_stmt|;
block|}
comment|/* FIXME: cagney/2002-05-22: Should only need to allocate space for      the raw registers.  Unfortunately some code still accesses the      register array directly using the global registers[].  Until that      code has been purged, play safe and over allocating the register      buffer.  Ulgh!  */
name|descr
operator|->
name|sizeof_raw_registers
operator|=
name|descr
operator|->
name|sizeof_cooked_registers
expr_stmt|;
comment|/* Sanity check.  Confirm that there is agreement between the      regcache and the target's redundant DEPRECATED_REGISTER_BYTE (new      targets should not even be defining it).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DEPRECATED_REGISTER_BYTE_P
argument_list|()
condition|)
name|gdb_assert
argument_list|(
name|descr
operator|->
name|register_offset
index|[
name|i
index|]
operator|==
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_RAW_SIZE (i));       gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
endif|#
directive|endif
block|}
comment|/* gdb_assert (descr->sizeof_raw_registers == DEPRECATED_REGISTER_BYTES (i));  */
return|return
name|descr
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|regcache_descr
modifier|*
name|regcache_descr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
return|return
name|gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|regcache_descr_handle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Utility functions returning useful register attributes stored in    the regcache descr.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache_descr
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
return|return
name|descr
operator|->
name|register_type
index|[
name|regnum
index|]
return|;
block|}
end_function

begin_comment
comment|/* Utility functions returning useful register attributes stored in    the regcache descr.  */
end_comment

begin_function
name|int
name|register_size
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache_descr
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
expr_stmt|;
comment|/* NB: The deprecated DEPRECATED_REGISTER_RAW_SIZE, if not provided, defaults      to the size of the register's type.  */
name|gdb_assert
argument_list|(
name|size
operator|==
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OK */
comment|/* NB: Don't check the register's virtual size.  It, in say the case      of the MIPS, may not match the raw size!  */
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* The register cache for storing raw register values.  */
end_comment

begin_struct
struct|struct
name|regcache
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
decl_stmt|;
comment|/* The register buffers.  A read-only register cache can hold the      full [0 .. NUM_REGS + NUM_PSEUDO_REGS) while a read/write      register cache can only hold [0 .. NUM_REGS).  */
name|char
modifier|*
name|registers
decl_stmt|;
name|char
modifier|*
name|register_valid_p
decl_stmt|;
comment|/* Is this a read-only cache?  A read-only cache is used for saving      the target's register state (e.g, across an inferior function      call or just before forcing a function return).  A read-only      cache can only be updated via the methods regcache_dup() and      regcache_cpy().  The actual contents are determined by the      reggroup_save and reggroup_restore methods.  */
name|int
name|readonly_p
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|regcache
modifier|*
name|regcache_xmalloc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
decl_stmt|;
name|struct
name|regcache
modifier|*
name|regcache
decl_stmt|;
name|gdb_assert
argument_list|(
name|gdbarch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|descr
operator|=
name|regcache_descr
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
name|regcache
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|regcache
argument_list|)
expr_stmt|;
name|regcache
operator|->
name|descr
operator|=
name|descr
expr_stmt|;
name|regcache
operator|->
name|registers
operator|=
name|XCALLOC
argument_list|(
name|descr
operator|->
name|sizeof_raw_registers
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|regcache
operator|->
name|register_valid_p
operator|=
name|XCALLOC
argument_list|(
name|descr
operator|->
name|sizeof_raw_register_valid_p
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|regcache
operator|->
name|readonly_p
operator|=
literal|1
expr_stmt|;
return|return
name|regcache
return|;
block|}
end_function

begin_function
name|void
name|regcache_xfree
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
if|if
condition|(
name|regcache
operator|==
name|NULL
condition|)
return|return;
name|xfree
argument_list|(
name|regcache
operator|->
name|registers
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|regcache
operator|->
name|register_valid_p
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|regcache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_regcache_xfree
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|regcache_xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_regcache_xfree
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_regcache_xfree
argument_list|,
name|regcache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return REGCACHE's architecture.  */
end_comment

begin_function
name|struct
name|gdbarch
modifier|*
name|get_regcache_arch
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
return|return
name|regcache
operator|->
name|descr
operator|->
name|gdbarch
return|;
block|}
end_function

begin_comment
comment|/* Return  a pointer to register REGNUM's buffer cache.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|register_buffer
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
return|return
name|regcache
operator|->
name|registers
operator|+
name|regcache
operator|->
name|descr
operator|->
name|register_offset
index|[
name|regnum
index|]
return|;
block|}
end_function

begin_function
name|void
name|regcache_save
parameter_list|(
name|struct
name|regcache
modifier|*
name|dst
parameter_list|,
name|regcache_cooked_read_ftype
modifier|*
name|cooked_read
parameter_list|,
name|void
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|dst
operator|->
name|descr
operator|->
name|gdbarch
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|regnum
decl_stmt|;
comment|/* The DST should be `read-only', if it wasn't then the save would      end up trying to write the register values back out to the      target.  */
name|gdb_assert
argument_list|(
name|dst
operator|->
name|readonly_p
argument_list|)
expr_stmt|;
comment|/* Clear the dest.  */
name|memset
argument_list|(
name|dst
operator|->
name|registers
argument_list|,
literal|0
argument_list|,
name|dst
operator|->
name|descr
operator|->
name|sizeof_cooked_registers
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dst
operator|->
name|register_valid_p
argument_list|,
literal|0
argument_list|,
name|dst
operator|->
name|descr
operator|->
name|sizeof_cooked_register_valid_p
argument_list|)
expr_stmt|;
comment|/* Copy over any registers (identified by their membership in the      save_reggroup) and mark them as valid.  The full [0 .. NUM_REGS +      NUM_PSEUDO_REGS) range is checked since some architectures need      to save/restore `cooked' registers that live in memory.  */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|dst
operator|->
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|save_reggroup
argument_list|)
condition|)
block|{
name|int
name|valid
init|=
name|cooked_read
argument_list|(
name|src
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|memcpy
argument_list|(
name|register_buffer
argument_list|(
name|dst
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|register_valid_p
index|[
name|regnum
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|regcache_restore
parameter_list|(
name|struct
name|regcache
modifier|*
name|dst
parameter_list|,
name|regcache_cooked_read_ftype
modifier|*
name|cooked_read
parameter_list|,
name|void
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|dst
operator|->
name|descr
operator|->
name|gdbarch
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|regnum
decl_stmt|;
comment|/* The dst had better not be read-only.  If it is, the `restore'      doesn't make much sense.  */
name|gdb_assert
argument_list|(
operator|!
name|dst
operator|->
name|readonly_p
argument_list|)
expr_stmt|;
comment|/* Copy over any registers, being careful to only restore those that      were both saved and need to be restored.  The full [0 .. NUM_REGS      + NUM_PSEUDO_REGS) range is checked since some architectures need      to save/restore `cooked' registers that live in memory.  */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|dst
operator|->
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|restore_reggroup
argument_list|)
condition|)
block|{
name|int
name|valid
init|=
name|cooked_read
argument_list|(
name|src
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid
condition|)
name|regcache_cooked_write
argument_list|(
name|dst
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_cooked_read
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|regcache
init|=
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|regcache
operator|->
name|register_valid_p
index|[
name|regnum
index|]
operator|&&
name|regcache
operator|->
name|readonly_p
condition|)
comment|/* Don't even think about fetching a register from a read-only        cache when the register isn't yet valid.  There isn't a target        from which the register value can be fetched.  */
return|return
literal|0
return|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|regcache_cpy
parameter_list|(
name|struct
name|regcache
modifier|*
name|dst
parameter_list|,
name|struct
name|regcache
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|!=
name|NULL
operator|&&
name|dst
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|->
name|descr
operator|->
name|gdbarch
operator|==
name|dst
operator|->
name|descr
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|!=
name|dst
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|->
name|readonly_p
operator|||
name|dst
operator|->
name|readonly_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src
operator|->
name|readonly_p
condition|)
name|regcache_save
argument_list|(
name|dst
argument_list|,
name|do_cooked_read
argument_list|,
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|dst
operator|->
name|readonly_p
condition|)
name|regcache_restore
argument_list|(
name|dst
argument_list|,
name|do_cooked_read
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
name|regcache_cpy_no_passthrough
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cpy_no_passthrough
parameter_list|(
name|struct
name|regcache
modifier|*
name|dst
parameter_list|,
name|struct
name|regcache
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|!=
name|NULL
operator|&&
name|dst
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|->
name|descr
operator|->
name|gdbarch
operator|==
name|dst
operator|->
name|descr
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2002-05-17: Don't let the caller do a no-passthrough      move of data into the current_regcache().  Doing this would be      silly - it would mean that valid_p would be completely invalid.  */
name|gdb_assert
argument_list|(
name|dst
operator|!=
name|current_regcache
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|registers
argument_list|,
name|src
operator|->
name|registers
argument_list|,
name|dst
operator|->
name|descr
operator|->
name|sizeof_raw_registers
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|register_valid_p
argument_list|,
name|src
operator|->
name|register_valid_p
argument_list|,
name|dst
operator|->
name|descr
operator|->
name|sizeof_raw_register_valid_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|regcache
modifier|*
name|regcache_dup
parameter_list|(
name|struct
name|regcache
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|newbuf
decl_stmt|;
name|gdb_assert
argument_list|(
name|current_regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newbuf
operator|=
name|regcache_xmalloc
argument_list|(
name|src
operator|->
name|descr
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
name|regcache_cpy
argument_list|(
name|newbuf
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|newbuf
return|;
block|}
end_function

begin_function
name|struct
name|regcache
modifier|*
name|regcache_dup_no_passthrough
parameter_list|(
name|struct
name|regcache
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|newbuf
decl_stmt|;
name|gdb_assert
argument_list|(
name|current_regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newbuf
operator|=
name|regcache_xmalloc
argument_list|(
name|src
operator|->
name|descr
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
name|regcache_cpy_no_passthrough
argument_list|(
name|newbuf
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|newbuf
return|;
block|}
end_function

begin_function
name|int
name|regcache_valid_p
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
return|return
name|regcache
operator|->
name|register_valid_p
index|[
name|regnum
index|]
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|deprecated_grub_regcache_for_registers
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
return|return
name|regcache
operator|->
name|registers
return|;
block|}
end_function

begin_comment
comment|/* Global structure containing the current regcache.  */
end_comment

begin_comment
comment|/* FIXME: cagney/2002-05-11: The two global arrays registers[] and    deprecated_register_valid[] currently point into this structure.  */
end_comment

begin_decl_stmt
name|struct
name|regcache
modifier|*
name|current_regcache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE: this is a write-through cache.  There is no "dirty" bit for    recording if the register values have been changed (eg. by the    user).  Therefore all registers must be written back to the    target when appropriate.  */
end_comment

begin_comment
comment|/* REGISTERS contains the cached register values (in target byte order). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|deprecated_registers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEPRECATED_REGISTER_VALID is 0 if the register needs to be fetched,                      1 if it has been fetched, and 		    -1 if the register value was not available.       "Not available" indicates that the target is not not able to supply    the register at this state.  The register may become available at a    later time (after the next resume).  This often occures when GDB is    manipulating a target that contains only a snapshot of the entire    system being debugged - some of the registers in such a system may    not have been saved.  */
end_comment

begin_decl_stmt
name|signed
name|char
modifier|*
name|deprecated_register_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The thread/process associated with the current set of registers. */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|registers_ptid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTIONS:  */
end_comment

begin_comment
comment|/* REGISTER_CACHED()     Returns 0 if the value is not in the cache (needs fetch).>0 if the value is in the cache.<0 if the value is permanently unavailable (don't ask again).  */
end_comment

begin_function
name|int
name|register_cached
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|deprecated_register_valid
index|[
name|regnum
index|]
return|;
block|}
end_function

begin_comment
comment|/* Record that REGNUM's value is cached if STATE is>0, uncached but    fetchable if STATE is 0, and uncached and unfetchable if STATE is<0.  */
end_comment

begin_function
name|void
name|set_register_cached
parameter_list|(
name|int
name|regnum
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|<
name|current_regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|current_regcache
operator|->
name|register_valid_p
index|[
name|regnum
index|]
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether register REGNUM is a real register.  */
end_comment

begin_function
specifier|static
name|int
name|real_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|NUM_REGS
return|;
block|}
end_function

begin_comment
comment|/* Low level examining and depositing of registers.     The caller is responsible for making sure that the inferior is    stopped before calling the fetching routines, or it will get    garbage.  (a change from GDB version 3, in which the caller got the    value from the last stop).  */
end_comment

begin_comment
comment|/* REGISTERS_CHANGED ()     Indicate that registers may have changed, so invalidate the cache.  */
end_comment

begin_function
name|void
name|registers_changed
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|registers_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Force cleanup of any alloca areas if using C alloca instead of      a builtin alloca.  This particular call is used to clean up      areas allocated by low level target code which may build up      during lengthy interactions between gdb and the target before      gdb gives control to the user (ie watchpoints).  */
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
condition|;
name|i
operator|++
control|)
name|set_register_cached
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|registers_changed_hook
condition|)
name|registers_changed_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DEPRECATED_REGISTERS_FETCHED ()     Indicate that all registers have been fetched, so mark them all valid.  */
end_comment

begin_comment
comment|/* NOTE: cagney/2001-12-04: This function does not set valid on the    pseudo-register range since pseudo registers are always supplied    using supply_register().  */
end_comment

begin_comment
comment|/* FIXME: cagney/2001-12-04: This function is DEPRECATED.  The target    code was blatting the registers[] array and then calling this.    Since targets should only be using supply_register() the need for    this function/hack is eliminated.  */
end_comment

begin_function
name|void
name|deprecated_registers_fetched
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|set_register_cached
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Do not assume that the pseudo-regs have also been fetched.      Fetching all real regs NEVER accounts for pseudo-regs.  */
block|}
end_function

begin_comment
comment|/* deprecated_read_register_bytes and deprecated_write_register_bytes    are generally a *BAD* idea.  They are inefficient because they need    to check for partial updates, which can only be done by scanning    through all of the registers and seeing if the bytes that are being    read/written fall inside of an invalid register.  [The main reason    this is necessary is that register sizes can vary, so a simple    index won't suffice.]  It is far better to call read_register_gen    and write_register_gen if you want to get at the raw register    contents, as it only takes a regnum as an argument, and therefore    can't do a partial register update.     Prior to the recent fixes to check for partial updates, both read    and deprecated_write_register_bytes always checked to see if any    registers were stale, and then called target_fetch_registers (-1)    to update the whole set.  This caused really slowed things down for    remote targets.  */
end_comment

begin_comment
comment|/* Copy INLEN bytes of consecutive data from registers    starting with the INREGBYTE'th byte of register data    into memory at MYADDR.  */
end_comment

begin_function
name|void
name|deprecated_read_register_bytes
parameter_list|(
name|int
name|in_start
parameter_list|,
name|char
modifier|*
name|in_buf
parameter_list|,
name|int
name|in_len
parameter_list|)
block|{
name|int
name|in_end
init|=
name|in_start
operator|+
name|in_len
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
name|reg_buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* See if we are trying to read bytes from out-of-date registers.  If so,      update just those registers.  */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|int
name|reg_start
decl_stmt|;
name|int
name|reg_end
decl_stmt|;
name|int
name|reg_len
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|byte
decl_stmt|;
name|reg_start
operator|=
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|reg_len
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|reg_end
operator|=
name|reg_start
operator|+
name|reg_len
expr_stmt|;
if|if
condition|(
name|reg_end
operator|<=
name|in_start
operator|||
name|in_end
operator|<=
name|reg_start
condition|)
comment|/* The range the user wants to read doesn't overlap with regnum.  */
continue|continue;
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\0'
condition|)
comment|/* Force the cache to fetch the entire register.  */
name|deprecated_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|reg_buf
argument_list|)
expr_stmt|;
else|else
comment|/* Legacy note: even though this register is ``invalid'' we            still need to return something.  It would appear that some            code relies on apparent gaps in the register array also            being returned.  */
comment|/* FIXME: cagney/2001-08-18: This is just silly.  It defeats            the entire register read/write flow of control.  Must            resist temptation to return 0xdeadbeef.  */
name|memcpy
argument_list|(
name|reg_buf
argument_list|,
operator|&
name|deprecated_registers
index|[
name|reg_start
index|]
argument_list|,
name|reg_len
argument_list|)
expr_stmt|;
comment|/* Legacy note: This function, for some reason, allows a NULL          input buffer.  If the buffer is NULL, the registers are still          fetched, just the final transfer is skipped. */
if|if
condition|(
name|in_buf
operator|==
name|NULL
condition|)
continue|continue;
comment|/* start = max (reg_start, in_start) */
if|if
condition|(
name|reg_start
operator|>
name|in_start
condition|)
name|start
operator|=
name|reg_start
expr_stmt|;
else|else
name|start
operator|=
name|in_start
expr_stmt|;
comment|/* end = min (reg_end, in_end) */
if|if
condition|(
name|reg_end
operator|<
name|in_end
condition|)
name|end
operator|=
name|reg_end
expr_stmt|;
else|else
name|end
operator|=
name|in_end
expr_stmt|;
comment|/* Transfer just the bytes common to both IN_BUF and REG_BUF */
for|for
control|(
name|byte
operator|=
name|start
init|;
name|byte
operator|<
name|end
condition|;
name|byte
operator|++
control|)
block|{
name|in_buf
index|[
name|byte
operator|-
name|in_start
index|]
operator|=
name|reg_buf
index|[
name|byte
operator|-
name|reg_start
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read register REGNUM into memory at MYADDR, which must be large    enough for REGISTER_RAW_BYTES (REGNUM).  Target byte-order.  If the    register is known to be the size of a CORE_ADDR or smaller,    read_register can be used instead.  */
end_comment

begin_function
specifier|static
name|void
name|legacy_read_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_cached
argument_list|(
name|regnum
argument_list|)
condition|)
name|target_fetch_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
name|register_buffer
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_read
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
operator|&&
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcache
operator|->
name|descr
operator|->
name|legacy_p
operator|&&
operator|!
name|regcache
operator|->
name|readonly_p
condition|)
block|{
name|gdb_assert
argument_list|(
name|regcache
operator|==
name|current_regcache
argument_list|)
expr_stmt|;
comment|/* For moment, just use underlying legacy code.  Ulgh!!! This 	 silently and very indirectly updates the regcache's regcache 	 via the global deprecated_register_valid[].  */
name|legacy_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make certain that the register cache is up-to-date with respect      to the current thread.  This switching shouldn't be necessary      only there is still only one target side register cache.  Sigh!      On the bright side, at least there is a regcache object.  */
if|if
condition|(
operator|!
name|regcache
operator|->
name|readonly_p
condition|)
block|{
name|gdb_assert
argument_list|(
name|regcache
operator|==
name|current_regcache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_cached
argument_list|(
name|regnum
argument_list|)
condition|)
name|target_fetch_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the value directly into the register cache.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|register_buffer
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_read_signed
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|LONGEST
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_read_unsigned
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|ULONGEST
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_write_signed
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|LONGEST
name|val
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_write_unsigned
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|ULONGEST
name|val
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deprecated_read_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|current_regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|current_regcache
operator|->
name|descr
operator|->
name|gdbarch
operator|==
name|current_gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_regcache
operator|->
name|descr
operator|->
name|legacy_p
condition|)
block|{
name|legacy_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|regcache_cooked_read
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_read
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
condition|)
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regcache
operator|->
name|readonly_p
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
operator|&&
name|regcache
operator|->
name|register_valid_p
index|[
name|regnum
index|]
condition|)
comment|/* Read-only register cache, perhaphs the cooked value was cached?  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|register_buffer
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
else|else
name|gdbarch_pseudo_register_read
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|gdbarch
argument_list|,
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_read_signed
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|LONGEST
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_read_unsigned
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|ULONGEST
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_write_signed
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|LONGEST
name|val
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_write_unsigned
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|ULONGEST
name|val
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write register REGNUM at MYADDR to the target.  MYADDR points at    REGISTER_RAW_BYTES(REGNUM), which must be in target byte-order.  */
end_comment

begin_function
specifier|static
name|void
name|legacy_write_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|myaddr
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
comment|/* On the sparc, writing %g0 is a no-op, so we don't even want to      change the registers array if something writes to this register.  */
if|if
condition|(
name|CANNOT_STORE_REGISTER
argument_list|(
name|regnum
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
name|size
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_register
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* If we have a valid copy of the register, and new value == old 	 value, then don't bother doing the actual store. */
if|if
condition|(
name|register_cached
argument_list|(
name|regnum
argument_list|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|register_buffer
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|myaddr
argument_list|,
name|size
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
else|else
name|target_prepare_to_store
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|register_buffer
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|myaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|set_register_cached
argument_list|(
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_write
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
operator|&&
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|regcache
operator|->
name|readonly_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcache
operator|->
name|descr
operator|->
name|legacy_p
condition|)
block|{
comment|/* For moment, just use underlying legacy code.  Ulgh!!! This 	 silently and very indirectly updates the regcache's buffers 	 via the globals deprecated_register_valid[] and registers[].  */
name|gdb_assert
argument_list|(
name|regcache
operator|==
name|current_regcache
argument_list|)
expr_stmt|;
name|legacy_write_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* On the sparc, writing %g0 is a no-op, so we don't even want to      change the registers array if something writes to this register.  */
if|if
condition|(
name|CANNOT_STORE_REGISTER
argument_list|(
name|regnum
argument_list|)
condition|)
return|return;
comment|/* Make certain that the correct cache is selected.  */
name|gdb_assert
argument_list|(
name|regcache
operator|==
name|current_regcache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
comment|/* If we have a valid copy of the register, and new value == old      value, then don't bother doing the actual store. */
if|if
condition|(
name|regcache_valid_p
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|register_buffer
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|target_prepare_to_store
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|register_buffer
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|buf
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|regcache
operator|->
name|register_valid_p
index|[
name|regnum
index|]
operator|=
literal|1
expr_stmt|;
name|target_store_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deprecated_write_register_gen
parameter_list|(
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|current_regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|current_regcache
operator|->
name|descr
operator|->
name|gdbarch
operator|==
name|current_gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_regcache
operator|->
name|descr
operator|->
name|legacy_p
condition|)
block|{
name|legacy_write_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|regcache_cooked_write
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_write
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
condition|)
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|gdbarch_pseudo_register_write
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|gdbarch
argument_list|,
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy INLEN bytes of consecutive data from memory at MYADDR    into registers starting with the MYREGSTART'th byte of register data.  */
end_comment

begin_function
name|void
name|deprecated_write_register_bytes
parameter_list|(
name|int
name|myregstart
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|int
name|myregend
init|=
name|myregstart
operator|+
name|inlen
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|target_prepare_to_store
argument_list|()
expr_stmt|;
comment|/* Scan through the registers updating any that are covered by the      range myregstart<=>myregend using write_register_gen, which does      nice things like handling threads, and avoiding updates when the      new and old contents are the same.  */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|int
name|regstart
decl_stmt|,
name|regend
decl_stmt|;
name|regstart
operator|=
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|regend
operator|=
name|regstart
operator|+
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
comment|/* Is this register completely outside the range the user is writing?  */
if|if
condition|(
name|myregend
operator|<=
name|regstart
operator|||
name|regend
operator|<=
name|myregstart
condition|)
comment|/* do nothing */
empty_stmt|;
comment|/* Is this register completely within the range the user is writing?  */
elseif|else
if|if
condition|(
name|myregstart
operator|<=
name|regstart
operator|&&
name|regend
operator|<=
name|myregend
condition|)
name|deprecated_write_register_gen
argument_list|(
name|regnum
argument_list|,
name|myaddr
operator|+
operator|(
name|regstart
operator|-
name|myregstart
operator|)
argument_list|)
expr_stmt|;
comment|/* The register partially overlaps the range being written.  */
else|else
block|{
name|char
name|regbuf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* What's the overlap between this register's bytes and              those the caller wants to write?  */
name|int
name|overlapstart
init|=
name|max
argument_list|(
name|regstart
argument_list|,
name|myregstart
argument_list|)
decl_stmt|;
name|int
name|overlapend
init|=
name|min
argument_list|(
name|regend
argument_list|,
name|myregend
argument_list|)
decl_stmt|;
comment|/* We may be doing a partial update of an invalid register. 	     Update it from the target before scribbling on it.  */
name|deprecated_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|deprecated_registers
index|[
name|overlapstart
index|]
argument_list|,
name|myaddr
operator|+
operator|(
name|overlapstart
operator|-
name|myregstart
operator|)
argument_list|,
name|overlapend
operator|-
name|overlapstart
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform a partial register transfer using a read, modify, write    operation.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|regcache_read_ftype
function_decl|)
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
name|regcache_write_ftype
function_decl|)
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|void
name|regcache_xfer_part
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
specifier|const
name|void
modifier|*
name|out
parameter_list|,
name|regcache_read_ftype
modifier|*
name|read
parameter_list|,
name|regcache_write_ftype
modifier|*
name|write
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache
operator|->
name|descr
decl_stmt|;
name|bfd_byte
name|reg
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<=
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|>=
literal|0
operator|&&
name|offset
operator|+
name|len
operator|<=
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
comment|/* Something to do?  */
if|if
condition|(
name|offset
operator|+
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* Read (when needed) ... */
if|if
condition|(
name|in
operator|!=
name|NULL
operator|||
name|offset
operator|>
literal|0
operator|||
name|offset
operator|+
name|len
operator|<
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
condition|)
block|{
name|gdb_assert
argument_list|(
name|read
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* ... modify ... */
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|in
argument_list|,
name|reg
operator|+
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|reg
operator|+
name|offset
argument_list|,
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* ... write (when needed).  */
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
block|{
name|gdb_assert
argument_list|(
name|write
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|regcache_raw_read_part
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache
operator|->
name|descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|regcache_xfer_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
name|regcache_raw_read
argument_list|,
name|regcache_raw_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_raw_write_part
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache
operator|->
name|descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|regcache_xfer_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|regcache_raw_read
argument_list|,
name|regcache_raw_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_read_part
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache
operator|->
name|descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
name|regcache_xfer_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
name|regcache_cooked_read
argument_list|,
name|regcache_cooked_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regcache_cooked_write_part
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache
operator|->
name|descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
name|regcache_xfer_part
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|regcache_cooked_read
argument_list|,
name|regcache_cooked_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hack to keep code that view the register buffer as raw bytes    working.  */
end_comment

begin_function
name|int
name|register_offset_hack
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|regcache_descr
modifier|*
name|descr
init|=
name|regcache_descr
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|descr
operator|->
name|nr_cooked_registers
argument_list|)
expr_stmt|;
return|return
name|descr
operator|->
name|register_offset
index|[
name|regnum
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the contents of register REGNUM as an unsigned integer.  */
end_comment

begin_function
name|ULONGEST
name|read_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
decl_stmt|;
name|deprecated_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|read_register_pid
parameter_list|(
name|int
name|regnum
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|save_ptid
decl_stmt|;
name|int
name|save_pid
decl_stmt|;
name|CORE_ADDR
name|retval
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|retval
operator|=
name|read_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|save_ptid
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Store VALUE into the raw contents of register number REGNUM.  */
end_comment

begin_function
name|void
name|write_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|LONGEST
name|val
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|(
name|LONGEST
operator|)
name|val
argument_list|)
expr_stmt|;
name|deprecated_write_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_register_pid
parameter_list|(
name|int
name|regnum
parameter_list|,
name|CORE_ADDR
name|val
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|save_ptid
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|write_register
argument_list|(
name|regnum
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|save_ptid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: kettenis/20030828: We should get rid of supply_register and    regcache_collect in favour of regcache_raw_supply and    regcache_raw_collect.  */
end_comment

begin_comment
comment|/* SUPPLY_REGISTER()     Record that register REGNUM contains VAL.  This is used when the    value is obtained from the inferior or core dump, so there is no    need to store the value there.     If VAL is a NULL pointer, then it's probably an unsupported register.    We just set its value to all zeros.  We might want to record this    fact, and report it to the users of read_register and friends.  */
end_comment

begin_function
name|void
name|supply_register
parameter_list|(
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|)
block|{
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* On some architectures, e.g. HPPA, there are a few stray bits in      some registers, that the rest of the code would like to ignore.  */
comment|/* NOTE: cagney/2001-03-16: The macro CLEAN_UP_REGISTER_VALUE is      going to be deprecated.  Instead architectures will leave the raw      register value as is and instead clean things up as they pass      through the method gdbarch_pseudo_register_read() clean up the      values. */
ifdef|#
directive|ifdef
name|DEPRECATED_CLEAN_UP_REGISTER_VALUE
name|DEPRECATED_CLEAN_UP_REGISTER_VALUE
call|\
argument_list|(
name|regnum
argument_list|,
name|register_buffer
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|regcache_collect
parameter_list|(
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|regcache_raw_collect
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Supply register REGNUM, whose contents are stored in BUF, to REGCACHE.  */
end_comment

begin_function
name|void
name|regcache_raw_supply
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|void
modifier|*
name|regbuf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|regcache
operator|->
name|readonly_p
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/20030828: It shouldn't be necessary to handle      CURRENT_REGCACHE specially here.  */
if|if
condition|(
name|regcache
operator|==
name|current_regcache
operator|&&
operator|!
name|ptid_equal
argument_list|(
name|registers_ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|registers_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
name|regbuf
operator|=
name|register_buffer
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|size
operator|=
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|memcpy
argument_list|(
name|regbuf
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|regbuf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mark the register as cached.  */
name|regcache
operator|->
name|register_valid_p
index|[
name|regnum
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collect register REGNUM from REGCACHE and store its contents in BUF.  */
end_comment

begin_function
name|void
name|regcache_raw_collect
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|regbuf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|gdb_assert
argument_list|(
name|regcache
operator|!=
name|NULL
operator|&&
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
argument_list|)
expr_stmt|;
name|regbuf
operator|=
name|register_buffer
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|size
operator|=
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|regbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read_pc, write_pc, read_sp, deprecated_read_fp, etc.  Special    handling for registers PC, SP, and FP.  */
end_comment

begin_comment
comment|/* NOTE: cagney/2001-02-18: The functions read_pc_pid(), read_pc(),    read_sp(), and deprecated_read_fp(), will eventually be replaced by    per-frame methods.  Instead of relying on the global INFERIOR_PTID,    they will use the contextual information provided by the FRAME.    These functions do not belong in the register cache.  */
end_comment

begin_comment
comment|/* NOTE: cagney/2003-06-07: The functions generic_target_write_pc(),    write_pc_pid(), write_pc(), and deprecated_read_fp(), all need to    be replaced by something that does not rely on global state.  But    what?  */
end_comment

begin_function
name|CORE_ADDR
name|read_pc_pid
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|saved_inferior_ptid
decl_stmt|;
name|CORE_ADDR
name|pc_val
decl_stmt|;
comment|/* In case ptid != inferior_ptid. */
name|saved_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
if|if
condition|(
name|TARGET_READ_PC_P
argument_list|()
condition|)
name|pc_val
operator|=
name|TARGET_READ_PC
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
comment|/* Else use per-frame method on get_current_frame.  */
elseif|else
if|if
condition|(
name|PC_REGNUM
operator|>=
literal|0
condition|)
block|{
name|CORE_ADDR
name|raw_val
init|=
name|read_register_pid
argument_list|(
name|PC_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|pc_val
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|raw_val
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_pc_pid: Unable to find PC"
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|saved_inferior_ptid
expr_stmt|;
return|return
name|pc_val
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|read_pc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|read_pc_pid
argument_list|(
name|inferior_ptid
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|generic_target_write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|PC_REGNUM
operator|>=
literal|0
condition|)
name|write_register_pid
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"generic_target_write_pc"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_pc_pid
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|saved_inferior_ptid
decl_stmt|;
comment|/* In case ptid != inferior_ptid. */
name|saved_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|TARGET_WRITE_PC
argument_list|(
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|saved_inferior_ptid
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|write_pc_pid
argument_list|(
name|pc
argument_list|,
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cope with strage ways of getting to the stack and frame pointers */
end_comment

begin_function
name|CORE_ADDR
name|read_sp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_READ_SP_P
argument_list|()
condition|)
return|return
name|TARGET_READ_SP
argument_list|()
return|;
elseif|else
if|if
condition|(
name|gdbarch_unwind_sp_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
return|return
name|get_frame_sp
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
return|;
elseif|else
if|if
condition|(
name|SP_REGNUM
operator|>=
literal|0
condition|)
comment|/* Try SP_REGNUM last: this makes all sorts of [wrong] assumptions        about the architecture so put it at the end.  */
return|return
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
return|;
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_sp: Unable to find SP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deprecated_write_sp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|SP_REGNUM
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CORE_ADDR
name|deprecated_read_fp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|DEPRECATED_TARGET_READ_FP_P
argument_list|()
condition|)
return|return
name|DEPRECATED_TARGET_READ_FP
argument_list|()
return|;
elseif|else
if|if
condition|(
name|DEPRECATED_FP_REGNUM
operator|>=
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|DEPRECATED_FP_REGNUM
argument_list|)
return|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"deprecated_read_fp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reg_flush_command
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Force-flush the register cache.  */
name|registers_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Register cache flushed.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_regcache
parameter_list|(
name|void
parameter_list|)
block|{
name|current_regcache
operator|=
name|regcache_xmalloc
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
name|current_regcache
operator|->
name|readonly_p
operator|=
literal|0
expr_stmt|;
name|deprecated_registers
operator|=
name|deprecated_grub_regcache_for_registers
argument_list|(
name|current_regcache
argument_list|)
expr_stmt|;
name|deprecated_register_valid
operator|=
name|current_regcache
operator|->
name|register_valid_p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_endian_bytes
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|enum
name|bfd_endian
name|endian
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|endian
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Bad switch"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_enum
enum|enum
name|regcache_dump_what
block|{
name|regcache_dump_none
block|,
name|regcache_dump_raw
block|,
name|regcache_dump_cooked
block|,
name|regcache_dump_groups
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|regcache_dump
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|enum
name|regcache_dump_what
name|what_to_dump
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|regcache
operator|->
name|descr
operator|->
name|gdbarch
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|int
name|footnote_nr
init|=
literal|0
decl_stmt|;
name|int
name|footnote_register_size
init|=
literal|0
decl_stmt|;
name|int
name|footnote_register_offset
init|=
literal|0
decl_stmt|;
name|int
name|footnote_register_type_name_null
init|=
literal|0
decl_stmt|;
name|long
name|register_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|fprintf_unfiltered (file, "legacy_p %d\n", regcache->descr->legacy_p);   fprintf_unfiltered (file, "nr_raw_registers %d\n", 		      regcache->descr->nr_raw_registers);   fprintf_unfiltered (file, "nr_cooked_registers %d\n", 		      regcache->descr->nr_cooked_registers);   fprintf_unfiltered (file, "sizeof_raw_registers %ld\n", 		      regcache->descr->sizeof_raw_registers);   fprintf_unfiltered (file, "sizeof_raw_register_valid_p %ld\n", 		      regcache->descr->sizeof_raw_register_valid_p);   fprintf_unfiltered (file, "NUM_REGS %d\n", NUM_REGS);   fprintf_unfiltered (file, "NUM_PSEUDO_REGS %d\n", NUM_PSEUDO_REGS);
endif|#
directive|endif
name|gdb_assert
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
operator|==
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
operator|-
literal|1
init|;
name|regnum
operator|<
name|regcache
operator|->
name|descr
operator|->
name|nr_cooked_registers
condition|;
name|regnum
operator|++
control|)
block|{
comment|/* Name.  */
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %-10s"
argument_list|,
literal|"Name"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|p
operator|=
literal|"''"
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %-10s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Number.  */
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %4s"
argument_list|,
literal|"Nr"
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %4d"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
comment|/* Relative number.  */
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %4s"
argument_list|,
literal|"Rel"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|<
name|NUM_REGS
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %4d"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %4d"
argument_list|,
operator|(
name|regnum
operator|-
name|NUM_REGS
operator|)
argument_list|)
expr_stmt|;
comment|/* Offset.  */
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %6s  "
argument_list|,
literal|"Offset"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %6ld"
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|register_offset
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_offset
operator|!=
name|regcache
operator|->
name|descr
operator|->
name|register_offset
index|[
name|regnum
index|]
operator|||
name|register_offset
operator|!=
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
operator|||
operator|(
name|regnum
operator|>
literal|0
operator|&&
operator|(
name|regcache
operator|->
name|descr
operator|->
name|register_offset
index|[
name|regnum
index|]
operator|!=
operator|(
name|regcache
operator|->
name|descr
operator|->
name|register_offset
index|[
name|regnum
operator|-
literal|1
index|]
operator|+
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
operator|-
literal|1
index|]
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|footnote_register_offset
condition|)
name|footnote_register_offset
operator|=
operator|++
name|footnote_nr
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|footnote_register_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|register_offset
operator|=
operator|(
name|regcache
operator|->
name|descr
operator|->
name|register_offset
index|[
name|regnum
index|]
operator|+
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
operator|)
expr_stmt|;
block|}
comment|/* Size.  */
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %5s "
argument_list|,
literal|"Size"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %5ld"
argument_list|,
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
operator|!=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|)
operator|||
operator|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
operator|!=
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
operator|)
operator|||
operator|(
name|regcache
operator|->
name|descr
operator|->
name|sizeof_register
index|[
name|regnum
index|]
operator|!=
name|TYPE_LENGTH
argument_list|(
name|register_type
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|footnote_register_size
condition|)
name|footnote_register_size
operator|=
operator|++
name|footnote_nr
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|footnote_register_size
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* Type.  */
block|{
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|t
operator|=
literal|"Type"
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
name|blt
index|[]
init|=
literal|"builtin_type"
decl_stmt|;
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|register_type
argument_list|(
name|regcache
operator|->
name|descr
operator|->
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|footnote_register_type_name_null
condition|)
name|footnote_register_type_name_null
operator|=
operator|++
name|footnote_nr
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|n
argument_list|,
literal|"*%d"
argument_list|,
name|footnote_register_type_name_null
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|t
operator|=
name|n
expr_stmt|;
block|}
comment|/* Chop a leading builtin_type.  */
if|if
condition|(
name|strncmp
argument_list|(
name|t
argument_list|,
name|blt
argument_list|,
name|strlen
argument_list|(
name|blt
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|+=
name|strlen
argument_list|(
name|blt
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" %-15s"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Leading space always present.  */
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* Value, raw.  */
if|if
condition|(
name|what_to_dump
operator|==
name|regcache_dump_raw
condition|)
block|{
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"Raw value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|regcache
operator|->
name|descr
operator|->
name|nr_raw_registers
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<cooked>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|regcache_valid_p
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"<invalid>"
argument_list|)
expr_stmt|;
else|else
block|{
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|dump_endian_bytes
argument_list|(
name|file
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Value, cooked.  */
if|if
condition|(
name|what_to_dump
operator|==
name|regcache_dump_cooked
condition|)
block|{
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"Cooked value"
argument_list|)
expr_stmt|;
else|else
block|{
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|dump_endian_bytes
argument_list|(
name|file
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|buf
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Group members.  */
if|if
condition|(
name|what_to_dump
operator|==
name|regcache_dump_groups
condition|)
block|{
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"Groups"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|struct
name|reggroup
modifier|*
name|group
decl_stmt|;
for|for
control|(
name|group
operator|=
name|reggroup_next
argument_list|(
name|gdbarch
argument_list|,
name|NULL
argument_list|)
init|;
name|group
operator|!=
name|NULL
condition|;
name|group
operator|=
name|reggroup_next
argument_list|(
name|gdbarch
argument_list|,
name|group
argument_list|)
control|)
block|{
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|reggroup_name
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|","
expr_stmt|;
block|}
block|}
block|}
block|}
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|footnote_register_size
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"*%d: Inconsistent register sizes.\n"
argument_list|,
name|footnote_register_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|footnote_register_offset
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"*%d: Inconsistent register offsets.\n"
argument_list|,
name|footnote_register_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|footnote_register_type_name_null
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"*%d: Register type's name NULL.\n"
argument_list|,
name|footnote_register_type_name_null
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|regcache_print
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|enum
name|regcache_dump_what
name|what_to_dump
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|regcache_dump
argument_list|(
name|current_regcache
argument_list|,
name|gdb_stdout
argument_list|,
name|what_to_dump
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|ui_file
modifier|*
name|file
init|=
name|gdb_fopen
argument_list|(
name|args
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
literal|"maintenance print architecture"
argument_list|)
expr_stmt|;
name|regcache_dump
argument_list|(
name|current_regcache
argument_list|,
name|file
argument_list|,
name|what_to_dump
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_print_registers
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|regcache_print
argument_list|(
name|args
argument_list|,
name|regcache_dump_none
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_print_raw_registers
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|regcache_print
argument_list|(
name|args
argument_list|,
name|regcache_dump_raw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_print_cooked_registers
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|regcache_print
argument_list|(
name|args
argument_list|,
name|regcache_dump_cooked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_print_register_groups
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|regcache_print
argument_list|(
name|args
argument_list|,
name|regcache_dump_groups
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_regcache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototype */
end_comment

begin_function
name|void
name|_initialize_regcache
parameter_list|(
name|void
parameter_list|)
block|{
name|regcache_descr_handle
operator|=
name|register_gdbarch_data
argument_list|(
name|init_regcache_descr
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|current_regcache
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|deprecated_registers
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|deprecated_register_valid
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_regcache
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"flushregs"
argument_list|,
name|class_maintenance
argument_list|,
name|reg_flush_command
argument_list|,
literal|"Force gdb to flush its register cache (maintainer command)"
argument_list|)
expr_stmt|;
comment|/* Initialize the thread/process associated with the current set of       registers.  For now, -1 is special, and means `no current process'.  */
name|registers_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"registers"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_registers
argument_list|,
literal|"Print the internal register configuration.\ Takes an optional file parameter."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"raw-registers"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_raw_registers
argument_list|,
literal|"Print the internal register configuration including raw values.\ Takes an optional file parameter."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"cooked-registers"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_cooked_registers
argument_list|,
literal|"Print the internal register configuration including cooked values.\ Takes an optional file parameter."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"register-groups"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_register_groups
argument_list|,
literal|"Print the internal register configuration including each register's group.\ Takes an optional file parameter."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

