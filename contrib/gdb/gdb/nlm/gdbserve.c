begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gdbserve.c -- NLM debugging stub for Novell NetWare.     This is originally based on an m68k software stub written by Glenn    Engel at HP, but has changed quite a bit.  It was modified for the    i386 by Jim Kingdon, Cygnus Support.  It was modified to run under    NetWare by Ian Lance Taylor, Cygnus Support.     This code is intended to produce an NLM (a NetWare Loadable Module)    to run under Novell NetWare.  To create the NLM, compile this code    into an object file using the NLM SDK on any i386 host, and use the    nlmconv program (available in the GNU binutils) to transform the    resulting object file into an NLM.  */
end_comment

begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or it's performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<dfs.h>
end_include

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_include
include|#
directive|include
file|<advanced.h>
end_include

begin_include
include|#
directive|include
file|<debugapi.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<nwtypes.h>
end_include

begin_include
include|#
directive|include
file|<nwdfs.h>
end_include

begin_include
include|#
directive|include
file|<nwconio.h>
end_include

begin_include
include|#
directive|include
file|<nwadv.h>
end_include

begin_include
include|#
directive|include
file|<nwdbgapi.h>
end_include

begin_include
include|#
directive|include
file|<nwthread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<aio.h>
end_include

begin_include
include|#
directive|include
file|"cpu.h"
end_include

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/* This information is from Novell.  It is not in any of the standard    NetWare header files.  */
end_comment

begin_struct
struct|struct
name|DBG_LoadDefinitionStructure
block|{
name|void
modifier|*
name|reserved1
index|[
literal|4
index|]
decl_stmt|;
name|LONG
name|reserved5
decl_stmt|;
name|LONG
name|LDCodeImageOffset
decl_stmt|;
name|LONG
name|LDCodeImageLength
decl_stmt|;
name|LONG
name|LDDataImageOffset
decl_stmt|;
name|LONG
name|LDDataImageLength
decl_stmt|;
name|LONG
name|LDUninitializedDataLength
decl_stmt|;
name|LONG
name|LDCustomDataOffset
decl_stmt|;
name|LONG
name|LDCustomDataSize
decl_stmt|;
name|LONG
name|reserved6
index|[
literal|2
index|]
decl_stmt|;
name|LONG
function_decl|(
modifier|*
name|LDInitializationProcedure
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LO_NORMAL
value|0x0000
end_define

begin_define
define|#
directive|define
name|LO_STARTUP
value|0x0001
end_define

begin_define
define|#
directive|define
name|LO_PROTECT
value|0x0002
end_define

begin_define
define|#
directive|define
name|LO_DEBUG
value|0x0004
end_define

begin_define
define|#
directive|define
name|LO_AUTO_LOAD
value|0x0008
end_define

begin_comment
comment|/* Loader returned error codes */
end_comment

begin_define
define|#
directive|define
name|LOAD_COULD_NOT_FIND_FILE
value|1
end_define

begin_define
define|#
directive|define
name|LOAD_ERROR_READING_FILE
value|2
end_define

begin_define
define|#
directive|define
name|LOAD_NOT_NLM_FILE_FORMAT
value|3
end_define

begin_define
define|#
directive|define
name|LOAD_WRONG_NLM_FILE_VERSION
value|4
end_define

begin_define
define|#
directive|define
name|LOAD_REENTRANT_INITIALIZE_FAILURE
value|5
end_define

begin_define
define|#
directive|define
name|LOAD_CAN_NOT_LOAD_MULTIPLE_COPIES
value|6
end_define

begin_define
define|#
directive|define
name|LOAD_ALREADY_IN_PROGRESS
value|7
end_define

begin_define
define|#
directive|define
name|LOAD_NOT_ENOUGH_MEMORY
value|8
end_define

begin_define
define|#
directive|define
name|LOAD_INITIALIZE_FAILURE
value|9
end_define

begin_define
define|#
directive|define
name|LOAD_INCONSISTENT_FILE_FORMAT
value|10
end_define

begin_define
define|#
directive|define
name|LOAD_CAN_NOT_LOAD_AT_STARTUP
value|11
end_define

begin_define
define|#
directive|define
name|LOAD_AUTO_LOAD_MODULES_NOT_LOADED
value|12
end_define

begin_define
define|#
directive|define
name|LOAD_UNRESOLVED_EXTERNAL
value|13
end_define

begin_define
define|#
directive|define
name|LOAD_PUBLIC_ALREADY_DEFINED
value|14
end_define

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/* The main thread ID.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mainthread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An error message for the main thread to print.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|error_message
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The AIO port handle.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|AIOhandle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound    buffers.  At least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|(REGISTER_BYTES * 2 + 16)
end_define

begin_comment
comment|/* remote_debug> 0 prints ill-formed commands in valid packets and    checksum errors. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|breakpoint_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|mem2hex
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|may_fault
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|hex2mem
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|may_fault
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|set_step_traps
parameter_list|(
name|struct
name|StackFrame
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|clear_step_traps
parameter_list|(
name|struct
name|StackFrame
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|__main
parameter_list|()
block|{}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Read a character from the serial port.  This must busy wait, but    that's OK because we will be the only thread running anyhow.  */
end_comment

begin_function
specifier|static
name|int
name|getDebugChar
parameter_list|()
block|{
name|int
name|err
decl_stmt|;
name|LONG
name|got
decl_stmt|;
name|unsigned
name|char
name|ret
decl_stmt|;
do|do
block|{
name|err
operator|=
name|AIOReadData
argument_list|(
name|AIOhandle
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ret
argument_list|,
literal|1
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|error_message
operator|=
literal|"AIOReadData failed"
expr_stmt|;
name|ResumeThread
argument_list|(
name|mainthread
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|got
operator|==
literal|0
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Write a character to the serial port.  Returns 0 on failure,    non-zero on success.  */
end_comment

begin_function
specifier|static
name|int
name|putDebugChar
parameter_list|(
name|c
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|LONG
name|put
decl_stmt|;
name|put
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|put
operator|<
literal|1
condition|)
block|{
name|err
operator|=
name|AIOWriteData
argument_list|(
name|AIOhandle
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
literal|1
argument_list|,
operator|&
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|ConsolePrintf
argument_list|(
literal|"AIOWriteData: err = %d, put = %d\r\n"
argument_list|,
name|err
argument_list|,
name|put
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Turn a hex character into a number.  */
end_comment

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Scan for the sequence $<data>#<checksum>.  Returns 0 on failure,    non-zero on success.  */
end_comment

begin_function
specifier|static
name|int
name|getpacket
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|ch
decl_stmt|;
do|do
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|)
operator|!=
literal|'$'
condition|)
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|xmitcsum
operator|=
name|hex
argument_list|(
name|ch
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|ConsolePrintf
argument_list|(
literal|"bad checksum.  My count = 0x%x, sent=0x%x. buf=%s\n"
argument_list|,
name|checksum
argument_list|,
name|xmitcsum
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* failed checksum */
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* successful transfer */
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* remove sequence chars from buffer */
name|count
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
do|;
if|if
condition|(
name|remote_debug
condition|)
name|ConsolePrintf
argument_list|(
literal|"Received packet \"%s\"\r\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Send the packet in buffer.  Returns 0 on failure, non-zero on    success.  */
end_comment

begin_function
specifier|static
name|int
name|putpacket
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|ConsolePrintf
argument_list|(
literal|"Sending packet \"%s\"\r\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
condition|)
return|return
literal|0
return|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|0
return|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
operator|||
operator|!
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
operator|||
operator|!
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|%
literal|16
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'+'
condition|)
do|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|error
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|debug_error
parameter_list|(
name|format
parameter_list|,
name|parm
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|parm
decl_stmt|;
block|{
if|if
condition|(
name|remote_debug
condition|)
block|{
name|ConsolePrintf
argument_list|(
name|format
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|ConsolePrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is set if we could get a memory access fault.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mem_may_fault
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate to caller of mem2hex or hex2mem that there has been an    error.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|mem_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ALTERNATE_MEM_FUNCS
end_ifndef

begin_comment
comment|/* These are separate functions so that they are so short and sweet    that the compiler won't save any registers (if there is a fault    to mem_fault, they won't get restored, so there better not be any    saved).  */
end_comment

begin_function
name|int
name|get_char
parameter_list|(
name|addr
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|*
name|addr
return|;
block|}
end_function

begin_function
name|void
name|set_char
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
operator|*
name|addr
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTERNATE_MEM_FUNCS */
end_comment

begin_comment
comment|/* convert the memory pointed to by mem into hex, placing result in buf */
end_comment

begin_comment
comment|/* return a pointer to the last char put in buf (null) */
end_comment

begin_comment
comment|/* If MAY_FAULT is non-zero, then we should set mem_err in response to    a fault; if zero treat a fault like any other fault in the stub.  */
end_comment

begin_function
name|char
modifier|*
name|mem2hex
parameter_list|(
name|mem
parameter_list|,
name|buf
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|void
modifier|*
name|mem
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|mem
decl_stmt|;
name|mem_may_fault
operator|=
name|may_fault
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|ptr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_fault
operator|&&
name|mem_err
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|%
literal|16
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|mem_may_fault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem */
end_comment

begin_comment
comment|/* return a pointer to the character AFTER the last byte written */
end_comment

begin_function
name|char
modifier|*
name|hex2mem
parameter_list|(
name|buf
parameter_list|,
name|mem
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|mem
decl_stmt|;
name|mem_may_fault
operator|=
name|may_fault
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|ch
operator|+
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|set_char
argument_list|(
name|ptr
operator|++
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_fault
operator|&&
name|mem_err
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
block|}
name|mem_may_fault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function takes the 386 exception vector and attempts to    translate this number into a unix compatible signal value.  */
end_comment

begin_function
name|int
name|computeSignal
parameter_list|(
name|exceptionVector
parameter_list|)
name|int
name|exceptionVector
decl_stmt|;
block|{
name|int
name|sigval
decl_stmt|;
switch|switch
condition|(
name|exceptionVector
condition|)
block|{
case|case
literal|0
case|:
name|sigval
operator|=
literal|8
expr_stmt|;
break|break;
comment|/* divide by zero */
case|case
literal|1
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* debug exception */
case|case
literal|3
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint */
case|case
literal|4
case|:
name|sigval
operator|=
literal|16
expr_stmt|;
break|break;
comment|/* into instruction (overflow) */
case|case
literal|5
case|:
name|sigval
operator|=
literal|16
expr_stmt|;
break|break;
comment|/* bound instruction */
case|case
literal|6
case|:
name|sigval
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* Invalid opcode */
case|case
literal|7
case|:
name|sigval
operator|=
literal|8
expr_stmt|;
break|break;
comment|/* coprocessor not available */
case|case
literal|8
case|:
name|sigval
operator|=
literal|7
expr_stmt|;
break|break;
comment|/* double fault */
case|case
literal|9
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* coprocessor segment overrun */
case|case
literal|10
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* Invalid TSS */
case|case
literal|11
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* Segment not present */
case|case
literal|12
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* stack exception */
case|case
literal|13
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* general protection */
case|case
literal|14
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* page fault */
case|case
literal|16
case|:
name|sigval
operator|=
literal|7
expr_stmt|;
break|break;
comment|/* coprocessor error */
default|default:
name|sigval
operator|=
literal|7
expr_stmt|;
comment|/* "software generated"*/
block|}
return|return
operator|(
name|sigval
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************/
end_comment

begin_comment
comment|/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
end_comment

begin_comment
comment|/* RETURN NUMBER OF CHARS PROCESSED           */
end_comment

begin_comment
comment|/**********************************************/
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|ptr
parameter_list|,
name|intValue
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
modifier|*
name|intValue
decl_stmt|;
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|>=
literal|0
condition|)
block|{
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
block|}
else|else
break|break;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function does all command processing for interfacing to gdb.    It is called whenever an exception occurs in the module being    debugged.  */
end_comment

begin_function
specifier|static
name|LONG
name|handle_exception
parameter_list|(
name|frame
parameter_list|)
name|struct
name|StackFrame
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|addr
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|struct
name|DBG_LoadDefinitionStructure
modifier|*
name|ldinfo
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|first_insn
index|[
name|BREAKPOINT_SIZE
index|]
decl_stmt|;
comment|/* The first instruction in the program.  */
if|#
directive|if
literal|0
comment|/* According to some documentation from Novell, the bell sometimes      may be ringing at this point.  This can be stopped on Netware 4      systems by calling the undocumented StopBell() function. */
block|StopBell ();
endif|#
directive|endif
if|if
condition|(
name|remote_debug
condition|)
block|{
name|ConsolePrintf
argument_list|(
literal|"vector=%d: %s, pc=%08x, thread=%08x\r\n"
argument_list|,
name|frame
operator|->
name|ExceptionNumber
argument_list|,
name|frame
operator|->
name|ExceptionDescription
argument_list|,
name|frame
operator|->
name|ExceptionPC
argument_list|,
name|GetThreadID
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|frame
operator|->
name|ExceptionNumber
condition|)
block|{
case|case
name|START_NLM_EVENT
case|:
comment|/* If the NLM just started, we record the module load information 	 and the thread ID, and set a breakpoint at the first instruction 	 in the program.  */
name|ldinfo
operator|=
operator|(
operator|(
expr|struct
name|DBG_LoadDefinitionStructure
operator|*
operator|)
name|frame
operator|->
name|ExceptionErrorCode
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|first_insn
argument_list|,
name|ldinfo
operator|->
name|LDInitializationProcedure
argument_list|,
name|BREAKPOINT_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ldinfo
operator|->
name|LDInitializationProcedure
argument_list|,
name|breakpoint_insn
argument_list|,
name|BREAKPOINT_SIZE
argument_list|)
expr_stmt|;
name|flush_i_cache
argument_list|()
expr_stmt|;
return|return
name|RETURN_TO_PROGRAM
return|;
case|case
name|ENTER_DEBUGGER_EVENT
case|:
case|case
name|KEYBOARD_BREAK_EVENT
case|:
comment|/* Pass some events on to the next debugger, in case it will handle 	 them.  */
return|return
name|RETURN_TO_NEXT_DEBUGGER
return|;
case|case
literal|3
case|:
comment|/* Breakpoint */
comment|/* After we've reached the initial breakpoint, reset it.  */
if|if
condition|(
name|frame
operator|->
name|ExceptionPC
operator|-
name|DECR_PC_AFTER_BREAK
operator|==
operator|(
name|LONG
operator|)
name|ldinfo
operator|->
name|LDInitializationProcedure
operator|&&
name|memcmp
argument_list|(
name|ldinfo
operator|->
name|LDInitializationProcedure
argument_list|,
name|breakpoint_insn
argument_list|,
name|BREAKPOINT_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ldinfo
operator|->
name|LDInitializationProcedure
argument_list|,
name|first_insn
argument_list|,
name|BREAKPOINT_SIZE
argument_list|)
expr_stmt|;
name|frame
operator|->
name|ExceptionPC
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|flush_i_cache
argument_list|()
expr_stmt|;
block|}
comment|/* Normal breakpoints end up here */
name|do_status
argument_list|(
name|remcomOutBuffer
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* At the moment, we don't care about most of the unusual NetWare 	 exceptions.  */
if|if
condition|(
name|frame
operator|->
name|ExceptionNumber
operator|>
literal|31
condition|)
return|return
name|RETURN_TO_PROGRAM
return|;
comment|/* Most machine level exceptions end up here */
name|do_status
argument_list|(
name|remcomOutBuffer
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* Segment not present */
case|case
literal|13
case|:
comment|/* General protection */
case|case
literal|14
case|:
comment|/* Page fault */
comment|/* If we get a GP fault, and mem_may_fault is set, and the 	 instruction pointer is near set_char or get_char, then we caused 	 the fault ourselves accessing an illegal memory location.  */
if|if
condition|(
name|mem_may_fault
operator|&&
operator|(
operator|(
name|frame
operator|->
name|ExceptionPC
operator|>=
operator|(
name|long
operator|)
operator|&
name|set_char
operator|&&
name|frame
operator|->
name|ExceptionPC
operator|<
operator|(
name|long
operator|)
operator|&
name|set_char
operator|+
literal|50
operator|)
operator|||
operator|(
name|frame
operator|->
name|ExceptionPC
operator|>=
operator|(
name|long
operator|)
operator|&
name|get_char
operator|&&
name|frame
operator|->
name|ExceptionPC
operator|<
operator|(
name|long
operator|)
operator|&
name|get_char
operator|+
literal|50
operator|)
operator|)
condition|)
block|{
name|mem_err
operator|=
literal|1
expr_stmt|;
comment|/* Point the instruction pointer at an assembly language stub 	     which just returns from the function.  */
name|frame
operator|->
name|ExceptionPC
operator|+=
literal|4
expr_stmt|;
comment|/* Skip the load or store */
comment|/* Keep going.  This will act as though it returned from 	     set_char or get_char.  The calling routine will check 	     mem_err, and do the right thing.  */
return|return
name|RETURN_TO_PROGRAM
return|;
block|}
comment|/* Random mem fault, report it */
name|do_status
argument_list|(
name|remcomOutBuffer
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
case|case
name|TERMINATE_NLM_EVENT
case|:
comment|/* There is no way to get the exit status.  */
name|sprintf
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"W%02x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* We generate our own status */
block|}
comment|/* FIXME: How do we know that this exception has anything to do with      the program we are debugging?  We can check whether the PC is in      the range of the module we are debugging, but that doesn't help      much since an error could occur in a library routine.  */
name|clear_step_traps
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
condition|)
return|return
name|RETURN_TO_NEXT_DEBUGGER
return|;
if|if
condition|(
name|frame
operator|->
name|ExceptionNumber
operator|==
name|TERMINATE_NLM_EVENT
condition|)
block|{
name|ResumeThread
argument_list|(
name|mainthread
argument_list|)
expr_stmt|;
return|return
name|RETURN_TO_PROGRAM
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|getpacket
argument_list|(
name|remcomInBuffer
argument_list|)
condition|)
return|return
name|RETURN_TO_NEXT_DEBUGGER
return|;
switch|switch
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|do_status
argument_list|(
name|remcomOutBuffer
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|remote_debug
operator|=
operator|!
operator|(
name|remote_debug
operator|)
expr_stmt|;
comment|/* toggle debug flag */
break|break;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
name|frame_to_registers
argument_list|(
name|frame
argument_list|,
name|remcomOutBuffer
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* set the value of the CPU registers - return OK */
name|registers_to_frame
argument_list|(
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
condition|)
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
name|ptr
operator|=
literal|0
expr_stmt|;
name|mem_err
operator|=
literal|0
expr_stmt|;
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
name|debug_error
argument_list|(
literal|"memory fault"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptr
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
name|debug_error
argument_list|(
literal|"malformed read memory command: %s"
argument_list|,
name|remcomInBuffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
condition|)
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|':'
condition|)
block|{
name|mem_err
operator|=
literal|0
expr_stmt|;
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
name|debug_error
argument_list|(
literal|"memory fault"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ptr
condition|)
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
name|debug_error
argument_list|(
literal|"malformed write memory command: %s"
argument_list|,
name|remcomInBuffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
case|case
literal|'s'
case|:
comment|/* cAA..AA    Continue at address AA..AA(optional) */
comment|/* sAA..AA   Step one instruction from AA..AA(optional) */
comment|/* try to read optional parameter, pc unchanged if no parm */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
comment|/*	      registers[PC_REGNUM].lo = addr;*/
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting PC to 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
name|set_step_traps
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|flush_i_cache
argument_list|()
expr_stmt|;
return|return
name|RETURN_TO_PROGRAM
return|;
case|case
literal|'k'
case|:
comment|/* kill the program */
name|KillMe
argument_list|(
name|ldinfo
argument_list|)
expr_stmt|;
name|ResumeThread
argument_list|(
name|mainthread
argument_list|)
expr_stmt|;
return|return
name|RETURN_TO_PROGRAM
return|;
case|case
literal|'q'
case|:
comment|/* Query message */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
argument_list|,
literal|"Offsets"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"Text=%x;Data=%x;Bss=%x"
argument_list|,
name|ldinfo
operator|->
name|LDCodeImageOffset
argument_list|,
name|ldinfo
operator|->
name|LDDataImageOffset
argument_list|,
name|ldinfo
operator|->
name|LDDataImageOffset
operator|+
name|ldinfo
operator|->
name|LDDataImageLength
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E04, Unknown query %s"
argument_list|,
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* reply to the request */
if|if
condition|(
operator|!
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
condition|)
return|return
name|RETURN_TO_NEXT_DEBUGGER
return|;
block|}
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|bitRate
block|{
name|BYTE
name|bitRate
decl_stmt|;
specifier|const
name|char
modifier|*
name|bitRateString
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|bitRate
name|bitRateTable
index|[]
init|=
block|{
block|{
name|AIO_BAUD_50
block|,
literal|"50"
block|}
block|,
block|{
name|AIO_BAUD_75
block|,
literal|"75"
block|}
block|,
block|{
name|AIO_BAUD_110
block|,
literal|"110"
block|}
block|,
block|{
name|AIO_BAUD_134p5
block|,
literal|"134.5"
block|}
block|,
block|{
name|AIO_BAUD_150
block|,
literal|"150"
block|}
block|,
block|{
name|AIO_BAUD_300
block|,
literal|"300"
block|}
block|,
block|{
name|AIO_BAUD_600
block|,
literal|"600"
block|}
block|,
block|{
name|AIO_BAUD_1200
block|,
literal|"1200"
block|}
block|,
block|{
name|AIO_BAUD_1800
block|,
literal|"1800"
block|}
block|,
block|{
name|AIO_BAUD_2000
block|,
literal|"2000"
block|}
block|,
block|{
name|AIO_BAUD_2400
block|,
literal|"2400"
block|}
block|,
block|{
name|AIO_BAUD_3600
block|,
literal|"3600"
block|}
block|,
block|{
name|AIO_BAUD_4800
block|,
literal|"4800"
block|}
block|,
block|{
name|AIO_BAUD_7200
block|,
literal|"7200"
block|}
block|,
block|{
name|AIO_BAUD_9600
block|,
literal|"9600"
block|}
block|,
block|{
name|AIO_BAUD_19200
block|,
literal|"19200"
block|}
block|,
block|{
name|AIO_BAUD_38400
block|,
literal|"38400"
block|}
block|,
block|{
name|AIO_BAUD_57600
block|,
literal|"57600"
block|}
block|,
block|{
name|AIO_BAUD_115200
block|,
literal|"115200"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dataBitsTable
index|[]
init|=
literal|"5678"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stopBitsTable
index|[]
init|=
block|{
literal|"1"
block|,
literal|"1.5"
block|,
literal|"2"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|parity
index|[]
init|=
literal|"NOEMS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start up.  The main thread opens the named serial I/O port, loads    the named NLM module and then goes to sleep.  The serial I/O port    is named as a board number and a port number.  It would be more DOS    like to provide a menu of available serial ports, but I don't want    to have to figure out how to do that.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|hardware
decl_stmt|,
name|board
decl_stmt|,
name|port
decl_stmt|;
name|BYTE
name|bitRate
decl_stmt|;
name|BYTE
name|dataBits
decl_stmt|;
name|BYTE
name|stopBits
decl_stmt|;
name|BYTE
name|parityMode
decl_stmt|;
name|LONG
name|err
decl_stmt|;
name|struct
name|debuggerStructure
name|s
decl_stmt|;
name|int
name|cmdindx
decl_stmt|;
name|char
modifier|*
name|cmdlin
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* set progname */
name|progname
operator|=
literal|"gdbserve"
expr_stmt|;
comment|/* set default serial line */
name|hardware
operator|=
operator|-
literal|1
expr_stmt|;
name|board
operator|=
literal|0
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
comment|/* set default serial line characteristics */
name|bitRate
operator|=
name|AIO_BAUD_9600
expr_stmt|;
name|dataBits
operator|=
name|AIO_DATA_BITS_8
expr_stmt|;
name|stopBits
operator|=
name|AIO_STOP_BITS_1
expr_stmt|;
name|parityMode
operator|=
name|AIO_PARITY_NONE
expr_stmt|;
name|cmdindx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
operator|*
name|argv
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|strnicmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"BAUD="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bitRate
modifier|*
name|brp
decl_stmt|;
name|bp
operator|=
operator|*
name|argv
operator|+
literal|5
expr_stmt|;
for|for
control|(
name|brp
operator|=
name|bitRateTable
init|;
name|brp
operator|->
name|bitRate
operator|!=
operator|(
name|BYTE
operator|)
operator|-
literal|1
condition|;
name|brp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|brp
operator|->
name|bitRateString
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bitRate
operator|=
name|brp
operator|->
name|bitRate
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|brp
operator|->
name|bitRateString
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: unknown or unsupported bit rate"
argument_list|,
name|progname
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strnicmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"BOARD="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
operator|*
name|argv
operator|+
literal|6
expr_stmt|;
name|board
operator|=
name|strtol
argument_list|(
name|bp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|bp
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: expected integer argument\n"
argument_list|,
name|progname
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|1
comment|/* FIXME: this option has been depricated */
elseif|else
if|if
condition|(
name|strnicmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"NODE="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
operator|*
name|argv
operator|+
literal|5
expr_stmt|;
name|board
operator|=
name|strtol
argument_list|(
name|bp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|bp
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: expected integer argument\n"
argument_list|,
name|progname
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strnicmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"PORT="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
operator|*
name|argv
operator|+
literal|5
expr_stmt|;
name|port
operator|=
name|strtol
argument_list|(
name|bp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|bp
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: expected integer argument\n"
argument_list|,
name|progname
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|cmdindx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: load %s [options] program [arguments]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|AIOAcquirePort
argument_list|(
operator|&
name|hardware
argument_list|,
operator|&
name|board
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|AIOhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|AIO_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|AIO_PORT_NOT_AVAILABLE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Port not available\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIO_BOARD_NUMBER_INVALID
case|:
case|case
name|AIO_PORT_NUMBER_INVALID
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No such port\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open port: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|AIOConfigurePort
argument_list|(
name|AIOhandle
argument_list|,
name|bitRate
argument_list|,
name|dataBits
argument_list|,
name|stopBits
argument_list|,
name|parityMode
argument_list|,
name|AIO_HARDWARE_FLOW_CONTROL_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|AIO_QUALIFIED_SUCCESS
condition|)
block|{
name|AIOPORTCONFIG
name|portConfig
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Port configuration changed!\n"
argument_list|)
expr_stmt|;
name|portConfig
operator|.
name|returnLength
operator|=
sizeof|sizeof
argument_list|(
name|portConfig
argument_list|)
expr_stmt|;
name|AIOGetPortConfiguration
argument_list|(
name|AIOhandle
argument_list|,
operator|&
name|portConfig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Bit Rate: %s, Data Bits: %c, Stop Bits: %s, Parity: %c,\  Flow:%s\n"
argument_list|,
name|bitRateTable
index|[
name|portConfig
operator|.
name|bitRate
index|]
operator|.
name|bitRateString
argument_list|,
name|dataBitsTable
index|[
name|portConfig
operator|.
name|dataBits
index|]
argument_list|,
name|stopBitsTable
index|[
name|portConfig
operator|.
name|stopBits
index|]
argument_list|,
name|parity
index|[
name|portConfig
operator|.
name|parityMode
index|]
argument_list|,
name|portConfig
operator|.
name|flowCtrlMode
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|AIO_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not configure port: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|AIOReleasePort
argument_list|(
name|AIOhandle
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AIOSetExternalControl
argument_list|(
name|AIOhandle
argument_list|,
name|AIO_EXTERNAL_CONTROL
argument_list|,
operator|(
name|AIO_EXTCTRL_DTR
operator||
name|AIO_EXTCTRL_RTS
operator|)
argument_list|)
operator|!=
name|AIO_SUCCESS
condition|)
block|{
name|LONG
name|extStatus
decl_stmt|,
name|chgdExtStatus
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not set desired port controls!\n"
argument_list|)
expr_stmt|;
name|AIOGetExternalStatus
argument_list|(
name|AIOhandle
argument_list|,
operator|&
name|extStatus
argument_list|,
operator|&
name|chgdExtStatus
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Port controls now: %d, %d\n"
argument_list|,
name|extStatus
argument_list|,
name|chgdExtStatus
argument_list|)
expr_stmt|;
block|}
comment|/* Register ourselves as an alternate debugger.  */
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|s
argument_list|)
expr_stmt|;
name|s
operator|.
name|DDSResourceTag
operator|=
operator|(
operator|(
expr|struct
name|ResourceTagStructure
operator|*
operator|)
name|AllocateResourceTag
argument_list|(
name|GetNLMHandle
argument_list|()
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
literal|"gdbserver"
argument_list|,
name|DebuggerSignature
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|DDSResourceTag
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AllocateResourceTag failed\n"
argument_list|)
expr_stmt|;
name|AIOReleasePort
argument_list|(
name|AIOhandle
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|DDSdebuggerEntry
operator|=
name|handle_exception
expr_stmt|;
name|s
operator|.
name|DDSFlags
operator|=
name|TSS_FRAME_BIT
expr_stmt|;
name|err
operator|=
name|RegisterDebuggerRTag
argument_list|(
operator|&
name|s
argument_list|,
name|AT_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RegisterDebuggerRTag failed\n"
argument_list|)
expr_stmt|;
name|AIOReleasePort
argument_list|(
name|AIOhandle
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the command line we were invoked with, and advance it past      our name and the board and port arguments.  */
name|cmdlin
operator|=
name|getcmd
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdindx
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cmdlin
argument_list|)
condition|)
operator|++
name|cmdlin
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cmdlin
argument_list|)
condition|)
operator|++
name|cmdlin
expr_stmt|;
block|}
comment|/* In case GDB is started before us, ack any packets (presumably      "$?#xx") sitting there.  */
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"putDebugChar failed\n"
argument_list|)
expr_stmt|;
name|UnRegisterDebugger
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|AIOReleasePort
argument_list|(
name|AIOhandle
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mainthread
operator|=
name|GetThreadID
argument_list|()
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|ConsolePrintf
argument_list|(
literal|"About to call LoadModule with \"%s\" %08x\r\n"
argument_list|,
name|cmdlin
argument_list|,
name|__GetScreenID
argument_list|(
name|GetCurrentScreen
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start up the module to be debugged.  */
name|err
operator|=
name|LoadModule
argument_list|(
operator|(
expr|struct
name|ScreenStruct
operator|*
operator|)
name|__GetScreenID
argument_list|(
name|GetCurrentScreen
argument_list|()
argument_list|)
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|cmdlin
argument_list|,
name|LO_DEBUG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LoadModule failed: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|UnRegisterDebugger
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|AIOReleasePort
argument_list|(
name|AIOhandle
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for the debugger to wake us up.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|ConsolePrintf
argument_list|(
literal|"Suspending main thread (%08x)\r\n"
argument_list|,
name|mainthread
argument_list|)
expr_stmt|;
name|SuspendThread
argument_list|(
name|mainthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|ConsolePrintf
argument_list|(
literal|"Resuming main thread (%08x)\r\n"
argument_list|,
name|mainthread
argument_list|)
expr_stmt|;
comment|/* If we are woken up, print an optional error message, deregister      ourselves and exit.  */
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
name|UnRegisterDebugger
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|AIOReleasePort
argument_list|(
name|AIOhandle
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

