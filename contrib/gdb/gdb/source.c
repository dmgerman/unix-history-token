begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* List lines of source files for GDB, the GNU debugger.    Copyright 1986, 87, 88, 89, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CRLF_SOURCE_FILES
end_ifdef

begin_comment
comment|/* Define CRLF_SOURCE_FILES in an xm-*.h file if source files on the    host use \r\n rather than just \n.  Defining CRLF_SOURCE_FILES is    much faster than defining LSEEK_NOT_LINEAR.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPEN_MODE
value|(O_RDONLY | O_BINARY)
end_define

begin_define
define|#
directive|define
name|FDOPEN_MODE
value|FOPEN_RB
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (CRLF_SOURCE_FILES) */
end_comment

begin_define
define|#
directive|define
name|OPEN_MODE
value|O_RDONLY
end_define

begin_define
define|#
directive|define
name|FDOPEN_MODE
value|FOPEN_RT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (CRLF_SOURCE_FILES) */
end_comment

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|int
name|open_source_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|find_source_lines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_decl_stmt
name|void
name|_initialize_source
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_filename_and_charpos
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reverse_search_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forward_search_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|line_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ambiguous_line_spec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtabs_and_lines
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|source_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_directories
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Path of directories to search for source files.    Same format as the PATH environment variable's value.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symtab of default file for listing lines of.  */
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|current_source_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default next line to list.  */
end_comment

begin_decl_stmt
name|int
name|current_source_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default number of lines to print with commands like "list".    This is based on guessing how many long (i.e. more than chars_per_line    characters) lines there will be.  To be completely correct, "list"    and friends should be rewritten to count characters and see where    things are wrapping, but that would be a fair amount of work.  */
end_comment

begin_decl_stmt
name|int
name|lines_to_list
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last line printed.  Default for various commands.    current_source_line is usually, but not always, the same as this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_line_listed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line number listed by last listing command.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_line_listed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saves the name of the last source file visited and a possible error code.    Used to prevent repeating annoying "No such file or directories" msgs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|last_source_visited
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_source_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Set the source file default for the "list" command to be S.     If S is NULL, and we don't have a default, find one.  This    should only be called when the user actually tries to use the    default, since we produce an error if we can't find a reasonable    default.  Also, since this can cause symbols to be read, doing it    before we need to would make things slower than necessary.  */
end_comment

begin_function
name|void
name|select_source_symtab
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|cs_pst
init|=
literal|0
decl_stmt|;
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
comment|/* Make the default place to list be the function `main'      if one exists.  */
if|if
condition|(
name|lookup_symbol
argument_list|(
literal|"main"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
literal|"main"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
block|}
comment|/* All right; find the last file in the symtab list (ignoring .h's).  */
name|current_source_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ofp
operator|=
name|object_files
init|;
name|ofp
operator|!=
name|NULL
condition|;
name|ofp
operator|=
name|ofp
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|ofp
operator|->
name|symtabs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|STREQ
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
comment|/* Howabout the partial symbol tables? */
for|for
control|(
name|ofp
operator|=
name|object_files
init|;
name|ofp
operator|!=
name|NULL
condition|;
name|ofp
operator|=
name|ofp
operator|->
name|next
control|)
block|{
for|for
control|(
name|ps
operator|=
name|ofp
operator|->
name|psymtabs
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|ps
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|STREQ
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cs_pst
operator|=
name|ps
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cs_pst
condition|)
block|{
if|if
condition|(
name|cs_pst
operator|->
name|readin
condition|)
block|{
name|fatal
argument_list|(
literal|"Internal: select_source_symtab: readin pst found and no symtabs."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_source_symtab
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|cs_pst
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
name|error
argument_list|(
literal|"Can't find a default source file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|show_directories
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"Source directories searched: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|source_path
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget what we learned about line positions in source files, and    which directories contain them; must check again now since files    may be found in a different directory now.  */
end_comment

begin_function
name|void
name|forget_cached_source_info
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|init_source_path
parameter_list|()
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$cdir%c$cwd"
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
name|source_path
operator|=
name|strsave
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|forget_cached_source_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of the source path.  */
end_comment

begin_function
name|void
name|directory_command
parameter_list|(
name|dirname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* FIXME, this goes to "delete dir"... */
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Reinitialize source path to empty? "
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|source_path
argument_list|)
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|mod_path
argument_list|(
name|dirname
argument_list|,
operator|&
name|source_path
argument_list|)
expr_stmt|;
name|last_source_visited
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|show_directories
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|forget_cached_source_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of an arbitrary path.  */
end_comment

begin_function
name|void
name|mod_path
parameter_list|(
name|dirname
parameter_list|,
name|which_path
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|char
modifier|*
modifier|*
name|which_path
decl_stmt|;
block|{
name|char
modifier|*
name|old
init|=
operator|*
name|which_path
decl_stmt|;
name|int
name|prefix
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
return|return;
name|dirname
operator|=
name|strsave
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|name
init|=
name|dirname
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
block|{
name|char
modifier|*
name|separator
init|=
name|strchr
argument_list|(
name|name
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
decl_stmt|;
name|char
modifier|*
name|space
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tab
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|separator
operator|==
literal|0
operator|&&
name|space
operator|==
literal|0
operator|&&
name|tab
operator|==
literal|0
condition|)
name|p
operator|=
name|dirname
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|separator
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|separator
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|separator
expr_stmt|;
if|if
condition|(
name|space
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|space
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|tab
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|tab
expr_stmt|;
name|dirname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|dirname
operator|==
name|DIRNAME_SEPARATOR
operator|||
operator|*
name|dirname
operator|==
literal|' '
operator|||
operator|*
name|dirname
operator|==
literal|'\t'
condition|)
operator|++
name|dirname
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|_WIN32
comment|/* On win32 h:\ is different to h: */
if|if
condition|(
name|SLASH_P
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
comment|/* Sigh. "foo/" => "foo" */
operator|--
name|p
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|1
condition|)
block|{
comment|/* "." => getwd ().  */
name|name
operator|=
name|current_directory
expr_stmt|;
goto|goto
name|append
goto|;
block|}
elseif|else
if|if
condition|(
name|SLASH_P
argument_list|(
name|p
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|2
condition|)
block|{
comment|/* "/." => "/".  */
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|append
goto|;
block|}
else|else
block|{
comment|/* "...foo/." => "...foo".  */
name|p
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ROOTED_P
argument_list|(
name|name
argument_list|)
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
name|name
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|SLASH_STRING
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Unless it's a variable, check existence.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
comment|/* These are warnings, not errors, since we don't want a 	   non-existent directory in a .gdbinit file to stop processing 	   of the .gdbinit file.  	   Whether they get added to the path is more debatable.  Current 	   answer is yes, in case the user wants to go make the directory 	   or whatever.  If the directory continues to not exist/not be 	   a directory/etc, then having them in the path should be 	   harmless.  */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Warning: "
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|name
argument_list|,
name|save_errno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
name|warning
argument_list|(
literal|"%s is not a directory."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|append
label|:
block|{
specifier|register
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|p
operator|=
operator|*
name|which_path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|len
index|]
operator|==
name|DIRNAME_SEPARATOR
operator|)
condition|)
block|{
comment|/* Found it in the search path, remove old copy */
if|if
condition|(
name|p
operator|>
operator|*
name|which_path
condition|)
name|p
operator|--
expr_stmt|;
comment|/* Back over leading separator */
if|if
condition|(
name|prefix
operator|>
name|p
operator|-
operator|*
name|which_path
condition|)
goto|goto
name|skip_dup
goto|;
comment|/* Same dir twice in one cmd */
name|strcpy
argument_list|(
name|p
argument_list|,
operator|&
name|p
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Copy from next \0 or  : */
block|}
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
operator|++
name|p
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|char
name|tinybuf
index|[
literal|2
index|]
decl_stmt|;
name|tinybuf
index|[
literal|0
index|]
operator|=
name|DIRNAME_SEPARATOR
expr_stmt|;
name|tinybuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If we have already tacked on a name(s) in this command,			   be sure they stay on the front as we tack on some more.  */
if|if
condition|(
name|prefix
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|old
index|[
name|prefix
index|]
expr_stmt|;
name|old
index|[
name|prefix
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|concat
argument_list|(
name|old
argument_list|,
name|tinybuf
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|old
index|[
name|prefix
index|]
operator|=
name|c
expr_stmt|;
operator|*
name|which_path
operator|=
name|concat
argument_list|(
name|temp
argument_list|,
literal|""
argument_list|,
operator|&
name|old
index|[
name|prefix
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|which_path
operator|=
name|concat
argument_list|(
name|name
argument_list|,
operator|(
name|old
index|[
literal|0
index|]
condition|?
name|tinybuf
else|:
name|old
operator|)
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|old
operator|=
operator|*
name|which_path
expr_stmt|;
block|}
block|}
name|skip_dup
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|*
name|dirname
operator|!=
literal|'\0'
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|source_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|current_source_symtab
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No current source file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Current source file is %s\n"
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|dirname
condition|)
name|printf_filtered
argument_list|(
literal|"Compilation directory is %s\n"
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
name|printf_filtered
argument_list|(
literal|"Located in %s\n"
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nlines
condition|)
name|printf_filtered
argument_list|(
literal|"Contains %d line%s.\n"
argument_list|,
name|s
operator|->
name|nlines
argument_list|,
name|s
operator|->
name|nlines
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source language is %s.\n"
argument_list|,
name|language_str
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Compiled with %s debugging format.\n"
argument_list|,
name|s
operator|->
name|debugformat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file named STRING, searching path PATH (dir names sep by some char)    using mode MODE and protection bits PROT in the calls to open.     If TRY_CWD_FIRST, try to open ./STRING before searching PATH.    (ie pretend the first element of PATH is ".").  This also indicates    that a slash in STRING disables searching of the path (this is    so that "exec-file ./foo" or "symbol-file ./foo" insures that you    get that particular version of foo or an error message).     If FILENAMED_OPENED is non-null, set it to a newly allocated string naming    the actual file opened (this string will always start with a "/".  We    have to take special pains to avoid doubling the "/" between the directory    and the file, sigh!  Emacs gets confuzzed by this when we print the    source file name!!!      If a file is found, return the descriptor.    Otherwise, return -1, with errno set for the last name we tried to open.  */
end_comment

begin_comment
comment|/*>>>> This should only allow files of certain types,>>>>  eg executable, non-directory */
end_comment

begin_function
name|int
name|openp
parameter_list|(
name|path
parameter_list|,
name|try_cwd_first
parameter_list|,
name|string
parameter_list|,
name|mode
parameter_list|,
name|prot
parameter_list|,
name|filename_opened
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|try_cwd_first
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename_opened
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|alloclen
decl_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|mode
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|try_cwd_first
operator|||
name|SLASH_P
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|filename
operator|=
name|string
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SLASH_P
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* ./foo => foo */
while|while
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|SLASH_P
argument_list|(
name|string
index|[
literal|1
index|]
argument_list|)
condition|)
name|string
operator|+=
literal|2
expr_stmt|;
name|alloclen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
name|p
condition|;
name|p
operator|=
name|p1
condition|?
name|p1
operator|+
literal|1
else|:
literal|0
control|)
block|{
name|p1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|p
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|len
operator|=
name|p1
operator|-
name|p
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'w'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
block|{
comment|/* Name is $cwd -- insert current directory name instead.  */
name|int
name|newlen
decl_stmt|;
comment|/* First, realloc the filename buffer if too short. */
name|len
operator|=
name|strlen
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|len
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|alloclen
condition|)
block|{
name|alloclen
operator|=
name|newlen
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|filename
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal file name in path -- just use it.  */
name|strncpy
argument_list|(
name|filename
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove trailing slashes */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|SLASH_P
argument_list|(
name|filename
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|filename
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|filename
operator|+
name|len
argument_list|,
name|SLASH_STRING
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
break|break;
block|}
name|done
label|:
if|if
condition|(
name|filename_opened
condition|)
block|{
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
operator|*
name|filename_opened
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ROOTED_P
argument_list|(
name|filename
argument_list|)
condition|)
operator|*
name|filename_opened
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Beware the // my son, the Emacs barfs, the botch that catch... */
operator|*
name|filename_opened
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|SLASH_CHAR
operator|==
name|current_directory
index|[
name|strlen
argument_list|(
name|current_directory
argument_list|)
operator|-
literal|1
index|]
condition|?
literal|""
else|:
name|SLASH_STRING
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MPW
comment|/* This is a debugging hack that can go away when all combinations      of Mac and Unix names are handled reasonably.  */
block|{
specifier|extern
name|int
name|debug_openp
decl_stmt|;
if|if
condition|(
name|debug_openp
condition|)
block|{
name|printf
argument_list|(
literal|"openp on %s, path %s mode %d prot %d\n  returned %d"
argument_list|,
name|string
argument_list|,
name|path
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|filename_opened
condition|)
name|printf
argument_list|(
literal|" (filename is %s)"
argument_list|,
operator|*
name|filename_opened
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MPW */
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* This is essentially a convenience, for clients that want the behaviour    of openp, using source_path, but that really don't want the file to be    opened but want instead just to know what the full pathname is (as    qualified against source_path).     The current working directory is searched first.     If the file was found, this function returns 1, and FULL_PATHNAME is    set to the fully-qualified pathname.     Else, this functions returns 0, and FULL_PATHNAME is set to NULL.    */
end_comment

begin_function
name|int
name|source_full_path_of
parameter_list|(
name|filename
parameter_list|,
name|full_pathname
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
modifier|*
name|full_pathname
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|full_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
operator|*
name|full_pathname
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a source file given a symtab S.  Returns a file descriptor or    negative number for error.  */
end_comment

begin_function
name|int
name|open_source_file
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|path
init|=
name|source_path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Quick way out if we already know its full name */
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
block|{
name|result
operator|=
name|open
argument_list|(
name|s
operator|->
name|fullname
argument_list|,
name|OPEN_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
return|return
name|result
return|;
comment|/* Didn't work -- free old one, try again. */
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|dirname
operator|!=
name|NULL
condition|)
block|{
comment|/* Replace a path entry of  $cdir  with the compilation directory name */
define|#
directive|define
name|cdir_len
value|5
comment|/* We cast strstr's result in case an ANSIhole has made it const, 	 which produces a "required warning" when assigned to a nonconst. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strstr
argument_list|(
name|source_path
argument_list|,
literal|"$cdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|==
name|path
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
name|DIRNAME_SEPARATOR
operator|)
operator|&&
operator|(
name|p
index|[
name|cdir_len
index|]
operator|==
name|DIRNAME_SEPARATOR
operator|||
name|p
index|[
name|cdir_len
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|source_path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|s
operator|->
name|dirname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|source_path
expr_stmt|;
name|strncpy
argument_list|(
name|path
argument_list|,
name|source_path
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Before $cdir */
name|strcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
comment|/* new stuff */
name|strcat
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|source_path
operator|+
name|len
operator|+
name|cdir_len
argument_list|)
expr_stmt|;
comment|/* After $cdir */
block|}
block|}
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|OPEN_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* Didn't work.  Try using just the basename. */
name|p
operator|=
name|basename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|s
operator|->
name|filename
condition|)
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|OPEN_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MPW
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* Didn't work.  Try using just the MPW basename. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mpw_basename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|s
operator|->
name|filename
condition|)
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|OPEN_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* Didn't work.  Try using the mixed Unix/MPW basename. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mpw_mixed_basename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|s
operator|->
name|filename
condition|)
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|OPEN_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MPW */
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
block|{
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|mstrsave
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the path to the source file associated with symtab.  Returns NULL    if no symtab.  */
end_comment

begin_function
name|char
modifier|*
name|symtab_to_filename
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
comment|/* If we've seen the file before, just return fullname. */
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
return|return
name|s
operator|->
name|fullname
return|;
comment|/* Try opening the file to setup fullname */
name|fd
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|s
operator|->
name|filename
return|;
comment|/* File not found.  Just use short name */
comment|/* Found the file.  Cleanup and return the full name */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|fullname
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and initialize the table S->line_charpos that records    the positions of the lines in the source file, which is assumed    to be open on descriptor DESC.    All set S->nlines to the number of such lines.  */
end_comment

begin_function
name|void
name|find_source_lines
parameter_list|(
name|s
parameter_list|,
name|desc
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|lines_allocated
init|=
literal|1000
decl_stmt|;
name|int
modifier|*
name|line_charpos
decl_stmt|;
name|long
name|mtime
init|=
literal|0
decl_stmt|;
name|int
name|size
decl_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmmalloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|lines_allocated
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|desc
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|objfile
operator|&&
name|s
operator|->
name|objfile
operator|->
name|obfd
condition|)
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exec_bfd
condition|)
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|&&
name|mtime
operator|<
name|st
operator|.
name|st_mtime
condition|)
block|{
if|if
condition|(
name|tui_version
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Source file is more recent than executable.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LSEEK_NOT_LINEAR
block|{
name|char
name|c
decl_stmt|;
comment|/* Have to read it byte by byte to find out where the chars live */
name|line_charpos
index|[
literal|0
index|]
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|myread
argument_list|(
name|desc
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
comment|/* lseek linear.  */
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
comment|/* st_size might be a large type, but we only support source files whose         size fits in an int.  */
name|size
operator|=
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
comment|/* Use malloc, not alloca, because this may be pretty large, and we may        run into various kinds of limits on stack size.  */
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Reassign `size' to result of read for systems where \r\n -> \n.  */
name|size
operator|=
name|myread
argument_list|(
name|desc
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|end
operator|=
name|data
operator|+
name|size
expr_stmt|;
name|p
operator|=
name|data
expr_stmt|;
name|line_charpos
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
comment|/* A newline at the end does not start a new line.  */
operator|&&
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|p
operator|-
name|data
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* lseek linear.  */
name|s
operator|->
name|nlines
operator|=
name|nlines
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
name|nlines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the character position of a line LINE in symtab S.    Return 0 if anything is invalid.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
unit|int source_line_charpos (s, line)      struct symtab *s;      int line; {   if (!s) return 0;   if (!s->line_charpos || line<= 0) return 0;   if (line> s->nlines)     line = s->nlines;   return s->line_charpos[line - 1]; }
comment|/* Return the line number of character position POS in symtab S.  */
end_comment

begin_comment
unit|int source_charpos_line (s, chr)     register struct symtab *s;     register int chr; {   register int line = 0;   register int *lnp;        if (s == 0 || s->line_charpos == 0) return 0;   lnp = s->line_charpos;
comment|/* Files are usually short, so sequential search is Ok */
end_comment

begin_endif
unit|while (line< s->nlines&& *lnp<= chr)     {       line++;       lnp++;     }   if (line>= s->nlines)     line = s->nlines;   return line; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get full pathname and line number positions for a symtab.    Return nonzero if line numbers may have changed.    Set *FULLNAME to actual name of the file as found by `openp',    or to 0 if the file is not found.  */
end_comment

begin_function
specifier|static
name|int
name|get_filename_and_charpos
parameter_list|(
name|s
parameter_list|,
name|fullname
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|fullname
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|,
name|linenums_changed
init|=
literal|0
decl_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|linenums_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|linenums_changed
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|linenums_changed
return|;
block|}
end_function

begin_comment
comment|/* Print text describing the full name of the source file S    and the line number LINE and its corresponding character position.    The text starts with two Ctrl-z so that the Emacs-GDB interface    can easily find it.     MID_STATEMENT is nonzero if the PC is not at the beginning of that line.     Return 1 if successful, 0 if could not find the file.  */
end_comment

begin_function
name|int
name|identify_source_line
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|mid_statement
parameter_list|,
name|pc
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|mid_statement
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|get_filename_and_charpos
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
comment|/* Don't index off the end of the line_charpos array.  */
return|return
literal|0
return|;
name|annotate_source
argument_list|(
name|s
operator|->
name|fullname
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
name|mid_statement
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|last_line_listed
operator|=
name|line
expr_stmt|;
name|current_source_symtab
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print source lines from the file of symtab S,    starting with line number LINE and stopping before line number STOPLINE. */
end_comment

begin_function
specifier|static
name|void
name|print_source_lines_base
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|stopline
parameter_list|,
name|noerror
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|,
name|stopline
decl_stmt|;
name|int
name|noerror
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|nlines
init|=
name|stopline
operator|-
name|line
decl_stmt|;
comment|/* Regardless of whether we can open the file, set current_source_symtab. */
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
comment|/* Only prints "No such file or directory" once */
if|if
condition|(
operator|(
name|s
operator|!=
name|last_source_visited
operator|)
operator|||
operator|(
operator|!
name|last_source_error
operator|)
condition|)
block|{
name|last_source_visited
operator|=
name|s
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|=
name|last_source_error
expr_stmt|;
name|noerror
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|last_source_error
operator|=
name|desc
expr_stmt|;
if|if
condition|(
operator|!
name|noerror
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|filename
argument_list|)
operator|+
literal|100
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d\t%s"
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%d\tin %s\n"
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|last_source_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Line number %d out of range; %s has %d lines."
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|s
operator|->
name|nlines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
name|FDOPEN_MODE
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|last_line_listed
operator|=
name|current_source_line
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t"
argument_list|,
name|current_source_line
operator|++
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
name|printf_filtered
argument_list|(
literal|"^%c"
argument_list|,
name|c
operator|+
literal|0100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|printf_filtered
argument_list|(
literal|"^?"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRLF_SOURCE_FILES
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* Just skip \r characters.  */
block|}
endif|#
directive|endif
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Show source lines from the file of symtab S, starting with line    number LINE and stopping before line number STOPLINE.  If this is the    not the command line version, then the source is shown in the source    window otherwise it is simply printed */
end_comment

begin_function
name|void
name|print_source_lines
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|stopline
parameter_list|,
name|noerror
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|,
name|stopline
decl_stmt|,
name|noerror
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
operator|!
name|tui_version
operator|||
name|m_winPtrIsNull
argument_list|(
name|srcWin
argument_list|)
operator|||
operator|!
name|srcWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
name|print_source_lines_base
argument_list|(
name|s
argument_list|,
name|line
argument_list|,
name|stopline
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
else|else
block|{
name|TuiGenWinInfoPtr
name|locator
init|=
name|locatorWinInfoPtr
argument_list|()
decl_stmt|;
specifier|extern
name|void
name|tui_vAddWinToLayout
name|PARAMS
argument_list|(
operator|(
name|va_list
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|tui_vUpdateSourceWindowsWithLine
name|PARAMS
argument_list|(
operator|(
name|va_list
operator|)
argument_list|)
decl_stmt|;
comment|/* Regardless of whether we can open the file,        set current_source_symtab. */
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
comment|/* make sure that the source window is displayed */
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vAddWinToLayout
argument_list|,
name|SRC_WIN
argument_list|)
expr_stmt|;
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vUpdateSourceWindowsWithLine
argument_list|,
name|s
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vUpdateLocatorFilename
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|print_source_lines_base
argument_list|(
name|s
argument_list|,
name|line
argument_list|,
name|stopline
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a list of files and line numbers which a user may choose from   in order to list a function which was specified ambiguously (as with   `list classname::overloadedfuncname', for example).  The vector in   SALS provides the filenames and line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|ambiguous_line_spec
parameter_list|(
name|sals
parameter_list|)
name|struct
name|symtabs_and_lines
modifier|*
name|sals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|printf_filtered
argument_list|(
literal|"file: \"%s\", line number: %d\n"
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|,
name|sals_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|,
name|sal_end
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|no_end
init|=
literal|1
decl_stmt|;
name|int
name|dummy_end
init|=
literal|0
decl_stmt|;
name|int
name|dummy_beg
init|=
literal|0
decl_stmt|;
name|int
name|linenum_beg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
comment|/* Pull in a current source symtab if necessary */
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
operator|&&
operator|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* "l" or "l +" lists next ten lines.  */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"+"
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|,
name|current_source_line
operator|+
name|lines_to_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* "l -" lists previous ten lines, the ones before the ten just listed.  */
if|if
condition|(
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|max
argument_list|(
name|first_line_listed
operator|-
name|lines_to_list
argument_list|,
literal|1
argument_list|)
argument_list|,
name|first_line_listed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now if there is only one argument, decode it in SAL      and set NO_END.      If there are two arguments, decode them in SAL and SAL_END      and clear NO_END; however, if one of the arguments is blank,      set DUMMY_BEG or DUMMY_END to record that fact.  */
name|arg1
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
name|dummy_beg
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
comment|/* Record whether the BEG arg is all digits.  */
for|for
control|(
name|p
operator|=
name|arg
init|;
name|p
operator|!=
name|arg1
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|linenum_beg
operator|=
operator|(
name|p
operator|==
name|arg1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
block|{
name|no_end
operator|=
literal|0
expr_stmt|;
name|arg1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|0
condition|)
name|dummy_end
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dummy_beg
condition|)
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals_end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal_end
operator|=
name|sals_end
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|arg1
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_end
operator|&&
operator|!
name|dummy_beg
operator|&&
operator|!
name|dummy_end
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|sal_end
operator|.
name|symtab
condition|)
name|error
argument_list|(
literal|"Specified start and end are in different files."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|dummy_end
condition|)
name|error
argument_list|(
literal|"Two empty args do not say what lines to list."
argument_list|)
expr_stmt|;
comment|/* if line was specified by address,      first print exactly which line, and which file.      In this case, sal.symtab == 0 means address is outside      of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
comment|/* FIXME-32x64--assumes sal.pc fits in long.  */
name|error
argument_list|(
literal|"No source file for address %s."
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|sal
operator|.
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|print_address_numeric
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is in "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" (%s:%d).\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_address_numeric
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at %s:%d.\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If line was not specified by just a line number,      and it does not imply a symtab, it must be an undebuggable symbol      which means no source code.  */
if|if
condition|(
operator|!
name|linenum_beg
operator|&&
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* If this command is repeated with RET,      turn it into the no-arg variant.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|sal_end
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
condition|)
name|print_source_lines
argument_list|(
name|sal_end
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal_end
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal_end
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|no_end
condition|)
if|if
condition|(
name|lines_to_list
operator|%
literal|2
operator|==
literal|0
condition|)
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|/
literal|2
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal
operator|.
name|line
operator|+
operator|(
name|lines_to_list
operator|/
literal|2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* If lines_to_list is odd, then we round down in        * one of the lines_to_list/2 computations, round up in        * the other, so the total window size around the specified        * line comes out right.        */
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|/
literal|2
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal
operator|.
name|line
operator|+
operator|(
operator|(
literal|1
operator|+
name|lines_to_list
operator|)
operator|/
literal|2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|(
name|dummy_end
condition|?
name|sal
operator|.
name|line
operator|+
name|lines_to_list
else|:
name|sal_end
operator|.
name|line
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print info on range of pc's in a specified line.  */
end_comment

begin_function
specifier|static
name|void
name|line_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|end_pc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|sal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|last_line_listed
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|=
name|decode_line_spec_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
comment|/* C++  More than one line may have been specified, as when the user      specifies an overloaded function name. Print info on them all. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No line number information available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
literal|0
condition|)
block|{
comment|/* This is useful for "info line *0x7f34".  If we can't tell the 		 user about a source line, at least let them have the symbolic 		 address.  */
name|printf_filtered
argument_list|(
literal|" for address "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_pc
operator|==
name|end_pc
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\""
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at address "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|start_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" but contains no code.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\""
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" starts at address "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|start_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" and ends at "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|end_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
comment|/* x/i should display this line's code.  */
name|set_next_address
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
comment|/* Repeating "info line" should do the following line.  */
name|last_line_listed
operator|=
name|sal
operator|.
name|line
operator|+
literal|1
expr_stmt|;
comment|/* If this is the only line, show the source code.  If it could 	     not find the file, don't do anything special.  */
if|if
condition|(
name|annotation_level
operator|&&
name|sals
operator|.
name|nelts
operator|==
literal|1
condition|)
name|identify_source_line
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
literal|0
argument_list|,
name|start_pc
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Is there any case in which we get here, and have an address 	   which the user would want to see?  If we have debugging symbols 	   and no line numbers?  */
name|printf_filtered
argument_list|(
literal|"Line number %d is out of range for \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands to search the source file for a regexp.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|forward_search_command
parameter_list|(
name|regex
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regex
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/*    ** If this is the TUI, search from the first line displayed in    ** the source window, otherwise, search from last_line_listed+1    ** in current_source_symtab    */
if|if
condition|(
operator|!
name|tui_version
condition|)
name|line
operator|=
name|last_line_listed
expr_stmt|;
else|else
block|{
if|if
condition|(
name|srcWin
operator|->
name|generic
operator|.
name|isVisible
operator|&&
name|srcWin
operator|->
name|generic
operator|.
name|contentSize
operator|>
literal|0
condition|)
name|line
operator|=
operator|(
operator|(
name|TuiWinContent
operator|)
name|srcWin
operator|->
name|generic
operator|.
name|content
operator|)
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"No source displayed.\nExpression not found.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|line
operator|++
expr_stmt|;
else|#
directive|else
name|line
operator|=
name|last_line_listed
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|current_source_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
name|FDOPEN_MODE
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|cursize
decl_stmt|,
name|newsize
decl_stmt|;
name|cursize
operator|=
literal|256
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|cursize
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|buf
operator|==
name|cursize
condition|)
block|{
name|newsize
operator|=
name|cursize
operator|+
name|cursize
operator|/
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|cursize
expr_stmt|;
name|cursize
operator|=
name|newsize
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|/* we now have a source line in buf, null terminate and match */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_version
condition|)
name|print_source_lines_base
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|++
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|reverse_search_command
parameter_list|(
name|regex
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regex
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/*   ** If this is the TUI, search from the first line displayed in   ** the source window, otherwise, search from last_line_listed-1   ** in current_source_symtab   */
if|if
condition|(
operator|!
name|tui_version
condition|)
name|line
operator|=
name|last_line_listed
expr_stmt|;
else|else
block|{
if|if
condition|(
name|srcWin
operator|->
name|generic
operator|.
name|isVisible
operator|&&
name|srcWin
operator|->
name|generic
operator|.
name|contentSize
operator|>
literal|0
condition|)
name|line
operator|=
operator|(
operator|(
name|TuiWinContent
operator|)
name|srcWin
operator|->
name|generic
operator|.
name|content
operator|)
index|[
literal|0
index|]
operator|->
name|whichElement
operator|.
name|source
operator|.
name|lineOrAddr
operator|.
name|lineNo
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"No source displayed.\nExpression not found.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|line
operator|--
expr_stmt|;
else|#
directive|else
name|line
operator|=
name|last_line_listed
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|current_source_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
name|FDOPEN_MODE
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|>
literal|1
condition|)
block|{
comment|/* FIXME!!!  We walk right off the end of buf if we get a long line!!! */
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Should be reasonable??? */
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|/* We now have a source line in buf; null terminate and match.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|tui_version
condition|)
name|print_source_lines_base
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|--
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|stream
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_source
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
comment|/* The intention is to use POSIX Basic Regular Expressions.      Always use the GNU regex routine for consistency across all hosts.      Our current GNU regex.c does not have all the POSIX features, so this is      just an approximation.  */
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"directory"
argument_list|,
name|class_files
argument_list|,
name|directory_command
argument_list|,
literal|"Add directory DIR to beginning of search path for source files.\n\ Forget cached info on source file locations and line positions.\n\ DIR can also be $cwd for the current working directory, or $cdir for the\n\ directory in which the source file was compiled into object code.\n\ With no argument, reset the search path to $cdir:$cwd, the default."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com_alias
argument_list|(
literal|"use"
argument_list|,
literal|"directory"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_cmd
argument_list|(
literal|"directories"
argument_list|,
name|no_class
argument_list|,
name|show_directories
argument_list|,
literal|"Current search path for finding source files.\n\ $cwd in the path means the current working directory.\n\ $cdir in the path means the compilation directory of the source file."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"D"
argument_list|,
literal|"directory"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"ld"
argument_list|,
name|no_class
argument_list|,
name|show_directories
argument_list|,
literal|"Current search path for finding source files.\n\ $cwd in the path means the current working directory.\n\ $cdir in the path means the compilation directory of the source file."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
name|add_info
argument_list|(
literal|"source"
argument_list|,
name|source_info
argument_list|,
literal|"Information about the current source file."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"line"
argument_list|,
name|line_info
argument_list|,
name|concat
argument_list|(
literal|"Core addresses of the code for a source line.\n\ Line can be specified as\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\ "
argument_list|,
literal|"\ Default is to describe the last source line that was listed.\n\n\ This sets the default address for \"x\" to the line's first instruction\n\ so that \"x/i\" suffices to start examining the machine code.\n\ The address is also stored as the value of \"$_\"."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
name|forward_search_command
argument_list|,
literal|"Search for regular expression (see regex(3)) from last line listed.\n\ The matching line number is also stored as the value of \"$_\"."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"search"
argument_list|,
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"reverse-search"
argument_list|,
name|class_files
argument_list|,
name|reverse_search_command
argument_list|,
literal|"Search backward for regular expression (see regex(3)) from last line listed.\n\ The matching line number is also stored as the value of \"$_\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"/"
argument_list|,
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"?"
argument_list|,
literal|"reverse-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|add_com
argument_list|(
literal|"list"
argument_list|,
name|class_files
argument_list|,
name|list_command
argument_list|,
name|concat
argument_list|(
literal|"List specified function or line.\n\ With no argument, lists ten more lines after or around previous listing.\n\ \"list -\" lists the ten lines before a previous ten-line listing.\n\ One argument specifies a line, and ten lines are listed around that line.\n\ Two arguments with comma between specify starting and ending lines to list.\n\ "
argument_list|,
literal|"\ Lines can be specified in these ways:\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to list around the line containing that address.\n\ With two args if one is empty it stands for ten lines away from the other arg."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"l"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|add_com_alias
argument_list|(
literal|"v"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com_alias
argument_list|(
literal|"file"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"listsize"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lines_to_list
argument_list|,
literal|"Set number of source lines gdb will list by default."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

